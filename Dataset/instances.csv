index,project,body,methodName,relativePath,absolutePath,javaDoc,spanMethod,coverage,tokensPerMethod,tokensFirstLine,javaDocFirstSentence,perturbed_eval_1,pegasusPerturbed,pegagusPerturbedEntropy,pivotingPerturbed
1,cdk,"static AtomTypePattern[] loadPatterns(InputStream smaIn) throws IOException{
    List<AtomTypePattern> matchers = new ArrayList<AtomTypePattern>();
    BufferedReader br = new BufferedReader(new InputStreamReader(smaIn));
    String line = null;
    while ((line = br.readLine()) != null) {
        if (skipLine(line))
            continue;
        String[] cols = line.split("" "");
        String sma = cols[0];
        String symb = cols[1];
        try {
            matchers.add(new AtomTypePattern(SmartsPattern.create(sma).setPrepare(false), symb));
        } catch (IllegalArgumentException ex) {
            throw new IOException(ex);
        }
    }
    return matchers.toArray(new AtomTypePattern[matchers.size()]);
}",loadPatterns,org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,"/**
     * Internal - load the SMARTS patterns for each atom type from MMFFSYMB.sma.
     *
     * @param smaIn input stream of MMFFSYMB.sma
     * @return array of patterns
     * @throws IOException
     */",215-241,"('loadPatterns', {'INSTRUCTION': {'covered': 62, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",154.0,13.0,Internal - load the SMARTS patterns for each atom type from MMFFSYMB., Internal - for each type of atom from MMFFSYMB.sma loads the SMARTS models.,Load the patterns for each atom type from MMFFSYMB.,0.393088244380532,  Internal - load SMARTS models for each type of atom from MMFFSYMB.
3,dcache,"private static String toGroupName(String attribute){
    int pos = attribute.indexOf(';');
    if (pos > -1) {
        attribute = attribute.substring(0, pos);
    }
    return attribute.replace(""X"", ""XX"").replace(""."", ""X"");
}",toGroupName,org/dcache/services/billing/text/BillingParserBuilder.java,/modules/dcache/src/main/java/org/dcache/services/billing/text/BillingParserBuilder.java,"/**
     * Translates a attribute name into a name suitable for a named capturing group.
     */",252-261,"('toGroupName', {'INSTRUCTION': {'covered': 15, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",57.0,14.0,Translates a attribute name into a name suitable for a named capturing group.," Given an attribute name as input, it translates an attribute name into a name suitable  for a named capturing group.",A name is translated into a name suitable for a group.,0.0938992682120705,  Translates an attribute name into a name that is appropriate for a named capture group.
4,matsim-libs," void revisitNode(final Node n, final DijkstraNodeData data, final RouterPriorityQueue<Node> pendingNodes, final double time, final double cost, final Link outLink){
    pendingNodes.remove(n);
    data.visit(outLink, cost, time, getIterationId());
    pendingNodes.add(n, getPriority(data));
}",revisitNode,org/matsim/pt/router/TransitLeastCostPathTree.java,/matsim/src/main/java/org/matsim/pt/router/TransitLeastCostPathTree.java,"/**
	 * Changes the position of the given Node n in the pendingNodes queue and
	 * updates its time and cost information.
	 *
	 * @param n
	 *            The Node that is revisited.
	 * @param data
	 *            The data for n.
	 * @param pendingNodes
	 *            The nodes visited and not processed yet.
	 * @param time
	 *            The time of the visit of n.
	 * @param cost
	 *            The accumulated cost at the time of the visit of n.
	 * @param outLink
	 *            The link from which we came visiting n.
	 */",482-506,"('revisitNode', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,20.0,Changes the position of the given Node n in the pendingNodes queue and  updates its time and cost information., Updates time and cost information as node node location changes.   The parameter outLink is the link through which we came to visit n.,The given Node n is in the pendingNodes queue and can be changed.,1.1552558115937,  Changes the position of the given node n in the pendingNodes queue and updates its time and cost information.
5,cdk,"private static int[] insert(int v, int[] vs){
    final int n = vs.length;
    final int[] ws = Arrays.copyOf(vs, n + 1);
    ws[n] = v;
    for (int i = n; i > 0 && ws[i] < ws[i - 1]; i--) {
        int tmp = ws[i];
        ws[i] = ws[i - 1];
        ws[i - 1] = tmp;
    }
    return ws;
}",insert,org/openscience/cdk/smiles/BeamToCDK.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/BeamToCDK.java,"/**
     * Insert the vertex 'v' into sorted position in the array 'vs'.
     *
     * @param v  a vertex (int id)
     * @param vs array of vertices (int ids)
     * @return array with 'u' inserted in sorted order
     */",581-602,"('insert', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",109.0,15.0,Insert the vertex 'v' into sorted position in the array 'vs'., Starting from the array 'vs' insert the vertex 'v' in ordinal position.,The array 'vs' has the 'v' inserted into it.,1.07879688690664,  Insert the vertex 'v' in the sorted position in the 'vs' table.
6,acs-aem-commons,"private void createOrUpdateNodesForJsonObject(final ResourceResolver remoteAssetsResolver, final String key, final Resource parentResource) throws IOException, RepositoryException{
    if (PROTECTED_NODES.contains(key)) {
        return;
    }
    String objectPath = String.format(""%s/%s"", parentResource.getPath(), key);
    JsonObject jsonObjectWithChildren = getJsonFromUri(objectPath);
    String resourcePrimaryType = jsonObjectWithChildren.getAsJsonPrimitive(JcrConstants.JCR_PRIMARYTYPE).getAsString();
    Resource resource = getOrCreateNode(remoteAssetsResolver, objectPath, resourcePrimaryType);
    createOrUpdateNodes(remoteAssetsResolver, jsonObjectWithChildren, resource);
    ValueMap resourceProperties = resource.adaptTo(ModifiableValueMap.class);
    if (DamConstants.NT_DAM_ASSET.equals(parentResource.getValueMap().get(JcrConstants.JCR_PRIMARYTYPE, String.class)) && DamConstants.NT_DAM_ASSETCONTENT.equals(resourceProperties.get(JcrConstants.JCR_PRIMARYTYPE, String.class))) {
        resourceProperties.put(RemoteAssets.IS_REMOTE_ASSET, true);
        LOG.trace(""Property '{}' added for resource '{}'."", RemoteAssets.IS_REMOTE_ASSET, resource.getPath());
        this.saveRefreshCount++;
        if (this.saveRefreshCount == this.remoteAssetsConfig.getSaveInterval()) {
            this.saveRefreshCount = 0;
            remoteAssetsResolver.commit();
            remoteAssetsResolver.refresh();
            LOG.info(""Executed incremental save of node sync."");
        }
    }
}",createOrUpdateNodesForJsonObject,com/adobe/acs/commons/remoteassets/impl/RemoteAssetsNodeSyncImpl.java,/bundle/src/main/java/com/adobe/acs/commons/remoteassets/impl/RemoteAssetsNodeSyncImpl.java,"/**
     * Handler for when a JSON element is an Object, representing a resource.
     *
     * @param key String
     * @param parentResource Resource
     * @throws IOException exception
     * @throws RepositoryException exception
     */",208-242,"('createOrUpdateNodesForJsonObject', {'INSTRUCTION': {'covered': 95, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",232.0,14.0,"Handler for when a JSON element is an Object, representing a resource.", Handler used when a resource is represented by an Object that is a JSON element.   ,"When a resource is represented by an object, the handler is needed.",0.19668287806293,"  Handler when a JSON element is an object, representing a resource."
7,twilio-java,"public static Workflow fromJson(String json) throws IOException{
    ObjectMapper mapper = new ObjectMapper();
    return mapper.readValue(json, Workflow.class);
}",fromJson,com/twilio/taskrouter/Workflow.java,/src/main/java/com/twilio/taskrouter/Workflow.java,"/**
     * Converts a JSON workflow configuration to a workflow object.
     *
     * @param json JSON for workflow
     * @return a workflow rule target object
     * @throws IOException if unable to create object
     */",55-65,"('fromJson', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,10.0,Converts a JSON workflow configuration to a workflow object.,Converts a JSON workflow configuration to a workflow object.,A configuration is converted to a object.,0.170327249771777,  Converts a JSON workflow configuration to a workflow object.
8,jeromq,"public long timeout(){
    if (tickets.isEmpty()) {
        return -1;
    }
    sortIfNeeded();
    Ticket first = tickets.get(0);
    return first.start - now() + first.delay;
}",timeout,org/zeromq/timer/ZTicket.java,/src/main/java/org/zeromq/timer/ZTicket.java,"/**
     * Returns the time in millisecond until the next ticket.
     * @return the time in millisecond until the next ticket.
     */",160-173,"('timeout', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,10.0,Returns the time in millisecond until the next ticket.,The time until the next ticket is returned in milliseconds. Return the time in millisecond until the next ticket.,The time is returned in a second.,0.274892268365893,  Returns the time in milliseconds to the next ticket.
9,weblogic-kubernetes-operator,"public void useKubernetesVersion(String version) throws IOException{
    KubernetesSchemaReference reference = KubernetesSchemaReference.create(version);
    URL cacheUrl = reference.getKubernetesSchemaCacheUrl();
    if (cacheUrl == null) {
        throw new IOException(""No schema cached for Kubernetes "" + version);
    }
    addExternalSchema(reference.getKubernetesSchemaUrl(), cacheUrl);
}",useKubernetesVersion,oracle/kubernetes/json/SchemaGenerator.java,/json-schema-generator/src/main/java/oracle/kubernetes/json/SchemaGenerator.java,"/**
   * Specifies the version of the Kubernetes schema to use.
   *
   * @param version a Kubernetes version string, such as ""1.9.0""
   * @throws IOException if no schema for that version is cached.
   */",97-111,"('useKubernetesVersion', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",58.0,10.0,Specifies the version of the Kubernetes schema to use.,"Show the version of the Kubernetes schema to be used. Indicate a  Kubernetes version string, for example ""1.8.0""  and return IOException if no schema exists in the cached for the given version.",The version of the Kubernetes schema that is used is specified.,0.311401150484418,  Specifies the version of the Kubernetes schema to use.
10,dcache,"public synchronized void addCacheEntry(CacheEntry entry) throws CacheException, InterruptedException{
    FileAttributes fileAttributes = entry.getFileAttributes();
    String storageClass = fileAttributes.getStorageClass();
    String hsmName = fileAttributes.getHsm().toLowerCase();
    String composedName = storageClass + ""@"" + hsmName;
    StorageClassInfo classInfo = _storageClasses.get(composedName);
    if (classInfo == null) {
        classInfo = new StorageClassInfo(_storageHandler, hsmName, storageClass);
        StorageClassInfo tmpInfo = _storageClasses.get(""*@"" + hsmName);
        if (tmpInfo != null) {
            classInfo.setExpiration(tmpInfo.getExpiration());
            classInfo.setPending(tmpInfo.getPending());
            classInfo.setMaxSize(tmpInfo.getMaxSize());
            classInfo.setOpen(tmpInfo.isOpen());
        }
        _storageClasses.put(composedName, classInfo);
    }
    classInfo.add(entry);
    _pnfsIds.put(entry.getPnfsId(), classInfo);
}",addCacheEntry,org/dcache/pool/classic/StorageClassContainer.java,/modules/dcache/src/main/java/org/dcache/pool/classic/StorageClassContainer.java,"/**
     * adds a CacheEntry to the list of HSM storage requests.
     *
     * @param entry
     */",157-190,"('addCacheEntry', {'INSTRUCTION': {'covered': 72, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",177.0,11.0,adds a CacheEntry to the list of HSM storage requests.,based on the storage requests HSM adds a ChacheEntry .,The list of storage requests has a cache entry added.,0.313729244562084,  Adds a CacheEntry to the list of HSM storage requests.
11,cdk,"private static int findPrefix(Trie trie, String string, int i, int best){
    if (trie == null)
        return best;
    if (trie.token != null)
        best = i;
    if (i == string.length())
        return best;
    final char c = norm(string.charAt(i));
    if (c > 128)
        return best;
    return findPrefix(trie.children[c], string, i + 1, best);
}",findPrefix,org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,"/**
     * Find the longest prefix from position (i) in this string that
     * is present in the trie symbol table.
     *
     * @param trie   trie node (start with root)
     * @param string string to find a prefix of
     * @param i      the position in the string
     * @param best   best score so far (-1 to start)
     * @return the length of the prefix
     */",404-425,"('findPrefix', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",95.0,21.0,Find the longest prefix from position (i) in this string that  is present in the trie symbol table.,"Find, within the trie symbol table, the longest prefix from position (i).  ",The trie symbol table has a string that is the longest from position i.,0.32955872235036,  Look for the longest prefix of position (i) in this string in the sort symbol table.
12,mybatis-3,"public static int hashCode(Object obj){
    if (obj == null) {
        // for consistency with Arrays#hashCode() and Objects#hashCode()
        return 0;
    }
    final Class<?> clazz = obj.getClass();
    if (!clazz.isArray()) {
        return obj.hashCode();
    }
    final Class<?> componentType = clazz.getComponentType();
    if (long.class.equals(componentType)) {
        return Arrays.hashCode((long[]) obj);
    } else if (int.class.equals(componentType)) {
        return Arrays.hashCode((int[]) obj);
    } else if (short.class.equals(componentType)) {
        return Arrays.hashCode((short[]) obj);
    } else if (char.class.equals(componentType)) {
        return Arrays.hashCode((char[]) obj);
    } else if (byte.class.equals(componentType)) {
        return Arrays.hashCode((byte[]) obj);
    } else if (boolean.class.equals(componentType)) {
        return Arrays.hashCode((boolean[]) obj);
    } else if (float.class.equals(componentType)) {
        return Arrays.hashCode((float[]) obj);
    } else if (double.class.equals(componentType)) {
        return Arrays.hashCode((double[]) obj);
    } else {
        return Arrays.hashCode((Object[]) obj);
    }
}",hashCode,org/apache/ibatis/reflection/ArrayUtil.java,/src/main/java/org/apache/ibatis/reflection/ArrayUtil.java,"/**
   * Returns a hash code for {@code obj}.
   *
   * @param obj
   *          The object to get a hash code for. May be an array or <code>null</code>.
   * @return A hash code of {@code obj} or 0 if {@code obj} is <code>null</code>
   */",25-61,"('hashCode', {'INSTRUCTION': {'covered': 84, 'missed': 0}, 'BRANCH': {'covered': 20, 'missed': 0}, 'LINE': {'covered': 23, 'missed': 0}, 'COMPLEXITY': {'covered': 11, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",296.0,11.0,Returns a hash code for {@code obj}.,Yields a hash code for {@code obj}. The meethod return A hash code of {@code obj} or 0 if {@code obj} is <code>null</code>,A code is returned for @code obj.,0.879059222536263,  Returns a hash code for {@code obj}.
13,cdk,"public void writeMolecule(IAtomContainer mol) throws IOException{
    matcher = SybylAtomTypeMatcher.getInstance(mol.getBuilder());
    try {
        logger.debug(""Writing header..."");
        if (mol.getTitle() != null) {
            writer.write(""#        Name: "" + mol.getTitle());
            writer.write('\n');
        }
        writer.write('\n');
        logger.debug(""Writing molecule block..."");
        writer.write(""@<TRIPOS>MOLECULE"");
        writer.write('\n');
        if (mol.getID() == null) {
            writer.write(""CDKMolecule"");
        } else {
            writer.write(mol.getID());
        }
        writer.write('\n');
        writer.write(mol.getAtomCount() + "" "" + mol.getBondCount());
        writer.write('\n');
        writer.write(""SMALL"");
        writer.write('\n');
        writer.write(""NO CHARGES"");
        writer.write('\n');
        logger.debug(""Writing atom block..."");
        writer.write(""@<TRIPOS>ATOM"");
        writer.write('\n');
        for (int i = 0; i < mol.getAtomCount(); i++) {
            IAtom atom = mol.getAtom(i);
            writer.write((i + 1) + "" "" + atom.getSymbol() + (mol.indexOf(atom) + 1) + "" "");
            if (atom.getPoint3d() != null) {
                writer.write(atom.getPoint3d().x + "" "");
                writer.write(atom.getPoint3d().y + "" "");
                writer.write(atom.getPoint3d().z + "" "");
            } else if (atom.getPoint2d() != null) {
                writer.write(atom.getPoint2d().x + "" "");
                writer.write(atom.getPoint2d().y + "" "");
                writer.write("" 0.000 "");
            } else {
                writer.write(""0.000 0.000 0.000 "");
            }
            IAtomType sybylType = null;
            try {
                sybylType = matcher.findMatchingAtomType(mol, atom);
            } catch (CDKException e) {
                e.printStackTrace();
            }
            if (sybylType != null) {
                writer.write(sybylType.getAtomTypeName());
            } else {
                writer.write(atom.getSymbol());
            }
            writer.write('\n');
        }
        logger.debug(""Writing bond block..."");
        writer.write(""@<TRIPOS>BOND"");
        writer.write('\n');
        int counter = 0;
        for (IBond bond : mol.bonds()) {
            String sybylBondOrder = ""-1"";
            if (bond.getOrder().equals(IBond.Order.SINGLE))
                sybylBondOrder = ""1"";
            else if (bond.getOrder().equals(IBond.Order.DOUBLE))
                sybylBondOrder = ""2"";
            else if (bond.getOrder().equals(IBond.Order.TRIPLE))
                sybylBondOrder = ""3"";
            if (bond.getFlag(CDKConstants.ISAROMATIC))
                sybylBondOrder = ""ar"";
            final IAtom bondAtom1 = bond.getBegin();
            final IAtom bondAtom2 = bond.getEnd();
            try {
                final IAtomType bondAtom1Type = matcher.findMatchingAtomType(mol, bondAtom1);
                final IAtomType bondAtom2Type = matcher.findMatchingAtomType(mol, bondAtom2);
                if (bondAtom1Type != null && bondAtom2Type != null && ((bondAtom1Type.getAtomTypeName().equals(""N.am"") && bondAtom2Type.getAtomTypeName().equals(""C.2"")) || (bondAtom2Type.getAtomTypeName().equals(""N.am"") && bondAtom1Type.getAtomTypeName().equals(""C.2"")))) {
                    sybylBondOrder = ""am"";
                }
            } catch (CDKException e) {
                e.printStackTrace();
            }
            writer.write((counter + 1) + "" "" + (mol.indexOf(bond.getBegin()) + 1) + "" "" + (mol.indexOf(bond.getEnd()) + 1) + "" "" + sybylBondOrder);
            writer.write('\n');
            counter++;
        }
    } catch (IOException e) {
        throw e;
    }
}",writeMolecule,org/openscience/cdk/io/Mol2Writer.java,/storage/io/src/main/java/org/openscience/cdk/io/Mol2Writer.java,"/**
     * Writes a single frame in XYZ format to the Writer.
     *
     * @param mol the Molecule to write
     * @throws java.io.IOException if there is an error during writing
     */",133-259,"('writeMolecule', {'INSTRUCTION': {'covered': 320, 'missed': 78}, 'BRANCH': {'covered': 16, 'missed': 18}, 'LINE': {'covered': 60, 'missed': 15}, 'COMPLEXITY': {'covered': 4, 'missed': 14}, 'METHOD': {'covered': 1, 'missed': 0}})",781.0,11.0,Writes a single frame in XYZ format to the Writer., Insert within the Writer a single frame in XYZ format.  ,A single frame is written in a format called the writer's format.,0.356403466457851,  Writes a single image in XYZ format in the writer.
14,cdk,"public boolean allHeavyAtomsPlaced(IAtomContainer ac){
    for (int i = 0; i < ac.getAtomCount(); i++) {
        if (isUnplacedHeavyAtom(ac.getAtom(i))) {
            return false;
        }
    }
    return true;
}",allHeavyAtomsPlaced,org/openscience/cdk/modeling/builder3d/AtomPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomPlacer3D.java,"/**
     *  True is all the atoms in the given AtomContainer have been placed.
     *
     * @param  ac  The AtomContainer to be searched
     * @return     True is all the atoms in the given AtomContainer have been placed
     */",604-617,"('allHeavyAtomsPlaced', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",49.0,13.0,True is all the atoms in the given AtomContainer have been placed., Returns True if all atoms related to the given AtomContainr have been placed.  ,The atoms in the container have been placed.,0.142141057600746,  True is that all the atoms of the given AtomContainer have been placed.
15,logstash-logback-encoder,"private boolean enqueue(Event event) throws ShutdownInProgressException, InterruptedException{
    if (this.disruptor.getRingBuffer().tryPublishEvent(this.eventTranslator, event)) {
        return true;
    }
    if (this.appendTimeout.getMilliseconds() == 0) {
        return false;
    }
    long deadline = Long.MAX_VALUE;
    if (this.appendTimeout.getMilliseconds() < 0) {
        lock.lockInterruptibly();
    } else {
        deadline = System.currentTimeMillis() + this.appendTimeout.getMilliseconds();
        if (!lock.tryLock(this.appendTimeout.getMilliseconds(), TimeUnit.MILLISECONDS)) {
            return false;
        }
    }
    long backoff = 1L;
    long backoffLimit = TimeUnit.MILLISECONDS.toNanos(this.appendRetryFrequency.getMilliseconds());
    try {
        do {
            if (!isStarted()) {
                throw new ShutdownInProgressException();
            }
            if (deadline <= System.currentTimeMillis()) {
                return false;
            }
            if (Thread.currentThread().isInterrupted()) {
                throw new InterruptedException();
            }
            LockSupport.parkNanos(backoff);
            backoff = Math.min(backoff * 2, backoffLimit);
        } while (!this.disruptor.getRingBuffer().tryPublishEvent(this.eventTranslator, event));
        return true;
    } finally {
        lock.unlock();
    }
}",enqueue,net/logstash/logback/appender/AsyncDisruptorAppender.java,/src/main/java/net/logstash/logback/appender/AsyncDisruptorAppender.java,"/**
     * Enqueue an event in the ring buffer, retrying if allowed by the configuration.
     * 
     * @param event the event to add to the ring buffer
     * @return {@code true} if the event is successfully enqueued, {@code false} if the event
     *         could not be added to the ring buffer.
     * @throws ShutdownInProgressException thrown when the appender is shutdown while retrying
     *         to enqueue the event
     * @throws InterruptedException thrown when the logging thread is interrupted while retrying
     */",534-600,"('enqueue', {'INSTRUCTION': {'covered': 93, 'missed': 6}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 21, 'missed': 2}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",257.0,15.0,"Enqueue an event in the ring buffer, retrying if allowed by the configuration.","  Enqueue an event in the ring buffer, if allowed by the configuration, retry.  The methon return {@code true} in case the event was successfully added, {@code false}   in case the event was not added to the ring buffer.    ","If allowed by the configuration, you can queue an event in the ring buffer.",0.215699618364069,"  String an event into the ring buffer, try again if the configuration allows it."
16,matsim-libs,"private static void prepareRNG(final Random rng){
    for (int i = 0; i < 100; i++) {
        rng.nextDouble();
    }
}",prepareRNG,org/matsim/core/gbl/MatsimRandom.java,/matsim/src/main/java/org/matsim/core/gbl/MatsimRandom.java,"/**
         * Draw some random numbers to better initialize the pseudo-random number generator.
         *
         * @param rng the random number generator to initialize.
         */",92-101,"('prepareRNG', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,12.0,Draw some random numbers to better initialize the pseudo-random number generator., In order to better initialize the pseudo-random number generator draw   some random numbers.,Draw some random numbers to make the generator work better.,0.0914113192820884,  Draw random numbers to better initialize the pseudo-random number generator.
17,cdk,"private String encode(int[] path){
    StringBuilder sb = new StringBuilder(path.length * 3);
    for (int i = 0, n = path.length - 1; i <= n; i++) {
        IAtom atom = container.getAtom(path[i]);
        sb.append(toAtomPattern(atom));
        if (i < n) {
            IBond bond = container.getBond(container.getAtom(path[i]), container.getAtom(path[i + 1]));
            sb.append(getBondSymbol(bond));
        }
    }
    return sb.toString();
}",encode,org/openscience/cdk/fingerprint/ShortestPathWalker.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/ShortestPathWalker.java,"/**
     * Encode the provided path of atoms to a string.
     *
     * @param path inclusive array of vertex indices
     * @return encoded path
     */",136-154,"('encode', {'INSTRUCTION': {'covered': 63, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",126.0,10.0,Encode the provided path of atoms to a string.,Starting with a string encodes a path of atoms.,The path of atoms can be found in the provided text.,0.861084792626924,  Encode the provided path of atoms to a string.
18,tablesaw,"public int mappedRowNumber(int rowNumber){
    if (isSorted()) {
        return sortOrder[rowNumber];
    } else if (hasSelection()) {
        return selection.get(rowNumber);
    }
    return rowNumber;
}",mappedRowNumber,tech/tablesaw/table/TableSlice.java,/core/src/main/java/tech/tablesaw/table/TableSlice.java,"/**
   * Maps the view row number to the row number on the underlying source table.
   *
   * @param rowNumber the row number in the view.
   * @return the matching row number in the underlying table.
   */",255-268,"('mappedRowNumber', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",43.0,15.0,Maps the view row number to the row number on the underlying source table.,"    Starting from the row of the source table, the corresponding row number     of the view is mapped.  ",The view row number is mapped to the underlying source table.,0.0680378417813278,  Maps the row number of the view to the row number of the underlying source table.
19,matsim-libs,"public static void addService(Carrier carrier, CarrierService carrierService){
    carrier.getServices().put(carrierService.getId(), carrierService);
}",addService,org/matsim/contrib/freight/carrier/CarrierUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/carrier/CarrierUtils.java,"/**
	 * Adds an {@link CarrierService} to the {@link Carrier}.
	 * @param carrier
	 * @param carrierService
	 */",36-43,"('addService', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,15.0,Adds an {@link CarrierService} to the {@link Carrier}.,Appends a {@link CarrierService} to the {@link Carrier}.         ,The @link Carrier is now an @link Carrier Service.,1.21415787076405,  Adds a {carrierservice @link} to the {@link Carrier}.
20,glowstone,"public boolean readCompoundList(@NonNls String key, Consumer<? super List<CompoundTag>> consumer){
    return readList(key, TagType.COMPOUND, consumer);
}",readCompoundList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to a list subtag if it is present and its contents are compound
     * tags. Processes the list as a single object; to process each tag separately, instead use
     * {@link #iterateCompoundList(String, Consumer)}.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */",558-570,"('readCompoundList', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,19.0,Applies the given function to a list subtag if it is present and its contents are compound  tags.," Given a list subtag if it is present and its content is composed of tags,    the function is applied.  To process each tag separately you can use    {@link #iterateCompoundList(String, Consumer)},    while tag processes the list as a single object   ","If the function is present and the contents are compound tags, apply it to a list subtag.",0.492552590037658,  Applies the given function to a list subtag if it is present and its contents are composed.
21,weblogic-kubernetes-operator,"public Watchable<V1ConfigMap> createConfigMapWatch(String namespace) throws ApiException{
    return FACTORY.createWatch(callParams, V1ConfigMap.class, new ListNamespacedConfigMapCall(namespace));
}",createConfigMapWatch,oracle/kubernetes/operator/builders/WatchBuilder.java,/operator/src/main/java/oracle/kubernetes/operator/builders/WatchBuilder.java,"/**
   * Creates a web hook object to track config map calls.
   *
   * @param namespace the namespace
   * @return the active web hook
   * @throws ApiException if there is an error on the call that sets up the web hook.
   */",118-130,"('createConfigMapWatch', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,11.0,Creates a web hook object to track config map calls., Given the configuration map to keep track of calls a web hook object is created.   The method returns the active web hook otherwise an ApiException if    there is an error in the call set by the web hook   ,A web hook object is created to track map calls.,0.447964995415663,  Creates a Web hook object to track configuration map calls.
23,cron-utils,"static Function<CronField, CronField> returnOnZeroExpression(final CronFieldName name){
    return field -> {
        final FieldConstraints constraints = FieldConstraintsBuilder.instance().forField(name).createConstraintsInstance();
        return new CronField(name, new On(new IntegerFieldValue(0)), constraints);
    };
}",returnOnZeroExpression,com/cronutils/mapper/CronMapper.java,/src/main/java/com/cronutils/mapper/CronMapper.java,"/**
     * Creates a Function that returns a On instance with zero value.
     *
     * @param name - Cron field name
     * @return new CronField -> CronField instance, never null
     */",238-250,"('returnOnZeroExpression', {'INSTRUCTION': {'covered': 3, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",59.0,12.0,Creates a Function that returns a On instance with zero value.,Lets you create a function that can return an instance of On with value zero      ,A function returns a On instance with zero value.,0.190230814868357,  Creates a function that returns an On instance with a null value.
24,matsim-libs,"public static double calculateWeightFromPoint(final Coordinate emissionSource, final Coordinate cellCentroid, double smoothingRadius){
    if (smoothingRadius <= 0)
        throw new IllegalArgumentException(""smoothing radius must be greater 0"");
    double dist = emissionSource.distance(cellCentroid);
    return Math.exp((-dist * dist) / (smoothingRadius * smoothingRadius));
}",calculateWeightFromPoint,org/matsim/contrib/analysis/spatial/SpatialInterpolation.java,/contribs/analysis/src/main/java/org/matsim/contrib/analysis/spatial/SpatialInterpolation.java,"/**
     * This uses an exponential distance weighting to calculate the impact of point based emissions onto the centroid of
     * a grid cell. The calculation is described in Kickhoefer's PhD thesis https://depositonce.tu-berlin.de/handle/11303/4386
     * in Appendix A.2
     *
     * @param emissionSource Centroid of the link
     * @param cellCentroid   Centroid of the impacted cell
     * @return weight factor by which the emission value should be multiplied to calculate the impact of the cell
     */",41-57,"('calculateWeightFromPoint', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,22.0,This uses an exponential distance weighting to calculate the impact of point based emissions onto the centroid of  a grid cell.,Exponential distance weighting is used to calculate the impact of  point emissions on the centroid of a grid cell.  You can find a description of the calculation in the dissertation by  Kickhoefer's PhD thesis https://depositonce.tu-berlin.de/handle/11303/4386 in Appendix A.2,The impact of point based emissions onto the centroid of a grid cell is calculated using an exponential distance weight.,0.230157454769525,  This uses exponential distance weighting to calculate the impact of point emissions on the centroid of a grid cell.
25,cdk,"private int parseMobileHydrogens(List<Integer> mobHydrAttachPositions, String inputInchi){
    int totalMobHydrCount = 0;
    String hydrogens = """";
    String inchi = inputInchi;
    if (inchi.indexOf(""/h"") != -1) {
        hydrogens = inchi.substring(inchi.indexOf(""/h"") + 2);
        if (hydrogens.indexOf('/') != -1) {
            hydrogens = hydrogens.substring(0, hydrogens.indexOf('/'));
        }
        String mobileHydrogens = hydrogens.substring(hydrogens.indexOf('('));
        Pattern mobileHydrPattern = Pattern.compile(""\\((.)*?\\)"");
        Matcher match = mobileHydrPattern.matcher(mobileHydrogens);
        while (match.find()) {
            String mobileHGroup = match.group();
            int mobHCount = 0;
            String head = mobileHGroup.substring(0, mobileHGroup.indexOf(',') + 1);
            if (head.contains(""H,""))
                head = head.replace(""H,"", ""H1,"");
            if (head.contains(""-,""))
                head = head.replace(""-,"", ""-1,"");
            head = head.substring(2);
            Pattern subPattern = Pattern.compile(""[0-9]*"");
            Matcher subMatch = subPattern.matcher(head);
            while (subMatch.find()) {
                if (!subMatch.group().equals("""")) {
                    mobHCount += Integer.valueOf(subMatch.group());
                }
            }
            totalMobHydrCount += mobHCount;
            mobileHGroup = mobileHGroup.substring(mobileHGroup.indexOf(',') + 1).replace("")"", """");
            StringTokenizer tokenizer = new StringTokenizer(mobileHGroup, "","");
            while (tokenizer.hasMoreTokens()) {
                Integer position = Integer.valueOf(tokenizer.nextToken());
                mobHydrAttachPositions.add(position);
            }
        }
    }
    LOGGER.debug(""#total mobile hydrogens: "", totalMobHydrCount);
    return totalMobHydrCount;
}",parseMobileHydrogens,org/openscience/cdk/tautomers/InChITautomerGenerator.java,/tool/tautomer/src/main/java/org/openscience/cdk/tautomers/InChITautomerGenerator.java,"/**
     * Parses mobile H group(s) in an InChI String.
     * <p>
     * Multiple InChI sequences of mobile hydrogens are joined into a single sequence (list),
     * see step 1 of algorithm in paper.
     * <br>
     * Mobile H group has syntax (H[n][-[m]],a1,a2[,a3[,a4...]])
     * Brackets [ ] surround optional terms.
     * <ul>
     *  <li>Term H[n] stands for 1 or, if the number n (n>1) is present, n mobile hydrogen atoms.</li>
     *  <li>Term [-[m]], if present, stands for 1 or, if the number m (m>1) is present, m mobile negative charges.</li>
     *  <li>a1,a2[,a3[,a4...]] are canonical numbers of atoms in the mobile H group.</li>
     *  <li>no two mobile H groups may have an atom (a canonical number) in common.</li>
     * </ul>
     * @param mobHydrAttachPositions list of positions where mobile H can attach
     * @param inputInchi InChI input
     * @return overall count of hydrogens to be dispersed over the positions
     */",344-408,"('parseMobileHydrogens', {'INSTRUCTION': {'covered': 140, 'missed': 12}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 31, 'missed': 1}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",357.0,12.0,Parses mobile H group(s) in an InChI String.,"Allows the analysis of  mobile H group(s) in an InChI String. multiple InChI sequences of mobile hydrogens can be combined into a  single sequence (list),  Step 1 of the algorithm reported in the paper.  Mobile H group has syntax (H[n][-[m]],a1,a2[,a3[,a4...]])  Brackets [ ] encircle optional terms.  Term H[n] stands for 1 or, if the number n (n>1) is present, n mobile hydrogen atoms. Term [-[m]], if present, stands for 1 or, if the number m (m>1) is present, m mobile negative charges. a1,a2[,a3[,a4...]] are canonical numbers of atoms in the mobile H group. no two mobile H groups may have an atom (a canonical number) in common.    The method returns the total count of hydrogens to be dispersed on the positions",Parses mobile H group in an InChI String.,0.433534509985365,  Analyzes the mobile H group(s) in an InChI string.
26,dcache,"private static void scanFields(Object obj, Map<List<String>, AcCommandExecutor> commands){
    for (Field field : obj.getClass().getFields()) {
        Iterator<String> i = Splitter.on('_').split(field.getName()).iterator();
        FieldType helpMode;
        String helpType = i.next();
        switch(helpType) {
            case ""hh"":
                helpMode = FieldType.HELP_HINT;
                break;
            case ""fh"":
                helpMode = FieldType.FULL_HELP;
                break;
            case ""acl"":
                helpMode = FieldType.ACL;
                break;
            default:
                continue;
        }
        if (!i.hasNext()) {
            continue;
        }
        List<String> name = Lists.newArrayList(i);
        AcCommandExecutor command = getCommandExecutor(obj, commands, name);
        switch(helpMode) {
            case FULL_HELP:
                command.setFullHelpField(field);
                break;
            case HELP_HINT:
                command.setHelpHintField(field);
                break;
            case ACL:
                command.setAclField(field);
                break;
        }
    }
}",scanFields,dmg/util/command/AcCommandScanner.java,/modules/cells/src/main/java/dmg/util/command/AcCommandScanner.java,"/**
     * Scan for help fields: fh_(= full help) or hh_(= help hint).
     */",30-71,"('scanFields', {'INSTRUCTION': {'covered': 74, 'missed': 2}, 'BRANCH': {'covered': 9, 'missed': 3}, 'LINE': {'covered': 21, 'missed': 2}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",199.0,19.0,Scan for help fields: fh_(= full help) or hh_(= help hint).,Allows you to scan for help fields: fh_(= full help) or hh_(= help hint).,Scan for help fields: fh_(full help) or hh_(help hint).,0.643584897892085,  Look for the help fields: fh_(= full help) or hh_(= help index).
27,egeria,"private Optional<EntityDetail> findSchemaAttributeEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, SCHEMA_ATTRIBUTE_TYPE_NAME);
}",findSchemaAttributeEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineSchemaAttributeHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineSchemaAttributeHandler.java,"/**
     * Find out if the SchemaAttribute object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",66-82,"('findSchemaAttributeEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,13.0,Find out if the SchemaAttribute object is already stored in the repository., It uses the fully qualified name to retrieve the entity. It allows you to find out if the  SchemaAttribute object is already stored in the repository.  ,"If the object is already in the repository, you should find it.",0.154956691436665,  Find out if the SchemaAttribute object is already stored in the repository.
28,soul,"public ShenyuAdminResult deletePluginHandles(@RequestBody @NotEmpty final List<@NotBlank String> ids){
    return ShenyuAdminResult.success(ShenyuResultMessage.DELETE_SUCCESS, pluginHandleService.deletePluginHandles(ids));
}",deletePluginHandles,org/apache/shenyu/admin/controller/PluginHandleController.java,/shenyu-admin/src/main/java/org/apache/shenyu/admin/controller/PluginHandleController.java,"/**
     * batch delete some plugin handles by some id list.
     * @param ids plugin handle id list.
     * @return {@linkplain ShenyuAdminResult}
     */",118-126,"('deletePluginHandles', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,10.0,batch delete some plugin handles by some id list.,from a list of ids batch delete some plugin handles.,Some handles by an id list are deleted.,0.455063560781009,  delete in batches some plugin descriptors by a list of identifiers.
29,openapi-generator,"public static JsonNode readWithInfo(String location, List<AuthorizationValue> auths) throws Exception{
    String data;
    location = location.replaceAll(""\\\\"", ""/"");
    if (location.toLowerCase(Locale.ROOT).startsWith(""http"")) {
        data = RemoteUrl.urlToString(location, auths);
    } else {
        final String fileScheme = ""file:"";
        Path path;
        if (location.toLowerCase(Locale.ROOT).startsWith(fileScheme)) {
            path = Paths.get(URI.create(location));
        } else {
            path = Paths.get(location);
        }
        if (Files.exists(path)) {
            data = FileUtils.readFileToString(path.toFile(), ""UTF-8"");
        } else {
            data = ClasspathHelper.loadFileFromClasspath(location);
        }
    }
    return getRightMapper(data).readTree(data);
}",readWithInfo,org/openapitools/codegen/utils/ModelUtils.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ModelUtils.java,"/**
     * Parse and return a JsonNode representation of the input OAS document.
     *
     * @param location the URL of the OAS document.
     * @param auths the list of authorization values to access the remote URL.
     *
     * @throws java.lang.Exception if an error occurs while retrieving the OpenAPI document.
     *
     * @return A JsonNode representation of the input OAS document.
     */",1608-1638,"('readWithInfo', {'INSTRUCTION': {'covered': 40, 'missed': 13}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 8, 'missed': 3}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",166.0,12.0,Parse and return a JsonNode representation of the input OAS document.,Allows you to parse and return a JsonNode representation of the OAS document given  as input. The method returns a JsonNode representation of the OAS document  given as input. Otherwise if an error occurs during retrieval of the OpenAPI term  document with java.lang.Exception.   ,Return a representation of the OAS document.,0.134081871383596,  Analyze and return a JsonNode representation of the input OAS document.
30,matsim-libs,"public final void addStrategy(final PlanStrategy strategy, final String subpopulation, final double weight){
    delegate.addStrategy(strategy, subpopulation, weight);
}",addStrategy,org/matsim/core/replanning/StrategyManager.java,/matsim/src/main/java/org/matsim/core/replanning/StrategyManager.java,"/**
	 * Adds a strategy to this manager with the specified weight. This weight
	 * compared to the sum of weights of all strategies in this manager defines
	 * the probability this strategy will be used for an agent.
	 *
	 */",109-120,"('addStrategy', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,11.0,Adds a strategy to this manager with the specified weight., Allows a strategy to be added to this manager with the specified weight.  The probability of this strategy being used for an agent is defined   by this weight relative to the sum of the weights of all strategies in this manager.,The manager has a strategy with a specified weight.,0.304590973756266,  Adds a policy to this handler with the specified weight.
32,cdk,"public List<Permutation> transversal(final PermutationGroup subgroup){
    final long m = this.order() / subgroup.order();
    final List<Permutation> results = new ArrayList<Permutation>();
    Backtracker transversalBacktracker = new Backtracker() {

        private boolean finished = false;

        @Override
        public void applyTo(Permutation p) {
            for (Permutation f : results) {
                Permutation h = f.invert().multiply(p);
                if (subgroup.test(h) == size) {
                    return;
                }
            }
            results.add(p);
            if (results.size() >= m) {
                this.finished = true;
            }
        }

        @Override
        public boolean isFinished() {
            return finished;
        }
    };
    this.apply(transversalBacktracker);
    return results;
}",transversal,org/openscience/cdk/group/PermutationGroup.java,/tool/group/src/main/java/org/openscience/cdk/group/PermutationGroup.java,"/**
     * Generate a transversal of a subgroup in this group.
     *
     * @param subgroup the subgroup to use for the transversal
     * @return a list of permutations
     */",241-276,"('transversal', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",156.0,10.0,Generate a transversal of a subgroup in this group.,Allows you to generate a transversal of a subgroup of the following group,A subgroup of this group should be created.,0.266067889731676,  Generate a cross-section of a subgroup in this group.
33,acs-aem-commons,"public Resource decorate(final Resource resource){
    try {
        if (!this.accepts(resource)) {
            return resource;
        }
    } catch (Exception e) {
        // Logging at debug level b/c if this happens it could represent a ton of logging
        LOG.debug(""Failed binary sync check for remote asset: {}"", resource.getPath());
        return resource;
    }
    boolean syncSuccessful = false;
    if (isAlreadySyncing(resource.getPath())) {
        syncSuccessful = waitForSyncInProgress(resource);
    } else {
        syncSuccessful = syncAssetBinaries(resource);
    }
    if (syncSuccessful) {
        LOG.trace(""Refreshing resource after binary sync of {}"", resource.getPath());
        resource.getResourceResolver().refresh();
        return resource.getResourceResolver().getResource(resource.getPath());
    } else {
        return resource;
    }
}",decorate,com/adobe/acs/commons/remoteassets/impl/RemoteAssetDecorator.java,/bundle/src/main/java/com/adobe/acs/commons/remoteassets/impl/RemoteAssetDecorator.java,"/**
     * When resolving a remote asset, first sync the asset from the remote server.
     * @param resource The resource being resolved.
     * @return The current resource.  If the resource is a ""remote"" asset, it will
     * first be converted to a true local AEM asset by sync'ing in the rendition
     * binaries from the remote server.
     */",76-108,"('decorate', {'INSTRUCTION': {'covered': 49, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",137.0,15.0,"When resolving a remote asset, first sync the asset from the remote server.",In first it is necessary to synchronize the resource from the remote server when  resolving a remote resource,"First, sync the asset from the remote server.",0.104527623499358,"  When resolving a remote resource, first synchronize the resource from the remote server."
34,cdk,"public BitSet projectG1(BitSet set){
    BitSet projection = new BitSet(getFirstGraphSize());
    CDKRNode xNode = null;
    for (int x = set.nextSetBit(0); x >= 0; x = set.nextSetBit(x + 1)) {
        xNode = getGraph().get(x);
        projection.set(xNode.getRMap().getId1());
    }
    return projection;
}",projectG1,org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,"/**
     *  Projects a CDKRGraph bitset on the source graph G1.
     * @param  set  CDKRGraph BitSet to project
     * @return      The associate BitSet in G1
     */",530-544,"('projectG1', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",83.0,10.0,Projects a CDKRGraph bitset on the source graph G1.,A set of CDKRGraph bits is projected onto the G1 source graph.  The method at this point returns BitSet associated in G1.,The bitset is on the source graph G1.,0.22479617148768,Projects a CDKRGraph bit set onto the G1 source graphic.
35,cdk,"private IAtomContainer readSmiles(final String line){
    try {
        return sp.parseSmiles(line);
    } catch (CDKException e) {
        logger.error(""Error while reading the SMILES from: "" + line + "", "", e);
        final IAtomContainer empty = builder.newInstance(IAtomContainer.class, 0, 0, 0, 0);
        empty.setProperty(BAD_SMILES_INPUT, line);
        empty.setTitle(suffix(line));
        return empty;
    }
}",readSmiles,org/openscience/cdk/io/iterator/IteratingSMILESReader.java,/storage/smiles/src/main/java/org/openscience/cdk/io/iterator/IteratingSMILESReader.java,"/**
     * Read the SMILES given in the input line - or return an empty container.
     *
     * @param line input line
     * @return the read container (or an empty one)
     */",162-178,"('readSmiles', {'INSTRUCTION': {'covered': 63, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,15.0,Read the SMILES given in the input line - or return an empty container.,The method in question either reads the SMILES indicated in the input line  or returns an empty container.,Return an empty container if you read the SMILES given in the input line.,0.641183155229738,  Read the SMILES given in the input line - or return an empty container.
37,jooby,"public static Optional<Cookie> create(@Nonnull String namespace, @Nonnull Config conf){
    if (conf.hasPath(namespace)) {
        Cookie cookie = new Cookie(conf.getString(namespace + "".name""));
        value(conf, namespace + "".value"", Config::getString, cookie::setValue);
        value(conf, namespace + "".path"", Config::getString, cookie::setPath);
        value(conf, namespace + "".domain"", Config::getString, cookie::setDomain);
        value(conf, namespace + "".secure"", Config::getBoolean, cookie::setSecure);
        value(conf, namespace + "".httpOnly"", Config::getBoolean, cookie::setHttpOnly);
        value(conf, namespace + "".maxAge"", (c, path) -> c.getDuration(path, TimeUnit.SECONDS), cookie::setMaxAge);
        value(conf, namespace + "".sameSite"", (c, path) -> SameSite.of(c.getString(path)), cookie::setSameSite);
        return Optional.of(cookie);
    }
    return Optional.empty();
}",create,io/jooby/Cookie.java,/jooby/src/main/java/io/jooby/Cookie.java,"/**
   * Attempt to create/parse a cookie from application configuration object. The namespace given
   * must be present and must defined a <code>name</code> property.
   *
   * The namespace might optionally defined: value, path, domain, secure, httpOnly and maxAge.
   *
   * @param namespace Cookie namespace/prefix.
   * @param conf Configuration object.
   * @return Parsed cookie or empty.
   */",550-575,"('create', {'INSTRUCTION': {'covered': 133, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 12, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",208.0,10.0,Attempt to create/parse a cookie from application configuration object.,"The provided namespace must be present and must define a name property.  Attempt to create/parametrize a cookie from the application configuration item. The namespace can optionally define: value, path, domain, secure, httpOnly and maxAge.",Attempt to create a cookie from an object.,0.362635528775633,  Try creating/parsing a cookie from the application configuration object.
38,tablesaw,"public Iterator<LocalTime> iterator(){
    return new Iterator<LocalTime>() {

        final IntIterator intIterator = intIterator();

        @Override
        public boolean hasNext() {
            return intIterator.hasNext();
        }

        @Override
        public LocalTime next() {
            return PackedLocalTime.asLocalTime(intIterator.nextInt());
        }
    };
}",iterator,tech/tablesaw/api/TimeColumn.java,/core/src/main/java/tech/tablesaw/api/TimeColumn.java,"/**
   * Returns an iterator over elements of type {@code T}.
   *
   * @return an Iterator.
   */",609-631,"('iterator', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,13.0,Returns an iterator over elements of type {@code T}.,Allows an iterator to be returned on items of type {@code T}.,An iterator is returned over elements of type @code T.,0.308572151823239,  Returns an iterator over elements of type {@code T}.
39,cdk,"private boolean lookupRingSystem(IRingSet rs, IAtomContainer molecule, boolean anon){
    if (!useIdentTemplates)
        return false;
    final IChemObjectBuilder bldr = molecule.getBuilder();
    final IAtomContainer ringSystem = bldr.newInstance(IAtomContainer.class);
    for (IAtomContainer container : rs.atomContainers()) ringSystem.add(container);
    final Set<IAtom> ringAtoms = new HashSet<>();
    for (IAtom atom : ringSystem.atoms()) ringAtoms.add(atom);
    final IAtomContainer ringWithStubs = bldr.newInstance(IAtomContainer.class);
    ringWithStubs.add(ringSystem);
    for (IBond bond : molecule.bonds()) {
        IAtom atom1 = bond.getBegin();
        IAtom atom2 = bond.getEnd();
        if (isHydrogen(atom1) || isHydrogen(atom2))
            continue;
        if (ringAtoms.contains(atom1) ^ ringAtoms.contains(atom2)) {
            ringWithStubs.addAtom(atom1);
            ringWithStubs.addAtom(atom2);
            ringWithStubs.addBond(bond);
        }
    }
    final IAtomContainer skeletonStub = clearHydrogenCounts(AtomContainerManipulator.skeleton(ringWithStubs));
    final IAtomContainer skeleton = clearHydrogenCounts(AtomContainerManipulator.skeleton(ringSystem));
    final IAtomContainer anonymous = clearHydrogenCounts(AtomContainerManipulator.anonymise(ringSystem));
    for (IAtomContainer container : Arrays.asList(skeletonStub, skeleton, anonymous)) {
        if (!anon && container == anonymous)
            continue;
        if (identityLibrary.assignLayout(container)) {
            for (int i = 0; i < ringSystem.getAtomCount(); i++) {
                IAtom atom = ringSystem.getAtom(i);
                atom.setPoint2d(container.getAtom(i).getPoint2d());
                atom.setFlag(CDKConstants.ISPLACED, true);
            }
            return true;
        }
    }
    return false;
}",lookupRingSystem,org/openscience/cdk/layout/StructureDiagramGenerator.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/StructureDiagramGenerator.java,"/**
     * Using a fast identity template library, lookup the the ring system and assign coordinates.
     * The method indicates whether a match was found and coordinates were assigned.
     *
     * @param rs       the ring set
     * @param molecule the rest of the compound
     * @param anon     check for anonmised templates
     * @return coordinates were assigned
     */",1583-1649,"('lookupRingSystem', {'INSTRUCTION': {'covered': 175, 'missed': 1}, 'BRANCH': {'covered': 22, 'missed': 2}, 'LINE': {'covered': 32, 'missed': 1}, 'COMPLEXITY': {'covered': 11, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",345.0,16.0,"Using a fast identity template library, lookup the the ring system and assign coordinates.",Search the ring system and assign coordinates using a library of fast identity models.  This method allows the user to indicate whether a match has been found and  whether coordinates have been assigned.,The ring system and coordinates can be assigned using a fast identity template library.,0.180330700980185,"  Using a library of quick identity patterns, search for the ring system and assign coordinates."
40,cdk,"public double weight(){
    double result = 0;
    Iterator edgeIterator = edgeSet().iterator();
    while (edgeIterator.hasNext()) {
        result += ((Edge) edgeIterator.next()).getWeight();
    }
    return result;
}",weight,org/openscience/cdk/ringsearch/cyclebasis/SimpleCycle.java,/legacy/src/main/java/org/openscience/cdk/ringsearch/cyclebasis/SimpleCycle.java,"/**
     * Returns the sum of the weights of all edges in this cycle.
     *
     * @return the sum of the weights of all edges in this cycle
     */",86-98,"('weight', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,13.0,Returns the sum of the weights of all edges in this cycle.,"In relation to this loop, the sum of the weights of all edges is returned",The sum of the weights of all edges is returned.,0.413491567106878,  Returns the sum of the weights of all the edges in this cycle.
41,weblogic-kubernetes-operator,"public synchronized boolean containsCluster(String clusterName){
    if (clusterName != null) {
        for (WlsClusterConfig clusterConfig : configuredClusters) {
            if (clusterConfig.getClusterName().equals(clusterName)) {
                return true;
            }
        }
    }
    return false;
}",containsCluster,oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,"/**
   * Whether the WebLogic domain contains a cluster with the given cluster name.
   *
   * @param clusterName cluster name to be checked
   * @return True if the WebLogic domain contains a cluster with the given cluster name
   */",335-351,"('containsCluster', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,13.0,Whether the WebLogic domain contains a cluster with the given cluster name.,If the WebLogic domain includes a cluster with the given cluster name. The method returns True if the WebLogic domain in question contains  a cluster with the given cluster name,The WebLogic domain has a cluster with a name.,0.206896983892128,  If the WebLogic domain contains a cluster with the given cluster name.
43,dataverse,"public static void updateProperties(){
    if (settingsSvc == null) {
        return;
    }
    properties.clear();
    Set<Setting> dbSettings = settingsSvc.listAll();
    dbSettings.forEach(s -> properties.put(PREFIX + ""."" + s.getName().substring(1) + (s.getLang() == null ? """" : ""."" + s.getLang()), s.getContent()));
    lastUpdate = Instant.now();
}",updateProperties,edu/harvard/iq/dataverse/settings/source/DbSettingConfigSource.java,/src/main/java/edu/harvard/iq/dataverse/settings/source/DbSettingConfigSource.java,"/**
     * Retrieve settings from the database via service and update cache.
     */",37-49,"('updateProperties', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",97.0,11.0,Retrieve settings from the database via service and update cache.,Update the cache after ever retrieving the setting from the database through the service.,Update cache and retrieve settings from the database.,0.551407905394742,  Retrieve database settings through the service and update cache.
44,liquibase,"protected String[] fixupArgs(String[] args){
    List<String> fixedArgs = new ArrayList<>();
    for (int i = 0; i < args.length; i++) {
        String arg = args[i];
        if ((arg.startsWith(""--"") || arg.startsWith(""-D"")) && !arg.contains(""="")) {
            String nextArg = null;
            if ((i + 1) < args.length) {
                nextArg = args[i + 1];
            }
            if ((nextArg != null) && !nextArg.startsWith(""--"") && !isCommand(nextArg)) {
                arg = arg + ""="" + nextArg;
                i++;
            }
        }
        arg = arg.replace(""\\,"", "","");
        fixedArgs.add(arg);
    }
    return fixedArgs.toArray(new String[fixedArgs.size()]);
}",fixupArgs,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,"/**
     * On windows machines, it splits args on '=' signs.  Put it back like it was.
     */",814-839,"('fixupArgs', {'INSTRUCTION': {'covered': 79, 'missed': 0}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",177.0,12.0,"On windows machines, it splits args on '=' signs.","The method in question, to bring everything back to the way it was before,  on Windows computers, divides the arguments on the '=' signs",It splits args on windows machines.,0.487332402409288,"  On Windows machines, it divides the args on the '=' signs."
45,acs-aem-commons,"private boolean matches(List<Pattern> patterns, String data){
    for (Pattern pattern : patterns) {
        final Matcher matcher = pattern.matcher(data);
        if (matcher.matches()) {
            return true;
        }
    }
    return false;
}",matches,com/adobe/acs/commons/httpcache/config/impl/HttpCacheConfigImpl.java,/bundle/src/main/java/com/adobe/acs/commons/httpcache/config/impl/HttpCacheConfigImpl.java,"/**
     * Matching the given data with the set of compiled patterns.
     *
     * @param patterns
     * @param data
     * @return
     */",385-401,"('matches', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,11.0,Matching the given data with the set of compiled patterns.,Corresponds to the data provided with the set of completed models.,The data and compiled patterns are matched.,0.234644423224815,  Match the data with all compiled models.
48,glowstone,"public boolean readInt(@NonNls String key, IntConsumer consumer){
    if (isInt(key)) {
        consumer.accept(getInt(key));
        return true;
    }
    return false;
}",readInt,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to an integer subtag if it is present.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */",404-418,"('readInt', {'INSTRUCTION': {'covered': 11, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,13.0,Applies the given function to an integer subtag if it is present.,"In the case where an integer subtag is present, the date function is applied. ","If the function is present, apply it to the subtag.",0.463002178584216,  Applies the given function to an entire subtag if it is present.
50,matsim-libs,"public double calculate(DrtRequest drtRequest, InsertionWithDetourData<D> insertion){
    // TODO precompute time slacks for each stop to filter out even more infeasible insertions ???????????
    var detourTimeInfo = detourTimeCalculator.calculateDetourTimeInfo(insertion);
    if (!checkTimeConstraintsForScheduledRequests(insertion.getInsertion(), detourTimeInfo.pickupTimeLoss, detourTimeInfo.getTotalTimeLoss())) {
        return INFEASIBLE_SOLUTION_COST;
    }
    double vehicleSlackTime = calcVehicleSlackTime(insertion.getVehicleEntry(), timeOfDay.getAsDouble());
    return costCalculationStrategy.calcCost(drtRequest, insertion.getInsertion(), vehicleSlackTime, detourTimeInfo);
}",calculate,org/matsim/contrib/drt/optimizer/insertion/InsertionCostCalculator.java,/contribs/drt/src/main/java/org/matsim/contrib/drt/optimizer/insertion/InsertionCostCalculator.java,"/**
	 * As the main goal is to minimise bus operation time, this method calculates how much longer the bus will operate
	 * after insertion. By returning INFEASIBLE_SOLUTION_COST, the insertion is considered infeasible
	 * <p>
	 * The insertion is invalid if some maxTravel/Wait constraints for the already scheduled requests are not fulfilled.
	 * This is denoted by returning INFEASIBLE_SOLUTION_COST.
	 * <p>
	 *
	 * @param drtRequest the request
	 * @param insertion  the insertion to be considered here
	 * @return cost of insertion (INFEASIBLE_SOLUTION_COST represents an infeasible insertion)
	 */",87-111,"('calculate', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,24.0,"As the main goal is to minimise bus operation time, this method calculates how much longer the bus will operate  after insertion.","This method calculates the bus travel time after insertion,  with the goal of minimizing the bus travel time.  In case the insertion is considered infeasible, it returns INFEASIBLE_SOLUTION_COST  If certain maxTravel/Wait constraints for already scheduled requests are not met the entry is invalid. This is indicated with the return INFEASIBLE_SOLUTION_COST.""","The main goal is to reduce bus operation time, and this method calculates how long the bus will operate after the introduction.",0.5624203466937,"  As the main goal is to minimize the operating time of the bus, this method calculates how long the bus will still run after insertion."
51,weblogic-kubernetes-operator,"public List<T> split(Map<String, String> data){
    startSplitResult();
    for (DataEntry dataEntry : getSortedEntrySizes(data)) {
        addToSplitResult(dataEntry);
    }
    recordSplitResult();
    recordTargetInfo(result.get(0), result.size());
    return result;
}",split,oracle/kubernetes/operator/helpers/ConfigMapSplitter.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/ConfigMapSplitter.java,"/**
   * Given a map, splits it so that no map has more total data than the specified limit, and returns a list of
   * target objects built from the resultant maps. This may result in some maps receiving partial value for the largest
   * items. If the target type implements CountRecorder, the 'recordCount' method of the first target will be invoked
   * with the number of targets created.
   *
   * @param data the map to split.
   */",45-62,"('split', {'INSTRUCTION': {'covered': 33, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,32.0,"Given a map, splits it so that no map has more total data than the specified limit, and returns a list of  target objects built from the resultant maps.",The method in question splits the input map with the goal that no map has more total data than the specified limit. It then returns a list of target objects constructed from the resulting maps. In some cases it may happen that some maps get a partial value for larger elements.  The 'recordCount' method of the first target will be invoked with the number of targets  created if the target type implements CountRecorder,"If you give a map, it splits it so that no map has more data than the limit, and returns a list of target objects.",0.35231159253648,"  Given a map, divide it so that no map has more total data than the specified limit and returns a list of target objects built from the resulting maps."
52,cdk,"private IChemModel readChemModel(IChemModel chemModel) throws CDKException{
    IReactionSet setOfReactions = chemModel.getReactionSet();
    if (setOfReactions == null) {
        setOfReactions = chemModel.getBuilder().newInstance(IReactionSet.class);
    }
    chemModel.setReactionSet(readReactionSet(setOfReactions));
    return chemModel;
}",readChemModel,org/openscience/cdk/io/MDLRXNReader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLRXNReader.java,"/**
    * Read a IChemModel from a file in MDL RDF format.
    *
    * @param  chemModel The IChemModel
    * @return           The IChemModel that was read from the RDF file
    */",192-205,"('readChemModel', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",56.0,11.0,Read a IChemModel from a file in MDL RDF format.,From a file in MDL format RDF reads an IChemModel,The IChemModel is in MDL RDF format.,0.192112203994705,  Read an IChemModel from a file in MDL RDF format.
53,cdk,"public Permutation invert(){
    Permutation inversion = new Permutation(values.length);
    for (int i = 0; i < values.length; i++) {
        inversion.values[this.values[i]] = i;
    }
    return inversion;
}",invert,org/openscience/cdk/group/Permutation.java,/tool/group/src/main/java/org/openscience/cdk/group/Permutation.java,"/**
     * Invert the permutation, so that for all i : inv[p[i]] = i.
     *
     * @return the inverse of this permutation
     */",212-223,"('invert', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,20.0,"Invert the permutation, so that for all i : inv[p[i]] = i.",In order that for all i : inv[p[i]] = i the following method reverses the permutation,"For all, Invert the permutation.",0.433356573948511,"  Reverse the permutation, so that for all i: inv[p[i]] = i."
55,openapi-generator," void addAuthenticationSwitches(Map<String, Object> bundle){
    Map<String, SecurityScheme> securitySchemeMap = openAPI.getComponents() != null ? openAPI.getComponents().getSecuritySchemes() : null;
    List<CodegenSecurity> authMethods = config.fromSecurity(securitySchemeMap);
    if (authMethods != null && !authMethods.isEmpty()) {
        bundle.put(""authMethods"", authMethods);
        bundle.put(""hasAuthMethods"", true);
        if (ProcessUtils.hasOAuthMethods(authMethods)) {
            bundle.put(""hasOAuthMethods"", true);
            bundle.put(""oauthMethods"", ProcessUtils.getOAuthMethods(authMethods));
        }
        if (ProcessUtils.hasHttpBearerMethods(authMethods)) {
            bundle.put(""hasHttpBearerMethods"", true);
            bundle.put(""httpBearerMethods"", ProcessUtils.getHttpBearerMethods(authMethods));
        }
        if (ProcessUtils.hasHttpSignatureMethods(authMethods)) {
            bundle.put(""hasHttpSignatureMethods"", true);
            bundle.put(""httpSignatureMethods"", ProcessUtils.getHttpSignatureMethods(authMethods));
        }
        if (ProcessUtils.hasHttpBasicMethods(authMethods)) {
            bundle.put(""hasHttpBasicMethods"", true);
            bundle.put(""httpBasicMethods"", ProcessUtils.getHttpBasicMethods(authMethods));
        }
        if (ProcessUtils.hasApiKeyMethods(authMethods)) {
            bundle.put(""hasApiKeyMethods"", true);
            bundle.put(""apiKeyMethods"", ProcessUtils.getApiKeyMethods(authMethods));
        }
    }
}",addAuthenticationSwitches,org/openapitools/codegen/DefaultGenerator.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java,"/**
     * Add authentication methods to the given map
     * This adds a boolean and a collection for each authentication type to the map.
     * <p>
     * Examples:
     * <p> 
     *   boolean hasOAuthMethods
     * <p>
     *   List&lt;CodegenSecurity&gt; oauthMethods
     *
     * @param bundle the map which the booleans and collections will be added
     */",804-844,"('addAuthenticationSwitches', {'INSTRUCTION': {'covered': 83, 'missed': 25}, 'BRANCH': {'covered': 12, 'missed': 4}, 'LINE': {'covered': 17, 'missed': 4}, 'COMPLEXITY': {'covered': 5, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",257.0,22.0,Add authentication methods to the given map  This adds a boolean and a collection for each authentication type to the map.,The method in question from tthe given map allows the addition of authentication methods.  In this case a boolean and a collection for each type of  authentication is added to the map. For examples:  boolean hasOAuthMethods List&lt;CodegenSecurity&gt; oauthMethods,This adds a collection and a boolean for each type ofAuthentication to the map.,0.342279670649763,  Add authentication methods to the given card This adds a Boolean and a collection for each type of authentication to the card.
56,cdk,"public void dumpSystemProperties(){
    debug(""os.name        : "" + System.getProperty(""os.name""));
    debug(""os.version     : "" + System.getProperty(""os.version""));
    debug(""os.arch        : "" + System.getProperty(""os.arch""));
    debug(""java.version   : "" + System.getProperty(""java.version""));
    debug(""java.vendor    : "" + System.getProperty(""java.vendor""));
}",dumpSystemProperties,org/openscience/cdk/tools/LoggingTool.java,/misc/log4j/src/main/java/org/openscience/cdk/tools/LoggingTool.java,"/**
     * Outputs system properties for the operating system and the java
     * version. More specifically: os.name, os.version, os.arch, java.version
     * and java.vendor.
     */",215-227,"('dumpSystemProperties', {'INSTRUCTION': {'covered': 56, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,12.0,Outputs system properties for the operating system and the java  version.,"The method allows you to get the properties of the java version  and the operating system. Specifically: os.name, os.version, os.arch, java.version and java.vendor.",The system properties are used for the operating system and java version.,0.12071628510258,  Generates the system properties of the operating system and Java version.
57,mybatis-3,"public List<String> list(String path) throws IOException{
    List<String> names = new ArrayList<>();
    for (URL url : getResources(path)) {
        names.addAll(list(url, path));
    }
    return names;
}",list,org/apache/ibatis/io/VFS.java,/src/main/java/org/apache/ibatis/io/VFS.java,"/**
   * Recursively list the full resource path of all the resources that are children of all the
   * resources found at the specified path.
   *
   * @param path The path of the resource(s) to list.
   * @return A list containing the names of the child resources.
   * @throws IOException If I/O errors occur
   */",212-226,"('list', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,23.0,Recursively list the full resource path of all the resources that are children of all the  resources found at the specified path.,"Starting with all resources that are children of all resources found in the specified path, the method allows the full path to be recursively listed",List the full resource path of all the resources that are children of all the resources found at the path.,0.299864282890757,  Recursively list the full path of all resources that are children of all resources found on the specified path.
58,json-schema-validator,"public void combineWithCollector(String name, Object data){
    Object object = collectorMap.get(name);
    if (object instanceof Collector<?>) {
        Collector<?> collector = (Collector<?>) object;
        collector.combine(data);
    }
}",combineWithCollector,com/networknt/schema/CollectorContext.java,/src/main/java/com/networknt/schema/CollectorContext.java,"/**
     * Combines data with Collector identified by the given name.
     *
     * @param name String
     * @param data Object
     */",104-116,"('combineWithCollector', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,10.0,Combines data with Collector identified by the given name.,From the specific name given combines the data with the Collector,The data is combined with the collector.,0.222421313951726,  Combines data with collector identified by first name.
59,dataverse,"public static void printAttributes(HttpServletRequest request){
    List<String> shibValues = new ArrayList<>();
    if (request == null) {
        logger.fine(""HttpServletRequest was null. No shib values to print."");
        return;
    }
    for (String attr : shibAttrs) {
        Object attrObject = request.getAttribute(attr);
        if (attrObject != null) {
            shibValues.add(attr + "": "" + attrObject.toString());
        }
    }
    logger.fine(""shib values: "" + shibValues);
}",printAttributes,edu/harvard/iq/dataverse/authorization/providers/shib/ShibUtil.java,/src/main/java/edu/harvard/iq/dataverse/authorization/providers/shib/ShibUtil.java,"/**
     * These are the attributes we are getting from the IdP at testshib.org, a
     * dump from https://pdurbin.pagekite.me/Shibboleth.sso/Session
     *
     * Miscellaneous
     *
     * Session Expiration (barring inactivity): 479 minute(s)
     *
     * Client Address: 10.0.2.2
     *
     * SSO Protocol: urn:oasis:names:tc:SAML:2.0:protocol
     *
     * Identity Provider: https://idp.testshib.org/idp/shibboleth
     *
     * Authentication Time: 2014-09-12T17:07:36.137Z
     *
     * Authentication Context Class:
     * urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport
     *
     * Authentication Context Decl: (none)
     *
     *
     *
     * Attributes
     *
     * affiliation: Member@testshib.org;Staff@testshib.org
     *
     * cn: Me Myself And I
     *
     * entitlement: urn:mace:dir:entitlement:common-lib-terms
     *
     * eppn: myself@testshib.org
     *
     * givenName: Me Myself
     *
     * persistent-id:
     * https://idp.testshib.org/idp/shibboleth!https://pdurbin.pagekite.me/shibboleth!zylzL+NruovU5OOGXDOL576jxfo=
     *
     * sn: And I
     *
     * telephoneNumber: 555-5555
     *
     * uid: myself
     *
     * unscoped-affiliation: Member;Staff
     *
     */",297-367,"('printAttributes', {'INSTRUCTION': {'covered': 32, 'missed': 7}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,13.0,These are the attributes we are getting from the IdP at testshib.,"The attributes we get from the IdP of testshib.org, from https://pdurbin.pagekite.me/Shibboleth.sso/Session are as follows:  affiliation, cn, entitlement, eppn, givenName, persistent-id, sn, telephoneNumber, uid, unscoped-affiliation.",The IdP at testshib gives us these attributes.,0.249406190291094,  These are the attributes we get from the IdP to testshib.
60,cdk,"private static double correctMass(double mass, Integer charge){
    if (charge == null)
        return mass;
    double massE = 0.00054857990927;
    if (charge > 0)
        mass -= massE * charge;
    else if (charge < 0)
        mass += massE * Math.abs(charge);
    return mass;
}",correctMass,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * Correct the mass according the charge of the IMmoleculeFormula.
     * Negative charge will add the mass of one electron to the mass.
     *
     * @param mass      The mass to correct
     * @param charge    The charge
     * @return          The mass with the correction
     */",838-854,"('correctMass', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,10.0,Correct the mass according the charge of the IMmoleculeFormula.,Based on the IMmoleculeFormula it is possible to correct the mass. At this point you will add the mass of an electron to the mass through the negative charge,Correct the mass according to the charge of the molecule.,0.568120328807709,  Correct the mass according to the load of the IMmoleculeFormula.
61,cdk,"private static String multipleExtractor(String formula){
    String recentCompoundCount = ""0"";
    String recentCompound = """";
    boolean found = false;
    for (int f = 0; f < formula.length(); f++) {
        char thisChar = formula.charAt(f);
        if (thisChar >= '0' && thisChar <= '9') {
            if (!found)
                recentCompoundCount += thisChar;
            else
                recentCompound += thisChar;
        } else {
            found = true;
            recentCompound += thisChar;
        }
    }
    return muliplier(recentCompound, Integer.valueOf(recentCompoundCount));
}",multipleExtractor,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * The starting with numeric value is used to show a quantity by which a formula is multiplied.
     * For example: 2H2O really means that a H4O2 unit.
     *
     * @param formula Formula to correct
     * @return        Formula with the correction
     */",1443-1469,"('multipleExtractor', {'INSTRUCTION': {'covered': 63, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,18.0,The starting with numeric value is used to show a quantity by which a formula is multiplied.,The initial numeric value is used to specify an amount for which a formula is multiplied.,The formula is calculated by using the starting value and the number of times the formula is repeated.,0.525741784593024,  The starting value by a numeric value is used to display a quantity by which a formula is multiplied.
62,cdk,"static long[] parseUSmilesNumbers(String aux, IAtomContainer container){
    int index;
    long[] numbers = new long[container.getAtomCount()];
    int[] first = null;
    int label = 1;
    if ((index = aux.indexOf(""/R:"")) >= 0) {
        int endIndex = aux.indexOf('/', index + 8);
        if (endIndex < 0)
            endIndex = aux.length();
        String[] baseNumbers = aux.substring(index + 8, endIndex).split("";"");
        first = new int[baseNumbers.length];
        Arrays.fill(first, -1);
        for (int i = 0; i < baseNumbers.length; i++) {
            String[] numbering = baseNumbers[i].split("","");
            first[i] = Integer.parseInt(numbering[0]) - 1;
            for (String number : numbering) {
                numbers[Integer.parseInt(number) - 1] = label++;
            }
        }
    } else if ((index = aux.indexOf(""/N:"")) >= 0) {
        String[] baseNumbers = aux.substring(index + 3, aux.indexOf('/', index + 3)).split("";"");
        first = new int[baseNumbers.length];
        Arrays.fill(first, -1);
        if ((index = aux.indexOf(""/F:"")) >= 0) {
            String[] fixedHNumbers = aux.substring(index + 3, aux.indexOf('/', index + 3)).split("";"");
            for (int i = 0; i < fixedHNumbers.length; i++) {
                String component = fixedHNumbers[i];
                if (component.charAt(component.length() - 1) == 'm') {
                    int n = component.length() > 1 ? Integer.parseInt(component.substring(0, component.length() - 1)) : 1;
                    for (int j = 0; j < n; j++) {
                        String[] numbering = baseNumbers[i + j].split("","");
                        first[i + j] = Integer.parseInt(numbering[0]) - 1;
                        for (String number : numbering) numbers[Integer.parseInt(number) - 1] = label++;
                    }
                } else {
                    String[] numbering = component.split("","");
                    for (String number : numbering) numbers[Integer.parseInt(number) - 1] = label++;
                }
            }
        } else {
            for (int i = 0; i < baseNumbers.length; i++) {
                String[] numbering = baseNumbers[i].split("","");
                first[i] = Integer.parseInt(numbering[0]) - 1;
                for (String number : numbering) numbers[Integer.parseInt(number) - 1] = label++;
            }
        }
    } else {
        throw new IllegalArgumentException(""AuxInfo did not contain extractable base numbers (/N: or /R:)."");
    }
    for (int v : first) {
        if (v >= 0) {
            IAtom atom = container.getAtom(v);
            if (atom.getFormalCharge() == null)
                continue;
            if (atom.getAtomicNumber() == 8 && atom.getFormalCharge() == -1) {
                List<IAtom> neighbors = container.getConnectedAtomsList(atom);
                if (neighbors.size() == 1) {
                    IAtom correctedStart = findPiBondedOxygen(container, neighbors.get(0));
                    if (correctedStart != null)
                        exch(numbers, v, container.indexOf(correctedStart));
                }
            }
        }
    }
    for (int i = 0; i < numbers.length; i++) if (numbers[i] == 0)
        numbers[i] = label++;
    return numbers;
}",parseUSmilesNumbers,org/openscience/cdk/graph/invariant/InChINumbersTools.java,/storage/inchi/src/main/java/org/openscience/cdk/graph/invariant/InChINumbersTools.java,"/**
     * Parse the InChI canonical atom numbers (from the AuxInfo) to use in
     * Universal SMILES.
     *
     * The parsing follows: ""Rule A: The correspondence between the input atom
     * order and the InChI canonical labels should be obtained from the
     * reconnected metal layer (/R:) in preference to the initial layer, and
     * then from the fixed hydrogen labels (/F:) in preference to the standard
     * labels (/N:)."" 
     *
     * The labels are also adjust for ""Rule E: If the start atom is a negatively
     * charged oxygen atom, start instead at any carbonyl oxygen attached to the
     * same neighbour."" 
     *
     * All unlabelled atoms (e.g. hydrogens) are assigned the same label which
     * is different but larger then all other labels. The hydrogen
     * labelling then needs to be adjusted externally as universal SMILES
     * suggests hydrogens should be visited first.
     *
     * @param aux       inchi AuxInfo
     * @param container the structure to obtain the numbering of
     * @return the numbers string to use
     */",86-191,"('parseUSmilesNumbers', {'INSTRUCTION': {'covered': 384, 'missed': 6}, 'BRANCH': {'covered': 41, 'missed': 5}, 'LINE': {'covered': 54, 'missed': 1}, 'COMPLEXITY': {'covered': 19, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",749.0,17.0,Parse the InChI canonical atom numbers (from the AuxInfo) to use in  Universal SMILES.,"To use inUniversal SMILES analyze the canonical atom numbers of InChI (from AuxInfo).  The analysis follows: ""Rule A: From the reconnected metal layer (/ R :) it should be possible to obtain the correspondence between the order of the incoming atoms and the canonical InChI labels, rather than from the initial layer, and therefore from the fixed labels of hydrogen (/ F :) in preference to standard labels (/ N :). ""  It is also possible to adjust the labels for Rule E: in the case of the start atom is a negatively charged oxygen atom, start instead at any carbonyl oxygen attached to the same neighbour.""   The same label is assigned to all unlabeled atoms (eg Hydrogens) which is different but larger than all other labels. Universal SMILES suggests that hydrogens should be visited first therefore hydrogen labeling must therefore be externally regulated.",Universal SMILES uses the InChI canonical atom numbers.,0.61558432534238,  Analyze the numbers of canonical atoms InChI (from the AuxInfo) for use in Universal SMILES.
63,jackson-databind,"public ObjectReader readerForUpdating(Object valueToUpdate){
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}",readerForUpdating,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Factory method for constructing {@link ObjectReader} that will
     * update given Object (usually Bean, but can be a Collection or Map
     * as well, but NOT an array) with JSON data. Deserialization occurs
     * normally except that the root-level value in JSON is not used for
     * instantiating a new object; instead give updateable object is used
     * as root.
     * Runtime type of value object is used for locating deserializer,
     * unless overridden by other factory methods of {@link ObjectReader}
     */",4096-4110,"('readerForUpdating', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,37.0,"Factory method for constructing {@link ObjectReader} that will  update given Object (usually Bean, but can be a Collection or Map  as well, but NOT an array) with JSON data.","It will be possible to update a certain object (usually Bean, but it can also be a collection or a map, but NOT an array) with JSON data through the factory method {@link ObjectReader}.  De-serialization normally happens, except that the value of the root layer in JSON is not used to instantiate a new object. The runtime type of the value object is used to locate the deserializer, unless it is overwritten by other factory methods of {@link ObjectReader}",The method for constructing @link ObjectReader that will update given object is a factory method.,1.14555495215555,"  A factory method for constructing {@link ObjectReader} that will update a given object (usually Bean, but can also be a collection or map, but NOT an array) with JSON data."
64,jackson-databind,"public static boolean isProxyType(Class<?> type){
    String name = type.getName();
    if (name.startsWith(""net.sf.cglib.proxy."") || name.startsWith(""org.hibernate.proxy."")) {
        return true;
    }
    return false;
}",isProxyType,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * Helper method used to weed out dynamic Proxy types; types that do
     * not expose concrete method API that we could use to figure out
     * automatic Bean (property) based serialization.
     */",233-255,"('isProxyType', {'INSTRUCTION': {'covered': 13, 'missed': 2}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,33.0,Helper method used to weed out dynamic Proxy types; types that do  not expose concrete method API that we could use to figure out  automatic Bean (property) based serialization.,To understand Bean-based automatic serialization (property) it is possible to use types that do not expose the API of the concrete method. This is a helper method for eliminating dynamic proxy types,The method used to weed out dynamic Proxy types is called a helpers method.,0.855630472713994,  Assistive method used to eliminate dynamic proxy types; types that do not expose the concrete method API that we could use to understand Bean-based automatic serialization (property).
65,logstash-logback-encoder,"public static List<InetSocketAddress> parse(String destinations, int defaultPort){
    /*
         * Multiple destinations can be specified on one single line, separated by comma
         */
    String[] destinationStrings = (destinations == null ? """" : destinations.trim()).split(""\\s*,\\s*"");
    List<InetSocketAddress> destinationList = new ArrayList<>(destinationStrings.length);
    for (String entry : destinationStrings) {
        /*
             * For #134, check to ensure properties are defined when destinations
             * are set using properties.
             */
        if (entry.contains(CoreConstants.UNDEFINED_PROPERTY_SUFFIX)) {
            throw new IllegalArgumentException(""Invalid destination '"" + entry + ""': unparseable value (expected format 'host[:port]')."");
        }
        Matcher matcher = DESTINATION_PATTERN.matcher(entry);
        if (!matcher.matches()) {
            throw new IllegalArgumentException(""Invalid destination '"" + entry + ""': unparseable value (expected format 'host[:port]')."");
        }
        String host = matcher.group(HOSTNAME_GROUP);
        String portString = matcher.group(PORT_GROUP);
        int port;
        try {
            port = (portString != null) ? Integer.parseInt(portString) : defaultPort;
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException(""Invalid destination '"" + entry + ""': unparseable port (was '"" + portString + ""')."");
        }
        destinationList.add(InetSocketAddress.createUnresolved(host, port));
    }
    return destinationList;
}",parse,net/logstash/logback/appender/destination/DestinationParser.java,/src/main/java/net/logstash/logback/appender/destination/DestinationParser.java,"/**
     * Constructs {@link InetSocketAddress}es by parsing the given {@link String} value.
     * <p>
     * The string is a comma separated list of destinations in the form of hostName[:portNumber].
     * <p>
     *
     * For example, ""host1.domain.com,host2.domain.com:5560""
     * <p>
     *
     * If portNumber is not provided, then the given defaultPort will be used.
     * 
     * @param destinations comma-separated list of destinations in the form of {@code hostName[:portNumber]}
     * @param defaultPort the port number to use when a destination does not specify one explicitly
     * @return ordered list of {@link InetSocketAddress} instances
     */",39-94,"('parse', {'INSTRUCTION': {'covered': 111, 'missed': 2}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",203.0,18.0,Constructs {@link InetSocketAddress}es by parsing the given {@link String} value.,"By analyzing the specified {@link String} value, it builds {@link InetSocketAddress} The string is a comma-separated list of targets in the form of hostName [: portNumber]",The given @link String value is used to construct @link InetSocketAddresses.,0.65011910575187,  Constructs {@link InetSocketAddress}es by parsing the given {@link String} value.
66,cdk,"public static boolean contains(IMolecularFormulaSet formulaSet, IMolecularFormula formula){
    for (IMolecularFormula fm : formulaSet.molecularFormulas()) {
        if (MolecularFormulaManipulator.compare(fm, formula)) {
            return true;
        }
    }
    return false;
}",contains,org/openscience/cdk/tools/manipulator/MolecularFormulaSetManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaSetManipulator.java,"/**
     *  True, if the IMolecularFormulaSet contains the given IMolecularFormula but not
     *  as object. It compare according contains the same number and type of Isotopes.
     *  It is not based on compare objects.
     *
     * @param formulaSet   The IMolecularFormulaSet
     * @param  formula     The IMolecularFormula this IMolecularFormulaSet is searched for
     * @return             True, if the IMolecularFormulaSet contains the given formula
     *
     * @see                IMolecularFormulaSet#contains(IMolecularFormula)
     */",166-184,"('contains', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,14.0,"True, if the IMolecularFormulaSet contains the given IMolecularFormula but not  as object.","The method in question returns True, if the specified MolecularFormula object is contained in IMolecularFormulaSet but not as an object. Compares objects that contain the same number and type of isotopes.  It does not rely on comparing objects.","If the IMolecularFormulaSet contains the given IMolecularFormula but not as object, it is true.",0.392988217973468,"  True, if IMolecularFormulaSet contains the given IMolecularFormula but not as an object."
67,jackson-databind,"public static String apostrophed(String text){
    if (text == null) {
        return ""[null]"";
    }
    return new StringBuilder(text.length() + 2).append('\'').append(text).append('\'').toString();
}",apostrophed,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * Returns either {@code 'text'} (single-quoted) or {@code [null]}.
     *
     * @since 2.9
     */",805-815,"('apostrophed', {'INSTRUCTION': {'covered': 17, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,20.0,Returns either {@code 'text'} (single-quoted) or {@code [null]}.,The following method allows you to return either {@code 'text'} (single-quoted) or {@code [null]}.,Either @code 'text' or @code 'null' will be returned.,0.759913550007265,  Returns {@code 'text'} (single quotation mark) or {@code [null]}.
68,cdk,"void store(OutputStream out) throws IOException{
    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(out));
    for (Entry<String, List<Point2d[]>> e : templateMap.entrySet()) {
        for (Point2d[] val : e.getValue()) {
            bw.write(encodeEntry(new AbstractMap.SimpleImmutableEntry<>(e.getKey(), val)));
            bw.write('\n');
        }
    }
    bw.close();
}",store,org/openscience/cdk/layout/IdentityTemplateLibrary.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/IdentityTemplateLibrary.java,"/**
     * Store a template library to the provided output stream.
     *
     * @param out output stream
     * @throws IOException low level IO error
     */",484-502,"('store', {'INSTRUCTION': {'covered': 50, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",98.0,10.0,Store a template library to the provided output stream.,In the provided output stream this method allows you to store a template library.,The template library should be stored in the provided output stream.,0.421867323576133,  Store a library of templates in the provided output stream.
69,cdk,"private static int readUInt(final String line, int index, int digits){
    int result = 0;
    while (digits-- > 0) result = (result * 10) + toInt(line.charAt(index++));
    return result;
}",readUInt,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Read an unsigned int value from the given index with the expected number
     * of digits.
     *
     * @param line   input line
     * @param index  start index
     * @param digits number of digits (max)
     * @return an unsigned int
     */",1671-1685,"('readUInt', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,16.0,Read an unsigned int value from the given index with the expected number  of digits.,The method in question from the given index with the expected number of digits reads an int value without a sign,The expected number of digits is what you'll get when you read an unsigned int value from the index.,0.243987253483922,  Read an unsigned int value from the given index with the expected number of digits.
70,dataverse,"public static String generateNewFileName(final String fileName){
    String newName;
    String baseName;
    String extension = null;
    int extensionIndex = fileName.lastIndexOf(""."");
    if (extensionIndex != -1) {
        extension = fileName.substring(extensionIndex + 1);
        baseName = fileName.substring(0, extensionIndex);
    } else {
        baseName = fileName;
    }
    if (baseName.matches("".*-[0-9][0-9]*$"")) {
        int dashIndex = baseName.lastIndexOf(""-"");
        String numSuffix = baseName.substring(dashIndex + 1);
        String basePrefix = baseName.substring(0, dashIndex);
        int numSuffixValue = Integer.parseInt(numSuffix);
        numSuffixValue++;
        baseName = basePrefix + ""-"" + numSuffixValue;
    } else {
        baseName = baseName + ""-1"";
    }
    newName = baseName;
    if (extension != null) {
        newName = newName + ""."" + extension;
    }
    return newName;
}",generateNewFileName,edu/harvard/iq/dataverse/ingest/IngestUtil.java,/src/main/java/edu/harvard/iq/dataverse/ingest/IngestUtil.java,"/**
     * Generates a new unique filename by adding -[number] to the base name.
     *
     * @param fileName original filename
     * @return a new unique filename
     */",208-244,"('generateNewFileName', {'INSTRUCTION': {'covered': 62, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 18, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",168.0,16.0,Generates a new unique filename by adding -[number] to the base name.,Adding -[number] to the base name generates a new filename,Adding -[number] to the base name creates a new unique filename.,1.01501677171445,  Generates a new unique file name by appending -[number] to the base name.
71,jeromq,"public Timer add(long interval, Handler handler, Object... args){
    if (handler == null) {
        return null;
    }
    Utils.checkArgument(interval > 0, ""Delay of a timer has to be strictly greater than 0"");
    final Timer timer = new Timer(this, interval, handler, args);
    final boolean rc = insert(timer);
    assert (rc);
    return timer;
}",add,zmq/util/Timers.java,/src/main/java/zmq/util/Timers.java,"/**
     * Add timer to the set, timer repeats forever, or until cancel is called.
     * @param interval the interval of repetition in milliseconds.
     * @param handler the callback called at the expiration of the timer.
     * @param args the optional arguments for the handler.
     * @return an opaque handle for further cancel.
     */",113-130,"('add', {'INSTRUCTION': {'covered': 32, 'missed': 4}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",71.0,16.0,"Add timer to the set, timer repeats forever, or until cancel is called.",In the following method a timer is added to the collection the handler parameter the callback is called when the timer expires. Until cancel is called the timer repeats forever,Add a timer to the set and it will repeat forever.,0.380046231451206,"  Add the timer to the set, the timer repeats forever or until the cancellation is called."
72,openapi-generator,"public String toModelName(final String name){
    if (schemaKeyToModelNameCache.containsKey(name)) {
        return schemaKeyToModelNameCache.get(name);
    }
    String camelizedName = camelize(modelNamePrefix + ""_"" + name + ""_"" + modelNameSuffix);
    schemaKeyToModelNameCache.put(name, camelizedName);
    return camelizedName;
}",toModelName,org/openapitools/codegen/DefaultCodegen.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java,"/**
     * Converts the OpenAPI schema name to a model name suitable for the current code generator.
     * May be overridden for each programming language.
     * In case the name belongs to the TypeSystem it won't be renamed.
     *
     * @param name the name of the model
     * @return capitalized model name
     */",2380-2397,"('toModelName', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",57.0,16.0,Converts the OpenAPI schema name to a model name suitable for the current code generator.,The OpenAPI schema name is converted to a template name suitable for the current code generator. For any programming language it can be overridden. It will not be renamed if the name belongs to TypeSystem.,The OpenAPI name is converted to a model name for the current code generator.,0.799427466674471,  Converts the OpenAPI schema name to a template name that is appropriate for the current code generator.
74,javaparser,"public static String castValue(String value, Type requiredType, String valueType){
    String requiredTypeName = requiredType.asString();
    if (requiredTypeName.equals(valueType))
        return value;
    else
        return String.format(""(%s) %s"", requiredTypeName, value);
}",castValue,com/github/javaparser/generator/core/utils/CodeUtils.java,/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/utils/CodeUtils.java,"/**
	 * Cast the value if the current type doesn't match the required type.
	 * <br>
	 * Given the following example:
	 * <code>
	 *     int withoutCast = 1;
	 *     double withCast = (double) 1;
	 * </code>
	 * The variable withoutCast doesn't need to be casted, since we have int as required type and int as value type.
	 * While in the variable withCast we have double as required type and int as value type.
	 *
	 * @param value           The value to be returned.
	 * @param requiredType    The expected type to be casted if needed.
	 * @param valueType       The type of the value to be returned.
	 *
	 * @return The value casted if needed.
	 */",32-56,"('castValue', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",50.0,14.0,Cast the value if the current type doesn't match the required type.,In case the current type does not match the required type it casts the value. In the variable conCast we have double as the required type and int as the value type. Whereas in the case where we have int as the required type and int as the value type the variable withoutCast does not need to be cast.,"If the current type doesn't match the required type, cast the value.",0.187302707008753,  Convert the value if the current type does not match the required type.
75,cdk,"public static ILigand defineLigand(IAtomContainer container, VisitedAtoms visitedAtoms, int chiralAtom, int ligandAtom){
    if (ligandAtom == HYDROGEN) {
        return new ImplicitHydrogenLigand(container, visitedAtoms, container.getAtom(chiralAtom));
    } else {
        return new Ligand(container, visitedAtoms, container.getAtom(chiralAtom), container.getAtom(ligandAtom));
    }
}",defineLigand,org/openscience/cdk/geometry/cip/CIPTool.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/CIPTool.java,"/**
     * Creates a ligand attached to a single chiral atom, where the involved
     * atoms are identified by there index in the {@link IAtomContainer}. For ligand
     * atom, {@link #HYDROGEN} can be passed as index, which will indicate the presence of
     * an implicit hydrogen, not explicitly present in the chemical graph of the
     * given <code>container</code>.
     *
     * @param container  {@link IAtomContainer} for which the returned {@link ILigand}s are defined
     * @param visitedAtoms a list of atoms already visited in the analysis
     * @param chiralAtom an integer pointing to the {@link IAtom} index of the chiral atom
     * @param ligandAtom an integer pointing to the {@link IAtom} index of the {@link ILigand}
     * @return           the created {@link ILigand}
     */",307-327,"('defineLigand', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,27.0,"Creates a ligand attached to a single chiral atom, where the involved  atoms are identified by there index in the {@link IAtomContainer}.","From the atoms involved that are identified by the index in the {@link IAtomContainer} creates a ligand linked to a single chiral atom. {@link #HYDROGEN} for the ligand atom, can be passed as an index, this will allow to indicate the presence of an implicit hydrogen, thus not explicitly occurring in the chemical graph of the given <code>container</code>",The involved atoms are identified by the index in the @link IAtomContainer.,0.729108886222505,"  Creates a ligand attached to a single chiral atom, where the atoms involved are identified by the index {@link IAtomContainer}."
76,matsim-libs,"public void checkConsistency(Config config){
    super.checkConsistency(config);
    boolean hasOpeningAndClosingTime = false;
    boolean hasOpeningTimeAndLatePenalty = false;
    for (ActivityParams actType : this.getActivityParams()) {
        if (actType.isScoringThisActivityAtAll()) {
            if (actType.getOpeningTime().isDefined() && actType.getClosingTime().isDefined()) {
                hasOpeningAndClosingTime = true;
                if (actType.getOpeningTime().seconds() == 0. && actType.getClosingTime().seconds() > 24. * 3600 - 1) {
                    log.error(""it looks like you have an activity type with opening time set to 0:00 and closing "" + ""time set to 24:00. This is most probably not the same as not setting them at all.  "" + ""In particular, activities which extend past midnight may not accumulate scores."");
                }
            }
            if (actType.getOpeningTime().isDefined() && (getLateArrival_utils_hr() < -0.001)) {
                hasOpeningTimeAndLatePenalty = true;
            }
        }
    }
    if (!hasOpeningAndClosingTime && !hasOpeningTimeAndLatePenalty) {
        log.info(""NO OPENING OR CLOSING TIMES DEFINED!\n\n"" + ""There is no activity type that has an opening *and* closing time (or opening time and late penalty) defined.\n"" + ""This usually means that the activity chains can be shifted by an arbitrary\n"" + ""number of hours without having an effect on the score of the plans, and thus\n"" + ""resulting in wrong results / traffic patterns.\n"" + ""If you are using MATSim without time adaptation, you can ignore this warning.\n\n"");
    }
    if (this.getMarginalUtlOfWaiting_utils_hr() != 0.0) {
        log.warn(""marginal utl of wait set to: "" + this.getMarginalUtlOfWaiting_utils_hr() + "". Setting this different from zero is "" + ""discouraged since there is already the marginal utility of time as a resource. The parameter was also used "" + ""in the past for pt routing; if you did that, consider setting the new "" + ""parameter waitingPt instead."");
    }
}",checkConsistency,org/matsim/core/config/groups/PlanCalcScoreConfigGroup.java,/matsim/src/main/java/org/matsim/core/config/groups/PlanCalcScoreConfigGroup.java,"/**
		 * Checks whether all the settings make sense or if there are some
		 * problems with the parameters currently set. Currently, this checks
		 * that for at least one activity type opening AND closing times are
		 * defined.
		 */",1510-1561,"('checkConsistency', {'INSTRUCTION': {'covered': 90, 'missed': 12}, 'BRANCH': {'covered': 18, 'missed': 2}, 'LINE': {'covered': 17, 'missed': 2}, 'COMPLEXITY': {'covered': 9, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",207.0,19.0,Checks whether all the settings make sense or if there are some  problems with the parameters currently set.,"The following method checks whether there are problems with the currently set parameters or whether all settings make sense. For at least one type of activity, check that opening and closing times are defined.",Checks if the settings make sense or if there are problems with the parameters currently set.,0.547390837594194,  Checks if all the parameters make sense or if there are any problems with the currently defined parameters.
77,cdk,"public DescriptorValue calculate(IAtom atom, IAtomContainer container){
    double value;
    String originalAtomtypeName = atom.getAtomTypeName();
    Integer originalNeighborCount = atom.getFormalNeighbourCount();
    Integer originalValency = atom.getValency();
    Double originalBondOrderSum = atom.getBondOrderSum();
    Order originalMaxBondOrder = atom.getMaxBondOrder();
    IAtomType.Hybridization originalHybridization = atom.getHybridization();
    if (!isCachedAtomContainer(container)) {
        try {
            AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(container);
            LonePairElectronChecker lpcheck = new LonePairElectronChecker();
            lpcheck.saturate(container);
        } catch (CDKException e) {
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(Double.NaN), NAMES, e);
        }
    }
    value = db.extractIP(container, atom);
    atom.setAtomTypeName(originalAtomtypeName);
    atom.setFormalNeighbourCount(originalNeighborCount);
    atom.setValency(originalValency);
    atom.setHybridization(originalHybridization);
    atom.setMaxBondOrder(originalMaxBondOrder);
    atom.setBondOrderSum(originalBondOrderSum);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(value), NAMES);
}",calculate,org/openscience/cdk/qsar/descriptors/atomic/IPAtomicHOSEDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/IPAtomicHOSEDescriptor.java,"/**
     *  This method calculates the ionization potential of an atom.
     *
     *@param  atom          The IAtom to ionize.
     *@param  container         Parameter is the IAtomContainer.
     *@return                   The ionization potential. Not possible the ionization.
     */",119-160,"('calculate', {'INSTRUCTION': {'covered': 71, 'missed': 17}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 19, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",220.0,10.0,This method calculates the ionization potential of an atom.,This method makes it possible to calculate the ionization potential of an atom,The method calculates the potential of an atom.,0.770640448549817,  This method calculates the ionization potential of an atom.
78,openapi-generator,"public static boolean isObjectSchema(Schema schema){
    if (schema instanceof ObjectSchema) {
        return true;
    }
    if (SchemaTypeUtil.OBJECT_TYPE.equals(schema.getType()) && !(schema instanceof MapSchema)) {
        return true;
    }
    if (schema.getType() == null && schema.getProperties() != null && !schema.getProperties().isEmpty()) {
        return true;
    }
    return false;
}",isObjectSchema,org/openapitools/codegen/utils/ModelUtils.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ModelUtils.java,"/**
     * Return true if the specified schema is an object with a fixed number of properties.
     *
     * A ObjectSchema differs from an MapSchema in the following way:
     * - An ObjectSchema is not extensible, i.e. it has a fixed number of properties.
     * - A MapSchema is an object that can be extended with an arbitrary set of properties.
     *   The payload may include dynamic properties.
     *
     * For example, an OpenAPI schema is considered an ObjectSchema in the following scenarios:
     *
     *   type: object
     *   additionalProperties: false
     *   properties:
     *     name:
     *       type: string
     *     address:
     *       type: string
     *
     * @param schema the OAS schema
     * @return true if the specified schema is an Object schema.
     */",425-461,"('isObjectSchema', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",85.0,16.0,Return true if the specified schema is an object with a fixed number of properties.,If the specified pattern is an object with a fixed number of properties returns true,"If the specified object is an object with a fixed number of properties, return true.",0.851904796427581,  Return true if the specified schema is an object with a fixed number of properties.
79,matsim-libs,"public static void insertLegAct(Plan plan, int pos, Leg leg, Activity act){
    if (pos < plan.getPlanElements().size()) {
        Object o = plan.getPlanElements().get(pos);
        if (!(o instanceof Leg)) {
            throw new IllegalArgumentException(""Position to insert leg and act is not valid (act instead of leg at position)."");
        }
    } else if (pos > plan.getPlanElements().size()) {
        throw new IllegalArgumentException(""Position to insert leg and act is not valid."");
    }
    plan.getPlanElements().add(pos, act);
    plan.getPlanElements().add(pos, leg);
}",insertLegAct,org/matsim/core/population/PopulationUtils.java,/matsim/src/main/java/org/matsim/core/population/PopulationUtils.java,"/**
         * Inserts a leg and a following act at position <code>pos</code> into the plan.
         * @param pos the position where to insert the leg-act-combo. acts and legs are both counted from the beginning starting at 0.
         * @param leg the leg to insert
         * @param act the act to insert, following the leg
         *
         * @throws IllegalArgumentException If the leg and act cannot be inserted at the specified position without retaining the correct order of legs and acts.
         */",1057-1076,"('insertLegAct', {'INSTRUCTION': {'covered': 40, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",117.0,20.0,Inserts a leg and a following act at position <code>pos</code> into the plan.,Inserts a leg and a subsequent act at position <code>pos</code> into the plan.,A leg and a following act are inserted into the plan.,0.536312162644162,  Inserts one leg and one subsequent act to the <code>pos</code> position in the plane.
80,weblogic-kubernetes-operator,"public Map<String, Object> generate(Class<?> someClass){
    Map<String, Object> result = new HashMap<>();
    if (includeSchemaReference) {
        result.put(""$schema"", JSON_SCHEMA_REFERENCE);
    }
    generateObjectTypeIn(result, someClass);
    if (!definedObjects.isEmpty()) {
        Map<String, Object> definitions = new TreeMap<>();
        result.put(""definitions"", definitions);
        for (Class<?> type : definedObjects.keySet()) {
            if (!definedObjects.get(type).equals(EXTERNAL_CLASS)) {
                definitions.put(getDefinitionKey(type), definedObjects.get(type));
            }
        }
    }
    return result;
}",generate,oracle/kubernetes/json/SchemaGenerator.java,/json-schema-generator/src/main/java/oracle/kubernetes/json/SchemaGenerator.java,"/**
   * Generates an object representing a JSON schema for the specified class.
   *
   * @param someClass the class for which the schema should be generated
   * @return a map of maps, representing the computed JSON
   */",167-191,"('generate', {'INSTRUCTION': {'covered': 61, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",142.0,12.0,Generates an object representing a JSON schema for the specified class.,An object representing the relevant JSON schema is constructed for the specified class,An object is generated for a class.,0.486318278394064,  Generates an object representing a JSON schema for the specified class.
81,tablesaw,"private void validateColumn(FunctionMetaData function, Column<?> sourceColumn){
    if (!function.isCompatibleColumn(sourceColumn.type())) {
        throw new IllegalArgumentException(""Function: "" + function.functionName() + "" Is not compatible with column type: "" + sourceColumn.type());
    }
}",validateColumn,tech/tablesaw/analytic/AnalyticQueryEngine.java,/core/src/main/java/tech/tablesaw/analytic/AnalyticQueryEngine.java,"/**
   * Checks to make sure the given aggregate function is compatible with the type of the source
   * column.
   */",114-126,"('validateColumn', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",52.0,18.0,Checks to make sure the given aggregate function is compatible with the type of the source  column.,Checks whether the source column type is compatible with the given aggregate function,Checks to make sure the aggregate function is compatible with the source column.,0.377006557828616,  Verifies that the given aggregation function is compatible with the type of the source column.
82,acs-aem-commons,"protected void bindScriptProvider(OnDeployScriptProvider scriptProvider){
    logger.info(""Executing on-deploy scripts from scriptProvider: {}"", scriptProvider.getClass().getName());
    scriptProviders.add(scriptProvider);
    List<OnDeployScript> scripts = scriptProvider.getScripts();
    if (scripts.size() == 0) {
        logger.debug(""No on-deploy scripts found."");
        return;
    }
    try (ResourceResolver resourceResolver = logIn()) {
        runScripts(resourceResolver, scripts);
    }
}",bindScriptProvider,com/adobe/acs/commons/ondeploy/impl/OnDeployExecutorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/ondeploy/impl/OnDeployExecutorImpl.java,"/**
     * Executes all on-deploy scripts on bind of a script provider.
     */",138-154,"('bindScriptProvider', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,11.0,Executes all on-deploy scripts on bind of a script provider.,Allows all scripts to run on-deploy on bind of a script provider.,All on-deploy scripts are executed on the bind of a script provider.,0.285104866675482,  Runs all scripts that are being deployed when binding a script provider.
83,cdk,"public static boolean isAromatic(IRing ring, IAtomContainer atomContainer){
    java.util.Iterator<IAtom> ringAtoms = ring.atoms().iterator();
    int eCount = 0;
    java.util.List<IBond> conectedBonds;
    int numDoubleBond = 0;
    boolean allConnectedBondsSingle;
    while (ringAtoms.hasNext()) {
        IAtom atom = ringAtoms.next();
        numDoubleBond = 0;
        allConnectedBondsSingle = true;
        conectedBonds = atomContainer.getConnectedBondsList(atom);
        for (IBond conectedBond : conectedBonds) {
            if (conectedBond.getOrder() == IBond.Order.DOUBLE && ring.contains(conectedBond)) {
                numDoubleBond++;
            } else // Count the Electron if bond order = 1.5
            if (conectedBond.getFlag(CDKConstants.ISAROMATIC) && ring.contains(conectedBond)) {
                numDoubleBond = 1;
            }
            if (conectedBond.getOrder() != IBond.Order.SINGLE) {
                allConnectedBondsSingle = false;
            }
        }
        if (numDoubleBond == 1) {
            // C or heteroatoms both contibute 1 electron in sp2 hybridized form
            eCount++;
        } else if (!atom.getSymbol().equals(""C"")) {
            // Heteroatom probably in sp3 hybrid therefore 2 electrons contributed.
            eCount = eCount + 2;
        } else if (atom.getFlag(CDKConstants.ISAROMATIC)) {
            eCount++;
        } else if (allConnectedBondsSingle && atom.getSymbol().equals(""C"") && atom.getFormalCharge() == 1.0) {
            // This is for tropylium and kinds.
            // Dependence on hybridisation would be better:
            // empty p-orbital is needed
            continue;
        } else {
            return false;
        }
    }
    return eCount - 2 != 0 && (eCount - 2) % 4 == 0;
}",isAromatic,org/openscience/cdk/aromaticity/AromaticityCalculator.java,/legacy/src/main/java/org/openscience/cdk/aromaticity/AromaticityCalculator.java,"/**
     *  Tests the <code>ring</code> in the <code>molecule</code> for aromaticity. Uses the
     *  H&uuml;ckel rule (4n + 2) pie electrons. sp<sup>2</sup> hybridized C contibute 1 electron non
     *  sp<sup>2</sup> hybridized heteroatoms contribute 2 electrons (N and O should never be sp in
     *  or anything else in a ring and d electron elements get to complicated)
     *  sp<sup>2</sup> hybridized heteroatoms contribute 1 electron hybridization is worked out by
     *  counting the number of bonds with order 2. Therefore sp<sup>2</sup> hybridization is assumed
     *  if there is one bond of order 2. Otherwise sp<sup>3</sup> hybridization is assumed.
     *
     * @param  ring      the ring to test
     * @param  atomContainer  the AtomContainer the ring is in
     * @return           true if the ring is aromatic false otherwise.
     */",45-103,"('isAromatic', {'INSTRUCTION': {'covered': 90, 'missed': 23}, 'BRANCH': {'covered': 17, 'missed': 13}, 'LINE': {'covered': 23, 'missed': 4}, 'COMPLEXITY': {'covered': 6, 'missed': 10}, 'METHOD': {'covered': 1, 'missed': 0}})",274.0,21.0,Tests the <code>ring</code> in the <code>molecule</code> for aromaticity.,For aromaticity tests the <code>ring</code> in the <code>molecule</code>. The method returns true if the ring is aromatic false otherwise,The aromaticity is tested in the code>ring/code>.,0.583058183991712,  Tests <code>the aromaticity of the ring</code> in the <code>molecule</code>.
84,cdk,"public static IAtomContainer scaffold(final IAtomContainer mol){
    if (!mol.isEmpty() && mol.getAtom(0).getContainer() == null)
        return null;
    Deque<IAtom> queue = new ArrayDeque<>();
    int[] bcount = new int[mol.getAtomCount()];
    for (IAtom atom : mol.atoms()) {
        int numBonds = atom.getBondCount();
        bcount[atom.getIndex()] = numBonds;
        if (numBonds == 1)
            queue.add(atom);
    }
    while (!queue.isEmpty()) {
        IAtom atom = queue.poll();
        if (atom == null)
            continue;
        bcount[atom.getIndex()] = 0;
        for (IBond bond : atom.bonds()) {
            IAtom nbr = bond.getOther(atom);
            bcount[nbr.getIndex()]--;
            if (bcount[nbr.getIndex()] == 1)
                queue.add(nbr);
        }
    }
    IAtomContainer scaffold = mol.getBuilder().newAtomContainer();
    for (int i = 0; i < mol.getAtomCount(); i++) {
        IAtom atom = mol.getAtom(i);
        if (bcount[i] > 0)
            scaffold.addAtom(atom);
    }
    for (int i = 0; i < mol.getBondCount(); i++) {
        IBond bond = mol.getBond(i);
        if (bcount[bond.getBegin().getIndex()] > 0 && bcount[bond.getEnd().getIndex()] > 0)
            scaffold.addBond(bond);
    }
    return scaffold;
}",scaffold,org/openscience/cdk/fragment/MurckoFragmenter.java,/tool/fragment/src/main/java/org/openscience/cdk/fragment/MurckoFragmenter.java,"/**
     * Computes the Murcko Scaffold for the provided molecule in linear time.
     * Note the return value contains the same atoms/bonds as in the input
     * and an additional clone and valence adjustments may be required.
     *
     * @param mol the molecule
     * @return the atoms and bonds in the scaffold
     */",156-211,"('scaffold', {'INSTRUCTION': {'covered': 144, 'missed': 3}, 'BRANCH': {'covered': 23, 'missed': 3}, 'LINE': {'covered': 31, 'missed': 2}, 'COMPLEXITY': {'covered': 11, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",333.0,12.0,Computes the Murcko Scaffold for the provided molecule in linear time.,"For the molecule supplied in linear time, Murck's Scaffold is calculated. The returned value contains the same atoms/bonds as the input. In addition, it may require further cloning and valence adjustments.",The Murcko Scaffold is computed for a molecule in a linear time.,0.496948186185992,  Calculates the Murcko scaffolding for the molecule supplied in linear time.
85,jackson-databind,"public ObjectMapper registerModule(Module module){
    _assertNotNull(""module"", module);
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    for (Module dep : module.getDependencies()) {
        registerModule(dep);
    }
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    module.setupModule(new Module.SetupContext() {

        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            return (C) ObjectMapper.this;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public MutableConfigOverride configOverride(Class<?> type) {
            return ObjectMapper.this.configOverride(type);
        }

        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = _deserializationContext._factory.withAdditionalDeserializers(d);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = _deserializationContext._factory.withAdditionalKeyDeserializers(d);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = _deserializationContext._factory.withDeserializerModifier(modifier);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void addSerializers(Serializers s) {
            _serializerFactory = _serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            _serializerFactory = _serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            _serializerFactory = _serializerFactory.withSerializerModifier(modifier);
        }

        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = _deserializationContext._factory.withAbstractTypeResolver(resolver);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = _typeFactory;
            f = f.withModifier(modifier);
            setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = _deserializationContext._factory.withValueInstantiators(instantiators);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            _deserializationConfig = _deserializationConfig.with(ci);
            _serializationConfig = _serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            _deserializationConfig = _deserializationConfig.withInsertedAnnotationIntrospector(ai);
            _serializationConfig = _serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            _deserializationConfig = _deserializationConfig.withAppendedAnnotationIntrospector(ai);
            _serializationConfig = _serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            ObjectMapper.this.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            ObjectMapper.this.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(Collection<Class<?>> subtypes) {
            ObjectMapper.this.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            setPropertyNamingStrategy(naming);
        }
    });
    return this;
}",registerModule,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Method for registering a module that can extend functionality
     * provided by this mapper; for example, by adding providers for
     * custom serializers and deserializers.
     * 
     * @param module Module to register
     */",809-1019,"('registerModule', {'INSTRUCTION': {'covered': 62, 'missed': 10}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 17, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",836.0,26.0,"Method for registering a module that can extend functionality  provided by this mapper; for example, by adding providers for  custom serializers and deserializers.","Registration of a module that can extend the functionality provided by this mapper. For example, adding providers for custom serialisers and deserialisers.",Adding providers for custom serializers and deserializers is a method for registration a module that can extend the function of this mapper.,0.435470582653588,"  Method of registering a module capable of extending the functionality provided by this mapper; for example, by adding suppliers for custom serializers and deserializers."
86,cucumber-reporting,"void updateElements(Feature feature, Element[] elements){
    for (int i = 0; i < elements.length; i++) {
        Element current = elements[i];
        if (current.isScenario()) {
            checkArgument(current.getStartTime() != null, ERROR);
            int indexOfPreviousResult = find(feature.getElements(), current);
            boolean hasBackground = isBackground(i - 1, elements);
            if (indexOfPreviousResult < 0) {
                feature.addElements(hasBackground ? new Element[] { elements[i - 1], current } : new Element[] { current });
            } else {
                if (replaceIfExists(feature.getElements()[indexOfPreviousResult], current)) {
                    feature.getElements()[indexOfPreviousResult] = current;
                    if (hasBackground && isBackground(indexOfPreviousResult - 1, feature.getElements())) {
                        feature.getElements()[indexOfPreviousResult - 1] = elements[i - 1];
                    }
                }
            }
        }
    }
}",updateElements,net/masterthought/cucumber/reducers/ReportFeatureWithRetestMerger.java,/src/main/java/net/masterthought/cucumber/reducers/ReportFeatureWithRetestMerger.java,"/**
     * Updates feature's elements with items from the @elements list if an Id of the item coincides
     * with an Id of any element from the @feature object. If there is no element in the @feature object
     * then the item is appended to the end of the elements' list of the @feature.
     *
     * @param feature  - target object of Feature class.
     * @param elements - list of elements which need to be inserted to the @feature with replacing
     *                   or adding to the end.
     */",40-74,"('updateElements', {'INSTRUCTION': {'covered': 74, 'missed': 25}, 'BRANCH': {'covered': 11, 'missed': 5}, 'LINE': {'covered': 14, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",195.0,30.0,Updates feature's elements with items from the @elements list if an Id of the item coincides  with an Id of any element from the @feature object.,"If the element's id matches the id of any element in the @feature object, it updates the elements in the feature with the elements in the @elements list. The element is added to the end of the @feature element list if there is no element in the @feature object.","If an Id of an item coincides with an Id of an element from the feature object, the feature's elements will be updated.",0.207878053587579,  Updates feature items with items in the @elements list if an item ID coincides with an item ID in the @feature object.
87,dcache,"public static Optional<Integer> optionalPortWithDefault(URI uri){
    int port = portWithDefault(uri, null, -1);
    return port > -1 ? Optional.of(port) : Optional.<Integer>empty();
}",optionalPortWithDefault,org/dcache/util/URIs.java,/modules/common/src/main/java/org/dcache/util/URIs.java,"/**
     * Obtain an optional port number based on supplied URI.  Use the defined port number, if the
     * URI defines one; otherwise use the default port number for URI's schema, if one is known.
     * Otherwise return an empty Optional.
     */",56-64,"('optionalPortWithDefault', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,10.0,Obtain an optional port number based on supplied URI.,"An optional port number is obtained from the URI provided. Use the defined port number if the URI defines one. Otherwise, if known, it uses the default port number for the URI's scheme.",The port number can be obtained based on the supplied URI.,0.574130637711767,  Get an optional port number based on the provided URI.
88,matsim-libs,"public static void reduceToBiggestCluster(Network network, Map<Id<Node>, Node> biggestCluster){
    List<Node> allNodes2 = new ArrayList<>(network.getNodes().values());
    for (Node node : allNodes2) {
        if (!biggestCluster.containsKey(node.getId())) {
            network.removeNode(node.getId());
        }
    }
    log.info(""  resulting network contains "" + network.getNodes().size() + "" nodes and "" + network.getLinks().size() + "" links."");
    log.info(""done."");
}",reduceToBiggestCluster,org/matsim/core/network/algorithms/NetworkCleaner.java,/matsim/src/main/java/org/matsim/core/network/algorithms/NetworkCleaner.java,"/** 
	 * Reducing the network so it only contains nodes included in the biggest Cluster.
	 * Loop over all nodes and check if they are in the cluster, if not, remove them from the network
	 */",144-158,"('reduceToBiggestCluster', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",117.0,14.0,Reducing the network so it only contains nodes included in the biggest Cluster.,"The method to contain are the nodes included in the largest cluster reduces the network. Check if all nodes are part of the cluster; if not, remove them from the network.",The network should only have the smallest cluster of the biggest.,0.551194766881731,   Shrinking the network so that it contains only nodes included in the largest cluster.
89,cdk,"public static Partition unit(int size){
    Partition unit = new Partition();
    unit.cells.add(new TreeSet<Integer>());
    for (int i = 0; i < size; i++) {
        unit.cells.get(0).add(i);
    }
    return unit;
}",unit,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,"/**
     * Create a unit partition - in other words, the coarsest possible partition
     * where all the elements are in one cell.
     *
     * @param size the number of elements
     * @return a new Partition with one cell containing all the elements
     */",80-94,"('unit', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,22.0,"Create a unit partition - in other words, the coarsest possible partition  where all the elements are in one cell.",Create the coarsest possible partition in which all elements are in one cell.,The coarsest partition where all the elements are in one cell is the unit partition.,0.719816071057307,"  Create a unit partition - in other words, the coarsest possible partition where all the elements are in a cell."
90,matsim-libs,"public Collection<T> values(){
    if (this.values == null) {
        this.values = new AbstractCollection<T>() {

            @Override
            public Iterator<T> iterator() {
                Iterator<T> iterator = new Iterator<T>() {

                    private final int expectedModCount = QuadTree.this.modCount;

                    private Leaf<T> currentLeaf = firstLeaf();

                    private int nextIndex = 0;

                    private T next = first();

                    private T first() {
                        if (this.currentLeaf == null) {
                            return null;
                        }
                        this.nextIndex = 0;
                        loadNext();
                        return this.next;
                    }

                    @Override
                    public boolean hasNext() {
                        return this.next != null;
                    }

                    @Override
                    public T next() {
                        if (this.next == null) {
                            return null;
                        }
                        if (QuadTree.this.modCount != this.expectedModCount) {
                            throw new ConcurrentModificationException();
                        }
                        T current = this.next;
                        loadNext();
                        return current;
                    }

                    private void loadNext() {
                        boolean searching = true;
                        while (searching) {
                            int size = this.currentLeaf.value != null ? 1 : this.currentLeaf.values.size();
                            if (this.nextIndex < size) {
                                this.nextIndex++;
                                this.next = this.currentLeaf.value != null ? this.currentLeaf.value : this.currentLeaf.values.get(this.nextIndex - 1);
                                searching = false;
                            } else {
                                this.currentLeaf = nextLeaf(this.currentLeaf);
                                if (this.currentLeaf == null) {
                                    this.next = null;
                                    searching = false;
                                } else {
                                    this.nextIndex = 0;
                                }
                            }
                        }
                    }

                    @Override
                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
                return iterator;
            }

            @Override
            public int size() {
                return QuadTree.this.size;
            }
        };
    }
    return this.values;
}",values,org/matsim/core/utils/collections/QuadTree.java,/matsim/src/main/java/org/matsim/core/utils/collections/QuadTree.java,"/**
	 * Returns a collection view of the values contained in this map.  The
	 * collection's iterator will return the values in the order that their
	 * corresponding keys appear in the tree.  The collection is backed by
	 * this <tt>QuadMap</tt> instance, so changes to this map are reflected in
	 * the collection.
	 *
	 * @return a collection view of the values contained in this map.
	 */",276-359,"('values', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",380.0,12.0,Returns a collection view of the values contained in this map.,The method returns a collection view of the values contained in the following map.The values are returned in the order in which the corresponding keys appear in the tree.,A collection view of the values is returned.,0.610701618551137,  Returns a collection view of the values contained in this map.
91,jackson-databind,"public EnumMap<?, SerializableString> internalMap(){
    EnumMap<?, SerializableString> result = _asMap;
    if (result == null) {
        Map<Enum<?>, SerializableString> map = new LinkedHashMap<Enum<?>, SerializableString>();
        for (Enum<?> en : _values) {
            map.put(en, _textual[en.ordinal()]);
        }
        result = new EnumMap(map);
    }
    return result;
}",internalMap,com/fasterxml/jackson/databind/util/EnumValues.java,/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java,"/**
     * Method used for serialization and introspection by core Jackson code.
     */",116-131,"('internalMap', {'INSTRUCTION': {'covered': 42, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",93.0,11.0,Method used for serialization and introspection by core Jackson code.,This method is used for serialisation and introspection from Jackson's main code.,Core Jackson code is used for the method.,0.555929129887707,  A method used for serialization and introspection by basic Jackson code.
92,matsim-libs,"public void calculateLaneCapacities(Network network, Lanes lanes){
    for (LanesToLinkAssignment l2l : lanes.getLanesToLinkAssignments().values()) {
        Link link = network.getLinks().get(l2l.getLinkId());
        for (Lane lane : l2l.getLanes().values()) {
            calculateAndSetCapacity(lane, lane.getToLaneIds() == null || lane.getToLaneIds().isEmpty(), link, network);
        }
    }
}",calculateLaneCapacities,org/matsim/contrib/sumo/SumoNetworkConverter.java,/contribs/sumo/src/main/java/org/matsim/contrib/sumo/SumoNetworkConverter.java,"/**
     * Calculates lane capacities, according to {@link LanesUtils}.
     */",144-155,"('calculateLaneCapacities', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,12.0,"Calculates lane capacities, according to {@link LanesUtils}.",Based on {@link LanesUtils} calculate the capacity of lanes,"According to @link LanesUtils, it calculates lane capacities.",0.798648776152227,"  Calculates track capacities, based on {@link LanesUtils}."
93,cdk,"static List<Point2D> grahamScan(final List<Point2D> points){
    if (points.size() <= 3)
        return new ArrayList<Point2D>(points);
    Collections.sort(points, new CompareYThenX());
    Collections.sort(points, new PolarComparator(points.get(0)));
    Deque<Point2D> hull = new ArrayDeque<Point2D>();
    hull.push(points.get(0));
    hull.push(points.get(1));
    hull.push(points.get(2));
    for (int i = 3; i < points.size(); i++) {
        Point2D top = hull.pop();
        while (!hull.isEmpty() && !isLeftTurn(hull.peek(), top, points.get(i))) {
            top = hull.pop();
        }
        hull.push(top);
        hull.push(points.get(i));
    }
    return new ArrayList<Point2D>(hull);
}",grahamScan,org/openscience/cdk/renderer/generators/standard/ConvexHull.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/ConvexHull.java,"/**
     * The Graham Scan algorithm determines the points belonging to the convex hull in O(n lg n).
     *
     * @param points set of points
     * @return points in the convex hull
     * @see <a href=""http://en.wikipedia.org/wiki/Graham_scan"">Graham scan, Wikipedia</a>
     */",163-193,"('grahamScan', {'INSTRUCTION': {'covered': 89, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",212.0,20.0,The Graham Scan algorithm determines the points belonging to the convex hull in O(n lg n).,The points belonging to the convex hull in O(n lg n) are determined by the Graham Scan algorithm,The points belonging to the hull are determined by the Graham Scan.,0.362463947582369,  The Graham Scan algorithm determines the points belonging to the convex shell in O(n lg n).
94,dataverse,"public Boolean verifyPassword(String userIdInProvider, String password){
    BuiltinUser biUser = bean.findByUserName(userIdInProvider);
    if (biUser == null)
        return null;
    return PasswordEncryption.getVersion(biUser.getPasswordEncryptionVersion()).check(password, biUser.getEncryptedPassword());
}",verifyPassword,edu/harvard/iq/dataverse/authorization/providers/builtin/BuiltinAuthenticationProvider.java,/src/main/java/edu/harvard/iq/dataverse/authorization/providers/builtin/BuiltinAuthenticationProvider.java,"/**
     * Validates that the passed password is indeed the password of the user.
     * @param userIdInProvider
     * @param password
     * @return {@code true} if the password matches the user's password; {@code false} otherwise.
     */",85-97,"('verifyPassword', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,13.0,Validates that the passed password is indeed the password of the user.,Based on the user's password validate the passed password,The password is confirmed as the password of the user.,0.320928093927256,  Validates that the password passed is the user's password.
95,cdk,"private static void makeElevationMap(IAtom atom, List<IBond> bonds, Map<IAtom, Integer> map){
    map.clear();
    for (IBond bond : bonds) {
        int elevation = 0;
        switch(bond.getStereo()) {
            case UP:
            case DOWN_INVERTED:
                elevation = +1;
                break;
            case DOWN:
            case UP_INVERTED:
                elevation = -1;
                break;
        }
        if (bond.getBegin().equals(atom)) {
            map.put(bond.getEnd(), elevation);
        } else {
            map.put(bond.getBegin(), -1 * elevation);
        }
    }
}",makeElevationMap,org/openscience/cdk/hash/stereo/GeometricTetrahedralEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricTetrahedralEncoderFactory.java,"/**
     * Maps the input bonds to a map of Atom->Elevation where the elevation is
     * whether the bond is off the plane with respect to the central atom.
     *
     * @param atom  central atom
     * @param bonds bonds connected to the central atom
     * @param map   map to load with elevation values (can be reused)
     */",250-282,"('makeElevationMap', {'INSTRUCTION': {'covered': 49, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",127.0,29.0,Maps the input bonds to a map of Atom->Elevation where the elevation is  whether the bond is off the plane with respect to the central atom.,Maps the input bonds to a map of Atom->Elevation Elevation is used to check whether the bond is out of the plane with respect to the central atom.,The map shows the bonds on the plane and the elevation of the central atom.,0.824822047641372,  Maps the input bonds to an Atom->Elevation map where the elevation is if the bond is out of the plane relative to the central atom.
96,egeria,"public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (!(objectToCompare instanceof DigitalService)) {
        return false;
    }
    DigitalService asset = (DigitalService) objectToCompare;
    return Objects.equals(getVersion(), asset.getVersion()) && Objects.equals(getDisplayName(), asset.getDisplayName()) && Objects.equals(getDescription(), asset.getDescription());
}",equals,org/odpi/openmetadata/accessservices/digitalservice/properties/DigitalService.java,/open-metadata-implementation/access-services/digital-service/digital-service-api/src/main/java/org/odpi/openmetadata/accessservices/digitalservice/properties/DigitalService.java,"/**
     * {@inheritDoc}
     *
     * Return comparison result based on the content of the properties.
     */",141-161,"('equals', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,15.0,{@inheritDoc}   Return comparison result based on the content of the properties.,"Based on the content of the properties, the result of the comparison is returned ",The return result is based on the content of the properties.,0.135107291740365,  {@inheritDoc}   Return the result of the comparison based on the content of the properties.
97,liquibase,"private static boolean isNoArgCommand(String arg){
    return COMMANDS.MIGRATE.equals(arg) || COMMANDS.MIGRATE_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE.equalsIgnoreCase(arg) || COMMANDS.UPDATE_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE_TESTING_ROLLBACK.equalsIgnoreCase(arg) || COMMANDS.LIST_LOCKS.equalsIgnoreCase(arg) || COMMANDS.RELEASE_LOCKS.equalsIgnoreCase(arg) || COMMANDS.VALIDATE.equalsIgnoreCase(arg) || COMMANDS.HELP.equalsIgnoreCase(arg) || COMMANDS.CLEAR_CHECKSUMS.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(arg);
}",isNoArgCommand,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,"/**
     * Returns true if the given main command arg needs no special parameters.
     *
     * @param arg the main command to test
     * @return true if arg is a valid main command and needs no special parameters, false in all other cases
     */",680-699,"('isNoArgCommand', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'BRANCH': {'covered': 24, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 13, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",119.0,13.0,Returns true if the given main command arg needs no special parameters.,"In the case where the given main command arg does not need any special parameters, the method returns true.","If the main command needs no special parameters, this is true.",1.15804692373566,  Returns true if the given arg master command does not need special parameters.
98,anserini,"public static float computeQueryDocumentScoreWithSimilarity(IndexReader reader, String docid, String q, Similarity similarity) throws IOException{
    return computeQueryDocumentScoreWithSimilarityAndAnalyzer(reader, docid, q, similarity, IndexCollection.DEFAULT_ANALYZER);
}",computeQueryDocumentScoreWithSimilarity,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,"/**
   * Computes the score of a document with respect to a query given a scoring function. Assumes Anserini's default
   * analyzer.
   *
   * @param reader index reader
   * @param docid docid of the document to score
   * @param q query
   * @param similarity scoring function
   * @return the score of the document with respect to the query
   * @throws IOException if error encountered during query
   */",673-689,"('computeQueryDocumentScoreWithSimilarity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,16.0,Computes the score of a document with respect to a query given a scoring function.,Given a scoring function computes the score of a document with respect to a query,The score of a document is computed with respect to a query.,0.173858807520445,  Calculates the score of a document against a query with a scoring function.
99,openapi-generator,"private static String generateNextName(String name){
    Pattern pattern = Pattern.compile(""\\d+\\z"");
    Matcher matcher = pattern.matcher(name);
    if (matcher.find()) {
        String numStr = matcher.group();
        int num = Integer.parseInt(numStr) + 1;
        return name.substring(0, name.length() - numStr.length()) + num;
    } else {
        return name + ""2"";
    }
}",generateNextName,org/openapitools/codegen/DefaultCodegen.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java,"/**
     * Generate the next name for the given name, i.e. append ""2"" to the base name if not ending with a number,
     * otherwise increase the number by 1. For example:
     * status    => status2
     * status2   => status3
     * myName100 => myName101
     *
     * @param name The base name
     * @return The next name for the base name
     */",5112-5132,"('generateNextName', {'INSTRUCTION': {'covered': 43, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,11.0,"Generate the next name for the given name, i.", Taking a base name as input generates the next name for the given name.,The next name should be generated.,0.394310108099911,"  Generate the following name for the first name, i."
100,cdk,"private void combineHydrogenPositions(List<Integer> taken, List<List<Integer>> combinations, IAtomContainer skeleton, int totalMobHydrCount, List<Integer> mobHydrAttachPositions){
    if (taken.size() != totalMobHydrCount) {
        for (int i = 0; i < mobHydrAttachPositions.size(); i++) {
            int pos = mobHydrAttachPositions.get(i);
            IAtom atom = findAtomByPosition(skeleton, pos);
            int conn = getConnectivity(atom, skeleton);
            int hCnt = 0;
            for (int t : taken) if (t == pos)
                hCnt++;
            if (atom.getValency() - atom.getFormalCharge() > (hCnt + conn)) {
                taken.add(pos);
                combineHydrogenPositions(taken, combinations, skeleton, totalMobHydrCount, mobHydrAttachPositions);
                taken.remove(taken.size() - 1);
            }
        }
    } else {
        List<Integer> addList = new ArrayList<Integer>(taken.size());
        addList.addAll(taken);
        Collections.sort(addList);
        if (!combinations.contains(addList)) {
            combinations.add(addList);
        }
    }
}",combineHydrogenPositions,org/openscience/cdk/tautomers/InChITautomerGenerator.java,/tool/tautomer/src/main/java/org/openscience/cdk/tautomers/InChITautomerGenerator.java,"/**
     * Makes combinations recursively of all possible mobile Hydrogen positions.
     * @param taken positions taken by hydrogen
     * @param combinations combinations made so far
     * @param skeleton container to work on
     * @param totalMobHydrCount
     * @param mobHydrAttachPositions
     */",590-622,"('combineHydrogenPositions', {'INSTRUCTION': {'covered': 98, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",226.0,10.0,Makes combinations recursively of all possible mobile Hydrogen positions.,"From all possible mobile hydrogen positions, it performs recursive combinations.",Makes combinations that are all possible.,0.47708428596362,  Makes recursive combinations of all possible mobile positions of hydrogen.
101,dcache,"public void buildRemovalTransition(StatePath ourPath, StateTransition transition, boolean forced){
    LOGGER.trace(""entering buildRemovalTransition: path={}"", ourPath);
    Date now = new Date();
    for (Map.Entry<String, StateComponent> entry : _children.entrySet()) {
        StateComponent childValue = entry.getValue();
        String childName = entry.getKey();
        boolean shouldRemoveThisChild = forced;
        boolean shouldItr = forced;
        if (childValue.hasExpired()) {
            LOGGER.trace(""registering {} (in path {}) for removal."", childName, ourPath);
            shouldRemoveThisChild = shouldItr = true;
        }
        Date childExp = childValue.getEarliestChildExpiryDate();
        if (childExp != null && !now.before(childExp)) {
            shouldItr = true;
        }
        if (shouldItr || shouldRemoveThisChild) {
            StateChangeSet changeSet = transition.getOrCreateChangeSet(ourPath);
            if (shouldRemoveThisChild) {
                changeSet.recordRemovedChild(childName);
            }
            if (shouldItr) {
                changeSet.recordChildItr(childName);
                childValue.buildRemovalTransition(buildChildPath(ourPath, childName), transition, shouldRemoveThisChild);
            }
        }
    }
}",buildRemovalTransition,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,"/**
     * Ostensibly, we iterate over all children to find Mortal children that should be removed.  In
     * practise, cached knowledge of Mortal child expiry Dates means this iterates over only those
     * StateComponents that contain children that have actually expired.
     *
     * @param ourPath
     * @param transition
     * @param forced
     */",687-736,"('buildRemovalTransition', {'INSTRUCTION': {'covered': 83, 'missed': 0}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 22, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",196.0,16.0,"Ostensibly, we iterate over all children to find Mortal children that should be removed.",To find the dead children that are to be removed it iterates over all children.  This causes it to iterate only over those StateComponents that contain actually expired children.,We look over all children to find children that should be removed.,0.156702810440307,"  Apparently, we iterate on all children to find mortal children who should be abducted."
102,cdk,"private static StereoEncoder axial3DEncoder(IAtomContainer container, IAtom start, List<IBond> startBonds, IAtom end, List<IBond> endBonds){
    Point3d[] coordinates = new Point3d[4];
    PermutationParity perm = new CombinedPermutationParity(fill3DCoordinates(container, start, startBonds, coordinates, 0), fill3DCoordinates(container, end, endBonds, coordinates, 2));
    GeometricParity geom = new Tetrahedral3DParity(coordinates);
    int u = container.indexOf(start);
    int v = container.indexOf(end);
    return new GeometryEncoder(new int[] { u, v }, perm, geom);
}",axial3DEncoder,org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,"/**
     * Create an encoder for axial 3D stereochemistry for the given start and
     * end atoms.
     *
     * @param container  the molecule
     * @param start      start of the cumulated system
     * @param startBonds bonds connected to the start
     * @param end        end of the cumulated system
     * @param endBonds   bonds connected to the end
     * @return an encoder
     */",188-213,"('axial3DEncoder', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",120.0,15.0,Create an encoder for axial 3D stereochemistry for the given start and  end atoms.,"For the indicated start and target atoms, create an encoder for axial 3D stereochemistry",An Encoder is needed for the given start and end atoms.,0.44505799266735,Create an encoder for axial 3D stereochemistry for the given start and end atoms.
105,liquibase,"public Change create(String name){
    Change plugin = getPlugin(name);
    if (plugin == null) {
        return null;
    }
    try {
        return plugin.getClass().getConstructor().newInstance();
    } catch (Exception e) {
        throw new UnexpectedLiquibaseException(e);
    }
}",create,liquibase/change/ChangeFactory.java,/liquibase-core/src/main/java/liquibase/change/ChangeFactory.java,"/**
     * Create a new Change implementation for the given change name. The class of the constructed object will be the Change implementation with the highest priority.
     * Each call to create will return a new instance of the Change.
     */",81-95,"('create', {'INSTRUCTION': {'covered': 24, 'missed': 6}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,11.0,Create a new Change implementation for the given change name.,"For the given change name, create a new implementation of Change. A new instance of Change will be returned for each call to create.",A new implementation for the given change name is needed.,0.260805723088709,  Create a new change implementation for the given change name.
106,acs-aem-commons,"private boolean isAllowedUser(Resource resource) throws RepositoryException{
    ResourceResolver resourceResolver = resource.getResourceResolver();
    String userId = resourceResolver.getUserID();
    if (!userId.equals(ADMIN_ID)) {
        if (this.config.getWhitelistedServiceUsers().contains(userId)) {
            return true;
        }
        Session session = resourceResolver.adaptTo(Session.class);
        User currentUser = (User) getUserManager(session).getAuthorizable(userId);
        if (currentUser != null && !currentUser.isSystemUser()) {
            return true;
        } else {
            LOG.trace(""Avoiding binary sync b/c this is a non-whitelisted service user: {}"", session.getUserID());
        }
    } else {
        LOG.trace(""Avoiding binary sync for admin user"");
    }
    return false;
}",isAllowedUser,com/adobe/acs/commons/remoteassets/impl/RemoteAssetDecorator.java,/bundle/src/main/java/com/adobe/acs/commons/remoteassets/impl/RemoteAssetDecorator.java,"/**
     * Check if the user is allowed to sync binaries.
     *
     * Service users, as well as the admin user, are prevented from sync'ing
     * binaries to ensure that some back end procress traversing the DAM doesn't
     * trigger a sync of the entire DAM, thus subverting the benefits of
     * remote assets.
     *
     * Service users can be whitelisted via remote aseets configuration if it
     * is desired for a particular service user to be able to sync binaries.
     *
     * @param resource The asset content Resource to sync binaries for.
     * @return True if user is allowed to sync binaries, else false.
     * @throws RepositoryException
     */",154-188,"('isAllowedUser', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",136.0,10.0,Check if the user is allowed to sync binaries.,This method makes it possible to check whether the user is authorised to synchronise binaries. Both service users and the administrator user are prevented from synchronising binaries. The configuration of remote assets allows users to be added to a list.,"If the user is allowed to sync, check it.",0.275394665925662,  Check if the user has permission to synchronize the binaries.
107,jackson-databind,"public T valueToTree(Object fromValue) throws IllegalArgumentException{
    if (fromValue == null) {
        return (T) getNodeFactory().nullNode();
    }
    final SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);
    final DefaultSerializerProvider context = _serializerProvider(config);
    TokenBuffer buf = context.bufferForValueConversion(this);
    if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
        buf = buf.forceUseOfBigDecimal(true);
    }
    try {
        context.serializeValue(buf, fromValue);
        try (JsonParser p = buf.asParser()) {
            return readTree(p);
        }
    } catch (IOException e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    }
}",valueToTree,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Method that is reverse of {@link #treeToValue}: it
     * will convert given Java value (usually bean) into its
     * equivalent Tree mode {@link JsonNode} representation.
     * Functionally similar to serializing value into token stream and parsing that
     * stream back as tree model node,
     * but more efficient as {@link TokenBuffer} is used to contain the intermediate
     * representation instead of fully serialized contents.
     *<p>
     * NOTE: while results are usually identical to that of serialization followed
     * by deserialization, this is not always the case. In some cases serialization
     * into intermediate representation will retain encapsulation of things like
     * raw value ({@link com.fasterxml.jackson.databind.util.RawValue}) or basic
     * node identity ({@link JsonNode}). If so, result is a valid tree, but values
     * are not re-constructed through actual format representation. So if transformation
     * requires actual materialization of encoded content,
     * it will be necessary to do actual serialization.
     * 
     * @param <T> Actual node type; usually either basic {@link JsonNode} or
     *  {@link com.fasterxml.jackson.databind.node.ObjectNode}
     * @param fromValue Java value to convert
     *
     * @return (non-null) Root node of the resulting content tree: in case of
     *   {@code null} value node for which {@link JsonNode#isNull()} returns {@code true}.
     */",3344-3396,"('valueToTree', {'INSTRUCTION': {'covered': 41, 'missed': 8}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 2}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",136.0,34.0,Method that is reverse of {@link #treeToValue}: it  will convert given Java value (usually bean) into its  equivalent Tree mode {@link JsonNode} representation.,Reverse method to {@link #treeToValue}: the provided Java value (usually a bean) is converted into its equivalent representation in Tree mode {@link JsonNode}. It is used to hold the intermediate representation instead of the fully serialised content.,"The method is reverse of @link #treeToValue, it will convert given Java value into its equivalent Tree mode.",0.744966993140192,  Reverse method of {@link #treeToValue}: it will convert the given Java value (usually bean) to its equivalent in Tree view {@link JsonNode representation}.
108,cdk,"private static PermutationParity fill2DCoordinates(IAtomContainer container, IAtom a, List<IBond> connected, Point2d[] coordinates, int[] elevations, int offset){
    int i = 0;
    coordinates[offset + 1] = a.getPoint2d();
    elevations[offset + 1] = 0;
    int[] indices = new int[2];
    for (IBond bond : connected) {
        if (!isDoubleBond(bond)) {
            IAtom other = bond.getOther(a);
            coordinates[i + offset] = other.getPoint2d();
            elevations[i + offset] = elevation(bond, a);
            indices[i] = container.indexOf(other);
            i++;
        }
    }
    if (i == 1) {
        return PermutationParity.IDENTITY;
    } else {
        return new BasicPermutationParity(indices);
    }
}",fill2DCoordinates,org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,"/**
     * Fill the {@literal coordinates} and {@literal elevation} from the given
     * offset index. If there is only one connection then the second entry (from
     * the offset) will use the coordinates of <i>a</i>. The permutation parity
     * is also built and returned.
     *
     * @param container   atom container
     * @param a           the central atom
     * @param connected   bonds connected to the central atom
     * @param coordinates the coordinates array to fill
     * @param elevations  the elevations of the connected atoms
     * @param offset      current location in the offset array
     * @return the permutation parity
     */",215-253,"('fill2DCoordinates', {'INSTRUCTION': {'covered': 68, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",164.0,19.0,Fill the {@literal coordinates} and {@literal elevation} from the given  offset index.,"Starting from the given offset index, it fills the {@ literal coordinates} and {@ literal heights}. The second entry (from the offset) will use the coordinates of <i> a </i> in case there is only one connection.",The coordinates and elevation are from the offset index.,0.356782922290219,  Fill in the {coordinates @literal} and {@literal elevation} from the given offset index.
109,matsim-libs,"protected Path constructPath(Node fromNode, Node toNode, double startTime, double arrivalTime){
    List<Node> nodes = new ArrayList<>();
    List<Link> links = new ArrayList<>();
    nodes.add(0, toNode);
    Link tmpLink = getData(toNode).getPrevLink();
    if (tmpLink != null) {
        while (tmpLink.getFromNode() != fromNode) {
            links.add(0, tmpLink);
            nodes.add(0, tmpLink.getFromNode());
            tmpLink = getData(tmpLink.getFromNode()).getPrevLink();
        }
        links.add(0, tmpLink);
        nodes.add(0, tmpLink.getFromNode());
    }
    DijkstraNodeData toNodeData = getData(toNode);
    Path path = new Path(nodes, links, arrivalTime - startTime, toNodeData.getCost());
    return path;
}",constructPath,org/matsim/core/router/Dijkstra.java,/matsim/src/main/java/org/matsim/core/router/Dijkstra.java,"/**
         * Constructs the path after the algorithm has been run.
         *
         * @param fromNode
         *            The node where the path starts.
         * @param toNode
         *            The node where the path ends.
         * @param startTime
         *            The time when the trip starts.
         */",321-351,"('constructPath', {'INSTRUCTION': {'covered': 65, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",176.0,10.0,Constructs the path after the algorithm has been run.,"After execution of the algorithm, the path is constructed",The path is constructed after the algorithm has been run.,0.228797063057459,  Constructs the path after the algorithm is run.
110,matsim-libs,"public static void copyTo(Attributes from, Attributes to){
    for (var entry : from.getAsMap().entrySet()) {
        to.putAttribute(entry.getKey(), entry.getValue());
    }
}",copyTo,org/matsim/utils/objectattributes/attributable/AttributesUtils.java,/matsim/src/main/java/org/matsim/utils/objectattributes/attributable/AttributesUtils.java,"/**
         * Adds the mappings from ""from"" to ""to"". Nothing is done to copy the Object themselves,
         * which should be fine for 99.9% of the usecases of Attributes (value objects)
         */",31-39,"('copyTo', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,12.0,"Adds the mappings from ""from"" to ""to"".","The method in question allows mappings to be added from 'from' to 'to'. While for copying the objects themselves, nothing is done, which should be fine for 99.9% of Attribute (value object) use cases.","The mappings are changed from ""from"" to ""to"".",0.384669713515458,"  Adds mappings from ""from"" to ""to""."
111,jackson-databind,"public JsonNode replace(String propertyName, JsonNode value){
    if (value == null) {
        value = nullNode();
    }
    return _children.put(propertyName, value);
}",replace,com/fasterxml/jackson/databind/node/ObjectNode.java,/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java,"/**
     * Method for replacing value of specific property with passed
     * value, and returning value (or null if none).
     *
     * @param propertyName Property of which value to replace
     * @param value Value to set property to, replacing old value if any
     * 
     * @return Old value of the property; null if there was no such property
     *   with value
     * 
     * @since 2.1
     */",439-457,"('replace', {'INSTRUCTION': {'covered': 9, 'missed': 3}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,21.0,"Method for replacing value of specific property with passed  value, and returning value (or null if none).",The value of a specific property is replaced with the passed value and returns the value (or null if there is none).,The method for replacing the value of the property with another is called a substitution.,0.771889237090254,  How to replace the value of a specific property with a passed value and return the value (or null if none).
112,cdk,"protected static String formatMDLFloat(float fl){
    String s = """", fs = """";
    int l;
    NumberFormat nf = NumberFormat.getNumberInstance(Locale.ENGLISH);
    nf.setMinimumIntegerDigits(1);
    nf.setMaximumIntegerDigits(4);
    nf.setMinimumFractionDigits(4);
    nf.setMaximumFractionDigits(4);
    nf.setGroupingUsed(false);
    if (Double.isNaN(fl) || Double.isInfinite(fl))
        s = ""0.0000"";
    else
        s = nf.format(fl);
    l = 10 - s.length();
    for (int f = 0; f < l; f++) fs += "" "";
    fs += s;
    return fs;
}",formatMDLFloat,org/openscience/cdk/io/MDLV2000Writer.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Writer.java,"/**
     * Formats a float to fit into the connectiontable and changes it
     * to a String.
     *
     * @param fl The float to be formated
     * @return The String to be written into the connectiontable
     */",1347-1372,"('formatMDLFloat', {'INSTRUCTION': {'covered': 67, 'missed': 3}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 14, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",134.0,15.0,Formats a float to fit into the connectiontable and changes it  to a String.,This method formats a float to insert it into the connection table and changes it to a string.,A float is formatted to fit into the connectiontable and changed to a String.,0.806747037444189,  Formats a float to fit the connection table and replaces it with a string.
113,matsim-libs,"public static Carriers createShipmentVRPCarrierFromServiceVRPSolution(Carriers carriers){
    Carriers carriersWithShipments = new Carriers();
    for (Carrier carrier : carriers.getCarriers().values()) {
        Carrier carrierWS = CarrierUtils.createCarrier(carrier.getId());
        if (carrier.getShipments().size() > 0) {
            copyShipments(carrierWS, carrier);
        }
        if (carrier.getServices().size() > 0) {
            createShipmentsFromServices(carrierWS, carrier);
        }
        carrierWS.setCarrierCapabilities(carrier.getCarrierCapabilities());
        carriersWithShipments.addCarrier(carrierWS);
    }
    return carriersWithShipments;
}",createShipmentVRPCarrierFromServiceVRPSolution,org/matsim/contrib/freight/utils/FreightUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/utils/FreightUtils.java,"/**
         * Creates a new {@link Carriers} container only with {@link CarrierShipment}s
         * for creating a new VRP. As consequence of the transformation of
         * {@link CarrierService}s to {@link CarrierShipment}s the solution of the VRP
         * can have tours with vehicles returning to the depot and load for another tour
         * instead of creating another vehicle with additional (fix) costs. <br/>
         * The method is meant for multi-depot problems. Here, the original ""services""
         * input does not have an assignment of services to depots. The solution to the
         * problem, however, does. So the assignment is taken from that solution, and
         * each returned {@link Carrier} has that depot as pickup location in each
         * shipment.
         *
         * @param carriers carriers with a Solution (result of solving the VRP).
         * @return Carriers carriersWithShipments
         */",143-174,"('createShipmentVRPCarrierFromServiceVRPSolution', {'INSTRUCTION': {'covered': 44, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",116.0,23.0,Creates a new {@link Carriers} container only with {@link CarrierShipment}s  for creating a new VRP.,"To create a new VRP create a new container {@link Carriers} only with {@link CarrierShipment}.  The VRP solution can have tours with vehicles that return to the depot and load for another tour instead of creating another vehicle with additional (fixed) costs As a consequence of transforming {@link CarrierService}s to {@link CarrierShipment}s   The method makes it possible to handle problems with multiple repositories. The original 'services' input does not provide for assigning services to depots.  Therefore, the assignment is taken from that solution and each {@link Carrier} returned has that depot as pick-up location in each dispatch.",A new container is created with the help of the CarrierShipment.,0.618711687071035,  Creates a container {@link Carriers} only with {@link CarrierShipment} to create a new VRP.
114,weblogic-kubernetes-operator,"public static boolean isFirstNewer(V1ObjectMeta first, V1ObjectMeta second){
    if (second == null) {
        return true;
    }
    if (first == null) {
        return false;
    }
    OffsetDateTime time1 = first.getCreationTimestamp();
    OffsetDateTime time2 = second.getCreationTimestamp();
    if (time1.equals(time2)) {
        return getResourceVersion(first).compareTo(getResourceVersion(second)) > 0;
    } else {
        return time1.isAfter(time2);
    }
}",isFirstNewer,oracle/kubernetes/operator/helpers/KubernetesUtils.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/KubernetesUtils.java,"/**
   * Returns true if the first metadata indicates a newer resource than does the second. 'Newer'
   * indicates that the creation time is later. If two items have the same creation time, a higher
   * resource version indicates the newer resource.
   *
   * @param first  the first item to compare
   * @param second the second item to compare
   * @return true if the first object is newer than the second object
   */",122-147,"('isFirstNewer', {'INSTRUCTION': {'covered': 30, 'missed': 2}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,15.0,Returns true if the first metadata indicates a newer resource than does the second.,"If the first metadata indicates a more recent resource than the second returns True. Whereas, in the case where two elements have the same creation time, a resource version plus resource version indicates the more recent resource.","If the first and second gis show a newer resource, then it's true.",0.47128674647248,  Returns true if the first metadata indicates a newer resource than the second.
115,cdk,"public static Pattern findSubstructure(IAtomContainer query){
    boolean isQuery = query instanceof IQueryAtomContainer;
    return new Ullmann(query, isQuery ? AtomMatcher.forQuery() : AtomMatcher.forElement(), isQuery ? BondMatcher.forQuery() : BondMatcher.forOrder());
}",findSubstructure,org/openscience/cdk/isomorphism/Ullmann.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/Ullmann.java,"/**
     * Create a pattern which can be used to find molecules which contain the
     * {@code query} structure.
     *
     * @param query the substructure to find
     * @return a pattern for finding the {@code query}
     */",122-133,"('findSubstructure', {'INSTRUCTION': {'covered': 14, 'missed': 4}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",52.0,20.0,Create a pattern which can be used to find molecules which contain the  {@code query} structure.,The method allows the creation of a model that can be used to find molecules that contain the structure {@query code}.,A pattern can be created to find the @code query structure.,0.687299894559208,  Create a template that can be used to find molecules that contain the {@code query} structure.
116,cron-utils,"public CronDefinition instance(){
    final Set<CronConstraint> validations = new HashSet<>();
    validations.addAll(cronConstraints);
    final List<FieldDefinition> values = new ArrayList<>(fields.values());
    values.sort(FieldDefinition.createFieldDefinitionComparator());
    return new CronDefinition(values, validations, matchDayOfWeekAndDayOfMonth);
}",instance,com/cronutils/model/definition/CronDefinitionBuilder.java,/src/main/java/com/cronutils/model/definition/CronDefinitionBuilder.java,"/**
     * Creates a new CronDefinition instance with provided field definitions.
     *
     * @return returns CronDefinition instance, never null
     */",156-167,"('instance', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,10.0,Creates a new CronDefinition instance with provided field definitions.,"From the provided field definitions, create a new instance of CronDefinition",A new CronDefinition instance is created with field definitions.,0.371087579804145,  Creates a CronDefinition instance with the provided field definitions.
117,weblogic-kubernetes-operator,"public V1TokenReviewStatus check(String principal, String token, String namespace){
    // Don't expose the token since it's a credential
    LOGGER.entering(principal);
    V1TokenReview result = null;
    try {
        boolean allowed = authorizationProxy.check(principal, AuthorizationProxy.Operation.create, AuthorizationProxy.Resource.TOKENREVIEWS, null, namespace == null ? AuthorizationProxy.Scope.cluster : AuthorizationProxy.Scope.namespace, namespace);
        if (allowed) {
            result = new CallBuilder().createTokenReview(prepareTokenReview(token));
        } else {
            LOGGER.warning(MessageKeys.CANNOT_CREATE_TOKEN_REVIEW);
        }
    } catch (ApiException e) {
        LOGGER.severe(MessageKeys.APIEXCEPTION_FROM_TOKEN_REVIEW, e);
        LOGGER.exiting(null);
        return null;
    }
    LOGGER.fine(""Returned TokenReview"", result);
    V1TokenReviewStatus status = result != null ? result.getStatus() : null;
    LOGGER.exiting(status);
    return status;
}",check,oracle/kubernetes/operator/helpers/AuthenticationProxy.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/AuthenticationProxy.java,"/**
   * Check if the specified access token can be authenticated.
   *
   * @param principal The user, group or service account.
   * @param token The access token that identifies the user.
   * @param namespace Namespace
   * @return V1TokenReviewStatus containing either info about the authenticated user or an error
   *     explaining why the user couldn't be authenticated
   */",20-57,"('check', {'INSTRUCTION': {'covered': 55, 'missed': 14}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 12, 'missed': 5}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",167.0,10.0,Check if the specified access token can be authenticated.,The method verifies whether the specified access token can be authenticated. The method verifies whether the specified access token can be authenticated. Return V1TokenReviewStatus containing either info about the authenticated user or an error.,"If the access token can be verified, check it.",0.135052338432147,  Check if the specified access token can be authenticated.
118,jooby,"public static String unsign(@Nonnull final String value, @Nonnull final String secret){
    int sep = value.indexOf(""|"");
    if (sep <= 0) {
        return null;
    }
    String str = value.substring(sep + 1);
    return sign(str, secret).equals(value) ? str : null;
}",unsign,io/jooby/Cookie.java,/jooby/src/main/java/io/jooby/Cookie.java,"/**
   * Un-sign a value, previously signed with {@link #sign(String, String)}.
   * Produces a nonnull value or <code>null</code> for invalid.
   *
   * @param value A signed value.
   * @param secret A secret key.
   * @return A new signed value or null.
   */",464-479,"('unsign', {'INSTRUCTION': {'covered': 21, 'missed': 3}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,19.0,"Un-sign a value, previously signed with {@link #sign(String, String)}.","In this method an Un-sign a value, previously signed with {@link #sign(String, String)}, produces a nonnull value or <code>null</code> for invalid.","Un-sign a value that was previously signed with the @link #sign(String, String)",0.798209843641386,"  Unsign a value previously signed with {@link #sign(String, String)}."
119,cdk,"public IAtomContainer kekuliseAromaticRings(IAtomContainer molecule) throws CDKException{
    IAtomContainer mNew = null;
    try {
        mNew = (IAtomContainer) molecule.clone();
    } catch (Exception e) {
        throw new CDKException(""Failed to clone source molecule"");
    }
    IRingSet ringSet;
    try {
        ringSet = removeExtraRings(mNew);
    } catch (CDKException x) {
        throw x;
    } catch (Exception x) {
        throw new CDKException(""failure in SSSRFinder.findAllRings"", x);
    }
    if (ringSet == null) {
        throw new CDKException(""failure in SSSRFinder.findAllRings"");
    }
    // We need to establish which rings share bonds and set up sets of such interdependant rings
    List<Integer[]> rBondsArray = null;
    List<List<Integer>> ringGroups = null;
    // Start by getting a list (same dimensions and ordering as ringset) of all the ring bond numbers in the reduced ring set
    rBondsArray = getRingSystem(mNew, ringSet);
    // Now find out which share a bond and assign them accordingly to groups
    ringGroups = assignRingGroups(rBondsArray);
    // Loop through each group of rings checking all choices of double bond combis and seeing if you can get a
    // proper molecule.
    for (int i = 0; i < ringGroups.size(); i++) {
        // Set all ring bonds with single order to allow Matrix solving to work
        setAllRingBondsSingleOrder(ringGroups.get(i), ringSet);
        // Set up  lists of atoms, bonds and atom pairs for this ringGroup
        List<Integer> atomNos = null;
        atomNos = getAtomNosForRingGroup(mNew, ringGroups.get(i), ringSet);
        List<Integer> bondNos = null;
        bondNos = getBondNosForRingGroup(mNew, ringGroups.get(i), ringSet);
        // Array of same dimensions as bondNos (cols in Matrix)
        List<Integer[]> atomNoPairs = null;
        atomNoPairs = getAtomNoPairsForRingGroup(mNew, bondNos);
        // Set up ajacency Matrix
        Matrix M = new Matrix(atomNos.size(), bondNos.size());
        for (int x = 0; x < M.getRows(); x++) {
            for (int y = 0; y < M.getCols(); y++) {
                if (Objects.equals(atomNos.get(x), atomNoPairs.get(y)[0])) {
                    M.set(x, y, 1);
                } else {
                    if (Objects.equals(atomNos.get(x), atomNoPairs.get(y)[1])) {
                        M.set(x, y, 1);
                    } else {
                        M.set(x, y, 0);
                    }
                }
            }
        }
        // Array of same dimensions as atomNos (rows in Matrix)
        List<Integer> freeValencies = null;
        freeValencies = getFreeValenciesForRingGroup(mNew, atomNos, M, ringSet);
        // Array of ""answers""
        List<Integer> bondOrders = new ArrayList<Integer>();
        for (int j = 0; j < bondNos.size(); j++) {
            bondOrders.add(0);
        }
        if (solveMatrix(M, atomNos, bondNos, freeValencies, atomNoPairs, bondOrders)) {
            for (int j = 0; j < bondOrders.size(); j++) {
                mNew.getBond(bondNos.get(j)).setOrder(bondOrders.get(j) == 1 ? IBond.Order.SINGLE : IBond.Order.DOUBLE);
            }
        } else {
            // TODO Put any failure code here
        }
    }
    return mNew;
}",kekuliseAromaticRings,org/openscience/cdk/smiles/FixBondOrdersTool.java,/legacy/src/main/java/org/openscience/cdk/smiles/FixBondOrdersTool.java,"/**
     * kekuliseAromaticRings - function to add double/single bond order information for molecules having rings containing all atoms marked SP2 or Planar3 hybridisation.
     * @param molecule The {@link IAtomContainer} to kekulise
     * @return The {@link IAtomContainer} with kekule structure
     * @throws CDKException
     */",140-231,"('kekuliseAromaticRings', {'INSTRUCTION': {'covered': 211, 'missed': 21}, 'BRANCH': {'covered': 18, 'missed': 2}, 'LINE': {'covered': 36, 'missed': 7}, 'COMPLEXITY': {'covered': 9, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",527.0,22.0,kekuliseAromaticRings - function to add double/single bond order information for molecules having rings containing all atoms marked SP2 or Planar3 hybridisation.,kekuliseAromaticRings-function to add double/single bond order information for molecules that have rings that contain all atoms marked with SP2 or Planar3 hybridisation,The kekuliseAromaticRings function adds double/ single bond order information for the molecule with all the atoms marked Planar3 hybridisation.,1.03522879103686,kekuliseAromaticRings - function to add double/single bond order information for molecules with rings containing all atoms labeled SP2 or Hybridation Planar3.
120,weblogic-kubernetes-operator,"public static Step updateExporterSidecars(){
    return new Step() {

        @Override
        public NextAction apply(Packet packet) {
            return doNext(updateExportersWithConfiguration(packet), packet);
        }

        private Step updateExportersWithConfiguration(Packet packet) {
            final Collection<String> serverNames = getExporterEnabledServerNames(packet);
            if (serverNames.isEmpty()) {
                return getNext();
            } else {
                return Step.chain(SecretHelper.createAuthorizationSourceStep(), RunInParallel.perServer(serverNames, ConfigurationVerificationStartStep::new));
            }
        }

        private Collection<String> getExporterEnabledServerNames(Packet packet) {
            return getAllServerNames(packet).stream().filter(name -> hasExporterConfiguration(packet, name)).filter(name -> hasExporterSidecar(packet, name)).collect(Collectors.toList());
        }

        private Collection<String> getAllServerNames(Packet packet) {
            return DomainPresenceInfo.fromPacket(packet).map(DomainPresenceInfo::getServerNames).orElse(Collections.emptyList());
        }

        // Change this to handle per-cluster configuration
        @SuppressWarnings(""unused"")
        private boolean hasExporterConfiguration(Packet packet, String serverName) {
            return DomainPresenceInfo.fromPacket(packet).map(DomainPresenceInfo::getDomain).map(Domain::getMonitoringExporterConfiguration).isPresent();
        }

        private boolean hasExporterSidecar(Packet packet, String serverName) {
            return DomainPresenceInfo.fromPacket(packet).map(dpi -> dpi.getServerPod(serverName)).map(this::hasExporterSidecar).orElse(false);
        }

        private boolean hasExporterSidecar(V1Pod pod) {
            return Optional.ofNullable(pod).map(V1Pod::getSpec).map(V1PodSpec::getContainers).orElse(Collections.emptyList()).stream().anyMatch(c -> c.getName().equals(KubernetesConstants.EXPORTER_CONTAINER_NAME));
        }
    };
}",updateExporterSidecars,oracle/kubernetes/operator/steps/MonitoringExporterSteps.java,/operator/src/main/java/oracle/kubernetes/operator/steps/MonitoringExporterSteps.java,"/**
   * Creates a step to initiate processing for all servers in the domain for which a configuration is defined,
   * checking the configuration of each exporter sidecar and updating it if necessary.
   *
   * Expects packet to contain DomainPresenceInfo and:
   *     DOMAIN_TOPOLOGY              the domain configuration
   *     AUTHORIZATION_HEADER_FACTORY a factory to create an http authentication header
   */",44-107,"('updateExporterSidecars', {'INSTRUCTION': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",340.0,32.0,"Creates a step to initiate processing for all servers in the domain for which a configuration is defined,  checking the configuration of each exporter sidecar and updating it if necessary.","It allows the creation of a pass to start processing all servers in the domain, checking, if defined, the configuration of each export sidecar and updating it if necessary.","If necessary, it creates a step to initiate exporter processing for all the server in the domain that has a configuration defined.",0.332139534007904,"  Creates a step to start processing all servers in the domain for which a configuration is defined, checking the configuration of each exporting sidecar and updating it as needed."
121,cdk,"private static boolean addIsotopeDist(IMolecularFormula mf, IIsotope[] isotopes, int idx, int count){
    if (count == 0)
        return true;
    double frac = 100d;
    for (int i = 0; i < idx; i++) frac -= isotopes[i].getNaturalAbundance();
    double p = isotopes[idx].getNaturalAbundance() / frac;
    if (p >= 1.0) {
        mf.addIsotope(isotopes[idx], count);
        return true;
    }
    double kMin = (count + 1) * (1 - p) - 1;
    double kMax = (count + 1) * (1 - p);
    if ((int) Math.ceil(kMin) == (int) Math.floor(kMax)) {
        int k = (int) kMax;
        mf.addIsotope(isotopes[idx], count - k);
        return addIsotopeDist(mf, isotopes, idx + 1, k);
    }
    return false;
}",addIsotopeDist,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * Helper method for adding isotope distributions to a MF. The method adds
     * a distribution of isotopes by splitting the set of isotopes in two,
     * the one under consideration (specified by 'idx') and the remaining to be
     * considered ('&gt;idx'). The inflection point is calculate as 'k'
     * &le 'count' isotopes added. If there are remaining isotopes the method
     * calls it's self with 'idx+1' and 'count := k'.
     *
     * @param mf       the molecular formula to update
     * @param isotopes the isotopes, sorted most abundance to least
     * @param idx      which isotope we're currently considering
     * @param count    the number of isotopes remaining to select from
     * @return the distribution is unique (or not)
     */",1581-1619,"('addIsotopeDist', {'INSTRUCTION': {'covered': 89, 'missed': 2}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 15, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",192.0,10.0,Helper method for adding isotope distributions to a MF.,Method for adding isotope distributions to an MF. The method adds an isotope distribution by dividing the set of isotopes into two parts.,Adding isotope to distributions is a method of adding.,0.470706541913815,  A helper method for adding isotopic distributions to an MF.
122,cdk,"public Point3d[] calculate3DCoordinates2(Point3d aPoint, Point3d bPoint, Point3d cPoint, int nwanted, double length, double angle){
    Point3d[] newPoints = new Point3d[0];
    double ang2 = angle / 2.0;
    Vector3d ba = new Vector3d(aPoint);
    ba.sub(bPoint);
    Vector3d ca = new Vector3d(aPoint);
    ca.sub(cPoint);
    Vector3d baxca = new Vector3d();
    baxca.cross(ba, ca);
    if (baxca.length() < 0.00000001) {
        ;
    } else if (nwanted == 1) {
        newPoints = new Point3d[1];
        Vector3d ax = new Vector3d(ba);
        ax.add(ca);
        ax.normalize();
        ax.scale(length);
        newPoints[0] = new Point3d(aPoint);
        newPoints[0].add(ax);
    } else if (nwanted >= 2) {
        newPoints = new Point3d[2];
        Vector3d ax = new Vector3d(ba);
        ax.add(ca);
        ax.normalize();
        baxca.normalize();
        baxca.scale(Math.sin(ang2) * length);
        ax.scale(Math.cos(ang2) * length);
        newPoints[0] = new Point3d(aPoint);
        newPoints[0].add(ax);
        newPoints[0].add(baxca);
        newPoints[1] = new Point3d(aPoint);
        newPoints[1].add(ax);
        newPoints[1].sub(baxca);
    }
    baxca = null;
    ba = null;
    ca = null;
    return newPoints;
}",calculate3DCoordinates2,org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,"/**
     *  Calculate new point(s) X in a B-A-C system, it forms a B-A(-C)-X
     *  system. (2) 2 ligands(B, C) of refAtom A (i) 1 points required; vector in
     *  ABC plane bisecting AB, AC. If ABC is linear, no points (ii) 2 points: 2
     *  points X1, X2, X1-A-X2 = angle about 2i vector
     *
     *@param  aPoint   to which substituents are added
     *@param  bPoint   first ligand of A
     *@param  cPoint   second ligand of A
     *@param  nwanted  number of points to calculate (1-2)
     *@param  length   A-X length
     *@param  angle    B-A-X angle
     *@return          Point3d[] nwanted points (or zero if failed)
     */",438-494,"('calculate3DCoordinates2', {'INSTRUCTION': {'covered': 111, 'missed': 30}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 28, 'missed': 7}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",323.0,22.0,"Calculate new point(s) X in a B-A-C system, it forms a B-A(-C)-X  system.",This method calculates new points X by taking three points in a B-A-C system as input and forms a system B-A(-C)-X,A B-A-C system is formed by calculating new point(s) X.,0.443697550121469,"  Calculate new X points in a B-A-C system, it forms a B-A(-C)-X system."
123,dcache,"private void updateEarliestChildExpiryDate(Date newDate){
    if (newDate == null) {
        return;
    }
    if (_earliestChildExpiry == null || newDate.before(_earliestChildExpiry)) {
        _earliestChildExpiry = newDate;
    }
}",updateEarliestChildExpiryDate,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,"/**
     * Possibly update our belief of the earliest time that a Mortal child StateComponent will
     * expire.  It is safe to call this method with all child Dates: it will update the
     * _earliestChildExpiry Date correctly.
     *
     * @param newDate the expiry Date of a Mortal child StateComponent
     */",109-124,"('updateEarliestChildExpiryDate', {'INSTRUCTION': {'covered': 14, 'missed': 1}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,16.0,Possibly update our belief of the earliest time that a Mortal child StateComponent will  expire., It will eventually update the belief about the earliest time a StateComponent child of Mortal will expire,We believe that a child will expire at the earliest time.,0.372941056204372,  Perhaps update our belief the first time that a deadly child StateComponent will expire.
124,openapi-generator,"private Set<Map<String, String>> toImportsObjects(Map<String, String> mappedImports){
    Set<Map<String, String>> result = new TreeSet<Map<String, String>>((Comparator<Map<String, String>>) (o1, o2) -> {
        String s1 = o1.get(""classname"");
        String s2 = o2.get(""classname"");
        return s1.compareTo(s2);
    });
    mappedImports.entrySet().forEach(mapping -> {
        Map<String, String> im = new LinkedHashMap<>();
        im.put(""import"", mapping.getKey());
        im.put(""classname"", mapping.getValue());
        result.add(im);
    });
    return result;
}",toImportsObjects,org/openapitools/codegen/DefaultGenerator.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java,"/**
     * Using an import map created via {@link #getAllImportsMappings(Set)} to build a list import objects.
     * The import objects have two keys: import and classname which hold the key and value of the initial map entry.
     *
     * @param mappedImports Map of fully qualified import and import
     * @return The set of unique imports
     */",1234-1257,"('toImportsObjects', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",158.0,22.0,Using an import map created via {@link #getAllImportsMappings(Set)} to build a list import objects.,The map created via {@link#getAllImportsMappings(Set)} is used to construct a list of import objects. Import objects have two keys: they contain the key and the value of the initial map entry.,"To build a list import objects, you need an import map created via @link #getAllImportsMappings(Set).",0.746702768106061,  Using an import card created through {@link #getAllImportsMappings(Set)} to create a list of import objects.
125,egeria,"public Optional<EntityDetail> findCollectionEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, COLLECTION_TYPE_NAME);
}",findCollectionEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCollectionHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCollectionHandler.java,"/**
     * Find out if the Transformation Project object is already stored in the repository as a Collection. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",92-108,"('findCollectionEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,17.0,Find out if the Transformation Project object is already stored in the repository as a Collection.,Allows you to check whether the transformation project object is stored in the repository as a Collection. It uses the fully qualified name to retrieve the entity.,"If the Transformation Project object is already in the repository, you can find out if it is a collection.",0.258108744478671,  Find out if the Transformation Project object is already stored in the repository as a collection.
126,cdk,"boolean feasible(int n, int m){
    // verify atom semantic feasibility
    if (!atomMatcher.matches(container1.getAtom(n), container2.getAtom(m)))
        return false;
    // unmapped terminal vertices n and m are adjacent to
    int nTerminal1 = 0, nTerminal2 = 0;
    // unmapped non-terminal (remaining) vertices n and m are adjacent to
    int nRemain1 = 0, nRemain2 = 0;
    // 0-look-ahead: check each adjacent edge for being mapped, and count
    // terminal or remaining
    for (int n_prime : g1[n]) {
        int m_prime = m1[n_prime];
        // v is already mapped, there should be an edge {m, w} in g2.
        if (m_prime != UNMAPPED) {
            IBond bond2 = bonds2.get(m, m_prime);
            // the bond is not present in the target
            if (bond2 == null)
                return false;
            // verify bond semantic feasibility
            if (!bondMatcher.matches(bonds1.get(n, n_prime), bond2))
                return false;
        } else {
            if (t1[n_prime] > 0)
                nTerminal1++;
            else
                nRemain1++;
        }
    }
    // 0-look-ahead: check each adjacent edge for being mapped, and count
    // terminal or remaining
    for (int m_prime : g2[m]) {
        int n_prime = m2[m_prime];
        if (n_prime != UNMAPPED) {
            IBond bond1 = bonds1.get(n, n_prime);
            // the bond is not present in the query
            if (bond1 == null)
                return false;
            // verify bond semantic feasibility
            if (!bondMatcher.matches(bond1, bonds2.get(m, m_prime)))
                return false;
        } else {
            if (t2[m_prime] > 0)
                nTerminal2++;
            else
                nRemain2++;
        }
    }
    // 1-look-ahead : the mapping {n, m} is feasible iff the number of
    // terminal vertices (t1) adjacent to n is equal to the
    // number of terminal vertices (t2) adjacent to m.
    // 
    // 2-look-ahead: the mapping {n, m} is feasible iff the number of
    // vertices adjacent to n that are neither in m1 or t1 is equal to
    // the number of the number of vertices adjacent to m that are neither
    // in m2 or t2.
    return nTerminal1 == nTerminal2 && nRemain1 == nRemain2;
}",feasible,org/openscience/cdk/isomorphism/VFState.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/VFState.java,"/**
     * Check the feasibility of the candidate pair {n, m}. A candidate pair is
     * syntactically feasible iff all k-look-ahead rules hold. These look ahead
     * rules check adjacency relation of the mapping. If an edge is mapped in g1
     * it should also be mapped in g2 and vise-versa (0-look-ahead). If an edge
     * in g1 is unmapped but the edge is adjacent to an another mapped vertex
     * (terminal) then the number of such edges should be equal in g1 compared
     * to g2 (1-look-ahead). If the edge is unmapped and non-terminal then the
     * number of such edges should be equal in g1 compared to g2 (2-look-ahead).
     * 
     *
     * @param n a candidate vertex from g1
     * @param m a candidate vertex from g2
     * @return the mapping is feasible
     */",86-160,"('feasible', {'INSTRUCTION': {'covered': 144, 'missed': 4}, 'BRANCH': {'covered': 24, 'missed': 2}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 12, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",243.0,13.0,"Check the feasibility of the candidate pair {n, m}.","Checks the feasibility of the candidate pair {n, m}. If all k-look-ahead rules are valid a candidate pair is syntactically feasible. The adjacency relation of the mapping is checked by the look-ahead rules.",The feasibility of the candidate pair is checked.,0.102795181592992,"  Check the feasibility of the candidate pair {n, m}."
127,tablesaw,"public Table sampleX(double proportion){
    Preconditions.checkArgument(proportion <= 1 && proportion >= 0, ""The sample proportion must be between 0 and 1"");
    int tableSize = (int) Math.round(rowCount() * proportion);
    return where(selectNRowsAtRandom(tableSize, rowCount()));
}",sampleX,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,"/**
   * Returns a table consisting of randomly selected records from this table. The sample size is
   * based on the given proportion
   *
   * @param proportion The proportion to go in the sample
   */",553-565,"('sampleX', {'INSTRUCTION': {'covered': 27, 'missed': 1}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,12.0,Returns a table consisting of randomly selected records from this table.,"Returns a table from randomly selected records. Based on the given proportion, the sample size is defined.",A table consisting of randomly selected records is returned.,0.390648568971858,  Returns a table consisting of randomly selected records from that table.
128,acs-aem-commons,"protected final void sendEmail(final List<HealthCheckExecutionResult> success, final List<HealthCheckExecutionResult> failure, final long timeTaken){
    final ProductInfo[] productInfos = productInfoService.getInfos();
    final String hostname = getHostname();
    final Map<String, String> emailParams = new HashMap<>();
    emailParams.put(""subject"", String.format(""%s [ %d Failures ] [ %d Success ] [ %s ]"", emailSubject, failure.size(), success.size(), hostname));
    emailParams.put(""failure"", resultToPlainText(""Failing Health Checks"", failure));
    emailParams.put(""success"", resultToPlainText(""Successful Health Checks"", success));
    emailParams.put(""executedAt"", Calendar.getInstance().getTime().toString());
    emailParams.put(""runModes"", StringUtils.join(slingSettingsService.getRunModes(), "", ""));
    emailParams.put(""mode"", ModeUtil.isAuthor() ? ""Author"" : ""Publish"");
    emailParams.put(""hostname"", hostname);
    emailParams.put(""timeTaken"", String.valueOf(timeTaken));
    if (productInfos.length == 1) {
        emailParams.put(""productName"", productInfos[0].getShortName());
        emailParams.put(""productVersion"", productInfos[0].getShortVersion());
    }
    emailParams.put(""successCount"", String.valueOf(success.size()));
    emailParams.put(""failureCount"", String.valueOf(failure.size()));
    emailParams.put(""totalCount"", String.valueOf(failure.size() + success.size()));
    if (ArrayUtils.isNotEmpty(recipientEmailAddresses)) {
        final List<String> failureList = emailService.sendEmail(emailTemplatePath, emailParams, recipientEmailAddresses);
        if (failureList.size() > 0) {
            log.warn(""Could not send health status check e-mails to recipients [ {} ]"", StringUtils.join(failureList, "", ""));
        } else {
            log.info(""Successfully sent Health Check email to [ {} ] recipients"", recipientEmailAddresses.length - failureList.size());
        }
    } else {
        log.warn(""No e-mail addresses provided to e-mail results of health checks. Either add the appropriate e-mail recipients or remove the health check status e-mail configuration entirely."");
    }
}",sendEmail,com/adobe/acs/commons/hc/impl/HealthCheckStatusEmailer.java,/bundle/src/main/java/com/adobe/acs/commons/hc/impl/HealthCheckStatusEmailer.java,"/**
     * Creates the e-mail template parameter map and invokes the OSGi E-Mail Service.
     *
     * @param success the list of successful Health Check Execution Results
     * @param failure the list of unsuccessful Health Check Execution Results
     * @param timeTaken the time taken to execute all Health Checks
     */",218-260,"('sendEmail', {'INSTRUCTION': {'covered': 162, 'missed': 12}, 'BRANCH': {'covered': 4, 'missed': 4}, 'LINE': {'covered': 23, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",389.0,13.0,Creates the e-mail template parameter map and invokes the OSGi E-Mail Service.,Call up the OSGi e-mail service and enable the creation of the e-mail template parameter map.,The OSGi E-Mail Service is invoked after the creation of the e-mail template.,0.460517130364482,  Creates the e-mail template parameter mapping and calls the OSGi e-mail service.
130,cdk,"private double hydrogenXDodge(int hydrogens, int mass, TextOutline elementLabel, TextOutline hydrogenLabel, TextOutline hydrogenCount, TextOutline massLabel){
    if (mass < 0 && hydrogens > 1) {
        return (elementLabel.getBounds().getMinX() - padding) - hydrogenCount.getBounds().getMaxX();
    } else if (mass >= 0) {
        if (hydrogens > 1) {
            return (massLabel.getBounds().getMinX() + padding) - hydrogenCount.getBounds().getMaxX();
        } else if (hydrogens > 0) {
            return (massLabel.getBounds().getMinX() - padding) - hydrogenLabel.getBounds().getMaxX();
        }
    }
    return 0;
}",hydrogenXDodge,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,"/**
     * If the hydrogens are position in from of the element we may need to move the hydrogen and
     * hydrogen count labels. This code assesses the positions of the mass, hydrogen, and hydrogen
     * count labels and determines the x-axis adjustment needed for the hydrogen label to dodge a
     * collision.
     *
     * @param hydrogens     number of hydrogens
     * @param mass          atomic mass
     * @param elementLabel  element label outline
     * @param hydrogenLabel hydrogen label outline
     * @param hydrogenCount hydrogen count label outline
     * @param massLabel     the mass label outline
     * @return required adjustment to x-axis
     */",543-569,"('hydrogenXDodge', {'INSTRUCTION': {'covered': 47, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",140.0,22.0,If the hydrogens are position in from of the element we may need to move the hydrogen and  hydrogen count labels.,"This method evaluates the positions of the mass, hydrogen and hydrogen count labels to determine the x-axis adjustment required for the hydrogen label to avoid a collision. ",We may need to change the hydrogen and hydrogen count labels if the hydrogens are in the element.,0.530275911447373,"  If the hydrogens are positioned from the element, we may need to move the hydrogen and hydrogen counting labels."
131,acs-aem-commons,"protected final Optional<Resource> merge(final Resource resource, final String destination, final Collection<String> sources, final Class<T> typeHint, final boolean allowDuplicates) throws PersistenceException{
    ResourceResolver rr = resource.getResourceResolver();
    @SuppressWarnings(""unchecked"")
    final T[] emptyArray = (T[]) Array.newInstance(typeHint, 0);
    Collection<T> collectedValues;
    if (allowDuplicates) {
        collectedValues = new ArrayList<>();
    } else {
        collectedValues = new LinkedHashSet<>();
    }
    for (final String source : sources) {
        Resource sourceProperties = resource;
        String sourceParam = source;
        if (source.contains(""/"")) {
            sourceParam = StringUtils.substringAfterLast(source, ""/"");
            sourceProperties = rr.getResource(resource, StringUtils.substringBeforeLast(source, ""/""));
        }
        T[] tmp = sourceProperties.adaptTo(ModifiableValueMap.class).get(sourceParam, emptyArray);
        collectedValues.addAll(Arrays.asList(tmp));
    }
    Resource targetResource = resource;
    String targetProperty = destination;
    if (destination.contains(""/"")) {
        targetProperty = StringUtils.substringAfterLast(destination, ""/"");
        targetResource = rr.getResource(resource, StringUtils.substringBeforeLast(destination, ""/""));
    }
    ModifiableValueMap targetProperties = targetResource.adaptTo(ModifiableValueMap.class);
    final T[] currentValues = targetProperties.get(targetProperty, emptyArray);
    if (!collectedValues.equals(Arrays.asList(currentValues))) {
        targetProperties.put(targetProperty, collectedValues.toArray(emptyArray));
        return Optional.of(targetResource);
    } else {
        return Optional.empty();
    }
}",merge,com/adobe/acs/commons/wcm/impl/PropertyMergePostProcessor.java,/bundle/src/main/java/com/adobe/acs/commons/wcm/impl/PropertyMergePostProcessor.java,"/**
     * Merges the values found in the the source properties into the destination
     * property as a multi-value. The values of the source properties and
     * destination properties must all be the same property type.
     *
     * The unique set of properties will be stored in
     *
     * @param resource the resource to look for the source and destination
     * properties on
     * @param destination the property to store the collected properties.
     * @param sources the properties to collect values from for merging
     * @param typeHint the data type that should be used when reading and
     * storing the data
     * @param allowDuplicates true to allow duplicates values in the destination
     * property; false to make values unique
     * @return Optional resource updated, if any
     */",214-277,"('merge', {'INSTRUCTION': {'covered': 108, 'missed': 2}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 24, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",324.0,17.0,Merges the values found in the the source properties into the destination  property as a multi-value.,The values found in the source property in the target property as multi-value are merged.,The source properties are combined into the destination property as multi-value.,0.175622139220299,  Merges the values found in the source properties into the destination property as a multiple value.
132,dcache,"public CellMessage clone(){
    try {
        CellMessage copy = (CellMessage) super.clone();
        copy._destination = _destination.clone();
        if (_source != null) {
            copy._source = _source.clone();
        }
        copy._messageStream = _messageStream;
        return copy;
    } catch (CloneNotSupportedException e) {
        throw new RuntimeException(e);
    }
}",clone,dmg/cells/nucleus/CellMessage.java,/modules/cells/src/main/java/dmg/cells/nucleus/CellMessage.java,"/**
     * The method does not copy the message object - only the encoded message stream (if any).
     */",217-233,"('clone', {'INSTRUCTION': {'covered': 23, 'missed': 6}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",73.0,19.0,The method does not copy the message object - only the encoded message stream (if any).,"The method only copies the encoded message stream, if any, and does not copy the message object.",The method only uses the message stream as a reference.,0.326491299031426,  The method does not copy the message object - only the encoded message flow (if any).
133,cdk,"public static BitSet decode(String enc){
    byte[] fp = base64Decode(enc);
    if (fp.length < 4) {
        throw new IllegalArgumentException(""Input is not a proper PubChem base64 encoded fingerprint"");
    }
    int len = (fp[0] << 24) | (fp[1] << 16) | (fp[2] << 8) | (fp[3] & 0xff);
    if (len != FP_SIZE) {
        throw new IllegalArgumentException(""Input is not a proper PubChem base64 encoded fingerprint"");
    }
    PubchemFingerprinter pc = new PubchemFingerprinter(null);
    for (int i = 0; i < pc.m_bits.length; ++i) {
        pc.m_bits[i] = fp[i + 4];
    }
    BitSet ret = new BitSet(FP_SIZE);
    for (int i = 0; i < FP_SIZE; i++) {
        if (pc.isBitOn(i))
            ret.set(i);
    }
    return ret;
}",decode,org/openscience/cdk/fingerprint/PubchemFingerprinter.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/PubchemFingerprinter.java,"/**
     * Returns a fingerprint from a Base64 encoded Pubchem fingerprint.
     *
     * @param enc The Base64 encoded fingerprint
     * @return A BitSet corresponding to the input fingerprint
     */",346-375,"('decode', {'INSTRUCTION': {'covered': 83, 'missed': 5}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 12, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",178.0,10.0,Returns a fingerprint from a Base64 encoded Pubchem fingerprint.,From a Base64-encoded fingerprint Pubchem returns a fingerprint,A Base64 encoded Pubchem fingerprints is returned.,0.698329562209862,Returns a fingerprint from a Base64-encoded Pubchem fingerprint.
134,dataverse,"public static boolean isPubliclyDownloadable(FileMetadata fileMetadata){
    if (fileMetadata == null) {
        return false;
    }
    if (fileMetadata.isRestricted()) {
        String msg = ""Not publicly downloadable because the file is restricted."";
        logger.fine(msg);
        return false;
    }
    if (isActivelyEmbargoed(fileMetadata)) {
        return false;
    }
    boolean popupReasons = isDownloadPopupRequired(fileMetadata.getDatasetVersion());
    if (popupReasons == true) {
        return false;
    }
    return true;
}",isPubliclyDownloadable,edu/harvard/iq/dataverse/util/FileUtil.java,/src/main/java/edu/harvard/iq/dataverse/util/FileUtil.java,"/**
     * Provide download URL if no Terms of Use, no guestbook, and not
     * restricted.
     */",1542-1585,"('isPubliclyDownloadable', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,16.0,"Provide download URL if no Terms of Use, no guestbook, and not  restricted.","If there Terms of Use, no guestbook, and not restricted, please provide the URL for downloading.","If there are no Terms of Use, no guestbook, and no download URL, then provide one.",0.405122984056609,"  Provide the download URL if there are no terms of use, no guestbook and no restrictions."
135,egeria,"public int hashCode(){
    return Objects.hash(getType(), getInstanceProvenanceType(), getMetadataCollectionId(), getMetadataCollectionName(), getInstanceLicense(), getCreatedBy(), getUpdatedBy(), getCreateTime(), getMaintainedBy(), getUpdateTime(), getVersion(), getStatus(), getStatusOnDelete(), getMappingProperties());
}",hashCode,org/odpi/openmetadata/repositoryservices/connectors/stores/metadatacollectionstore/properties/instances/InstanceAuditHeader.java,/open-metadata-implementation/repository-services/repository-services-apis/src/main/java/org/odpi/openmetadata/repositoryservices/connectors/stores/metadatacollectionstore/properties/instances/InstanceAuditHeader.java,"/**
     * Return a hash code based on the values of this object.
     *
     * @return in hash code
     */",590-602,"('hashCode', {'INSTRUCTION': {'covered': 75, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,12.0,Return a hash code based on the values of this object.,Returns a hash code based on the values of this object,Return a code based on the values of the object.,0.310345741624581,  Return a hash code based on the values of this object.
136,weblogic-kubernetes-operator,"boolean verifyMachinesConfigured(String machineNamePrefix, int numMachinesNeeded){
    if (wlsDomainConfig != null && machineNamePrefix != null) {
        for (int suffix = 1; suffix <= numMachinesNeeded; suffix++) {
            if (wlsDomainConfig.getMachineConfig(machineNamePrefix + suffix) == null) {
                return false;
            }
        }
    }
    return true;
}",verifyMachinesConfigured,oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,"/**
   * Verify whether the WebLogic domain already has all the machines configured for use by the
   * dynamic cluster. For example, if machineNamePrefix is ""domain1-cluster1-machine"" and
   * numMachinesNeeded is 2, this method return true if machines named ""domain1-cluster1-machine1""
   * and ""domain1-cluster1-machine2"" are configured in the WebLogic domain.
   *
   * @param machineNamePrefix Prefix of the names of the machines
   * @param numMachinesNeeded Number of machines needed for this dynamic cluster
   * @return True if the WebLogic domain already has all the machines configured, or if there is no
   *     WlsDomainConfig object associated with this cluster, in which case we cannot perform the
   *     verification, or if machineNamePrefix is null, false otherwise
   */",290-311,"('verifyMachinesConfigured', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,18.0,Verify whether the WebLogic domain already has all the machines configured for use by the  dynamic cluster.,Checks whether all machines configured to use the dynamic cluster have the WebLogic domain,"If the WebLogic domain already has all the machines configured for use, you should check it.",0.591292943260742,  Check if the WebLogic domain already has all the machines configured for use by the dynamic cluster.
138,jeromq," boolean checkForChanges(){
    final Map<File, byte[]> presents = new HashMap<>(fingerprints);
    boolean modified = traverseDirectory(location, new IFileVisitor() {

        @Override
        public boolean visitFile(File file) {
            return modified(presents.remove(file), file);
        }

        @Override
        public boolean visitDir(File dir) {
            return modified(presents.remove(dir), dir);
        }
    });
    return modified || !presents.isEmpty();
}",checkForChanges,org/zeromq/ZCertStore.java,/src/main/java/org/zeromq/ZCertStore.java,"/**
     * Check if files in the certificate folders have been added or removed.
     */",270-293,"('checkForChanges', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",98.0,13.0,Check if files in the certificate folders have been added or removed.,The following method allows you to check whether files in the certificate folders have been added or removed.,"If there are files in the certificate folders that have been added or removed, you should check them.",0.128931130721899,  Check if any files in the certificate folders have been added or removed.
139,cdk,"public StereoEncoder create(IAtomContainer container, int[][] graph){
    // XXX: this code isn't pretty, the current IAtomContainer
    // implementations are  slow for the queries (i.e. looking at connected
    // atoms/bonds) we need to ask to decide if something is a potential
    // tetrahedral centre. We can help out a little with the adjacency list
    // (int[][]) but this doesn't help with the bonds.
    int n = container.getAtomCount();
    List<StereoEncoder> encoders = new ArrayList<StereoEncoder>();
    Map<IAtom, Integer> elevation = new HashMap<IAtom, Integer>(10);
    ATOMS: for (int i = 0; i < n; i++) {
        int degree = graph[i].length;
        // ignore those which don't have 3 or 4 neighbors
        if (degree < 3 || degree > 4)
            continue;
        IAtom atom = container.getAtom(i);
        // only create encoders for SP3 hybridized atom. atom typing is
        // currently wrong for some atoms, in sulfoxide for example the atom
        // type sets SP2... but there we don't to fuss about with that here
        if (!sp3(atom))
            continue;
        // avoid nitrogen-inversion
        if (Integer.valueOf(7).equals(atom.getAtomicNumber()) && degree == 3)
            continue;
        // TODO: we could be more strict with our selection, InChI uses C,
        // Si, Ge, P, As, B, Sn, N, P, S, Se but has preconditions for
        // certain cases. An atom or ion N, P, As, S or Se is not stereogenic
        // if it has a terminal H or two terminal neighbors -XHm, -XHn (n+m>0)
        // where X is O, S, Se, Te, or N
        // XXX: likely bottle neck
        List<IBond> bonds = container.getConnectedBondsList(atom);
        // try to create geometric parity
        GeometricParity geometric = geometric(elevation, bonds, i, graph[i], container);
        if (geometric != null) {
            // add a new encoder if a geometric parity
            encoders.add(new GeometryEncoder(i, new BasicPermutationParity(graph[i]), geometric));
        }
    }
    // no encoders, replace with the empty encoder
    return encoders.isEmpty() ? StereoEncoder.EMPTY : new MultiStereoEncoder(encoders);
}",create,org/openscience/cdk/hash/stereo/GeometricTetrahedralEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricTetrahedralEncoderFactory.java,"/**
     * Create a stereo encoder for all potential 2D and 3D tetrahedral
     * elements.
     *
     * @param container an atom container
     * @param graph     adjacency list representation of the container
     * @return a new encoder for tetrahedral elements
     */",54-113,"('create', {'INSTRUCTION': {'covered': 83, 'missed': 5}, 'BRANCH': {'covered': 12, 'missed': 4}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",221.0,13.0,Create a stereo encoder for all potential 2D and 3D tetrahedral  elements.,For all potential 2D and 3D tetrahedral elements create a stereo encoder,A stereo Encoder is needed for all potential 2D and 3D elements.,0.251114903825953,Create a stereo encoder for all potential 2D and 3D tetrahedral elements.
140,jackson-databind,"public byte[] binaryValue() throws IOException{
    if (_value instanceof byte[]) {
        return (byte[]) _value;
    }
    return super.binaryValue();
}",binaryValue,com/fasterxml/jackson/databind/node/POJONode.java,/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java,"/**
     * As it is possible that some implementations embed byte[] as POJONode
     * (despite optimal being {@link BinaryNode}), let's add support for exposing
     * binary data here too.
     */",36-48,"('binaryValue', {'INSTRUCTION': {'covered': 8, 'missed': 3}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,35.0,"As it is possible that some implementations embed byte[] as POJONode  (despite optimal being {@link BinaryNode}), let's add support for exposing  binary data here too.","We add support for exposing binary data as it is possible for some implementations to incorporate byte[] as POJONode ( despite the fact that {@link BinaryNode} is optimal),",It is possible that some implementations will add support for exposing data in the form of POJONode.,1.11090718020103,"  As it is possible that some implementations integrate byte[] as POJONode (although the optimal is {@link BinaryNode}), let's add here also support for binary data exposure."
141,cdk,"private boolean isAmide(IAtom atom0, IAtom atom1, IAtomContainer ac){
    if (atom0.getAtomicNumber() == IElement.C && atom1.getAtomicNumber() == IElement.N) {
        for (IAtom neighbor : ac.getConnectedAtomsList(atom0)) {
            if (neighbor.getAtomicNumber() == IElement.O && ac.getBond(atom0, neighbor).getOrder() == Order.DOUBLE) {
                return true;
            }
        }
    }
    return false;
}",isAmide,org/openscience/cdk/qsar/descriptors/molecular/RotatableBondsCountDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/RotatableBondsCountDescriptor.java,"/**
     * Checks whether both atoms are involved in an amide C-N bond: *N(*)C(*)=O.
     *
     * Only the most common constitution is considered. Tautomeric, O\C(*)=N\*,
     * and charged forms, [O-]\C(*)=N\*, are ignored.
     *
     * @param atom0 the first bonding partner
     * @param atom1 the second bonding partner
     * @param ac the parent container
     *
     * @return if both partners are involved in an amide C-N bond
     */",192-215,"('isAmide', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",90.0,20.0,Checks whether both atoms are involved in an amide C-N bond: N()C()=O.,It allows one to check whether both atoms are involved in a C-N amide bond: *N(*)C(*)=O.,"The N is for ""N is involved in an amide C-N bond.""",0.63936359819647,  Checks whether the two atoms are involved in an amide bond C-N: N()C()=O.
142,weblogic-kubernetes-operator,"private static ParsedJson parseJson(String jsonString){
    ObjectMapper mapper = new ObjectMapper();
    try {
        ParsedJson parsedJson = new ParsedJson();
        Map result = mapper.readValue(jsonString, Map.class);
        parsedJson.domainName = (String) result.get(""name"");
        parsedJson.adminServerName = (String) result.get(""adminServerName"");
        Map servers = (Map<String, Object>) result.get(""servers"");
        if (servers != null) {
            parsedJson.servers = (List<Map<String, Object>>) servers.get(""items"");
        }
        Map serverTemplates = (Map<String, Object>) result.get(""serverTemplates"");
        if (serverTemplates != null) {
            parsedJson.serverTemplates = (List<Map<String, Object>>) serverTemplates.get(""items"");
        }
        Map clusters = (Map<String, Object>) result.get(""clusters"");
        if (clusters != null) {
            parsedJson.clusters = (List<Map<String, Object>>) clusters.get(""items"");
        }
        Map machines = (Map<String, Object>) result.get(""machines"");
        if (machines != null) {
            parsedJson.machines = (List<Map<String, Object>>) machines.get(""items"");
        }
        return parsedJson;
    } catch (Exception e) {
        LOGGER.warning(MessageKeys.JSON_PARSING_FAILED, jsonString, e.getMessage());
    }
    return null;
}",parseJson,oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,"/**
   * Parse the json string containing WLS configuration and return a list containing a map of
   * (server attribute name, attribute value).
   *
   * @param jsonString JSON string containing WLS configuration to be parsed
   * @return a ParsedJson object containing WebLogic domain configuration by parsing the given JSON
   *     string
   */",165-202,"('parseJson', {'INSTRUCTION': {'covered': 80, 'missed': 17}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 3}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",293.0,24.0,"Parse the json string containing WLS configuration and return a list containing a map of  (server attribute name, attribute value).","Returns a list containing a map of (server attribute name, attribute value) after parsing the json string containing the WLS configuration",Parse the json string and return a list with a map.,0.508266634349763,"  Parse the json string containing the WLS configuration and return a list containing a map of (server attribute name, attribute value)."
143,logstash-logback-encoder,"protected PatternLayoutAdapter<Event> buildLayout(String format){
    PatternLayoutAdapter<Event> adapter = new PatternLayoutAdapter<>(createLayout());
    adapter.setPattern(format);
    adapter.setContext(context);
    adapter.start();
    return adapter;
}",buildLayout,net/logstash/logback/pattern/AbstractJsonPatternParser.java,/src/main/java/net/logstash/logback/pattern/AbstractJsonPatternParser.java,"/**
     * Initialize a PatternLayout with the supplied format and throw an {@link IllegalArgumentException}
     * if the format is invalid.
     * 
     * @param format the pattern layout format
     * @return a configured and started {@link PatternLayoutAdapter} instance around the supplied format
     * @throws IllegalArgumentException if the supplied format is not a valid PatternLayout
     */",212-227,"('buildLayout', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,21.0,Initialize a PatternLayout with the supplied format and throw an {@link IllegalArgumentException}  if the format is invalid.,"From the provided format, it initialises a PatternLayout and throws a {@link IllegalArgumentException} if the format is invalid.","If the format is invalid, throw an IllegalArgumentException if the pattern is created.",2.42343002799508,  Initialize a PatternLayout with the format provided and run a {@link IllegalArgumentException} if the format is invalid.
144,anserini,"public static String convertLuceneDocidToDocid(IndexReader reader, int docid){
    if (docid >= reader.maxDoc())
        return null;
    try {
        return reader.document(docid).get(IndexArgs.ID);
    } catch (IOException e) {
        return null;
    }
}",convertLuceneDocidToDocid,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,"/**
   * Converts a Lucene internal docid to a collection docid.
   *
   * @param reader index reader
   * @param docid Lucene internal docid
   * @return corresponding collection docid, or <code>null</code> if not found.
   */",757-774,"('convertLuceneDocidToDocid', {'INSTRUCTION': {'covered': 12, 'missed': 3}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,10.0,Converts a Lucene internal docid to a collection docid.,A collection docid is converted into an internal Lucene docid,A collection docid is converted to a Lucene internal docid.,0.808480929669891,  Converts an internal Lucene docid to a collection docid.
145,cdk,"public IRenderingElement generateCompactElement(IAtom atom, RendererModel model){
    Point2d point = atom.getPoint2d();
    double radius = (Double) model.get(AtomRadius.class) / model.getParameter(Scale.class).getValue();
    double distance = 2 * radius;
    if (model.get(CompactShape.class) == Shape.SQUARE) {
        return new RectangleElement(point.x - radius, point.y - radius, distance, distance, true, getAtomColor(atom, model));
    } else {
        return new OvalElement(point.x, point.y, radius, true, getAtomColor(atom, model));
    }
}",generateCompactElement,org/openscience/cdk/renderer/generators/BasicAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/BasicAtomGenerator.java,"/**
     * Generate a compact element for an atom, such as a circle or a square,
     * rather than text element.
     *
     * @param atom the atom to generate the compact element for
     * @param model the renderer model
     * @return a compact rendering element
     */",333-351,"('generateCompactElement', {'INSTRUCTION': {'covered': 59, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",130.0,21.0,"Generate a compact element for an atom, such as a circle or a square,  rather than text element.","Instead of a text element for an atom, a compact element such as a circle or square is generated",A circle or square is a better fit for an atom than a text element.,0.700671400207211,"  Generate a compact element for an atom, such as a circle or square, rather than a text element."
147,matsim-libs,"public E poll(){
    E minValue;
    if (isEmpty())
        return null;
    else {
        this.modCount++;
        minValue = data[0];
        if (classicalRemove) {
            data[0] = data[heapSize - 1];
            costs[0] = costs[heapSize - 1];
            indices[this.getIndex(data[0])] = 0;
            indices[this.getIndex(minValue)] = -1;
            heapSize--;
            if (heapSize > 0)
                siftDown(0);
        } else {
            siftDownUp(0);
            indices[this.getIndex(minValue)] = -1;
        }
        return minValue;
    }
}",poll,org/matsim/core/router/priorityqueue/BinaryMinHeap.java,/matsim/src/main/java/org/matsim/core/router/priorityqueue/BinaryMinHeap.java,"/**
         * Retrieves and removes the head of this queue, or <tt>null</tt> if this
         * queue is empty.
         * 
         * @return the head of this queue, or <tt>null</tt> if this queue is empty.
         */",151-179,"('poll', {'INSTRUCTION': {'covered': 83, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",130.0,23.0,"Retrieves and removes the head of this queue, or <tt>null</tt> if this  queue is empty.","The head of this queue is retrieved and removed, otherwise returns <tt>null</tt> if this queue is empty.","If the queue is empty, you can retrieve and remove the head of it.",0.412031528381004,"  Retrieves and deletes the header from this queue, or <tt>null</tt> if this queue is empty."
148,egeria,"private Optional<EntityDetail> findDatabaseSchemaEntity(String userId, String qualifiedName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, DEPLOYED_DATABASE_SCHEMA_TYPE_NAME);
}",findDatabaseSchemaEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineRelationalDataHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineRelationalDataHandler.java,"/**
     * Find out if the DatabaseSchema object is already stored in the repository.
     * It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the database schema to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",166-182,"('findDatabaseSchemaEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,13.0,Find out if the DatabaseSchema object is already stored in the repository.,"Discovers whether the DatabaseSchema object is already stored in the repository.  To retrieve the entity, use the full name","If the database object is already in the repository, you should find it.",0.155385203559939,  Verify that the DatabaseSchema object is already stored in the repository.
149,liquibase,"protected boolean supportsSortingObjects(Database database){
    return (database instanceof AbstractDb2Database) || (database instanceof MSSQLDatabase) || (database instanceof OracleDatabase) || database instanceof PostgresDatabase;
}",supportsSortingObjects,liquibase/diff/output/changelog/DiffToChangeLog.java,/liquibase-core/src/main/java/liquibase/diff/output/changelog/DiffToChangeLog.java,"/**
     * Used by {@link #sortMissingObjects(Collection, Database)} to determine whether to go into the sorting logic.
     */",487-493,"('supportsSortingObjects', {'INSTRUCTION': {'covered': 14, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 4}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,23.0,"Used by {@link #sortMissingObjects(Collection, Database)} to determine whether to go into the sorting logic.","To determine whether to go into the sorting logic used by {@link #sortMissingObjects(Collection, Database)}",The use of the #sortMissingObjects to determine whether to go into the sorting logic was used by @link.,1.05887834297401,"  Used by {@link #sortMissingObjects(Collection, Database)} to determine whether to enter the sort logic."
151,tablesaw," static Selection withoutRange(int totalRangeStart, int totalRangeEnd, int excludedRangeStart, int excludedRangeEnd){
    return BitmapBackedSelection.withoutRange(totalRangeStart, totalRangeEnd, excludedRangeStart, excludedRangeEnd);
}",withoutRange,tech/tablesaw/selection/Selection.java,/core/src/main/java/tech/tablesaw/selection/Selection.java,"/**
   * Returns a Selection containing all values from totalRangeStart to totalRangeEnd, except for
   * those in the range from excludedRangeStart to excludedRangeEnd. Start values are inclusive, end
   * values exclusive.
   */",108-117,"('withoutRange', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,22.0,"Returns a Selection containing all values from totalRangeStart to totalRangeEnd, except for  those in the range from excludedRangeStart to excludedRangeEnd.","All values from totalRangeStart to totalRangeEnd except those in the range excludedRangeStart to excludedRangeEnd are returned in a selection. Start values are included, end values excluded.","The selection contains values from totalRangeStart to totalRangeEnd, except for those in the range from excludedRangeStart to excludedRangeEnd.",0.961275903059573,"  Returns a selection containing all values from totalRangeStart to totalRangeEnd, except those between excludedRangeStart and excludedRangeEnd."
152,weblogic-kubernetes-operator,"public synchronized boolean containsServer(String serverName){
    if (!isNullOrEmpty(serverName)) {
        return getServers().stream().anyMatch(s -> serverName.equals(s.getName())) || getConfiguredClusters().stream().anyMatch(c -> c.containsServer(serverName));
    }
    return false;
}",containsServer,oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,"/**
   * Whether the WebLogic domain contains a server with the given server name,
   * including standalone servers, and servers that belong to a configured or dynamic cluster.
   *
   * @param serverName server name to be checked
   * @return True if the WebLogic domain contains a server with the given server name
   */",353-366,"('containsServer', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",68.0,28.0,"Whether the WebLogic domain contains a server with the given server name,  including standalone servers, and servers that belong to a configured or dynamic cluster.","The following method returns True if the WebLogic domain contains a server with the given server name, including independent servers and those belonging to a configured or dynamic cluster.",The server name of the server in the WebLogic domain can include the server that is a part of a configured or dynamic cluster.,0.764851472234447,"  If the WebLogic domain contains a server with the given server name, including stand-alone servers and servers belonging to a configured or dynamic cluster."
153,cdk,"public LigancyFourChirality project(ILigand[] newOrder){
    ITetrahedralChirality.Stereo newStereo = this.stereo;
    ILigand[] newAtoms = new ILigand[4];
    System.arraycopy(this.ligands, 0, newAtoms, 0, 4);
    for (int i = 0; i < 3; i++) {
        if (!newAtoms[i].getLigandAtom().equals(newOrder[i].getLigandAtom())) {
            for (int j = i; j < 4; j++) {
                if (newAtoms[j].getLigandAtom().equals(newOrder[i].getLigandAtom())) {
                    swap(newAtoms, i, j);
                    if (newStereo == Stereo.CLOCKWISE) {
                        newStereo = Stereo.ANTI_CLOCKWISE;
                    } else {
                        newStereo = Stereo.CLOCKWISE;
                    }
                }
            }
        }
    }
    return new LigancyFourChirality(chiralAtom, newAtoms, newStereo);
}",project,org/openscience/cdk/geometry/cip/LigancyFourChirality.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/LigancyFourChirality.java,"/**
     * Recalculates the {@link LigancyFourChirality} based on the new, given atom ordering.
     *
     * @param newOrder new order of atoms
     * @return the chirality following the new atom order
     */",117-149,"('project', {'INSTRUCTION': {'covered': 68, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",176.0,16.0,"Recalculates the {@link LigancyFourChirality} based on the new, given atom ordering.",Based on the new ordering of atoms Recalculates the {@link LigancyFourChirality},The @link Ligancy FourChirality is calculated based on the new atom ordering.,1.75341208847306,  Recalculates the {@link LigancyFourChirality} according to the new order of atoms given.
154,logstash-logback-encoder,"private void appendRootCauseFirst(StringBuilder builder, String prefix, int indent, IThrowableProxy throwableProxy, Deque<String> stackHashes){
    if (throwableProxy == null || builder.length() > maxLength) {
        return;
    }
    if (throwableProxy.getCause() != null) {
        appendRootCauseFirst(builder, prefix, indent, throwableProxy.getCause(), stackHashes);
        prefix = CoreConstants.WRAPPED_BY;
    }
    String hash = stackHashes == null || stackHashes.isEmpty() ? null : stackHashes.removeLast();
    appendFirstLine(builder, prefix, indent, throwableProxy, hash);
    appendStackTraceElements(builder, indent, throwableProxy);
    IThrowableProxy[] suppressedThrowableProxies = throwableProxy.getSuppressed();
    if (suppressedThrowableProxies != null) {
        for (IThrowableProxy suppressedThrowableProxy : suppressedThrowableProxies) {
            appendRootCauseFirst(builder, CoreConstants.SUPPRESSED, indent + ThrowableProxyUtil.SUPPRESSED_EXCEPTION_INDENT, suppressedThrowableProxy, null);
        }
    }
}",appendRootCauseFirst,net/logstash/logback/stacktrace/ShortenedThrowableConverter.java,/src/main/java/net/logstash/logback/stacktrace/ShortenedThrowableConverter.java,"/**
     * Appends a throwable and recursively appends its causedby/suppressed throwables
     * in ""reverse"" order (Root cause first).
     */",349-380,"('appendRootCauseFirst', {'INSTRUCTION': {'covered': 59, 'missed': 16}, 'BRANCH': {'covered': 9, 'missed': 5}, 'LINE': {'covered': 11, 'missed': 2}, 'COMPLEXITY': {'covered': 3, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",167.0,20.0,"Appends a throwable and recursively appends its causedby/suppressed throwables  in ""reverse"" order (Root cause first).","It applies a throwable and recursively its caused/deleted throwables in ""reverse"" sequence (root cause first).",Appends a throwable and then reverses it in order.,1.96092468411286,"  Adds a disposable and recursively adds its caused/deleted disposables in ""reverse"" order (first cause first)."
155,egeria,"protected Optional<Relationship> findRelationship(String userId, String firstGUID, String secondGUID, String firstEntityTypeName, String relationshipTypeName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    final String methodName = ""findRelationship"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateName(firstGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    invalidParameterHandler.validateName(secondGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    TypeDef relationshipTypeDef = repositoryHelper.getTypeDefByName(userId, relationshipTypeName);
    Relationship relationshipBetweenEntities = repositoryHandler.getRelationshipBetweenEntities(userId, firstGUID, firstEntityTypeName, secondGUID, relationshipTypeDef.getGUID(), relationshipTypeDef.getName(), methodName);
    if (relationshipBetweenEntities == null) {
        return Optional.empty();
    }
    if (firstGUID.equalsIgnoreCase(relationshipBetweenEntities.getEntityOneProxy().getGUID()) && secondGUID.equalsIgnoreCase(relationshipBetweenEntities.getEntityTwoProxy().getGUID())) {
        return Optional.of(relationshipBetweenEntities);
    }
    return Optional.empty();
}",findRelationship,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCommonHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCommonHandler.java,"/**
     * Find out if the relationship is already stored in the repository.
     * It will search for relationships that have the source firstGUID and target secondGUID
     *
     * @param userId               the name of the calling user
     * @param firstGUID            the unique identifier of the entity at first end
     * @param secondGUID           the unique identifier of the entity at second end
     * @param relationshipTypeName type name for the relationship to create
     * @param firstEntityTypeName  type name for the entity at first end
     *
     * @return The found relationship or an empty Optional
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",269-309,"('findRelationship', {'INSTRUCTION': {'covered': 57, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 12, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",177.0,12.0,Find out if the relationship is already stored in the repository.,Finds out whether the relation is already stored in the repository. It searches for relationships where the source is the firstGUID and the destination is the secondGUID.,"If the relationship is already in the repository, you should find out.",0.210287073468003,  Check if the relationship is already stored in the repository.
156,mybatis-3,"protected static T invoke(Method method, Object object, Object... parameters) throws IOException, RuntimeException{
    try {
        return (T) method.invoke(object, parameters);
    } catch (IllegalArgumentException | IllegalAccessException e) {
        throw new RuntimeException(e);
    } catch (InvocationTargetException e) {
        if (e.getTargetException() instanceof IOException) {
            throw (IOException) e.getTargetException();
        } else {
            throw new RuntimeException(e);
        }
    }
}",invoke,org/apache/ibatis/io/VFS.java,/src/main/java/org/apache/ibatis/io/VFS.java,"/**
   * Invoke a method on an object and return whatever it returns.
   *
   * @param <T>
   *          the generic type
   * @param method
   *          The method to invoke.
   * @param object
   *          The instance or class (for static methods) on which to invoke the method.
   * @param parameters
   *          The parameters to pass to the method.
   * @return Whatever the method returns.
   * @throws IOException
   *           If I/O errors occur
   * @throws RuntimeException
   *           If anything else goes wrong
   */",148-179,"('invoke', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,12.0,Invoke a method on an object and return whatever it returns.,Allows a method to be invoked on an object and return what it returns.,Return whatever it returns by using a method on an object.,0.612226970540833,  Call a method on an object and return what it returns.
157,dcache,"private static List<AuthorisationSupplier> parseScope(String claim) throws InvalidScopeException{
    return Splitter.on(' ').trimResults().splitToList(claim).stream().map(SciTokenPlugin::resolveScope).filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());
}",parseScope,org/dcache/gplazma/scitoken/SciTokenPlugin.java,/modules/gplazma2-scitoken/src/main/java/org/dcache/gplazma/scitoken/SciTokenPlugin.java,"/**
     * Parse the ""scope"" claim and extract all SciToken or WLCG Profile scopes.
     */",184-194,"('parseScope', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,15.0,"Parse the ""scope"" claim and extract all SciToken or WLCG Profile scopes.",Following the analysis of the request 'scope' and extract all SciToken scopes or WLCG Profiles.,"Parse the ""scope"" claim and extract the scope.",0.680151029985872,  Analyze the scope claim and extract all SciToken or WLCG Profile scopes.
158,openapi-generator,"private void flattenComposedChildren(OpenAPI openAPI, String key, List<Schema> children){
    if (children == null || children.isEmpty()) {
        return;
    }
    ListIterator<Schema> listIterator = children.listIterator();
    while (listIterator.hasNext()) {
        Schema component = listIterator.next();
        if ((component != null) && (component.get$ref() == null) && ((component.getProperties() != null && !component.getProperties().isEmpty()) || (component.getEnum() != null && !component.getEnum().isEmpty()))) {
            String innerModelName = resolveModelName(component.getTitle(), key);
            Schema innerModel = modelFromProperty(openAPI, component, innerModelName);
            String existing = matchGenerated(innerModel);
            if (existing == null) {
                openAPI.getComponents().addSchemas(innerModelName, innerModel);
                addGenerated(innerModelName, innerModel);
                Schema schema = new Schema().$ref(innerModelName);
                schema.setRequired(component.getRequired());
                listIterator.set(schema);
            } else {
                Schema schema = new Schema().$ref(existing);
                schema.setRequired(component.getRequired());
                listIterator.set(schema);
            }
        }
    }
}",flattenComposedChildren,org/openapitools/codegen/InlineModelResolver.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/InlineModelResolver.java,"/**
     * Flattens properties of inline object schemas that belong to a composed schema into a
     * single flat list of properties. This is useful to generate a single or multiple
     * inheritance model.
     *
     * In the example below, codegen may generate a 'Dog' class that extends from the
     * generated 'Animal' class. 'Dog' has additional properties 'name', 'age' and 'breed' that
     * are flattened as a single list of properties.
     *
     * Dog:
     *   allOf:
     *     - $ref: '#/components/schemas/Animal'
     *     - type: object
     *       properties:
     *         name:
     *           type: string
     *         age:
     *           type: string
     *     - type: object
     *       properties:
     *         breed:
     *           type: string
     *
     * @param openAPI the OpenAPI document
     * @param key a unique name ofr the composed schema.
     * @param children the list of nested schemas within a composed schema (allOf, anyOf, oneOf).
     */",348-412,"('flattenComposedChildren', {'INSTRUCTION': {'covered': 88, 'missed': 4}, 'BRANCH': {'covered': 14, 'missed': 6}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",256.0,20.0,Flattens properties of inline object schemas that belong to a composed schema into a  single flat list of properties.,The properties of inline object schemas that belong to a compound schema in a single flat list of properties are flattened. This allows the generation of an inheritance pattern,Flatten the properties of inline object schemas into a single list.,0.264267354911332,  Flattens the properties of inline object schemas that belong to a schema composed into a single flat list of properties.
159,cdk,"public static Order resource2Order(Resource rdfOrder){
    if (rdfOrder.equals(CDK.SINGLEBOND)) {
        return Order.SINGLE;
    } else if (rdfOrder.equals(CDK.DOUBLEBOND)) {
        return Order.DOUBLE;
    } else if (rdfOrder.equals(CDK.TRIPLEBOND)) {
        return Order.TRIPLE;
    } else if (rdfOrder.equals(CDK.QUADRUPLEBOND)) {
        return Order.QUADRUPLE;
    }
    return null;
}",resource2Order,org/openscience/cdk/libio/jena/Convertor.java,/storage/iordf/src/main/java/org/openscience/cdk/libio/jena/Convertor.java,"/**
     * Converts a {@link Resource} object into the matching {@link Order}.
     *
     * @param rdfOrder Resource for which the matching {@link Order} should be given.
     * @return the matching {@link Order}.
     */",253-270,"('resource2Order', {'INSTRUCTION': {'covered': 24, 'missed': 2}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,17.0,Converts a {@link Resource} object into the matching {@link Order}.,{@link Order} refers to the conversion of the corresponding {@link Resource} object.,The @link Resource object is converted into the matching @link Order.,0.808927411981844,  Converts an object to {@link Resource} to the corresponding {@link Order}.
160,dcache,"private static Set<String> toAttributes(String format){
    Set<String> attributes = new HashSet<>();
    Matcher matcher = ATTRIBUTE_PATTERN.matcher(format);
    while (matcher.find()) {
        String expression = matcher.group(1);
        if (!isIf(expression) && !isElse(expression) && !isEndIf(expression)) {
            int pos = expression.indexOf(';');
            attributes.add(pos > -1 ? expression.substring(0, pos) : expression);
        }
    }
    return attributes;
}",toAttributes,org/dcache/services/billing/text/BillingParserBuilder.java,/modules/dcache/src/main/java/org/dcache/services/billing/text/BillingParserBuilder.java,"/**
     * Returns names of all attributes in the provided billing format.
     */",263-277,"('toAttributes', {'INSTRUCTION': {'covered': 38, 'missed': 5}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",112.0,11.0,Returns names of all attributes in the provided billing format.,The names of all attributes are returned in the provided billing format,The names of all attributes are returned.,0.168007070870768,  Returns the names of all attributes in the billing format provided.
161,egeria,"protected void upsertExternalRelationship(String userId, String firstGUID, String secondGUID, String relationshipTypeName, String firstEntityTypeName, String externalSourceName, InstanceProperties relationshipProperties) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    final String methodName = ""upsertExternalRelationship"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateGUID(firstGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    invalidParameterHandler.validateGUID(secondGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    String externalSourceGUID = dataEngineRegistrationHandler.getExternalDataEngine(userId, externalSourceName);
    Optional<Relationship> relationship = findRelationship(userId, firstGUID, secondGUID, firstEntityTypeName, relationshipTypeName);
    if (relationship.isEmpty()) {
        TypeDef relationshipTypeDef = repositoryHelper.getTypeDefByName(userId, relationshipTypeName);
        repositoryHandler.createExternalRelationship(userId, relationshipTypeDef.getGUID(), externalSourceGUID, externalSourceName, firstGUID, secondGUID, relationshipProperties, methodName);
    } else {
        Relationship originalRelationship = relationship.get();
        RelationshipDifferences relationshipDifferences = repositoryHelper.getRelationshipDifferences(originalRelationship, buildRelationship(originalRelationship.getGUID(), relationshipProperties), true);
        if (relationshipDifferences.hasInstancePropertiesDifferences()) {
            repositoryHandler.updateRelationshipProperties(userId, externalSourceGUID, externalSourceName, originalRelationship.getGUID(), relationshipProperties, methodName);
        }
    }
}",upsertExternalRelationship,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCommonHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCommonHandler.java,"/**
     * Create or updates an external relationship between two entities. Verifies that the relationship is not present before creating it. If the
     * relationship is present, verifies the instanceProperties for the relationship to be updated.
     *
     * @param userId                 the name of the calling user
     * @param firstGUID              the unique identifier of the entity at first end
     * @param secondGUID             the unique identifier of the entity at second end
     * @param relationshipTypeName   type name for the relationship to create
     * @param firstEntityTypeName    type name for the entity at first end
     * @param externalSourceName     the unique name of the external source
     * @param relationshipProperties the properties for the relationship
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",221-267,"('upsertExternalRelationship', {'INSTRUCTION': {'covered': 84, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",218.0,10.0,Create or updates an external relationship between two entities.,"Updates or creates an external relation between two entities. Check before creating the relationship that it is not present. If the relationship is present, the instanceProperties of the relationship to be updated must be checked.",An external relationship between two entities can be created or updated.,0.257820566478949,  Create or update an external relationship between two entities.
162,cdk,"private int[] priority(int focus, IAtom[] atoms, int n){
    int[] rank = new int[n];
    for (int i = 0; i < n; i++) rank[i] = i;
    for (int j = 1; j < n; j++) {
        int v = rank[j];
        int i = j - 1;
        while ((i >= 0) && hasPriority(focus, atomToIndex.get(atoms[v]), atomToIndex.get(atoms[rank[i]]))) {
            rank[i + 1] = rank[i--];
        }
        rank[i + 1] = v;
    }
    return rank;
}",priority,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,"/**
     * Obtain a prioritised array where the indices 0 to n which correspond to
     * the provided {@code atoms}.
     *
     * @param focus focus of the tetrahedral atom
     * @param atoms the atom
     * @param n     number of atoms
     * @return prioritised indices
     */",1009-1031,"('priority', {'INSTRUCTION': {'covered': 71, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",145.0,21.0,Obtain a prioritised array where the indices 0 to n which correspond to  the provided {@code atoms}.,Get a priority array in which the indices from 0 to n corresponding to the {@code} atoms provided,The provided code atoms correspond to the indices 0 to n.,0.34847583143654,Obtain a hierarchical array where the indices 0 to n that correspond to the {@code atoms} provided.
163,cdk,"private IsotopePattern calculateAbundanceAndMass(IsotopePattern current, List<IsotopeContainer> additional){
    if (additional == null || additional.size() == 0)
        return current;
    List<IsotopeContainer> containers = new ArrayList<>();
    if (current == null) {
        current = new IsotopePattern();
        for (IsotopeContainer container : additional) current.addIsotope(container);
    } else {
        for (IsotopeContainer container : current.getIsotopes()) {
            for (IsotopeContainer other : additional) {
                double abundance = container.getIntensity() * other.getIntensity() * 0.01;
                double mass = container.getMass() + other.getMass();
                IsotopeContainer existing = findExisting(containers, mass, resolution);
                if (existing != null) {
                    double newIntensity = existing.getIntensity() + abundance;
                    existing.setMass((existing.getMass() * existing.getIntensity() + mass * abundance) / newIntensity);
                    existing.setIntensity(newIntensity);
                    if (storeFormula) {
                        for (IMolecularFormula mf : container.getFormulas()) addDistinctFormula(existing, union(mf, other.getFormula()));
                    }
                    continue;
                }
                if (abundance > minAbundance) {
                    IsotopeContainer newcontainer = new IsotopeContainer(mass, abundance);
                    if (storeFormula) {
                        for (IMolecularFormula mf : container.getFormulas()) newcontainer.addFormula(union(mf, other.getFormula()));
                    }
                    containers.add(newcontainer);
                }
            }
        }
        current = new IsotopePattern();
        for (IsotopeContainer container : containers) {
            current.addIsotope(container);
        }
    }
    return current;
}",calculateAbundanceAndMass,org/openscience/cdk/formula/IsotopePatternGenerator.java,/tool/formula/src/main/java/org/openscience/cdk/formula/IsotopePatternGenerator.java,"/**
     * Calculates the mass and abundance of all isotopes generated by adding one
     * atom. Receives the periodic table element and calculate the isotopes, if
     * there exist a previous calculation, add these new isotopes. In the
     * process of adding the new isotopes, remove those that has an abundance
     * less than setup parameter minIntensity, and remove duplicated masses.
     *
     * @param additional additional isotopes to 'multiple' the current pattern by
     * @return the calculation was successful
     */",190-252,"('calculateAbundanceAndMass', {'INSTRUCTION': {'covered': 177, 'missed': 2}, 'BRANCH': {'covered': 24, 'missed': 2}, 'LINE': {'covered': 31, 'missed': 0}, 'COMPLEXITY': {'covered': 12, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",314.0,14.0,Calculates the mass and abundance of all isotopes generated by adding one  atom.,"Calculate the mass and abundance of all isotopes obtained by adding an atom. It receives the element from the periodic table and calculates the isotopes; if a previous calculation exists, the new isotopes are added. In the process of adding new isotopes, those with an abundance below the minIntensity parameter are removed. It also removes duplicate masses.",Add one atom to the generated isotopes and calculate their mass and abundance.,0.375819125797711,  Calculates the mass and abundance of all isotopes generated by the addition of an atom.
164,cdk,"public static void percieveAtomTypesAndConfigureAtoms(IAtomContainer container) throws CDKException{
    CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.getInstance(container.getBuilder());
    for (IAtom atom : container.atoms()) {
        if (!(atom instanceof IPseudoAtom)) {
            IAtomType matched = matcher.findMatchingAtomType(container, atom);
            if (matched != null) {
                AtomTypeManipulator.configure(atom, matched);
            }
        }
    }
}",percieveAtomTypesAndConfigureAtoms,org/openscience/cdk/normalize/SMSDNormalizer.java,/legacy/src/main/java/org/openscience/cdk/normalize/SMSDNormalizer.java,"/**
     * Convenience method to perceive atom types for all <code>IAtom</code>s in the
     * <code>IAtomContainer</code>, using the <code>CDKAtomTypeMatcher</code>. If the
     * matcher finds atom matching atom type, the <code>IAtom</code> will be configured
     * to have the same properties as the <code>IAtomType</code>. If no matching atom
     * type is found, no configuration is performed.
     * @param container
     * @throws CDKException
     */",302-323,"('percieveAtomTypesAndConfigureAtoms', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",79.0,36.0,"Convenience method to perceive atom types for all <code>IAtom</code>s in the  <code>IAtomContainer</code>, using the <code>CDKAtomTypeMatcher</code>.","Metodo che consente la percezione dei tipi di atomo per tutti gli <code>IAtom</code>s in the <code>IAtomContainer</code> attraverso l'utilizzo di <code>CDKAtomTypeMatcher</code>. Nel caso in cui il matcher rileva un tipo di atomo corrispondente, le stesse proprieta' del tipo di atomo <code>IAtom</code> saranno configurate su <code>IAtomType</code>. Mentre non viene eseguita alcuna configurazione, nel caso in cui non viene trovato un tipo di atomo corrispondete ",The convenience method to perceive atom types is used.,1.14204701836919,"  A practical method for perceiving atom types for all <code>IAtom</code>s in <code>the IAtomContainer</code>, using the <code>CDKAtomTypeMatcher</code>."
165,cdk,"private static double deltavPhosphorous(IAtom atom, IAtomContainer atomContainer){
    if (atom.getAtomicNumber() != IElement.P)
        return -1;
    List<IAtom> connected = atomContainer.getConnectedAtomsList(atom);
    int conditions = 0;
    if (connected.size() == 4)
        conditions++;
    for (IAtom connectedAtom : connected) {
        if (connectedAtom.getAtomicNumber() == IElement.O && atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.DOUBLE)
            conditions++;
        if (atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.SINGLE)
            conditions++;
    }
    if (conditions == 5)
        return 2.22;
    return -1;
}",deltavPhosphorous,org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,"/**
     * Checks whether the P atom is in a PO environment.
     * 
     * This environment is noted in Kier & Hall (1986), page 20
     *
     * @param atom          The P atom in question
     * @param atomContainer The molecule containing the P atom
     * @return The empirical delta V if present in the above environment,
     *         -1 otherwise
     */",219-244,"('deltavPhosphorous', {'INSTRUCTION': {'covered': 53, 'missed': 4}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 10, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",140.0,11.0,Checks whether the P atom is in a PO environment.,See if the P atom is present in a PO environment.,The P atom is checked to see if it is in a PO environment.,0.260771379956401,  Checks whether the P atom is in a PO environment.
166,cdk,"public void fireChange(){
    if (getNotification() && listeners != null) {
        EventObject event = new EventObject(this);
        for (int i = 0; i < listeners.size(); i++) {
            listeners.get(i).stateChanged(event);
        }
    }
}",fireChange,org/openscience/cdk/renderer/RendererModel.java,/display/render/src/main/java/org/openscience/cdk/renderer/RendererModel.java,"/**
     * Notifies registered listeners of certain changes that have occurred in
     * this model.
     */",404-415,"('fireChange', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,13.0,Notifies registered listeners of certain changes that have occurred in  this model.,Notifying registered listeners of changes in this model,Changes that have occurred in this model have been notified to registered listeners.,0.221199632925599,  Notifies the saved listeners of certain changes that have occurred in this model.
168,tablesaw,"private Iterable<TableSlice> partition(){
    if (query.getPartitionColumns().isEmpty()) {
        return ImmutableList.of(new TableSlice(query.getTable()));
    }
    return query.getTable().splitOn(query.getPartitionColumns().toArray(new String[0]));
}",partition,tech/tablesaw/analytic/AnalyticQueryEngine.java,/core/src/main/java/tech/tablesaw/analytic/AnalyticQueryEngine.java,"/**
   * Partition the source table into a series of table slices. Does not modify the underlying table.
   */",140-148,"('partition', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,11.0,Partition the source table into a series of table slices.,The source table is split into a series of table slices. The underlying table is not modified.,The source table should be partitioned into slices.,0.367211584507255,  Partition the source table into a series of table slices.
169,cdk,"public List<Permutation> all(){
    final List<Permutation> permutations = new ArrayList<Permutation>();
    Backtracker counter = new Backtracker() {

        @Override
        public void applyTo(Permutation p) {
            permutations.add(p);
        }

        @Override
        public boolean isFinished() {
            return false;
        }
    };
    this.apply(counter);
    return permutations;
}",all,org/openscience/cdk/group/PermutationGroup.java,/tool/group/src/main/java/org/openscience/cdk/group/PermutationGroup.java,"/**
     * Generate the whole group from the compact list of permutations.
     *
     * @return a list of permutations
     */",303-324,"('all', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,11.0,Generate the whole group from the compact list of permutations.,From the compact list of permutations generate the entire group,The whole group can be generated from the compact list of permutations.,0.468012925408487,  Generate the entire group from the compact list of swaps.
170,cdk,"public static IAtomContainer model2Molecule(Model model, IChemObjectBuilder builder){
    ResIterator mols = model.listSubjectsWithProperty(RDF.type, CDK.MOLECULE);
    IAtomContainer mol = null;
    if (mols.hasNext()) {
        Resource rdfMol = mols.next();
        mol = builder.newInstance(IAtomContainer.class);
        Map<Resource, IAtom> rdfToCDKAtomMap = new HashMap<Resource, IAtom>();
        StmtIterator atoms = rdfMol.listProperties(CDK.HASATOM);
        while (atoms.hasNext()) {
            Resource rdfAtom = atoms.nextStatement().getResource();
            IAtom atom;
            if (rdfAtom.hasProperty(RDF.type, CDK.PSEUDOATOM)) {
                atom = builder.newInstance(IPseudoAtom.class);
                atom.setStereoParity(0);
                Statement label = rdfAtom.getProperty(CDK.HASLABEL);
                if (label != null)
                    ((IPseudoAtom) atom).setLabel(label.getString());
            } else {
                atom = builder.newInstance(IAtom.class);
            }
            Statement symbol = rdfAtom.getProperty(CDK.SYMBOL);
            if (symbol != null)
                atom.setSymbol(symbol.getString());
            rdfToCDKAtomMap.put(rdfAtom, atom);
            deserializeAtomTypeFields(rdfAtom, atom);
            mol.addAtom(atom);
        }
        StmtIterator bonds = rdfMol.listProperties(CDK.HASBOND);
        while (bonds.hasNext()) {
            Resource rdfBond = bonds.nextStatement().getResource();
            IBond bond = builder.newInstance(IBond.class);
            StmtIterator bondAtoms = rdfBond.listProperties(CDK.BINDSATOM);
            int atomCounter = 0;
            while (bondAtoms.hasNext()) {
                Statement rdfAtom = bondAtoms.nextStatement();
                IAtom atom = rdfToCDKAtomMap.get(rdfAtom.getResource());
                bond.setAtom(atom, atomCounter);
                atomCounter++;
            }
            Resource order = rdfBond.getProperty(CDK.HASORDER).getResource();
            bond.setOrder(resource2Order(order));
            mol.addBond(bond);
            deserializeElectronContainerFields(rdfBond, bond);
        }
    }
    return mol;
}",model2Molecule,org/openscience/cdk/libio/jena/Convertor.java,/storage/iordf/src/main/java/org/openscience/cdk/libio/jena/Convertor.java,"/**
     * Converts a {@link Model} into an {@link IAtomContainer} using the given {@link IChemObjectBuilder}.
     *
     * @param model RDF graph to deserialize into an {@link IAtomContainer}.
     * @param builder {@link IChemObjectBuilder} used to create new {@link IChemObject}s.
     * @return a {@link IAtomContainer} deserialized from the RDF graph.
     */",306-357,"('model2Molecule', {'INSTRUCTION': {'covered': 153, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 40, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",407.0,23.0,Converts a {@link Model} into an {@link IAtomContainer} using the given {@link IChemObjectBuilder}.,Using the {@link IChemObjectBuilder} given converts a {@link Model} to a {@link IAtomContainer},The model is converted into an IAtomContainer using the given IChemObjectBuilder.,0.346444615143087,  Converts a {@link Model} to {@link IAtomContainer} using the given {@link IChemObjectBuilder}.
171,acs-aem-commons,"private boolean doesRequestMatch(SlingHttpServletRequest request){
    WCMMode wcmMode = WCMMode.fromRequest(request);
    if (wcmMode != null && wcmMode != WCMMode.DISABLED) {
        log.trace(""Request in author mode: {}, no redirection."", wcmMode);
        return false;
    }
    String method = request.getMethod();
    if (!getMethods().contains(method)) {
        log.trace(""Request method [{}] does not match any of {}."", method, methods);
        return false;
    }
    String ext = request.getRequestPathInfo().getExtension();
    if (ext != null && !getExtensions().isEmpty() && !getExtensions().contains(ext)) {
        log.trace(""Request extension [{}] does not match any of {}."", ext, exts);
        return false;
    }
    String resourcePath = request.getRequestPathInfo().getResourcePath();
    boolean matches = getPaths().isEmpty() || getPaths().stream().anyMatch(p -> resourcePath.startsWith(p + ""/""));
    if (!matches) {
        log.trace(""Request path [{}] not within any of {}."", resourcePath, paths);
        return false;
    }
    return true;
}",doesRequestMatch,com/adobe/acs/commons/redirects/filter/RedirectFilter.java,/bundle/src/main/java/com/adobe/acs/commons/redirects/filter/RedirectFilter.java,"/**
     * Check whether redirection for the given request is allowed.
     * <ol>
     * <li>On author redirects are disabled in EDIT, PREVIEW and DESIGN WCM Modes.
     * To test on author you need to disable WCM mode and append &wcmmode=disabled
     * to the query string</li>
     * <li>Redirects are supported only for GET and HEAD methods</li>
     * This can be changed in the OSGi configuration</li>
     * <li>If configured, redirects are allowed only for the specified extensions,
     * e.g. only *.html requests will be redirected. Same path with .json extension
     * will <i>not</i> be redirected. This feature is disabled by default.</li>
     * </ol>
     *
     * @param request the request to check
     * @return whether redirection for the given is allowed
     */",486-528,"('doesRequestMatch', {'INSTRUCTION': {'covered': 84, 'missed': 0}, 'BRANCH': {'covered': 15, 'missed': 3}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",206.0,10.0,Check whether redirection for the given request is allowed.,"Check whether redirection is permitted for the given request. In WCM EDIT, PREVIEW and DESIGN modes, redirects to author are disabled. In order to test on author, it is necessary to disable the WCM mode and add &wcmmode=disabled to the query string. In addition, redirects are only supported for GET and HEAD methods. If configured, redirects are only allowed for the specified extensions. By default, this function is disabled.",Check if the given request is allowed to be diverted.,0.332636186599137,  Check if redirection for the given request is allowed.
172,cdk,"public Iterable<IMapping> mappings(){
    return new Iterable<IMapping>() {

        @Override
        public Iterator<IMapping> iterator() {
            return new MappingIterator();
        }
    };
}",mappings,org/openscience/cdk/Reaction.java,/base/data/src/main/java/org/openscience/cdk/Reaction.java,"/**
     * Returns the mappings between the reactant and the product side.
     *
     * @return An Iterator to the Mappings.
     * @see    #addMapping
     */",168-183,"('mappings', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,11.0,Returns the mappings between the reactant and the product side.,"Between the reagent side and the product side, mappings are returned",The mappings between the reactant and the product side are returned.,0.418501292167985,  Returns the mappings between the reagent and the product side.
173,liquibase,"public SqlStatement[] generateStatements(Database database){
    List<SqlStatement> returnStatements = new ArrayList<>();
    String sql = StringUtil.trimToNull(getSql());
    if (sql == null) {
        return new SqlStatement[0];
    }
    String processedSQL = normalizeLineEndings(sql);
    if (this instanceof RawSQLChange && ((RawSQLChange) this).isRerunnable()) {
        returnStatements.add(new RawSqlStatement(processedSQL, getEndDelimiter()));
        return returnStatements.toArray(new SqlStatement[returnStatements.size()]);
    }
    for (String statement : StringUtil.processMultiLineSQL(processedSQL, isStripComments(), isSplitStatements(), getEndDelimiter())) {
        if (database instanceof MSSQLDatabase) {
            statement = statement.replaceAll(""\\n"", ""\r\n"");
        }
        String escapedStatement = statement;
        try {
            if (database.getConnection() != null) {
                escapedStatement = database.getConnection().nativeSQL(statement);
            }
        } catch (DatabaseException e) {
            escapedStatement = statement;
        }
        returnStatements.add(new RawSqlStatement(escapedStatement, getEndDelimiter()));
    }
    return returnStatements.toArray(new SqlStatement[returnStatements.size()]);
}",generateStatements,liquibase/change/AbstractSQLChange.java,/liquibase-core/src/main/java/liquibase/change/AbstractSQLChange.java,"/**
     * Generates one or more SqlStatements depending on how the SQL should be parsed.
     * If split statements is set to true then the SQL is split and each command is made into a separate SqlStatement.
     * <p></p>
     * If stripping comments is true then any comments are removed before the splitting is executed.
     * The set SQL is passed through the {@link java.sql.Connection#nativeSQL} method if a connection is available.
     */",216-256,"('generateStatements', {'INSTRUCTION': {'covered': 84, 'missed': 19}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 15, 'missed': 4}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",229.0,14.0,Generates one or more SqlStatements depending on how the SQL should be parsed.,"Depending on how the SQL is to be analysed, it generates one or more SqlStatements. SQL is split and each command is turned into a separate SqlStatement if split statements is set to true.  Comments are removed before the split statement is executed if the stripping of comments is true. If a connection is available the SQL set is passed through the method {@link java.sql.Connection#nativeSQL}","Depending on how the SQL should be read, one or more SqlStatements can be generated.",0.229453054082421,  Generates one or more SqlStatements based on how sql should be parsed.
174,cdk,"public String toCanonicalSignatureString(int height){
    String canonicalSignature = null;
    for (int i = 0; i < getVertexCount(); i++) {
        String signatureForI = signatureStringForVertex(i, height);
        if (canonicalSignature == null || canonicalSignature.compareTo(signatureForI) < 0) {
            canonicalSignature = signatureForI;
        }
    }
    return canonicalSignature;
}",toCanonicalSignatureString,org/openscience/cdk/signature/MoleculeSignature.java,/descriptor/signature/src/main/java/org/openscience/cdk/signature/MoleculeSignature.java,"/**
     * Make a canonical signature string of a given height.
     *
     * @param height the maximum height to make signatures
     * @return the canonical signature string
     */",186-201,"('toCanonicalSignatureString', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,10.0,Make a canonical signature string of a given height.,"From a given height, it creates a canonical signature string",A signature string of a height.,0.181131475591323,  Create a canonical signature string of a given height.
175,cdk,"private static GeometryEncoder encoder(ITetrahedralChirality tc, Map<IAtom, Integer> atomToIndex){
    IAtom[] ligands = tc.getLigands();
    int centre = atomToIndex.get(tc.getChiralAtom());
    int[] indices = new int[4];
    int offset = -1;
    for (int i = 0; i < ligands.length; i++) {
        indices[i] = atomToIndex.get(ligands[i]);
        if (indices[i] == centre)
            offset = i;
    }
    int parity = tc.getStereo() == CLOCKWISE ? -1 : 1;
    if (offset >= 0) {
        for (int i = offset; i < indices.length - 1; i++) {
            indices[i] = indices[i + 1];
        }
        if (Integer.lowestOneBit(3 - offset) == 0x1)
            parity *= -1;
        indices = Arrays.copyOf(indices, indices.length - 1);
    }
    return new GeometryEncoder(centre, new BasicPermutationParity(indices), GeometricParity.valueOf(parity));
}",encoder,org/openscience/cdk/hash/stereo/TetrahedralElementEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/TetrahedralElementEncoderFactory.java,"/**
     * Create an encoder for the {@link ITetrahedralChirality} element.
     *
     * @param tc          stereo element from an atom container
     * @param atomToIndex map of atoms to indices
     * @return a new geometry encoder
     */",73-118,"('encoder', {'INSTRUCTION': {'covered': 96, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",215.0,12.0,Create an encoder for the {@link ITetrahedralChirality} element.,For the {@link ITetrahedralChirality} element create an encoder,The @link ITetrahedralChirality element has an Encoder.,1.17261735531017,  Create an encoder for the {@link ITetrahedralChirality} element.
176,cdk,"public static boolean containsElement(IMolecularFormula formula, IElement element){
    for (IIsotope isotope : formula.isotopes()) {
        if (element.getSymbol().equals(isotope.getSymbol()))
            return true;
    }
    return false;
}",containsElement,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * True, if the MolecularFormula contains the given element as IIsotope object.
     *
     * @param  formula   IMolecularFormula molecularFormula
     * @param  element   The element this MolecularFormula is searched for
     * @return           True, if the MolecularFormula contains the given element object
     */",190-204,"('containsElement', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",49.0,13.0,"True, if the MolecularFormula contains the given element as IIsotope object.","If the MolecularFormula contains the element given as the IIsotope object, the method returns true.","If the element is an IIsotope object, it's true.",0.293965138251268,"  True, if molecularFormula contains the given element as an IIsotope object."
177,cdk,"public static IsotopePattern sortByMass(IsotopePattern isotopeP){
    try {
        IsotopePattern isoSort = (IsotopePattern) isotopeP.clone();
        if (isoSort.getNumberOfIsotopes() == 0)
            return isoSort;
        List<IsotopeContainer> listISO = isoSort.getIsotopes();
        Collections.sort(listISO, new Comparator<IsotopeContainer>() {

            @Override
            public int compare(IsotopeContainer o1, IsotopeContainer o2) {
                return Double.compare(o1.getMass(), o2.getMass());
            }
        });
        isoSort.setMonoIsotope(listISO.get(0));
        return isoSort;
    } catch (CloneNotSupportedException e) {
        e.printStackTrace();
    }
    return null;
}",sortByMass,org/openscience/cdk/formula/IsotopePatternManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/formula/IsotopePatternManipulator.java,"/**
     * Return the isotope pattern sorted by mass
     * to the highest abundance.
     *
     * @param isotopeP  The IsotopePattern object to sort
     * @return          The IsotopePattern sorted
     */",106-140,"('sortByMass', {'INSTRUCTION': {'covered': 23, 'missed': 7}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 4}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",130.0,12.0,Return the isotope pattern sorted by mass  to the highest abundance.,The isotope pattern sorted by mass at maximum abundance is returned.,The pattern of the isotope is sorted by mass.,0.784389204413977,  Restore the highest abundance of the mass-sorted isotopic pattern.
178,matsim-libs,"private double calculateRouteDistanceWithAssociatedPickup(JobInsertionContext context){
    double routeDistance = 0;
    int positionOfRelatedPickup = context.getRelatedActivityContext().getInsertionIndex();
    int nextRouteActivity = 0;
    // checks if the associated pickup is on first position
    if (positionOfRelatedPickup == 0 && context.getRoute().getActivities().isEmpty()) {
        context.getRoute().getStart().setLocation(context.getNewVehicle().getStartLocation());
        // This value is never used. it gets overwritten before usage. -- commenting it out. KMT, Jun'20
        // routeDistance = getDistance(context.getRoute().getStart(), context.getAssociatedActivities().get(0),
        // context.getNewVehicle(), context.getNewDepTime());
        context.getRoute().getEnd().setLocation(context.getNewVehicle().getEndLocation());
        routeDistance = getDistance(context.getAssociatedActivities().get(0), context.getRoute().getEnd(), context.getNewVehicle(), context.getNewDepTime());
        return routeDistance;
    } else if (positionOfRelatedPickup == 0 && !context.getRoute().getActivities().isEmpty()) {
        // This value is never used. it gets overwritten before usage. -- commenting it out. KMT, Jun'20
        // routeDistance = getDistance(context.getRoute().getStart(), context.getAssociatedActivities().get(0),
        // context.getNewVehicle(), context.getNewDepTime());
        routeDistance = getDistance(context.getAssociatedActivities().get(0), context.getRoute().getActivities().get(0), context.getNewVehicle(), context.getNewDepTime());
    } else {
        routeDistance = getDistance(context.getRoute().getStart(), context.getRoute().getActivities().get(0), context.getNewVehicle(), context.getNewDepTime());
    }
    // adds distances between every tour activity and adds the associated pickup on
    // the correct position of the tour
    while (context.getRoute().getTourActivities().getActivities().size() > (nextRouteActivity + 1)) {
        if (positionOfRelatedPickup == (nextRouteActivity + 1) && positionOfRelatedPickup != 0) {
            routeDistance = routeDistance + getDistance(context.getRoute().getActivities().get(nextRouteActivity), context.getAssociatedActivities().get(0), context.getNewVehicle());
            routeDistance = routeDistance + getDistance(context.getAssociatedActivities().get(0), context.getRoute().getActivities().get(nextRouteActivity), context.getNewVehicle());
        } else {
            routeDistance = routeDistance + getDistance(context.getRoute().getActivities().get(nextRouteActivity), context.getRoute().getActivities().get(nextRouteActivity + 1), context.getNewVehicle());
        }
        nextRouteActivity++;
    }
    if (positionOfRelatedPickup == context.getRoute().getActivities().size()) {
        routeDistance = routeDistance + getDistance(context.getRoute().getActivities().get(nextRouteActivity), context.getAssociatedActivities().get(0), context.getNewVehicle());
        routeDistance = routeDistance + getDistance(context.getAssociatedActivities().get(0), context.getRoute().getEnd(), context.getNewVehicle());
    } else
        routeDistance = routeDistance + getDistance(context.getRoute().getActivities().get(nextRouteActivity), context.getRoute().getEnd(), context.getNewVehicle());
    return routeDistance;
}",calculateRouteDistanceWithAssociatedPickup,org/matsim/contrib/freight/jsprit/DistanceConstraint.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/jsprit/DistanceConstraint.java,"/**
         * Calculates the distance based on the route-based distances between every tour
         * activities. The method also integrates the associated pickup in the tour.
         */",130-183,"('calculateRouteDistanceWithAssociatedPickup', {'INSTRUCTION': {'covered': 222, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 31, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",561.0,13.0,Calculates the distance based on the route-based distances between every tour  activities.,"Based on the route between the activities of each tour, it calculates the distance .  The pick-up associated with the tour is integrated into the",The distance is calculated based on the route-based distances between the activities.,0.243047624685901,  Calculates the distance based on the distances based on the route between each tourist activity.
179,weblogic-kubernetes-operator,"public CallBuilder withAuthentication(String accessToken){
    if (!isNullOrEmpty(accessToken)) {
        this.helper = new ClientPool().withApiClient(createApiClient(accessToken));
    }
    return this;
}",withAuthentication,oracle/kubernetes/operator/helpers/CallBuilder.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/CallBuilder.java,"/**
   * Create AccessTokenAuthentication component for authenticating user represented by
   * the given token.
   * @param accessToken - User's Bearer token
   * @return - this CallBuilder instance
   */",2151-2162,"('withAuthentication', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,12.0,Create AccessTokenAuthentication component for authenticating user represented by  the given token.,"To authenticate the user represented by the given token, create the AccessTokenAuthentication component",AccessTokenAuthentication component is created to allow for the authenticating of user represented by a token.,0.273095666658776,  Create the AccessTokenAuthentication component to authenticate the user represented by the given token.
180,cdk,"public static void aromatizeMolecule(IAtomContainer mol){
    IRingSet ringSet = null;
    try {
        AllRingsFinder arf = new AllRingsFinder();
        ringSet = arf.findAllRings(mol);
    } catch (Exception e) {
        e.printStackTrace();
    }
    try {
        SMSDNormalizer.percieveAtomTypesAndConfigureAtoms(mol);
        Aromaticity.cdkLegacy().apply(mol);
        RingSetManipulator.markAromaticRings(ringSet);
    } catch (Exception e) {
        e.printStackTrace();
    }
    for (int i = 0; i <= mol.getAtomCount() - 1; i++) {
        mol.getAtom(i).setFlag(CDKConstants.ISAROMATIC, false);
        jloop: for (int j = 0; j <= ringSet.getAtomContainerCount() - 1; j++) {
            IRing ring = (IRing) ringSet.getAtomContainer(j);
            if (!ring.getFlag(CDKConstants.ISAROMATIC)) {
                continue jloop;
            }
            boolean haveatom = ring.contains(mol.getAtom(i));
            if (haveatom && ring.getAtomCount() == 6) {
                mol.getAtom(i).setFlag(CDKConstants.ISAROMATIC, true);
            }
        }
    }
}",aromatizeMolecule,org/openscience/cdk/normalize/SMSDNormalizer.java,/legacy/src/main/java/org/openscience/cdk/normalize/SMSDNormalizer.java,"/**
     * This function finds rings and uses aromaticity detection code to
     * aromatize the molecule.
     * @param mol input molecule
     */",118-178,"('aromatizeMolecule', {'INSTRUCTION': {'covered': 74, 'missed': 7}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 5}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",226.0,14.0,This function finds rings and uses aromaticity detection code to  aromatize the molecule.,This function to aromatise the molecule finds the rings and uses the aromaticity detection code,The function uses aromaticity detection code to find rings.,0.146076276589445,  This function finds rings and uses the aromaticity detection code to flavor the molecule.
181,dataverse,"public FileMetadata createCopy(){
    FileMetadata fmd = new FileMetadata();
    fmd.setCategories(new LinkedList<>(getCategories()));
    fmd.setDataFile(getDataFile());
    fmd.setDatasetVersion(getDatasetVersion());
    fmd.setDescription(getDescription());
    fmd.setLabel(getLabel());
    fmd.setRestricted(isRestricted());
    fmd.setDirectoryLabel(getDirectoryLabel());
    return fmd;
}",createCopy,edu/harvard/iq/dataverse/FileMetadata.java,/src/main/java/edu/harvard/iq/dataverse/FileMetadata.java,"/**
     * Creates a copy of {@code this}, with identical business logic fields.
     * E.g., {@link #label} would be duplicated; {@link #version} will not.
     * 
     * @return A copy of {@code this}, except for the DB-related data.
     */",115-132,"('createCopy', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,16.0,"Creates a copy of {@code this}, with identical business logic fields.","Creates a copy of {@code this}, where the business logic fields are identical",A copy of @code this is created.,0.742771807655122,"  Creates a copy of {@code this}, with identical business logic fields."
182,acs-aem-commons,"private boolean accepts(final ReplicationAction replicationAction, final ReplicationOptions replicationOptions){
    if (replicationAction == null || replicationOptions == null) {
        log.debug(""Replication Action or Options are null. Skipping this replication."");
        return false;
    }
    final String path = replicationAction.getPath();
    if (replicationOptions.getFilter() instanceof DispatcherFlushRulesFilter) {
        log.debug(""Ignore applying dispatcher flush rules for [ {} ], as it originated from this "" + ""Service."", path);
        return false;
    } else if ((this.hierarchicalFlushRules == null || this.hierarchicalFlushRules.size() < 1) && (this.resourceOnlyFlushRules == null || this.resourceOnlyFlushRules.size() < 1)) {
        log.warn(""Ignored due no configured flush rules."");
        return false;
    } else if (StringUtils.isBlank(path)) {
        log.debug(""Replication Action path is blank. Skipping this replication."");
        return false;
    } else if (!ReplicationActionType.ACTIVATE.equals(replicationAction.getType()) && !ReplicationActionType.DEACTIVATE.equals(replicationAction.getType()) && !ReplicationActionType.DELETE.equals(replicationAction.getType())) {
        return false;
    }
    return true;
}",accepts,com/adobe/acs/commons/replication/dispatcher/impl/DispatcherFlushRulesImpl.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/impl/DispatcherFlushRulesImpl.java,"/**
     * Checks if this service should react to or ignore this replication action.
     *
     * @param replicationAction The replication action that is initiating this flush request
     * @param replicationOptions The replication options that is initiating this flush request
     * @return true is this service should attempt to flush associated resources for this replication request
     */",208-243,"('accepts', {'INSTRUCTION': {'covered': 64, 'missed': 6}, 'BRANCH': {'covered': 17, 'missed': 5}, 'LINE': {'covered': 17, 'missed': 2}, 'COMPLEXITY': {'covered': 7, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",198.0,13.0,Checks if this service should react to or ignore this replication action.,Controls whether the service should ignore the response action or react,This service is checked to see if it should respond to this action.,0.542121213749766,  Checks whether this service should react or ignore this replication action.
183,cdk,"public boolean contains(IIsotope isotope){
    for (Iterator<IIsotope> it = isotopes().iterator(); it.hasNext(); ) {
        IIsotope thisIsotope = it.next();
        if (isTheSame(thisIsotope, isotope)) {
            return true;
        }
    }
    return false;
}",contains,org/openscience/cdk/formula/AdductFormula.java,/base/data/src/main/java/org/openscience/cdk/formula/AdductFormula.java,"/**
     *  True, if the AdductFormula contains the given IIsotope object and not
     *  the instance. The method looks for other isotopes which has the same
     *  symbol, natural abundance and exact mass.
     *
     * @param  isotope  The IIsotope this AdductFormula is searched for
     * @return          True, if the AdductFormula contains the given isotope object
     */",111-128,"('contains', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,15.0,"True, if the AdductFormula contains the given IIsotope object and not  the instance.","In the case where the AdductFormula contains the given IIsotope object and not the instance returns True. Whereas, the method searches for other isotopes with the same natural abundance, the same symbol and the same exact mass.","If the AdductFormula contains the IIsotope object, it's true.",0.30247503443561,"  True, if AdductFormula contains the given IIsotope object, not the instance."
184,cdk,"public DescriptorValue calculate(IAtomContainer container){
    if (!GeometryUtil.has3DCoordinates(container))
        return getDummyDescriptorValue(new CDKException(""Molecule must have 3D coordinates""));
    double sum = 0.0;
    IAtomContainer ac;
    try {
        ac = (IAtomContainer) container.clone();
    } catch (CloneNotSupportedException e) {
        return getDummyDescriptorValue(e);
    }
    double[][] cmat = new double[ac.getAtomCount()][3];
    for (int i = 0; i < ac.getAtomCount(); i++) {
        Point3d coords = ac.getAtom(i).getPoint3d();
        cmat[i][0] = coords.x;
        cmat[i][1] = coords.y;
        cmat[i][2] = coords.z;
    }
    Map<String, Double> hash = null;
    double[] wt = new double[ac.getAtomCount()];
    if (this.type.equals(""unity"")) {
        for (int i = 0; i < ac.getAtomCount(); i++) wt[i] = 1.0;
    } else {
        if (this.type.equals(""mass"")) {
            hash = this.hashatwt;
        } else if (this.type.equals(""volume"")) {
            hash = this.hashvdw;
        } else if (this.type.equals(""eneg"")) {
            hash = this.hasheneg;
        } else if (this.type.equals(""polar"")) {
            hash = this.hashpol;
        }
        for (int i = 0; i < ac.getAtomCount(); i++) {
            String sym = ac.getAtom(i).getSymbol();
            wt[i] = (Double) hash.get(sym);
        }
    }
    PCA pcaobject = null;
    try {
        pcaobject = new PCA(cmat, wt);
    } catch (CDKException cdke) {
        logger.debug(cdke);
    }
    double[] lambda = pcaobject.getEigenvalues();
    double[] gamma = new double[3];
    double[] nu = new double[3];
    double[] eta = new double[3];
    for (int i = 0; i < 3; i++) sum += lambda[i];
    for (int i = 0; i < 3; i++) nu[i] = lambda[i] / sum;
    double[][] scores = pcaobject.getScores();
    for (int i = 0; i < 3; i++) {
        sum = 0.0;
        for (int j = 0; j < ac.getAtomCount(); j++) sum += scores[j][i] * scores[j][i] * scores[j][i] * scores[j][i];
        sum = sum / (lambda[i] * lambda[i] * ac.getAtomCount());
        eta[i] = 1.0 / sum;
    }
    for (int i = 0; i < 3; i++) {
        double ns = 0.0;
        double na = 0.0;
        for (int j = 0; j < ac.getAtomCount(); j++) {
            boolean foundmatch = false;
            for (int k = 0; k < ac.getAtomCount(); k++) {
                if (k == j)
                    continue;
                if (scores[j][i] == -1 * scores[k][i]) {
                    ns++;
                    foundmatch = true;
                    break;
                }
            }
            if (!foundmatch)
                na++;
        }
        double n = (double) ac.getAtomCount();
        gamma[i] = -1.0 * ((ns / n) * Math.log(ns / n) / Math.log(2.0) + (na / n) * Math.log(1.0 / n) / Math.log(2.0));
        gamma[i] = 1.0 / (1.0 + gamma[i]);
    }
    double t = lambda[0] + lambda[1] + lambda[2];
    double a = lambda[0] * lambda[1] + lambda[0] * lambda[2] + lambda[1] * lambda[2];
    double v = t + a + lambda[0] * lambda[1] * lambda[2];
    double k = 0.0;
    sum = 0.0;
    for (int i = 0; i < 3; i++) sum += lambda[i];
    for (int i = 0; i < 3; i++) k = (lambda[i] / sum) - (1.0 / 3.0);
    k = k / (4.0 / 3.0);
    double g = Math.pow(gamma[0] * gamma[1] * gamma[2], 1.0 / 3.0);
    double d = eta[0] + eta[1] + eta[2];
    DoubleArrayResult retval = new DoubleArrayResult(11 + 6);
    retval.add(lambda[0]);
    retval.add(lambda[1]);
    retval.add(lambda[2]);
    retval.add(nu[0]);
    retval.add(nu[1]);
    retval.add(gamma[0]);
    retval.add(gamma[1]);
    retval.add(gamma[2]);
    retval.add(eta[0]);
    retval.add(eta[1]);
    retval.add(eta[2]);
    retval.add(t);
    retval.add(a);
    retval.add(v);
    retval.add(k);
    retval.add(g);
    retval.add(d);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), retval, getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/WHIMDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/WHIMDescriptor.java,"/**
     * Calculates 11 directional and 6 non-directional WHIM descriptors for.
     * the specified weighting scheme
     *
     * @param container Parameter is the atom container.
     * @return An ArrayList containing the descriptors in the order described above.
     */",301-450,"('calculate', {'INSTRUCTION': {'covered': 502, 'missed': 65}, 'BRANCH': {'covered': 31, 'missed': 11}, 'LINE': {'covered': 82, 'missed': 15}, 'COMPLEXITY': {'covered': 16, 'missed': 6}, 'METHOD': {'covered': 1, 'missed': 0}})",1163.0,10.0,Calculates 11 directional and 6 non-directional WHIM descriptors for.,"For the specified weighting scheme, calculate 11 directional and 6 non-directional WHIM descriptors",11 and 6 WHIM descriptors were calculated.,0.578668099220741,Calculates 11 directional WHIM descriptors and 6 non-directional WHIM descriptors for.
185,cdk,"public boolean test(final int[] mapping){
    // n.b. not true for unspecified queries e.g. [C@?H](*)(*)*
    if (queryStereoIndices.length > targetStereoIndices.length)
        return false;
    // reset augment group config if it was initialised
    if (groupConfigAdjust != null)
        Arrays.fill(groupConfigAdjust, 0);
    for (final int u : queryStereoIndices) {
        switch(queryTypes[u]) {
            case Tetrahedral:
                if (!checkTetrahedral(u, mapping))
                    return false;
                break;
            case Geometric:
                if (!checkGeometric(u, otherIndex(u), mapping))
                    return false;
                break;
        }
    }
    return true;
}",test,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,"/**
     * Is the {@code mapping} of the stereochemistry in the query preserved in
     * the target.
     *
     * @param mapping permutation of the query vertices
     * @return the stereo chemistry is value
     */",104-132,"('test', {'INSTRUCTION': {'covered': 56, 'missed': 4}, 'BRANCH': {'covered': 11, 'missed': 2}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 6, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",103.0,18.0,Is the {@code mapping} of the stereochemistry in the query preserved in  the target.,The {@code} mapping of the stereochemistry in the query is stored in the destination,Is the query preserved in the target?,0.223971332803513,  Is the {mapping @code} of the stereochemistry in the query preserved in the target?
186,cdk,"private void parseMolCXSMILES(String title, IAtomContainer mol) throws InvalidSmilesException{
    CxSmilesState cxstate;
    int pos;
    if (title != null && title.startsWith(""|"")) {
        if ((pos = CxSmilesParser.processCx(title, cxstate = new CxSmilesState())) >= 0) {
            mol.setTitle(title.substring(pos));
            final Map<IAtom, IAtomContainer> atomToMol = new HashMap<>(2 * mol.getAtomCount());
            final List<IAtom> atoms = new ArrayList<>(mol.getAtomCount());
            for (IAtom atom : mol.atoms()) {
                atoms.add(atom);
                atomToMol.put(atom, mol);
            }
            assignCxSmilesInfo(mol.getBuilder(), mol, atoms, atomToMol, cxstate);
        }
    }
}",parseMolCXSMILES,org/openscience/cdk/smiles/SmilesParser.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/SmilesParser.java,"/**
     * Parses CXSMILES layer and set attributes for atoms and bonds on the provided molecule.
     *
     * @param title SMILES title field
     * @param mol   molecule
     */",301-327,"('parseMolCXSMILES', {'INSTRUCTION': {'covered': 65, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",159.0,15.0,Parses CXSMILES layer and set attributes for atoms and bonds on the provided molecule.,"Allows the CXSMILES level to be analysed. In addition, the molecule bonds provided and the attributes for the atoms.",Parses the layer and sets the attributes for the atoms and bonds.,0.342214737536253,  Analyzes the CXSMILES layer and defines the attributes of atoms and bonds on the supplied molecule.
187,matsim-libs,"public static double calcEndOfPlanElement(final double now, final PlanElement pe, Config config){
    Preconditions.checkArgument(Double.isFinite(now));
    if (pe instanceof Activity) {
        Activity act = (Activity) pe;
        return PopulationUtils.decideOnActivityEndTime(act, now, config).seconds();
    } else {
        double ttime = PopulationUtils.decideOnTravelTimeForLeg((Leg) pe).orElse(0);
        return now + ttime;
    }
}",calcEndOfPlanElement,org/matsim/core/router/TripRouter.java,/matsim/src/main/java/org/matsim/core/router/TripRouter.java,"/**
         * Helper method, that can be used to compute start time of legs.
         * (it is also used internally).
         * It is provided here, because such an operation is mainly useful for routing,
         * but it may be externalized in a ""util"" class...
         * @param config TODO
         */",202-224,"('calcEndOfPlanElement', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,14.0,"Helper method, that can be used to compute start time of legs.",Allows the calculation of the start time of routes (is also used internally).,The method can be used to calculate the start time of legs.,0.617405881626939,"  Assistance method, which can be used to calculate the start time of the legs."
188,cdk,"private static String breakExtractor(String formula){
    boolean finalBreak = false;
    int innerMostBracket = formula.lastIndexOf(""("");
    if (innerMostBracket < 0)
        return formula;
    String finalformula = formula.substring(0, innerMostBracket);
    String multipliedformula = """";
    String formulaEnd = """";
    String multiple = """";
    for (int f = innerMostBracket + 1; f < formula.length(); f++) {
        char thisChar = formula.charAt(f);
        if (finalBreak) {
            if (isDigit(thisChar)) {
                multiple += thisChar;
            } else {
                formulaEnd = formula.substring(f, formula.length());
                break;
            }
        } else {
            if (thisChar == ')') {
                finalBreak = true;
            } else
                multipliedformula += thisChar;
        }
    }
    finalformula += muliplier(multipliedformula, multiple.isEmpty() ? 1 : Integer.valueOf(multiple)) + formulaEnd;
    if (finalformula.contains(""(""))
        return breakExtractor(finalformula);
    else
        return finalformula;
}",breakExtractor,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * The parenthesis convention is used to show a quantity by which a formula is multiplied.
     * For example: (C12H20O11)2 really means that a C24H40O22 unit.
     *
     * @param formula Formula to correct
     * @return        Formula with the correction
     */",1398-1441,"('breakExtractor', {'INSTRUCTION': {'covered': 99, 'missed': 2}, 'BRANCH': {'covered': 13, 'missed': 1}, 'LINE': {'covered': 21, 'missed': 1}, 'COMPLEXITY': {'covered': 7, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",195.0,16.0,The parenthesis convention is used to show a quantity by which a formula is multiplied.,"To indicate a quantity by which a formula is multiplied, the convention of brackets is used ",The quantity is shown by using the parenthesis convention.,0.0849403989108162,  The parenthesis convention is used to show a quantity by which a formula is multiplied.
189,anserini,"public static String documentContents(IndexReader reader, String docid){
    try {
        return reader.document(convertDocidToLuceneDocid(reader, docid)).get(IndexArgs.CONTENTS);
    } catch (Exception e) {
        return null;
    }
}",documentContents,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,"/**
   * Returns the ""contents"" field of a document based on a collection docid. The method is named to be consistent with
   * Lucene's {@link IndexReader#document(int)}, contra Java's standard method naming conventions.
   *
   * @param reader index reader
   * @param docid collection docid
   * @return the ""contents"" field the document
   */",555-570,"('documentContents', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,15.0,"Returns the ""contents"" field of a document based on a collection docid.","  Based on a docid collection, the 'content' field of a document is returned. The method name is consistent with Lucene {@link IndexReader#document(int)}, whereas it is at odds with the naming conventions of Java's standard methods.",The field of the document is based on the collection docid.,0.361831735177235,"  Returns the ""contents"" field of a document based on a collection docid."
190,cdk,"public DescriptorValue calculate(IAtomContainer mol){
    this.mol = mol;
    excavateMolecule();
    int nSmallRings = smallRings.length;
    int nAromRings = 0;
    int nRingBlocks = 0;
    int nAromBlocks = countAromaticComponents();
    int nRings3 = 0, nRings4 = 0, nRings5 = 0, nRings6 = 0, nRings7 = 0, nRings8 = 0, nRings9 = 0;
    for (int[] r : smallRings) {
        final int sz = r.length;
        if (sz == 3)
            nRings3++;
        else if (sz == 4)
            nRings4++;
        else if (sz == 5)
            nRings5++;
        else if (sz == 6)
            nRings6++;
        else if (sz == 7)
            nRings7++;
        else if (sz == 8)
            nRings8++;
        else if (sz == 9)
            nRings9++;
        boolean aromatic = true;
        for (int n = 0; n < r.length; n++) if (!bondArom[findBond(r[n], r[n < sz - 1 ? n + 1 : 0])]) {
            aromatic = false;
            break;
        }
        if (aromatic)
            nAromRings++;
    }
    for (int n = ringBlock.length - 1; n >= 0; n--) nRingBlocks = Math.max(nRingBlocks, ringBlock[n]);
    IntegerArrayResult result = new IntegerArrayResult();
    result.add(nSmallRings);
    result.add(nAromRings);
    result.add(nRingBlocks);
    result.add(nAromBlocks);
    result.add(nRings3);
    result.add(nRings4);
    result.add(nRings5);
    result.add(nRings6);
    result.add(nRings7);
    result.add(nRings8);
    result.add(nRings9);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), result, NAMES);
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/SmallRingDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/SmallRingDescriptor.java,"/**
     * Performs the calculation: the graph will be analyzed and ring information will be determined and wrapped
     * up into descriptors.
     *
     * @param mol the atoms and bonds that make up the molecular object
     * @return the various ring-based descriptors generated
     */",136-197,"('calculate', {'INSTRUCTION': {'covered': 169, 'missed': 18}, 'BRANCH': {'covered': 17, 'missed': 9}, 'LINE': {'covered': 36, 'missed': 7}, 'COMPLEXITY': {'covered': 8, 'missed': 6}, 'METHOD': {'covered': 1, 'missed': 0}})",363.0,21.0,Performs the calculation: the graph will be analyzed and ring information will be determined and wrapped  up into descriptors.,"The method allows the actual atom polarisability of a given atom to be calculated. From the tools.HydrogenAdder class, the method addExplicitHydrogensToSatisfyValency",The graph will be analyzed and ring information wrapped up into descriptors.,1.00134881130705,  Perform the calculation: the graph will be analyzed and the information in the ring will be determined and wrapped in descriptors.
191,cdk,"private void layoutCyclicParts() throws CDKException{
    logger.debug(""Start of layoutNextRingSystem()"");
    resetUnplacedRings();
    IAtomContainer placedAtoms = AtomPlacer.getPlacedAtoms(molecule);
    logger.debug(""Finding attachment bond to already placed part..."");
    IBond nextRingAttachmentBond = getNextBondWithUnplacedRingAtom();
    if (nextRingAttachmentBond != null) {
        logger.debug(""...bond found."");
        IAtom ringAttachmentAtom = getRingAtom(nextRingAttachmentBond);
        IAtom chainAttachmentAtom = getOtherBondAtom(ringAttachmentAtom, nextRingAttachmentBond);
        IRingSet nextRingSystem = getRingSystemOfAtom(ringSystems, ringAttachmentAtom);
        IAtomContainer ringSystem = RingSetManipulator.getAllInOneContainer(nextRingSystem);
        Point2d oldRingAttachmentAtomPoint = ringAttachmentAtom.getPoint2d();
        Point2d oldChainAttachmentAtomPoint = chainAttachmentAtom.getPoint2d();
        layoutRingSet(firstBondVector, nextRingSystem);
        AtomPlacer.markNotPlaced(placedAtoms);
        IAtomContainer placedRingSubstituents = ringPlacer.placeRingSubstituents(nextRingSystem, bondLength);
        ringSystem.add(placedRingSubstituents);
        AtomPlacer.markPlaced(placedAtoms);
        logger.debug(""Computing translation/rotation of new ringset to fit old attachment bond orientation..."");
        Point2d oldPoint2 = oldRingAttachmentAtomPoint;
        Point2d oldPoint1 = oldChainAttachmentAtomPoint;
        Point2d newPoint2 = ringAttachmentAtom.getPoint2d();
        Point2d newPoint1 = chainAttachmentAtom.getPoint2d();
        logger.debug(""oldPoint1: "" + oldPoint1);
        logger.debug(""oldPoint2: "" + oldPoint2);
        logger.debug(""newPoint1: "" + newPoint1);
        logger.debug(""newPoint2: "" + newPoint2);
        double oldAngle = GeometryUtil.getAngle(oldPoint2.x - oldPoint1.x, oldPoint2.y - oldPoint1.y);
        double newAngle = GeometryUtil.getAngle(newPoint2.x - newPoint1.x, newPoint2.y - newPoint1.y);
        double angleDiff = oldAngle - newAngle;
        logger.debug(""oldAngle: "" + oldAngle + "", newAngle: "" + newAngle + ""; diff = "" + angleDiff);
        Vector2d translationVector = new Vector2d(oldPoint1);
        translationVector.sub(new Vector2d(newPoint1));
        GeometryUtil.translate2D(ringSystem, translationVector);
        GeometryUtil.rotate(ringSystem, oldPoint1, angleDiff);
        logger.debug(""...done translating/rotating new ringset to fit old attachment bond orientation."");
    } else {
        logger.debug(""...no bond found"");
        if (ringSystems != null) {
            for (IRingSet ringset : ringSystems) {
                for (IAtomContainer ring : ringset.atomContainers()) ringPlacer.completePartiallyPlacedRing(ringset, (IRing) ring, bondLength);
                if (allPlaced(ringset))
                    ringPlacer.placeRingSubstituents(ringset, bondLength);
            }
        }
    }
    logger.debug(""End of layoutNextRingSystem()"");
}",layoutCyclicParts,org/openscience/cdk/layout/StructureDiagramGenerator.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/StructureDiagramGenerator.java,"/**
     * Does the layout for the next RingSystem that is connected to those parts of
     * the molecule that have already been laid out. Finds the next ring with an
     * unplaced ring atom and lays out this ring. Then lays out the ring substituents
     * of this ring. Then moves and rotates the laid out ring to match the position
     * of its attachment bond to the rest of the molecule.
     *
     * @throws CDKException if an error occurs
     */",1902-2009,"('layoutCyclicParts', {'INSTRUCTION': {'covered': 236, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 47, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",420.0,23.0,Does the layout for the next RingSystem that is connected to those parts of  the molecule that have already been laid out.,"Arrange the next RingSystem connected to the parts of the molecule already arranged. After finding the next ring with an atom from the unplaced ring, arranges it. At this point he draws the ring substituents of this ring. Finally, move and rotate the drawn ring so that the position of its attachment bond matches the rest of the molecule.",Does the layout for the next RingSystem connect to the parts of the molecule that have already been laid out?,0.513928689027366,  Makes the arrangement for the next RingSystem that is connected to the parts of the molecule that have already been arranged.
192,openapi-generator," static ValidationRule empty(){
    return new ValidationRule(Severity.ERROR, ""empty"", ""failure message"", (i) -> Fail.empty());
}",empty,org/openapitools/codegen/validation/ValidationRule.java,/modules/openapi-generator-core/src/main/java/org/openapitools/codegen/validation/ValidationRule.java,"/**
     * Constructs an empty rule (useful for testing).
     *
     * @return An ""empty"" rule.
     */",87-94,"('empty', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,10.0,Constructs an empty rule (useful for testing).,An empty line useful for testing is constructed,"Useful for testing, this rule is empty.",0.589437476510427,  Constructs an empty rule (useful for testing).
193,dataverse,"public TabularDataIngest read(BufferedInputStream stream, File dataFile) throws IOException{
    init();
    if (stream == null) {
        throw new IOException(BundleUtil.getStringFromBundle(""ingest.csv.nullStream""));
    }
    TabularDataIngest ingesteddata = new TabularDataIngest();
    DataTable dataTable = new DataTable();
    BufferedReader localBufferedReader = new BufferedReader(new InputStreamReader(stream));
    File tabFileDestination = File.createTempFile(""data-"", "".tab"");
    PrintWriter tabFileWriter = new PrintWriter(tabFileDestination.getAbsolutePath());
    int lineCount = readFile(localBufferedReader, dataTable, tabFileWriter);
    logger.fine(""Tab file produced: "" + tabFileDestination.getAbsolutePath());
    dataTable.setUnf(""UNF:6:NOTCALCULATED"");
    ingesteddata.setTabDelimitedFile(tabFileDestination);
    ingesteddata.setDataTable(dataTable);
    return ingesteddata;
}",read,edu/harvard/iq/dataverse/ingest/tabulardata/impl/plugins/csv/CSVFileReader.java,/src/main/java/edu/harvard/iq/dataverse/ingest/tabulardata/impl/plugins/csv/CSVFileReader.java,"/**
     * Reads a CSV file, converts it into a dataverse DataTable.
     *
     * @param stream a <code>BufferedInputStream</code>.
     * @return an <code>TabularDataIngest</code> object
     * @throws java.io.IOException if a reading error occurs.
     */",105-137,"('read', {'INSTRUCTION': {'covered': 58, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",141.0,12.0,"Reads a CSV file, converts it into a dataverse DataTable.",Converts a CSV file into a table of data.,A dataverse DataTable is created when acsv file is read and converted.,0.798439070162964,"  Reads a CSV file, converts it to DataTable dataverse."
194,twilio-java,"private static String replace(String string, boolean replaceSlash){
    if (string == null || string.isEmpty()) {
        return string;
    }
    StringBuffer buffer = new StringBuffer(string.length());
    Matcher matcher = TOKEN_REPLACE_PATTERN.matcher(string);
    while (matcher.find()) {
        String replacement = matcher.group(0);
        if (""+"".equals(replacement)) {
            replacement = ""%20"";
        } else if (""*"".equals(replacement)) {
            replacement = ""%2A"";
        } else if (""%7E"".equals(replacement)) {
            replacement = ""~"";
        } else if (replaceSlash && ""%2F"".equals(replacement)) {
            replacement = ""/"";
        }
        matcher.appendReplacement(buffer, replacement);
    }
    matcher.appendTail(buffer);
    return buffer.toString();
}",replace,com/twilio/jwt/validation/RequestCanonicalizer.java,/src/main/java/com/twilio/jwt/validation/RequestCanonicalizer.java,"/**
     * Replaces the special characters in the URLEncoded string with the replacement values defined by the spec.
     *
     * Partially copied from https://github.com/aws/aws-sdk-java: com.amazonaws.util.SdkHttpUtils (2017-05-19)
     *
     * @param string       the string to replace characters in
     * @param replaceSlash whether the encoded '/' should be replaced
     * @return the string after replacements
     */",168-201,"('replace', {'INSTRUCTION': {'covered': 66, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",161.0,17.0,Replaces the special characters in the URLEncoded string with the replacement values defined by the spec.,"In the URLEncoded string, special characters are replaced on the basis of the replacement values defined by the specification.",The special characters in the URLEncoded string are replaced with the replacement values defined by the spec.,0.333147191174338,  Replaces the special characters in the URLEncoded string with the replacement values defined by the specification.
195,dcache,"public static boolean isExemptFromNamespaceChecks(Subject subject){
    return subject.getPrincipals().stream().anyMatch(p -> p instanceof UidPrincipal && ((UidPrincipal) p).getUid() == 0 || p instanceof ExemptFromNamespaceChecks);
}",isExemptFromNamespaceChecks,org/dcache/auth/Subjects.java,/modules/common/src/main/java/org/dcache/auth/Subjects.java,"/**
     * Return true if the subject is root or has the special ExemptFromNamespaceChecks principal.
     *
     * @param subject The identity of the user.
     * @return if the user is except from namespace checks.
     * @see #isRoot(javax.security.auth.Subject)
     */",70-82,"('isExemptFromNamespaceChecks', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,14.0,Return true if the subject is root or has the special ExemptFromNamespaceChecks principal.,In the case where the object is root or has the special principle ExemptFromNamespaceChecks returns true ,"If the subject is root, return true.",0.197727867705204,  Return true if the object is root or has the special Principal ExemptFromNamespaceChecks.
196,jackson-databind,"protected void _removeUnwantedProperties(Map<String, POJOPropertyBuilder> props){
    Iterator<POJOPropertyBuilder> it = props.values().iterator();
    while (it.hasNext()) {
        POJOPropertyBuilder prop = it.next();
        if (!prop.anyVisible()) {
            it.remove();
            continue;
        }
        if (prop.anyIgnorals()) {
            if (!prop.isExplicitlyIncluded()) {
                it.remove();
                _collectIgnorals(prop.getName());
                continue;
            }
            prop.removeIgnored();
            if (!prop.couldDeserialize()) {
                _collectIgnorals(prop.getName());
            }
        }
    }
}",_removeUnwantedProperties,com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java,/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java,"/**
     * Method called to get rid of candidate properties that are marked
     * as ignored.
     */",884-914,"('_removeUnwantedProperties', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",132.0,14.0,Method called to get rid of candidate properties that are marked  as ignored.,Allows the deletion of candidate properties flagged as ignored.,Candidate properties marked as ignored are thrown out.,0.564805981882159,  Method called to get rid of candidate properties marked as ignored.
197,tablesaw,"public static Function<Table, Selection> neither(Function<Table, Selection> sel1, Function<Table, Selection> sel2){
    return new Not(either(sel1, sel2));
}",neither,tech/tablesaw/api/QuerySupport.java,/core/src/main/java/tech/tablesaw/api/QuerySupport.java,"/**
   * Returns a selection for all records that match neither of the given functions. In other words,
   * if either (or both) of sel1 or sel2 is {@code true}, the record as a whole is {@code false}.
   */",26-33,"('neither', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,14.0,Returns a selection for all records that match neither of the given functions.,This method returns all records that do not match any of the specified functions. ,A selection is returned for records that do not match the functions.,0.402104749852766,  Returns a selection for all records that do not match any of the given functions.
198,matsim-libs,"private static List<String> convertSkillsAttributeToList(Attributes attributes){
    if (attributes.getAttribute(ATTR_SKILLS) == null) {
        return new ArrayList<>();
    } else {
        return Arrays.asList(Objects.requireNonNull(attributes.getAttribute(ATTR_SKILLS)).toString().split("",""));
    }
}",convertSkillsAttributeToList,org/matsim/contrib/freight/utils/FreightUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/utils/FreightUtils.java,"/**
         * Converts the 'skills' attribute to a list of strings.
         *
         * @param attributes the {@link Attributes} container that is checked for the
         *                   skill(s) to be converted.
         * @return the {@link List} of skills, possibly empty, as parsed from the
         *         attribute.
         */",487-501,"('convertSkillsAttributeToList', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",64.0,11.0,Converts the 'skills' attribute to a list of strings.,Obtains a list of strings from the conversion of the 'skills' attribute,The skills attribute is converted to a list of strings.,0.623037492050315,  Converts the 'skills' attribute into a list of strings.
199,glowstone,"public void sendMessages(GlowSession session){
    if (!needsUpdate) {
        return;
    }
    int id = entity.entityId;
    if (entity instanceof GlowPlayer) {
        GlowPlayer player = (GlowPlayer) entity;
        if (player.getUniqueId().equals(session.getPlayer().getUniqueId())) {
            id = 0;
        }
    }
    session.send(new EntityPropertyMessage(id, properties));
    needsUpdate = false;
}",sendMessages,net/glowstone/entity/AttributeManager.java,/src/main/java/net/glowstone/entity/AttributeManager.java,"/**
     * Sends the managed entity's properties to the client, if the client's snapshot is stale.
     *
     * @param session the client's session
     */",56-74,"('sendMessages', {'INSTRUCTION': {'covered': 36, 'missed': 1}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 9, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",85.0,18.0,"Sends the managed entity's properties to the client, if the client's snapshot is stale.","If the client snapshot is obsolete, it allows the managed entity's properties to be sent to the client","If the client's snapshot is not fresh, the managed entity's properties are sent to them.",0.368012526730976,"  Sends the properties of the managed entity to the client, if the client snapshot is outdated."
200,cdk,"static Entry<String, Point2d[]> decodeEntry(String str){
    final int i = str.indexOf(' ');
    if (i < 0)
        throw new IllegalArgumentException();
    return new SimpleEntry<String, Point2d[]>(str.substring(0, i), decodeCoordinates(str.substring(i + 1)));
}",decodeEntry,org/openscience/cdk/layout/IdentityTemplateLibrary.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/IdentityTemplateLibrary.java,"/**
     * Create a library entry from a SMILES string with the coordinates suffixed in binary. The
     * entry should be created with {@link #encodeEntry(java.util.Map.Entry)} and not created
     * manually. Note, the entry is not added to the library.
     *
     * @param str input string
     * @return library entry
     */",231-243,"('decodeEntry', {'INSTRUCTION': {'covered': 20, 'missed': 4}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",72.0,15.0,Create a library entry from a SMILES string with the coordinates suffixed in binary.,"From a SMILES string with binary suffix coordinates creates a library entry. The entry must not be created manually but must be created with {@link #encodeEntry(java.util.Map.Entry)}. Furthermore, the entry is not added to the library.",The coordinates are added to the SMILES string in a way that makes it appear as if it is a library entry.,0.916836520408373,  Create a library entry from a SMILES string with the coordinates suffixed in binary.
201,cdk,"public Point3d calculate3DCoordinates3(Point3d aPoint, Point3d bPoint, Point3d cPoint, Point3d dPoint, double length){
    Vector3d bc = new Vector3d(bPoint);
    bc.sub(cPoint);
    Vector3d dc = new Vector3d(dPoint);
    dc.sub(cPoint);
    Vector3d ca = new Vector3d(cPoint);
    ca.sub(aPoint);
    Vector3d n1 = new Vector3d();
    Vector3d n2 = new Vector3d();
    n1.cross(bc, dc);
    n1.normalize();
    n1.scale(length);
    Vector3d ax = new Vector3d(aPoint);
    ax.add(n1);
    ax.sub(aPoint);
    Vector3d ax2 = new Vector3d(aPoint);
    ax2.add(n2);
    ax2.sub(aPoint);
    Point3d point = new Point3d(aPoint);
    double dotProduct = ca.dot(ax);
    double angle = Math.acos((dotProduct) / (ax.length() * ca.length()));
    if (angle < 1.5) {
        n2.cross(dc, bc);
        n2.normalize();
        n2.scale(length);
        point.add(n2);
    } else {
        point.add(n1);
    }
    bc = null;
    dc = null;
    ca = null;
    n1 = null;
    n2 = null;
    return point;
}",calculate3DCoordinates3,org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,"/**
     *  Calculate new point X in a B-A(-D)-C system. It forms a B-A(-D)(-C)-X
     *  system. (3) 3 ligands(B, C, D) of refAtom A (i) 1 points required; if A, B,
     *  C, D coplanar, no points. else vector is resultant of BA, CA, DA
     *
     *@param  aPoint  to which substituents are added
     *@param  bPoint  first ligand of A
     *@param  cPoint  second ligand of A
     *@param  dPoint  third ligand of A
     *@param  length  A-X length
     *@return         Point3d nwanted points (or null if failed (coplanar))
     */",496-552,"('calculate3DCoordinates3', {'INSTRUCTION': {'covered': 100, 'missed': 13}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 28, 'missed': 4}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",268.0,13.0,Calculate new point X in a B-A(-D)-C system.,From a system B-A(-D)-C calculate the new point X. Create a system B-A(-D)(-C)-X,"In a B-A(-D)-C system, calculate the new point X.",0.512710085220485,  Calculate the new X point in a B-A(-D)-C system.
202,acs-aem-commons," boolean needsUpdate(@Nonnull Resource ensureDefinition, @Nonnull Resource oakIndex) throws IOException, RepositoryException{
    final Session session = ensureDefinition.getResourceResolver().adaptTo(Session.class);
    final ChecksumGenerator checksumGenerator = this.ensureOakIndex.getChecksumGenerator();
    final CustomChecksumGeneratorOptions ensureDefinitionOptions = new CustomChecksumGeneratorOptions();
    ensureDefinitionOptions.addIncludedNodeTypes(new String[] { NT_OAK_UNSTRUCTURED });
    ensureDefinitionOptions.addExcludedProperties(this.ignoreProperties);
    ensureDefinitionOptions.addExcludedSubTrees(this.excludeSubTrees);
    ensureDefinitionOptions.addExcludedNodeNames(this.excludeNodeNames);
    final Map<String, String> srcChecksum = checksumGenerator.generateChecksums(session, ensureDefinition.getPath(), ensureDefinitionOptions);
    final CustomChecksumGeneratorOptions oakIndexOptions = new CustomChecksumGeneratorOptions();
    oakIndexOptions.addIncludedNodeTypes(new String[] { NT_OAK_QUERY_INDEX_DEFINITION });
    oakIndexOptions.addExcludedProperties(this.ignoreProperties);
    oakIndexOptions.addExcludedSubTrees(this.excludeSubTrees);
    oakIndexOptions.addExcludedNodeNames(this.excludeNodeNames);
    final Map<String, String> destChecksum = checksumGenerator.generateChecksums(session, oakIndex.getPath(), oakIndexOptions);
    return !StringUtils.equals(srcChecksum.get(ensureDefinition.getPath()), destChecksum.get(oakIndex.getPath()));
}",needsUpdate,com/adobe/acs/commons/oak/impl/EnsureOakIndexJobHandler.java,/bundle/src/main/java/com/adobe/acs/commons/oak/impl/EnsureOakIndexJobHandler.java,"/**
     * Determines if the ensure definition is the same as the the same-named oak:index definition.
     *
     * @param ensureDefinition the ensure index definition
     * @param oakIndex         the oak index definition
     * @return true if the ensure definition and the oak index definition are different
     * @throws IOException
     * @throws RepositoryException
     */",487-522,"('needsUpdate', {'INSTRUCTION': {'covered': 88, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",223.0,17.0,Determines if the ensure definition is the same as the the same-named oak:index definition.,Determines whether the definition of ensure is equal to the definition oak:index with the same name.,"If the ensure definition is the same as the oak: index definition, then it's a problem.",0.465933633308375,  Determines whether the warranty definition is the same as the oak:index definition of the same name.
203,cdk,"public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
    if (!isCachedAtomContainer(ac)) {
        Double[] org = new Double[ac.getAtomCount()];
        for (int i = 0; i < org.length; i++) org[i] = ac.getAtom(i).getCharge();
        IAtomContainer mol = atom.getBuilder().newInstance(IAtomContainer.class, ac);
        if (maxIterations != 0)
            peoe.setMaxGasteigerIters(maxIterations);
        try {
            peoe.assignGasteigerMarsiliSigmaPartialCharges(mol, true);
            for (int i = 0; i < ac.getAtomCount(); i++) {
                cacheDescriptorValue(ac.getAtom(i), ac, new DoubleResult(mol.getAtom(i).getCharge()));
            }
        } catch (Exception e) {
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(Double.NaN), NAMES, e);
        }
        for (int i = 0; i < org.length; i++) mol.getAtom(i).setCharge(org[i]);
    }
    return getCachedDescriptorValue(atom) != null ? new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), getCachedDescriptorValue(atom), NAMES) : null;
}",calculate,org/openscience/cdk/qsar/descriptors/atomic/PartialSigmaChargeDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/PartialSigmaChargeDescriptor.java,"/**
     *  The method returns apha partial charges assigned to an heavy atom through Gasteiger Marsili
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *  For this method will be only possible if the heavy atom has single bond.
     *
     *@param  atom              The IAtom for which the DescriptorValue is requested
     *@param  ac                AtomContainer
     *@return                   Value of the alpha partial charge
     */",120-152,"('calculate', {'INSTRUCTION': {'covered': 107, 'missed': 18}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 14, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",259.0,27.0,The method returns apha partial charges assigned to an heavy atom through Gasteiger Marsili  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.,"The partial apha charges assigned to a heavy atom via Gasteiger Marsili are returned by this method. From the class tools.HydrogenAdder it is necessary to call the method addExplicitHydrogensToSatisfyValency. If the heavy atom has a single bond, this method can be applied.",The method returns partial charges assigned to an heavy atom through Gasteiger Marsili.,0.535168093178731,  The method returns partial charges apha assigned to a heavy atom via Gasteiger Marsili It is necessary to call the method addExplicitHydrogensToSatisfyValency from the class tools.
204,cron-utils,"protected void isInRange(final FieldValue<?> fieldValue){
    if (fieldValue instanceof IntegerFieldValue) {
        final int value = ((IntegerFieldValue) fieldValue).getValue();
        if (!constraints.isInRange(value)) {
            throw new IllegalArgumentException(String.format(OORANGE, value, constraints.getStartRange(), constraints.getEndRange()));
        }
    }
}",isInRange,com/cronutils/model/field/expression/visitor/ValidationFieldExpressionVisitor.java,/src/main/java/com/cronutils/model/field/expression/visitor/ValidationFieldExpressionVisitor.java,"/**
     * Check if given number is greater or equal to start range and minor or equal to end range.
     *
     * @param fieldValue - to be validated
     * @throws IllegalArgumentException - if not in range
     */",117-131,"('isInRange', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,19.0,Check if given number is greater or equal to start range and minor or equal to end range.,Verifies whether the given number is less than or equal to the final range or greater than or equal to the initial range.,"If the number is greater or equal to the start range, you should check it.",0.308417110171343,  Check if the given number is greater than or equal to the beginning range and minor or equal to the end range.
205,cdk,"private boolean verify(int n, int m){
    for (int n_prime : g1[n]) {
        boolean found = false;
        for (int m_prime : g2[m]) {
            if (matrix.get(n_prime, m_prime) && bondMatcher.matches(bond1.get(n, n_prime), bonds2.get(m, m_prime))) {
                found = true;
                break;
            }
        }
        if (!found)
            return false;
    }
    return true;
}",verify,org/openscience/cdk/isomorphism/UllmannState.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/UllmannState.java,"/**
     * Verify that for every vertex adjacent to n, there should be at least one
     * feasible candidate adjacent which can be mapped. If no such candidate
     * exists the mapping of n -> m is not longer valid.
     *
     * @param n query vertex
     * @param m target vertex
     * @return mapping is still valid
     */",196-217,"('verify', {'INSTRUCTION': {'covered': 69, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",94.0,23.0,"Verify that for every vertex adjacent to n, there should be at least one  feasible candidate adjacent which can be mapped.","For each vertex adjacent to n, it must be verified that there is at least one feasible adjacent candidate that can be mapped. The mapping of n -> m is no longer valid if there is no such candidate.",There should be at least one feasible candidate adjacent which can be mapped for every single vertex.,0.768304567711752,"  Verify that for each vertex adjacent to n, there must be at least one feasible adjacent candidate that can be mapped."
206,cdk,"static String dataHeader(final String line){
    if (line.length() > 2 && line.charAt(0) != '>' && line.charAt(1) != ' ')
        return null;
    int i = line.indexOf('<', 2);
    if (i < 0)
        return null;
    int j = line.indexOf('>', i);
    if (j < 0)
        return null;
    return line.substring(i + 1, j);
}",dataHeader,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Obtain the field name from a potential SD data header. If the header
     * does not contain a field name, then null is returned. The method does
     * not currently return field numbers (e.g. DT&lt;n&gt;).
     *
     * @param line an input line
     * @return the field name
     */",2292-2307,"('dataHeader', {'INSTRUCTION': {'covered': 39, 'missed': 2}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",95.0,11.0,Obtain the field name from a potential SD data header.,"From a potential SD data header, obtain the field name. Null is returned if the header does not contain a field name. The method currently does not return field numbers (e.g. DT&lt;n&gt;).",Obtain the field name from the data.,0.264300389980479,  Get the field name from a potential SD data header.
207,cdk,"private static int[][] findAromaticRings(int[][] cycles, int[] contribution, int[] dbs){
    boolean found;
    boolean[] checked = new boolean[cycles.length];
    final boolean[] aromaticAtoms = new boolean[contribution.length];
    final List<int[]> ringsOfSize6 = new ArrayList<int[]>();
    final List<int[]> ringsOfSize5 = new ArrayList<int[]>();
    do {
        found = false;
        for (int i = 0; i < cycles.length; i++) {
            int[] cycle = cycles[i];
            int len = cycle.length - 1;
            if (checked[i])
                continue;
            if (isAromaticRing(cycle, contribution, dbs, aromaticAtoms)) {
                checked[i] = true;
                found |= true;
                for (int j = 0; j < len; j++) {
                    aromaticAtoms[cycle[j]] = true;
                }
                if (len == 6)
                    ringsOfSize6.add(cycle);
                else if (len == 5)
                    ringsOfSize5.add(cycle);
            }
        }
    } while (found);
    List<int[]> rings = new ArrayList<int[]>();
    rings.addAll(ringsOfSize6);
    rings.addAll(ringsOfSize5);
    return rings.toArray(new int[rings.size()][]);
}",findAromaticRings,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,"/**
     * From a provided set of cycles find the 5/6 member cycles that fit the MMFF aromaticity
     * definition - {@link #isAromaticRing(int[], int[], int[], boolean[])}. The cycles of size 6
     * are listed first.
     *
     * @param cycles       initial set of cycles from
     * @param contribution vector of p electron contributions from each vertex
     * @param dbs          vector of double-bond pairs, index stored double-bonded index
     * @return the cycles that are aromatic
     */",113-168,"('findAromaticRings', {'INSTRUCTION': {'covered': 103, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 22, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",283.0,42.0,"From a provided set of cycles find the 5/6 member cycles that fit the MMFF aromaticity  definition - {@link #isAromaticRing(int[], int[], int[], boolean[])}.","From a given set of cycles, it is necessary to find the 5/6 member cycles that satisfy the MMFF definition of aromaticity - {@link #isAromaticRing(int[], int[], boolean[])}. Cycles of size 6 are listed first.",The MMFF aromaticity definition states that the 6 member cycles fit the definition.,0.941336864741545,"From a set of cycles provided, find the 5/6 member cycles that correspond to the definition of aromaticity of MMFF - {@link #isAromaticRing(int[], int[], int[], boolean[])}."
208,cdk,"public void addMapping(IMapping mapping){
    if (mappingCount + 1 >= map.length)
        growMappingArray();
    map[mappingCount] = mapping;
    mappingCount++;
    notifyChanged();
}",addMapping,org/openscience/cdk/Reaction.java,/base/data/src/main/java/org/openscience/cdk/Reaction.java,"/**
     * Adds a mapping between the reactant and product side to this
     * Reaction.
     *
     * @param mapping Mapping to add.
     * @see   #mappings
     */",411-424,"('addMapping', {'INSTRUCTION': {'covered': 23, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,13.0,Adds a mapping between the reactant and product side to this  Reaction.,A mapping is added between the reactant side and the product side of this Reaction.,A mapping between the reactant and product side is added.,0.863825027459556,  Adds a mapping between the reactive side and the product side to this reaction.
209,cdk,"public boolean add(IAtomContainer atomContainer){
    if (this.atomContainer == null) {
        this.atomContainer = atomContainer;
        title = (String) atomContainer.getTitle();
    }
    if (title == null) {
        throw new IllegalArgumentException(""At least one of the input molecules does not have a title"");
    }
    if (!title.equals(atomContainer.getTitle()))
        throw new IllegalArgumentException(""The input molecules does not have the same title ('"" + title + ""') as the other conformers ('"" + atomContainer.getTitle() + ""')"");
    if (atomContainer.getAtomCount() != this.atomContainer.getAtomCount())
        throw new IllegalArgumentException(""Doesn't have the same number of atoms as the rest of the conformers"");
    coordinates.add(getCoordinateList(atomContainer));
    return true;
}",add,org/openscience/cdk/ConformerContainer.java,/base/data/src/main/java/org/openscience/cdk/ConformerContainer.java,"/**
     * Add a conformer to the end of the list.
     * 
     * This method allows you to add a IAtomContainer object as another conformer.
     * Before adding it ensures that the title of specific object matches the
     * stored title for these conformers. It will also check that the number of
     * atoms in the specified molecule match the number of atoms in the current set
     * of conformers.
     * 
     * This method will not check for duplicate conformers.
     *
     * @param atomContainer The new conformer to add.
     * @return true
     */",220-252,"('add', {'INSTRUCTION': {'covered': 54, 'missed': 10}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 10, 'missed': 2}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",120.0,10.0,Add a conformer to the end of the list.,A conformer is added to the end of the list. The addition of an AtomContainer object as another conformer is permitted by the following method. Once it has been ensured that the title of the specific object matches the title stored for these conformers it is added.,The end of the list should have a conformer added to it.,0.376752516774774,  Add a conformer to the end of the list.
210,dcache,"public synchronized void remove(LoggerName logger, String appender){
    if (_rules.remove(logger, appender) != null) {
        clearCache();
    }
}",remove,dmg/util/logback/FilterThresholdSet.java,/modules/cells/src/main/java/dmg/util/logback/FilterThresholdSet.java,"/**
     * Removes the threshold of the given logger and appender combination in this threshold set. The
     * new effective threshold will be derived from the regular inheritance rules.
     */",151-159,"('remove', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,15.0,Removes the threshold of the given logger and appender combination in this threshold set.,"From the threshold set, it removes the threshold of the indicated logger and appender combination. From the regular inheritance rules the new threshold will be derived",The threshold of the given combination is removed.,0.386535814203195,  Removes the threshold from the given recorder and appendix combination in this threshold set.
211,cdk,"public void sortAtomContainers(final Comparator<IAtomContainer> comparator){
    Integer[] indexes = new Integer[atomContainerCount];
    for (int i = 0; i < indexes.length; i++) indexes[i] = i;
    Arrays.sort(indexes, new Comparator<Integer>() {

        @Override
        public int compare(Integer o1, Integer o2) {
            return comparator.compare(atomContainers[o1], atomContainers[o2]);
        }
    });
    IAtomContainer[] containersTmp = Arrays.copyOf(atomContainers, indexes.length);
    Double[] multipliersTmp = Arrays.copyOf(multipliers, indexes.length);
    for (int i = 0; i < indexes.length; i++) {
        atomContainers[i] = containersTmp[indexes[i]];
        multipliers[i] = multipliersTmp[indexes[i]];
    }
}",sortAtomContainers,org/openscience/cdk/AtomContainerSet.java,/base/data/src/main/java/org/openscience/cdk/AtomContainerSet.java,"/**
     * Sort the AtomContainers and multipliers using a provided Comparator.
     * @param comparator defines the sorting method
     */",408-439,"('sortAtomContainers', {'INSTRUCTION': {'covered': 67, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",170.0,10.0,Sort the AtomContainers and multipliers using a provided Comparator.,"Using a provided comparator, order the AtomContainers and multipliers",Sort the containers using a Comparator.,0.393783047494438,  Sort AtomContainers and multipliers using a provided comparator.
212,cdk,"static HydrogenPosition usingAngularExtent(final List<Vector2d> vectors){
    double[] extents = VecmathUtil.extents(vectors);
    Arrays.sort(extents);
    Map<HydrogenPosition, OffsetExtent> extentMap = new HashMap<HydrogenPosition, OffsetExtent>();
    for (int i = 0; i < extents.length; i++) {
        final double before = extents[i];
        final double after = extents[(i + 1) % extents.length];
        for (final HydrogenPosition position : values()) {
            final double bias = TAU - position.direction;
            double afterBias = after + bias;
            double beforeBias = before + bias;
            if (beforeBias >= TAU)
                beforeBias -= TAU;
            if (afterBias >= TAU)
                afterBias -= TAU;
            final double afterExtent = afterBias;
            final double beforeExtent = TAU - beforeBias;
            final double totalExtent = afterExtent + beforeExtent;
            final double offset = Math.abs(totalExtent / 2 - beforeExtent);
            OffsetExtent offsetExtent = extentMap.get(position);
            if (offsetExtent == null || totalExtent < offsetExtent.extent) {
                extentMap.put(position, new OffsetExtent(totalExtent, offset));
            }
        }
    }
    Set<Map.Entry<HydrogenPosition, OffsetExtent>> extentEntries = extentMap.entrySet();
    Map.Entry<HydrogenPosition, OffsetExtent> best = null;
    for (Map.Entry<HydrogenPosition, OffsetExtent> e : extentEntries) {
        if (best == null || ExtentPriority.INSTANCE.compare(e, best) < 0)
            best = e;
    }
    assert best != null;
    return best.getKey();
}",usingAngularExtent,org/openscience/cdk/renderer/generators/standard/HydrogenPosition.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/HydrogenPosition.java,"/**
     * Using the angular extents of vectors, determine the best position for a hydrogen label. The
     * position with the most space is selected first. If multiple positions have the same amount of
     * space, the one where the hydrogen position is most centred is selected. If all position are
     * okay, the priority is Right > Left > Above > Below.
     *
     * @param vectors directional vectors for each bond from an atom
     * @return best hydrogen position
     */",124-184,"('usingAngularExtent', {'INSTRUCTION': {'covered': 147, 'missed': 4}, 'BRANCH': {'covered': 20, 'missed': 2}, 'LINE': {'covered': 26, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",308.0,16.0,"Using the angular extents of vectors, determine the best position for a hydrogen label.","Determine the best position for a hydrogen label using the angular extremes of the vectors. We first select the position with the most space. The one where the hydrogen position is most centred is selected if several positions have the same amount of space. If all position are okay, the priority is Right > Left > Above > Below.",The best position for a hydrogen label is determined using the angular extents of the vectors.,0.387869030510431,"  Using the angular ranges of the vectors, determine the best position for a hydrogen label."
214,anserini,"public static Document document(IndexReader reader, String docid){
    try {
        return reader.document(IndexReaderUtils.convertDocidToLuceneDocid(reader, docid));
    } catch (Exception e) {
        return null;
    }
}",document,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,"/**
   * Returns the Lucene {@link Document} based on a collection docid. The method is named to be consistent with Lucene's
   * {@link IndexReader#document(int)}, contra Java's standard method naming conventions.
   *
   * @param reader index reader
   * @param docid collection docid
   * @return corresponding Lucene {@link Document}
   */",492-507,"('document', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,14.0,Returns the Lucene {@link Document} based on a collection docid.,"Based on the docid collection, it returns Lucene's {@link Document}. The method is called in order to be consistent with Lucene's {@link IndexReader#document(int)} as opposed to Java's standard method naming conventions.",The document is based on a collection docid.,0.319175158351138,  Returns the Lucene document {@link Document} based on a collection docid.
215,glowstone,"public boolean readBoolean(@NonNls String key, Consumer<? super Boolean> consumer){
    return readTag(key, ByteTag.class, byteVal -> consumer.accept(byteVal != 0));
}",readBoolean,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to a byte subtag if it is present, converting it to boolean first.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */",498-509,"('readBoolean', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,19.0,"Applies the given function to a byte subtag if it is present, converting it to boolean first.","If it is present, it applies the given function to a byte subtag, converting it first to a Boolean ","If the function is present, apply it to a subtag and convert it to a string.",0.404176881911894,"  Applies the given function to a byte subtag if it is present, first converting it to Boolean."
217,tablesaw,"public static boolean isAlphanumeric(final String cs){
    if (Strings.isNullOrEmpty(cs)) {
        return false;
    }
    final int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (!Character.isLetterOrDigit(cs.charAt(i))) {
            return false;
        }
    }
    return true;
}",isAlphanumeric,tech/tablesaw/util/StringUtils.java,/core/src/main/java/tech/tablesaw/util/StringUtils.java,"/**
   * Checks if the CharSequence contains only Unicode letters or digits.
   *
   * <p>{@code null} will return {@code false}. An empty CharSequence (length()=0) will return
   * {@code false}.
   *
   * <pre>
   * StringUtils.isAlphanumeric(null)   = false
   * StringUtils.isAlphanumeric("""")     = false
   * StringUtils.isAlphanumeric(""  "")   = false
   * StringUtils.isAlphanumeric(""abc"")  = true
   * StringUtils.isAlphanumeric(""ab c"") = false
   * StringUtils.isAlphanumeric(""ab2c"") = true
   * StringUtils.isAlphanumeric(""ab-c"") = false
   * </pre>
   *
   * @param cs the CharSequence to check, may be null
   * @return {@code true} if only contains letters or digits, and is non-null
   * @since 3.0 Changed signature from isAlphanumeric(String) to isAlphanumeric(CharSequence)
   * @since 3.0 Changed """" to return false and not true
   */",378-410,"('isAlphanumeric', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,11.0,Checks if the CharSequence contains only Unicode letters or digits.,Allows you to verify whether the character sequence contains only Unicode letters or digits.,The CharSequence contains only letters and digits.,0.676220004551006,  Checks whether charSequence contains only Unicode letters or numbers.
218,matsim-libs,"public void removeNodesWithoutLinks(){
    List<Node> toBeRemoved = new ArrayList<>();
    for (Node node : this.network.getNodes().values()) {
        if ((node.getInLinks().size() == 0) && (node.getOutLinks().size() == 0)) {
            toBeRemoved.add(node);
        }
    }
    for (Node node : toBeRemoved) {
        this.network.removeNode(node.getId());
    }
}",removeNodesWithoutLinks,org/matsim/core/network/algorithms/MultimodalNetworkCleaner.java,/matsim/src/main/java/org/matsim/core/network/algorithms/MultimodalNetworkCleaner.java,"/**
         * Removes nodes from the network that have no incoming or outgoing links attached to them.
         */",61-74,"('removeNodesWithoutLinks', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",100.0,16.0,Removes nodes from the network that have no incoming or outgoing links attached to them.,Nodes that have no incoming or outgoing connections are removed from the network.,The network has no incoming or outgoing links for the nodes that are removed.,0.532156791935069,  Removes nodes from the network to which no inbound or outbound links are attached.
219,tablesaw,"private void processAggregateFunctions(TableSlice slice){
    for (String toColumn : query.getArgumentList().getAggregateFunctions().keySet()) {
        FunctionCall<AggregateFunctions> functionCall = query.getArgumentList().getAggregateFunctions().get(toColumn);
        AggregateFunctions aggregateFunction = functionCall.getFunction();
        Column<?> sourceColumn = query.getTable().column(functionCall.getSourceColumnName());
        validateColumn(aggregateFunction, sourceColumn);
        Column<?> destinationColumn = destination.column(functionCall.getDestinationColumnName());
        new WindowSlider(query.getWindowFrame(), aggregateFunction, slice, sourceColumn, destinationColumn).execute();
    }
}",processAggregateFunctions,tech/tablesaw/analytic/AnalyticQueryEngine.java,/core/src/main/java/tech/tablesaw/analytic/AnalyticQueryEngine.java,"/**
   * Execute all aggregate functions for the given slice setting values in the appropriate
   * destination column.
   */",54-72,"('processAggregateFunctions', {'INSTRUCTION': {'covered': 56, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",127.0,16.0,Execute all aggregate functions for the given slice setting values in the appropriate  destination column.,From the given slice perform all aggregate functions by setting values in the appropriate destination column in the destination column,Aggregate functions for the slice setting values are executed.,0.667489598714237,  Perform all aggregation functions for the slice parameter values given in the appropriate destination column.
220,cdk,"public DescriptorValue calculate(IAtomContainer container){
    try {
        IAtomContainer clone = (IAtomContainer) container.clone();
        AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(clone);
        int nsp2 = 0;
        int nsp3 = 0;
        for (IAtom atom : clone.atoms()) {
            if (atom.getAtomicNumber() != IElement.C)
                continue;
            if (atom.getHybridization() == Hybridization.SP2)
                nsp2++;
            else if (atom.getHybridization() == Hybridization.SP3)
                nsp3++;
        }
        double ratio = nsp3 / (double) (nsp2 + nsp3);
        return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(ratio), getDescriptorNames());
    } catch (CloneNotSupportedException e) {
        return getDummyDescriptorValue(e);
    } catch (CDKException e) {
        return getDummyDescriptorValue(e);
    }
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/HybridizationRatioDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/HybridizationRatioDescriptor.java,"/**
     * Calculate sp3/sp2 hybridization ratio in the supplied {@link IAtomContainer}.
     *
     * @param container The AtomContainer for which this descriptor is to be calculated.
     * @return The ratio of sp3 to sp2 carbons
     */",112-139,"('calculate', {'INSTRUCTION': {'covered': 62, 'missed': 10}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 4}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",166.0,13.0,Calculate sp3/sp2 hybridization ratio in the supplied {@link IAtomContainer}.,The sp3/sp2 hybridisation ratio is calculated in the {@link IAtomContainer} provided.,The supplied IAtomContainer has a sp3/sp2 hybridization ratio.,1.13656483935282,Calculate the sp3/sp2 hybridization ratio in the provided {@link IAtomContainer}.
221,cdk,"private int chooseRingNumber(){
    for (int i = 1; i < rnums.length; i++) {
        if (rnums[i] == 0) {
            rnums[i] = 1;
            return i;
        }
    }
    throw new IllegalStateException(""No more ring numbers available!"");
}",chooseRingNumber,org/openscience/cdk/smarts/SmartsFragmentExtractor.java,/tool/smarts/src/main/java/org/openscience/cdk/smarts/SmartsFragmentExtractor.java,"/**
     * Select the lowest ring number for use in SMARTS.
     *
     * @return ring number
     * @throws IllegalStateException all ring numbers are used
     */",321-335,"('chooseRingNumber', {'INSTRUCTION': {'covered': 21, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,10.0,Select the lowest ring number for use in SMARTS.,Select the lowest ring number to be used in SMARTS.,The lowest ring number is used in SMARTS.,0.376267068793337,  Select the lowest ring number to use in SMARTS.
222,shardingsphere-elasticjob,"public void checkMaxTimeDiffSecondsTolerable() throws JobExecutionEnvironmentException{
    int maxTimeDiffSeconds = load(true).getMaxTimeDiffSeconds();
    if (0 > maxTimeDiffSeconds) {
        return;
    }
    long timeDiff = Math.abs(timeService.getCurrentMillis() - jobNodeStorage.getRegistryCenterTime());
    if (timeDiff > maxTimeDiffSeconds * 1000L) {
        throw new JobExecutionEnvironmentException(""Time different between job server and register center exceed '%s' seconds, max time different is '%s' seconds."", timeDiff / 1000, maxTimeDiffSeconds);
    }
}",checkMaxTimeDiffSecondsTolerable,org/apache/shardingsphere/elasticjob/lite/internal/config/ConfigurationService.java,/elasticjob-lite/elasticjob-lite-core/src/main/java/org/apache/shardingsphere/elasticjob/lite/internal/config/ConfigurationService.java,"/**
     * Check max time different seconds tolerable between job server and registry center.
     * 
     * @throws JobExecutionEnvironmentException throe JobExecutionEnvironmentException if exceed max time different seconds
     */",90-105,"('checkMaxTimeDiffSecondsTolerable', {'INSTRUCTION': {'covered': 45, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,13.0,Check max time different seconds tolerable between job server and registry center.,"Between the job server and the registration centre, the maximum time of several seconds can be controlled","Between job server and registry center, check max time.",0.266389157581326,  Check the maximum tolerable time of different seconds between the task server and the registry center.
224,matsim-libs,"public static final int findSecondTerminusStop(ArrayList<TransitStopFacility> stops){
    double totalDistance = 0;
    Map<Integer, Double> distFromStart2StopIndex = new HashMap<>();
    TransitStopFacility previousStop = stops.get(0);
    for (int i = 0; i < stops.size(); i++) {
        TransitStopFacility currentStop = stops.get(i);
        totalDistance = totalDistance + CoordUtils.calcEuclideanDistance(previousStop.getCoord(), currentStop.getCoord());
        distFromStart2StopIndex.put(i, totalDistance);
        previousStop = currentStop;
    }
    // add leg from last to first stop
    totalDistance = totalDistance + CoordUtils.calcEuclideanDistance(previousStop.getCoord(), stops.get(0).getCoord());
    // first terminus is first stop in stops, other terminus is stop half way on the
    // circular route beginning at the first stop
    for (int i = 1; i < stops.size(); i++) {
        if (distFromStart2StopIndex.get(i) >= totalDistance / 2) {
            if (Math.abs(totalDistance / 2 - distFromStart2StopIndex.get(i - 1)) > Math.abs(totalDistance / 2 - distFromStart2StopIndex.get(i))) {
                // -> if both Math.abs() are equal the previous stop (i-1) is returned
                return i;
            } else {
                return i - 1;
            }
        }
    }
    return 0;
}",findSecondTerminusStop,org/matsim/contrib/minibus/genericUtils/TerminusStopFinder.java,/contribs/minibus/src/main/java/org/matsim/contrib/minibus/genericUtils/TerminusStopFinder.java,"/**
         * Find the 2nd terminus stop (1st terminus is at index 0 per definition).
         * 
         * Returns stop index instead of the stop, in order to cater for stops which are
         * served multiple times
         * 
         * @param stops
         * @return index of the stop which is half way on the route from start stop over
         *         all stops back to the start stop
         *         
         * @author gleich
         * 
         */",31-75,"('findSecondTerminusStop', {'INSTRUCTION': {'covered': 103, 'missed': 2}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",221.0,16.0,Find the 2nd terminus stop (1st terminus is at index 0 per definition).,"Find the 2nd terminus (based on the definition, the 1st terminus is at index 0). To take into account stops that are served several times returns the stop index instead of the stop.",The 2nd stop is at index 0 per definition.,0.523233117007238,Find the 2nd terminus stop (the 1st terminus is at index 0 by definition).
225,cdk,"public static double evalSimpleIndex(IAtomContainer atomContainer, List<List<Integer>> fragLists){
    double sum = 0;
    for (List<Integer> fragList : fragLists) {
        double prod = 1.0;
        for (Integer atomSerial : fragList) {
            IAtom atom = atomContainer.getAtom(atomSerial);
            int nconnected = atomContainer.getConnectedBondsCount(atom);
            prod = prod * nconnected;
        }
        if (prod != 0)
            sum += 1.0 / Math.sqrt(prod);
    }
    return sum;
}",evalSimpleIndex,org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,"/**
     * Evaluates the simple chi index for a set of fragments.
     *
     * @param atomContainer The target <code>AtomContainer</code>
     * @param fragLists      A list of fragments
     * @return The simple chi index
     */",101-120,"('evalSimpleIndex', {'INSTRUCTION': {'covered': 53, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",96.0,11.0,Evaluates the simple chi index for a set of fragments.,For a set of fragments evaluate the simple chi index ,Evaluates the chi index for a set of fragments.,0.103356143361033,  Evaluates the simple chi index for a set of fragments.
226,dcache,"public synchronized boolean hasAppender(String appender){
    return _appenders.contains(appender) || (_parent != null && _parent.hasAppender(appender));
}",hasAppender,dmg/util/logback/FilterThresholdSet.java,/modules/cells/src/main/java/dmg/util/logback/FilterThresholdSet.java,"/**
     * Returns whether the appender is valid is valid for use in a threshold definition.
     */",104-110,"('hasAppender', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,15.0,Returns whether the appender is valid is valid for use in a threshold definition.,"For use in a threshold definition, it returns whether the appender is valid or not.","If the appender is valid, it is valid for use in a threshold definition.",0.512660324188762,  Indicates whether the appendix is valid and valid for use in a threshold definition.
227,cdk,"public IBond clone() throws CloneNotSupportedException{
    Bond clone = (Bond) super.clone();
    if (atoms != null) {
        clone.atoms = new IAtom[atoms.length];
        for (int f = 0; f < atoms.length; f++) {
            if (atoms[f] != null) {
                clone.atoms[f] = (IAtom) ((IAtom) atoms[f]).clone();
            }
        }
    }
    return clone;
}",clone,org/openscience/cdk/Bond.java,/base/data/src/main/java/org/openscience/cdk/Bond.java,"/**
     * Clones this bond object, including clones of the atoms between which the
     * bond is defined.
     *
     * @return The cloned object
     */",553-572,"('clone', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",97.0,17.0,"Clones this bond object, including clones of the atoms between which the  bond is defined.","Clone the following bond object, including clones of the atoms between which the bond is defined","Clones the bond object, including the atoms between it.",0.369602656230942,"  Clones this binding object, including clones of the atoms between which the bond is defined."
228,jackson-databind,"public SimpleModule addValueInstantiator(Class<?> beanType, ValueInstantiator inst){
    _checkNotNull(beanType, ""class to register value instantiator for"");
    _checkNotNull(inst, ""value instantiator"");
    if (_valueInstantiators == null) {
        _valueInstantiators = new SimpleValueInstantiators();
    }
    _valueInstantiators = _valueInstantiators.addValueInstantiator(beanType, inst);
    return this;
}",addValueInstantiator,com/fasterxml/jackson/databind/module/SimpleModule.java,/src/main/java/com/fasterxml/jackson/databind/module/SimpleModule.java,"/**
     * Method for registering {@link ValueInstantiator} to use when deserializing
     * instances of type <code>beanType</code>.
     *<p>
     * Instantiator is
     * registered when module is registered for <code>ObjectMapper</code>.
     */",470-486,"('addValueInstantiator', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",58.0,23.0,Method for registering {@link ValueInstantiator} to use when deserializing  instances of type <code>beanType</code>.,The method to register {@link ValueInstantiator} is used when deserialising instances of type <code>beanType</code>. When the module is registered for <code>ObjectMapper</code> the instantiator is registered.,The method for registration @link ValueInstantiator is used when deserializing instances of type code>beanType/code>.,0.70196409527169,  The method for registering {@link ValueInstantiator} to use when deserializing instances of type <code>beanType</code>.
229,cdk,"public DescriptorValue calculate(IBond bond, IAtomContainer ac){
    Double originalCharge1 = bond.getBegin().getCharge();
    String originalAtomtypeName1 = bond.getBegin().getAtomTypeName();
    Integer originalNeighborCount1 = bond.getBegin().getFormalNeighbourCount();
    IAtomType.Hybridization originalHybridization1 = bond.getBegin().getHybridization();
    Integer originalValency1 = bond.getBegin().getValency();
    Double originalCharge2 = bond.getEnd().getCharge();
    String originalAtomtypeName2 = bond.getEnd().getAtomTypeName();
    Integer originalNeighborCount2 = bond.getEnd().getFormalNeighbourCount();
    IAtomType.Hybridization originalHybridization2 = bond.getEnd().getHybridization();
    Integer originalValency2 = bond.getEnd().getValency();
    Double originalBondOrderSum1 = bond.getBegin().getBondOrderSum();
    Order originalMaxBondOrder1 = bond.getBegin().getMaxBondOrder();
    Double originalBondOrderSum2 = bond.getEnd().getBondOrderSum();
    Order originalMaxBondOrder2 = bond.getEnd().getMaxBondOrder();
    if (!isCachedAtomContainer(ac)) {
        try {
            AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(ac);
            if (lpeChecker) {
                LonePairElectronChecker lpcheck = new LonePairElectronChecker();
                lpcheck.saturate(ac);
            }
        } catch (CDKException e) {
            return getDummyDescriptorValue(e);
        }
        if (maxIterations != -1)
            peoe.setMaxGasteigerIters(maxIterations);
        if (maxIterations != -1)
            pepe.setMaxGasteigerIters(maxIterations);
        if (maxResonStruc != -1)
            pepe.setMaxResoStruc(maxResonStruc);
        try {
            peoe.assignGasteigerMarsiliSigmaPartialCharges(ac, true);
            List<Double> peoeBond = new ArrayList<Double>();
            for (Iterator<IBond> it = ac.bonds().iterator(); it.hasNext(); ) {
                IBond bondi = it.next();
                double result = Math.abs(bondi.getBegin().getCharge() - bondi.getEnd().getCharge());
                peoeBond.add(result);
            }
            for (Iterator<IAtom> it = ac.atoms().iterator(); it.hasNext(); ) it.next().setCharge(0.0);
            pepe.assignGasteigerPiPartialCharges(ac, true);
            for (int i = 0; i < ac.getBondCount(); i++) {
                IBond bondi = ac.getBond(i);
                double result = Math.abs(bondi.getBegin().getCharge() - bondi.getEnd().getCharge());
                cacheDescriptorValue(bondi, ac, new DoubleResult(peoeBond.get(i) + result));
            }
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }
    bond.getBegin().setCharge(originalCharge1);
    bond.getBegin().setAtomTypeName(originalAtomtypeName1);
    bond.getBegin().setHybridization(originalHybridization1);
    bond.getBegin().setValency(originalValency1);
    bond.getBegin().setFormalNeighbourCount(originalNeighborCount1);
    bond.getEnd().setCharge(originalCharge2);
    bond.getEnd().setAtomTypeName(originalAtomtypeName2);
    bond.getEnd().setHybridization(originalHybridization2);
    bond.getEnd().setValency(originalValency2);
    bond.getEnd().setFormalNeighbourCount(originalNeighborCount2);
    bond.getBegin().setMaxBondOrder(originalMaxBondOrder1);
    bond.getBegin().setBondOrderSum(originalBondOrderSum1);
    bond.getEnd().setMaxBondOrder(originalMaxBondOrder2);
    bond.getEnd().setBondOrderSum(originalBondOrderSum2);
    return getCachedDescriptorValue(bond) != null ? new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), getCachedDescriptorValue(bond), NAMES) : null;
}",calculate,org/openscience/cdk/qsar/descriptors/bond/BondPartialTChargeDescriptor.java,/descriptor/qsarbond/src/main/java/org/openscience/cdk/qsar/descriptors/bond/BondPartialTChargeDescriptor.java,"/**
     *  The method calculates the bond total Partial charge of a given bond
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *
     *@param  ac                AtomContainer
     *@return return the sigma electronegativity
     */",152-230,"('calculate', {'INSTRUCTION': {'covered': 256, 'missed': 27}, 'BRANCH': {'covered': 13, 'missed': 5}, 'LINE': {'covered': 54, 'missed': 4}, 'COMPLEXITY': {'covered': 5, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",714.0,25.0,The method calculates the bond total Partial charge of a given bond  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.,The total partial charge of a given bond is calculated. The method addExplicitHydrogensToSatisfyValency must be called from the tools.HydrogenAdder class. ,The method calculates the bond total partial charge of a given bond,0.428708045296393,  The method calculates the total partial load of the binding of a given link It is necessary to call the addExplicitHydrogensToSatisfyValency method from the class tools.
230,dcache,"public static Checksum parseChecksum(String digest){
    requireNonNull(digest, ""value may not be null"");
    int del = digest.indexOf(DELIMITER);
    if (del < 1) {
        throw new IllegalArgumentException(""Not a dCache checksum: "" + digest);
    }
    String type = digest.substring(0, del);
    String checksum = digest.substring(del + 1);
    return new Checksum(ChecksumType.getChecksumType(type), checksum);
}",parseChecksum,org/dcache/util/Checksum.java,/modules/common/src/main/java/org/dcache/util/Checksum.java,"/**
     * Create a new checksum instance for an already computed digest of a particular type.
     *
     * @param digest the input must have the following format:
     *               <type>:<hexadecimal digest>
     * @throws IllegalArgumentException if argument has wrong form
     * @throws NullPointerException     if argument is null
     */",130-150,"('parseChecksum', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",82.0,15.0,Create a new checksum instance for an already computed digest of a particular type.,"For an already calculated digest of a particular type, create a new checksum instance",A new instance of a particular type is needed.,0.543560005567141,  Create a new checksum instance for an already calculated summary of a particular type.
231,weblogic-kubernetes-operator," boolean isIstioEnabled(){
    return Optional.ofNullable(configuration).map(Configuration::getIstio).map(Istio::getEnabled).orElse(false);
}",isIstioEnabled,oracle/kubernetes/weblogic/domain/model/DomainSpec.java,/operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainSpec.java,"/**
   * Test if the domain is deployed under Istio environment.
   *
   * @return istioEnabled
   */",835-845,"('isIstioEnabled', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,10.0,Test if the domain is deployed under Istio environment.,Allows you to check whether the domain is distributed in the Istio environment,"If the domain is deployed under Istio, you should test it.",0.110559920782763,  Test whether the domain is deployed under the Istio environment.
232,weblogic-kubernetes-operator,"public boolean hasNamedServer(String serverName){
    return getServerConfigs().stream().anyMatch(c -> serverName.equals(c.getName()));
}",hasNamedServer,oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,"/**
   * Returns true if one of the servers in the cluster has the specified name.
   *
   * @param serverName the name to look for
   * @return true or false
   */",135-143,"('hasNamedServer', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,15.0,Returns true if one of the servers in the cluster has the specified name.,"In the event that one of the servers in the cluster bears the specified name, true is returned.","If one of the server in the cluster has the specified name, this is true.",1.3710665481329,  Returns true if one of the servers in the cluster has the specified name.
234,acs-aem-commons,"private boolean isDispatcherTransportURI(final Agent agent){
    final String transportURI = agent.getConfiguration().getTransportURI();
    return (StringUtils.startsWith(transportURI, HTTP) || StringUtils.startsWith(transportURI, HTTPS));
}",isDispatcherTransportURI,com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,"/**
     * Checks if the agent has a valid transport URI set.
     *
     * @param agent Agent to check
     * @return true if the Agent's transport URI is in the proper form
     */",142-153,"('isDispatcherTransportURI', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,11.0,Checks if the agent has a valid transport URI set.,Verify whether the agent reports a valid transport URI,The agent is checked if they have a valid transport set.,0.787137996858752,  Checks whether the agent has a valid transport URI.
235,anserini,"public final Iterator<FileSegment<T>> iterator(){
    List<Path> paths = discover(this.path);
    Iterator<Path> pathsIterator = paths.iterator();
    return new Iterator<>() {

        Path segmentPath;

        FileSegment<T> segment;

        @Override
        public boolean hasNext() {
            if (segment != null) {
                return true;
            }
            if (!pathsIterator.hasNext()) {
                return false;
            } else {
                try {
                    segmentPath = pathsIterator.next();
                    segment = createFileSegment(segmentPath);
                } catch (IOException e) {
                    return false;
                }
            }
            return true;
        }

        @Override
        public FileSegment<T> next() throws NoSuchElementException {
            if (!hasNext()) {
                throw new NoSuchElementException(""No more file segments to read."");
            } else {
                FileSegment<T> seg = segment;
                segment = null;
                return seg;
            }
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    };
}",iterator,io/anserini/collection/DocumentCollection.java,/src/main/java/io/anserini/collection/DocumentCollection.java,"/**
   * An iterator over {@code FileSegment} for the {@code DocumentCollection} iterable.
   * A collection is comprised of one or more file segments.
   */",98-145,"('iterator', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",189.0,17.0,An iterator over {@code FileSegment} for the {@code DocumentCollection} iterable.,An iterator on {@code FileSegment} for the iterable {@code DocumentCollection}. A collection may consist of one or more file segments,The iterator is over @code DocumentCollection.,0.687896165886014,  An iterator on {@code FileSegment} for the iterable {@code DocumentCollection}.
236,jackson-databind,"protected MappingIterator<T> _newIterator(JsonParser p, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean parserManaged){
    return new MappingIterator<T>(_valueType, p, ctxt, deser, parserManaged, _valueToUpdate);
}",_newIterator,com/fasterxml/jackson/databind/ObjectReader.java,/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java,"/**
     * Factory method used to create {@link MappingIterator} instances;
     * either default, or custom subtype.
     * 
     * @since 2.5
     */",326-337,"('_newIterator', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,19.0,"Factory method used to create {@link MappingIterator} instances;  either default, or custom subtype.",Method for creating instances of {@link MappingIterator} custom subtype or either default,The factory method creates @link MappingIterator instances.,0.872265713559452,  A factory method used to create {@link MappingIterator} instances;  either by default or custom subtype.
237,cdk,"private static void addExtendedTetrahedralConfiguration(ExtendedTetrahedral et, GraphBuilder gb, Map<IAtom, Integer> indices){
    IAtom[] ligands = et.peripherals();
    int u = indices.get(et.focus());
    int[] vs = new int[] { indices.get(ligands[0]), indices.get(ligands[1]), indices.get(ligands[2]), indices.get(ligands[3]) };
    gb.extendedTetrahedral(u).lookingFrom(vs[0]).neighbors(vs[1], vs[2], vs[3]).winding(et.winding() == CLOCKWISE ? Configuration.CLOCKWISE : Configuration.ANTI_CLOCKWISE).build();
}",addExtendedTetrahedralConfiguration,org/openscience/cdk/smiles/CDKToBeam.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/CDKToBeam.java,"/**
     * Add extended tetrahedral stereo configuration to the Beam GraphBuilder.
     *
     * @param et      stereo element specifying tetrahedral configuration
     * @param gb      the current graph builder
     * @param indices atom indices
     */",348-366,"('addExtendedTetrahedralConfiguration', {'INSTRUCTION': {'covered': 81, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",153.0,10.0,Add extended tetrahedral stereo configuration to the Beam GraphBuilder.,Extended tetrahedral stereo configuration added to Beam GraphBuilder,The Beam GraphBuilder can be used to add extended stereo configuration.,0.29998816493298,  Add an extended tetrahedral stereo configuration to the Beam GraphBuilder.
238,matsim-libs,"protected void relaxNode(final Node outNode, final Node toNode, final RouterPriorityQueue<Node> pendingNodes){
    DijkstraNodeData outData = getData(outNode);
    double currTime = outData.getTime();
    double currCost = outData.getCost();
    if (this.pruneDeadEnds) {
        PreProcessDijkstra.DeadEndData ddOutData = getPreProcessData(outNode);
        for (Link l : outNode.getOutLinks().values()) {
            relaxNodeLogic(l, pendingNodes, currTime, currCost, toNode, ddOutData);
        }
    } else {
        for (Link l : outNode.getOutLinks().values()) {
            relaxNodeLogic(l, pendingNodes, currTime, currCost, toNode, null);
        }
    }
}",relaxNode,org/matsim/core/router/Dijkstra.java,/matsim/src/main/java/org/matsim/core/router/Dijkstra.java,"/**
         * Expands the given Node in the routing algorithm; may be overridden in
         * sub-classes.
         *
         * @param outNode
         *            The Node to be expanded.
         * @param toNode
         *            The target Node of the route.
         * @param pendingNodes
         *            The set of pending nodes so far.
         */",371-398,"('relaxNode', {'INSTRUCTION': {'covered': 61, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",132.0,15.0,Expands the given Node in the routing algorithm; may be overridden in  sub-classes.,This method allows the expansion of the given node in the routing algorithm; it can also be overridden in the subclasses,The given Node may be expanded in the routing algorithm.,0.632716567611816,  Expands the given node in the routing algorithm; can be replaced in subclasses.
239,tablesaw,"private List<Index> buildIndexesForJoinColumns(List<Integer> joinColumnIndexes, Table table){
    return joinColumnIndexes.stream().map(c -> indexFor(table, c)).collect(Collectors.toList());
}",buildIndexesForJoinColumns,tech/tablesaw/joining/DataFrameJoiner.java,/core/src/main/java/tech/tablesaw/joining/DataFrameJoiner.java,/** Build a reverse index for every join column in the table. */,336-339,"('buildIndexesForJoinColumns', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,12.0,Build a reverse index for every join column in the table.," For each join column in the table, create an inverse index",Every join column in the table should be built with a reverse index.,0.77643292894935, Create an inverse index for each join column in the table.
240,cdk,"public IAtomContainer generate(IAtomContainerSet atomContainers) throws CDKException{
    int iteration = 0;
    boolean structureFound = false;
    do {
        iteration++;
        boolean bondFormed;
        do {
            bondFormed = false;
            for (IAtomContainer ac : atomContainers.atomContainers()) {
                for (IAtom atom : AtomContainerManipulator.getAtomArray(ac)) {
                    if (!satCheck.isSaturated(atom, ac)) {
                        IAtom partner = getAnotherUnsaturatedNode(atom, ac, atomContainers);
                        if (partner != null) {
                            IAtomContainer toadd = AtomContainerSetManipulator.getRelevantAtomContainer(atomContainers, partner);
                            double cmax1 = satCheck.getCurrentMaxBondOrder(atom, ac);
                            double cmax2 = satCheck.getCurrentMaxBondOrder(partner, toadd);
                            double max = Math.min(cmax1, cmax2);
                            // (double)Math.round(Math.random() * max)
                            double order = Math.min(Math.max(1.0, max), 3.0);
                            logger.debug(""cmax1, cmax2, max, order: "" + cmax1 + "", "" + cmax2 + "", "" + max + "", "" + order);
                            if (toadd != ac) {
                                atomContainers.removeAtomContainer(toadd);
                                ac.add(toadd);
                            }
                            ac.addBond(ac.getBuilder().newInstance(IBond.class, atom, partner, BondManipulator.createBondOrder(order)));
                            bondFormed = true;
                        }
                    }
                }
            }
        } while (bondFormed);
        if (atomContainers.getAtomContainerCount() == 1 && satCheck.allSaturated(atomContainers.getAtomContainer(0))) {
            structureFound = true;
        }
    } while (!structureFound && iteration < 5);
    if (atomContainers.getAtomContainerCount() == 1 && satCheck.allSaturated(atomContainers.getAtomContainer(0))) {
        structureFound = true;
    }
    if (!structureFound)
        throw new CDKException(""Could not combine the fragments to combine a valid, satured structure"");
    return atomContainers.getAtomContainer(0);
}",generate,org/openscience/cdk/structgen/stochastic/PartialFilledStructureMerger.java,/tool/structgen/src/main/java/org/openscience/cdk/structgen/stochastic/PartialFilledStructureMerger.java,"/**
     * Randomly generates a single, connected, correctly bonded structure from
     * a number of fragments.  IMPORTANT: The AtomContainers in the set must be
     * connected. If an AtomContainer is disconnected, no valid result will
     * be formed
     * @param atomContainers The fragments to generate for.
     * @return The newly formed structure.
     * @throws CDKException No valid result could be formed.
     */",62-115,"('generate', {'INSTRUCTION': {'covered': 168, 'missed': 8}, 'BRANCH': {'covered': 17, 'missed': 9}, 'LINE': {'covered': 31, 'missed': 1}, 'COMPLEXITY': {'covered': 6, 'missed': 8}, 'METHOD': {'covered': 1, 'missed': 0}})",332.0,16.0,"Randomly generates a single, connected, correctly bonded structure from  a number of fragments.","A single, connected and correctly bound structure from a set of fragments is generated randomly. IMPORTANT: The AtomContainers of the collection must be connected. No valid result will be formed if an AtomContainer is disconnected.","Randomly generated a single, connected, correctly bonded structure from a number of fragments.",0.984073489481379,"  Randomly generates a single, connected, and properly linked structure from a number of fragments."
241,cdk,"protected void generateAtomContainerFromInchi(IChemObjectBuilder builder) throws CDKException{
    InchiInput input = output.getInchiInput();
    molecule = builder.newInstance(IAtomContainer.class);
    Map<InchiAtom, IAtom> inchiCdkAtomMap = new HashMap<InchiAtom, IAtom>();
    List<InchiAtom> atoms = input.getAtoms();
    for (int i = 0; i < atoms.size(); i++) {
        InchiAtom iAt = atoms.get(i);
        IAtom cAt = builder.newInstance(IAtom.class);
        inchiCdkAtomMap.put(iAt, cAt);
        cAt.setID(""a"" + i);
        cAt.setAtomicNumber(Elements.ofString(iAt.getElName()).number());
        cAt.setFormalCharge(iAt.getCharge());
        cAt.setImplicitHydrogenCount(iAt.getImplicitHydrogen());
        int isotopicMass = iAt.getIsotopicMass();
        if (isotopicMass != 0) {
            if (isotopicMass > ISOTOPIC_SHIFT_THRESHOLD) {
                try {
                    int massNumber = Isotopes.getInstance().getMajorIsotope(cAt.getAtomicNumber()).getMassNumber();
                    cAt.setMassNumber(massNumber + (isotopicMass - ISOTOPIC_SHIFT_FLAG));
                } catch (IOException e) {
                    throw new CDKException(""Could not load Isotopes data"", e);
                }
            } else {
                cAt.setMassNumber(isotopicMass);
            }
        }
        molecule.addAtom(cAt);
        cAt = molecule.getAtom(molecule.getAtomCount() - 1);
        addHydrogenIsotopes(builder, cAt, 2, iAt.getImplicitDeuterium());
        addHydrogenIsotopes(builder, cAt, 3, iAt.getImplicitTritium());
    }
    List<InchiBond> bonds = input.getBonds();
    for (int i = 0; i < bonds.size(); i++) {
        InchiBond iBo = bonds.get(i);
        IBond cBo = builder.newInstance(IBond.class);
        IAtom atO = inchiCdkAtomMap.get(iBo.getStart());
        IAtom atT = inchiCdkAtomMap.get(iBo.getEnd());
        cBo.setAtoms(new IAtom[] { atO, atT });
        InchiBondType type = iBo.getType();
        switch(type) {
            case SINGLE:
                cBo.setOrder(IBond.Order.SINGLE);
                break;
            case DOUBLE:
                cBo.setOrder(IBond.Order.DOUBLE);
                break;
            case TRIPLE:
                cBo.setOrder(IBond.Order.TRIPLE);
                break;
            case ALTERN:
                cBo.setIsInRing(true);
                break;
            default:
                throw new CDKException(""Unknown bond type: "" + type);
        }
        InchiBondStereo stereo = iBo.getStereo();
        switch(stereo) {
            case NONE:
                cBo.setStereo(IBond.Stereo.NONE);
                break;
            case SINGLE_1DOWN:
                cBo.setStereo(IBond.Stereo.DOWN);
                break;
            case SINGLE_1UP:
                cBo.setStereo(IBond.Stereo.UP);
                break;
            case SINGLE_2DOWN:
                cBo.setStereo(IBond.Stereo.DOWN_INVERTED);
                break;
            case SINGLE_2UP:
                cBo.setStereo(IBond.Stereo.UP_INVERTED);
                break;
            case SINGLE_1EITHER:
                cBo.setStereo(IBond.Stereo.UP_OR_DOWN);
                break;
            case SINGLE_2EITHER:
                cBo.setStereo(IBond.Stereo.UP_OR_DOWN_INVERTED);
                break;
        }
        molecule.addBond(cBo);
    }
    List<InchiStereo> stereos = input.getStereos();
    for (int i = 0; i < stereos.size(); i++) {
        InchiStereo stereo0d = stereos.get(i);
        if (stereo0d.getType() == InchiStereoType.Tetrahedral || stereo0d.getType() == InchiStereoType.Allene) {
            InchiAtom central = stereo0d.getCentralAtom();
            InchiAtom[] neighbours = stereo0d.getAtoms();
            IAtom focus = inchiCdkAtomMap.get(central);
            IAtom[] neighbors = new IAtom[] { inchiCdkAtomMap.get(neighbours[0]), inchiCdkAtomMap.get(neighbours[1]), inchiCdkAtomMap.get(neighbours[2]), inchiCdkAtomMap.get(neighbours[3]) };
            ITetrahedralChirality.Stereo stereo;
            if (stereo0d.getParity() == InchiStereoParity.ODD) {
                stereo = ITetrahedralChirality.Stereo.ANTI_CLOCKWISE;
            } else if (stereo0d.getParity() == InchiStereoParity.EVEN) {
                stereo = ITetrahedralChirality.Stereo.CLOCKWISE;
            } else {
                continue;
            }
            IStereoElement stereoElement = null;
            if (stereo0d.getType() == InchiStereoType.Tetrahedral) {
                stereoElement = builder.newInstance(ITetrahedralChirality.class, focus, neighbors, stereo);
            } else if (stereo0d.getType() == InchiStereoType.Allene) {
                IAtom[] peripherals = neighbors;
                IAtom[] terminals = ExtendedTetrahedral.findTerminalAtoms(molecule, focus);
                for (IAtom terminal : terminals) {
                    if (peripherals[1].equals(terminal)) {
                        peripherals[1] = findOtherSinglyBonded(molecule, terminal, peripherals[0]);
                    } else if (peripherals[2].equals(terminal)) {
                        peripherals[2] = findOtherSinglyBonded(molecule, terminal, peripherals[3]);
                    } else if (peripherals[0].equals(terminal)) {
                        peripherals[0] = findOtherSinglyBonded(molecule, terminal, peripherals[1]);
                    } else if (peripherals[3].equals(terminal)) {
                        peripherals[3] = findOtherSinglyBonded(molecule, terminal, peripherals[2]);
                    }
                }
                stereoElement = new ExtendedTetrahedral(focus, peripherals, stereo);
            }
            assert stereoElement != null;
            molecule.addStereoElement(stereoElement);
        } else if (stereo0d.getType() == InchiStereoType.DoubleBond) {
            boolean extended = false;
            InchiAtom[] neighbors = stereo0d.getAtoms();
            IAtom x = inchiCdkAtomMap.get(neighbors[0]);
            IAtom a = inchiCdkAtomMap.get(neighbors[1]);
            IAtom b = inchiCdkAtomMap.get(neighbors[2]);
            IAtom y = inchiCdkAtomMap.get(neighbors[3]);
            IBond stereoBond = molecule.getBond(a, b);
            if (stereoBond == null) {
                extended = true;
                IBond tmp = null;
                stereoBond = ExtendedCisTrans.findCentralBond(molecule, a);
                if (stereoBond == null)
                    continue;
                IAtom[] ends = ExtendedCisTrans.findTerminalAtoms(molecule, stereoBond);
                assert ends != null;
                if (ends[0] != a)
                    flip(stereoBond);
            } else {
                if (!stereoBond.getBegin().equals(a))
                    flip(stereoBond);
            }
            int config = IStereoElement.TOGETHER;
            if (stereo0d.getParity() == InchiStereoParity.EVEN)
                config = IStereoElement.OPPOSITE;
            if (extended) {
                molecule.addStereoElement(new ExtendedCisTrans(stereoBond, new IBond[] { molecule.getBond(x, a), molecule.getBond(b, y) }, config));
            } else {
                molecule.addStereoElement(new DoubleBondStereochemistry(stereoBond, new IBond[] { molecule.getBond(x, a), molecule.getBond(b, y) }, config));
            }
        }
    }
}",generateAtomContainerFromInchi,org/openscience/cdk/inchi/InChIToStructure.java,/storage/inchi/src/main/java/org/openscience/cdk/inchi/InChIToStructure.java,"/**
     * Gets structure from InChI, and converts InChI library data structure
     * into an IAtomContainer.
     *
     * @throws CDKException
     */",158-384,"('generateAtomContainerFromInchi', {'INSTRUCTION': {'covered': 515, 'missed': 119}, 'BRANCH': {'covered': 39, 'missed': 28}, 'LINE': {'covered': 97, 'missed': 26}, 'COMPLEXITY': {'covered': 13, 'missed': 26}, 'METHOD': {'covered': 1, 'missed': 0}})",1349.0,15.0,"Gets structure from InChI, and converts InChI library data structure  into an IAtomContainer.","Once the structure has been obtained from InChI, it converts the data structure of the InChI library into an IAtomContainer.",Gets structure from InChI and converts it into an IAtomContainer.,0.32404378516653,  Gets the structure of InChI and converts the data structure of the InChI library to IAtomContainer.
242,cdk,"private void layoutAcyclicParts() throws CDKException{
    logger.debug(""Start of handleAliphatics"");
    int safetyCounter = 0;
    IAtomContainer unplacedAtoms = null;
    IAtomContainer placedAtoms = null;
    IAtomContainer longestUnplacedChain = null;
    IAtom atom = null;
    Vector2d direction = null;
    Vector2d startVector = null;
    boolean done;
    do {
        safetyCounter++;
        done = false;
        atom = getNextAtomWithAliphaticUnplacedNeigbors();
        if (atom != null) {
            unplacedAtoms = getUnplacedAtoms(atom);
            placedAtoms = getPlacedAtoms(atom);
            longestUnplacedChain = atomPlacer.getLongestUnplacedChain(molecule, atom);
            logger.debug(""---start of longest unplaced chain---"");
            try {
                logger.debug(""Start at atom no. "" + (molecule.indexOf(atom) + 1));
                logger.debug(AtomPlacer.listNumbers(molecule, longestUnplacedChain));
            } catch (Exception exc) {
                logger.debug(exc);
            }
            logger.debug(""---end of longest unplaced chain---"");
            if (longestUnplacedChain.getAtomCount() > 1) {
                if (placedAtoms.getAtomCount() > 1) {
                    logger.debug(""More than one atoms placed already"");
                    logger.debug(""trying to place neighbors of atom "" + (molecule.indexOf(atom) + 1));
                    atomPlacer.distributePartners(atom, placedAtoms, GeometryUtil.get2DCenter(placedAtoms), unplacedAtoms, bondLength);
                    direction = new Vector2d(longestUnplacedChain.getAtom(1).getPoint2d());
                    startVector = new Vector2d(atom.getPoint2d());
                    direction.sub(startVector);
                    logger.debug(""Done placing neighbors of atom "" + (molecule.indexOf(atom) + 1));
                } else {
                    logger.debug(""Less than or equal one atoms placed already"");
                    logger.debug(""Trying to get next bond vector."");
                    direction = atomPlacer.getNextBondVector(atom, placedAtoms.getAtom(0), GeometryUtil.get2DCenter(molecule), true);
                }
                for (int f = 1; f < longestUnplacedChain.getAtomCount(); f++) {
                    longestUnplacedChain.getAtom(f).setFlag(CDKConstants.ISPLACED, false);
                }
                atomPlacer.placeLinearChain(longestUnplacedChain, direction, bondLength);
            } else {
                done = true;
            }
        } else {
            done = true;
        }
    } while (!done && safetyCounter <= molecule.getAtomCount());
    logger.debug(""End of handleAliphatics"");
}",layoutAcyclicParts,org/openscience/cdk/layout/StructureDiagramGenerator.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/StructureDiagramGenerator.java,"/**
     * Does a layout of all aliphatic parts connected to the parts of the molecule
     * that have already been laid out. Starts at the first bond with unplaced
     * neighbours and stops when a ring is encountered.
     *
     * @throws CDKException if an error occurs
     */",1829-1900,"('layoutAcyclicParts', {'INSTRUCTION': {'covered': 192, 'missed': 4}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 41, 'missed': 2}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",413.0,21.0,Does a layout of all aliphatic parts connected to the parts of the molecule  that have already been laid out.,On the basis of all the aliphatic parts connected to the parts of the molecule already arranged makes an arrangement. It starts from the first bond with unpositioned neighbours and stops when a ring is encountered.,Does a layout of all the aliphatic parts of the molecule.,0.538570797595953,  Makes a layout of all the aliphatic parts connected to the parts of the molecule that have already been arranged.
243,cdk,"public void registerParameters(IGenerator<? extends IChemObject> generator){
    for (IGeneratorParameter<?> param : generator.getParameters()) {
        try {
            renderingParameters.put(param.getClass().getName(), param.getClass().newInstance());
        } catch (InstantiationException | IllegalAccessException e) {
            throw new IllegalStateException(""Could not create a copy of rendering parameter."");
        }
    }
}",registerParameters,org/openscience/cdk/renderer/RendererModel.java,/display/render/src/main/java/org/openscience/cdk/renderer/RendererModel.java,"/**
     * Registers rendering parameters from {@link IGenerator}s
     * with this model.
     *
     * @param generator
     */",266-281,"('registerParameters', {'INSTRUCTION': {'covered': 25, 'missed': 6}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,14.0,Registers rendering parameters from {@link IGenerator}s  with this model.,Registers rendering parameters from {@link IGenerator}s with this template,Registers parameters from @link IGenerators.,1.66844739372781,  Saves the rendering parameters of {@link IGenerator} with this template.
244,jackson-databind,"public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource){
    _mixIns.addLocalDefinition(target, mixinSource);
    return this;
}",addMixIn,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Method to use for adding mix-in annotations to use for augmenting
     * specified class or interface. All annotations from
     * <code>mixinSource</code> are taken to override annotations
     * that <code>target</code> (or its supertypes) has.
     *
     * @param target Class (or interface) whose annotations to effectively override
     * @param mixinSource Class (or interface) whose annotations are to
     *   be ""added"" to target's annotations, overriding as necessary
     *
     * @since 2.5
     */",1502-1518,"('addMixIn', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,16.0,Method to use for adding mix-in annotations to use for augmenting  specified class or interface.,Add mix-in annotations to be used to augment the specified class or interface. The mixinSource annotations are considered to override the annotations that the target (or its supertypes) possesses.,Adding mix-in annotations is a method to use.,0.625928163930459,  Method to use to add mix annotations to use to augment the specified class or interface.
245,cdk,"static Point2d[] decodeCoordinates(String str){
    if (str.startsWith(""|("")) {
        int end = str.indexOf(')', 2);
        if (end < 0)
            return new Point2d[0];
        String[] strs = str.substring(2, end).split("";"");
        Point2d[] points = new Point2d[strs.length];
        for (int i = 0; i < strs.length; i++) {
            String coord = strs[i];
            int first = coord.indexOf(',');
            int second = coord.indexOf(',', first + 1);
            String x = coord.substring(0, first);
            String y = coord.substring(first + 1, second);
            if (x.isEmpty())
                x = ""0"";
            if (y.isEmpty())
                y = ""0"";
            points[i] = new Point2d(Double.parseDouble(x), Double.parseDouble(y));
        }
        return points;
    } else {
        String[] strs = str.split("", "");
        Point2d[] points = new Point2d[strs.length / 2];
        for (int i = 0; i < strs.length; i += 2) {
            points[i / 2] = new Point2d(Double.parseDouble(strs[i]), Double.parseDouble(strs[i + 1]));
        }
        return points;
    }
}",decodeCoordinates,org/openscience/cdk/layout/IdentityTemplateLibrary.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/IdentityTemplateLibrary.java,"/**
     * Decode coordinates that have been placed in a byte buffer.
     *
     * @param str the string to decode
     * @return array of coordinates
     */",245-280,"('decodeCoordinates', {'INSTRUCTION': {'covered': 115, 'missed': 5}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 22, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",290.0,11.0,Decode coordinates that have been placed in a byte buffer.,Coordinates that have been entered into a byte buffer are decoded,The coordinates are in a buffer.,0.275746538701339,  Decode the coordinates that have been placed in a byte buffer.
246,cdk,"TextOutline resize(final double scaleX, final double scaleY){
    final Point2D center = getCenter();
    final AffineTransform transform = new AffineTransform();
    transform.translate(center.getX(), center.getY());
    transform.scale(scaleX, scaleY);
    transform.translate(-center.getX(), -center.getY());
    return transform(transform);
}",resize,org/openscience/cdk/renderer/generators/standard/TextOutline.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/TextOutline.java,"/**
     * Convenience function to resize the outline and maintain the existing
     * center point.
     *
     * @param scaleX scale x-axis
     * @param scaleY scale y-axis
     * @return resized outline
     */",215-230,"('resize', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",81.0,13.0,Convenience function to resize the outline and maintain the existing  center point.,Function to maintain the existing centre point and resize the contour,"To maintain the center point, the convenience function is needed.",1.46906205936172,  Convenience function to resize the outline and hold the existing center point.
247,cdk,"void markRow(int i, int marking){
    for (int j = (i * mCols), end = j + mCols; j < end; j++) if (data[j] > 0)
        data[j] = marking;
}",markRow,org/openscience/cdk/isomorphism/CompatibilityMatrix.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/CompatibilityMatrix.java,"/**
     * Mark all values in row i allowing it to be reset later.
     *
     * @param i       row index
     * @param marking the marking to store (should be negative)
     */",102-111,"('markRow', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,13.0,Mark all values in row i allowing it to be reset later.,"Since we want to reset the values later, we mark all of them in a row",I allow the values to be reset later on.,0.333236765128875,Mark all values in line i to allow it to be reset later.
248,cdk,"private List<IIsotope> orderList(List<IIsotope> isotopes_TO){
    List<IIsotope> newOrderList = new ArrayList<IIsotope>();
    for (int i = 0; i < orderElements.length; i++) {
        String symbol = orderElements[i];
        Iterator<IIsotope> itIso = isotopes_TO.iterator();
        while (itIso.hasNext()) {
            IIsotope isotopeToCo = itIso.next();
            if (isotopeToCo.getSymbol().equals(symbol)) {
                newOrderList.add(isotopeToCo);
            }
        }
    }
    return newOrderList;
}",orderList,org/openscience/cdk/formula/MassToFormulaTool.java,/legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java,"/**
     * Put the order the List of IIsotope according the probability occurrence.
     *
     * @param isotopes_TO  The List of IIsotope
     * @return             The list of IIsotope ordered
     */",417-436,"('orderList', {'INSTRUCTION': {'covered': 40, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",111.0,12.0,Put the order the List of IIsotope according the probability occurrence.,Order the list of IIsotope based on the probability of their occurrence.,The order of the List of IIsotope should be decided by the probability occurrence.,0.253152591949335,Put the order of the IIsotope List according to the probability of occurrence.
249,matsim-libs,"public AttributeConverter<?> putAttributeConverter(final Class<?> clazz, final AttributeConverter<?> converter){
    return this.converter.putAttributeConverter(clazz, converter);
}",putAttributeConverter,org/matsim/utils/objectattributes/ObjectAttributesXmlReader.java,/matsim/src/main/java/org/matsim/utils/objectattributes/ObjectAttributesXmlReader.java,"/**
	 * Sets the converter for reading attributes of the specified class.
	 *
	 * @param clazz
	 * @param converter
	 * @return the previously registered converter for this class, or <code>null</code> if none was set before.
	 */",110-119,"('putAttributeConverter', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,11.0,Sets the converter for reading attributes of the specified class.,"For the specified class, we define the converter to be used for reading the attributes.",The class is specified and the class reading attributes are set.,0.593543186463413,Sets the converter for reading the attributes of the specified class.
250,shardingsphere-elasticjob,"public boolean hasShardingInfoInOfflineServers(){
    List<String> onlineInstances = jobNodeStorage.getJobNodeChildrenKeys(InstanceNode.ROOT);
    int shardingTotalCount = configService.load(true).getShardingTotalCount();
    for (int i = 0; i < shardingTotalCount; i++) {
        if (!onlineInstances.contains(jobNodeStorage.getJobNodeData(ShardingNode.getInstanceNode(i)))) {
            return true;
        }
    }
    return false;
}",hasShardingInfoInOfflineServers,org/apache/shardingsphere/elasticjob/lite/internal/sharding/ShardingService.java,/elasticjob-lite/elasticjob-lite-core/src/main/java/org/apache/shardingsphere/elasticjob/lite/internal/sharding/ShardingService.java,"/**
     * Query has sharding info in offline servers or not.
     * 
     * @return has sharding info in offline servers or not
     */",211-225,"('hasShardingInfoInOfflineServers', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",80.0,10.0,Query has sharding info in offline servers or not.,Return whether the query has sharding info in offline servers.,There is a query that has sharding info in offline server.,0.283056602238684,The query may or may not contain partitioning information in the offline servers.
251,glowstone,"public boolean iterateCompoundList(@NonNls String key, Consumer<? super CompoundTag> consumer){
    return readCompoundList(key, compoundTags -> compoundTags.forEach(consumer));
}",iterateCompoundList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to each compound tag in a compound-list subtag, if that subtag
     * exists.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was iterated over (even if it was empty); false otherwise
     */",572-582,"('iterateCompoundList', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,18.0,"Applies the given function to each compound tag in a compound-list subtag, if that subtag  exists.","If a specific subtag exists, we apply the given function to each tag in the compound list of subtags. The function returns true if the tag exists and the function has been called, false otherwise.","If a compound-list subtag exists, apply the given function to it.",0.436413659936604,"Applies the given function to each compound tag in a compound list subtag, if that subtag exists."
252,tablesaw,"public Table melt(List<String> idVariables, List<NumericColumn<?>> measuredVariables, Boolean dropMissing){
    Table result = Table.create(name);
    for (String idColName : idVariables) {
        result.addColumns(column(idColName).type().create(idColName));
    }
    result.addColumns(StringColumn.create(MELT_VARIABLE_COLUMN_NAME), DoubleColumn.create(MELT_VALUE_COLUMN_NAME));
    List<String> measureColumnNames = measuredVariables.stream().map(Column::name).collect(Collectors.toList());
    TableSliceGroup slices = splitOn(idVariables.toArray(new String[0]));
    for (TableSlice slice : slices) {
        for (Row row : slice) {
            for (String colName : measureColumnNames) {
                if (!dropMissing || !row.isMissing(colName)) {
                    writeIdVariables(idVariables, result, row);
                    result.stringColumn(MELT_VARIABLE_COLUMN_NAME).append(colName);
                    double value = row.getNumber(colName);
                    result.doubleColumn(MELT_VALUE_COLUMN_NAME).append(value);
                }
            }
        }
    }
    return result;
}",melt,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,"/**
   * Melt implements the 'tidy' melt operation as described in these papers by Hadley Wickham.
   *
   * <p>Tidy concepts: {@see https://www.jstatsoft.org/article/view/v059i10}
   *
   * <p>Cast function details: {@see https://www.jstatsoft.org/article/view/v021i12}
   *
   * <p>In short, melt turns columns into rows, but in a particular way. Used with the cast method,
   * it can help make data tidy. In a tidy dataset, every variable is a column and every observation
   * a row.
   *
   * <p>This method returns a table that contains all the data in this table, but organized such
   * that there is a set of identifier variables (columns) and a single measured variable (column).
   * For example, given a table with columns:
   *
   * <p>patient_id, gender, age, weight, temperature,
   *
   * <p>it returns a table with the columns:
   *
   * <p>patient_id, variable, value
   *
   * <p>In the new format, the strings age, weight, and temperature have become cells in the
   * measurement table, such that a single row in the source table might look like this in the
   * result table:
   *
   * <p>1234, gender, male 1234, age, 42 1234, weight, 186 1234, temperature, 97.4
   *
   * <p>This kind of structure often makes for a good intermediate format for performing subsequent
   * transformations. It is especially useful when combined with the {@link #cast()} operation
   *
   * @param idVariables A list of column names intended to be used as identifiers. In he example,
   *     only patient_id would be an identifier
   * @param measuredVariables A list of columns intended to be used as measured variables. All
   *     columns must have the same type
   * @param dropMissing drop any row where the value is missing
   */",1554-1619,"('melt', {'INSTRUCTION': {'covered': 123, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 22, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",214.0,16.0,Melt implements the 'tidy' melt operation as described in these papers by Hadley Wickham.,The function Melt implements the same melt operation described in the papers by Hadley Wickham.,The 'tidy' melt operation is described in these papers.,1.01330556827075,"Melt implements the ""ordered"" merge operation described in these articles by Hadley Wickham."
253,tablesaw,"StringColumn hourMinute(){
    StringColumn newColumn = StringColumn.create(this.name() + "" hour & minute"");
    for (int r = 0; r < this.size(); r++) {
        long c1 = this.getLongInternal(r);
        if (DateTimeColumn.valueIsMissing(c1)) {
            newColumn.append(StringColumnType.missingValueIndicator());
        } else {
            String hm = Strings.padStart(String.valueOf(getHour(c1)), 2, '0');
            hm = hm + "":"" + Strings.padStart(String.valueOf(getMinute(c1)), 2, '0');
            newColumn.append(hm);
        }
    }
    return newColumn;
}",hourMinute,tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,"/**
   * Returns a StringColumn with the year and week-of-year derived from this column concatenated
   * into a String that will sort lexicographically in temporal order.
   *
   * <p>This simplifies the production of plots and tables that aggregate values into standard
   * temporal units (e.g., you want monthly data but your source data is more than a year long and
   * you don't want months from different years aggregated together).
   */",261-282,"('hourMinute', {'INSTRUCTION': {'covered': 55, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",134.0,24.0,Returns a StringColumn with the year and week-of-year derived from this column concatenated  into a String that will sort lexicographically in temporal order.,Create a String Column that contains the year and the week of the year. The column is sorted lexicographically in temporal order.,The year and week-of-year derived from this column will be returned as a String.,0.361055965283091,Returns a StringColumn with the year and week of the year derived from this column concatenated into a String that will sort lexicographically in temporal order.
255,matsim-libs,"private Map<Id<Link>, Link> findCluster(final Link startLink, final Set<String> modes){
    final Map<Id<Link>, DoubleFlagRole> linkRoles = new HashMap<>(this.network.getLinks().size());
    ArrayList<Node> pendingForward = new ArrayList<>();
    ArrayList<Node> pendingBackward = new ArrayList<>();
    TreeMap<Id<Link>, Link> clusterLinks = new TreeMap<>();
    pendingForward.add(startLink.getToNode());
    pendingBackward.add(startLink.getFromNode());
    while (pendingForward.size() > 0) {
        int idx = pendingForward.size() - 1;
        Node currNode = pendingForward.remove(idx);
        for (Link link : currNode.getOutLinks().values()) {
            if (intersectingSets(modes, link.getAllowedModes())) {
                DoubleFlagRole r = getDoubleFlag(link, linkRoles);
                if (!r.forwardFlag) {
                    r.forwardFlag = true;
                    pendingForward.add(link.getToNode());
                }
            }
        }
    }
    while (pendingBackward.size() > 0) {
        int idx = pendingBackward.size() - 1;
        Node currNode = pendingBackward.remove(idx);
        for (Link link : currNode.getInLinks().values()) {
            if (intersectingSets(modes, link.getAllowedModes())) {
                DoubleFlagRole r = getDoubleFlag(link, linkRoles);
                if (!r.backwardFlag) {
                    r.backwardFlag = true;
                    pendingBackward.add(link.getFromNode());
                    if (r.forwardFlag) {
                        clusterLinks.put(link.getId(), link);
                    }
                }
            }
        }
    }
    return clusterLinks;
}",findCluster,org/matsim/core/network/algorithms/MultimodalNetworkCleaner.java,/matsim/src/main/java/org/matsim/core/network/algorithms/MultimodalNetworkCleaner.java,"/**
	 * Finds the cluster of links <pre>startLink</pre> is part of. The cluster
	 * contains all links which can be reached starting at <code>startLink</code>
	 * and from where it is also possible to return again to <code>startLink</code>.
	 *
	 * @param startLink the link to start building the cluster
	 * @param modes the set of modes that are allowed to
	 * @return cluster of links <pre>startLink</pre> is part of
	 */",168-224,"('findCluster', {'INSTRUCTION': {'covered': 137, 'missed': 0}, 'BRANCH': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 31, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",347.0,16.0,Finds the cluster of links <pre>startLink</pre> is part of.,"Starting from <pre>startLink</pre>, we look for the cluster of links that contain it. All these links can be reached starting from <code>startLink</code> and from where we can also return again to <code>startLink</code>",Starts with the startLink and ends with the part of the cluster.,0.247843138528595,Finds the link cluster that <pre>startLink</pre> is a part of.
256,weblogic-kubernetes-operator,"public static String toExternalServiceName(String domainUid, String serverName){
    return toDns1123LegalName(String.format(EXTERNAL_SERVICE_PATTERN, domainUid, serverName, getExternalServiceNameSuffix()));
}",toExternalServiceName,oracle/kubernetes/operator/helpers/LegalNames.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/LegalNames.java,"/**
   * Generates the introspector job name based on the given domainUid.
   *
   * @param domainUid domainUid
   * @param serverName WebLogic server name
   * @return String introspector job name
   */",108-121,"('toExternalServiceName', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,11.0,Generates the introspector job name based on the given domainUid.,"Given a domainUid, generates the introspector job name.",The job name is generated based on the domainUid.,0.224815792081671,Generates the name of the introspector task based on the given domainUid.
257,jeromq,"public boolean sendPicture(Socket socket, String picture, Object... args){
    if (!FORMAT.matcher(picture).matches()) {
        throw new ZMQException(picture + "" is not in expected format "" + FORMAT.pattern(), ZError.EPROTO);
    }
    ZMsg msg = new ZMsg();
    for (int pictureIndex = 0, argIndex = 0; pictureIndex < picture.length(); pictureIndex++, argIndex++) {
        char pattern = picture.charAt(pictureIndex);
        switch(pattern) {
            case 'i':
                {
                    msg.add(String.format(""%d"", (int) args[argIndex]));
                    break;
                }
            case '1':
                {
                    msg.add(String.format(""%d"", (0xff) & (int) args[argIndex]));
                    break;
                }
            case '2':
                {
                    msg.add(String.format(""%d"", (0xffff) & (int) args[argIndex]));
                    break;
                }
            case '4':
                {
                    msg.add(String.format(""%d"", (0xffffffff) & (int) args[argIndex]));
                    break;
                }
            case '8':
                {
                    msg.add(String.format(""%d"", (long) args[argIndex]));
                    break;
                }
            case 's':
                {
                    msg.add((String) args[argIndex]);
                    break;
                }
            case 'b':
            case 'c':
                {
                    msg.add((byte[]) args[argIndex]);
                    break;
                }
            case 'f':
                {
                    msg.add((ZFrame) args[argIndex]);
                    break;
                }
            case 'm':
                {
                    ZMsg msgParm = (ZMsg) args[argIndex];
                    while (msgParm.size() > 0) {
                        msg.add(msgParm.pop());
                    }
                    break;
                }
            case 'z':
                {
                    msg.add((byte[]) null);
                    argIndex--;
                    break;
                }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    return msg.send(socket, false);
}",sendPicture,org/zeromq/proto/ZPicture.java,/src/main/java/org/zeromq/proto/ZPicture.java,"/**
     * Queues a 'picture' message to the socket (or actor), so it can be sent.
     *
     * @param picture The picture is a string that defines the type of each frame.
     *                This makes it easy to send a complex multiframe message in
     *                one call. The picture can contain any of these characters,
     *                each corresponding to zero or one arguments:
     *
     *                <table>
     *                <caption> </caption>
     *                <tr><td>i = int  (stores signed integer)</td></tr>
     *                <tr><td>1 = byte (stores 8-bit unsigned integer)</td></tr>
     *                <tr><td>2 = int  (stores 16-bit unsigned integer)</td></tr>
     *                <tr><td>4 = long (stores 32-bit unsigned integer)</td></tr>
     *                <tr><td>8 = long (stores 64-bit unsigned integer)</td></tr>
     *                <tr><td>s = String</td></tr>
     *                <tr><td>b = byte[]</td></tr>
     *                <tr><td>c = byte[]</td></tr>
     *                <tr><td>f = ZFrame</td></tr>
     *                <tr><td>m = ZMsg (sends all frames in the ZMsg)<b>Has to be the last element of the picture</b></td></tr>
     *                <tr><td>z = sends zero-sized frame (0 arguments)</td></tr>
     *                </table>
     *                Note that s, b, f and m are encoded the same way and the choice is
     *                offered as a convenience to the sender, which may or may not already
     *                have data in a ZFrame or ZMsg. Does not change or take ownership of
     *                any arguments.
     *
     *                Also see {@link #recvPicture(Socket, String)}} how to recv a
     *                multiframe picture.
     * @param args    Arguments according to the picture
     * @return true if successful, false if sending failed for any reason
     */",247-339,"('sendPicture', {'INSTRUCTION': {'covered': 183, 'missed': 16}, 'BRANCH': {'covered': 16, 'missed': 3}, 'LINE': {'covered': 29, 'missed': 1}, 'COMPLEXITY': {'covered': 13, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",400.0,19.0,"Queues a 'picture' message to the socket (or actor), so it can be sent.","The function add a 'picture' message to the socket/actor queue, in order to be sent.",The picture message is sent to the actor.,0.299505152296428,"Queues an ""image"" message on the socket (or actor), so that it can be sent."
258,cdk,"TextOutline positionChargeLabel(int hydrogens, HydrogenPosition position, TextOutline charge, TextOutline element, TextOutline hydrogen){
    final Rectangle2D chargeBounds = charge.getBounds();
    Rectangle2D referenceBounds = element.getBounds();
    if (hydrogens > 0 && (position == Left || position == Right))
        referenceBounds = hydrogen.getBounds();
    if (position == Left)
        return charge.translate((referenceBounds.getMinX() - padding) - chargeBounds.getMaxX(), (referenceBounds.getMinY() - (chargeBounds.getHeight() / 2)) - chargeBounds.getMinY());
    else
        return charge.translate((referenceBounds.getMaxX() + padding) - chargeBounds.getMinX(), (referenceBounds.getMinY() - (chargeBounds.getHeight() / 2)) - chargeBounds.getMinY());
}",positionChargeLabel,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,"/**
     * Position the charge label on the top right of either the element or hydrogen label. Where the
     * charge is placed depends on the number of hydrogens and their position relative to the
     * element symbol.
     *
     * @param hydrogens number of hydrogen
     * @param position  position of hydrogen
     * @param charge    the charge label outline (to be positioned)
     * @param element   the element label outline
     * @param hydrogen  the hydrogen label outline
     * @return positioned charge label
     */",493-526,"('positionChargeLabel', {'INSTRUCTION': {'covered': 62, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",162.0,16.0,Position the charge label on the top right of either the element or hydrogen label.,"Given a charge, put the charge label on the top right of the element or of the hydrogen label. The position of the charge depends on the number of hydrogens and on their position in the element symbol.",The charge label should be on the top right of the element.,0.0442017544502708,Place the charging label at the top right of the item or hydrogen label.
259,acs-aem-commons,"protected String resultToPlainText(final String title, final List<HealthCheckExecutionResult> results){
    final StringBuilder sb = new StringBuilder();
    sb.append(title);
    sb.append(System.lineSeparator());
    if (results.size() == 0) {
        sb.append(""No "" + StringUtils.lowerCase(title) + "" could be found!"");
        sb.append(System.lineSeparator());
    } else {
        sb.append(StringUtils.repeat(""-"", NUM_DASHES));
        sb.append(System.lineSeparator());
        for (final HealthCheckExecutionResult result : results) {
            sb.append(StringUtils.rightPad(""[ "" + result.getHealthCheckResult().getStatus().name() + "" ]"", HEALTH_CHECK_STATUS_PADDING));
            sb.append(""  "");
            sb.append(result.getHealthCheckMetadata().getTitle());
            sb.append(System.lineSeparator());
        }
    }
    return sb.toString();
}",resultToPlainText,com/adobe/acs/commons/hc/impl/HealthCheckStatusEmailer.java,/bundle/src/main/java/com/adobe/acs/commons/hc/impl/HealthCheckStatusEmailer.java,"/**
     * Gererates the plain-text email sections for sets of Health Check Execution Results.
     *
     * @param title The section title
     * @param results the  Health Check Execution Results to render as plain text
     * @return the String for this section to be embedded in the e-mail
     */",262-291,"('resultToPlainText', {'INSTRUCTION': {'covered': 90, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",191.0,13.0,Gererates the plain-text email sections for sets of Health Check Execution Results.,Create for the sets of Health Check Execution Results the section of the email with the plain-text.,The plain-text email sections for the Health Check Execution Results are gererates.,0.367476340322326,Manage plain text email sections for status check execution result sets.
260,cdk,"public Iterable<IAtom> atoms(){
    return new Iterable<IAtom>() {

        @Override
        public Iterator<IAtom> iterator() {
            return new AtomsIterator();
        }
    };
}",atoms,org/openscience/cdk/Bond.java,/base/data/src/main/java/org/openscience/cdk/Bond.java,"/**
     * Returns the Iterator to atoms making up this bond.
     * Iterator.remove() is not implemented.
     *
     * @return An Iterator to atoms participating in this bond
     * @see #setAtoms
     */",158-174,"('atoms', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,10.0,Returns the Iterator to atoms making up this bond.,Returns for the atoms in the bond the Iterator.,This bond is made up of atoms.,0.228279668519479,Returns the iterator to the atoms that make up this bond.
261,egeria,"public String upsertSchemaType(String userId, SchemaType schemaType, String externalSourceName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
    final String methodName = ""upsertSchemaType"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateName(schemaType.getQualifiedName(), QUALIFIED_NAME_PROPERTY_NAME, methodName);
    invalidParameterHandler.validateName(schemaType.getDisplayName(), DISPLAY_NAME_PROPERTY_NAME, methodName);
    Optional<EntityDetail> originalSchemaTypeEntity = findSchemaTypeEntity(userId, schemaType.getQualifiedName());
    SchemaTypeBuilder schemaTypeBuilder = getSchemaTypeBuilder(schemaType);
    String externalSourceGUID = dataEngineRegistrationHandler.getExternalDataEngine(userId, externalSourceName);
    String schemaTypeGUID;
    if (originalSchemaTypeEntity.isEmpty()) {
        schemaTypeGUID = schemaTypeHandler.addSchemaType(userId, externalSourceGUID, externalSourceName, schemaTypeBuilder, methodName);
    } else {
        schemaTypeGUID = originalSchemaTypeEntity.get().getGUID();
        EntityDetail updatedSchemaTypeEntity = buildSchemaTypeEntityDetail(schemaTypeGUID, schemaType);
        EntityDetailDifferences entityDetailDifferences = repositoryHelper.getEntityDetailDifferences(originalSchemaTypeEntity.get(), updatedSchemaTypeEntity, true);
        if (entityDetailDifferences.hasInstancePropertiesDifferences()) {
            schemaTypeHandler.updateSchemaType(userId, externalSourceGUID, externalSourceName, schemaTypeGUID, SCHEMA_TYPE_GUID_PARAMETER_NAME, schemaTypeBuilder);
        }
    }
    dataEngineSchemaAttributeHandler.upsertSchemaAttributes(userId, schemaType.getAttributeList(), externalSourceName, externalSourceGUID, schemaTypeGUID);
    return schemaTypeGUID;
}",upsertSchemaType,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineSchemaTypeHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineSchemaTypeHandler.java,"/**
     * Create the schema type entity, with the corresponding schema attributes and relationships if it doesn't exist or
     * updates the existing one.
     *
     * @param userId             the name of the calling user
     * @param schemaType         the schema type values
     * @param externalSourceName the unique name of the external source
     *
     * @return unique identifier of the schema type in the repository
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",79-127,"('upsertSchemaType', {'INSTRUCTION': {'covered': 92, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",225.0,24.0,"Create the schema type entity, with the corresponding schema attributes and relationships if it doesn't exist or  updates the existing one.","Create the schema type entity. It contains the schema attributes and relationship, updating them if they already exist.","If the existing entity doesn't exist or is not updated, create a new entity with the corresponding attributes and relationships.",0.36938886623245,"Create the schema entity, with the corresponding attributes and schema relationships if it does not exist, or update the existing entity."
262,cdk,"private static String muliplier(String formula, int factor){
    String finalformula = """";
    String recentElementSymbol = """";
    String recentElementCountString = ""0"";
    for (int f = 0; f < formula.length(); f++) {
        char thisChar = formula.charAt(f);
        if (f < formula.length()) {
            if (thisChar >= 'A' && thisChar <= 'Z') {
                recentElementSymbol = String.valueOf(thisChar);
                recentElementCountString = ""0"";
            }
            if (thisChar >= 'a' && thisChar <= 'z') {
                recentElementSymbol += thisChar;
            }
            if (thisChar >= '0' && thisChar <= '9') {
                recentElementCountString += thisChar;
            }
        }
        if (f == formula.length() - 1 || (formula.charAt(f + 1) >= 'A' && formula.charAt(f + 1) <= 'Z')) {
            Integer recentElementCount = Integer.valueOf(recentElementCountString);
            if (recentElementCount == 0)
                finalformula += recentElementSymbol + factor;
            else
                finalformula += recentElementSymbol + recentElementCount * factor;
        }
    }
    return finalformula;
}",muliplier,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * This method multiply all the element over a value.
     *
     * @param formula Formula to correct
     * @param factor  Factor to multiply
     * @return        Formula with the correction
     */",1471-1505,"('muliplier', {'INSTRUCTION': {'covered': 117, 'missed': 0}, 'BRANCH': {'covered': 21, 'missed': 3}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",199.0,10.0,This method multiply all the element over a value.,"Given a value, the method multiply all the elements over it.",The method is used to add all the elements over a value.,0.708638083006823,This method multiplies the entire item on a value.
263,matsim-libs,"public boolean remove(E value){
    if (value == null)
        return false;
    int index = indices[this.getIndex(value)];
    if (index < 0) {
        return false;
    } else {
        if (classicalRemove) {
            boolean decreasedKey = decreaseKey(value, Double.NEGATIVE_INFINITY);
            if (decreasedKey && data[0] == value) {
                this.poll();
                return true;
            } else
                return false;
        } else {
            siftDownUp(index);
            indices[this.getIndex(value)] = -1;
            this.modCount++;
            return true;
        }
    }
}",remove,org/matsim/core/router/priorityqueue/BinaryMinHeap.java,/matsim/src/main/java/org/matsim/core/router/priorityqueue/BinaryMinHeap.java,"/**
	 * Removes a single instance of the specified element from this
	 * queue, if it is present.
	 *
	 * @return <tt>true</tt> if the queue contained the specified
	 *         element.
	 */",275-311,"('remove', {'INSTRUCTION': {'covered': 54, 'missed': 2}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 13, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",118.0,17.0,"Removes a single instance of the specified element from this  queue, if it is present.","If an instance of the specified element exists, we remove it.","If there is a single instance of the specified element present, it is removed.",1.10046574649611,"Removes a single instance of the specified item from this queue, if present."
264,acs-aem-commons," void parseParameters() throws ParseException{
    if (payloadPaths != null) {
        payloads = payloadPaths.stream().map(Pattern::compile).collect(Collectors.toList());
    }
    if (StringUtils.isNotEmpty(olderThanVal)) {
        final SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss"");
        Date d = sdf.parse(olderThanVal);
        olderThan = Calendar.getInstance();
        olderThan.setTime(d);
    }
    workflowRemovalConfig = new WorkflowRemovalConfig(modelIds, statuses, payloads, olderThan, olderThanMillis);
    workflowRemovalConfig.setBatchSize(BATCH_SIZE);
    workflowRemovalConfig.setMaxDurationInMins(MAX_DURATION_MINS);
}",parseParameters,com/adobe/acs/commons/mcp/impl/processes/WorkflowRemover.java,/bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/WorkflowRemover.java,"/**
     * Parse the input parameters into the form needed to call workflowInstanceRemover. The results are set into
     * instance variables.  Method is package scope for unit testing.
     *
     * @throws ParseException
     *             if the date is in an invalid format.
     * @throws PatternSyntaxException
     *          if the payloads contain illegal patterns
     */",164-188,"('parseParameters', {'INSTRUCTION': {'covered': 58, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",116.0,12.0,Parse the input parameters into the form needed to call workflowInstanceRemover.,The method parse the input parameters into the form used for calling workflowInstanceRemover and set them into instance variables.,The form needed to call theInstanceRemover requires input parameters.,0.73982975329067,Analyze the input parameters in the form needed to call workflowInstanceRemover.
265,jackson-databind,"public byte[] writeValueAsBytes(Object value) throws JsonProcessingException{
    try (ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler())) {
        _writeValueAndClose(createGenerator(bb, JsonEncoding.UTF8), value);
        final byte[] result = bb.toByteArray();
        bb.release();
        return result;
    } catch (JsonProcessingException e) {
        throw e;
    } catch (IOException e) {
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
}",writeValueAsBytes,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Method that can be used to serialize any Java value as
     * a byte array. Functionally equivalent to calling
     * {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}
     * and getting bytes, but more efficient.
     * Encoding used will be UTF-8.
     *<p>
     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
     */",3830-3853,"('writeValueAsBytes', {'INSTRUCTION': {'covered': 23, 'missed': 7}, 'LINE': {'covered': 5, 'missed': 4}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",90.0,15.0,Method that can be used to serialize any Java value as  a byte array.,This method can be called to serialize any Java value as an array of bytes.,Any Java value can be serialized using this method.,0.65145852650661,A method that can be used to serialize any Java value as an array of bytes.
266,cdk,"static int[] moveToBack(int[] neighbors, int v){
    int j = 0;
    for (int i = 0; i < neighbors.length; i++) {
        if (neighbors[i] != v) {
            neighbors[j++] = neighbors[i];
        }
    }
    neighbors[neighbors.length - 1] = v;
    return neighbors;
}",moveToBack,org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,"/**
     * Utility method for shifting a specified value in an index to the back
     * (see {@link #permutation(int[])}).
     *
     * @param neighbors list of neighbors
     * @param v         the value to shift to the back
     * @return <i>neighbors</i> array
     */",216-233,"('moveToBack', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,28.0,Utility method for shifting a specified value in an index to the back  (see {@link #permutation(int[])}).,This utility method can shift a specific value contained in an index to the end of the array.,The method for shifting a specified value in an index to the back is a utility method.,0.448550744531805,A utility method for moving a specified value in an index backwards (see {@link #permutation(int[])}).
267,cdk,"void readPropertiesFast(final BufferedReader input, final IAtomContainer container, final int nAtoms) throws IOException, CDKException{
    String line;
    int offset = container.getAtomCount() - nAtoms;
    Map<Integer, Sgroup> sgroups = new LinkedHashMap<>();
    LINES: while ((line = input.readLine()) != null) {
        int index, count, lnOffset;
        Sgroup sgroup;
        int length = line.length();
        final PropertyKey key = PropertyKey.of(line);
        switch(key) {
            case ATOM_ALIAS:
                index = readMolfileInt(line, 3) - 1;
                final String label = input.readLine();
                if (label == null)
                    return;
                label(container, offset + index, label);
                break;
            case ATOM_VALUE:
                index = readMolfileInt(line, 3) - 1;
                final String comment = line.substring(7);
                container.getAtom(offset + index).setProperty(CDKConstants.COMMENT, comment);
                break;
            case GROUP_ABBREVIATION:
                final String group = input.readLine();
                if (group == null)
                    return;
                break;
            case LEGACY_ATOM_LIST:
                index = readUInt(line, 0, 3) - 1;
                {
                    boolean negate = line.charAt(3) == 'T' || line.charAt(4) == 'T';
                    Expr expr = new Expr(Expr.Type.TRUE);
                    StringBuilder sb = new StringBuilder();
                    for (int i = 11; i < line.length(); i += 4) {
                        int atomicNumber = readUInt(line, i, 3);
                        expr.or(new Expr(Expr.Type.ELEMENT, atomicNumber));
                    }
                    if (negate)
                        expr.negate();
                    IAtom atom = container.getAtom(index);
                    if (AtomRef.deref(atom) instanceof QueryAtom) {
                        QueryAtom ref = (QueryAtom) AtomRef.deref(atom);
                        ref.setExpression(expr);
                    } else {
                        QueryAtom queryAtom = new QueryAtom(expr);
                        queryAtom.setPoint2d(atom.getPoint2d());
                        queryAtom.setPoint3d(atom.getPoint3d());
                        container.setAtom(index, queryAtom);
                    }
                }
                break;
            case M_ALS:
                index = readUInt(line, 7, 3) - 1;
                {
                    boolean negate = line.charAt(13) == 'T' || line.charAt(14) == 'T';
                    Expr expr = new Expr(Expr.Type.TRUE);
                    StringBuilder sb = new StringBuilder();
                    for (int i = 16; i < line.length(); i++) {
                        if (line.charAt(i) != ' ') {
                            sb.append(line.charAt(i));
                        } else if (sb.length() != 0) {
                            int elem = Elements.ofString(sb.toString()).number();
                            if (elem != 0)
                                expr.or(new Expr(Expr.Type.ELEMENT, elem));
                            sb.setLength(0);
                        }
                    }
                    if (sb.length() != 0) {
                        int elem = Elements.ofString(sb.toString()).number();
                        if (elem != 0)
                            expr.or(new Expr(Expr.Type.ELEMENT, elem));
                    }
                    if (negate)
                        expr.negate();
                    IAtom atom = container.getAtom(index);
                    if (AtomRef.deref(atom) instanceof QueryAtom) {
                        QueryAtom ref = (QueryAtom) AtomRef.deref(atom);
                        ref.setExpression(expr);
                    } else {
                        QueryAtom queryAtom = new QueryAtom(expr);
                        queryAtom.setPoint2d(atom.getPoint2d());
                        queryAtom.setPoint3d(atom.getPoint3d());
                        container.setAtom(index, queryAtom);
                    }
                }
                break;
            case M_CHG:
                count = readUInt(line, 6, 3);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    index = readMolfileInt(line, st) - 1;
                    int charge = readMolfileInt(line, st + 4);
                    container.getAtom(offset + index).setFormalCharge(charge);
                }
                break;
            case M_ISO:
                count = readUInt(line, 6, 3);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    index = readMolfileInt(line, st) - 1;
                    int mass = readMolfileInt(line, st + 4);
                    if (mass < 0)
                        handleError(""Absolute mass number should be >= 0, "" + line);
                    else
                        container.getAtom(offset + index).setMassNumber(mass);
                }
                break;
            case M_RAD:
                count = readUInt(line, 6, 3);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    index = readMolfileInt(line, st) - 1;
                    int value = readMolfileInt(line, st + 4);
                    SPIN_MULTIPLICITY multiplicity = SPIN_MULTIPLICITY.ofValue(value);
                    container.getAtom(offset + index).setProperty(CDKConstants.SPIN_MULTIPLICITY, multiplicity);
                    for (int e = 0; e < multiplicity.getSingleElectrons(); e++) container.addSingleElectron(offset + index);
                }
                break;
            case M_RGP:
                count = readUInt(line, 6, 3);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    index = readMolfileInt(line, st) - 1;
                    int number = readMolfileInt(line, st + 4);
                    label(container, offset + index, ""R"" + number);
                }
                break;
            case M_ZZC:
                if (mode == Mode.STRICT) {
                    throw new CDKException(""Atom property ZZC is illegal in STRICT mode"");
                }
                index = readMolfileInt(line, 7) - 1;
                String atomLabel = line.substring(11);
                container.getAtom(offset + index).setProperty(CDKConstants.ACDLABS_LABEL, atomLabel);
                break;
            case M_STY:
                count = readMolfileInt(line, 6);
                for (int i = 0; i < count; i++) {
                    lnOffset = 10 + (i * 8);
                    index = readMolfileInt(line, lnOffset);
                    if (mode == Mode.STRICT && sgroups.containsKey(index))
                        handleError(""STY line must appear before any other line that supplies Sgroup information"");
                    sgroup = new Sgroup();
                    sgroups.put(index, sgroup);
                    SgroupType type = SgroupType.parseCtabKey(line.substring(lnOffset + 4, lnOffset + 7));
                    if (type != null)
                        sgroup.setType(type);
                }
                break;
            case M_SST:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    if (mode == Mode.STRICT && sgroup.getType() != SgroupType.CtabCopolymer)
                        handleError(""SST (Sgroup Subtype) specified for a non co-polymer group"");
                    String sst = line.substring(st + 4, st + 7);
                    if (mode == Mode.STRICT && !(""ALT"".equals(sst) || ""RAN"".equals(sst) || ""BLO"".equals(sst)))
                        handleError(""Invalid sgroup subtype: "" + sst + "" expected (ALT, RAN, or BLO)"");
                    sgroup.putValue(SgroupKey.CtabSubType, sst);
                }
                break;
            case M_SAL:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                count = readMolfileInt(line, 10);
                for (int i = 0, st = 14; i < count && st + 3 <= length; i++, st += 4) {
                    index = readMolfileInt(line, st) - 1;
                    sgroup.addAtom(container.getAtom(offset + index));
                }
                break;
            case M_SBL:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                count = readMolfileInt(line, 10);
                for (int i = 0, st = 14; i < count && st + 3 <= length; i++, st += 4) {
                    index = readMolfileInt(line, st) - 1;
                    sgroup.addBond(container.getBond(offset + index));
                }
                break;
            case M_SPL:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 6 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    sgroup.addParent(ensureSgroup(sgroups, readMolfileInt(line, st + 4)));
                }
                break;
            case M_SCN:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 6 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    String con = line.substring(st + 4, Math.min(length, st + 7)).trim();
                    if (mode == Mode.STRICT && !(""HH"".equals(con) || ""HT"".equals(con) || ""EU"".equals(con)))
                        handleError(""Unknown SCN type (expected: HH, HT, or EU) was "" + con);
                    sgroup.putValue(SgroupKey.CtabConnectivity, con);
                }
                break;
            case M_SDI:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                count = readMolfileInt(line, 10);
                assert count == 4;
                sgroup.addBracket(new SgroupBracket(readMDLCoordinate(line, 13), readMDLCoordinate(line, 23), readMDLCoordinate(line, 33), readMDLCoordinate(line, 43)));
                break;
            case M_SMT:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                sgroup.putValue(SgroupKey.CtabSubScript, line.substring(11).trim());
                break;
            case M_SBT:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    sgroup.putValue(SgroupKey.CtabBracketStyle, readMolfileInt(line, st + 4));
                }
                break;
            case M_SDS:
                if (""EXP"".equals(line.substring(7, 10))) {
                    count = readMolfileInt(line, 10);
                    for (int i = 0, st = 14; i < count && st + 3 <= length; i++, st += 4) {
                        sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                        sgroup.putValue(SgroupKey.CtabExpansion, true);
                    }
                } else if (mode == Mode.STRICT) {
                    handleError(""Expected EXP to follow SDS tag"");
                }
                break;
            case M_SPA:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                count = readMolfileInt(line, 10);
                Collection<IAtom> parentAtomList = sgroup.getValue(SgroupKey.CtabParentAtomList);
                if (parentAtomList == null) {
                    sgroup.putValue(SgroupKey.CtabParentAtomList, parentAtomList = new HashSet<IAtom>());
                }
                for (int i = 0, st = 14; i < count && st + 3 <= length; i++, st += 4) {
                    index = readMolfileInt(line, st) - 1;
                    parentAtomList.add(container.getAtom(offset + index));
                }
                break;
            case M_SNC:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    sgroup.putValue(SgroupKey.CtabComponentNumber, readMolfileInt(line, st + 4));
                }
                break;
            case M_SDT:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                if (length < 11)
                    break;
                String name = line.substring(11, Math.min(41, length)).trim();
                sgroup.putValue(SgroupKey.DataFieldName, name);
                if (length < 41)
                    break;
                String fmt = line.substring(41, Math.min(43, length)).trim();
                if (fmt.length() == 1 && fmt.charAt(0) != 'F' && fmt.charAt(0) != 'N' && fmt.charAt(0) != 'T')
                    handleError(""Invalid Data Sgroup field format: "" + fmt);
                if (!fmt.isEmpty())
                    sgroup.putValue(SgroupKey.DataFieldFormat, fmt);
                if (length < 43)
                    break;
                String units = line.substring(43, Math.min(63, length)).trim();
                if (!units.isEmpty())
                    sgroup.putValue(SgroupKey.DataFieldUnits, units);
                break;
            case M_SDD:
                break;
            case M_SCD:
            case M_SED:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                String data = line.substring(11, Math.min(79, length));
                String curr = sgroup.getValue(SgroupKey.Data);
                if (curr != null)
                    data = curr + data;
                sgroup.putValue(SgroupKey.Data, data);
                break;
            case M_END:
                break LINES;
        }
    }
    for (IAtom atom : container.atoms()) {
        if (atom.getMassNumber() != null && atom.getMassNumber() < 0) {
            handleError(""Unstable use of mass delta on "" + atom.getSymbol() + "" please use M  ISO"");
            atom.setMassNumber(null);
        }
    }
    if (!sgroups.isEmpty()) {
        List<Sgroup> sgroupOrgList = new ArrayList<>(sgroups.values());
        List<Sgroup> sgroupCpyList = new ArrayList<>(sgroupOrgList.size());
        for (int i = 0; i < sgroupOrgList.size(); i++) {
            Sgroup cpy = sgroupOrgList.get(i).downcast();
            sgroupCpyList.add(cpy);
        }
        for (int i = 0; i < sgroupOrgList.size(); i++) {
            Sgroup newSgroup = sgroupCpyList.get(i);
            Set<Sgroup> oldParents = new HashSet<>(newSgroup.getParents());
            newSgroup.removeParents(oldParents);
            for (Sgroup parent : oldParents) {
                newSgroup.addParent(sgroupCpyList.get(sgroupOrgList.indexOf(parent)));
            }
        }
        container.setProperty(CDKConstants.CTAB_SGROUPS, sgroupCpyList);
    }
}",readPropertiesFast,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Reads the property block from the {@code input} setting the values in the
     * container.
     *
     * @param input     input resource
     * @param container the structure with atoms / bonds present
     * @param nAtoms    the number of atoms in the atoms block
     * @throws IOException low-level IO error
     */",880-1442,"('readPropertiesFast', {'INSTRUCTION': {'covered': 1184, 'missed': 129}, 'BRANCH': {'covered': 143, 'missed': 50}, 'LINE': {'covered': 225, 'missed': 18}, 'COMPLEXITY': {'covered': 66, 'missed': 44}, 'METHOD': {'covered': 1, 'missed': 0}})",2851.0,18.0,Reads the property block from the {@code input} setting the values in the  container.,reads the input and sets the values of the property block in the container.,The property block is read from the code input.,0.147679399644273,Reads the property block from the value {@code input} in the container.
268,soul,"public Mono<Void> execute(final ServerWebExchange exchange, final ShenyuPluginChain chain){
    String pluginName = named();
    PluginData pluginData = BaseDataCache.getInstance().obtainPluginData(pluginName);
    if (pluginData != null && pluginData.getEnabled()) {
        final Collection<SelectorData> selectors = BaseDataCache.getInstance().obtainSelectorData(pluginName);
        if (CollectionUtils.isEmpty(selectors)) {
            return handleSelectorIfNull(pluginName, exchange, chain);
        }
        SelectorData selectorData = matchSelector(exchange, selectors);
        if (Objects.isNull(selectorData)) {
            return handleSelectorIfNull(pluginName, exchange, chain);
        }
        selectorLog(selectorData, pluginName);
        List<RuleData> rules = BaseDataCache.getInstance().obtainRuleData(selectorData.getId());
        if (CollectionUtils.isEmpty(rules)) {
            return handleRuleIfNull(pluginName, exchange, chain);
        }
        RuleData rule;
        if (selectorData.getType() == SelectorTypeEnum.FULL_FLOW.getCode()) {
            // get last
            rule = rules.get(rules.size() - 1);
        } else {
            rule = matchRule(exchange, rules);
        }
        if (Objects.isNull(rule)) {
            return handleRuleIfNull(pluginName, exchange, chain);
        }
        ruleLog(rule, pluginName);
        return doExecute(exchange, chain, selectorData, rule);
    }
    return chain.execute(exchange);
}",execute,org/apache/shenyu/plugin/base/AbstractShenyuPlugin.java,/shenyu-plugin/shenyu-plugin-base/src/main/java/org/apache/shenyu/plugin/base/AbstractShenyuPlugin.java,"/**
     * Process the Web request and (optionally) delegate to the next
     * {@code ShenyuPlugin} through the given {@link ShenyuPluginChain}.
     *
     * @param exchange the current server exchange
     * @param chain    provides a way to delegate to the next plugin
     * @return {@code Mono<Void>} to indicate when request processing is complete
     */",56-96,"('execute', {'INSTRUCTION': {'covered': 80, 'missed': 22}, 'BRANCH': {'covered': 9, 'missed': 5}, 'LINE': {'covered': 17, 'missed': 4}, 'COMPLEXITY': {'covered': 3, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",267.0,26.0,Process the Web request and (optionally) delegate to the next  {@code ShenyuPlugin} through the given {@link ShenyuPluginChain}.,The method processes a web request. It can optionally delegate the operation to the next ShenyuPlugin,"If you want to delegate to the next @code ShenyuPlugin, Process the Web request and give the @link ShenyuPluginChain.",1.26981716543868,Process the web request and (optionally) delegate it to the next {@code ShenyuPlugin} via the given {@link ShenyuPluginChain}.
269,jackson-databind,"public ObjectReader readerForArrayOf(Class<?> type){
    return _newReader(getDeserializationConfig(), _typeFactory.constructArrayType(type), null, null, _injectableValues);
}",readerForArrayOf,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Factory method for constructing {@link ObjectReader} that will
     * read values of a type {@code List<type>}.
     * Functionally same as:
     *<pre>
     *    readerFor(type[].class);
     *</pre>
     *
     * @since 2.11
     */",4145-4159,"('readerForArrayOf', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,25.0,Factory method for constructing {@link ObjectReader} that will  read values of a type {@code List<type>}.,The method can construct the ObjectReader in order to read a list of values.,The method for constructing @link ObjectReader will read values of a type.,1.14950756092578,A factory method for constructing {@link ObjectReader} that will read the values of a {@code List<type>} type.
270,weblogic-kubernetes-operator,"public static Step readIntrospectionVersionStep(String ns, String domainUid){
    String configMapName = getIntrospectorConfigMapName(domainUid);
    return new CallBuilder().readConfigMapAsync(configMapName, ns, domainUid, new ReadIntrospectionVersionStep());
}",readIntrospectionVersionStep,oracle/kubernetes/operator/helpers/ConfigMapHelper.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/ConfigMapHelper.java,"/**
   * Reads the introspector config map for the specified domain, populating the following packet entries.
   *   INTROSPECTION_STATE_LABEL          the value of the domain's 'introspectVersion' when this map was created
   *
   * @param ns the namespace of the domain
   * @param domainUid the unique domain ID
   * @return a step to do the processing.
   */",924-935,"('readIntrospectionVersionStep', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,16.0,"Reads the introspector config map for the specified domain, populating the following packet entries.","Given a introspector config map for a specific domaiin, reads it and populate the packet entries.",The following packet entries are filled with the following config map.,0.704545234844214,"Reads the introspector's configuration card for the specified domain, filling in the following packet entries."
271,cdk,"public void writeMolecule(IAtomContainer mol) throws IOException{
    String st = """";
    boolean writecharge = true;
    try {
        String s1 = """" + mol.getAtomCount();
        writer.write(s1, 0, s1.length());
        writer.write('\n');
        String s2 = mol.getTitle();
        if (s2 != null) {
            writer.write(s2, 0, s2.length());
        }
        writer.write('\n');
        Iterator<IAtom> atoms = mol.atoms().iterator();
        while (atoms.hasNext()) {
            IAtom a = atoms.next();
            st = a.getSymbol();
            Point3d p3 = a.getPoint3d();
            if (p3 != null) {
                st = st + ""\t"" + (p3.x < 0 ? """" : "" "") + fsb.format(p3.x) + ""\t"" + (p3.y < 0 ? """" : "" "") + fsb.format(p3.y) + ""\t"" + (p3.z < 0 ? """" : "" "") + fsb.format(p3.z);
            } else {
                st = st + ""\t "" + fsb.format(0.0) + ""\t "" + fsb.format(0.0) + ""\t "" + fsb.format(0.0);
            }
            if (writecharge) {
                double ct = a.getCharge() == CDKConstants.UNSET ? 0.0 : a.getCharge();
                st = st + ""\t"" + ct;
            }
            writer.write(st, 0, st.length());
            writer.write('\n');
        }
    } catch (IOException e) {
        logger.error(""Error while writing file: "", e.getMessage());
        logger.debug(e);
    }
}",writeMolecule,org/openscience/cdk/io/XYZWriter.java,/storage/io/src/main/java/org/openscience/cdk/io/XYZWriter.java,"/**
    * writes a single frame in XYZ format to the Writer.
    * @param mol the Molecule to write
    */",136-185,"('writeMolecule', {'INSTRUCTION': {'covered': 172, 'missed': 26}, 'BRANCH': {'covered': 12, 'missed': 4}, 'LINE': {'covered': 25, 'missed': 4}, 'COMPLEXITY': {'covered': 5, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",347.0,11.0,writes a single frame in XYZ format to the Writer.,"Using the XYZ format, writes the frame to the Writer.",A single frame is written to the writer.,0.329706345601129,writes a single image in XYZ format to the recorder.
273,cdk,"public synchronized void searchMCS(boolean shouldMatchBonds){
    List<List<Integer>> mappings = null;
    try {
        if (source.getAtomCount() >= target.getAtomCount()) {
            mappings = new MCSPlus().getOverlaps(source, target, shouldMatchBonds);
        } else {
            flagExchange = true;
            mappings = new MCSPlus().getOverlaps(target, source, shouldMatchBonds);
        }
        PostFilter.filter(mappings);
        setAllMapping();
        setAllAtomMapping();
        setFirstMapping();
        setFirstAtomMapping();
    } catch (CDKException e) {
        mappings = null;
    }
}",searchMCS,org/openscience/cdk/smsd/algorithm/mcsplus/MCSPlusHandler.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/mcsplus/MCSPlusHandler.java,"/** {@inheritDoc}
     * Function is called by the main program and serves as a starting point for the comparison procedure.
     *
     * @param shouldMatchBonds
     */",93-116,"('searchMCS', {'INSTRUCTION': {'covered': 46, 'missed': 3}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",113.0,22.0,{@inheritDoc}  Function is called by the main program and serves as a starting point for the comparison procedure.,the function starts the comparison procedure and is called by the main program.,The function is called by the main program and serves as a starting point for comparison procedures.,0.269893903122951,{@inheritDoc}  The function is called by the main program and serves as a starting point for the comparison procedure.
274,acs-aem-commons,"private void populateBinaryContent() throws RepositoryException{
    final Node contents = getOrCreateByPath(entryNode, JCRHttpCacheStoreConstants.PATH_CONTENTS, JcrConstants.NT_FILE, JcrConstants.NT_FILE);
    final Node jcrContent = getOrCreateByPath(contents, JcrConstants.JCR_CONTENT, JcrConstants.NT_RESOURCE, JcrConstants.NT_RESOURCE);
    final Binary binary = session.getValueFactory().createBinary(cacheContent.getInputDataStream());
    jcrContent.setProperty(JcrConstants.JCR_DATA, binary);
    jcrContent.setProperty(JcrConstants.JCR_MIMETYPE, cacheContent.getContentType());
}",populateBinaryContent,com/adobe/acs/commons/httpcache/store/jcr/impl/writer/EntryNodeWriter.java,/bundle/src/main/java/com/adobe/acs/commons/httpcache/store/jcr/impl/writer/EntryNodeWriter.java,"/**
     * Save the inputstream to a binary property under the cache entry node.
     * @throws RepositoryException
     */",99-112,"('populateBinaryContent', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",96.0,13.0,Save the inputstream to a binary property under the cache entry node.,"using the cache entry node, saves in binary format the inputstream.","Under the cache entry node, save the inputstream to a property.",0.73859558896823,Save the input stream to a binary property under the cache input node.
275,acs-aem-commons,"public List<Resource> findResources(final ResourceResolver resourceResolver, final String language, final String statement, final String relPath) throws RepositoryException{
    if (StringUtils.isEmpty(statement)) {
        return Collections.emptyList();
    }
    final String[] lines = StringUtils.split(statement, '\n');
    if (QUERY_BUILDER.equalsIgnoreCase(language)) {
        return getResourcesFromQueryBuilder(resourceResolver, lines, relPath);
    } else if (LIST.equalsIgnoreCase(language)) {
        return getResourcesFromList(resourceResolver, lines, relPath);
    } else {
        return getResourcesFromQuery(resourceResolver, language, statement, relPath);
    }
}",findResources,com/adobe/acs/commons/util/impl/QueryHelperImpl.java,/bundle/src/main/java/com/adobe/acs/commons/util/impl/QueryHelperImpl.java,"/**
     * Find all the resources needed for the package definition.
     *
     * @param resourceResolver the resource resolver to find the resources
     * @param language         the Query language
     * @param statement        the Query statement
     * @param relPath          the relative path to resolve against query result nodes for package resources
     * @return a unique set of paths to include in the package
     * @throws RepositoryException
     */",60-87,"('findResources', {'INSTRUCTION': {'covered': 34, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",118.0,10.0,Find all the resources needed for the package definition.,Collect all the resources for the definition of the package.,The package definition requires all the resources found here.,0.172615768564587,Find all the resources needed to define the package.
276,weblogic-kubernetes-operator,"private static Step createServerStatusReaderStep(DomainPresenceInfo info, V1Pod pod, String serverName, long timeoutSeconds){
    return new ServerStatusReaderStep(info, pod, serverName, timeoutSeconds, new ServerHealthStep(serverName, pod, null));
}",createServerStatusReaderStep,oracle/kubernetes/operator/ServerStatusReader.java,/operator/src/main/java/oracle/kubernetes/operator/ServerStatusReader.java,"/**
   * Creates asynchronous step to read WebLogic server state from a particular pod.
   *
   * @param info the domain presence
   * @param pod The pod
   * @param serverName Server name
   * @param timeoutSeconds Timeout in seconds
   * @return Created step
   */",61-74,"('createServerStatusReaderStep', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",42.0,13.0,Creates asynchronous step to read WebLogic server state from a particular pod.,"From a specific pod, reads the WebLogic server state in an asyncronous step",A step is created to read the server state from a particular Pod.,0.294409124334335,Creates an asynchronous step to read the status of the WebLogic server from a particular space.
277,glowstone,"private static Location findSafeSpawnLocation(Location spawn){
    World world = spawn.getWorld();
    int blockX = spawn.getBlockX();
    int blockY = spawn.getBlockY();
    int blockZ = spawn.getBlockZ();
    int highestY = world.getHighestBlockYAt(blockX, blockZ);
    int y = blockY;
    boolean wasPreviousSafe = false;
    for (; y <= highestY; y++) {
        Material type = world.getBlockAt(blockX, y, blockZ).getType();
        boolean safe = Material.AIR.equals(type);
        if (wasPreviousSafe && safe) {
            y--;
            break;
        }
        wasPreviousSafe = safe;
    }
    return new Location(world, blockX + 0.5, y, blockZ + 0.5);
}",findSafeSpawnLocation,net/glowstone/entity/GlowPlayer.java,/src/main/java/net/glowstone/entity/GlowPlayer.java,"/**
     * Find a a Location obove or below the specified Location, which is on ground.
     *
     * <p>The returned Location will be at the center of the block, X and Y wise.
     *
     * @param spawn The Location a safe spawn position should be found at.
     * @return The location to spawn the player at.
     */",633-663,"('findSafeSpawnLocation', {'INSTRUCTION': {'covered': 56, 'missed': 4}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 13, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",144.0,16.0,"Find a a Location obove or below the specified Location, which is on ground.","Given a specific location on the ground, find a new location above or below.",The location is on the ground.,0.888315682226204,"Find an obove location or below the specified location, which is on the ground."
278,cdk,"protected boolean canDraw(IAtom atom, IAtomContainer container, RendererModel model){
    if (!hasCoordinates(atom)) {
        return false;
    }
    if (invisibleHydrogen(atom, model)) {
        return false;
    }
    if (invisibleCarbon(atom, container, model)) {
        return false;
    }
    return true;
}",canDraw,org/openscience/cdk/renderer/generators/BasicAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/BasicAtomGenerator.java,"/**
     * Checks an atom to see if it should be drawn. There are three reasons
     * not to draw an atom - a) no coordinates, b) an invisible hydrogen or
     * c) an invisible carbon.
     *
     * @param atom the atom to check
     * @param container the atom container the atom is part of
     * @param model the renderer model
     * @return true if the atom should be drawn
     */",279-306,"('canDraw', {'INSTRUCTION': {'covered': 21, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,11.0,Checks an atom to see if it should be drawn.,"Check whether we can draw an atom. This can not be done in three circumstances: there are no coordinates, there is an invisible hydrogen or an invisible carbon.",The atom is checked to see if it should be drawn.,0.503171778164863,Check an atom to see if it needs to be drawn.
279,acs-aem-commons,"private List<SyntheticChildAsPropertyResource> deserialize() throws InvalidDataFormatException{
    final long start = System.currentTimeMillis();
    final String propertyData = this.resource.getValueMap().get(this.propertyName, EMPTY_JSON);
    List<SyntheticChildAsPropertyResource> resources;
    resources = deserializeToSyntheticChildResources(JsonObjectUtil.toJsonObject(propertyData));
    if (this.comparator != null) {
        Collections.sort(resources, this.comparator);
    }
    log.debug(""Get operation for [ {} ] in [ {} ms ]"", this.resource.getPath() + ""/"" + this.propertyName, System.currentTimeMillis() - start);
    return resources;
}",deserialize,com/adobe/acs/commons/synth/children/ChildrenAsPropertyResource.java,/bundle/src/main/java/com/adobe/acs/commons/synth/children/ChildrenAsPropertyResource.java,"/**
     * Convert the serialized JSON data found in the node property to Resources.
     *
     * @return the list of children sorting using the comparator.
     * @throws InvalidDataFormatException
     */",294-318,"('deserialize', {'INSTRUCTION': {'covered': 45, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",114.0,13.0,Convert the serialized JSON data found in the node property to Resources.,Read a serialized JSON data found in the properties of the node and convert them to Resources.,The data in the property is serialized.,0.483869666869148,Convert the serialized JSON data found in the node property to Resources.
280,egeria,"private List<String> parseRecord(String fileRecord){
    if ((fileRecord == null) || (fileRecord.isEmpty())) {
        return null;
    }
    List<String> result = new ArrayList<>();
    StringBuffer currentValue = new StringBuffer();
    boolean inQuotes = false;
    boolean startCollectingCharacters = false;
    boolean doubleQuotesInColumn = false;
    char[] characters = fileRecord.toCharArray();
    for (char character : characters) {
        if (inQuotes) {
            startCollectingCharacters = true;
            if (character == quoteChar) {
                inQuotes = false;
                doubleQuotesInColumn = false;
            } else {
                if (character == '\""') {
                    if (!doubleQuotesInColumn) {
                        currentValue.append(character);
                        doubleQuotesInColumn = true;
                    }
                } else {
                    currentValue.append(character);
                }
            }
        } else {
            if (character == quoteChar) {
                inQuotes = true;
                if (characters[0] != '""' && quoteChar == '\""') {
                    currentValue.append('""');
                }
                if (startCollectingCharacters) {
                    currentValue.append('""');
                }
            } else if (character == delimiterChar) {
                result.add(currentValue.toString());
                currentValue = new StringBuffer();
                startCollectingCharacters = false;
            } else if (character == '\n') {
                break;
            } else if (character != '\r') {
                currentValue.append(character);
            }
        }
    }
    result.add(currentValue.toString());
    return result;
}",parseRecord,org/odpi/openmetadata/adapters/connectors/datastore/csvfile/CSVFileStoreConnector.java,/open-metadata-implementation/adapters/open-connectors/data-store-connectors/file-connectors/csv-file-connector/src/main/java/org/odpi/openmetadata/adapters/connectors/datastore/csvfile/CSVFileStoreConnector.java,"/**
     * Step through the record, character by character, extracting each column and enduring that escaped double quotes
     * and other tricks found in CSV files are handled.
     *
     * @param fileRecord a single record from the CSV file store
     * @return an array of column values extracted from the record
     */",274-364,"('parseRecord', {'INSTRUCTION': {'covered': 118, 'missed': 12}, 'BRANCH': {'covered': 20, 'missed': 8}, 'LINE': {'covered': 30, 'missed': 5}, 'COMPLEXITY': {'covered': 8, 'missed': 7}, 'METHOD': {'covered': 1, 'missed': 0}})",276.0,28.0,"Step through the record, character by character, extracting each column and enduring that escaped double quotes  and other tricks found in CSV files are handled.","Parse a specific record, character by character and extract each column. The function handle double quotes and other tricks contained in the CSV file",The character by character method of character by character extract and the escape of double quotes are handled.,1.08205686836471,"Browse the record, character by character, extracting each column and supporting escaped double quotes and other tricks found in CSV files are handled."
281,egeria,"public void upsertFolderHierarchy(String fileGuid, String pathName, String externalSourceGuid, String externalSourceName, String userId, String methodName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
    if (StringUtils.isEmpty(pathName)) {
        return;
    }
    validateParameters(fileGuid, externalSourceGuid, externalSourceName, userId, methodName);
    List<FileFolder> folders = extractFolders(pathName, externalSourceName, methodName);
    String folderGuid = """";
    String previousEntityGuid = fileGuid;
    String relationshipTypeName = NESTED_FILE_TYPE_NAME;
    for (FileFolder folder : folders) {
        if (relationshipTypeName.equals(NESTED_FILE_TYPE_NAME)) {
            deleteExistingNestedFileRelationships(fileGuid, externalSourceGuid, externalSourceName, userId, methodName);
        }
        folderGuid = upsertFolder(externalSourceGuid, externalSourceName, folder, userId, methodName);
        dataEngineCommonHandler.upsertExternalRelationship(userId, folderGuid, previousEntityGuid, relationshipTypeName, FILE_FOLDER_TYPE_NAME, externalSourceName, null);
        previousEntityGuid = folderGuid;
        relationshipTypeName = FOLDER_HIERARCHY_TYPE_NAME;
    }
    dataEngineCommonHandler.upsertExternalRelationship(userId, externalSourceGuid, folderGuid, SERVER_ASSET_USE_TYPE_NAME, SOFTWARE_SERVER_CAPABILITY_TYPE_NAME, externalSourceName, null);
}",upsertFolderHierarchy,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineFolderHierarchyHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineFolderHierarchyHandler.java,"/**
     * Construct the folder structure in which a data file is stored all the way to the SoftwareServerCapability. Care is
     * taken to maintain uniqueness of the relationship NestedFile that is between the file and the first folder.
     *
     * @param fileGuid           data file guid
     * @param pathName           file path
     * @param externalSourceGuid external source guid
     * @param externalSourceName external source name
     * @param userId             user id
     * @param methodName         method name
     *
     * @throws InvalidParameterException  if invalid parameters
     * @throws PropertyServerException    if errors in repository
     * @throws UserNotAuthorizedException if user not authorized
     */",65-107,"('upsertFolderHierarchy', {'INSTRUCTION': {'covered': 77, 'missed': 1}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 16, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",180.0,18.0,Construct the folder structure in which a data file is stored all the way to the SoftwareServerCapability.,Create the folder structure where the data file is stored until SoftwareServerCapability. Uniqueness of the relationship NestedFile is maintained.,The folder structure should have a data file in it.,0.543769217701536,Build the folder structure in which a data file is stored up to SoftwareServerCapability.
282,cdk,"private void flip(IBond bond){
    bond.setAtoms(new IAtom[] { bond.getEnd(), bond.getBegin() });
}",flip,org/openscience/cdk/inchi/InChIToStructure.java,/storage/inchi/src/main/java/org/openscience/cdk/inchi/InChIToStructure.java,"/**
     * Flip the storage order of atoms in a bond.
     * @param bond the bond
     */",150-156,"('flip', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,10.0,Flip the storage order of atoms in a bond.,Invert the order in which atoms in a bond are stored.,The storage order of atoms should be changed.,0.23574340791507,Reverse the order in which atoms are stored in a bond.
283,cdk,"protected static String formatMDLInt(int x, int n){
    char[] buf = new char[n];
    Arrays.fill(buf, ' ');
    String val = Integer.toString(x);
    if (val.length() > n)
        val = ""0"";
    int off = n - val.length();
    for (int i = 0; i < val.length(); i++) buf[off + i] = val.charAt(i);
    return new String(buf);
}",formatMDLInt,org/openscience/cdk/io/MDLV2000Writer.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Writer.java,"/**
     * Formats an integer to fit into the connection table and changes it
     * to a String.
     *
     * @param x The int to be formated
     * @param n Length of the String
     * @return The String to be written into the connectiontable
     */",1327-1345,"('formatMDLInt', {'INSTRUCTION': {'covered': 39, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",107.0,16.0,Formats an integer to fit into the connection table and changes it  to a String.,Change the format of an integer in order to fit into the connection table. The value is changed into a String.,The connection table has an integer that can be formatted to fit in.,0.557650317003611,Formats an integer to fit the connection table and replaces it with a string.
284,cdk,"private static int toCharge(final char c){
    switch(c) {
        case '1':
            return +3;
        case '2':
            return +2;
        case '3':
            return +1;
        case '4':
            return 0;
        case '5':
            return -1;
        case '6':
            return -2;
        case '7':
            return -3;
    }
    return 0;
}",toCharge,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Convert the a character (from an MDL V2000 input) to a charge value:
     * 1 = +1, 2 = +2, 3 = +3, 4 = doublet radical, 5 = -1, 6 = -2, 7 = -3.
     *
     * @param c a character
     * @return formal charge
     */",1620-1645,"('toCharge', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",68.0,45.0,"Convert the a character (from an MDL V2000 input) to a charge value:  1 = +1, 2 = +2, 3 = +3, 4 = doublet radical, 5 = -1, 6 = -2, 7 = -3.","Convert a specific character into a charge, starting from MDL V2000 input.",The a character is converted to a charge value of 1 + 1 + 2 + 3 + 4 + 5 + 6 + 7.,0.73073023592939,"Convert the character a (from an MDL V2000 entry) to the load value: 1 = +1, 2 = +2, 3 = +3, 4 = doublet radical, 5 = -1, 6 = -2, 7 = -3."
285,tablesaw,"public static Function<Table, Selection> notBoth(Function<Table, Selection> sel1, Function<Table, Selection> sel2){
    return new Not(both(sel1, sel2));
}",notBoth,tech/tablesaw/api/QuerySupport.java,/core/src/main/java/tech/tablesaw/api/QuerySupport.java,"/**
   * Returns a selection for all records that don't match both of the given functions. In other
   * words, if both sel1 and sel2 are true, the record as a whole is false, and if either (or both)
   * of sel1 or sel2 is {@code false}, the record as a whole is {@code true}.
   */",35-43,"('notBoth', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,16.0,Returns a selection for all records that don't match both of the given functions.,"For all records that don't match both the given functions, return a selection.",A selection is returned for records that don't match the functions.,0.203432381098079,Returns a selection for all records that do not match the two given functions.
286,cdk,"private boolean familyHalogen(IAtom atom){
    String symbol = atom.getSymbol();
    return symbol.equals(""F"") || symbol.equals(""Cl"") || symbol.equals(""Br"") || symbol.equals(""I"");
}",familyHalogen,org/openscience/cdk/qsar/descriptors/atomic/IPAtomicHOSEDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/IPAtomicHOSEDescriptor.java,"/**
     * Looking if the Atom belongs to the halogen family.
     *
     * @param  atom  The IAtom
     * @return       True, if it belongs
     */",162-171,"('familyHalogen', {'INSTRUCTION': {'covered': 22, 'missed': 1}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,10.0,Looking if the Atom belongs to the halogen family.,checks whether the selected Atom's familiy is halogen.,The atom is being looked at to see if it belongs to the halogen family.,0.556170552942032,See if the Atom belongs to the halogen family.
287,matsim-libs,"public final void addModule(final ConfigGroup specializedConfigModule){
    String name = specializedConfigModule.getName();
    if (name == null || name.isEmpty()) {
        throw new RuntimeException(""cannot insert module with empty name"");
    }
    ConfigGroup m = this.modules.get(name);
    if (m != null) {
        if (m.getClass() == ConfigGroup.class && specializedConfigModule.getClass() != ConfigGroup.class) {
            copyTo(m, specializedConfigModule);
            this.modules.put(name, specializedConfigModule);
        } else {
            throw new IllegalArgumentException(""Module "" + name + "" exists already."");
        }
    }
    this.modules.put(name, specializedConfigModule);
}",addModule,org/matsim/core/config/Config.java,/matsim/src/main/java/org/matsim/core/config/Config.java,"/**
	 * Adds the specified module / config-group with the specified name to the
	 * configuration.
	 * <p></p>
	 * This is the typical way to ""materialize"" material that, so far, exists only as Map, into a specialized module.
	 * @param specializedConfigModule
	 *
	 * @throws IllegalArgumentException
	 *             if a config-group with the specified name already exists.
	 */",245-279,"('addModule', {'INSTRUCTION': {'covered': 41, 'missed': 11}, 'BRANCH': {'covered': 6, 'missed': 4}, 'LINE': {'covered': 9, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",128.0,14.0,Adds the specified module / config-group with the specified name to the  configuration.,"Given the configuration, adds the module and config-group with the specified name.",The specified module is added to the configuration.,0.442515907608469,Adds the specified configuration module/group with the specified name to the configuration.
288,cdk,"static int length(final String str){
    int i = str.length() - 1;
    while (i >= 0 && str.charAt(i) == ' ') {
        i--;
    }
    return i + 1;
}",length,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Determine the length of the line excluding trailing whitespace.
     *
     * @param str a string
     * @return the length when trailing white space is removed
     */",1490-1502,"('length', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,10.0,Determine the length of the line excluding trailing whitespace.,"Ignoring the whitespaces at the end of a line, compute the line length.",The length of the line should be determined.,0.220993198326707,Determine the length of the line excluding trailing white space.
289,acs-aem-commons,"protected boolean runScript(ResourceResolver resourceResolver, OnDeployScript script){
    Resource statusResource = getOrCreateStatusTrackingResource(resourceResolver, script.getClass());
    String status = getScriptStatus(statusResource);
    if (status == null || status.equals(SCRIPT_STATUS_FAIL)) {
        trackScriptStart(statusResource);
        try {
            script.execute(resourceResolver);
            logger.info(""On-deploy script completed successfully: {}"", statusResource.getPath());
            trackScriptEnd(statusResource, SCRIPT_STATUS_SUCCESS, """");
            return true;
        } catch (Exception e) {
            String errMsg = ""On-deploy script failed: "" + statusResource.getPath();
            logger.error(errMsg, e);
            resourceResolver.revert();
            trackScriptEnd(statusResource, SCRIPT_STATUS_FAIL, ExceptionUtils.getStackTrace(e.getCause()));
            throw new OnDeployEarlyTerminationException(new RuntimeException(errMsg));
        }
    } else if (!status.equals(SCRIPT_STATUS_SUCCESS)) {
        String errMsg = ""On-deploy script is already running or in an otherwise unknown state: "" + statusResource.getPath() + "" - status: "" + status;
        logger.error(errMsg);
        throw new OnDeployEarlyTerminationException(new RuntimeException(errMsg));
    } else {
        logger.debug(""Skipping on-deploy script, as it is already complete: {}"", statusResource.getPath());
    }
    return false;
}",runScript,com/adobe/acs/commons/ondeploy/impl/OnDeployExecutorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/ondeploy/impl/OnDeployExecutorImpl.java,"/**
     * Run the {@link OnDeployScript}, if it has not previously been run successfully.
     * @param resourceResolver the resource resolver to use when running
     * @param script the script to run.
     * @return true if the script is executed, false if it has previous been run successfully
     */",191-225,"('runScript', {'INSTRUCTION': {'covered': 102, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 20, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",216.0,17.0,"Run the {@link OnDeployScript}, if it has not previously been run successfully.",Run the OnDeployScript only if the previous run were not successfully.,"If it has not been successfully run before, then you need to run the @link OnDeployScript.",1.08587842435127,"Run the {onDeployScript} @link, if it has not yet been run successfully."
290,cdk,"private Integer[] findPaths(IAtomContainer container){
    ShortestPathWalker walker = new ShortestPathWalker(container);
    List<Integer> paths = new ArrayList<Integer>();
    int patternIndex = 0;
    for (String s : walker.paths()) {
        int toHashCode = s.hashCode();
        paths.add(patternIndex, toHashCode);
        patternIndex++;
    }
    IRingSet sssr = Cycles.essential(container).toRingSet();
    RingSetManipulator.sort(sssr);
    for (Iterator<IAtomContainer> it = sssr.atomContainers().iterator(); it.hasNext(); ) {
        IAtomContainer ring = it.next();
        int toHashCode = String.valueOf(ring.getAtomCount()).hashCode();
        paths.add(patternIndex, toHashCode);
        patternIndex++;
    }
    List<String> l = new ArrayList<String>();
    for (Iterator<IAtom> it = container.atoms().iterator(); it.hasNext(); ) {
        IAtom atom = it.next();
        int charge = atom.getFormalCharge() == null ? 0 : atom.getFormalCharge();
        if (charge != 0) {
            l.add(atom.getSymbol().concat(String.valueOf(charge)));
        }
    }
    Collections.sort(l);
    int toHashCode = l.hashCode();
    paths.add(patternIndex, toHashCode);
    patternIndex++;
    l = new ArrayList<String>();
    for (Iterator<IAtom> it = container.atoms().iterator(); it.hasNext(); ) {
        IAtom atom = it.next();
        int st = atom.getStereoParity() == null ? 0 : atom.getStereoParity();
        if (st != 0) {
            l.add(atom.getSymbol().concat(String.valueOf(st)));
        }
    }
    Collections.sort(l);
    toHashCode = l.hashCode();
    paths.add(patternIndex, toHashCode);
    patternIndex++;
    if (container.getSingleElectronCount() > 0) {
        StringBuilder radicalInformation = new StringBuilder();
        radicalInformation.append(""RAD: "").append(String.valueOf(container.getSingleElectronCount()));
        paths.add(patternIndex, radicalInformation.toString().hashCode());
        patternIndex++;
    }
    if (container.getLonePairCount() > 0) {
        StringBuilder lpInformation = new StringBuilder();
        lpInformation.append(""LP: "").append(String.valueOf(container.getLonePairCount()));
        paths.add(patternIndex, lpInformation.toString().hashCode());
        patternIndex++;
    }
    return paths.toArray(new Integer[paths.size()]);
}",findPaths,org/openscience/cdk/fingerprint/ShortestPathFingerprinter.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/ShortestPathFingerprinter.java,"/**
     * Get all paths of lengths 0 to the specified length.
     *
     * This method will find all paths upto length N starting from each atom in the molecule and return the unique set
     * of such paths.
     *
     * @param container The molecule to search
     * @return A map of path strings, keyed on themselves
     */",177-255,"('findPaths', {'INSTRUCTION': {'covered': 156, 'missed': 50}, 'BRANCH': {'covered': 16, 'missed': 4}, 'LINE': {'covered': 40, 'missed': 9}, 'COMPLEXITY': {'covered': 7, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",545.0,11.0,Get all paths of lengths 0 to the specified length.,Return a unique set of all paths that start from each atom in the molecule with a length between 0 and N.,Get the paths of lengths 0 to the length.,0.222193016599033,Get all paths from length 0 to the specified length.
291,jackson-databind,"public static Class<?> primitiveType(Class<?> type){
    if (type.isPrimitive()) {
        return type;
    }
    if (type == Integer.class) {
        return Integer.TYPE;
    }
    if (type == Long.class) {
        return Long.TYPE;
    }
    if (type == Boolean.class) {
        return Boolean.TYPE;
    }
    if (type == Double.class) {
        return Double.TYPE;
    }
    if (type == Float.class) {
        return Float.TYPE;
    }
    if (type == Byte.class) {
        return Byte.TYPE;
    }
    if (type == Short.class) {
        return Short.TYPE;
    }
    if (type == Character.class) {
        return Character.TYPE;
    }
    return null;
}",primitiveType,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * Method that can be used to find primitive type for given class if (but only if)
     * it is either wrapper type or primitive type; returns {@code null} if type is neither.
     *
     * @since 2.7
     */",911-948,"('primitiveType', {'INSTRUCTION': {'covered': 47, 'missed': 0}, 'BRANCH': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",152.0,38.0,Method that can be used to find primitive type for given class if (but only if)  it is either wrapper type or primitive type; returns {@code null} if type is neither.,-,"If it is either wrapper type or primitive type, the method can be used to find primitive type for given class.",1.05062973103661,A method that can be used to find a primitive type for a given class if (but only if) it is either a wrapper type or a primitive type; returns {@code null} if the type is neither.
292,cucumber-reporting,"public boolean hasContent(){
    if (embeddings.length > 0) {
        // assuming that if the embedding exists then it is not empty
        return true;
    }
    if (StringUtils.isNotBlank(result.getErrorMessage())) {
        return true;
    }
    // TODO: hook with 'output' should be treated as empty or not?
    return false;
}",hasContent,net/masterthought/cucumber/json/Hook.java,/src/main/java/net/masterthought/cucumber/json/Hook.java,"/**
     * Checks if the hook has content meaning as it has at least attachment or result with error message.
     *
     * @return <code>true</code> if the hook has content otherwise <code>false</code>
     */",43-58,"('hasContent', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,19.0,Checks if the hook has content meaning as it has at least attachment or result with error message.,Check the presence of the content in the hook; this happens if there is an attachment or a result with an error message.,"If the hook has at least an attachment or result with an error message, it's checked.",0.735270647616884,Checks whether the hook has a content meaning because it has at least one attachment or result with error message.
293,cdk," static String auxInfo(IAtomContainer container, INCHI_OPTION... options) throws CDKException{
    InChIGeneratorFactory factory = InChIGeneratorFactory.getInstance();
    boolean org = factory.getIgnoreAromaticBonds();
    factory.setIgnoreAromaticBonds(true);
    InChIGenerator gen = factory.getInChIGenerator(container, Arrays.asList(options));
    factory.setIgnoreAromaticBonds(org);
    if (gen.getReturnStatus() != INCHI_RET.OKAY && gen.getReturnStatus() != INCHI_RET.WARNING)
        throw new CDKException(""Could not generate InChI Numbers: "" + gen.getMessage());
    return gen.getAuxInfo();
}",auxInfo,org/openscience/cdk/graph/invariant/InChINumbersTools.java,/storage/inchi/src/main/java/org/openscience/cdk/graph/invariant/InChINumbersTools.java,"/**
     * Obtain the InChI auxiliary info for the provided structure using
     * using the specified InChI options.
     *
     * @param  container the structure to obtain the numbers of
     * @return auxiliary info
     * @throws CDKException the inchi could not be generated
     */",224-241,"('auxInfo', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",106.0,16.0,Obtain the InChI auxiliary info for the provided structure using  using the specified InChI options.,"Get the InChi auxiliary info, using the specified options, for the given structure.",The InChI auxiliary info can be obtained using the specified options.,0.502110203370694,Obtain the InChI auxiliary information for the provided structure using the specified InChI options.
294,cdk,"public List<Orbit> calculateOrbits(){
    List<Orbit> orbits = new ArrayList<Orbit>();
    List<SymmetryClass> symmetryClasses = super.getSymmetryClasses();
    for (SymmetryClass symmetryClass : symmetryClasses) {
        Orbit orbit = new Orbit(symmetryClass.getSignatureString(), -1);
        for (int atomIndex : symmetryClass) {
            orbit.addAtom(atomIndex);
        }
        orbits.add(orbit);
    }
    return orbits;
}",calculateOrbits,org/openscience/cdk/signature/MoleculeSignature.java,/descriptor/signature/src/main/java/org/openscience/cdk/signature/MoleculeSignature.java,"/**
     * Calculates the orbits of the atoms of the molecule.
     *
     * @return a list of orbits
     */",153-169,"('calculateOrbits', {'INSTRUCTION': {'covered': 46, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,10.0,Calculates the orbits of the atoms of the molecule.,Returns the list of the orbits of all the atoms in the molecule.,The molecule's atoms are calculated.,0.536357632222563,Calculates the orbits of the atoms of the molecule.
295,acs-aem-commons,"private boolean isResourceOnly(final Agent agent){
    final ValueMap properties = agent.getConfiguration().getProperties();
    final String[] headers = properties.get(AgentConfig.PROTOCOL_HTTP_HEADERS, new String[] {});
    for (final String header : headers) {
        if (StringUtils.equals(header, CQ_SCOPE_ACTION_HEADER)) {
            return true;
        }
    }
    return false;
}",isResourceOnly,com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,"/**
     * Checks if the agent has valid CQ-Action-Scope: ResourceOnly header.
     *
     * @param agent Agent to check
     * @return true if the Agent's headers contain the expected values
     */",174-191,"('isResourceOnly', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,11.0,Checks if the agent has valid CQ-Action-Scope: ResourceOnly header.,Returns whether the Agent has a valid CQ-Action-Scope.,The agent is checked if it has a valid ResourceOnly header.,1.47112645415745,Checks whether the agent has a valid CQ-Action-Scope: ResourceOnly header.
296,shenyu,"public static LocalDateTime formatLocalDateTimeFromTimestamp(final Long timestamp){
    return LocalDateTime.ofEpochSecond(timestamp / 1000, 0, ZoneOffset.ofHours(8));
}",formatLocalDateTimeFromTimestamp,org/apache/shenyu/common/utils/DateUtils.java,/shenyu-common/src/main/java/org/apache/shenyu/common/utils/DateUtils.java,"/**
     * Format local date time from timestamp local date time.
     *
     * @param timestamp the timestamp
     * @return the local date time
     */",81-89,"('formatLocalDateTimeFromTimestamp', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,10.0,Format local date time from timestamp local date time.,Returns the local date time formatted from the timestamp of the local date time.,Local date time from local time stamp.,0.168517840529983,Format the local date and time from the local date timestamp.
297,tablesaw,"public Row appendRow(){
    for (final Column<?> column : columnList) {
        column.appendMissing();
    }
    return row(rowCount() - 1);
}",appendRow,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,"/**
   * Appends an empty row and returns a Row object indexed to the newly added row so values can be
   * set.
   *
   * <p>Intended usage:
   *
   * <p>for (int i = 0; ...) { Row row = table.appendRow(); row.setString(""name"", ""Bob"");
   * row.setFloat(""IQ"", 123.4f); ...etc. }
   */",1098-1112,"('appendRow', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,21.0,Appends an empty row and returns a Row object indexed to the newly added row so values can be  set.,"The function appends an empty row, returning a Row object pointing to the new inserted row in order to be set.",Appends an empty row and returns a Row object that is related to the new row.,1.06966574019092,Adds a blank row and returns an indexed Row object to the newly added row so that values can be set.
298,matsim-libs,"public static OptionalTime decideOnActivityEndTime(Activity act, double now, Config config){
    return decideOnActivityEndTime(act, now, config.plans().getActivityDurationInterpretation());
}",decideOnActivityEndTime,org/matsim/core/population/PopulationUtils.java,/matsim/src/main/java/org/matsim/core/population/PopulationUtils.java,"/**
         * Computes the (expected or planned) activity end time, depending on the configured time interpretation.
         */",458-463,"('decideOnActivityEndTime', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,18.0,"Computes the (expected or planned) activity end time, depending on the configured time interpretation.","After reading the configured time interpretation, computes the activity end time that is expected or planned.",The end time is computed based on the configured time interpretation.,0.1718143258513,"Calculates the end time of the activity (scheduled or scheduled), based on the interpretation of the configured time."
299,acs-aem-commons,"protected String aggregateChecksums(final Map<String, String> checksums){
    if (checksums.isEmpty()) {
        return null;
    }
    StringBuilder data = new StringBuilder();
    for (Map.Entry<String, String> entry : checksums.entrySet()) {
        data.append(entry.getKey() + ""="" + entry.getValue());
    }
    return DigestUtils.sha1Hex(data.toString());
}",aggregateChecksums,com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,"/**
     * Aggregates a set of checksum entries into a single checksum value.
     * @param checksums the checksums
     * @return the checksum value
     */",376-391,"('aggregateChecksums', {'INSTRUCTION': {'covered': 42, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,12.0,Aggregates a set of checksum entries into a single checksum value.,Returns the checksum value computed by aggregating a set of checksum entries.,A set of entries are aggregated into a single value.,0.367690462440356,Groups a set of checksum entries into a single checksum value.
300,cdk,"public static void translateAllPositive(IAtomContainer atomCon){
    double minX = Double.MAX_VALUE;
    double minY = Double.MAX_VALUE;
    Iterator<IAtom> atoms = atomCon.atoms().iterator();
    while (atoms.hasNext()) {
        IAtom atom = (IAtom) atoms.next();
        if (atom.getPoint2d() != null) {
            if (atom.getPoint2d().x < minX) {
                minX = atom.getPoint2d().x;
            }
            if (atom.getPoint2d().y < minY) {
                minY = atom.getPoint2d().y;
            }
        }
    }
    logger.debug(""Translating: minx="" + minX + "", minY="" + minY);
    translate2D(atomCon, minX * -1, minY * -1);
}",translateAllPositive,org/openscience/cdk/geometry/GeometryTools.java,/legacy/src/main/java/org/openscience/cdk/geometry/GeometryTools.java,"/**
     *  Adds an automatically calculated offset to the coordinates of all atoms
     *  such that all coordinates are positive and the smallest x or y coordinate
     *  is exactly zero.
     *  See comment for center(IAtomContainer atomCon, Dimension areaDim, HashMap renderingCoordinates) for details on coordinate sets
     *
     *@param  atomCon  AtomContainer for which all the atoms are translated to
     *      positive coordinates
     */",102-128,"('translateAllPositive', {'INSTRUCTION': {'covered': 62, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",150.0,28.0,Adds an automatically calculated offset to the coordinates of all atoms  such that all coordinates are positive and the smallest x or y coordinate  is exactly zero.,The function calculates an offset that has to be added to the coordinates of all atoms so that the smallest x or y coordinates is exactly zero.,The smallest x or y coordinate is exactly zero when calculating the offset.,0.611724182652086,Adds an automatically calculated offset to the coordinates of all atoms so that all coordinates are positive and the smallest x or y coordinate is exactly zero.
301,cdk,"private int permutationParity(int[] vs){
    int n = 0;
    for (int i = 0; i < vs.length; i++) for (int j = i + 1; j < vs.length; j++) if (vs[i] > vs[j])
        n++;
    return (n & 0x1) == 1 ? -1 : 1;
}",permutationParity,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,"/**
     * Compute the permutation parity of the values {@code vs}. The parity is
     * whether we need to do an odd or even number of swaps to put the values in
     * sorted order.
     *
     * @param vs values
     * @return parity of the permutation (odd = -1, even = +1)
     */",310-324,"('permutationParity', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",79.0,13.0,Compute the permutation parity of the values {@code vs}.,"Given a list of values, it returns the permutation parity. The parity is equal to -1 if we need a odd number of swaps to sort the list or +1 if we need a even number of swaps.",The permutation parity of the values is computed.,0.196910072447064,Calculate the permutation parity of the {@code vs} values.
302,glowstone,"public boolean isList(@NonNls String key, TagType type){
    if (!is(key, ListTag.class)) {
        return false;
    }
    ListTag tag = getTag(key, ListTag.class);
    return tag.getChildType() == type;
}",isList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Test whether the subtag with the given key is of {@link List} type.
     *
     * @param key the key to look up
     * @param type the {@link TagType} of the list's elements
     * @return true if the subtag exists and is a {@link List}; false otherwise
     */",842-855,"('isList', {'INSTRUCTION': {'covered': 20, 'missed': 1}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",52.0,17.0,Test whether the subtag with the given key is of {@link List} type.,"Given a key, check whether the subtag containing the key is of List type.",The subtag with the given key is of the @link List type.,1.02217324065121,Check if the subtag with the given key is of type {@link List}.
303,cdk,"public int[] findHeavyAtomsInChain(IAtomContainer molecule, IAtomContainer chain){
    int[] heavy = { -1, -1 };
    int hc = 0;
    for (int i = 0; i < chain.getAtomCount(); i++) {
        if (isHeavyAtom(chain.getAtom(i))) {
            if (heavy[0] < 0) {
                heavy[0] = molecule.indexOf(chain.getAtom(i));
            }
            hc++;
        }
    }
    heavy[1] = hc;
    return heavy;
}",findHeavyAtomsInChain,org/openscience/cdk/modeling/builder3d/AtomPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomPlacer3D.java,"/**
     *  Count and find first heavy atom(s) (non Hydrogens) in a chain.
     *
     * @param  molecule the reference molecule for searching the chain
     * @param  chain  chain to be searched
     * @return        the atom number of the first heavy atom the number of heavy atoms in the chain
     */",81-101,"('findHeavyAtomsInChain', {'INSTRUCTION': {'covered': 46, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",107.0,17.0,Count and find first heavy atom(s) (non Hydrogens) in a chain.,"The function can count and found the first heavy atom in the chain, ignoring Hydrogens.",Find the first heavy atom in a chain.,0.380739529018082,Count and find the first heavy atom(s) (non-hydrogen) in a chain.
304,matsim-libs,"private void consolidateData(final TravelTimeData data){
    synchronized (data) {
        if (data.isNeedingConsolidation()) {
            // initialize prevTravelTime with ttime from time bin 0 and time 0.  (The interface comment already states that
            // having both as argument does not make sense.)
            double prevTravelTime = data.getTravelTime(0, 0.0);
            // changed (1, 0.0) to (0, 0.0) since Michal has convinced me (by a test) that using ""1"" is wrong
            // because you get the wrong result for time slot number 1.  This change does not affect the existing
            // unit tests.  kai, oct'11
            // go from time slot 1 forward in time:
            for (int i = 1; i < this.numSlots; i++) {
                // once more the getter is weird since it needs both the time slot and the time:
                double travelTime = data.getTravelTime(i, i * this.timeSlice);
                // if the travel time in the previous time slice was X, then now it is X-S, where S is the time slice:
                double minTravelTime = prevTravelTime - this.timeSlice;
                // if the travel time that has been measured so far is less than that minimum travel time, then do something:
                if (travelTime < minTravelTime) {
                    // (set the travel time to the smallest possible travel time that makes sense according to the argument above)
                    travelTime = minTravelTime;
                    data.setTravelTime(i, travelTime);
                }
                prevTravelTime = travelTime;
            }
            data.setNeedsConsolidation(false);
        }
    }
}",consolidateData,org/matsim/core/trafficmonitoring/TravelTimeCalculator.java,/matsim/src/main/java/org/matsim/core/trafficmonitoring/TravelTimeCalculator.java,"/**
	 * Makes sure that the travel times ""make sense"".
	 * <p></p>
	 * Imagine short bin sizes (e.g. 5min), small links (e.g. 300 veh/hour)
	 * and small sample sizes (e.g. 2%). This would mean that effectively
	 * in the simulation only 6 vehicles can pass the link in one hour,
	 * one every 10min. So, the travel time in one time slot could be 
	 * >= 10min if two cars enter the link at the same time. If no car
	 * enters in the next time bin, the travel time in that time bin should
	 * still be >=5 minutes (10min - binSize), and not freespeedTraveltime,
	 * because actually every car entering the link in this bin will be behind
	 * the car entered before, which still needs >=5min until it can leave.
	 * <p></p>
	 * This method ensures that the travel time in a time bin
	 * cannot be smaller than the travel time in the bin before minus the
	 * bin size.
	 *
	 */",439-488,"('consolidateData', {'INSTRUCTION': {'covered': 54, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",113.0,11.0,"Makes sure that the travel times ""make sense"".","Checks that the travel times are meaningful. Imagine that the bin size is 5 min, the links is 300 veh/hour and the sample size is 2%. It means that only 6 vehicles can pass the link every hour (one every 10 minutes). This imply that the travel time in a time slot can be >=10 minutes if two cars enter the link at the same time. If we see that no car enters in the next time been, hence the travel time must be >=5 minutes.",It's important that the travel times make sense.,0.638665515646668,"Makes sure travel times ""make sense."""
305,mybatis-3,"public ResolverUtil<T> findImplementations(Class<?> parent, String... packageNames){
    if (packageNames == null) {
        return this;
    }
    Test test = new IsA(parent);
    for (String pkg : packageNames) {
        find(test, pkg);
    }
    return this;
}",findImplementations,org/apache/ibatis/io/ResolverUtil.java,/src/main/java/org/apache/ibatis/io/ResolverUtil.java,"/**
   * Attempts to discover classes that are assignable to the type provided. In the case
   * that an interface is provided this method will collect implementations. In the case
   * of a non-interface class, subclasses will be collected.  Accumulated classes can be
   * accessed by calling {@link #getClasses()}.
   *
   * @param parent
   *          the class of interface to find subclasses or implementations of
   * @param packageNames
   *          one or more package names to scan (including subpackages) for classes
   * @return the resolver util
   */",185-208,"('findImplementations', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",58.0,12.0,Attempts to discover classes that are assignable to the type provided.,"Given the provided type, it tries to find classes that are assignable. The method will collect implementations if we provide an interface and subclasses if we provide a non-interface class. You can acces to the found classes by calling getClasses()",Attempts to find classes that are assignable.,0.338556048005858,Attempts to discover which classes can be assigned to the type provided.
306,cdk,"public boolean mapTemplates(IAtomContainer molecule) throws CDKException{
    for (Pattern anonPattern : elemPatterns) {
        for (Map<IAtom, IAtom> atoms : anonPattern.matchAll(molecule).toAtomMap()) {
            for (Map.Entry<IAtom, IAtom> e : atoms.entrySet()) {
                e.getValue().setPoint2d(new Point2d(e.getKey().getPoint2d()));
                e.getValue().setFlag(CDKConstants.ISPLACED, true);
            }
            if (!atoms.isEmpty())
                return true;
        }
    }
    for (Pattern anonPattern : anonPatterns) {
        for (Map<IAtom, IAtom> atoms : anonPattern.matchAll(molecule).toAtomMap()) {
            for (Map.Entry<IAtom, IAtom> e : atoms.entrySet()) {
                e.getValue().setPoint2d(new Point2d(e.getKey().getPoint2d()));
                e.getValue().setFlag(CDKConstants.ISPLACED, true);
            }
            if (!atoms.isEmpty())
                return true;
        }
    }
    return false;
}",mapTemplates,org/openscience/cdk/layout/TemplateHandler.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/TemplateHandler.java,"/**
     * Checks if one of the loaded templates is a substructure in the given
     * Molecule. If so, it assigns the coordinates from the template to the
     * respective atoms in the Molecule, and marks the atoms as ISPLACED.
     *
     * @param molecule The molecule to be check for potential templates
     * @return True if there was a possible mapping
     */",209-241,"('mapTemplates', {'INSTRUCTION': {'covered': 120, 'missed': 2}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 19, 'missed': 2}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",218.0,15.0,Checks if one of the loaded templates is a substructure in the given  Molecule.,"Given a molecule, verifies if one of the templates that have been loaded is a substructure. It this happens, the function assigns the coordintes from the template to the involved atoms, marking them as ISPLACED.","If one of the loaded templates is a substructure, the check is done.",0.234761477131769,Checks whether any of the charged models is a substructure in the given molecule.
307,matsim-libs,"private void checkNodeIsMarkedAsCountStation(Node node){
    Link linkToBlock = null;
    if (this.shortNameMap.keySet().contains(node.getId().toString())) {
        // node is marked as count station
        if (node.getInLinks().size() == 1 && node.getOutLinks().size() == 1) {
            // ok, node has one in and one outLink, so put the count station on the shorter one and block it
            // Prefer the inLink, if both have the same length
            for (Link inLink : node.getInLinks().values()) {
                for (Link outLink : node.getOutLinks().values()) {
                    if (inLink.getLength() > outLink.getLength()) {
                        linkToBlock = outLink;
                    } else {
                        linkToBlock = inLink;
                    }
                    break;
                }
                break;
            }
            // check, if count data is present
            Id<Link> shortNameId = Id.create(this.shortNameMap.get(node.getId().toString()), Link.class);
            if (this.outCounts.getCount(shortNameId) == null) {
                // Count station wasn't added to outCounts, yet
                Count<Link> oldCount = this.inCounts.getCount(shortNameId);
                if (oldCount == null) {
                    // count station was mapped, but data can not be provided, do nothing
                    // TODO [AN] Check, if linkToBlock can be removed
                } else {
                    // create new count with correct locId and migrate data
                    if (linkToBlock != null) {
                        this.outCounts.createAndAddCount(linkToBlock.getId(), oldCount.getCsLabel());
                        Count<Link> newCount = this.outCounts.getCount(linkToBlock.getId());
                        newCount.setCoord(oldCount.getCoord());
                        for (Volume volume : oldCount.getVolumes().values()) {
                            newCount.createVolume(volume.getHourOfDayStartingWithOne(), volume.getValue());
                        }
                    }
                }
            } else {
                // count station was already processed and moved to outCounts
            }
        } else {
            log.warn(""Count station "" + this.shortNameMap.get(node.getId().toString()) + "" is registerd to node "" + node.getId().toString() + "" which has "" + node.getInLinks().size() + "" inLinks and "" + node.getOutLinks().size() + "" outLinks. Can only map one to one. Removing count station from counts data."");
        }
    }
    // everything worked fine, check if a link was blocked
    if (linkToBlock != null) {
        this.linksBlockedByFacility.add(linkToBlock.getId().toString());
    }
}",checkNodeIsMarkedAsCountStation,playground/vsp/andreas/osmBB/PTCountsNetworkSimplifier.java,/contribs/vsp/src/main/java/playground/vsp/andreas/osmBB/PTCountsNetworkSimplifier.java,"/**
         * Check whether the node is marked as count station. If that is the case, migrate its count data to outCounts and mark it as non modifiable
         * @param node The node to be checked
         */",354-408,"('checkNodeIsMarkedAsCountStation', {'INSTRUCTION': {'covered': 146, 'missed': 4}, 'BRANCH': {'covered': 15, 'missed': 7}, 'LINE': {'covered': 25, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 7}, 'METHOD': {'covered': 1, 'missed': 0}})",389.0,10.0,Check whether the node is marked as count station.,"If the node is marked as count station, move the count data to outCount and mark the node as non changeable",The count station is marked by the location of the node.,0.477508440086464,Check if the node is marked as a counting station.
308,cdk,"private static boolean isHueckelValid(IAtomContainer singleRing) throws CDKException{
    int electronCount = 0;
    for (IAtom ringAtom : singleRing.atoms()) {
        if (ringAtom.getHybridization() != CDKConstants.UNSET && (ringAtom.getHybridization() == Hybridization.SP2) || ringAtom.getHybridization() == Hybridization.PLANAR3) {
            // for example, a carbon
            // note: the double bond is in the ring, that has been tested earlier
            // FIXME: this does assume bond orders to be resolved too, when detecting
            // sprouting double bonds
            if (""N.planar3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""N.minus.planar3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""N.amide"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""S.2"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""S.planar3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""C.minus.planar"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""O.planar3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""N.sp2.3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 1;
            } else {
                if (factory == null) {
                    factory = AtomTypeFactory.getInstance(""org/openscience/cdk/dict/data/cdk-atom-types.owl"", ringAtom.getBuilder());
                }
                IAtomType type = factory.getAtomType(ringAtom.getAtomTypeName());
                Object property = type.getProperty(CDKConstants.PI_BOND_COUNT);
                if (property != null && property instanceof Integer) {
                    electronCount += ((Integer) property).intValue();
                }
            }
        } else if (ringAtom.getHybridization() != null && ringAtom.getHybridization() == Hybridization.SP3 && getLonePairCount(ringAtom) > 0) {
            // for example, a nitrogen or oxygen
            electronCount += 2;
        }
    }
    return (electronCount % 4 == 2) && (electronCount > 2);
}",isHueckelValid,org/openscience/cdk/aromaticity/DoubleBondAcceptingAromaticityDetector.java,/legacy/src/main/java/org/openscience/cdk/aromaticity/DoubleBondAcceptingAromaticityDetector.java,"/**
     * Tests if the electron count matches the H&uuml;ckel 4n+2 rule.
     */",124-170,"('isHueckelValid', {'INSTRUCTION': {'covered': 118, 'missed': 15}, 'BRANCH': {'covered': 27, 'missed': 13}, 'LINE': {'covered': 28, 'missed': 5}, 'COMPLEXITY': {'covered': 11, 'missed': 10}, 'METHOD': {'covered': 1, 'missed': 0}})",351.0,15.0,Tests if the electron count matches the H&uuml;ckel 4n+2 rule.,"Using the 4n+2 rule, the function evaluates if the electron count matches the H&uuml",The H&uuml;ckel 4n+2 rule requires tests if the electron count matches it.,0.358461452030907,Tests whether the number of electrons corresponds to the Hückel 4n+2 rule.
309,tablesaw,"public List<LocalTime> top(int n){
    List<LocalTime> top = new ArrayList<>();
    int[] values = data.toIntArray();
    IntArrays.parallelQuickSort(values, IntComparators.OPPOSITE_COMPARATOR);
    for (int i = 0; i < n && i < values.length; i++) {
        top.add(PackedLocalTime.asLocalTime(values[i]));
    }
    return top;
}",top,tech/tablesaw/api/TimeColumn.java,/core/src/main/java/tech/tablesaw/api/TimeColumn.java,"/**
   * Returns the largest (""top"") n values in the column. Does not change the order in this column
   *
   * @param n The maximum number of records to return. The actual number will be smaller if n is
   *     greater than the number of observations in the column
   * @return A list, possibly empty, of the largest observations
   */",495-510,"('top', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,14.0,"Returns the largest (""top"") n values in the column.","Returns a list of the largest n observation in the column, without changing the order of the element in that column.",The largest values are in the column.,0.468040413201937,"Returns the n largest values (""top"") in the column."
310,shardingsphere-elasticjob,"public boolean isDisabled(@Param(name = ""jobName"", source = ParamSource.PATH) final String jobName){
    return facadeService.isJobDisabled(jobName);
}",isDisabled,org/apache/shardingsphere/elasticjob/cloud/console/controller/CloudJobController.java,/elasticjob-cloud/elasticjob-cloud-scheduler/src/main/java/org/apache/shardingsphere/elasticjob/cloud/console/controller/CloudJobController.java,"/**
     * Check whether the cloud job is disabled or not.
     *
     * @param jobName job name
     * @return true is disabled, otherwise not
     */",142-151,"('isDisabled', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,10.0,Check whether the cloud job is disabled or not.,"Given a jobName, returns true if the cloud job is disabled and false otherwise.",Check to see if the cloud job is disabled.,0.417081237679259,Check if the cloud task is disabled or not.
311,cdk,"private IAtomContainer connectAtoms(String inputInchi, IAtomContainer inputMolecule, Map<Integer, IAtom> inchiAtomsByPosition) throws CDKException{
    String inchi = inputInchi;
    inchi = inchi.substring(inchi.indexOf('/') + 1);
    inchi = inchi.substring(inchi.indexOf('/') + 1);
    String connections = inchi.substring(1, inchi.indexOf('/'));
    Pattern connectionPattern = Pattern.compile(""(-|\\(|\\)|,|([0-9])*)"");
    Matcher match = connectionPattern.matcher(connections);
    Stack<IAtom> atomStack = new Stack<IAtom>();
    IAtomContainer inchiMolGraph = inputMolecule.getBuilder().newInstance(IAtomContainer.class);
    boolean pop = false;
    boolean push = true;
    while (match.find()) {
        String group = match.group();
        push = true;
        if (!group.isEmpty()) {
            if (group.matches(""[0-9]*"")) {
                IAtom atom = inchiAtomsByPosition.get(Integer.valueOf(group));
                if (!inchiMolGraph.contains(atom))
                    inchiMolGraph.addAtom(atom);
                IAtom prevAtom = null;
                if (atomStack.size() != 0) {
                    if (pop) {
                        prevAtom = atomStack.pop();
                    } else {
                        prevAtom = atomStack.get(atomStack.size() - 1);
                    }
                    IBond bond = inputMolecule.getBuilder().newInstance(IBond.class, prevAtom, atom, IBond.Order.SINGLE);
                    inchiMolGraph.addBond(bond);
                }
                if (push) {
                    atomStack.push(atom);
                }
            } else if (group.equals(""-"")) {
                pop = true;
                push = true;
            } else if (group.equals("","")) {
                atomStack.pop();
                pop = false;
                push = false;
            } else if (group.equals(""("")) {
                pop = false;
                push = true;
            } else if (group.equals("")"")) {
                atomStack.pop();
                pop = true;
                push = true;
            } else {
                throw new CDKException(""Unexpected token "" + group + "" in connection table encountered."");
            }
        }
    }
    for (IAtom at : inchiAtomsByPosition.values()) {
        if (!inchiMolGraph.contains(at))
            inchiMolGraph.addAtom(at);
    }
    return inchiMolGraph;
}",connectAtoms,org/openscience/cdk/tautomers/InChITautomerGenerator.java,/tool/tautomer/src/main/java/org/openscience/cdk/tautomers/InChITautomerGenerator.java,"/**
     * Pops and pushes its ways through the InChI connection table to build up a simple molecule.
     * @param inputInchi user input InChI
     * @param inputMolecule user input molecule
     * @param inchiAtomsByPosition
     * @return molecule with single bonds and no hydrogens.
     */",249-313,"('connectAtoms', {'INSTRUCTION': {'covered': 179, 'missed': 25}, 'BRANCH': {'covered': 22, 'missed': 4}, 'LINE': {'covered': 42, 'missed': 4}, 'COMPLEXITY': {'covered': 10, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",447.0,17.0,Pops and pushes its ways through the InChI connection table to build up a simple molecule.,"In order to build up a simple molecule, using the InChi connection table, the method pops and pushes its ways returning a molecule with only one bond and no hydrogens.",Pops and pushes its way through the InChI connection table to build a molecule.,0.230125983703327,Pops and pushes its way through the InChI connection table to build a simple molecule.
312,cdk,"public DescriptorValue calculate(IAtomContainer container){
    // don't mod original
    container = clone(container);
    MurckoFragmenter fragmenter = new MurckoFragmenter(true, 3);
    DoubleResult result;
    try {
        fragmenter.generateFragments(container);
        IAtomContainer[] framework = fragmenter.getFrameworksAsContainers();
        IAtomContainer[] ringSystems = fragmenter.getRingSystemsAsContainers();
        if (framework.length == 1) {
            result = new DoubleResult(framework[0].getAtomCount() / (double) container.getAtomCount());
        } else if (framework.length == 0 && ringSystems.length == 1) {
            result = new DoubleResult(ringSystems[0].getAtomCount() / (double) container.getAtomCount());
        } else
            result = new DoubleResult(0.0);
    } catch (CDKException e) {
        result = new DoubleResult(Double.NaN);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), result, getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/FMFDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/FMFDescriptor.java,"/**
     * Calculates the FMF descriptor value for the given {@link IAtomContainer}.
     *
     * @param container An {@link org.openscience.cdk.interfaces.IAtomContainer} for which this descriptor
     *                  should be calculated
     * @return An object of {@link org.openscience.cdk.qsar.DescriptorValue} that contains the
     *         calculated FMF descriptor value as well as specification details
     */",58-89,"('calculate', {'INSTRUCTION': {'covered': 62, 'missed': 20}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 12, 'missed': 3}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",186.0,14.0,Calculates the FMF descriptor value for the given {@link IAtomContainer}.,"GIven a IAtomContainer, returns an objet that contains the FMF value calculated with the specification details.",The given @link IAtomContainer is calculated.,0.999927363451456,Calculates the value of the FMF descriptor for the given {@link IAtomContainer}.
313,shardingsphere-elasticjob,"public static JobContext from(final CloudJobConfiguration cloudJobConfig, final ExecutionType type){
    int shardingTotalCount = cloudJobConfig.getJobConfig().getShardingTotalCount();
    List<Integer> shardingItems = new ArrayList<>(shardingTotalCount);
    for (int i = 0; i < shardingTotalCount; i++) {
        shardingItems.add(i);
    }
    return new JobContext(cloudJobConfig, shardingItems, type);
}",from,org/apache/shardingsphere/elasticjob/cloud/scheduler/context/JobContext.java,/elasticjob-cloud/elasticjob-cloud-scheduler/src/main/java/org/apache/shardingsphere/elasticjob/cloud/scheduler/context/JobContext.java,"/**
     * Create job running context from job configuration and execution type.
     *
     * @param cloudJobConfig cloud job configuration
     * @param type execution type
     * @return Job running context
     */",41-55,"('from', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",76.0,11.0,Create job running context from job configuration and execution type.,Returns the created Job running context starting from the job configuration and the execution time.,Job configuration and execution type are used to create a job.,0.513835445199866,Create a task execution context from the task configuration and execution type.
314,cdk,"private boolean isMajorIsotope(int number, int mass){
    try {
        IIsotope isotope = Isotopes.getInstance().getMajorIsotope(number);
        return isotope != null && isotope.getMassNumber().equals(mass);
    } catch (IOException e) {
        return false;
    }
}",isMajorIsotope,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,"/**
     * Utility to determine if the specified mass is the major isotope for the given atomic number.
     *
     * @param number atomic number
     * @param mass   atomic mass
     * @return the mass is the major mass for the atomic number
     */",571-585,"('isMajorIsotope', {'INSTRUCTION': {'covered': 15, 'missed': 4}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 2, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,17.0,Utility to determine if the specified mass is the major isotope for the given atomic number.,"Given an atomic number, the utility can determine if a specific mass is the major isotope for that atomic number.",The mass is the major isotope for the number.,0.204602834727738,Utility for determining whether the specified mass is the primary isotope for the given atomic number.
315,acs-aem-commons,"public Map<String, String> generateChecksums(Session session, String path) throws RepositoryException, IOException{
    return generateChecksums(session, path, new DefaultChecksumGeneratorOptions());
}",generateChecksums,com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,"/**
     * Convenience method for  generateChecksums(session, path, new DefaultChecksumGeneratorOptions()).
     *
     * @param session the session
     * @param path tthe root path to generate checksums for
     * @return the map of abs path ~&gt; checksums
     * @throws RepositoryException
     * @throws IOException
     */",65-77,"('generateChecksums', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,15.0,"Convenience method for generateChecksums(session, path, new DefaultChecksumGeneratorOptions()).","Given a session and the root path, it generates the checksums.",The convenience method for generating checks is DefaultChecksumGeneratorOptions.,0.373452842913686,"Convenience method for generateChecksums(session, path, new DefaultChecksumGeneratorOptions())."
316,cdk,"long next(long seed){
    seed = seed ^ seed << 21;
    seed = seed ^ seed >>> 35;
    return seed ^ seed << 4;
}",next,org/openscience/cdk/hash/Xorshift.java,/tool/hash/src/main/java/org/openscience/cdk/hash/Xorshift.java,"/**
     * Generate the next pseudorandom number for the provided <i>seed</i>.
     *
     * @param seed random number seed
     * @return the next pseudorandom number
     */",39-50,"('next', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,16.0,Generate the next pseudorandom number for the provided <i>seed</i>.,"Given a seed, it returns the next pseudorandom number.",The next pseudorandom number is provided.,0.653185444013288,Generate the following pseudo-random number for the <i>seed</i> provided.
318,openapi-generator,"public String toVarName(final String name){
    if (reservedWords.contains(name)) {
        return escapeReservedWord(name);
    } else if (name.chars().anyMatch(character -> specialCharReplacements.containsKey(String.valueOf((char) character)))) {
        return escape(name, specialCharReplacements, null, null);
    }
    return name;
}",toVarName,org/openapitools/codegen/DefaultCodegen.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java,"/**
     * Return the variable name by removing invalid characters and proper escaping if
     * it's a reserved word.
     *
     * @param name the variable name
     * @return the sanitized variable name
     */",1451-1465,"('toVarName', {'INSTRUCTION': {'covered': 20, 'missed': 4}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",73.0,18.0,Return the variable name by removing invalid characters and proper escaping if  it's a reserved word.,"Given a variable name, the function sanitized id by removing invalid characters and escaping reserved words.",Remove invalid characters and proper escaping if the variable name is a reserved word.,0.312029275883449,Return the variable name by removing invalid characters and the appropriate escape if it is a reserved word.
319,cdk,"private Result compareRowwise(Permutation perm){
    int m = perm.size();
    for (int i = 0; i < m - 1; i++) {
        for (int j = i + 1; j < m; j++) {
            int x = getConnectivity(best.get(i), best.get(j));
            int y = getConnectivity(perm.get(i), perm.get(j));
            if (x > y)
                return Result.WORSE;
            if (x < y)
                return Result.BETTER;
        }
    }
    return Result.EQUAL;
}",compareRowwise,org/openscience/cdk/group/AbstractDiscretePartitionRefiner.java,/tool/group/src/main/java/org/openscience/cdk/group/AbstractDiscretePartitionRefiner.java,"/**
     * Check a permutation to see if it is better, equal, or worse than the
     * current best.
     *
     * @param perm the permutation to check
     * @return BETTER, EQUAL, or WORSE
     */",335-353,"('compareRowwise', {'INSTRUCTION': {'covered': 49, 'missed': 4}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",121.0,19.0,"Check a permutation to see if it is better, equal, or worse than the  current best.","Given the current best permutation, checks whether the new found permutation is worse, better, or equal than the best one.","To see if it is better, equal, or worse than the current best, check a permutation.",0.527037406011076,"Check a permutation to see if it is better, equal, or worse than the current best."
320,anserini,"public String documentContents(int ldocid){
    try {
        return reader.document(ldocid).get(IndexArgs.CONTENTS);
    } catch (Exception e) {
        return null;
    }
}",documentContents,io/anserini/search/SimpleImpactSearcher.java,/src/main/java/io/anserini/search/SimpleImpactSearcher.java,"/**
     * Returns the ""contents"" field of a document based on an internal Lucene docid.
     * The method is named to be consistent with Lucene's {@link IndexReader#document(int)}, contra Java's standard
     * method naming conventions.
     *
     * @param ldocid internal Lucene docid
     * @return the ""contents"" field the document
     */",317-332,"('documentContents', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,16.0,"Returns the ""contents"" field of a document based on an internal Lucene docid.","Starting from a Lucene internal documentation id, returns the ""contents"" field.","The ""contents"" field is based on an internal docid.",1.68958674371626,"Returns the ""contents"" field of a document based on an internal Lucene docid."
321,shardingsphere-elasticjob,"public Collection<Map<String, String>> sandbox(@Param(name = ""appName"", source = ParamSource.QUERY) final String appName) throws JsonParseException{
    Preconditions.checkArgument(!Strings.isNullOrEmpty(appName), ""Lack param 'appName'"");
    return mesosStateService.sandbox(appName);
}",sandbox,org/apache/shardingsphere/elasticjob/cloud/console/controller/CloudOperationController.java,/elasticjob-cloud/elasticjob-cloud-scheduler/src/main/java/org/apache/shardingsphere/elasticjob/cloud/console/controller/CloudOperationController.java,"/**
     * Get sandbox of the cloud job by app name.
     *
     * @param appName application name
     * @return sandbox info
     * @throws JsonParseException parse json exception
     */",94-105,"('sandbox', {'INSTRUCTION': {'covered': 11, 'missed': 1}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",56.0,10.0,Get sandbox of the cloud job by app name.,"Starting from the app name, the function provides a sandbox for the cloud job",The cloud job can be accessed by app name.,0.125551702804531,Get the sandbox of the cloud job by application name.
322,jeromq,"public ZMsg wrap(ZFrame frame){
    if (frame != null) {
        push(new ZFrame(""""));
        push(frame);
    }
    return this;
}",wrap,org/zeromq/ZMsg.java,/src/main/java/org/zeromq/ZMsg.java,"/**
     * Push frame plus empty frame to front of message, before 1st frame.
     * Message takes ownership of frame, will destroy it when message is sent.
     * @param frame
     */",115-127,"('wrap', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,14.0,"Push frame plus empty frame to front of message, before 1st frame.",Push before the first frame in from of the message the current frame followed by an empty frame. The message will destroy the frame after the sending.,The empty frame should be placed in front of the message before the first frame.,1.12701376195257,"Push the frame plus the blank frame towards the front of the message, before the 1st image."
323,egeria,"public Optional<EntityDetail> findPortAliasEntity(String userId, String qualifiedName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, PORT_ALIAS_TYPE_NAME);
}",findPortAliasEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,"/**
     * Find out if the PortAlias object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",349-365,"('findPortAliasEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,13.0,Find out if the PortAlias object is already stored in the repository.,"Discover whether the PortAlias object is already present in the repository, using the fully qualified name for retrieving the entity.","If the PortAlias object is already in the repository, you should find it.",0.207766070085106,Check if the PortAlias object is already stored in the repository.
324,cdk,"public static boolean has3DCoordinates(IAtomContainer container){
    if (container == null || container.getAtomCount() == 0)
        return Boolean.FALSE;
    for (IAtom atom : container.atoms()) {
        if (atom == null || atom.getPoint3d() == null)
            return Boolean.FALSE;
    }
    return Boolean.TRUE;
}",has3DCoordinates,org/openscience/cdk/geometry/GeometryTools.java,/legacy/src/main/java/org/openscience/cdk/geometry/GeometryTools.java,"/**
     * Determines if all this {@link IAtomContainer}'s atoms contain 3D coordinates. If any atom
     * is null or has unset 3D coordinates this method will return false. If the provided
     * container is null false is returned.
     *
     * @param container the atom container to examine
     *
     * @return indication that all 3D coordinates are available
     *
     * @see org.openscience.cdk.interfaces.IAtom#getPoint3d()
     */",1080-1103,"('has3DCoordinates', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,15.0,Determines if all this {@link IAtomContainer}'s atoms contain 3D coordinates.,Checks whether the IAtomContainer's atoms have 3D coordinates. Returns false if any atom is null or does not have 3D coordinates.,If all this is IAtomContainer's atoms have 3D coordinates.,0.354613282855063,Determines whether all of these {@link atoms of IAtomContainer} contain 3D coordinates.
325,jackson-databind,"public static String backticked(String text){
    if (text == null) {
        return ""[null]"";
    }
    return new StringBuilder(text.length() + 2).append('`').append(text).append('`').toString();
}",backticked,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * Returns either {@code `text`} (backtick-quoted) or {@code [null]}.
     *
     * @since 2.9
     */",793-803,"('backticked', {'INSTRUCTION': {'covered': 17, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,21.0,Returns either {@code `text`} (backtick-quoted) or {@code [null]}.,"Returns the fields 'text', blacktick-quoted or null.",Either @code text or @code [null] returns.,0.869858260293606,Returns {@code 'text'} (quotation marks back) or {@code [null]}.
326,cdk,"public void build() throws CDKException{
    trainingSize = training.size();
    trainingActives = numActive;
    contribs.clear();
    final int sz = training.size();
    final double invSz = 1.0 / sz;
    final double P_AT = numActive * invSz;
    for (Integer hash : inHash.keySet()) {
        final int[] AT = inHash.get(hash);
        final int A = AT[0], T = AT[1];
        final double Pcorr = (A + 1) / (T * P_AT + 1);
        final double P = Math.log(Pcorr);
        contribs.put(hash, P);
    }
    lowThresh = Double.POSITIVE_INFINITY;
    highThresh = Double.NEGATIVE_INFINITY;
    for (int[] fp : training) {
        double val = 0;
        for (int hash : fp) val += contribs.get(hash);
        lowThresh = Math.min(lowThresh, val);
        highThresh = Math.max(highThresh, val);
    }
    range = highThresh - lowThresh;
    invRange = range > 0 ? 1 / range : 0;
}",build,org/openscience/cdk/fingerprint/model/Bayesian.java,/tool/model/src/main/java/org/openscience/cdk/fingerprint/model/Bayesian.java,"/**
     * Performs that Bayesian model generation, using the {molecule:activity} pairs that have been submitted up to this
     * point. Once this method has finished, the object can be used to generate predictions, validation data or to
     * serialise for later use.
     */",223-263,"('build', {'INSTRUCTION': {'covered': 154, 'missed': 1}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 25, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",217.0,23.0,"Performs that Bayesian model generation, using the {molecule:activity} pairs that have been submitted up to this  point.","Using the molecule:activity pairs submited, it performs the Bayesian model generation. After calling this method, the object is able to generate predictions, validate data, or can be serialized for later execution.",The molecule:activity pairs that have been submitted up to this point are used to perform that model generation.,0.38303532828896,"Perform this Bayesian model generation, using the {molecule:activity} pairs that have been submitted so far."
327,cdk,"TextOutline positionHydrogenLabel(HydrogenPosition position, TextOutline element, TextOutline hydrogen){
    final Rectangle2D elementBounds = element.getBounds();
    final Rectangle2D hydrogenBounds = hydrogen.getBounds();
    switch(position) {
        case Above:
            return hydrogen.translate(0, (elementBounds.getMinY() - padding) - hydrogenBounds.getMaxY());
        case Right:
            return hydrogen.translate((elementBounds.getMaxX() + padding) - hydrogenBounds.getMinX(), 0);
        case Below:
            return hydrogen.translate(0, (elementBounds.getMaxY() + padding) - hydrogenBounds.getMinY());
        case Left:
            return hydrogen.translate((elementBounds.getMinX() - padding) - hydrogenBounds.getMaxX(), 0);
    }
    return hydrogen;
}",positionHydrogenLabel,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,"/**
     * Position the hydrogen label relative to the element label.
     *
     * @param position relative position where the hydrogen is placed
     * @param element  the outline of the element label
     * @param hydrogen the outline of the hydrogen
     * @return positioned hydrogen label
     */",438-460,"('positionHydrogenLabel', {'INSTRUCTION': {'covered': 59, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",151.0,10.0,Position the hydrogen label relative to the element label.,Compute the position of the hydrogen label relatetive the label of the element.,The hydrogen label should be placed relative to the element label.,0.14672351315642,Position the hydrogen label relative to the item label.
328,dcache,"void calcHashCode(){
    int code = 0;
    int elementCount = 0;
    for (String element : _elements) {
        int stringHash = 0;
        if (element == null) {
            stringHash = NULL_ELEMENT_HASH;
        } else {
            byte[] bytes = element.getBytes();
            int len = bytes.length > 10 ? 10 : bytes.length;
            for (int i = 0; i < len; i++) {
                stringHash ^= (bytes[i]) << (i * 5 + elementCount) % 24;
            }
        }
        code ^= stringHash;
        elementCount++;
    }
    _myHashCode = code;
    _haveHashCode = true;
}",calcHashCode,org/dcache/services/info/base/StatePath.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StatePath.java,"/**
     * Calculate the hash code and store it for later quick reference.
     */",104-132,"('calcHashCode', {'INSTRUCTION': {'covered': 68, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",121.0,12.0,Calculate the hash code and store it for later quick reference.,"Generate and store the hash code, that can be used for quick reference.",Store the code for later reference.,1.01497881433736,Calculate the hash code and store it for quick reference later.
329,cdk,"public boolean matches(IBond bond){
    bond = BondRef.deref(bond);
    if (bond instanceof PharmacophoreAngleBond) {
        PharmacophoreAngleBond pbond = (PharmacophoreAngleBond) bond;
        double bondLength = round(pbond.getBondLength(), 2);
        return bondLength >= lower && bondLength <= upper;
    } else
        return false;
}",matches,org/openscience/cdk/pharmacophore/PharmacophoreQueryAngleBond.java,/tool/pcore/src/main/java/org/openscience/cdk/pharmacophore/PharmacophoreQueryAngleBond.java,"/**
     * Checks whether the query angle constraint matches a target distance.
     * 
     * This method checks whether a query constraint is satisfied by an observed
     * angle (represented by a {@link org.openscience.cdk.pharmacophore.PharmacophoreAngleBond} in the target molecule.
     * Note that angles are compared upto 2 decimal places.
     *
     * @param bond The angle relationship in a target molecule
     * @return true if the target angle lies within the range of the query constraint
     */",85-104,"('matches', {'INSTRUCTION': {'covered': 29, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,11.0,Checks whether the query angle constraint matches a target distance.,The method returns true if the target angle is within the range of the query angle constraint.,The query angle constraint is checked to see if it matches the target distance.,0.316299927276104,Checks whether the query angle constraint matches a target distance.
331,cdk,"private void encodeExpr(int idx, int bprev, StringBuilder sb){
    avisit[idx] = numVisit++;
    sb.append(aexpr[idx]);
    final int d = deg[idx];
    int remain = d;
    for (int j = 0; j < d; j++) {
        int nbr = atomAdj[idx][j];
        int bidx = bondAdj[idx][j];
        if (rbnds[bidx] < 0) {
            final int rnum = chooseRingNumber();
            if (rnum > 9)
                sb.append('%');
            sb.append(rnum);
            rbnds[bidx] = rnum;
        } else if (rbnds[bidx] > 0) {
            final int rnum = rbnds[bidx];
            releaseRingNumber(rnum);
            if (rnum > 9)
                sb.append('%');
            sb.append(rnum);
        }
        if (mode == MODE_EXACT && avisit[nbr] == 0 || bidx == bprev || rbnds[bidx] != 0)
            remain--;
    }
    for (int j = 0; j < d; j++) {
        int nbr = atomAdj[idx][j];
        int bidx = bondAdj[idx][j];
        if (mode == MODE_EXACT && avisit[nbr] == 0 || bidx == bprev || rbnds[bidx] != 0)
            continue;
        remain--;
        if (avisit[nbr] == 0) {
            if (remain > 0)
                sb.append('(');
            sb.append(bexpr[bidx]);
            sb.append(mol.getAtom(nbr).isAromatic() ? 'a' : '*');
            if (remain > 0)
                sb.append(')');
        } else {
            if (remain > 0)
                sb.append('(');
            sb.append(bexpr[bidx]);
            encodeExpr(nbr, bidx, sb);
            if (remain > 0)
                sb.append(')');
        }
    }
}",encodeExpr,org/openscience/cdk/smarts/SmartsFragmentExtractor.java,/tool/smarts/src/main/java/org/openscience/cdk/smarts/SmartsFragmentExtractor.java,"/**
     * Recursively encodes a SMARTS expression into the provides
     * string builder.
     *
     * @param idx   atom index
     * @param bprev previous bond
     * @param sb    destition to write SMARTS to
     */",259-319,"('encodeExpr', {'INSTRUCTION': {'covered': 215, 'missed': 0}, 'BRANCH': {'covered': 40, 'missed': 0}, 'LINE': {'covered': 35, 'missed': 0}, 'COMPLEXITY': {'covered': 21, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",386.0,11.0,Recursively encodes a SMARTS expression into the provides  string builder.,"Given an atom index, recursively encode into a string builder a SMARTS expression.",The provides string builder has a SMARTS expression.,0.381159531182284,Recursively encodes a SMARTS expression in the provides string generator.
332,egeria,"public Optional<EntityDetail> findTopicEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, TOPIC_TYPE_NAME);
}",findTopicEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineTopicHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineTopicHandler.java,"/**
     * Find out if the Topic object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",98-114,"('findTopicEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,13.0,Find out if the Topic object is already stored in the repository.,"Discover whether the Topic object is already present in the repository, using the fully qualified name for retrieving the entity.","If the object is already in the repository, you should find it.",0.157903166321782,Find out if the Topic object is already stored in the repository.
333,jacoco-plugin,"private static Map<Type, Coverage> loadRatios(JacocoReportDir layout, String[] includes, String... excludes) throws IOException{
    Map<CoverageElement.Type, Coverage> ratios = new LinkedHashMap<>();
    ExecutionFileLoader efl = layout.parse(includes, excludes);
    IBundleCoverage bundleCoverage = efl.getBundleCoverage();
    if (bundleCoverage == null) {
        return null;
    }
    Coverage ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getClassCounter().getMissedCount(), bundleCoverage.getClassCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.CLASS, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getBranchCounter().getMissedCount(), bundleCoverage.getBranchCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.BRANCH, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getInstructionCounter().getMissedCount(), bundleCoverage.getInstructionCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.INSTRUCTION, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getMethodCounter().getMissedCount(), bundleCoverage.getMethodCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.METHOD, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getComplexityCounter().getMissedCount(), bundleCoverage.getComplexityCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.COMPLEXITY, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getLineCounter().getMissedCount(), bundleCoverage.getLineCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.LINE, ratio);
    return ratios;
}",loadRatios,hudson/plugins/jacoco/JacocoBuildAction.java,/src/main/java/hudson/plugins/jacoco/JacocoBuildAction.java,"/**
	 * Extracts top-level coverage information from the JaCoCo report document.
	 */",326-363,"('loadRatios', {'INSTRUCTION': {'covered': 120, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",349.0,10.0,Extracts top-level coverage information from the JaCoCo report document.,"Using the JaCoCo report, it finds the top-level converage information.",The JaCoCo report document has top-level coverage information.,0.302898450422585,Extracts high-level coverage information from the JaCoCo report document.
334,cdk,"public void addListener(IChemObjectListener col){
    List<IChemObjectListener> listeners = lazyChemObjectListeners();
    if (!listeners.contains(col)) {
        listeners.add(col);
    }
}",addListener,org/openscience/cdk/ChemObject.java,/base/data/src/main/java/org/openscience/cdk/ChemObject.java,"/**
     *  Use this to add yourself to this IChemObject as a listener. In order to do
     *  so, you must implement the ChemObjectListener Interface.
     *
     *@param  col  the ChemObjectListener
     *@see         #removeListener
     */",119-135,"('addListener', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,12.0,Use this to add yourself to this IChemObject as a listener.,Add yourself to the IChemObject as a listener but the ChemObjectListener interface must be implemented.,Add yourself to this IChem object.,0.137432359657595,Use it to add yourself to this IChemObject as a listener.
336,cdk,"public int parity(long[] current){
    int count = 0;
    for (int i = 0, n = indices.length; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int cmp = compare(current[indices[i]], current[indices[j]]);
            if (cmp == 0)
                return 0;
            else if (cmp > 0)
                count++;
        }
    }
    // value is odd, -1 or value is even +1
    return Integer.lowestOneBit(count) == 1 ? -1 : +1;
}",parity,org/openscience/cdk/hash/stereo/BasicPermutationParity.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/BasicPermutationParity.java,"/**
     * The number values to check is typically small ({@literal < 5}) and thus
     * we use brute-force to count the number of inversions.
     *
     *{@inheritDoc}
     */",55-77,"('parity', {'INSTRUCTION': {'covered': 51, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",113.0,28.0,The number values to check is typically small ({@literal < 5}) and thus  we use brute-force to count the number of inversions.,"Counts the number of inversion using a brute-force procedure, sine the number values to check is in general small.",The number values to check are usually small and therefore we use brute- force to count the number of inversions.,0.514156185861105,The numerical values to be checked are usually small ({@literal < 5}) and so we use brute force to count the number of inversions.
337,egeria,"public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
        return false;
    }
    LogRecordRequestBody that = (LogRecordRequestBody) objectToCompare;
    return Objects.equals(getConnectorInstanceId(), that.getConnectorInstanceId()) && Objects.equals(getConnectionName(), that.getConnectionName()) && Objects.equals(getConnectorType(), that.getConnectorType()) && Objects.equals(getContextId(), that.getContextId()) && Objects.equals(getMessage(), that.getMessage());
}",equals,org/odpi/openmetadata/accessservices/assetconsumer/rest/LogRecordRequestBody.java,/open-metadata-implementation/access-services/asset-consumer/asset-consumer-api/src/main/java/org/odpi/openmetadata/accessservices/assetconsumer/rest/LogRecordRequestBody.java,"/**
     * Equals method that returns true if containing properties are the same.
     *
     * @param objectToCompare object to compare
     * @return boolean result of comparison
     */",186-209,"('equals', {'INSTRUCTION': {'covered': 51, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 5}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",125.0,12.0,Equals method that returns true if containing properties are the same.,It returns true if the containing properties are the same.,"If the properties are the same, the equal method returns true.",0.388343962593669,Equal method; returns true if the properties containing are identical.
338,cdk,"static boolean parse(String label, List<String> tokens){
    int i = 0;
    int len = label.length();
    while (i < len) {
        int st = i;
        int last;
        char c = label.charAt(i);
        // BRACKETS we treat as separate
        if (c == '(' || c == ')') {
            tokens.add(Character.toString(c));
            i++;
            // digits following closing brackets
            if (c == ')') {
                st = i;
                while (i < len && isDigit(c = label.charAt(i))) {
                    i++;
                }
                if (i > st)
                    tokens.add(label.substring(st, i));
            }
            continue;
        }
        // separators
        if (c == '/' || c == '·' || c == '.' || c == '•' || c == '=') {
            tokens.add(Character.toString(c));
            i++;
            int beg = i;
            while (i < label.length() && isDigit(label.charAt(i))) {
                i++;
            }
            if (i > beg)
                tokens.add(label.substring(beg, i));
            continue;
        }
        // SYMBOL Tokens
        // optional prefix o- m- p- etc.
        if ((last = findPrefix(PREFIX_TRIE, label, i, -1)) > 0) {
            i += (last - i);
        }
        final int symSt = i;
        // a valid symbol token
        if ((last = findPrefix(SYMBOL_TRIE, label, i, -1)) > 0) {
            i += (last - i);
            // an optional number suffix e.g. O2 F3 Ph3 etc.
            while (i < len && isDigit(label.charAt(i))) {
                i++;
            }
        } else // a charge token, only if it's after some other parts
        if (i == st && st > 0) {
            c = norm(label.charAt(i));
            if (c == '-' || c == '+') {
                i++;
                while (i < len && isDigit(label.charAt(i))) {
                    i++;
                }
                // we expect charge at the end of the string.. if there is
                // still more it's not good input
                if (i < len) {
                    return failParse(label, tokens);
                }
            }
        }
        if (i == st || i == symSt) {
            return failParse(label, tokens);
        }
        tokens.add(label.substring(st, i));
    }
    return true;
}",parse,org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,"/**
     * Split a label it to recognised tokens for reversing, the
     * validity of the label is not checked! The method is intended
     * for zero/single attachments only and linkers are not supported.
     * 
     * 
     * Example: 
     * {@code NHCH2Ph -> N,H,C,H2,Ph -> reverse/join -> PhH2CHN}
     * 
     * 
     * 
     * The method return value signals whether formula
     * formatting (sub- and super- script) can be applied.
     *
     * @param label  abbreviation label
     * @param tokens the list of tokens from the input (n>0)
     * @return whether the label parsed okay (i.e. apply formatting)
     */",146-247,"('parse', {'INSTRUCTION': {'covered': 179, 'missed': 14}, 'BRANCH': {'covered': 46, 'missed': 10}, 'LINE': {'covered': 40, 'missed': 2}, 'COMPLEXITY': {'covered': 21, 'missed': 8}, 'METHOD': {'covered': 1, 'missed': 0}})",431.0,33.0,"Split a label it to recognised tokens for reversing, the  validity of the label is not checked! The method is intended  for zero/single attachments only and linkers are not supported.","Divide a label to find tokens for reversing, without checking the validity of the label. The method can be used if there is at most one attachment, without supporting the linkers.",The method is only for single attachment only and does not support linkers.,0.148063328194153,"Divide a label into recognized tokens to reverse it, the validity of the label is not verified! The method is for zero/single attachments only and linkers are not supported."
339,cdk,"public static IBioPolymer addAminoAcidAtCTerminus(IBioPolymer protein, IAminoAcid aaToAdd, IStrand strand, IAminoAcid aaToAddTo){
    addAminoAcid(protein, aaToAdd, strand);
    if ((protein.getMonomerCount() != 0) && (aaToAddTo != null)) {
        protein.addBond(aaToAdd.getBuilder().newInstance(IBond.class, aaToAddTo.getCTerminus(), aaToAdd.getNTerminus(), IBond.Order.SINGLE));
    }
    return protein;
}",addAminoAcidAtCTerminus,org/openscience/cdk/tools/ProteinBuilderTool.java,/storage/pdb/src/main/java/org/openscience/cdk/tools/ProteinBuilderTool.java,"/**
     * Builds a protein by connecting a new amino acid at the C-terminus of the
     * given strand. The acidic oxygen of the added amino acid is removed so that
     * additional amino acids can be added savely. But this also means that you
     * might want to add an oxygen at the end of the protein building!
     *
     * @param protein protein to which the strand belongs
     * @param aaToAdd amino acid to add to the strand of the protein
     * @param strand  strand to which the protein is added
     */",74-96,"('addAminoAcidAtCTerminus', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,17.0,Builds a protein by connecting a new amino acid at the C-terminus of the  given strand.,"Creates a protein connecting the new amino acid to the C-terminus, removing the acidic oxygen from the amino acid so that it can be added safely. You may want to add at the end of the protein an oxygen.",A new amino acid is connected to the C-terminus of the strand.,0.685385771620528,Builds a protein by connecting a new amino acid to the C termination of the given strand.
340,matsim-libs,"public static List<Link> findIntersectingLinks(Link link, final Network network){
    LineString segment = GeometryUtils.createGeotoolsLineString(link);
    return GeometryUtils.findIntersectingLinks(segment, network);
}",findIntersectingLinks,org/matsim/core/utils/geometry/GeometryUtils.java,/matsim/src/main/java/org/matsim/core/utils/geometry/GeometryUtils.java,"/**
	 * Method to find all links in {@link Network} that intersect a given {@link Link}.  Convenience method that
	 * only uses MATSim objects.
	 * 
	 * @param link
	 * @param network
	 * @return
	 */",55-66,"('findIntersectingLinks', {'INSTRUCTION': {'covered': 55, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,21.0,Method to find all links in {@link Network} that intersect a given {@link Link}.,"The method, that uses MATSim objects, find all the links in the Netwok that intersect the given Link.",The method to find links in the @link Network intersect a given one.,1.06597364492386,Method to search for all links in {@link Network} that cross a given {@link Link}.
341,sonar-cxx,"public static SourceFile scanSingleInputFile(InputFile inputFile, SquidAstVisitor<Grammar>... visitors){
    return scanSingleInputFileConfig(inputFile, new CxxSquidConfiguration(), visitors);
}",scanSingleInputFile,org/sonar/cxx/CxxAstScanner.java,/cxx-squid/src/main/java/org/sonar/cxx/CxxAstScanner.java,"/**
   * Helper method for testing checks without having to deploy them on a Sonar instance.
   *
   * @param inputFile is the file to be checked
   * @param visitors AST checks and visitors to use
   * @return file checked with measures and issues
   */",66-76,"('scanSingleInputFile', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,15.0,Helper method for testing checks without having to deploy them on a Sonar instance.,The method allows you to test checks without the deployment on Sonar instance.,The method is for testing checks without having to deploy them.,0.417191243386658,A helper method for testing checks without having to deploy them to a Sonar instance.
342,tablesaw,"public static IntColumn indexColumn(final String columnName, final int size, final int startsWith){
    final IntColumn indexColumn = IntColumn.create(columnName, size);
    for (int i = 0; i < size; i++) {
        indexColumn.set(i, i + startsWith);
    }
    return indexColumn;
}",indexColumn,tech/tablesaw/api/IntColumn.java,/core/src/main/java/tech/tablesaw/api/IntColumn.java,"/**
   * Returns a new numeric column initialized with the given name and size. The values in the column
   * are integers beginning at startsWith and continuing through size (exclusive), monotonically
   * increasing by 1 TODO consider a generic fill function including steps or random samples from
   * various distributions
   */",71-84,"('indexColumn', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",62.0,13.0,Returns a new numeric column initialized with the given name and size.,"Creates a new numeric column with the specified name and size, inserting values that beginning at startsWith and continuing through the size.",The new column is initialized with the given size and name.,0.191660446220208,Returns a new numeric column initialized with the given name and size.
343,weblogic-kubernetes-operator," static boolean checkUpdateDynamicClusterSizeJsonResult(String jsonResult){
    final String expectedResult = ""{}"";
    boolean result = false;
    if (expectedResult.equals(jsonResult)) {
        result = true;
    }
    return result;
}",checkUpdateDynamicClusterSizeJsonResult,oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,"/**
   * Checks the JSON result from the dynamic cluster size update REST request.
   *
   * @param jsonResult The JSON String result from the dynamic server cluster size update REST
   *     request
   * @return true if the result means the update was successful, false otherwise
   */",118-133,"('checkUpdateDynamicClusterSizeJsonResult', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,13.0,Checks the JSON result from the dynamic cluster size update REST request.,"Returns true if the update to the REST request, done usiing a JSON file from a dynamic cluster, was successful, false otherwise",The result of the dynamic cluster size update is checked.,0.304511585002596,Verifies the JSON result of the dynamic update REST request for the cluster size.
344,cdk,"int intType(final String sym){
    Integer intType = typeMap.get(sym);
    if (intType == null) {
        return 0;
    }
    return intType;
}",intType,org/openscience/cdk/forcefield/mmff/MmffParamSet.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffParamSet.java,"/**
     * Obtain the integer MMFF atom type for a given symbolic MMFF type.
     *
     * @param sym Symbolic MMFF type
     * @return integer MMFF type
     */",92-104,"('intType', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,13.0,Obtain the integer MMFF atom type for a given symbolic MMFF type.,"Starting from a given symbolic MMFF type, return the integer MMFF atom type.",Obtain the MMFF atom type for a symbolic MMFF type.,0.538384973450306,Get the whole MMFF atom type for a given symbolic MMFF type.
345,weblogic-kubernetes-operator,"boolean deleteServerServiceFromEvent(String serverName, V1Service event){
    if (serverName == null) {
        return false;
    }
    V1Service deletedService = getSko(serverName).getService().getAndAccumulate(event, this::getNewerCurrentOrNull);
    return deletedService != null;
}",deleteServerServiceFromEvent,oracle/kubernetes/operator/helpers/DomainPresenceInfo.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/DomainPresenceInfo.java,"/**
   * Given the service associated with a server service-deleted event, removes the service if it is
   * not older than the one recorded.
   *
   * @param serverName the name of the associated server
   * @param event the service associated with the event
   * @return true if the service was actually removed
   */",379-394,"('deleteServerServiceFromEvent', {'INSTRUCTION': {'covered': 18, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,23.0,"Given the service associated with a server service-deleted event, removes the service if it is  not older than the one recorded.","If the service associated with a server service-deleted event is not older than the one that has been recorded, remove it.","If the service is older than the one recorded, it is removed.",0.190836588382327,"Given the service associated with an event removed from the server service, deletes the service if it is not older than the registered service."
346,cdk,"public DescriptorValue calculate(IAtomContainer mol){
    if (checkRingSystem)
        Cycles.markRingAtomsAndBonds(mol);
    IAtomContainer aliphaticParts = mol.getBuilder().newAtomContainer();
    for (IAtom atom : mol.atoms()) {
        if (isAcyclicCarbon(atom))
            aliphaticParts.addAtom(atom);
    }
    for (IBond bond : mol.bonds()) {
        if (isAcyclicCarbon(bond.getBegin()) && isAcyclicCarbon(bond.getEnd()))
            aliphaticParts.addBond(bond);
    }
    int longest = 0;
    final int[][] adjlist = GraphUtil.toAdjList(aliphaticParts);
    for (int i = 0; i < adjlist.length; i++) {
        if (adjlist[i].length != 1)
            continue;
        int length = getMaxDepth(adjlist, i, -1);
        if (length > longest)
            longest = length;
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(longest), getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/LongestAliphaticChainDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/LongestAliphaticChainDescriptor.java,"/**
     * Calculate the count of atoms of the longest aliphatic chain in the supplied {@link IAtomContainer}.
     * <p>
     * The method require one parameter:
     * if checkRingSyste is true the CDKConstant.ISINRING will be set
     *
     * @param mol The {@link IAtomContainer} for which this descriptor is to be calculated
     * @return the number of atoms in the longest aliphatic chain of this AtomContainer
     * @see #setParameters
     */",166-209,"('calculate', {'INSTRUCTION': {'covered': 97, 'missed': 0}, 'BRANCH': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",201.0,19.0,Calculate the count of atoms of the longest aliphatic chain in the supplied {@link IAtomContainer}.,"Given a IAtomContainer, it computes the highest number of atoms of the longest aliphatic chain.",The supplied IAtomContainer has a count of atoms of the longest aliphatic chain.,0.401325297400462,Calculate the number of atoms of the longest aliphatic chain in the provided {@link IAtomContainer}.
347,cdk,"public static CDKRGraph buildRGraph(IAtomContainer sourceGraph, IAtomContainer targetGraph, boolean shouldMatchBonds) throws CDKException{
    CDKRGraph rGraph = new CDKRGraph();
    nodeConstructor(rGraph, sourceGraph, targetGraph, shouldMatchBonds);
    arcConstructor(rGraph, sourceGraph, targetGraph);
    return rGraph;
}",buildRGraph,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,"/**
     * Builds the CDKRGraph ( resolution graph ), from two atomContainer
     * (description of the two molecules to compare)
     * This is the interface point between the CDK model and
     * the generic MCSS algorithm based on the RGRaph.
     *
     * @param  sourceGraph  Description of the first molecule
     * @param  targetGraph  Description of the second molecule
     * @param shouldMatchBonds
     * @return     the rGraph
     * @throws CDKException
     */",437-455,"('buildRGraph', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",49.0,39.0,"Builds the CDKRGraph ( resolution graph ), from two atomContainer  (description of the two molecules to compare)  This is the interface point between the CDK model and  the generic MCSS algorithm based on the RGRaph.",Starting from to atomContainer build the resolution graph CDKRGraph.,The interface point between the CDK model and the generic MCSS algorithm is built from two atomContainers.,0.555313444624081,"Builds the CDKRGraph (resolution graph), from two atomContainer (description of the two molecules to be compared) This is the interface point between the CDK model and the generic MCSS algorithm based on the RGRaph."
348,cdk,"public int indexOf(Object o){
    IAtomContainer atomContainer = (IAtomContainer) o;
    if (!atomContainer.getTitle().equals(title))
        return -1;
    if (atomContainer.getAtomCount() != this.atomContainer.getAtomCount())
        return -1;
    boolean coordsMatch;
    int index = 0;
    for (Point3d[] coords : coordinates) {
        coordsMatch = true;
        for (int i = 0; i < atomContainer.getAtomCount(); i++) {
            Point3d p = atomContainer.getAtom(i).getPoint3d();
            if (!(p.x == coords[i].x && p.y == coords[i].y && p.z == coords[i].z)) {
                coordsMatch = false;
                break;
            }
        }
        if (coordsMatch)
            return index;
        index++;
    }
    return -1;
}",indexOf,org/openscience/cdk/ConformerContainer.java,/base/data/src/main/java/org/openscience/cdk/ConformerContainer.java,"/**
     * Returns the lowest index at which the specific IAtomContainer appears in the list or -1 if is not found.
     * 
     * A given IAtomContainer will occur in the list if the title matches the stored title for
     * the conformers in this container and if the coordinates for each atom in the specified molecule
     * are equal to the coordinates of the corresponding atoms in a conformer.
     *
     * @param o The IAtomContainer whose presence is being tested
     * @return The index where o was found
     */",366-398,"('indexOf', {'INSTRUCTION': {'covered': 78, 'missed': 4}, 'BRANCH': {'covered': 12, 'missed': 4}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",172.0,20.0,Returns the lowest index at which the specific IAtomContainer appears in the list or -1 if is not found.,"Given an IAtomContainer, returns the lowest index of appearence of that atom or -1 if the atom is not present","If the IAtomContainer is not found, the lowest index will be -1.",0.283459770170359,Returns the lowest index at which the specific IAtomContainer appears in the list or -1 if it cannot be found.
350,cdk,"private String cansmi(IAtomContainer mol, int[] ordering) throws CDKException{
    Integer[] hcntBackup = new Integer[mol.getAtomCount()];
    Map<IAtom, Integer> idxs = new HashMap<>();
    for (int i = 0; i < mol.getAtomCount(); i++) {
        hcntBackup[i] = mol.getAtom(i).getImplicitHydrogenCount();
        idxs.put(mol.getAtom(i), i);
    }
    int[] bondedValence = new int[mol.getAtomCount()];
    for (int i = 0; i < mol.getBondCount(); i++) {
        IBond bond = mol.getBond(i);
        bondedValence[idxs.get(bond.getBegin())] += bond.getOrder().numeric();
        bondedValence[idxs.get(bond.getEnd())] += bond.getOrder().numeric();
    }
    for (int i = 0; i < mol.getAtomCount(); i++) {
        IAtom atom = mol.getAtom(i);
        atom.setImplicitHydrogenCount(0);
        switch(atom.getAtomicNumber()) {
            case 5:
                if (bondedValence[i] <= 3)
                    atom.setImplicitHydrogenCount(3 - bondedValence[i]);
                break;
            case 6:
                if (bondedValence[i] <= 4)
                    atom.setImplicitHydrogenCount(4 - bondedValence[i]);
                break;
            case 7:
            case 15:
                if (bondedValence[i] <= 3)
                    atom.setImplicitHydrogenCount(3 - bondedValence[i]);
                else if (bondedValence[i] <= 5)
                    atom.setImplicitHydrogenCount(5 - bondedValence[i]);
                break;
            case 8:
                if (bondedValence[i] <= 2)
                    atom.setImplicitHydrogenCount(2 - bondedValence[i]);
                break;
            case 16:
                if (bondedValence[i] <= 2)
                    atom.setImplicitHydrogenCount(2 - bondedValence[i]);
                else if (bondedValence[i] <= 4)
                    atom.setImplicitHydrogenCount(4 - bondedValence[i]);
                else if (bondedValence[i] <= 6)
                    atom.setImplicitHydrogenCount(6 - bondedValence[i]);
                break;
            case 9:
            case 17:
            case 35:
            case 53:
                if (bondedValence[i] <= 1)
                    atom.setImplicitHydrogenCount(1 - bondedValence[i]);
                break;
            default:
                atom.setImplicitHydrogenCount(0);
                break;
        }
    }
    String smi = null;
    try {
        smi = smigen.create(mol, ordering);
    } finally {
        for (int i = 0; i < mol.getAtomCount(); i++) mol.getAtom(i).setImplicitHydrogenCount(hcntBackup[i]);
    }
    return smi;
}",cansmi,org/openscience/cdk/layout/IdentityTemplateLibrary.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/IdentityTemplateLibrary.java,"/**
     * Internal - create a canonical SMILES string temporarily adjusting to default
     * hydrogen count. This method may be moved to the SMILESGenerator in future.
     *
     * @param mol molecule
     * @param ordering ordering output
     * @return SMILES
     * @throws CDKException SMILES could be generate
     */",111-193,"('cansmi', {'INSTRUCTION': {'covered': 192, 'missed': 60}, 'BRANCH': {'covered': 18, 'missed': 15}, 'LINE': {'covered': 29, 'missed': 9}, 'COMPLEXITY': {'covered': 9, 'missed': 11}, 'METHOD': {'covered': 1, 'missed': 0}})",539.0,14.0,Internal - create a canonical SMILES string temporarily adjusting to default  hydrogen count.,The internal function creates a canonical SMILEY string after the adjustment of the hydrogen count.,The internal SMILES string temporarily adjusting to default hydrogen count.,0.389951683860561,Internal - create a canonical SMILES string that temporarily adjusts to the default hydrogen number.
351,cdk,"private static boolean queryAdjacencyAndOrder(IBond bond1, IBond bond2, IBond queryBond1, IBond queryBond2){
    IAtom centralAtom = null;
    IAtom centralQueryAtom = null;
    if (bond1.contains(bond2.getBegin())) {
        centralAtom = bond2.getBegin();
    } else if (bond1.contains(bond2.getEnd())) {
        centralAtom = bond2.getEnd();
    }
    if (queryBond1.contains(queryBond2.getBegin())) {
        centralQueryAtom = queryBond2.getBegin();
    } else if (queryBond1.contains(queryBond2.getEnd())) {
        centralQueryAtom = queryBond2.getEnd();
    }
    if (centralAtom != null && centralQueryAtom != null && ((IQueryAtom) centralQueryAtom).matches(centralAtom)) {
        IQueryAtom queryAtom1 = (IQueryAtom) queryBond1.getOther(centralQueryAtom);
        IQueryAtom queryAtom2 = (IQueryAtom) queryBond2.getOther(centralQueryAtom);
        IAtom atom1 = bond1.getOther(centralAtom);
        IAtom atom2 = bond2.getOther(centralAtom);
        if (queryAtom1.matches(atom1) && queryAtom2.matches(atom2) || queryAtom1.matches(atom2) && queryAtom2.matches(atom1)) {
            return true;
        } else {
            return false;
        }
    } else {
        return centralAtom == null && centralQueryAtom == null;
    }
}",queryAdjacencyAndOrder,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,"/**
     *  Determines if 2 bondA1 have 1 atom in common if second is atom query AtomContainer
     *  and wheter the order of the atoms is correct (atoms match).
     *
     * @param  bondA1  first bondA1
     * @param  bond2  second bondA1
     * @param queryBond1 first query bondA1
     * @param queryBond2 second query bondA1
     * @return    the symbol of the common atom or """" if the 2 bonds have no common atom
     */",966-1008,"('queryAdjacencyAndOrder', {'INSTRUCTION': {'covered': 89, 'missed': 4}, 'BRANCH': {'covered': 21, 'missed': 5}, 'LINE': {'covered': 19, 'missed': 1}, 'COMPLEXITY': {'covered': 10, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",246.0,29.0,Determines if 2 bondA1 have 1 atom in common if second is atom query AtomContainer  and wheter the order of the atoms is correct (atoms match).,"If two bondsA1 have an atom in common, return the atom or """" otherwise. It also returns if  the order of the atoms is correct.","If the second atom query is correct and the order of the atoms is correct, then the second bondA1 has 1 atom in common.",0.515923757632448,Determines whether 2 bondA1 have 1 atom in common if the second is atom query AtomContainer and the order of the atoms is correct (atom match).
352,acs-aem-commons,"private String replaceInString(String input, Map<String, Object> contentVariableReplacements){
    final List<String> keys = ContentVariableReplacementUtil.getKeys(input);
    for (String key : keys) {
        if (ContentVariableReplacementUtil.hasKey(contentVariableReplacements, key)) {
            String replaceValue = (String) ContentVariableReplacementUtil.getValue(contentVariableReplacements, key);
            input = ContentVariableReplacementUtil.doReplacement(input, key, replaceValue, propertyConfigService.getAction(key));
        }
    }
    return input;
}",replaceInString,com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,/bundle/src/main/java/com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,"/**
     * Reusable method to replace placeholders in the input string./
     *
     * @param input String input
     * @param contentVariableReplacements current map of content variables
     * @return The replaced or original String
     */",219-236,"('replaceInString', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,10.0,Reusable method to replace placeholders in the input string.,The function can replace placeholders in the input string.,The method is re-usable.,1.08896028615545,A reusable method for replacing placeholders in the input string.
353,metrics,"public void unregister(String name){
    HealthCheck healthCheck;
    synchronized (lock) {
        healthCheck = healthChecks.remove(name);
        if (healthCheck instanceof AsyncHealthCheckDecorator) {
            ((AsyncHealthCheckDecorator) healthCheck).tearDown();
        }
    }
    if (healthCheck != null) {
        onHealthCheckRemoved(name, healthCheck);
    }
}",unregister,io/dropwizard/metrics5/health/HealthCheckRegistry.java,/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/HealthCheckRegistry.java,"/**
     * Unregisters the application {@link HealthCheck} with the given name.
     *
     * @param name the name of the {@link HealthCheck} instance
     */",112-128,"('unregister', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,13.0,Unregisters the application {@link HealthCheck} with the given name.,"Given a name, unregisters the application HealthCheck that has that name.",The application is not registered with the given name.,0.159115782741925,Unregisters the application {@link HealthCheck} with the given name.
354,matsim-libs,"private static void createShipmentsFromServices(Carrier carrierWS, Carrier carrier){
    TreeMap<Id<CarrierService>, Id<Link>> depotServiceIsdeliveredFrom = new TreeMap<>();
    try {
        carrier.getSelectedPlan();
    } catch (Exception e) {
        throw new RuntimeException(""Carrier "" + carrier.getId() + "" has NO selectedPlan. --> CanNOT create a new carrier from solution"");
    }
    Collection<ScheduledTour> tours;
    try {
        tours = carrier.getSelectedPlan().getScheduledTours();
    } catch (Exception e) {
        throw new RuntimeException(""Carrier "" + carrier.getId() + "" has NO ScheduledTours. --> CanNOT create a new carrier from solution"");
    }
    for (ScheduledTour tour : tours) {
        Id<Link> depotForTour = tour.getVehicle().getLocation();
        for (TourElement te : tour.getTour().getTourElements()) {
            if (te instanceof ServiceActivity) {
                ServiceActivity act = (ServiceActivity) te;
                depotServiceIsdeliveredFrom.put(act.getService().getId(), depotForTour);
            }
        }
    }
    for (CarrierService carrierService : carrier.getServices().values()) {
        log.debug(""Converting CarrierService to CarrierShipment: "" + carrierService.getId());
        CarrierShipment carrierShipment = CarrierShipment.Builder.newInstance(Id.create(carrierService.getId().toString(), CarrierShipment.class), depotServiceIsdeliveredFrom.get(carrierService.getId()), carrierService.getLocationLinkId(), carrierService.getCapacityDemand()).setDeliveryServiceTime(carrierService.getServiceDuration()).setDeliveryTimeWindow(carrierService.getServiceStartTimeWindow()).setPickupTimeWindow(TimeWindow.newInstance(0.0, carrierService.getServiceStartTimeWindow().getEnd())).build();
        CarrierUtils.addShipment(carrierWS, carrierShipment);
    }
}",createShipmentsFromServices,org/matsim/contrib/freight/utils/FreightUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/utils/FreightUtils.java,"/**
	 * Transform all services from the existing carrier to the new carrier with
	 * shipments. The location of the depot from which the ""old"" carrier starts the
	 * tour to the service is used as fromLocation for the new Shipment.
	 *
	 * @param carrierWS the ""new"" carrier with Shipments
	 * @param carrier   the already existing carrier
	 */",264-308,"('createShipmentsFromServices', {'INSTRUCTION': {'covered': 105, 'missed': 16}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 26, 'missed': 4}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",316.0,14.0,Transform all services from the existing carrier to the new carrier with  shipments.,The function takes all services from the existing carrier and transform them with the shipment. The starting depot from the old carrier is used as fromLocatio for the new shipment.,All services should be transferred to the new carrier with shipments.,0.309582997409275,Transform all services from the existing carrier to the new carrier with shipments.
355,cdk,"void assign(IAtomContainer container, String[] symbs, EdgeToBondMap bonds, int[][] graph, Set<IBond> mmffArom){
    int[] contribution = new int[graph.length];
    int[] doubleBonds = new int[graph.length];
    Arrays.fill(doubleBonds, -1);
    setupContributionAndDoubleBonds(container, bonds, graph, contribution, doubleBonds);
    int[][] cycles = findAromaticRings(cyclesOfSizeFiveOrSix(container, graph), contribution, doubleBonds);
    for (int[] cycle : cycles) {
        int len = cycle.length - 1;
        if (len == 6) {
            updateAromaticTypesInSixMemberRing(cycle, symbs);
        }
        if (len == 5 && normaliseCycle(cycle, contribution)) {
            updateAromaticTypesInFiveMemberRing(cycle, symbs);
        }
        // mark aromatic bonds
        for (int i = 1; i < cycle.length; i++) mmffArom.add(bonds.get(cycle[i], cycle[i - 1]));
    }
}",assign,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,"/**
     * Given the assigned preliminary MMFF atom types (symbs[]) update these to the aromatic types.
     * To begin, all the 5 and 6 member aromatic cycles are discovered. The symbolic types of five
     * and six member cycles are then update with {@link #updateAromaticTypesInFiveMemberRing(int[],
     * String[])} and {@link #updateAromaticTypesInSixMemberRing(int[], String[])}.
     *
     * @param container structure representation
     * @param symbs     vector of symbolic types for the whole structure
     * @param bonds     edge to bond map lookup
     * @param graph     adjacency list graph representation of structure
     * @param mmffArom  set of bonds that are aromatic
     */",78-111,"('assign', {'INSTRUCTION': {'covered': 84, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",194.0,19.0,Given the assigned preliminary MMFF atom types (symbs[]) update these to the aromatic types.,"Given a preliminary MMFF atom types, update them to the aromatic ones. It starts finding the 5 and 6 member aromatic types, that are then updated with updateAromaticTypesInFiveMemberRing and updateAromaticTypesInSixMemberRing.",Update the MMFF atom types to the aromatic types.,0.58834253527078,"Given the assigned preliminary MMFF atom types (symbs[]), update them for aromatic types."
357,jackson-databind,"public static void closeOnFailAndThrowAsIOE(JsonGenerator g, Exception fail) throws IOException{
    g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);
    try {
        g.close();
    } catch (Exception e) {
        fail.addSuppressed(e);
    }
    throwIfIOE(fail);
    throwIfRTE(fail);
    throw new RuntimeException(fail);
}",closeOnFailAndThrowAsIOE,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * Helper method that encapsulate logic in trying to close output generator
     * in case of failure; useful mostly in forcing flush()ing as otherwise
     * error conditions tend to be hard to diagnose. However, it is often the
     * case that output state may be corrupt so we need to be prepared for
     * secondary exception without masking original one.
     *
     * @since 2.8
     */",480-504,"('closeOnFailAndThrowAsIOE', {'INSTRUCTION': {'covered': 25, 'missed': 8}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 4}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,35.0,Helper method that encapsulate logic in trying to close output generator  in case of failure; useful mostly in forcing flush()ing as otherwise  error conditions tend to be hard to diagnose.,The method encapsulates the logic when it tries to close the output generator if there is a failure. In that case it helps in forcing the flushing the error condition that are difficult to diagnose.,The method that helps in closing the output generator in case of failure is useful in forcing flush and other error conditions to be diagnosed.,0.607141068184654,"Assistive method that encapsulates the logic by trying to close the output generator in case of failure; useful mainly for forcing rinsing, because otherwise error conditions tend to be difficult to diagnose."
358,cdk,"private static IAtomContainer clearHydrogenCounts(IAtomContainer container){
    for (IAtom atom : container.atoms()) atom.setImplicitHydrogenCount(0);
    return container;
}",clearHydrogenCounts,org/openscience/cdk/layout/StructureDiagramGenerator.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/StructureDiagramGenerator.java,"/**
     * Simple helper function that sets all hydrogen counts to 0.
     *
     * @param container a structure representation
     * @return the input container
     */",1662-1672,"('clearHydrogenCounts', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,11.0,Simple helper function that sets all hydrogen counts to 0.,Resets to 0 all the counts of the hydrogen.,The function sets all hydrogen counts to 0.,0.691717655574184,Simple assistance function that sets all hydrogen counts to 0.
359,cdk,"public static String diff(IChemObject first, IChemObject second){
    IDifference diff = difference(first, second);
    if (diff == null) {
        return """";
    } else {
        return diff.toString();
    }
}",diff,org/openscience/cdk/tools/diff/AtomDiff.java,/misc/diff/src/main/java/org/openscience/cdk/tools/diff/AtomDiff.java,"/**
     * Compare two {@link IChemObject} classes and return the difference as a {@link String}.
     *
     * @param first  the first of the two classes to compare
     * @param second the second of the two classes to compare
     * @return a {@link String} representation of the difference between the first and second {@link IChemObject}.
     */",45-59,"('diff', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,20.0,Compare two {@link IChemObject} classes and return the difference as a {@link String}.,Returns the difference as a String between two IChemObject classes.,You can compare two classes and return a different result.,0.236781027046564,Compare two {@link IChemObject} classes and return the difference as a {@link String}.
360,cdk,"private static IAtom findPiBondedOxygen(IAtomContainer container, IAtom atom){
    for (IBond bond : container.getConnectedBondsList(atom)) {
        if (bond.getOrder() == IBond.Order.DOUBLE) {
            IAtom neighbor = bond.getOther(atom);
            int charge = neighbor.getFormalCharge() == null ? 0 : neighbor.getFormalCharge();
            if (neighbor.getAtomicNumber() == 8 && charge == 0)
                return neighbor;
        }
    }
    return null;
}",findPiBondedOxygen,org/openscience/cdk/graph/invariant/InChINumbersTools.java,/storage/inchi/src/main/java/org/openscience/cdk/graph/invariant/InChINumbersTools.java,"/**
     * Find a neutral oxygen bonded to the {@code atom} with a pi bond.
     *
     * @param container the container
     * @param atom      an atom from the container
     * @return a pi bonded oxygen (or null if not found)
     */",206-222,"('findPiBondedOxygen', {'INSTRUCTION': {'covered': 37, 'missed': 4}, 'BRANCH': {'covered': 6, 'missed': 4}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,17.0,Find a neutral oxygen bonded to the {@code atom} with a pi bond.,"Given the atom, return a pi bonded oxygen, or null if not found.",A neutral oxygen bond is found to the @code atom.,1.01572351097496,Find a neutral oxygen bound to the atom {@code} with a pi bond.
361,cdk,"private IChemFile readChemFile(IChemFile chemFile) throws CDKException{
    IChemSequence chemSequence = chemFile.getBuilder().newInstance(IChemSequence.class);
    IChemModel chemModel = chemFile.getBuilder().newInstance(IChemModel.class);
    chemSequence.addChemModel(readChemModel(chemModel));
    chemFile.addChemSequence(chemSequence);
    return chemFile;
}",readChemFile,org/openscience/cdk/io/MDLRXNReader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLRXNReader.java,"/**
    * Read a ChemFile from a file in MDL RDF format.
    *
    * @param  chemFile The IChemFile
    * @return          The IChemFile that was read from the RDF file.
    */",177-190,"('readChemFile', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",63.0,11.0,Read a ChemFile from a file in MDL RDF format.,"Using a file in MDL RDF format, read a ChemFile",The file is in MDL RDF format.,0.324081389857139,Read a ChemFile from a file in RDF MDL format.
362,metrics,"public void dump(OutputStream output){
    try (PrintWriter out = new PrintWriter(new OutputStreamWriter(output, UTF_8))) {
        for (long value : values) {
            out.printf(""%d%n"", value);
        }
    }
}",dump,io/dropwizard/metrics5/UniformSnapshot.java,/metrics-core/src/main/java/io/dropwizard/metrics5/UniformSnapshot.java,"/**
     * Writes the values of the snapshot to the given stream.
     *
     * @param output an output stream
     */",164-176,"('dump', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,11.0,Writes the values of the snapshot to the given stream.,"Given a stream, the method writes the values of the snapshot in that stream.",The values of the snapshot are written.,0.358793915122853,Writes the snapshot values to the given stream.
363,tablesaw,"StringColumn yearQuarter(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & quarter"");
    for (int r = 0; r < this.size(); r++) {
        int c1 = this.getIntInternal(r);
        if (DateColumn.valueIsMissing(c1)) {
            newColumn.appendMissing();
        } else {
            String yq = String.valueOf(PackedLocalDate.getYear(c1));
            yq = yq + ""-"" + Strings.padStart(String.valueOf(PackedLocalDate.getQuarter(c1)), 2, '0');
            newColumn.append(yq);
        }
    }
    return newColumn;
}",yearQuarter,tech/tablesaw/columns/dates/DateMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/dates/DateMapFunctions.java,"/**
   * Returns a StringColumn with the year and quarter from this column concatenated into a String
   * that will sort lexicographically in temporal order.
   *
   * <p>This simplifies the production of plots and tables that aggregate values into standard
   * temporal units (e.g., you want monthly data but your source data is more than a year long and
   * you don't want months from different years aggregated together).
   */",125-146,"('yearQuarter', {'INSTRUCTION': {'covered': 52, 'missed': 4}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",124.0,23.0,Returns a StringColumn with the year and quarter from this column concatenated into a String  that will sort lexicographically in temporal order.,Creates a StringColumn containing the year and the quarter and sort the column lexicographically in temporal order.,The year and quarter from this column will be used to sort the lexicographically in temporal order.,1.02300841287859,Returns a StringColumn with the year and quarter of this column concatenated into a String that will sort lexicographically in temporal order.
364,metrics,"public void tick(){
    final long count = uncounted.sumThenReset();
    final double instantRate = count / interval;
    if (initialized) {
        final double oldRate = this.rate;
        rate = oldRate + (alpha * (instantRate - oldRate));
    } else {
        rate = instantRate;
        initialized = true;
    }
}",tick,io/dropwizard/metrics5/EWMA.java,/metrics-core/src/main/java/io/dropwizard/metrics5/EWMA.java,"/**
     * Mark the passage of time and decay the current rate accordingly.
     */",84-97,"('tick', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",64.0,12.0,Mark the passage of time and decay the current rate accordingly.,The function marks the time passed and decrease the current rate.,The current rate should be decayd according to the passage of time.,0.520690025044074,Mark the passage of time and disrupt the current rate accordingly.
365,cdk,"static int[][] cyclesOfSizeFiveOrSix(IAtomContainer container, int[][] graph){
    try {
        return Cycles.all(6).find(container, graph, 6).paths();
    } catch (Intractable intractable) {
        return new int[0][];
    }
}",cyclesOfSizeFiveOrSix,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,"/**
     * Locate all 5 and 6 member cycles (rings) in a structure representation.
     *
     * @param container structure representation
     * @param graph     adjacency list graph representation of structure
     * @return closed walks (first = last vertex) of the cycles
     */",384-397,"('cyclesOfSizeFiveOrSix', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,15.0,Locate all 5 and 6 member cycles (rings) in a structure representation.,"It finds the 5 and 6 member cycles in the representation of the structure, called rings.",All 5 and 6 member cycles are in a structure representation.,0.487911270283485,Locate the cycles of 5 and 6 limbs (rings) in a structure representation.
366,shardingsphere-elasticjob,"public Map<String, String> toSingleValueMap(){
    return queryMap.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().get(0)));
}",toSingleValueMap,org/apache/shardingsphere/elasticjob/restful/wrapper/QueryParameterMap.java,/elasticjob-infra/elasticjob-restful/src/main/java/org/apache/shardingsphere/elasticjob/restful/wrapper/QueryParameterMap.java,"/**
     * Convert to a single value map, abandon values except the first of each parameter.
     *
     * @return single value map
     */",98-105,"('toSingleValueMap', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",50.0,16.0,"Convert to a single value map, abandon values except the first of each parameter.","Ignoring all the parameters but the first, convert them to a single value map.","Abandon values except the first one, if you want to convert to a single value map.",0.499489854916491,"Convert to a single value card, abandon the values except the first of each parameter."
367,cdk,"private static IChemModel newModel(final IAtomContainer container){
    if (container == null)
        throw new NullPointerException(""cannot create chem model for a null container"");
    final IChemObjectBuilder builder = container.getBuilder();
    final IChemModel model = builder.newInstance(IChemModel.class);
    final IAtomContainerSet containers = builder.newInstance(IAtomContainerSet.class);
    containers.addAtomContainer(container);
    model.setMoleculeSet(containers);
    return model;
}",newModel,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Create a new chem model for a single {@link IAtomContainer}.
     *
     * @param container the container to create the model for
     * @return a new {@link IChemModel}
     */",283-301,"('newModel', {'INSTRUCTION': {'covered': 27, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,14.0,Create a new chem model for a single {@link IAtomContainer}.,"For the given IAtomContainer, create a new chem model.",A single CHEM model for a single IAtomContainer is needed.,0.285831928196952,Create a chemical template for a single {@link IAtomContainer}.
368,cdk,"private int otherIndex(int i){
    IDoubleBondStereochemistry element = (IDoubleBondStereochemistry) queryElements[i];
    return queryMap.get(element.getStereoBond().getOther(query.getAtom(i)));
}",otherIndex,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,"/**
     * Given an index of an atom in the query get the index of the other atom in
     * the double bond.
     *
     * @param i query atom index
     * @return the other atom index involved in a double bond
     */",326-336,"('otherIndex', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",42.0,21.0,Given an index of an atom in the query get the index of the other atom in  the double bond.,"Returns the index of all the atoms in the double bond, starting from the index of an atom in the query.",The double bond's index of the other atom is given when you give an index of an atom.,0.545879831336274,"Given an index of one atom in the query, get the index of the other atom in the double bond."
369,cdk,"public Iterable<IIsotope> isotopes(){
    return new Iterable<IIsotope>() {

        @Override
        public Iterator<IIsotope> iterator() {
            return isotopesMax.keySet().iterator();
        }
    };
}",isotopes,org/openscience/cdk/formula/MolecularFormulaRange.java,/tool/formula/src/main/java/org/openscience/cdk/formula/MolecularFormulaRange.java,"/**
     *  Returns an Iterator for looping over all isotopes in this MolecularFormulaExpand.
     *
     * @return    An Iterator with the isotopes in this MolecularFormulaExpand
     */",157-170,"('isotopes', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,12.0,Returns an Iterator for looping over all isotopes in this MolecularFormulaExpand.,The function takes a MolecularFormulaExpand and returns an iterator for looping over all the isotopes.,The Iterator is used to loop over all the isotopes.,0.536296435966525,Returns an iterator for the loop over all isotopes in this MolecularFormulaExpand.
370,cdk,"public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
    if (factory == null)
        try {
            factory = AtomTypeFactory.getInstance(""org/openscience/cdk/config/data/jmol_atomtypes.txt"", ac.getBuilder());
        } catch (Exception exception) {
            return getDummyDescriptorValue(exception);
        }
    double atomicHardness;
    double radiusTarget;
    Iterator<IAtom> allAtoms = ac.atoms().iterator();
    atomicHardness = 0;
    double partial;
    double radius;
    String symbol;
    IAtomType type;
    try {
        symbol = atom.getSymbol();
        type = factory.getAtomType(symbol);
        radiusTarget = type.getCovalentRadius();
    } catch (Exception exception) {
        logger.debug(exception);
        return getDummyDescriptorValue(exception);
    }
    while (allAtoms.hasNext()) {
        IAtom curAtom = allAtoms.next();
        if (atom.getPoint3d() == null || curAtom.getPoint3d() == null) {
            return getDummyDescriptorValue(new CDKException(""The target atom or current atom had no 3D coordinates. These are required""));
        }
        if (!atom.equals(curAtom)) {
            partial = 0;
            symbol = curAtom.getSymbol();
            try {
                type = factory.getAtomType(symbol);
            } catch (Exception exception) {
                logger.debug(exception);
                return getDummyDescriptorValue(exception);
            }
            radius = type.getCovalentRadius();
            partial += radius * radius;
            partial += (radiusTarget * radiusTarget);
            partial = partial / (calculateSquareDistanceBetweenTwoAtoms(atom, curAtom));
            atomicHardness += partial;
        }
    }
    atomicHardness = 2 * atomicHardness;
    atomicHardness = atomicHardness * 0.172;
    atomicHardness = 1 / atomicHardness;
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(atomicHardness), NAMES);
}",calculate,org/openscience/cdk/qsar/descriptors/atomic/InductiveAtomicHardnessDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/InductiveAtomicHardnessDescriptor.java,"/**
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from
     *  the class tools.HydrogenAdder, and 3D coordinates.
     *
     *@param  atom              The IAtom for which the DescriptorValue is requested
     *@param  ac                AtomContainer
     *@return                   a double with polarizability of the heavy atom
     */",129-196,"('calculate', {'INSTRUCTION': {'covered': 112, 'missed': 28}, 'BRANCH': {'covered': 7, 'missed': 3}, 'LINE': {'covered': 28, 'missed': 9}, 'COMPLEXITY': {'covered': 3, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",322.0,13.0,It is needed to call the addExplicitHydrogensToSatisfyValency method from  the class tools.,"The function returns a double with polarizability of the heavy atom, needed for calling addExplicitHydrogensToSatisfyValency method.",The class tools have a method called the addExplicitHydrogensToSatisfyValency method.,0.469815085889578,It is necessary to call the addExplicitHydrogensToSatisfyValency method from the class tools.
372,cdk,"public void validateLeaveOneOut(){
    final int sz = training.size();
    estimates = new double[sz];
    for (int n = 0; n < sz; n++) estimates[n] = singleLeaveOneOut(n);
    calculateROC();
    rocType = ""leave-one-out"";
}",validateLeaveOneOut,org/openscience/cdk/fingerprint/model/Bayesian.java,/tool/model/src/main/java/org/openscience/cdk/fingerprint/model/Bayesian.java,"/**
     * Produces an ROC validation set, using the inputs provided prior to the model building, using leave-one-out. Note that
     * this should only be used for small datasets, since it is very thorough, and scales as O(N^2) relative to training set
     * size.
     */",315-327,"('validateLeaveOneOut', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",57.0,19.0,"Produces an ROC validation set, using the inputs provided prior to the model building, using leave-one-out.","Using the leave-one-out approach onhte inputs provided before the model creation, produces a ROC validaton set. Since it scales O(N^2), it should be used on small datasets.",The ROC validation set is produced using inputs provided prior to the model building.,0.240977764676658,"Produces an OCR validation set, using the inputs provided before the model was built, using the leave it aside."
373,twilio-java,"public String create(List<String> sortedIncludedHeaders){
    // Add the method and uri
    StringBuilder canonicalRequest = new StringBuilder();
    canonicalRequest.append(method).append(NEW_LINE);
    String canonicalUri = CANONICALIZE_PATH.apply(uri);
    canonicalRequest.append(canonicalUri).append(NEW_LINE);
    // Get the query args, replace whitespace and values that should be not encoded, sort and rejoin
    String canonicalQuery = CANONICALIZE_QUERY.apply(queryString);
    canonicalRequest.append(canonicalQuery).append(NEW_LINE);
    // Normalize all the headers
    Header[] normalizedHeaders = NORMALIZE_HEADERS.apply(headers);
    Map<String, List<String>> combinedHeaders = COMBINE_HEADERS.apply(normalizedHeaders);
    // Add the headers that we care about
    for (String header : sortedIncludedHeaders) {
        String lowercase = header.toLowerCase().trim();
        if (combinedHeaders.containsKey(lowercase)) {
            List<String> values = combinedHeaders.get(lowercase);
            Collections.sort(values);
            canonicalRequest.append(lowercase).append("":"").append(String.join("","", values)).append(NEW_LINE);
        }
    }
    canonicalRequest.append(NEW_LINE);
    // Mark the headers that we care about
    canonicalRequest.append(String.join("";"", sortedIncludedHeaders)).append(NEW_LINE);
    // Hash and hex the request payload
    if (requestBody != null && !requestBody.isEmpty()) {
        String hashedPayload = DigestUtils.sha256Hex(requestBody);
        canonicalRequest.append(hashedPayload);
    }
    return canonicalRequest.toString();
}",create,com/twilio/jwt/validation/RequestCanonicalizer.java,/src/main/java/com/twilio/jwt/validation/RequestCanonicalizer.java,"/**
     * Creates a canonical request string out of HTTP request components.
     *
     * @param sortedIncludedHeaders the headers that should be included into canonical request string
     * @return a string representing the canonical request
     */",44-90,"('create', {'INSTRUCTION': {'covered': 114, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",253.0,11.0,Creates a canonical request string out of HTTP request components.,"Starting from a HTTP request, it creates the canonical request string.",A string of request components is created.,0.734887903699347,Creates a canonical query string from the HTTP request components.
375,mybatis-3,"public ResolverUtil<T> findAnnotated(Class<? extends Annotation> annotation, String... packageNames){
    if (packageNames == null) {
        return this;
    }
    Test test = new AnnotatedWith(annotation);
    for (String pkg : packageNames) {
        find(test, pkg);
    }
    return this;
}",findAnnotated,org/apache/ibatis/io/ResolverUtil.java,/src/main/java/org/apache/ibatis/io/ResolverUtil.java,"/**
   * Attempts to discover classes that are annotated with the annotation. Accumulated
   * classes can be accessed by calling {@link #getClasses()}.
   *
   * @param annotation
   *          the annotation that should be present on matching classes
   * @param packageNames
   *          one or more package names to scan (including subpackages) for classes
   * @return the resolver util
   */",210-231,"('findAnnotated', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,11.0,Attempts to discover classes that are annotated with the annotation.,"Given an annotation, tries to discover all the classes that have that annotaion, that can be accessed using getClasses() method",Attempts to find classes that are annotated.,0.204634388269915,Attempts to discover classes annotated with annotation.
376,glowstone,"public void putCompoundList(@NonNls String key, List<CompoundTag> list){
    put(key, new ListTag<>(TagType.COMPOUND, list));
}",putCompoundList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Adds or replaces a list subtag with a list of compound tags.
     *
     * @param key the key to write to
     * @param list the list contents as compound tags
     */",947-955,"('putCompoundList', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,13.0,Adds or replaces a list subtag with a list of compound tags.,"Using a list of compound tags, the function adds or replaces a list of subtags.",A list subtag is added or replaced with a list of compound tags.,0.114138514497338,Adds or replaces a list subtag with a list of compound tags.
377,cdk,"public static int has2DCoordinatesNew(IAtomContainer container){
    if (container == null)
        return 0;
    boolean no2d = false;
    boolean with2d = false;
    for (IAtom atom : container.atoms()) {
        if (atom.getPoint2d() == null) {
            no2d = true;
        } else {
            with2d = true;
        }
    }
    if (!no2d && with2d) {
        return 2;
    } else if (no2d && with2d) {
        return 1;
    } else {
        return 0;
    }
}",has2DCoordinatesNew,org/openscience/cdk/geometry/GeometryTools.java,/legacy/src/main/java/org/openscience/cdk/geometry/GeometryTools.java,"/**
     *  Determines if this AtomContainer contains 2D coordinates for some or all molecules.
     *  See comment for center(IAtomContainer atomCon, Dimension areaDim, HashMap renderingCoordinates) for details on coordinate sets
     *
     *
     * @param container the molecule to be considered
     * @return    0 no 2d, 1=some, 2= for each atom
     * @deprecated use {@link #get2DCoordinateCoverage(org.openscience.cdk.interfaces.IAtomContainer)} for determining
     *             partial coordinates
     * @see #get2DCoordinateCoverage(org.openscience.cdk.interfaces.IAtomContainer)
     */",1020-1051,"('has2DCoordinatesNew', {'INSTRUCTION': {'covered': 40, 'missed': 2}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",95.0,13.0,Determines if this AtomContainer contains 2D coordinates for some or all molecules.,The function checks whether the AtomContainer contains 2D coordinates for some (or all) the molecules.,"If the AtomContainer contains 2D coordinates for some or all of the molecules, it's determined.",0.481839509837346,Determines whether this AtomContainer contains 2D coordinates for some or all of the molecules.
378,weblogic-kubernetes-operator,"public static List<V1EnvVar> createCopy(List<V1EnvVar> envVars){
    ArrayList<V1EnvVar> copy = new ArrayList<>();
    if (envVars != null) {
        for (V1EnvVar envVar : envVars) {
            copy.add(new V1EnvVarBuilder(envVar).build());
        }
    }
    return copy;
}",createCopy,oracle/kubernetes/operator/helpers/PodHelper.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/PodHelper.java,"/**
   * Create a copy of the list of V1EnvVar environment variables.
   *
   * @param envVars list of environment variables to copy
   * @return List containing a copy of the original list.
   */",263-280,"('createCopy', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",64.0,11.0,Create a copy of the list of V1EnvVar environment variables.,"Given a list of environment variables, generate a copy of that V1EnvVar list.",The list of V1EnvVar environment variables can be created.,0.525472721860478,Create a copy of the V1EnvVar environment variable list.
379,cdk,"public static IAtomContainer assign(final IAtomContainer container){
    GraphUtil.EdgeToBondMap edgeToBond = GraphUtil.EdgeToBondMap.withSpaceFor(container);
    new NonplanarBonds(container, GraphUtil.toAdjList(container, edgeToBond), edgeToBond);
    return container;
}",assign,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,"/**
     * Assign non-planar, up and down labels to indicate tetrahedral configuration. Currently all
     * existing directional labels are removed before assigning new labels.
     *
     * @param container the structure to assign labels to
     * @return a container with assigned labels (currently the same as the input)
     * @throws IllegalArgumentException an atom had no 2D coordinates or labels could not be
     *                                  assigned to a tetrahedral centre
     */",104-117,"('assign', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,12.0,"Assign non-planar, up and down labels to indicate tetrahedral configuration.","In order to indicate the tetrahedral configuration, remove all existing directional labels and assigns all the labels (non-planar, up and down)","The non-planar, up and down labels are used to indicate the configuration.",0.399620384516078,"Assign non-flat, up, and down labels to indicate the tetrahedral configuration."
380,cdk,"private void ensureDefaultOccurElements(IChemObjectBuilder builder){
    if (mfRange == null) {
        String[] elements = new String[] { ""C"", ""H"", ""O"", ""N"", ""Si"", ""P"", ""S"", ""F"", ""Cl"", ""Br"", ""I"", ""Sn"", ""B"", ""Pb"", ""Tl"", ""Ba"", ""In"", ""Pd"", ""Pt"", ""Os"", ""Ag"", ""Zr"", ""Se"", ""Zn"", ""Cu"", ""Ni"", ""Co"", ""Fe"", ""Cr"", ""Ti"", ""Ca"", ""K"", ""Al"", ""Mg"", ""Na"", ""Ce"", ""Hg"", ""Au"", ""Ir"", ""Re"", ""W"", ""Ta"", ""Hf"", ""Lu"", ""Yb"", ""Tm"", ""Er"", ""Ho"", ""Dy"", ""Tb"", ""Gd"", ""Eu"", ""Sm"", ""Pm"", ""Nd"", ""Pr"", ""La"", ""Cs"", ""Xe"", ""Te"", ""Sb"", ""Cd"", ""Rh"", ""Ru"", ""Tc"", ""Mo"", ""Nb"", ""Y"", ""Sr"", ""Rb"", ""Kr"", ""As"", ""Ge"", ""Ga"", ""Mn"", ""V"", ""Sc"", ""Ar"", ""Ne"", ""Be"", ""Li"", ""Tl"", ""Pb"", ""Bi"", ""Po"", ""At"", ""Rn"", ""Fr"", ""Ra"", ""Ac"", ""Th"", ""Pa"", ""U"", ""Np"", ""Pu"" };
        mfRange = new MolecularFormulaRange();
        for (int i = 0; i < elements.length; i++) mfRange.addIsotope(builder.newInstance(IIsotope.class, elements[i]), 0, 50);
    }
}",ensureDefaultOccurElements,org/openscience/cdk/formula/rules/ElementRule.java,/tool/formula/src/main/java/org/openscience/cdk/formula/rules/ElementRule.java,"/**
     * Initiate the MolecularFormulaExpand with the maximum and minimum occurrence of the Elements.
     * In this case all elements of the periodic table are loaded.
     */",128-145,"('ensureDefaultOccurElements', {'INSTRUCTION': {'covered': 417, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",264.0,13.0,Initiate the MolecularFormulaExpand with the maximum and minimum occurrence of the Elements.,"Given the MolecularFormulaExpand, the function sets the minimum and maximum occurrence of the Elements, loading them from the periodic table.",The maximum and minimum occurrence of the Elements are the things that should be initiated.,0.742548331833114,Launch molecularFormulaExpand with the maximum and minimum instance of the elements.
381,matsim-libs,"public void addSeries(final String title, final double[] xs, final double[] ys){
    XYSeries series = new XYSeries(title, false, true);
    for (int i = 0, n = Math.min(xs.length, ys.length); i < n; i++) {
        series.add(xs[i], ys[i]);
    }
    this.dataset.addSeries(series);
}",addSeries,org/matsim/core/utils/charts/XYScatterChart.java,/matsim/src/main/java/org/matsim/core/utils/charts/XYScatterChart.java,"/**
	 * Adds a new data series to the chart with the specified title.
	 * <code>xs<code> and <code>ys</code> should have the same length. If not,
	 * only as many items are shown as the shorter array contains.
	 * 
	 * @param title
	 * @param xs
	 *            The x values.
	 * @param ys
	 *            The y values.
	 */",80-98,"('addSeries', {'INSTRUCTION': {'covered': 33, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",90.0,13.0,Adds a new data series to the chart with the specified title.,"Given the title, adds the new series to the chart. Remember that <code>xs</code> and <code>ys</code> should have the same length (otherwise the exceeding elements will be ignored).",A new data series is added to the chart.,0.468578597523322,Adds a new data series to the chart with the specified title.
382,openapi-generator,"public static boolean isFreeFormObject(OpenAPI openAPI, Schema schema){
    if (schema == null) {
        once(LOGGER).error(""Schema cannot be null in isFreeFormObject check"");
        return false;
    }
    if (schema instanceof ComposedSchema) {
        ComposedSchema cs = (ComposedSchema) schema;
        List<Schema> interfaces = ModelUtils.getInterfaces(cs);
        if (interfaces != null && !interfaces.isEmpty()) {
            return false;
        }
    }
    if (""object"".equals(schema.getType())) {
        if ((schema.getProperties() == null || schema.getProperties().isEmpty())) {
            Schema addlProps = getAdditionalProperties(openAPI, schema);
            if (schema.getExtensions() != null && schema.getExtensions().containsKey(freeFormExplicit)) {
                boolean isFreeFormExplicit = Boolean.parseBoolean(String.valueOf(schema.getExtensions().get(freeFormExplicit)));
                if (!isFreeFormExplicit && addlProps != null && addlProps.getProperties() != null && !addlProps.getProperties().isEmpty()) {
                    once(LOGGER).error(String.format(Locale.ROOT, ""Potentially confusing usage of %s within model which defines additional properties"", freeFormExplicit));
                }
                return isFreeFormExplicit;
            }
            if (addlProps == null) {
                return true;
            } else {
                if (addlProps instanceof ObjectSchema) {
                    ObjectSchema objSchema = (ObjectSchema) addlProps;
                    if (objSchema.getProperties() == null || objSchema.getProperties().isEmpty()) {
                        return true;
                    }
                } else if (addlProps instanceof Schema) {
                    if (addlProps.getType() == null && addlProps.get$ref() == null && (addlProps.getProperties() == null || addlProps.getProperties().isEmpty())) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}",isFreeFormObject,org/openapitools/codegen/utils/ModelUtils.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ModelUtils.java,"/**
     * Check to see if the schema is a free form object.
     *
     * A free form object is an object (i.e. 'type: object' in a OAS document) that:
     * 1) Does not define properties, and
     * 2) Is not a composed schema (no anyOf, oneOf, allOf), and
     * 3) additionalproperties is not defined, or additionalproperties: true, or additionalproperties: {}.
     *
     * Examples:
     *
     * components:
     *   schemas:
     *     arbitraryObject:
     *       type: object
     *       description: This is a free-form object.
     *         The value must be a map of strings to values. The value cannot be 'null'.
     *         It cannot be array, string, integer, number.
     *     arbitraryNullableObject:
     *       type: object
     *       description: This is a free-form object.
     *         The value must be a map of strings to values. The value can be 'null',
     *         It cannot be array, string, integer, number.
     *       nullable: true
     *     arbitraryTypeValue:
     *       description: This is NOT a free-form object.
     *         The value can be any type except the 'null' value.
     *
     * @param openAPI the object that encapsulates the OAS document.
     * @param schema potentially containing a '$ref'
     * @return true if it's a free-form object
     */",753-836,"('isFreeFormObject', {'INSTRUCTION': {'covered': 97, 'missed': 23}, 'BRANCH': {'covered': 33, 'missed': 11}, 'LINE': {'covered': 25, 'missed': 1}, 'COMPLEXITY': {'covered': 15, 'missed': 8}, 'METHOD': {'covered': 1, 'missed': 0}})",341.0,12.0,Check to see if the schema is a free form object.,"check the schema to see if it is a free form object, so it does not define properties, it is not a composed scheama and does not define the additionalproperty","If the schema is a free form object, you should check it.",0.507955093875062,Check if the schema is a freeform object.
383,cdk,"private IMolecularFormulaSet returnOrdered(double mass, IMolecularFormulaSet formulaSet){
    IMolecularFormulaSet solutions_new = null;
    if (formulaSet.size() != 0) {
        double valueMin = 100;
        int i_final = 0;
        solutions_new = formulaSet.getBuilder().newInstance(IMolecularFormulaSet.class);
        List<Integer> listI = new ArrayList<Integer>();
        for (int j = 0; j < formulaSet.size(); j++) {
            for (int i = 0; i < formulaSet.size(); i++) {
                if (listI.contains(i))
                    continue;
                double value = MolecularFormulaManipulator.getTotalExactMass(formulaSet.getMolecularFormula(i));
                double diff = Math.abs(mass - Math.abs(value));
                if (valueMin > diff) {
                    valueMin = diff;
                    i_final = i;
                }
            }
            valueMin = 100;
            solutions_new.addMolecularFormula(formulaSet.getMolecularFormula(i_final));
            listI.add(i_final);
        }
    }
    return solutions_new;
}",returnOrdered,org/openscience/cdk/formula/MassToFormulaTool.java,/legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java,"/**
     * Return all molecular formulas but ordered according the tolerance difference between masses.
     *
     * @param  mass        The mass to analyze
     * @param  formulaSet  The IMolecularFormulaSet to order
     * @return             The IMolecularFormulaSet ordered
     */",538-573,"('returnOrdered', {'INSTRUCTION': {'covered': 76, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",193.0,13.0,Return all molecular formulas but ordered according the tolerance difference between masses.,Order the molecular formulas using the tolerance difference between the masses,Return all formulas but order them according to the tolerance difference.,0.312967099220703,Return all molecular formulas but ordered according to the tolerance difference between the masses.
384,cdk,"static int contribution(int elem, int x, int v){
    switch(elem) {
        case 6:
            if (x == 3 && v == 4)
                return 1;
            break;
        case 7:
            if (x == 2 && v == 3)
                return 1;
            if (x == 3 && v == 4)
                return 1;
            if (x == 3 && v == 3)
                return 2;
            if (x == 2 && v == 2)
                return 2;
            break;
        case 8:
        case 16:
            if (x == 2 && v == 2)
                return 2;
            break;
    }
    return -1;
}",contribution,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,"/**
     * Electron contribution of an element with the specified connectivity and valence.
     *
     * @param elem atomic number
     * @param x    connectivity
     * @param v    bonded valence
     * @return p electrons
     */",355-382,"('contribution', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'BRANCH': {'covered': 28, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 16, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",121.0,12.0,Electron contribution of an element with the specified connectivity and valence.,It returns the contribution of an electron with the defined connectivity and valence.,The element has a specified electron contribution.,0.531232650644111,Electronic contribution of an element with the specified connectivity and valence.
385,openapi-generator,"public static boolean isNullType(Schema schema){
    if (""null"".equals(schema.getType())) {
        return true;
    }
    return false;
}",isNullType,org/openapitools/codegen/utils/ModelUtils.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ModelUtils.java,"/**
     * isNullType returns true if the input schema is the 'null' type.
     *
     * The 'null' type is supported in OAS 3.1 and above. It is not supported
     * in OAS 2.0 and OAS 3.0.x.
     *
     * For example, the ""null"" type could be used to specify that a value must
     * either be null or a specified type:
     *
     * OptionalOrder:
     *   oneOf:
     *     - type: 'null'
     *     - $ref: '#/components/schemas/Order'
     *
     * @param schema the OpenAPI schema
     * @return true if the schema is the 'null' type
     */",1481-1503,"('isNullType', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,13.0,isNullType returns true if the input schema is the 'null' type.,The function returns true if the schema of the input fulfill the 'null' type.,"If the input is a null type, isNullType returns true.",0.635784208155832,isNullType returns true if the input schema is of type 'null'.
386,acs-aem-commons,"private boolean shouldProcess(String urlPath){
    // If includes are specified but none are valid we skip all requests.
    if (allInvalidIncludes) {
        LOG.debug(""Include patterns are empty due to invalid regex patterns, not processing any requests"");
        return false;
    }
    // If include and exclude lists are both empty we process all requests.
    if (includePatterns.isEmpty() && excludePatterns.isEmpty()) {
        LOG.debug(""Include and Exclude patterns are empty, processing all requests"");
        return true;
    }
    boolean shouldProcess = false;
    for (Pattern pattern : includePatterns) {
        if (pattern.matcher(urlPath).matches()) {
            LOG.debug(""URL path {} matches INCLUDE pattern {}"", urlPath, pattern.toString());
            shouldProcess = true;
            break;
        }
    }
    for (Pattern pattern : excludePatterns) {
        if (pattern.matcher(urlPath).matches()) {
            LOG.debug(""URL path {} matches EXCLUDE pattern {}"", urlPath, pattern.toString());
            shouldProcess = false;
            break;
        }
    }
    LOG.debug(""URL path {} is processed: {}"", urlPath, shouldProcess);
    return shouldProcess;
}",shouldProcess,com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,/bundle/src/main/java/com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,"/**
     * Checks the current URL path against the included and excluded patterns. Exclusions hold priority.
     *
     * @param urlPath Current request path
     * @return if the request should be processed
     */",122-156,"('shouldProcess', {'INSTRUCTION': {'covered': 81, 'missed': 2}, 'BRANCH': {'covered': 10, 'missed': 4}, 'LINE': {'covered': 19, 'missed': 2}, 'COMPLEXITY': {'covered': 4, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",160.0,12.0,Checks the current URL path against the included and excluded patterns.,"Giving priority to the exclusion patterns, check the current URL path agains included and excluded patterns.",The current URL path is checked against the included and excluded patterns.,0.346607690995069,Checks the current URL path against the included and excluded templates.
387,egeria,"private void processDeclassifiedEntityEvent(EntityDetail entityDetail) throws OCFCheckedExceptionBase, JsonProcessingException{
    if (!immutableValidLineageEntityEvents.contains(entityDetail.getType().getTypeDefName())) {
        return;
    }
    log.debug(PROCESSING_ENTITY_DETAIL_DEBUG_MESSAGE, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT.getEventTypeName(), entityDetail.getGUID(), entityDetail.getType().getTypeDefName());
    if (anyLineageClassificationsLeft(entityDetail)) {
        publisher.publishClassificationContext(entityDetail, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT);
        return;
    }
    publishEntityEvent(entityDetail, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT);
}",processDeclassifiedEntityEvent,org/odpi/openmetadata/accessservices/assetlineage/listeners/AssetLineageOMRSTopicListener.java,/open-metadata-implementation/access-services/asset-lineage/asset-lineage-server/src/main/java/org/odpi/openmetadata/accessservices/assetlineage/listeners/AssetLineageOMRSTopicListener.java,"/**
     * Process De-Classified Entity event for lineage entity
     * The entity context is published if there is no lineage classification left.
     * The Classification Context event is sent if there are lineage classifications available on lineage entity.
     *
     * @param entityDetail the entity object that contains a classification that has been deleted
     *
     * @throws OCFCheckedExceptionBase unable to send the event due to connectivity issue
     * @throws JsonProcessingException exception parsing the event json
     */",269-293,"('processDeclassifiedEntityEvent', {'INSTRUCTION': {'covered': 43, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",97.0,20.0,Process De-Classified Entity event for lineage entity  The entity context is published if there is no lineage classification left.,Process the event of the De-Classified Entity for lineage entity; the context will be published if all the lineage classification are done. The context event is sent if the lineage entity has lineage classification available.,"If there is no classification left, the entity context is published.",0.376279899317992,Process declassified entity event for lineage entity The entity context is published if there is no lineage classification left.
388,liquibase,"protected void printHelp(List<String> errorMessages, PrintStream stream){
    stream.println(coreBundle.getString(""errors""));
    for (String message : errorMessages) {
        stream.println(""  "" + message);
    }
    stream.println();
}",printHelp,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,"/**
     * If any errors have been found, print the list of errors first, then print the command line help text.
     *
     * @param errorMessages List of error messages
     * @param stream        the output stream to write the text to
     */",1143-1155,"('printHelp', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,22.0,"If any errors have been found, print the list of errors first, then print the command line help text.","If there are errors, it prints the list of errors followed by the help text.","If there are any errors, you should print the list and then the help text.",0.160908969678521,"If errors were detected, first print the list of errors, and then print the help text from the command line."
389,glowstone,"public static boolean hasMoved(Location first, Location second){
    return first.getX() != second.getX() || first.getY() != second.getY() || first.getZ() != second.getZ();
}",hasMoved,net/glowstone/util/Position.java,/src/main/java/net/glowstone/util/Position.java,"/**
     * Gets whether there has been a position change between the two Locations.
     *
     * @param first The initial location.
     * @param second The final location.
     * @return A boolean.
     */",76-86,"('hasMoved', {'INSTRUCTION': {'covered': 20, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",50.0,13.0,Gets whether there has been a position change between the two Locations.,Return true if between two locations there has been a change in the position.,Does it mean there has been a position change between the two locations?,0.232918435079785,Gets whether a position change occurred between the two locations.
390,cdk,"public void calculate(IAtomContainer mol) throws CDKException{
    this.mol = mol;
    fplist.clear();
    atomClass = classType <= CLASS_ECFP6 ? ATOMCLASS_ECFP : ATOMCLASS_FCFP;
    excavateMolecule();
    if (atomClass == ATOMCLASS_FCFP)
        calculateBioTypes();
    final int na = mol.getAtomCount();
    identity = new int[na];
    resolvedChiral = new boolean[na];
    atomGroup = new int[na][];
    for (int n = 0; n < na; n++) if (amask[n]) {
        if (atomClass == ATOMCLASS_ECFP)
            identity[n] = initialIdentityECFP(n);
        else
            identity[n] = initialIdentityFCFP(n);
        atomGroup[n] = new int[] { n };
        fplist.add(new FP(identity[n], 0, atomGroup[n]));
    }
    int niter = classType == CLASS_ECFP2 || classType == CLASS_FCFP2 ? 1 : classType == CLASS_ECFP4 || classType == CLASS_FCFP4 ? 2 : classType == CLASS_ECFP6 || classType == CLASS_FCFP6 ? 3 : 0;
    for (int iter = 1; iter <= niter; iter++) {
        final int[] newident = new int[na];
        for (int n = 0; n < na; n++) if (amask[n])
            newident[n] = circularIterate(iter, n);
        identity = newident;
        for (int n = 0; n < na; n++) if (amask[n]) {
            atomGroup[n] = growAtoms(atomGroup[n]);
            considerNewFP(new FP(identity[n], iter, atomGroup[n]));
        }
    }
}",calculate,org/openscience/cdk/fingerprint/CircularFingerprinter.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/CircularFingerprinter.java,"/**
     * Calculates the fingerprints for the given {@link IAtomContainer}, and stores them for subsequent retrieval.
     *
     * @param mol chemical structure; all nodes should be known legitimate elements
     */",227-272,"('calculate', {'INSTRUCTION': {'covered': 189, 'missed': 7}, 'BRANCH': {'covered': 26, 'missed': 6}, 'LINE': {'covered': 28, 'missed': 0}, 'COMPLEXITY': {'covered': 12, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",322.0,19.0,"Calculates the fingerprints for the given {@link IAtomContainer}, and stores them for subsequent retrieval.","Given a IAtomContainer, the function computes the fingerprint and stores it.",The fingerprints are calculated and stored for later use.,0.34468492508322,Calculates fingerprints for the given {@link IAtomContainer} and stores them for later retrieval.
391,glowstone,"public void putFloatList(@NonNls String key, List<Float> list){
    putList(key, TagType.FLOAT, list, FloatTag::new);
}",putFloatList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Adds or replaces a list subtag with a list of floats.
     *
     * @param key the key to write to
     * @param list the list contents as floats, to convert to float tags
     */",967-975,"('putFloatList', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,12.0,Adds or replaces a list subtag with a list of floats.,"Given a list subtag, it adds or replace this list with floats.",A list subtag is replaced with a list of floats.,0.300604074180798,Adds or replaces a list subtag with a floating list.
392,glowstone,"public boolean readStringList(@NonNls String key, Consumer<? super List<String>> consumer){
    return readList(key, TagType.STRING, consumer);
}",readStringList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to a list subtag if it is present and its contents are string
     * tags.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */",584-594,"('readStringList', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,19.0,Applies the given function to a list subtag if it is present and its contents are string  tags.,"If the contents of a list of subtag (if present) are string, apply the provided function. ","If the function is present and the contents are string tags, apply it to the list subtag.",0.482688015856047,Applies the given function to a list subtag if it is present and its contents consist of string tags.
393,cdk,"private static Integer findIdx(Map<T, Integer> idxs, T obj){
    Integer idx = idxs.get(obj);
    if (idx == null)
        return -1;
    return idx;
}",findIdx,org/openscience/cdk/io/MDLV3000Writer.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV3000Writer.java,"/**
     * Access the index of Obj->Int map, if the entry isn't found we return -1.
     *
     * @param idxs index map
     * @param obj the object
     * @param <T> the object type
     * @return index or -1 if not found
     */",132-145,"('findIdx', {'INSTRUCTION': {'covered': 9, 'missed': 3}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,19.0,"Access the index of Obj->Int map, if the entry isn't found we return -1.","Return the index of Obj->Int map if found, otherwise -1.","If the entry isn't found, we return -1.",0.416573464775299,"Go to the index of the Obj->Int card, if the entry is not found, we return -1."
394,matsim-libs,"public final Volume createVolume(final int h, final double val){
    if (h < 1) {
        throw new RuntimeException(""counts start at 1, not at 0.  If you have a use case where you need to go below one, "" + ""let us know and we think about it, but so far we had numerous debugging sessions because someone inserted counts at 0."");
    }
    // overkill?
    Volume v = new Volume(h, val);
    this.volumes.put(Integer.valueOf(h), v);
    return v;
}",createVolume,org/matsim/counts/Count.java,/matsim/src/main/java/org/matsim/counts/Count.java,"/**
	 * Creates and adds a {@link Volume} to the {@link Count}ing station.
	 * @param h indicating the hour-of-day. <b><i>Note: the hours for a counting 
	 * 		station must be from 1-24, and <b><i>not</i></b> from 0-23, 
	 * 		otherwise the {@link MatsimCountsReader} will throw an error.
	 * 		</i></b>
	 * @param val the total number of vehicles counted during hour <code>h</code>.
	 * @return the {@link Count}ing station's {@link Volume}.
	 */",43-61,"('createVolume', {'INSTRUCTION': {'covered': 18, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",62.0,19.0,Creates and adds a {@link Volume} to the {@link Count}ing station.,The function creates a Volume and adds it to the Count station and ,The @link Volume is added to the @link Counting station.,0.91265673397013,Creates and adds a {@link Volume} to the station {@link Count}ing.
395,cdk,"public String toString(){
    StringBuffer stringContent = new StringBuffer(64);
    stringContent.append(""Atom("").append(hashCode());
    if (getSymbol() != null) {
        stringContent.append("", S:"").append(getSymbol());
    }
    if (getImplicitHydrogenCount() != null) {
        stringContent.append("", H:"").append(getImplicitHydrogenCount());
    }
    if (getStereoParity() != null) {
        stringContent.append("", SP:"").append(getStereoParity());
    }
    if (getPoint2d() != null) {
        stringContent.append("", 2D:["").append(getPoint2d()).append(']');
    }
    if (getPoint3d() != null) {
        stringContent.append("", 3D:["").append(getPoint3d()).append(']');
    }
    if (getFractionalPoint3d() != null) {
        stringContent.append("", F3D:["").append(getFractionalPoint3d());
    }
    if (getCharge() != null) {
        stringContent.append("", C:"").append(getCharge());
    }
    stringContent.append("", "").append(super.toString());
    stringContent.append(')');
    return stringContent.toString();
}",toString,org/openscience/cdk/silent/Atom.java,/base/silent/src/main/java/org/openscience/cdk/silent/Atom.java,"/**
     * Returns a one line string representation of this Atom.
     * Methods is conform RFC #9.
     *
     * @return  The string representation of this Atom
     */",489-523,"('toString', {'INSTRUCTION': {'covered': 75, 'missed': 25}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 16, 'missed': 3}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",238.0,10.0,Returns a one line string representation of this Atom.,The function provides a single line representation of the Atom.,A one line string representation of this atom is returned.,0.318444078332272,Returns a string representation of a line of this atom.
396,jeromq,"public ZMsg msgBinaryPicture(String picture, Object... args){
    if (!BINARY_FORMAT.matcher(picture).matches()) {
        throw new ZMQException(picture + "" is not in expected binary format "" + BINARY_FORMAT.pattern(), ZError.EPROTO);
    }
    ZMsg msg = new ZMsg();
    // Pass 1: calculate total size of data frame
    int frameSize = 0;
    for (int index = 0; index < picture.length(); index++) {
        char pattern = picture.charAt(index);
        switch(pattern) {
            case '1':
                {
                    frameSize += 1;
                    break;
                }
            case '2':
                {
                    frameSize += 2;
                    break;
                }
            case '4':
                {
                    frameSize += 4;
                    break;
                }
            case '8':
                {
                    frameSize += 8;
                    break;
                }
            case 's':
                {
                    String string = (String) args[index];
                    frameSize += 1 + (string != null ? string.getBytes(ZMQ.CHARSET).length : 0);
                    break;
                }
            case 'S':
                {
                    String string = (String) args[index];
                    frameSize += 4 + (string != null ? string.getBytes(ZMQ.CHARSET).length : 0);
                    break;
                }
            case 'b':
            case 'c':
                {
                    byte[] block = (byte[]) args[index];
                    frameSize += 4 + block.length;
                    break;
                }
            case 'f':
                {
                    ZFrame frame = (ZFrame) args[index];
                    msg.add(frame);
                    break;
                }
            case 'm':
                {
                    ZMsg other = (ZMsg) args[index];
                    if (other == null) {
                        msg.add(new ZFrame((byte[]) null));
                    } else {
                        msg.addAll(other);
                    }
                    break;
                }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    // Pass 2: encode data into data frame
    ZFrame frame = new ZFrame(new byte[frameSize]);
    ZNeedle needle = new ZNeedle(frame);
    for (int index = 0; index < picture.length(); index++) {
        char pattern = picture.charAt(index);
        switch(pattern) {
            case '1':
                {
                    needle.putNumber1((int) args[index]);
                    break;
                }
            case '2':
                {
                    needle.putNumber2((int) args[index]);
                    break;
                }
            case '4':
                {
                    needle.putNumber4((int) args[index]);
                    break;
                }
            case '8':
                {
                    needle.putNumber8((long) args[index]);
                    break;
                }
            case 's':
                {
                    needle.putString((String) args[index]);
                    break;
                }
            case 'S':
                {
                    needle.putLongString((String) args[index]);
                    break;
                }
            case 'b':
            case 'c':
                {
                    byte[] block = (byte[]) args[index];
                    needle.putNumber4(block.length);
                    needle.putBlock(block, block.length);
                    break;
                }
            case 'f':
            case 'm':
                break;
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    msg.addFirst(frame);
    return msg;
}",msgBinaryPicture,org/zeromq/proto/ZPicture.java,/src/main/java/org/zeromq/proto/ZPicture.java,"/**
     * Creates a binary encoded 'picture' message to the socket (or actor), so it can be sent.
     * The arguments are encoded in a binary format that is compatible with zproto, and
     * is designed to reduce memory allocations.
     *
     * @param picture The picture argument is a string that defines the
     *                type of each argument. Supports these argument types:
     *                <table>
     *                <caption> </caption>
     *                <tr><th style=""text-align:left"">pattern</th><th style=""text-align:left"">java type</th><th style=""text-align:left"">zproto type</th></tr>
     *                <tr><td>1</td><td>int</td><td>type = ""number"" size = ""1""</td></tr>
     *                <tr><td>2</td><td>int</td><td>type = ""number"" size = ""2""</td></tr>
     *                <tr><td>4</td><td>long</td><td>type = ""number"" size = ""3""</td></tr>
     *                <tr><td>8</td><td>long</td><td>type = ""number"" size = ""4""</td></tr>
     *                <tr><td>s</td><td>String, 0-255 chars</td><td>type = ""string""</td></tr>
     *                <tr><td>S</td><td>String, 0-2^32-1 chars</td><td>type = ""longstr""</td></tr>
     *                <tr><td>b</td><td>byte[], 0-2^32-1 bytes</td><td>type = ""chunk""</td></tr>
     *                <tr><td>c</td><td>byte[], 0-2^32-1 bytes</td><td>type = ""chunk""</td></tr>
     *                <tr><td>f</td><td>ZFrame</td><td>type = ""frame""</td></tr>
     *                <tr><td>m</td><td>ZMsg</td><td>type = ""msg"" <b>Has to be the last element of the picture</b></td></tr>
     *                </table>
     * @param args    Arguments according to the picture
     * @return true when it has been queued on the socket and ØMQ has assumed responsibility for the message.
     * This does not indicate that the message has been transmitted to the network.
     * @apiNote Does not change or take ownership of any arguments.
     */",25-163,"('msgBinaryPicture', {'INSTRUCTION': {'covered': 221, 'missed': 34}, 'BRANCH': {'covered': 27, 'missed': 8}, 'LINE': {'covered': 56, 'missed': 2}, 'COMPLEXITY': {'covered': 20, 'missed': 6}, 'METHOD': {'covered': 1, 'missed': 0}})",600.0,21.0,"Creates a binary encoded 'picture' message to the socket (or actor), so it can be sent.","It creates a binary encoded image of the message, compatible with zproto and optimized in memory allocation, to the socket for sending it. ",A picture message can be sent if it is created in a way that is compatible with the actor.,0.362218078381548,"Creates a binary-encoded 'image' message to the socket (or actor), so that it can be sent."
397,metrics,"private ByteBuffer encryptPacket(ByteBuffer packet){
    final ByteBuffer payload = (ByteBuffer) ByteBuffer.allocate(SHA1_LENGTH + packet.remaining()).put(sha1(packet)).put((ByteBuffer) packet.flip()).flip();
    final EncryptionResult er = encrypt(password, payload);
    return (ByteBuffer) ByteBuffer.allocate(BUFFER_SIZE).putShort((short) TYPE_ENCR_AES256).putShort((short) (ENCRYPT_DATA_LEN + username.length + er.output.remaining())).putShort((short) username.length).put(username).put(er.iv).put(er.output).flip();
}",encryptPacket,io/dropwizard/metrics5/collectd/PacketWriter.java,/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/PacketWriter.java,"/**
     * Encrypts the provided packet, so it's can't be eavesdropped during a transfer
     * to a CollectD server. Wire format:
     * <pre>
     * +---------------------------------+-------------------------------+
     * ! Type (0x0210)                   ! Length                        !
     * +---------------------------------+-------------------------------+
     * ! Username length in bytes        ! Username                      \
     * +-----------------------------------------------------------------+
     * ! Initialization Vector (IV)      !                               \
     * +---------------------------------+-------------------------------+
     * ! Encrypted bytes (AES (SHA1(packet) + packet))                   \
     * +---------------------------------+-------------------------------+
     * </pre>
     *
     * @see <a href=""https://collectd.org/wiki/index.php/Binary_protocol#Encrypted_part"">
     * Binary protocol - CollectD | Encrypted part</a>
     */",170-202,"('encryptPacket', {'INSTRUCTION': {'covered': 49, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",138.0,20.0,"Encrypts the provided packet, so it's can't be eavesdropped during a transfer  to a CollectD server.","The packet, in order to be eavesdropped when it is transfered to a CollectD server, is encrypted.",The packet can't be eavesdropped on during a transfer to a CollectD server.,0.598769580556177,"Encrypts the supplied packet, so that it cannot be listened to during a transfer to a CollectD server."
398,cdk,"public boolean isDiscrete(){
    for (SortedSet<Integer> cell : cells) {
        if (cell.size() != 1) {
            return false;
        }
    }
    return true;
}",isDiscrete,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,"/**
     * Checks that all the cells are singletons - that is, they only have one
     * element. A discrete partition is equivalent to a permutation.
     *
     * @return true if all the cells are discrete
     */",141-154,"('isDiscrete', {'INSTRUCTION': {'covered': 18, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,17.0,"Checks that all the cells are singletons - that is, they only have one  element.","Verifies if all cells are singletons, so containing a single element.","The cells only have one element, so it's important to check that.",0.45793588886739,"Verifies that all cells are singletons - that is, they have only one element."
401,anserini,"private static Set<String> nearestVector(Map<String, List<float[]>> vectors, String word, int topN){
    Set<String> intermediate = new TreeSet<>();
    List<float[]> inputs = vectors.get(word);
    String separateToken = ""__"";
    for (Map.Entry<String, List<float[]>> entry : vectors.entrySet()) {
        for (float[] value : entry.getValue()) {
            for (float[] input : inputs) {
                float sim = 0;
                for (int i = 0; i < value.length; i++) {
                    sim += value[i] * input[i];
                }
                // store the words, sorted by decreasing distance using natural order (in the $dist__$word format)
                intermediate.add((1 - sim) + separateToken + entry.getKey());
            }
        }
    }
    Set<String> result = new HashSet<>();
    int i = 0;
    for (String w : intermediate) {
        if (i == topN) {
            break;
        }
        // only add actual word String (not the distance) to the result collection
        result.add(w.substring(w.indexOf(separateToken) + 2));
        i++;
    }
    return result;
}",nearestVector,io/anserini/ann/ApproximateNearestNeighborEval.java,/src/main/java/io/anserini/ann/ApproximateNearestNeighborEval.java,"/**
   * Calculate the nearest <i>N</i> words for a given input word.
   *
   * @param vectors vectors, keyed by word
   * @param word    the input word
   * @param topN    the number of similar word vectors to output
   * @return the {@code topN} similar words of the input word
   */",216-251,"('nearestVector', {'INSTRUCTION': {'covered': 111, 'missed': 1}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 21, 'missed': 1}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",229.0,17.0,Calculate the nearest <i>N</i> words for a given input word.,"Given an input word, compute the nearest N words.",The nearest words for the input word are calculated.,0.137159731730175,Calculate the <i>N</i> closest words for a given entry word.
402,cdk,"static void updateAromaticTypesInSixMemberRing(int[] cycle, String[] symbs){
    for (final int v : cycle) {
        if (NCN_PLUS.equals(symbs[v]) || ""N+=C"".equals(symbs[v]) || ""N=+C"".equals(symbs[v]))
            symbs[v] = ""NPD+"";
        else if (""N2OX"".equals(symbs[v]))
            symbs[v] = ""NPOX"";
        else if (""N=C"".equals(symbs[v]) || ""N=N"".equals(symbs[v]))
            symbs[v] = ""NPYD"";
        else if (symbs[v].startsWith(""C""))
            symbs[v] = ""CB"";
    }
}",updateAromaticTypesInSixMemberRing,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,"/**
     * Update aromatic atom types in a six member ring. The aromatic types here are hard coded from
     * the 'MMFFAROM.PAR' file.
     *
     * @param cycle 6-member aromatic cycle / ring
     * @param symbs vector of symbolic types for the whole structure
     */",219-236,"('updateAromaticTypesInSixMemberRing', {'INSTRUCTION': {'covered': 78, 'missed': 0}, 'BRANCH': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",135.0,10.0,Update aromatic atom types in a six member ring.,"Update the so called aromatic atoms, hard coded from MMFFAROM.PAR file, that are contained in a six member ring.",The aromatic atom types are updated.,0.318474221459417,Update the types of aromatic atoms in a six-member ring.
403,cdk,"public static IAtomContainer correct(IAtomContainer container){
    if (container.stereoElements().iterator().hasNext())
        new CorrectGeometricConfiguration(container);
    return container;
}",correct,org/openscience/cdk/layout/CorrectGeometricConfiguration.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/CorrectGeometricConfiguration.java,"/**
     * Adjust all double bond elements in the provided structure. <b>IMPORTANT:
     * up/down labels should be adjusted before adjust double-bond
     * configurations. coordinates are reflected by this method which can lead
     * to incorrect tetrahedral specification.</b>
     *
     * @param container the structure to adjust
     * @throws IllegalArgumentException an atom had unset coordinates
     */",70-83,"('correct', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,10.0,Adjust all double bond elements in the provided structure.,The function is used to adjust the double bond elements in the structure.,The structure has double bond elements.,0.399344700431223,Adjust all double-bonded elements in the provided structure.
405,cdk,"final int nextM(int n, int m){
    if (size == 0)
        return m + 1;
    for (int i = m + 1; i < g2.length; i++) if (m2[i] == UNMAPPED && (t1[n] == 0 || t2[i] > 0))
        return i;
    return mMax();
}",nextM,org/openscience/cdk/isomorphism/AbstractVFState.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/AbstractVFState.java,"/**
     * Given the current target candidate (m), find the next candidate. The next
     * candidate is the next vertex > m (in some ordering) that is unmapped and
     * is adjacent to a mapped vertex (terminal). If there is no such vertex
     * (disconnected) the next unmapped vertex is returned. If there are no more
     * candidates m == |V| of G2.
     *
     * @param m previous candidate m
     * @return the next value of m
     */",94-112,"('nextM', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,14.0,"Given the current target candidate (m), find the next candidate.","Given the current target candidate, it returns the next candidate, the verted that is unmpapped and adjacent to a terminal mapped vertex. If it can not find the vertex, it returns the next unmapped vertex or the cardinality of the vertex if there are no more candidates.",The next candidate should be found given the current target candidate.,0.5337023697731,"Given the current target candidate (m), find the next candidate."
406,cdk,"public void addIsotope(IIsotope isotope, int countMin, int countMax){
    if (isotope == null)
        throw new IllegalArgumentException(""Isotope must not be null"");
    boolean flag = false;
    for (Iterator<IIsotope> it = isotopes().iterator(); it.hasNext(); ) {
        IIsotope thisIsotope = it.next();
        if (isTheSame(thisIsotope, isotope)) {
            isotopesMax.put(thisIsotope, countMax);
            isotopesMin.put(thisIsotope, countMin);
            flag = true;
            break;
        }
    }
    if (!flag) {
        isotopesMax.put(isotope, countMax);
        isotopesMin.put(isotope, countMin);
    }
}",addIsotope,org/openscience/cdk/formula/MolecularFormulaRange.java,/tool/formula/src/main/java/org/openscience/cdk/formula/MolecularFormulaRange.java,"/**
     *  Adds an Isotope to this MolecularFormulaExpand in a number of
     *  maximum and minimum occurrences allowed.
     *
     * @param  isotope  The isotope to be added to this MolecularFormulaExpand
     * @param  countMax The maximal number of occurrences to add
     * @param  countMin The minimal number of occurrences to add
     *
     */",58-86,"('addIsotope', {'INSTRUCTION': {'covered': 60, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",127.0,16.0,Adds an Isotope to this MolecularFormulaExpand in a number of  maximum and minimum occurrences allowed.,Adds to the MolecularFormulaExpand the isotope in a number that represents the maximum and minimum occurrences allowed.,A number of maximum and minimum occurrences are allowed.,0.622435466431553,Adds an isotope to this MolecularFormulaExpand in a number of maximum and minimum allowed occurrences.
407,anserini,"public static Document documentByField(IndexReader reader, String field, String id){
    try {
        IndexSearcher searcher = new IndexSearcher(reader);
        Query q = new TermQuery(new Term(field, id));
        TopDocs rs = searcher.search(q, 1);
        ScoreDoc[] hits = rs.scoreDocs;
        if (hits == null || hits.length == 0) {
            return null;
        }
        return reader.document(hits[0].doc);
    } catch (IOException e) {
        return null;
    }
}",documentByField,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,"/**
   * Fetches the Lucene {@link Document} based on some field other than its unique collection docid. For example,
   * scientific articles might have DOIs. The method is named to be consistent with Lucene's
   * {@link IndexReader#document(int)}, contra Java's standard method naming conventions.
   *
   * @param reader index reader
   * @param field field
   * @param id unique id
   * @return corresponding Lucene {@link Document} based on the value of a specific field
   */",509-536,"('documentByField', {'INSTRUCTION': {'covered': 34, 'missed': 5}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 6, 'missed': 3}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",104.0,19.0,Fetches the Lucene {@link Document} based on some field other than its unique collection docid.,"Fetches the Lucene Document using some fields other than the docid, a unique collection id.",The Lucene @link Document is based on a field other than its unique collection.,1.23557630517751,Retrieves the Lucene {@link Document} based on a field other than its unique collection docid.
408,cucumber-reporting,"private void applyPatchForFeatures(){
    for (int i = 0; i < totalFeatures.length; i++) {
        int total = totalFeatures[i];
        int failures = getFailedFeatures()[i];
        if (total < failures) {
            int tmp = total;
            totalFeatures[i] = failures;
            failedFeatures[i] = tmp;
        }
    }
}",applyPatchForFeatures,net/masterthought/cucumber/Trends.java,/src/main/java/net/masterthought/cucumber/Trends.java,"/**
     * Due to the error with old implementation where total features
     * were passed instead of failures (and vice versa) following correction must be applied for trends generated
     * between release 3.0.0 and 3.1.0.
     */",188-204,"('applyPatchForFeatures', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",70.0,32.0,Due to the error with old implementation where total features  were passed instead of failures (and vice versa) following correction must be applied for trends generated  between release 3.,Applies a patch returning the failure rather than the total features.,The old implementation where total features were passed instead of failures must be corrected.,1.89858938165924,"Due to the error with the old implementation where the total functionality was passed instead of failures (and vice versa), the following fix should be applied for trends generated between version 3."
409,cdk,"public IChemFormat[] findChemFormats(int features){
    if (formats == null)
        loadFormats();
    Iterator<IChemFormat> iter = formats.iterator();
    List<IChemFormat> matches = new ArrayList<IChemFormat>();
    while (iter.hasNext()) {
        IChemFormat format = (IChemFormat) iter.next();
        if ((format.getSupportedDataFeatures() & features) == features)
            matches.add(format);
    }
    return (IChemFormat[]) matches.toArray(new IChemFormat[matches.size()]);
}",findChemFormats,org/openscience/cdk/io/WriterFactory.java,/storage/io/src/main/java/org/openscience/cdk/io/WriterFactory.java,"/**
     * Finds IChemFormats that provide a container for serialization for the
     * given features. The syntax of the integer is explained in the DataFeatures class.
     *
     * @param  features the data features for which a IChemFormat is searched
     * @return          an array of IChemFormat's that can contain the given features
     *
     * @see    org.openscience.cdk.tools.DataFeatures
     */",73-93,"('findChemFormats', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",111.0,13.0,Finds IChemFormats that provide a container for serialization for the  given features.,Provides a container for the serialization of a feature using IChemFormats.,IChemFormats provide a container for serialization.,0.842450092697043,Looks for IChemFormats that provide a container for serializing given features.
410,cdk,"private void layoutRingSystem(Point3d originalCoord, IAtom placedRingAtom, IRingSet ringSet, Point3d centerPlacedMolecule, IAtom atomB, AtomPlacer3D ap3d){
    IAtomContainer ac = RingSetManipulator.getAllInOneContainer(ringSet);
    Point3d newCoord = placedRingAtom.getPoint3d();
    Vector3d axis = new Vector3d(atomB.getPoint3d().x - newCoord.x, atomB.getPoint3d().y - newCoord.y, atomB.getPoint3d().z - newCoord.z);
    translateStructure(originalCoord, newCoord, ac);
    Vector3d startAtomVector = new Vector3d(newCoord.x - atomB.getPoint3d().x, newCoord.y - atomB.getPoint3d().y, newCoord.z - atomB.getPoint3d().z);
    IAtom farthestAtom = ap3d.getFarthestAtom(placedRingAtom.getPoint3d(), ac);
    Vector3d farthestAtomVector = new Vector3d(farthestAtom.getPoint3d().x - newCoord.x, farthestAtom.getPoint3d().y - newCoord.y, farthestAtom.getPoint3d().z - newCoord.z);
    Vector3d n1 = new Vector3d();
    n1.cross(axis, farthestAtomVector);
    n1.normalize();
    double lengthFarthestAtomVector = farthestAtomVector.length();
    Vector3d farthestVector = new Vector3d(startAtomVector);
    farthestVector.normalize();
    farthestVector.scale((startAtomVector.length() + lengthFarthestAtomVector));
    double dotProduct = farthestAtomVector.dot(farthestVector);
    double angle = Math.acos(dotProduct / (farthestAtomVector.length() * farthestVector.length()));
    Vector3d ringCenter = new Vector3d();
    for (int i = 0; i < ac.getAtomCount(); i++) {
        if (!(ac.getAtom(i).getFlag(CDKConstants.ISPLACED))) {
            ringCenter.x = (ac.getAtom(i).getPoint3d()).x - newCoord.x;
            ringCenter.y = (ac.getAtom(i).getPoint3d()).y - newCoord.y;
            ringCenter.z = (ac.getAtom(i).getPoint3d()).z - newCoord.z;
            ringCenter = AtomTetrahedralLigandPlacer3D.rotate(ringCenter, n1, angle);
            ac.getAtom(i).setPoint3d(new Point3d(ringCenter.x + newCoord.x, ringCenter.y + newCoord.y, ringCenter.z + newCoord.z));
        }
    }
    Point3d pointRingCenter = GeometryUtil.get3DCenter(ac);
    double distance = 0;
    double rotAngleMax = 0;
    angle = 1 / 180 * Math.PI;
    ringCenter = new Vector3d(pointRingCenter.x, pointRingCenter.y, pointRingCenter.z);
    ringCenter.x = ringCenter.x - newCoord.x;
    ringCenter.y = ringCenter.y - newCoord.y;
    ringCenter.z = ringCenter.z - newCoord.z;
    for (int i = 1; i < 360; i++) {
        ringCenter = AtomTetrahedralLigandPlacer3D.rotate(ringCenter, axis, angle);
        if (centerPlacedMolecule.distance(new Point3d(ringCenter.x, ringCenter.y, ringCenter.z)) > distance) {
            rotAngleMax = i;
            distance = centerPlacedMolecule.distance(new Point3d(ringCenter.x, ringCenter.y, ringCenter.z));
        }
    }
    rotAngleMax = (rotAngleMax / 180) * Math.PI;
    for (int i = 0; i < ac.getAtomCount(); i++) {
        if (!(ac.getAtom(i).getFlag(CDKConstants.ISPLACED))) {
            ringCenter.x = (ac.getAtom(i).getPoint3d()).x;
            ringCenter.y = (ac.getAtom(i).getPoint3d()).y;
            ringCenter.z = (ac.getAtom(i).getPoint3d()).z;
            ringCenter = AtomTetrahedralLigandPlacer3D.rotate(ringCenter, axis, rotAngleMax);
            ac.getAtom(i).setPoint3d(new Point3d(ringCenter.x, ringCenter.y, ringCenter.z));
            ac.getAtom(i).setFlag(CDKConstants.ISPLACED, true);
        }
    }
}",layoutRingSystem,org/openscience/cdk/modeling/builder3d/ModelBuilder3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/ModelBuilder3D.java,"/**
     * Layout the ring system, rotate and translate the template.
     *
     *@param  originalCoord         coordinates of the placedRingAtom from the template
     *@param  placedRingAtom        placedRingAtom
     *@param  ringSet               ring system which placedRingAtom is part of
     *@param  centerPlacedMolecule  the geometric center of the already placed molecule
     *@param  atomB                 placed neighbour atom of  placedRingAtom
     */",314-390,"('layoutRingSystem', {'INSTRUCTION': {'covered': 344, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 50, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",794.0,11.0,"Layout the ring system, rotate and translate the template.","Defines the ring system, rotating and translating the template.","The ring system can be layout, rotate and translated.",0.423684153604406,"Lay out the ring system, rotate and translate the model."
411,cdk,"private int[] neighbors(ITetrahedralChirality element, Map<IAtom, Integer> map){
    IAtom[] atoms = element.getLigands();
    int[] vs = new int[atoms.length];
    for (int i = 0; i < atoms.length; i++) vs[i] = map.get(atoms[i]);
    return vs;
}",neighbors,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,"/**
     * Access the neighbors of {@code element} as their indices.
     *
     * @param element tetrahedral element
     * @param map     atom index lookup
     * @return the neighbors
     */",282-295,"('neighbors', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,13.0,Access the neighbors of {@code element} as their indices.,"Given a tetrahedral element and an atom index, it accesses to the next element.",The neighbors of @code element are their indices.,0.831832873292271,Navigate to the neighbors of {@code element} as clues.
412,acs-aem-commons,"private void addReplicationStatusMixin(final Node node) throws RepositoryException{
    if (!this.hasMixin(node, ReplicationStatus.NODE_TYPE) && node.canAddMixin(ReplicationStatus.NODE_TYPE)) {
        node.addMixin(ReplicationStatus.NODE_TYPE);
    }
}",addReplicationStatusMixin,com/adobe/acs/commons/replication/status/impl/ReplicationStatusManagerImpl.java,/bundle/src/main/java/com/adobe/acs/commons/replication/status/impl/ReplicationStatusManagerImpl.java,"/**
     * Adds the cq:ReplicationStatus mixin if the node doesnt already have it or does have it as its jcr:supertype
     * already.
     *
     * @param node the node obj
     * @throws RepositoryException
     */",193-205,"('addReplicationStatusMixin', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,24.0,Adds the cq:ReplicationStatus mixin if the node doesnt already have it or does have it as its jcr:supertype  already.,"If the node does not have the cq:ReplicationStatus mixin (or it has it like jcr:superType), it is added it to the node.","If the jcr:supertype is already in the node, then the cq:ReplicationStatus mixin is added.",0.578271779822469,Adds the cq:ReplicationStatus mixin if the node does not already have it or already has it as jcr:supertype.
413,cdk,"public Iterable<IIsotope> isotopes(){
    return new Iterable<IIsotope>() {

        @Override
        public Iterator<IIsotope> iterator() {
            return isotopesList().iterator();
        }
    };
}",isotopes,org/openscience/cdk/silent/AdductFormula.java,/base/silent/src/main/java/org/openscience/cdk/silent/AdductFormula.java,"/**
     *  Returns an Iterator for looping over all isotopes in this adduct formula.
     *
     * @return    An Iterator with the isotopes in this adduct formula
     */",173-187,"('isotopes', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",42.0,13.0,Returns an Iterator for looping over all isotopes in this adduct formula.,Provides an iterator that can be used for looping over all isotopes in the formula.,This adduct formula returns an Iterator for looping over all the isotopes.,0.949278367083401,Returns an iterator for the loop over all isotopes of this adduct formula.
414,openapi-generator,"public static ValidationRule error(String failureMessage, Function<T, Result> fn){
    return new ValidationRule(Severity.ERROR, null, failureMessage, (Function<Object, Result>) fn);
}",error,org/openapitools/codegen/validation/ValidationRule.java,/modules/openapi-generator-core/src/main/java/org/openapitools/codegen/validation/ValidationRule.java,"/**
     * Create an instance of a {@link ValidationRule} which should result in an error should the evaluate of this rule fail.
     *
     * @param failureMessage The message to be displayed in the event of a test failure (intended to be user-facing).
     * @param fn The test condition to be applied as a part of this rule, when this function returns <code>true</code>,
     *             the evaluated instance will be considered ""valid"" according to this rule.
     * @param <T> The type of the object being evaluated.
     *
     * @return A new instance of a {@link ValidationRule}
     */",113-126,"('error', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,24.0,Create an instance of a {@link ValidationRule} which should result in an error should the evaluate of this rule fail.,Returns a ValidationRule instance that will return an error if the evaluation of the rule does not pass.,"If the evaluate of this rule fails, you should create an instance of the @link ValidationRule which should result in an error.",1.23922957383479,Create an instance of a {@link ValidationRule} that should cause an error if this rule fails to evaluate.
415,dataverse,"public String linkFor(String idpId, String redirectPage){
    AbstractOAuth2AuthenticationProvider idp = authenticationSvc.getOAuth2Provider(idpId);
    String state = createState(idp, toOption(redirectPage));
    return idp.buildAuthzUrl(state, systemConfig.getOAuth2CallbackUrl());
}",linkFor,edu/harvard/iq/dataverse/authorization/providers/oauth2/OAuth2LoginBackingBean.java,/src/main/java/edu/harvard/iq/dataverse/authorization/providers/oauth2/OAuth2LoginBackingBean.java,"/**
     * Generate the OAuth2 Provider URL to be used in the login page link for the provider.
     * @param idpId Unique ID for the provider (used to lookup in authn service bean)
     * @param redirectPage page part of URL where we should be redirected after login (e.g. ""dataverse.xhtml"")
     * @return A generated link for the OAuth2 provider login
     */",72-82,"('linkFor', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",49.0,17.0,Generate the OAuth2 Provider URL to be used in the login page link for the provider.,Create a OAuth2 Provider URL that can be used for the login for the provider.,The provider's login page link will be used if the OAuth2 Provider URL is generated.,0.434015868705152,Generate the URL of the OAuth2 provider to use in the link on the provider's login page.
417,tablesaw,"public Table[] stratifiedSampleSplit(CategoricalColumn<?> column, double table1Proportion){
    Preconditions.checkArgument(containsColumn(column), ""The categorical column must be part of the table, you can create a string column and add it to this table before sampling."");
    final Table first = emptyCopy();
    final Table second = emptyCopy();
    splitOn(column).asTableList().forEach(tab -> {
        Table[] splits = tab.sampleSplit(table1Proportion);
        first.append(splits[0]);
        second.append(splits[1]);
    });
    return new Table[] { first, second };
}",stratifiedSampleSplit,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,"/**
   * Splits the table into two stratified samples, this uses the specified column to divide the
   * table into groups, randomly assigning records to each according to the proportion given in
   * trainingProportion.
   *
   * @param column the column to be used for the stratified sampling
   * @param table1Proportion The proportion to go in the first table
   * @return An array two tables, with the first table having the proportion specified in the method
   *     parameter, and the second table having the balance of the rows
   */",524-551,"('stratifiedSampleSplit', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,33.0,"Splits the table into two stratified samples, this uses the specified column to divide the  table into groups, randomly assigning records to each according to the proportion given in  trainingProportion.","Using the specified column, it divides the table into two groups. Each record is assigned randomly to each group in order to maintain the proportion trainingProposrtion.","The table is split into two samples, with the specified column used to divide it into groups.",0.645193085298975,"Divides the table into two stratified samples, this uses the specified column to divide the table into groups, randomly assigning records to each based on the proportion given in trainingProportion."
418,cdk,"static boolean accept(IAtom atom, List<IBond> bonds){
    int dbCount = 0;
    if (!IAtomType.Hybridization.SP2.equals(atom.getHybridization()))
        return false;
    if (bonds.size() == 1)
        return false;
    for (IBond bond : bonds) {
        if (DOUBLE.equals(bond.getOrder()))
            dbCount++;
        IBond.Stereo stereo = bond.getStereo();
        if (IBond.Stereo.UP_OR_DOWN.equals(stereo) || IBond.Stereo.UP_OR_DOWN_INVERTED.equals(stereo))
            return false;
    }
    return dbCount == 1;
}",accept,org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,"/**
     * Test whether we accept atom and it's connected bonds for inclusion in a
     * double bond configuration. This method checks for query bonds (up/down)
     * as well as double bond counts. If there is more then one double bond in
     * the connect bonds then it cannot have Z/E configuration.
     *
     * @param atom  a double bonded atom
     * @param bonds all bonds connected to the atom
     * @return whether the atom is accepted for configuration
     */",235-269,"('accept', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",122.0,18.0,Test whether we accept atom and it's connected bonds for inclusion in a  double bond configuration.,"The function returns true if we accept the atoms with the connected bonds in a double bound configuration. Considering query bonds (up/down) and bond counts, if there exists more than one double bound, it can not have Z/E configuration.","If we accept atom, we need to test whether it's connected bonds for inclusion.",0.693343119765149,Test whether we accept the atom and its connected bonds for inclusion in a dual-link configuration.
419,liquibase,"public Precondition create(String tagName){
    Class<?> aClass = preconditions.get(tagName);
    if (aClass == null) {
        return null;
    }
    try {
        return (Precondition) aClass.getConstructor().newInstance();
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}",create,liquibase/precondition/PreconditionFactory.java,/liquibase-core/src/main/java/liquibase/precondition/PreconditionFactory.java,"/**
     * Create a new Precondition subclass based on the given tag name.
     */",55-68,"('create', {'INSTRUCTION': {'covered': 19, 'missed': 6}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",64.0,12.0,Create a new Precondition subclass based on the given tag name.,"Starting from the given tag name, create a new Precondition subclass.",The given tag name will be used to create a new Precondition subclass.,0.4946996704009,Create a Precondition subclass based on the given tag name.
420,cdk,"private void init(){
    for (IAtom atom : atoms) {
        if (atom.getPoint3d() == null)
            throw new IllegalArgumentException(""One or more atoms had no 3D coordinate set"");
    }
    Point3d cp = new Point3d(0, 0, 0);
    double maxRadius = 0;
    for (IAtom atom : atoms) {
        double vdwr = PeriodicTable.getVdwRadius(atom.getSymbol());
        if (vdwr + solventRadius > maxRadius)
            maxRadius = PeriodicTable.getVdwRadius(atom.getSymbol()) + solventRadius;
        cp.x = cp.x + atom.getPoint3d().x;
        cp.y = cp.y + atom.getPoint3d().y;
        cp.z = cp.z + atom.getPoint3d().z;
    }
    cp.x = cp.x / atoms.length;
    cp.y = cp.y / atoms.length;
    cp.z = cp.z / atoms.length;
    Tessellate tess = new Tessellate(""ico"", tesslevel);
    tess.doTessellate();
    logger.info(""Got tesselation, number of triangles = "" + tess.getNumberOfTriangles());
    NeighborList nbrlist = new NeighborList(atoms, maxRadius + solventRadius);
    logger.info(""Got neighbor list"");
    this.surfPoints = (List<Point3d>[]) new List[atoms.length];
    this.areas = new double[atoms.length];
    this.volumes = new double[atoms.length];
    for (int i = 0; i < atoms.length; i++) {
        int pointDensity = tess.getNumberOfTriangles() * 3;
        Point3d[][] points = atomicSurfacePoints(nbrlist, i, atoms[i], tess);
        translatePoints(i, points, pointDensity, atoms[i], cp);
    }
    logger.info(""Obtained points, areas and volumes"");
}",init,org/openscience/cdk/geometry/surface/NumericalSurface.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/geometry/surface/NumericalSurface.java,"/**
     * Initialize the surface, generating the points on the accessible surface
     * area of each atom as well as calculating the surface area of each atom.
     */",115-170,"('init', {'INSTRUCTION': {'covered': 206, 'missed': 5}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 28, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",348.0,26.0,"Initialize the surface, generating the points on the accessible surface  area of each atom as well as calculating the surface area of each atom.","The function is used for the initialization of the surface, by generating the points on the surface area of each atom and calculating the atom's surface area.",The surface area of each atom can be calculated by generating points on the accessible surface area of each atom.,0.429104577223317,"Initialize the surface, generate the points on the accessible surface of each atom as well as the calculation of the surface of each atom."
421,dataverse,"public Set<Group> collectAncestors(Collection<Group> groups){
    Set<Group> retVal = new HashSet<>();
    Set<Group> perimeter = new HashSet<>(groups);
    while (!perimeter.isEmpty()) {
        Group next = perimeter.iterator().next();
        retVal.add(next);
        perimeter.remove(next);
        explicitGroupService.findDirectlyContainingGroups(next).forEach(g -> {
            if (!retVal.contains(g)) {
                perimeter.add(g);
            }
        });
    }
    return retVal;
}",collectAncestors,edu/harvard/iq/dataverse/authorization/groups/GroupServiceBean.java,/src/main/java/edu/harvard/iq/dataverse/authorization/groups/GroupServiceBean.java,"/**
     * Returns all the groups that are in, of are ancestors of a group in
     * the passed group collection.
     * 
     * @param groups 
     * @return {@code groups} and their ancestors.
     */",180-206,"('collectAncestors', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",117.0,20.0,"Returns all the groups that are in, of are ancestors of a group in  the passed group collection.","Given a group, return all the ancestors.",The ancestors of a group in the passed group collection are returned.,0.253122373085084,"Returns all groups that are in, or are the ancestors of, a group in the transmitted group collection."
422,cdk,"public static IsotopePattern sortByIntensity(IsotopePattern isotopeP){
    try {
        IsotopePattern isoSort = (IsotopePattern) isotopeP.clone();
        if (isoSort.getNumberOfIsotopes() == 0)
            return isoSort;
        List<IsotopeContainer> listISO = isoSort.getIsotopes();
        Collections.sort(listISO, new Comparator<IsotopeContainer>() {

            @Override
            public int compare(IsotopeContainer o1, IsotopeContainer o2) {
                return Double.compare(o2.getIntensity(), o1.getIntensity());
            }
        });
        isoSort.setMonoIsotope(listISO.get(0));
        return isoSort;
    } catch (CloneNotSupportedException e) {
        e.printStackTrace();
    }
    return null;
}",sortByIntensity,org/openscience/cdk/formula/IsotopePatternManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/formula/IsotopePatternManipulator.java,"/**
     * Return the isotope pattern sorted by intensity
     * to the highest abundance.
     *
     * @param isotopeP  The IsotopePattern object to sort
     * @return          The IsotopePattern sorted
     */",69-104,"('sortByIntensity', {'INSTRUCTION': {'covered': 23, 'missed': 7}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 4}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",130.0,12.0,Return the isotope pattern sorted by intensity  to the highest abundance.,"Given an isotope, it sorts the isotope pattern by intensity to the highest abundance.",The pattern of the isotope is sorted by intensity.,0.637276347141448,Bring the intensity-sorted isotopic pattern back to the greatest abundance.
423,activiti,"protected ExecutionEntity processExecutionTree(String rootProcessInstanceId, List<ExecutionEntity> executions){
    ExecutionEntity rootExecution = null;
    // Collect executions
    Map<String, ExecutionEntity> executionMap = new HashMap<String, ExecutionEntity>(executions.size());
    for (ExecutionEntity executionEntity : executions) {
        if (executionEntity.getId().equals(rootProcessInstanceId)) {
            rootExecution = executionEntity;
        }
        executionMap.put(executionEntity.getId(), executionEntity);
    }
    // Set relationships
    for (ExecutionEntity executionEntity : executions) {
        // Root process instance relationship
        if (executionEntity.getRootProcessInstanceId() != null) {
            executionEntity.setRootProcessInstance(executionMap.get(executionEntity.getRootProcessInstanceId()));
        }
        // Process instance relationship
        if (executionEntity.getProcessInstanceId() != null) {
            executionEntity.setProcessInstance(executionMap.get(executionEntity.getProcessInstanceId()));
        }
        // Parent - child relationship
        if (executionEntity.getParentId() != null) {
            ExecutionEntity parentExecutionEntity = executionMap.get(executionEntity.getParentId());
            executionEntity.setParent(parentExecutionEntity);
            parentExecutionEntity.addChildExecution(executionEntity);
        }
        // Super - sub execution relationship
        if (executionEntity.getSuperExecution() != null) {
            ExecutionEntity superExecutionEntity = executionMap.get(executionEntity.getSuperExecutionId());
            executionEntity.setSuperExecution(superExecutionEntity);
            superExecutionEntity.setSubProcessInstance(executionEntity);
        }
    }
    return rootExecution;
}",processExecutionTree,org/activiti/engine/impl/persistence/entity/ExecutionEntityManagerImpl.java,/activiti-core/activiti-engine/src/main/java/org/activiti/engine/impl/persistence/entity/ExecutionEntityManagerImpl.java,"/**
   * Processes a collection of {@link ExecutionEntity} instances, which form on execution tree.
   * All the executions share the same rootProcessInstanceId (which is provided).
   * The return value will be the root {@link ExecutionEntity} instance, with all child {@link ExecutionEntity}
   * instances populated and set using the {@link ExecutionEntity} instances from the provided collections
   */",133-180,"('processExecutionTree', {'INSTRUCTION': {'covered': 95, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 2}, 'LINE': {'covered': 22, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",232.0,17.0,"Processes a collection of {@link ExecutionEntity} instances, which form on execution tree.","The function processes a collection of ExecutionEntity instances, that create an execution tree. It returns the root instance, with all children that share the same rootProcessInstanceId",A collection of instances form on the execution tree.,0.332797644740589,"Processes a collection of {@link ExecutionEntity} instances, which form in the runtime tree."
424,weblogic-kubernetes-operator," boolean isUseOnlineUpdate(){
    return Optional.ofNullable(configuration).map(Configuration::getModel).map(Model::getOnlineUpdate).map(OnlineUpdate::getEnabled).orElse(false);
}",isUseOnlineUpdate,oracle/kubernetes/weblogic/domain/model/DomainSpec.java,/operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainSpec.java,"/**
   * Test if the MII domain wants to use online update.
   *
   * @return true if using online update
   */",822-833,"('isUseOnlineUpdate', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,11.0,Test if the MII domain wants to use online update.,Returns true if the MII domain is using online updates.,"If the MII domain wants to use online update, you should test it.",0.248730666018798,Test whether the MII domain wants to use the online update.
425,tablesaw,"public Reader createReader(byte[] cachedBytes) throws IOException{
    if (cachedBytes != null) {
        return charset != null ? new InputStreamReader(new ByteArrayInputStream(cachedBytes), charset) : new InputStreamReader(new ByteArrayInputStream(cachedBytes));
    }
    if (inputStream != null) {
        return new InputStreamReader(inputStream, charset);
    }
    if (reader != null) {
        return reader;
    }
    return new InputStreamReader(new FileInputStream(file), charset);
}",createReader,tech/tablesaw/io/Source.java,/core/src/main/java/tech/tablesaw/io/Source.java,"/**
   * If cachedBytes are not null, returns a Reader created from the cachedBytes. Otherwise, returns
   * a Reader from the underlying source.
   */",86-103,"('createReader', {'INSTRUCTION': {'covered': 51, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",89.0,14.0,"If cachedBytes are not null, returns a Reader created from the cachedBytes.","It checks whether cachedBytes are not null, returning a Reader that use the cachedBytes, if not null, or the underlying source otherwise.",A Reader is created from the cachedBytes if they are not null.,0.66185881426421,"If cachedBytes is not null, returns a reader created from cachedBytes."
426,cdk,"static StereoEncoder newEncoder(IAtomContainer container, IAtom left, IAtom leftParent, IAtom right, IAtom rightParent, int[][] graph){
    List<IBond> leftBonds = container.getConnectedBondsList(left);
    List<IBond> rightBonds = container.getConnectedBondsList(right);
    if (accept(left, leftBonds) && accept(right, rightBonds)) {
        int leftIndex = container.indexOf(left);
        int rightIndex = container.indexOf(right);
        int leftParentIndex = container.indexOf(leftParent);
        int rightParentIndex = container.indexOf(rightParent);
        int[] leftNeighbors = moveToBack(graph[leftIndex], leftParentIndex);
        int[] rightNeighbors = moveToBack(graph[rightIndex], rightParentIndex);
        int l1 = leftNeighbors[0];
        int l2 = leftNeighbors[1] == leftParentIndex ? leftIndex : leftNeighbors[1];
        int r1 = rightNeighbors[0];
        int r2 = rightNeighbors[1] == rightParentIndex ? rightIndex : rightNeighbors[1];
        GeometricParity geometric = geometric(container, leftIndex, rightIndex, l1, l2, r1, r2);
        if (geometric != null) {
            return new GeometryEncoder(new int[] { leftIndex, rightIndex }, new CombinedPermutationParity(permutation(leftNeighbors), permutation(rightNeighbors)), geometric);
        }
    }
    return null;
}",newEncoder,org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,"/**
     * Create a new encoder for the specified left and right atoms. The parent
     * is the atom which is connected by a double bond to the left and right
     * atom. For simple double bonds the parent of each is the other atom, in
     * cumulenes the parents are not the same.
     *
     * @param container   the molecule
     * @param left        the left atom
     * @param leftParent  the left atoms parent (usually {@literal right})
     * @param right       the right atom
     * @param rightParent the right atoms parent (usually {@literal left})
     * @param graph       adjacency list representation of the molecule
     * @return a stereo encoder (or null)
     */",94-146,"('newEncoder', {'INSTRUCTION': {'covered': 109, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",254.0,12.0,Create a new encoder for the specified left and right atoms.,"Given a left and right atoms, return a stereo encoder for them. The parent is the atom connected by a double bond to the two atoms. In case of simple double bonds the parent is the other atom.",The left and right atoms are specified.,0.232184564051873,Create a new encoder for the specified left and right atoms.
427,cdk,"static String chargeAdjunctText(final int charge, final int unpaired){
    StringBuilder sb = new StringBuilder();
    if (unpaired == 1) {
        if (charge != 0) {
            sb.append('(').append(BULLET).append(')');
        } else {
            sb.append(BULLET);
        }
    } else if (unpaired > 1) {
        if (charge != 0) {
            sb.append('(').append(unpaired).append(BULLET).append(')');
        } else {
            sb.append(unpaired).append(BULLET);
        }
    }
    final char sign = charge < 0 ? MINUS : PLUS;
    final int coefficient = Math.abs(charge);
    if (coefficient > 1)
        sb.append(coefficient);
    if (coefficient > 0)
        sb.append(sign);
    return sb.toString();
}",chargeAdjunctText,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,"/**
     * Create the charge adjunct text for the specified charge and number of unpaired electrons.
     *
     * @param charge   formal charge
     * @param unpaired number of unpaired electrons
     * @return adjunct text
     */",605-636,"('chargeAdjunctText', {'INSTRUCTION': {'covered': 70, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",175.0,15.0,Create the charge adjunct text for the specified charge and number of unpaired electrons.,"Given a formal charge and the unpaired number of electrons, it creates the adjunct text.",The charge and number of unpaired electrons are the specified charges.,0.298585373510349,Create the charge addition text for the specified charge and the number of unpaired electrons.
429,glowstone,"public static float randomReal(float range){
    ThreadLocalRandom rand = ThreadLocalRandom.current();
    return (2.0F * rand.nextFloat() - 1.0F) * range;
}",randomReal,net/glowstone/util/SoundUtil.java,/src/main/java/net/glowstone/util/SoundUtil.java,"/**
     * Generates a random float between {@code -range} and {@code range}.
     *
     * @param range the bounds of the random float.
     * @return A randomly generated float.
     */",86-95,"('randomReal', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,17.0,Generates a random float between {@code -range} and {@code range}.,"Given a range of two floats, the method returns a random float in the range.",A random float is generated between @code -range and @code range.,0.551772747519207,Generates a random float between {@code -range} and {@code range}.
430,openapi-generator,"private static ValidationRule.Result apacheNginxHeaderCheck(ParameterWrapper parameterWrapper){
    Parameter parameter = parameterWrapper.getParameter();
    if (parameter == null || !""header"".equals(parameter.getIn()))
        return ValidationRule.Pass.empty();
    ValidationRule.Result result = ValidationRule.Pass.empty();
    String headerName = parameter.getName();
    if (StringUtils.isNotEmpty(headerName) && StringUtils.contains(headerName, '_')) {
        result = new ValidationRule.Fail();
        result.setDetails(String.format(Locale.ROOT, ""%s contains an underscore."", headerName));
    }
    return result;
}",apacheNginxHeaderCheck,org/openapitools/codegen/validations/oas/OpenApiParameterValidations.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/validations/oas/OpenApiParameterValidations.java,"/**
     * Apache and Nginx default to legacy CGI behavior in which header with underscore are ignored. Raise this for awareness to the user.
     *
     * @param parameter Any spec doc parameter. The method will handle {@link HeaderParameter} evaluation.
     * @return {@link ValidationRule.Pass} if the check succeeds, otherwise {@link ValidationRule.Fail} with details ""[key] contains an underscore.""
     */",29-47,"('apacheNginxHeaderCheck', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",120.0,16.0,Apache and Nginx default to legacy CGI behavior in which header with underscore are ignored.,"Returns ValidationRule.Pass if the chek of the Apache and Nginx default to legacy CGI behavior is OK, ValidationRule.Fail otherwise.",The legacy behavior of Apache and Nginx is ignored.,1.39901976590337,Apache and Nginx use legacy CGI behavior by default in which the underscore header is ignored.
431,acs-aem-commons,"public void disableIndex(@Nonnull Resource oakIndex) throws PersistenceException{
    final ModifiableValueMap oakIndexProperties = oakIndex.adaptTo(ModifiableValueMap.class);
    oakIndexProperties.put(PN_TYPE, DISABLED);
    log.info(""Disabled index at {}"", oakIndex.getPath());
}",disableIndex,com/adobe/acs/commons/oak/impl/EnsureOakIndexJobHandler.java,/bundle/src/main/java/com/adobe/acs/commons/oak/impl/EnsureOakIndexJobHandler.java,"/**
     * Disables an index, so it's no longer updated by Oak.
     *
     * @param oakIndex the index
     * @throws PersistenceException
     */",474-485,"('disableIndex', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,13.0,"Disables an index, so it's no longer updated by Oak.","Given an oakIndex, the method disables it so that Oak will not update it anymore.",Oak has disabled an index so it's no longer updated.,0.422592211603339,Disables an index so that it is no longer updated by Oak.
433,metrics,"public void addListener(HealthCheckRegistryListener listener){
    listeners.add(listener);
    for (Map.Entry<String, HealthCheck> entry : healthChecks.entrySet()) {
        listener.onHealthCheckAdded(entry.getKey(), entry.getValue());
    }
}",addListener,io/dropwizard/metrics5/health/HealthCheckRegistry.java,/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/HealthCheckRegistry.java,"/**
     * Adds a {@link HealthCheckRegistryListener} to a collection of listeners that will be notified on health check
     * registration. Listeners will be notified in the order in which they are added. The listener will be notified of all
     * existing health checks when it first registers.
     *
     * @param listener listener to add
     */",68-80,"('addListener', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,21.0,Adds a {@link HealthCheckRegistryListener} to a collection of listeners that will be notified on health check  registration.,"Adds the HealthCheckRegistryListener to the listeners notified, following the order in which they are added, during the registration of health check",A collection of listeners that will be notified on health check registration has been added.,0.211016938309729,Adds a {@link HealthCheckRegistryListener} to a collection of listeners that will be notified when the health check is saved.
434,jackson-databind,"public static TextNode valueOf(String v){
    if (v == null) {
        return null;
    }
    if (v.isEmpty()) {
        return EMPTY_STRING_NODE;
    }
    return new TextNode(v);
}",valueOf,com/fasterxml/jackson/databind/node/TextNode.java,/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java,"/**
     * Factory method that should be used to construct instances.
     * For some common cases, can reuse canonical instances: currently
     * this is the case for empty Strings, in future possible for
     * others as well. If null is passed, will return null.
     *
     * @return Resulting {@link TextNode} object, if <b>v</b>
     *   is NOT null; null if it is.
     */",27-45,"('valueOf', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,10.0,Factory method that should be used to construct instances.,"This factory method is used to create instances, using canonical instances for common cases (only Strings at the moment). If we pass null, it returns null.",The factory method should be used to build instances.,0.510732829548495,The factory method that must be used to build instances.
435,cdk,"public BitSet projectG2(BitSet set){
    BitSet projection = new BitSet(getSecondGraphSize());
    CDKRNode xNode = null;
    for (int x = set.nextSetBit(0); x >= 0; x = set.nextSetBit(x + 1)) {
        xNode = getGraph().get(x);
        projection.set(xNode.getRMap().getId2());
    }
    return projection;
}",projectG2,org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,"/**
     *  Projects a CDKRGraph bitset on the source graph G2.
     * @param  set  CDKRGraph BitSet to project
     * @return      The associate BitSet in G2
     */",546-560,"('projectG2', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",83.0,10.0,Projects a CDKRGraph bitset on the source graph G2.,"Given the source graph G2, the function projects a CDKRGraph bitset.",The bitset is on the source graph G2.,0.209183538563358,Projects a CDKRGraph bit set onto the G2 source graphic.
436,cdk,"private boolean isMacroCycle(IRing ring, IRingSet rs){
    if (ring.getAtomCount() < 8)
        return false;
    for (IBond bond : ring.bonds()) {
        boolean found = false;
        for (IAtomContainer other : rs.atomContainers()) {
            if (ring == other)
                continue;
            if (other.contains(bond)) {
                found = true;
                break;
            }
        }
        if (!found)
            return true;
    }
    return false;
}",isMacroCycle,org/openscience/cdk/layout/StructureDiagramGenerator.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/StructureDiagramGenerator.java,"/**
     * Check if a ring in a ring set is a macro cycle. We define this as a
     * ring with >= 10 atom and has at least one bond that isn't contained
     * in any other rings.
     *
     * @param ring ring to check
     * @param rs   rest of ring system
     * @return ring is a macro cycle
     */",1801-1827,"('isMacroCycle', {'INSTRUCTION': {'covered': 43, 'missed': 6}, 'BRANCH': {'covered': 9, 'missed': 3}, 'LINE': {'covered': 11, 'missed': 4}, 'COMPLEXITY': {'covered': 4, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,13.0,Check if a ring in a ring set is a macro cycle.,"Verify if a defined ring, in a ring set, is a macro cycle. It is defined like a ring with more than 10 atoms with at least one bond that is not contained in other rings.","If a ring is a macro cycle, you should check it.",0.209778343070917,Check if a ring in a set of rings is a macro cycle.
438,egeria,"public void addCollectionMembershipRelationship(String userId, String processGUID, String collectionGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    dataEngineCommonHandler.upsertExternalRelationship(userId, processGUID, collectionGUID, REFERENCEABLE_TO_COLLECTION_TYPE_NAME, COLLECTION_TYPE_NAME, externalSourceName, null);
}",addCollectionMembershipRelationship,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCollectionHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCollectionHandler.java,"/**
     * Create CollectionMembership relationships between a Process asset and a Collection. Verifies that the
     * relationship is not present before creating it
     *
     * @param userId             the name of the calling user
     * @param processGUID        the unique identifier of the process
     * @param collectionGUID     the unique identifier of the collection
     * @param externalSourceName the unique name of the external source
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",110-130,"('addCollectionMembershipRelationship', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",43.0,11.0,Create CollectionMembership relationships between a Process asset and a Collection.,"Given a Process and a Collection, create a relationship called CollectionMembership if it is not already present.",CollectionMembership relationships are created between a Process asset and a collection.,0.33226790238063,Create CollectionMembership relationships between a Process resource and a collection.
439,jackson-databind,"public static Class<?> wrapperType(Class<?> primitiveType){
    if (primitiveType == Integer.TYPE) {
        return Integer.class;
    }
    if (primitiveType == Long.TYPE) {
        return Long.class;
    }
    if (primitiveType == Boolean.TYPE) {
        return Boolean.class;
    }
    if (primitiveType == Double.TYPE) {
        return Double.class;
    }
    if (primitiveType == Float.TYPE) {
        return Float.class;
    }
    if (primitiveType == Byte.TYPE) {
        return Byte.class;
    }
    if (primitiveType == Short.TYPE) {
        return Short.class;
    }
    if (primitiveType == Character.TYPE) {
        return Character.class;
    }
    throw new IllegalArgumentException(""Class "" + primitiveType.getName() + "" is not a primitive type"");
}",wrapperType,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * Helper method for finding wrapper type for given primitive type (why isn't
     * there one in JDK?).
     * NOTE: throws {@link IllegalArgumentException} if given type is NOT primitive
     * type (caller has to check).
     */",876-909,"('wrapperType', {'INSTRUCTION': {'covered': 55, 'missed': 0}, 'BRANCH': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",151.0,21.0,Helper method for finding wrapper type for given primitive type (why isn't  there one in JDK?).,"Starting with a given primitive type, this helper method can find the wrapper type.",There is a method for finding a wrapper type.,0.315737203659688,Help method to find the wrapper type for a given primitive type (why isn't there one in JDK?).
440,acs-aem-commons,"private boolean isDispatcherHeaders(final Agent agent){
    final ValueMap properties = agent.getConfiguration().getProperties();
    final String[] headers = properties.get(AgentConfig.PROTOCOL_HTTP_HEADERS, new String[] {});
    for (final String header : headers) {
        if (StringUtils.startsWith(header, CQ_ACTION_HEADER)) {
            return true;
        }
    }
    return false;
}",isDispatcherHeaders,com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,"/**
     * Checks if the agent has a valid dispatcher headers.
     *
     * @param agent Agent to check
     * @return true if the Agent's headers contain the proper values
     */",155-172,"('isDispatcherHeaders', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,10.0,Checks if the agent has a valid dispatcher headers.,Verifies whether in the agent there are valid dispatcher headers.,The agent is checked if he has a valid dispatch.,0.931881377386189,Checks whether the agent has valid dispatcher headers.
441,matsim-libs,"private double findMinimalDistance(double minimalAdditionalDistance, double possibleAdditionalDistance){
    if (minimalAdditionalDistance == 0)
        minimalAdditionalDistance = possibleAdditionalDistance;
    else if (possibleAdditionalDistance < minimalAdditionalDistance)
        minimalAdditionalDistance = possibleAdditionalDistance;
    return minimalAdditionalDistance;
}",findMinimalDistance,org/matsim/contrib/freight/jsprit/DistanceConstraint.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/jsprit/DistanceConstraint.java,"/**
	 * Checks if the find possible distance is the minimal one.
	 *
	 * @param minimalAdditionalDistance
	 * @param possibleAdditionalDistance
	 * @return the minimal transport distance
	 */",287-300,"('findMinimalDistance', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,11.0,Checks if the find possible distance is the minimal one.,Verifies if the distance we found is the minimal one.,"If the find is minimal, it's checked.",0.123801918846869,Checks if the possible distance is minimal.
442,cdk,"public String toString(){
    StringBuffer resultString = new StringBuffer(32);
    resultString.append(""Bond("").append(this.hashCode());
    if (getOrder() != null) {
        resultString.append("", #O:"").append(getOrder());
    }
    resultString.append("", #S:"").append(getStereo());
    if (getAtomCount() > 0) {
        resultString.append("", #A:"").append(getAtomCount());
        for (int i = 0; i < atomCount; i++) {
            resultString.append("", "").append(atoms[i] == null ? ""null"" : atoms[i].toString());
        }
    }
    resultString.append("", "").append(super.toString());
    resultString.append(')');
    return resultString.toString();
}",toString,org/openscience/cdk/silent/Bond.java,/base/silent/src/main/java/org/openscience/cdk/silent/Bond.java,"/**
     * Returns a one line string representation of this Container. This method is
     * conform RFC #9.
     *
     * @return The string representation of this Container
     */",584-607,"('toString', {'INSTRUCTION': {'covered': 76, 'missed': 2}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",168.0,10.0,Returns a one line string representation of this Container.,Represent the Container using a string of one line.,A one line string representation of this container is returned.,0.302895802147426,Returns a string representation of a row in this container.
443,cdk,"private Edge findDirectionalEdge(Graph g, int u){
    List<Edge> edges = g.edges(u);
    if (edges.size() == 1)
        return null;
    Edge first = null;
    for (Edge e : edges) {
        Bond b = e.bond();
        if (b == Bond.UP || b == Bond.DOWN) {
            if (first == null)
                first = e;
            else if (((first.either() == e.either()) == (first.bond() == b)))
                return null;
        }
    }
    return first;
}",findDirectionalEdge,org/openscience/cdk/smiles/BeamToCDK.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/BeamToCDK.java,"/**
     * Utility for find the first directional edge incident to a vertex. If
     * there are no directional labels then null is returned.
     *
     * @param g graph from Beam
     * @param u the vertex for which to find
     * @return first directional edge (or null if none)
     */",419-442,"('findDirectionalEdge', {'INSTRUCTION': {'covered': 54, 'missed': 3}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 12, 'missed': 1}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",122.0,12.0,Utility for find the first directional edge incident to a vertex.,"This utility can be used for finding the first directional edge that is incident to a vertex, returning null if no directional labels can be found.",The first incident to a vertex is a utility.,0.415331338494571,Utility to find the first directional edge incident at a vertex.
444,weblogic-kubernetes-operator,"public boolean matchesYaml(String yaml){
    final String thisJson = toJson();
    final String otherJson = createFromYaml(yaml).toJson();
    return JsonParser.parseString(thisJson).equals(JsonParser.parseString(otherJson));
}",matchesYaml,oracle/kubernetes/weblogic/domain/model/MonitoringExporterConfiguration.java,/operator/src/main/java/oracle/kubernetes/weblogic/domain/model/MonitoringExporterConfiguration.java,"/**
   * Returns true if the specified YAML string matches this configuration, ignoring unknown fields
   * and field ordering. Note that ordering of elements in arrays is considered significant for this comparison.
   * @param yaml a monitoring exporter configuration to compare to this object.
   */",58-67,"('matchesYaml', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,18.0,"Returns true if the specified YAML string matches this configuration, ignoring unknown fields  and field ordering.","If the specified YAML string matches the configuration (ignoring fields that are unknown and the order of fields), the function returns true","If the specified YAML string matches the configuration, returns true.",0.330182835182501,"Returns true if the specified YAML string matches this configuration, ignoring unknown fields and field order."
445,tablesaw,"DoubleColumn logN(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[logN]"", size());
    for (int i = 0; i < size(); i++) {
        newColumn.set(i, Math.log(getDouble(i)));
    }
    return newColumn;
}",logN,tech/tablesaw/columns/numbers/NumberMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/numbers/NumberMapFunctions.java,/** Returns the natural log of the values in this column as a NumberColumn. */,275-283,"('logN', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",62.0,14.0,Returns the natural log of the values in this column as a NumberColumn.,Fill a NumeralColumn with the natural log of the value in this column.,The log of values in this column is a NumberColumn.,0.0857088444965321,Returns the natural log of values in this column as a NumberColumn column.
446,tablesaw,"StringColumn yearDay(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & month"");
    for (int r = 0; r < this.size(); r++) {
        long c1 = this.getLongInternal(r);
        if (DateTimeColumn.valueIsMissing(c1)) {
            newColumn.append(StringColumnType.missingValueIndicator());
        } else {
            String ym = String.valueOf(getYear(c1));
            ym = ym + ""-"" + Strings.padStart(String.valueOf(getDayOfYear(c1)), 3, '0');
            newColumn.append(ym);
        }
    }
    return newColumn;
}",yearDay,tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,"/**
   * Returns a StringColumn with the year and day-of-year derived from this column concatenated into
   * a String that will sort lexicographically in temporal order.
   *
   * <p>This simplifies the production of plots and tables that aggregate values into standard
   * temporal units (e.g., you want monthly data but your source data is more than a year long and
   * you don't want months from different years aggregated together).
   */",238-259,"('yearDay', {'INSTRUCTION': {'covered': 52, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",125.0,24.0,Returns a StringColumn with the year and day-of-year derived from this column concatenated into  a String that will sort lexicographically in temporal order.,Creates a StringColumn containing the year and the day of the year and sort the column lexicographically in temporal order.,The year and day-of-year derived from this column will be used to sort the string by temporal order.,0.366824091968015,Returns a StringColumn with the year and day of the year derived from this column concatenated into a String that will sort lexicographically in temporal order.
447,cdk,"public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
    neighboors = ac.getConnectedAtomsList(atom);
    IAtomContainer clone;
    try {
        clone = (IAtomContainer) ac.clone();
    } catch (CloneNotSupportedException e) {
        return getDummyDescriptorValue(e);
    }
    try {
        peoe = new GasteigerMarsiliPartialCharges();
        peoe.setMaxGasteigerIters(6);
        peoe.assignGasteigerMarsiliSigmaPartialCharges(clone, true);
    } catch (Exception exception) {
        return getDummyDescriptorValue(exception);
    }
    IAtom localAtom = clone.getAtom(ac.indexOf(atom));
    neighboors = clone.getConnectedAtomsList(localAtom);
    DoubleArrayResult protonPartialCharge = new DoubleArrayResult(MAX_PROTON_COUNT);
    assert (neighboors.size() < MAX_PROTON_COUNT);
    protonPartialCharge.add(localAtom.getCharge());
    int hydrogenNeighbors = 0;
    for (IAtom neighboor : neighboors) {
        if (neighboor.getAtomicNumber() == IElement.H) {
            hydrogenNeighbors++;
            protonPartialCharge.add(neighboor.getCharge());
        }
    }
    int remainder = MAX_PROTON_COUNT - (hydrogenNeighbors + 1);
    for (int i = 0; i < remainder; i++) protonPartialCharge.add(Double.NaN);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), protonPartialCharge, getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/atomic/ProtonTotalPartialChargeDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/ProtonTotalPartialChargeDescriptor.java,"/**
     *  The method returns partial charges assigned to an heavy atom and its protons through Gasteiger Marsili
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *
     *@param  atom              The IAtom for which the DescriptorValue is requested
     *@param  ac                AtomContainer
     *@return                   an array of doubles with partial charges of [heavy, proton_1 ... proton_n]
     */",109-160,"('calculate', {'INSTRUCTION': {'covered': 107, 'missed': 14}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 23, 'missed': 4}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",244.0,29.0,The method returns partial charges assigned to an heavy atom and its protons through Gasteiger Marsili  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.,"Given a heavy atom, it returns the partial charges assigned and the protons through Gasteiger Marsili. You have to call addExplicitHydrogensToSatisfyValency method, defined in the class tools.HydrogenAdder.",The method returns partial charges assigned to an heavy atom and its protons through Gasteiger Marsili.,0.419789465673351,The method returns partial charges assigned to a heavy atom and its protons via Gasteiger Marsili It is necessary to call the addExplicit methodHydrogensToSatisfyValency from the class tools.
448,cdk,"private IAtom[] pushHydrogensToBack(IAtomContainer mol, Map<IChemObject, Integer> atomToIdx){
    assert atomToIdx.isEmpty();
    IAtom[] atoms = new IAtom[mol.getAtomCount()];
    for (IAtom atom : mol.atoms()) {
        if (atom.getAtomicNumber() == 1)
            continue;
        atoms[atomToIdx.size()] = atom;
        atomToIdx.put(atom, atomToIdx.size() + 1);
    }
    for (IAtom atom : mol.atoms()) {
        if (atom.getAtomicNumber() != 1)
            continue;
        atoms[atomToIdx.size()] = atom;
        atomToIdx.put(atom, atomToIdx.size() + 1);
    }
    return atoms;
}",pushHydrogensToBack,org/openscience/cdk/io/MDLV3000Writer.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV3000Writer.java,"/**
     * CTfile specification is ambiguous as to how parity values should be written
     * for implicit hydrogens. Old applications (Symyx Draw) seem to push any
     * hydrogen to (implied) the last position but newer applications
     * (Accelrys/BioVia Draw) only do so for implicit hydrogens (makes more sense).
     * 
     * To avoid the ambiguity for those who read 0D stereo (bad anyways) we
     * actually do push all hydrogens atoms to the back of the atom list giving
     * them highest value (4) when writing parity values.
     *
     * @param mol       molecule
     * @param atomToIdx mapping that will be filled with the output index
     * @return the output order of atoms
     */",478-508,"('pushHydrogensToBack', {'INSTRUCTION': {'covered': 75, 'missed': 4}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",146.0,16.0,CTfile specification is ambiguous as to how parity values should be written  for implicit hydrogens.,"Since the old CTfile specification is ambiguous in the way in which parity values are written for implicit hydrogens, we actually push all hydrogens atoms at the end of the atom list and assigning them the highest value (4) for the parity values.",The specification for the CTfile is ambiguous.,0.274792717248591,The CTfile specification is ambiguous as to how parity values should be written for implicit hydrogens.
450,jackson-databind,"public static NameTransformer simpleTransformer(final String prefix, final String suffix){
    boolean hasPrefix = (prefix != null) && !prefix.isEmpty();
    boolean hasSuffix = (suffix != null) && !suffix.isEmpty();
    if (hasPrefix) {
        if (hasSuffix) {
            return new NameTransformer() {

                @Override
                public String transform(String name) {
                    return prefix + name + suffix;
                }

                @Override
                public String reverse(String transformed) {
                    if (transformed.startsWith(prefix)) {
                        String str = transformed.substring(prefix.length());
                        if (str.endsWith(suffix)) {
                            return str.substring(0, str.length() - suffix.length());
                        }
                    }
                    return null;
                }

                @Override
                public String toString() {
                    return ""[PreAndSuffixTransformer('"" + prefix + ""','"" + suffix + ""')]"";
                }
            };
        }
        return new NameTransformer() {

            @Override
            public String transform(String name) {
                return prefix + name;
            }

            @Override
            public String reverse(String transformed) {
                if (transformed.startsWith(prefix)) {
                    return transformed.substring(prefix.length());
                }
                return null;
            }

            @Override
            public String toString() {
                return ""[PrefixTransformer('"" + prefix + ""')]"";
            }
        };
    }
    if (hasSuffix) {
        return new NameTransformer() {

            @Override
            public String transform(String name) {
                return name + suffix;
            }

            @Override
            public String reverse(String transformed) {
                if (transformed.endsWith(suffix)) {
                    return transformed.substring(0, transformed.length() - suffix.length());
                }
                return null;
            }

            @Override
            public String toString() {
                return ""[SuffixTransformer('"" + suffix + ""')]"";
            }
        };
    }
    return NOP;
}",simpleTransformer,com/fasterxml/jackson/databind/util/NameTransformer.java,/src/main/java/com/fasterxml/jackson/databind/util/NameTransformer.java,"/**
     * Factory method for constructing a simple transformer based on
     * prefix and/or suffix.
     */",35-93,"('simpleTransformer', {'INSTRUCTION': {'covered': 42, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",346.0,13.0,Factory method for constructing a simple transformer based on  prefix and/or suffix.,The method is used for creating a simple transformer with prefix and/or suffix.,A simple transformer is constructed using the factory method.,0.305550167763403,Factory method to build a simple transformer based on a prefix and/or suffix.
451,matsim-libs,"public static double convertHHMMInteger(int hhmm){
    int h = hhmm / 100;
    int m = hhmm - (h * 100);
    double seconds = Math.abs(h) * 3600 + m * 60;
    return seconds;
}",convertHHMMInteger,org/matsim/core/utils/misc/Time.java,/matsim/src/main/java/org/matsim/core/utils/misc/Time.java,"/**
	 * Converts a number like 1634 to the time value of 16:34:00.
	 * 
	 * @param hhmm the time-representing number to convert.
	 * @return the time as seconds after midnight.
	 */",227-238,"('convertHHMMInteger', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,12.0,Converts a number like 1634 to the time value of 16:34:00.,"Given a number like 1634, the function converts it into time value, 16:34:00 in this case.",The time value is 16:34:00.,0.174594422286125,Converts a number like 1634 to a time value of 16:34:00.
452,cdk,"public static int convertBondOrder(IBond bond){
    int value = 0;
    switch(bond.getOrder()) {
        case QUADRUPLE:
            value = 4;
            break;
        case TRIPLE:
            value = 3;
            break;
        case DOUBLE:
            value = 2;
            break;
        case SINGLE:
            value = 1;
            break;
        default:
            value = 0;
    }
    return value;
}",convertBondOrder,org/openscience/cdk/smsd/filters/ChemicalFilters.java,/legacy/src/main/java/org/openscience/cdk/smsd/filters/ChemicalFilters.java,"/**
     * Get bond order value as {@code int} value.
     *
     * @param  bond The {@link IBond} for which the order is returned.
     * @return      1 for a single bond, 2 for a double bond, 3 for a triple bond, 4 for a quadruple bond,
     *              and 0 for any other bond type.
     */",841-867,"('convertBondOrder', {'INSTRUCTION': {'covered': 18, 'missed': 6}, 'BRANCH': {'covered': 3, 'missed': 2}, 'LINE': {'covered': 8, 'missed': 4}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",70.0,12.0,Get bond order value as {@code int} value.,"Given a bond iBond, it returns the order value of the bond.",Get the bond order value.,0.1891197143153,Get the value of the bond order as the value {@code int}.
453,anserini,"public SortedMap<Integer, Map<String, String>> read(BufferedReader bRdr) throws IOException{
    SortedMap<Integer, Map<String, String>> map = new TreeMap<>();
    Map<String, String> fields = new HashMap<>();
    String number = """";
    Matcher m;
    String line;
    while ((line = bRdr.readLine()) != null) {
        line = line.trim();
        if (line.startsWith(""<num>"") && line.endsWith(""</num>"")) {
            m = NUM_PATTERN.matcher(line);
            if (!m.find()) {
                throw new IOException(""Error parsing "" + line);
            }
            number = m.group(1);
        }
        if (line.startsWith(""<query>"") && line.endsWith(""</query>"") || line.startsWith(""<title>"") && line.endsWith(""</title>"")) {
            m = TITLE_PATTERN.matcher(line);
            if (!m.find()) {
                m = TITLE_PATTERN2.matcher(line);
                if (!m.find()) {
                    throw new IOException(""Error parsing "" + line);
                }
            }
            fields.put(""title"", m.group(1));
        }
        if (line.startsWith(""<querytweettime>"") && line.endsWith(""</querytweettime>"")) {
            m = TWEETTIME_PATTERN.matcher(line);
            if (!m.find()) {
                throw new IOException(""Error parsing "" + line);
            }
            fields.put(""time"", m.group(1));
        }
        if (line.startsWith(""</top>"")) {
            map.put(Integer.valueOf(number), fields);
            fields = new HashMap<>();
        }
    }
    return map;
}",read,io/anserini/search/topicreader/MicroblogTopicReader.java,/src/main/java/io/anserini/search/topicreader/MicroblogTopicReader.java,"/**
   * Read topics of TREC Microblog Tracks from 2011 to 2014 including:
   * topics.microblog2011.txt
   * topics.microblog2012.txt
   * topics.microblog2013.txt
   * topics.microblog2014.txt
   * @return SortedMap where keys are query/topic IDs and values are title portions of the topics
   * @throws IOException any io exception
   */",47-98,"('read', {'INSTRUCTION': {'covered': 113, 'missed': 18}, 'BRANCH': {'covered': 21, 'missed': 7}, 'LINE': {'covered': 24, 'missed': 3}, 'COMPLEXITY': {'covered': 8, 'missed': 7}, 'METHOD': {'covered': 1, 'missed': 0}})",340.0,14.0,Read topics of TREC Microblog Tracks from 2011 to 2014 including:  topics.,Read from TREC Microblog Tracks published between 2011 and 2014 different topics and return a SortedMap where the keys are query/topic IDs and the values are the title.,The topics of the TREC Microblog Tracks from 2011 to 2014 are listed below.,0.681436977122317,"Read the topics of TREC Microblog Tracks from 2011 to 2014, including: the topics."
454,matsim-libs,"public static void copyStream(final InputStream fromStream, final OutputStream toStream) throws UncheckedIOException{
    try {
        byte[] buffer = new byte[4096];
        int bytesRead;
        while ((bytesRead = fromStream.read(buffer)) != -1) {
            toStream.write(buffer, 0, bytesRead);
        }
    } catch (IOException e) {
        throw new UncheckedIOException(e);
    }
}",copyStream,org/matsim/core/utils/io/IOUtils.java,/matsim/src/main/java/org/matsim/core/utils/io/IOUtils.java,"/**
	 * Copies the content from one stream to another stream.
	 *
	 * @param fromStream The stream containing the data to be copied
	 * @param toStream   The stream the data should be written to
	 * 
	 * @throws UncheckedIOException
	 */",378-398,"('copyStream', {'INSTRUCTION': {'covered': 18, 'missed': 6}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,10.0,Copies the content from one stream to another stream.,"Given a stream, the method copies the content to another stream.",The content from one stream to another is copied.,0.462459323366171,Copies content from one stream to another.
455,logstash-logback-encoder,"private void appendPlaceHolder(StringBuilder builder, int indent, int consecutiveExcluded, String message){
    indent(builder, indent);
    builder.append(ELLIPSIS).append("" "").append(consecutiveExcluded).append("" "").append(message).append(CoreConstants.LINE_SEPARATOR);
}",appendPlaceHolder,net/logstash/logback/stacktrace/ShortenedThrowableConverter.java,/src/main/java/net/logstash/logback/stacktrace/ShortenedThrowableConverter.java,"/**
     * Appends a placeholder indicating that some frames were not written.
     */",460-471,"('appendPlaceHolder', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",59.0,11.0,Appends a placeholder indicating that some frames were not written.,"For indicating that some frames were not written in the StringBuilder, append a placeholder.",The appended information indicates that some frames were not written.,0.478800967442818,Adds a placeholder indicating that some images have not been written.
456,matsim-libs,"public void addCoreModules(){
    this.global = new GlobalConfigGroup();
    this.modules.put(GlobalConfigGroup.GROUP_NAME, this.global);
    this.controler = new ControlerConfigGroup();
    this.modules.put(ControlerConfigGroup.GROUP_NAME, this.controler);
    this.qSimConfigGroup = new QSimConfigGroup();
    this.modules.put(QSimConfigGroup.GROUP_NAME, this.qSimConfigGroup);
    this.counts = new CountsConfigGroup();
    this.modules.put(CountsConfigGroup.GROUP_NAME, this.counts);
    this.charyparNagelScoring = new PlanCalcScoreConfigGroup();
    this.modules.put(PlanCalcScoreConfigGroup.GROUP_NAME, this.charyparNagelScoring);
    this.network = new NetworkConfigGroup();
    this.modules.put(NetworkConfigGroup.GROUP_NAME, this.network);
    this.plans = new PlansConfigGroup();
    this.modules.put(PlansConfigGroup.GROUP_NAME, this.plans);
    this.households = new HouseholdsConfigGroup();
    this.modules.put(HouseholdsConfigGroup.GROUP_NAME, this.households);
    this.parallelEventHandling = new ParallelEventHandlingConfigGroup();
    this.modules.put(ParallelEventHandlingConfigGroup.GROUP_NAME, this.parallelEventHandling);
    this.facilities = new FacilitiesConfigGroup();
    this.modules.put(FacilitiesConfigGroup.GROUP_NAME, this.facilities);
    this.strategy = new StrategyConfigGroup();
    this.modules.put(StrategyConfigGroup.GROUP_NAME, this.strategy);
    this.travelTimeCalculatorConfigGroup = new TravelTimeCalculatorConfigGroup();
    this.modules.put(TravelTimeCalculatorConfigGroup.GROUPNAME, this.travelTimeCalculatorConfigGroup);
    this.scenarioConfigGroup = new ScenarioConfigGroup();
    this.modules.put(ScenarioConfigGroup.GROUP_NAME, this.scenarioConfigGroup);
    this.plansCalcRoute = new PlansCalcRouteConfigGroup();
    this.modules.put(PlansCalcRouteConfigGroup.GROUP_NAME, this.plansCalcRoute);
    this.timeAllocationMutator = new TimeAllocationMutatorConfigGroup();
    this.modules.put(TimeAllocationMutatorConfigGroup.GROUP_NAME, this.timeAllocationMutator);
    this.vspExperimentalGroup = new VspExperimentalConfigGroup();
    this.modules.put(VspExperimentalConfigGroup.GROUP_NAME, this.vspExperimentalGroup);
    this.ptCounts = new PtCountsConfigGroup();
    this.modules.put(PtCountsConfigGroup.GROUP_NAME, this.ptCounts);
    this.transit = new TransitConfigGroup();
    this.modules.put(TransitConfigGroup.GROUP_NAME, this.transit);
    this.linkStats = new LinkStatsConfigGroup();
    this.modules.put(LinkStatsConfigGroup.GROUP_NAME, this.linkStats);
    this.transitRouter = new TransitRouterConfigGroup();
    this.modules.put(TransitRouterConfigGroup.GROUP_NAME, this.transitRouter);
    this.subtourModeChoice = new SubtourModeChoiceConfigGroup();
    this.modules.put(SubtourModeChoiceConfigGroup.GROUP_NAME, this.subtourModeChoice);
    this.vehicles = new VehiclesConfigGroup();
    this.modules.put(VehiclesConfigGroup.GROUP_NAME, this.vehicles);
    this.changeMode = new ChangeModeConfigGroup();
    this.modules.put(ChangeModeConfigGroup.CONFIG_MODULE, this.changeMode);
    this.modules.put(ChangeLegModeConfigGroup.CONFIG_MODULE, new ChangeLegModeConfigGroup());
    // only to provide error messages. kai, may'16
    this.jdeqSim = new JDEQSimConfigGroup();
    this.modules.put(JDEQSimConfigGroup.NAME, this.jdeqSim);
    this.hermes = new HermesConfigGroup();
    this.modules.put(HermesConfigGroup.NAME, this.hermes);
    this.addConfigConsistencyChecker(new VspConfigConsistencyCheckerImpl());
    this.addConfigConsistencyChecker(new UnmaterializedConfigGroupChecker());
    this.addConfigConsistencyChecker(new BeanValidationConfigConsistencyChecker());
}",addCoreModules,org/matsim/core/config/Config.java,/matsim/src/main/java/org/matsim/core/config/Config.java,"/**
	 * Adds all the commonly used config-groups, also known as ""core modules"",
	 * to this config-instance. This should be called before reading any
	 * configuration from file.
	 */",112-200,"('addCoreModules', {'INSTRUCTION': {'covered': 324, 'missed': 0}, 'LINE': {'covered': 55, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",653.0,19.0,"Adds all the commonly used config-groups, also known as ""core modules"",  to this config-instance.","Given a config-instance, add the ""core modules"", the common used config-groups","The config-group that is added to this config-instance is also known as a ""core modules"" group.",2.64570414637703,"Adds all commonly used configuration groups, also known as ""core modules,"" to this configuration instance."
457,cdk,"private static GeometryEncoder encoder(IDoubleBondStereochemistry dbs, Map<IAtom, Integer> atomToIndex, int[][] graph){
    IBond db = dbs.getStereoBond();
    int u = atomToIndex.get(db.getBegin());
    int v = atomToIndex.get(db.getEnd());
    IBond[] bs = dbs.getBonds();
    int[] us = new int[2];
    int[] vs = new int[2];
    us[0] = atomToIndex.get(bs[0].getOther(db.getBegin()));
    us[1] = graph[u].length == 2 ? u : findOther(graph[u], v, us[0]);
    vs[0] = atomToIndex.get(bs[1].getOther(db.getEnd()));
    vs[1] = graph[v].length == 2 ? v : findOther(graph[v], u, vs[0]);
    int parity = dbs.getStereo() == OPPOSITE ? +1 : -1;
    GeometricParity geomParity = GeometricParity.valueOf(parity);
    PermutationParity permParity = new CombinedPermutationParity(us[1] == u ? BasicPermutationParity.IDENTITY : new BasicPermutationParity(us), vs[1] == v ? BasicPermutationParity.IDENTITY : new BasicPermutationParity(vs));
    return new GeometryEncoder(new int[] { u, v }, permParity, geomParity);
}",encoder,org/openscience/cdk/hash/stereo/DoubleBondElementEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/DoubleBondElementEncoderFactory.java,"/**
     * Create an encoder for the {@link IDoubleBondStereochemistry} element.
     *
     * @param dbs          stereo element from an atom container
     * @param atomToIndex  map of atoms to indices
     * @param graph        adjacency list of connected vertices
     * @return a new geometry encoder
     */",74-117,"('encoder', {'INSTRUCTION': {'covered': 143, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",292.0,12.0,Create an encoder for the {@link IDoubleBondStereochemistry} element.,"Given the IDoubleBondStereochemistry, a stereo element from an atom container, create an encoder for it.",An Encoder is needed for the IDoubleBondStereochemistry element.,0.632106831071692,Create an encoder for the {@link IDoubleBondStereochemistry} element.
458,cdk,"static double adjacentLength(Vector2d hypotenuse, Vector2d adjacent, double oppositeLength){
    return Math.tan(hypotenuse.angle(adjacent)) * oppositeLength;
}",adjacentLength,org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,"/**
     * Given vectors for the hypotenuse and adjacent side of a right angled
     * triangle and the length of the opposite side, determine how long the
     * adjacent side size.
     *
     * @param hypotenuse vector for the hypotenuse
     * @param adjacent vector for the adjacent side
     * @param oppositeLength length of the opposite side of a triangle
     * @return length of the adjacent side
     */",210-222,"('adjacentLength', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,29.0,"Given vectors for the hypotenuse and adjacent side of a right angled  triangle and the length of the opposite side, determine how long the  adjacent side size.","Determine the length of the adjacent side of the provided vector for the hypotenus, the adjacent side of a triangle with a right angle, and the opposite side.",The length of the opposite side and the hypotenuse of the right triangle are given in the same way.,0.415205883251729,"Given the vectors of the hypotenuse and the adjacent side of a right-angled triangle and the length of the opposite side, determine the length of the size on the adjacent side."
459,twilio-java,"public static void validateSslCertificate(){
    final NetworkHttpClient client = new NetworkHttpClient();
    final Request request = new Request(HttpMethod.GET, ""https://api.twilio.com:8443"");
    try {
        final Response response = client.makeRequest(request);
        if (!TwilioRestClient.SUCCESS.test(response.getStatusCode())) {
            throw new CertificateValidationException(""Unexpected response from certificate endpoint"", request, response);
        }
    } catch (final ApiException e) {
        throw new CertificateValidationException(""Could not get response from certificate endpoint"", request);
    }
}",validateSslCertificate,com/twilio/Twilio.java,/src/main/java/com/twilio/Twilio.java,"/**
     * Validate that we can connect to the new SSL certificate posted on api.twilio.com.
     *
     * @throws CertificateValidationException if the connection fails
     */",229-249,"('validateSslCertificate', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,14.0,Validate that we can connect to the new SSL certificate posted on api.,Check if we can use the SSL certificate from api.twiliio.com for the connection.,We can connect to the new certificate if we verify that we can.,0.413126887869741,Verify that we can connect to the new SSL certificate published on the API.
460,liquibase,"private void parseDefaultPropertyFileFromResource(File potentialPropertyFile) throws IOException, CommandLineParsingException{
    try (InputStream resourceAsStream = getClass().getClassLoader().getResourceAsStream(potentialPropertyFile.getAbsolutePath())) {
        if (resourceAsStream != null) {
            parsePropertiesFile(resourceAsStream);
        }
    }
}",parseDefaultPropertyFileFromResource,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,"/**
     * Open a property file that is embedded as a Java resource and parse it.
     *
     * @param potentialPropertyFile location and file name of the property file
     * @throws IOException                 if the file cannot be opened
     * @throws CommandLineParsingException if an error occurs during parsing
     */",782-797,"('parseDefaultPropertyFileFromResource', {'INSTRUCTION': {'covered': 10, 'missed': 3}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",50.0,15.0,Open a property file that is embedded as a Java resource and parse it.,Open and parse a property file embedded as a Java resource.,You can open a property file that is embedded in a Java resource.,0.299277181594768,Open an embedded properties file as a Java resource and parse it.
461,openapi-generator,"private static void visitSchema(OpenAPI openAPI, Schema schema, String mimeType, List<String> visitedSchemas, OpenAPISchemaVisitor visitor){
    visitor.visit(schema, mimeType);
    if (schema.get$ref() != null) {
        String ref = getSimpleRef(schema.get$ref());
        if (!visitedSchemas.contains(ref)) {
            visitedSchemas.add(ref);
            Schema referencedSchema = getSchemas(openAPI).get(ref);
            if (referencedSchema != null) {
                visitSchema(openAPI, referencedSchema, mimeType, visitedSchemas, visitor);
            }
        }
    }
    if (schema instanceof ComposedSchema) {
        List<Schema> oneOf = ((ComposedSchema) schema).getOneOf();
        if (oneOf != null) {
            for (Schema s : oneOf) {
                visitSchema(openAPI, s, mimeType, visitedSchemas, visitor);
            }
        }
        List<Schema> allOf = ((ComposedSchema) schema).getAllOf();
        if (allOf != null) {
            for (Schema s : allOf) {
                visitSchema(openAPI, s, mimeType, visitedSchemas, visitor);
            }
        }
        List<Schema> anyOf = ((ComposedSchema) schema).getAnyOf();
        if (anyOf != null) {
            for (Schema s : anyOf) {
                visitSchema(openAPI, s, mimeType, visitedSchemas, visitor);
            }
        }
    } else if (schema instanceof ArraySchema) {
        Schema itemsSchema = ((ArraySchema) schema).getItems();
        if (itemsSchema != null) {
            visitSchema(openAPI, itemsSchema, mimeType, visitedSchemas, visitor);
        }
    } else if (isMapSchema(schema)) {
        Object additionalProperties = schema.getAdditionalProperties();
        if (additionalProperties instanceof Schema) {
            visitSchema(openAPI, (Schema) additionalProperties, mimeType, visitedSchemas, visitor);
        }
    }
    if (schema.getNot() != null) {
        visitSchema(openAPI, schema.getNot(), mimeType, visitedSchemas, visitor);
    }
    Map<String, Schema> properties = schema.getProperties();
    if (properties != null) {
        for (Schema property : properties.values()) {
            visitSchema(openAPI, property, mimeType, visitedSchemas, visitor);
        }
    }
}",visitSchema,org/openapitools/codegen/utils/ModelUtils.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ModelUtils.java,"/**
     * Invoke the specified visitor function for every schema that matches mimeType in the OpenAPI document.
     *
     * To avoid infinite recursion, referenced schemas are visited only once. When a referenced schema is visited,
     * it is added to visitedSchemas.
     *
     * @param openAPI the OpenAPI document that contains schema objects.
     * @param schema the root schema object to be visited.
     * @param mimeType the mime type. TODO: does not seem to be used in a meaningful way.
     * @param visitedSchemas the list of referenced schemas that have been visited.
     * @param visitor the visitor function which is invoked for every visited schema.
     */",312-375,"('visitSchema', {'INSTRUCTION': {'covered': 172, 'missed': 0}, 'BRANCH': {'covered': 32, 'missed': 2}, 'LINE': {'covered': 40, 'missed': 0}, 'COMPLEXITY': {'covered': 16, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",424.0,16.0,Invoke the specified visitor function for every schema that matches mimeType in the OpenAPI document.,"If a schema matchs mimeType in the OpenAPI document, the method invokes the visitor function and is added to visitedAchemas . References schema are visited only one single time to avoid infiite recursion",Every schema that matches mimeType should be invoked with the specified visitor function.,0.974650298081132,Call the visitor function specified for each schema that corresponds to mimeType in the OpenAPI document.
462,tablesaw,"public Table xTabCounts(String column1Name, String column2Name){
    return CrossTab.counts(this, categoricalColumn(column1Name), categoricalColumn(column2Name));
}",xTabCounts,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,"/**
   * Returns a table with n by m + 1 cells. The first column contains labels, the other cells
   * contains the counts for every unique combination of values from the two specified columns in
   * this table.
   */",1249-1256,"('xTabCounts', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,11.0,Returns a table with n by m + 1 cells.,"Creates a table with n rows and m+1 columns. The first column contains the labels, while the other contains the number of unique combinations of values from the two specified columns.",A table with n by m and 1 cells.,0.337963950517331,Returns a table with n by m + 1 cells.
463,cdk,"private static Bond toBeamEdgeLabel(IBond b, int flavour) throws CDKException{
    if (SmiFlavor.isSet(flavour, SmiFlavor.UseAromaticSymbols) && b.isAromatic()) {
        if (!b.getBegin().isAromatic() || !b.getEnd().isAromatic())
            throw new IllegalStateException(""Aromatic bond connects non-aromatic atomic atoms"");
        return Bond.AROMATIC;
    }
    if (b.getOrder() == null)
        throw new CDKException(""A bond had undefined order, possible query bond?"");
    IBond.Order order = b.getOrder();
    switch(order) {
        case SINGLE:
            return Bond.SINGLE;
        case DOUBLE:
            return Bond.DOUBLE;
        case TRIPLE:
            return Bond.TRIPLE;
        case QUADRUPLE:
            return Bond.QUADRUPLE;
        default:
            if (!SmiFlavor.isSet(flavour, SmiFlavor.UseAromaticSymbols) && b.isAromatic())
                throw new CDKException(""Cannot write Kekulé SMILES output due to aromatic bond with unset bond order - molecule should be Kekulized"");
            throw new CDKException(""Unsupported bond order: "" + order);
    }
}",toBeamEdgeLabel,org/openscience/cdk/smiles/CDKToBeam.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/CDKToBeam.java,"/**
     * Convert a CDK {@link IBond} to the Beam edge label type.
     *
     * @param b cdk bond
     * @return the edge label for the Beam edge
     * @throws NullPointerException     the bond order was null and the bond was
     *                                  not-aromatic
     * @throws IllegalArgumentException the bond order could not be converted
     */",263-298,"('toBeamEdgeLabel', {'INSTRUCTION': {'covered': 70, 'missed': 0}, 'BRANCH': {'covered': 17, 'missed': 2}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",176.0,15.0,Convert a CDK {@link IBond} to the Beam edge label type.,"Given a CDK bond, it returns the edge label type for the Beam edge.",The CDK can be converted to the Beam edge label type.,0.381944877739515,Convert a CDK {@link IBond} to a beam edge label type.
464,cdk,"IAtom toCDKAtom(Atom beamAtom, int hCount){
    IAtom cdkAtom = newCDKAtom(beamAtom);
    cdkAtom.setImplicitHydrogenCount(hCount);
    cdkAtom.setFormalCharge(beamAtom.charge());
    if (beamAtom.isotope() >= 0)
        cdkAtom.setMassNumber(beamAtom.isotope());
    if (beamAtom.aromatic())
        cdkAtom.setIsAromatic(true);
    if (beamAtom.atomClass() > 0)
        cdkAtom.setProperty(ATOM_ATOM_MAPPING, beamAtom.atomClass());
    return cdkAtom;
}",toCDKAtom,org/openscience/cdk/smiles/BeamToCDK.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/BeamToCDK.java,"/**
     * Create a new CDK {@link IAtom} from the Beam Atom.
     *
     * @param beamAtom an Atom from the Beam ChemicalGraph
     * @param hCount   hydrogen count for the atom
     * @return the CDK atom to have it's properties set
     */",604-625,"('toCDKAtom', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",99.0,14.0,Create a new CDK {@link IAtom} from the Beam Atom.,"Starting from the beamAtom in a ChemicalGraph, create a new CDK IAtom.",A new CDK is created from the beam atom.,0.383405433508895,Create a new CDK {@link IAtom} from the beam atom.
465,cdk,"private static Map<IAtom, Integer> indexAtoms(IAtomContainer container){
    Map<IAtom, Integer> map = new HashMap<>(2 * container.getAtomCount());
    for (int i = 0; i < container.getAtomCount(); i++) map.put(container.getAtom(i), i);
    return map;
}",indexAtoms,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,"/**
     * Create an index of atoms for the provided {@code container}.
     *
     * @param container the container to index the atoms of
     * @return the index/lookup of atoms to the index they appear
     */",338-349,"('indexAtoms', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",72.0,14.0,Create an index of atoms for the provided {@code container}.,the method returns the index/lookup of atom for the given container.,The provided @code container has an index of atoms.,0.807122340183246,Create an index of atoms for the provided {container @code}.
466,cdk,"public DescriptorValue calculate(IAtomContainer mol){
    DoubleResult result;
    try {
        int nC = 0;
        int nCSP3 = 0;
        CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.getInstance(mol.getBuilder());
        for (IAtom atom : mol.atoms()) {
            if (atom.getAtomicNumber() == 6) {
                nC++;
                IAtomType matched = matcher.findMatchingAtomType(mol, atom);
                if (matched != null && matched.getHybridization() == IAtomType.Hybridization.SP3) {
                    nCSP3++;
                }
            }
        }
        result = new DoubleResult(nC == 0 ? 0 : (double) nCSP3 / nC);
    } catch (CDKException e) {
        result = new DoubleResult(Double.NaN);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), result, getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/FractionalCSP3Descriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/FractionalCSP3Descriptor.java,"/**
     * Calculates the Fsp<sup>3</sup> descriptor value for the given {@link IAtomContainer}.
     *
     * @param mol An {@link org.openscience.cdk.interfaces.IAtomContainer} for which this descriptor
     *            should be calculated
     * @return An object of {@link org.openscience.cdk.qsar.DescriptorValue} that contains the
     *         calculated Fsp<sup>3</sup> descriptor value
     */",84-116,"('calculate', {'INSTRUCTION': {'covered': 65, 'missed': 6}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 14, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",161.0,21.0,Calculates the Fsp<sup>3</sup> descriptor value for the given {@link IAtomContainer}.,Computes the Fsp3 descriptor value for the provided IAtomContainer,The given @link IAtomContainer is calculated using the Fspsup>3/sup> descriptor value.,0.831272211610685,Calculates the value of the Fsp<sup>3</sup> descriptor for the given {@link IAtomContainer}.
467,acs-aem-commons,"private void populateMetadataFromRow(Resource resource, Map<String, Object> nodeInfo) throws RepositoryException{
    LOG.debug(""Start of populateMetadataFromRow"");
    ModifiableValueMap resourceProperties = resource.adaptTo(ModifiableValueMap.class);
    Node node = resource.adaptTo(Node.class);
    for (Map.Entry entry : nodeInfo.entrySet()) {
        String key = (String) entry.getKey();
        Object value = entry.getValue();
        if (key != null && (mergeMode.overwriteProps || !resourceProperties.containsKey(key))) {
            if (node.hasProperty(key) && node.getProperty(key).isMultiple() && mergeMode.appendArrays) {
                appendArray(resourceProperties, entry);
            } else if (value != null) {
                resourceProperties.put(key, value);
            }
        }
    }
    LOG.debug(""End of populateMetadataFromRow"");
}",populateMetadataFromRow,com/adobe/acs/commons/mcp/impl/processes/DataImporter.java,/bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/DataImporter.java,"/**
     * Update the resource with the properties from the row.
     *
     * @param resource Resource object of which the properties are to be modified.
     * @param nodeInfo Map of properties from the row.
     */",364-389,"('populateMetadataFromRow', {'INSTRUCTION': {'covered': 58, 'missed': 13}, 'BRANCH': {'covered': 7, 'missed': 9}, 'LINE': {'covered': 13, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 7}, 'METHOD': {'covered': 1, 'missed': 0}})",166.0,10.0,Update the resource with the properties from the row.,"Given a row and a map of properties, update the resource.",The properties from the row should be updated.,0.256469514212581,Update the resource with the properties of the row.
468,dataverse,"public static List<CharacterRule> parseConfigString(String configString){
    List<CharacterRule> characterRules = new ArrayList<>();
    String[] typePlusNums = configString.split("","");
    for (String typePlusNum : typePlusNums) {
        String[] configArray = typePlusNum.split("":"");
        String type = configArray[0];
        String num = configArray[1];
        EnglishCharacterData typeData = EnglishCharacterData.valueOf(type);
        characterRules.add(new CharacterRule(typeData, new Integer(num)));
    }
    return characterRules;
}",parseConfigString,edu/harvard/iq/dataverse/validation/PasswordValidatorUtil.java,/src/main/java/edu/harvard/iq/dataverse/validation/PasswordValidatorUtil.java,"/**
     * Parses the list of character rules as defined in the database. Recall how
     * configString is formatted: ""UpperCase:1,LowerCase:1,Digit:1,Special:1""
     */",40-55,"('parseConfigString', {'INSTRUCTION': {'covered': 53, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,12.0,Parses the list of character rules as defined in the database.,"Taking into account the formatting of the configString (""UpperCase:1,LowerCase:1,Digit:1,Special:1"") parses the list of characters that are defined in the database.",The list of character rules isParsed.,0.331012382815216,Parses the list of character rules as defined in the database.
469,cdk,"private Pattern createPattern(String smarts, IChemObjectBuilder builder) throws IOException{
    SmartsPattern ptrn = SmartsPattern.create(smarts, builder);
    ptrn.setPrepare(false);
    return ptrn;
}",createPattern,org/openscience/cdk/fingerprint/MACCSFingerprinter.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/MACCSFingerprinter.java,"/**
     * Create a pattern for the provided SMARTS - if the SMARTS is '?' a pattern
     * is not created.
     *
     * @param smarts  a smarts pattern
     * @param builder chem object builder
     * @return the pattern to match
     */",307-319,"('createPattern', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,21.0,Create a pattern for the provided SMARTS - if the SMARTS is '?' a pattern  is not created.,"Using the SMARTS, it creates a pattern if the value of the SMART is different from '?'","If the SMARTS is '?', a pattern is not created.",0.440649438575239,"Create a template for the supplied SMARTS - if the SMARTS is '?', a template is not created."
470,cucumber-reporting,"private void fillMissingDurations(){
    long[] extendedArray = new long[buildNumbers.length];
    Arrays.fill(extendedArray, -1);
    System.arraycopy(durations, 0, extendedArray, buildNumbers.length - durations.length, durations.length);
    durations = extendedArray;
}",fillMissingDurations,net/masterthought/cucumber/Trends.java,/src/main/java/net/masterthought/cucumber/Trends.java,"/**
     * Since durations were added later there is need to fill missing data for those statuses.
     */",227-235,"('fillMissingDurations', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",57.0,16.0,Since durations were added later there is need to fill missing data for those statuses.,Integrate the durations for the statuses where it is missing.,There is need to fill in missing data for those statuses since durations were added later.,0.48075901214136,"Since the durations were added later, it is necessary to fill in the missing data for these statuses."
471,cron-utils,"private int generateNoneValues(final On on, final int year, final int month, final int reference){
    // the day of week the first of the month is on
    // 1-7
    final int dowForFirstDoM = LocalDate.of(year, month, 1).getDayOfWeek().getValue();
    // the day of week we need, normalize to jdk8time
    final int requiredDoW = ConstantsMapper.weekDayMapping(mondayDoWValue, ConstantsMapper.JAVA8, on.getTime().getValue());
    // the first day of the month
    // day 1 from given month
    int baseDay = 1;
    // the difference between the days of week
    final int diff = dowForFirstDoM - requiredDoW;
    // //base day remains the same if diff is zero
    if (diff < 0) {
        baseDay = baseDay + Math.abs(diff);
    }
    if (diff > 0) {
        baseDay = baseDay + 7 - diff;
    }
    // if baseDay is greater than the reference, we are returning the initial matching day value
    // Fix issue #92
    if (reference < 1) {
        return baseDay;
    }
    while (baseDay <= reference) {
        baseDay += 7;
    }
    return baseDay;
}",generateNoneValues,com/cronutils/model/time/generator/OnDayOfWeekValueGenerator.java,/src/main/java/com/cronutils/model/time/generator/OnDayOfWeekValueGenerator.java,"/**
     * Generate valid days of the month for the days of week expression. This method requires that you
     * pass it a -1 for the reference value when starting to generate a sequence of day values. That allows
     * it to handle the special case of which day of the month is the initial matching value.
     *
     * @param on        The expression object giving us the particular day of week we need.
     * @param year      The year for the calculation.
     * @param month     The month for the calculation.
     * @param reference This value must either be -1 indicating you are starting the sequence generation or an actual
     *                  day of month that meets the day of week criteria. So a value previously returned by this method.
     * @return
     */",124-161,"('generateNoneValues', {'INSTRUCTION': {'covered': 49, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",144.0,13.0,Generate valid days of the month for the days of week expression.,"The function takes the expression of the day of week and generates valid days. You need to pass -1 for the reference value for starting the generation of the sequence, allowing to handle special cases like when the day of the month is the initial matching value.",The days of week are expressed in valid days of the month.,0.359240218607499,Generate valid days of the month for the expression of the days of the week.
472,openapi-generator,"public void addFromInterfaceModel(CodegenModel cm, List<Map<String, String>> modelsImports){
    // Add cm as implemented interface
    additionalInterfaces.add(cm.classname);
    // Add all vars defined on cm
    // a ""oneOf"" model (cm) by default inherits all properties from its ""interfaceModels"",
    // but we only want to add properties defined on cm itself
    List<CodegenProperty> toAdd = new ArrayList<CodegenProperty>(cm.vars);
    // note that we can't just toAdd.removeAll(m.vars) for every interfaceModel,
    // as they might have different value of `hasMore` and thus are not equal
    List<String> omitAdding = new ArrayList<String>();
    if (cm.interfaceModels != null) {
        for (CodegenModel m : cm.interfaceModels) {
            for (CodegenProperty v : m.vars) {
                omitAdding.add(v.baseName);
            }
        }
    }
    for (CodegenProperty v : toAdd) {
        if (!omitAdding.contains(v.baseName)) {
            additionalProps.add(v.clone());
        }
    }
    // Add all imports of cm
    for (Map<String, String> importMap : modelsImports) {
        // we're ok with shallow clone here, because imports are strings only
        additionalImports.add(new HashMap<String, String>(importMap));
    }
}",addFromInterfaceModel,org/openapitools/codegen/utils/OneOfImplementorAdditionalData.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/OneOfImplementorAdditionalData.java,"/**
     * Add data from a given CodegenModel that the oneOf implementor should implement. For example:
     *
     * @param cm model that the implementor should implement
     * @param modelsImports imports of the given `cm`
     */",59-94,"('addFromInterfaceModel', {'INSTRUCTION': {'covered': 90, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",165.0,13.0,Add data from a given CodegenModel that the oneOf implementor should implement.,Provide the data for the CodegenModel for the oneOf implementor,The one of implementor should add data from the CodegenModel.,0.461521527769203,Add data from a given CodegenModel that the oneOf implementer needs to implement.
473,cdk,"public double calculateScaleForBondLength(double modelBondLength){
    if (Double.isNaN(modelBondLength) || modelBondLength == 0) {
        return DEFAULT_SCALE;
    } else {
        return rendererModel.getParameter(BondLength.class).getValue() / modelBondLength;
    }
}",calculateScaleForBondLength,org/openscience/cdk/renderer/AtomContainerRenderer.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/AtomContainerRenderer.java,"/**
     * Given a bond length for a model, calculate the scale that will transform
     * this length to the on screen bond length in RendererModel.
     *
     * @param modelBondLength the average bond length of the model
     * @return the scale necessary to transform this to a screen bond
     */",256-270,"('calculateScaleForBondLength', {'INSTRUCTION': {'covered': 18, 'missed': 2}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,25.0,"Given a bond length for a model, calculate the scale that will transform  this length to the on screen bond length in RendererModel.",Compute the scale for transforming the bond length to the on screen bond length for the RendererModel,"If you give a bond length for a model, calculate the scale that will transform it to the on screen bond length.",0.210351743948348,"Given the binding length of a model, calculate the scale that will turn that length into the link length on the screen in RendererModel."
474,jackson-databind,"protected JsonMappingException rewrapCtorProblem(DeserializationContext ctxt, Throwable t){
    if ((t instanceof ExceptionInInitializerError) || (t instanceof InvocationTargetException)) {
        Throwable cause = t.getCause();
        if (cause != null) {
            t = cause;
        }
    }
    return wrapAsJsonMappingException(ctxt, t);
}",rewrapCtorProblem,com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java,/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java,"/**
     * Method that subclasses may call for standard handling of an exception thrown when
     * calling constructor or factory method. Will unwrap {@link ExceptionInInitializerError}
     * and {@link InvocationTargetException}s, then call {@link #wrapAsJsonMappingException}.
     *
     * @since 2.7
     */",590-611,"('rewrapCtorProblem', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",57.0,19.0,Method that subclasses may call for standard handling of an exception thrown when  calling constructor or factory method.,Subclasses may call this method for handling standard exception raised when constructors or factory method are called.,Method that subclasses call for standard handling of an exception thrown when calling a factory method,0.381183709852927,A method that subclasses can call for standard handling of an exception thrown when calling a constructor or factory method.
475,egeria,"public Optional<EntityDetail> findSchemaTypeEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, SCHEMA_TYPE_TYPE_NAME);
}",findSchemaTypeEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineSchemaTypeHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineSchemaTypeHandler.java,"/**
     * Find out if the SchemaType object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the schema type to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",129-145,"('findSchemaTypeEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,13.0,Find out if the SchemaType object is already stored in the repository.,"Check whether the SchemaType object is already stored in the repository, using the fully qualified name.","If the object is already in the repository, you should find it.",0.157638602656076,Check to see if the SchemaType object is already stored in the repository.
476,cdk,"static Vector2d sum(final Tuple2d a, final Tuple2d b){
    return new Vector2d(a.x + b.x, a.y + b.y);
}",sum,org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,"/**
     * Sum the components of two vectors, the input is not modified.
     *
     * @param a first vector
     * @param b second vector
     * @return scaled vector
     */",148-157,"('sum', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,13.0,"Sum the components of two vectors, the input is not modified.","Without changing the input, sum the component of the two vectors",The input is not modified.,0.268696802976836,"Add the components of two vectors, the input is not modified."
477,acs-aem-commons,"public void flushBuffer() throws IOException{
    if (isBuffered()) {
        log.debug(""Prevent committing the response, it will be committed deferred, i.e. once this buffered response is closed"");
        if (log.isDebugEnabled()) {
            Throwable t = new Throwable("""");
            log.debug(""Stacktrace which triggered ServletResponse.flushBuffer()"", t);
        }
        flushWrappedBuffer = true;
    } else {
        wrappedResponse.flushBuffer();
    }
}",flushBuffer,com/adobe/acs/commons/util/BufferedServletOutput.java,/bundle/src/main/java/com/adobe/acs/commons/util/BufferedServletOutput.java,"/**
     * Will not commit the response, but only make sure that the wrapped response's {@code flushBuffer()} is executed, once this {@link #close()} is called.
     * This only affects output which is buffered, i.e. for unbuffered output the flush is not deferred.
     * @throws IOException 
     */",204-220,"('flushBuffer', {'INSTRUCTION': {'covered': 23, 'missed': 3}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,38.0,"Will not commit the response, but only make sure that the wrapped response's {@code flushBuffer()} is executed, once this {@link #close()} is called.","Check that the flushBuffer of the response is executed, without committing the reponse. Finally, it calls the close() method.","Will not commit the response, but only make sure that the wrapped response's @code flushBuffer() is executed.",0.404709064475263,"Do not validate the response, but only make sure that {@code flushBuffer()} of the encapsulated response is executed, once this {@link #close()} is called."
479,weblogic-kubernetes-operator,"public void updateLastKnownServerStatus(String serverName, String status){
    getSko(serverName).getLastKnownStatus().getAndUpdate(lastKnownStatus -> {
        LastKnownStatus updatedStatus = null;
        if (status != null) {
            updatedStatus = (lastKnownStatus != null && status.equals(lastKnownStatus.getStatus())) ? new LastKnownStatus(status, lastKnownStatus.getUnchangedCount() + 1) : new LastKnownStatus(status);
        }
        return updatedStatus;
    });
}",updateLastKnownServerStatus,oracle/kubernetes/operator/helpers/DomainPresenceInfo.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/DomainPresenceInfo.java,"/**
   * Updates the last status reported for the specified server.
   *
   * @param serverName the name of the server
   * @param status the new status
   */",346-366,"('updateLastKnownServerStatus', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,10.0,Updates the last status reported for the specified server.,"GIven a serverName, update the last status reported for the chosen server.",The last status for the server is updated.,0.198929150538017,Updates the last reported state for the specified server.
481,json-schema-validator,"public static boolean isNumber(JsonNode node, SchemaValidatorsConfig config){
    if (node.isNumber()) {
        return true;
    } else if (config.isTypeLoose()) {
        if (TypeFactory.getValueNodeType(node, config) == JsonType.STRING) {
            return isNumeric(node.textValue());
        }
    }
    return false;
}",isNumber,com/networknt/schema/TypeValidator.java,/src/main/java/com/networknt/schema/TypeValidator.java,"/**
     * Check if the type of the JsonNode's value is number based on the
     * status of typeLoose flag.
     *
     * @param node        the JsonNode to check
     * @param config      the SchemaValidatorsConfig to depend on
     * @return boolean to indicate if it is a number
     */",227-244,"('isNumber', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,19.0,Check if the type of the JsonNode's value is number based on the  status of typeLoose flag.,"Using the typeLoose flag's status, check if the JsonNode's value is a number.",The JsonNode's value is based on the status of the typeLoose flag.,1.02809596518892,Check if the type of the JsonNode value is numbered based on the status of the TypeLoose flag.
482,cdk,"static HydrogenPosition usingCardinalDirection(final Vector2d opposite){
    final double theta = Math.atan2(opposite.y, opposite.x);
    final int direction = (int) Math.round(theta / (Math.PI / 4));
    switch(direction) {
        case -4:
        case -3:
            return Right;
        case -2:
            return Above;
        case -1:
        case 0:
        case 1:
            return Left;
        case 2:
            return Below;
        case 3:
        case 4:
            return Right;
    }
    return Right;
}",usingCardinalDirection,org/openscience/cdk/renderer/generators/standard/HydrogenPosition.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/HydrogenPosition.java,"/**
     * By snapping to the cardinal direction (compass point) of the provided
     * vector, return the position opposite the 'snapped' coordinate.
     *
     * @param opposite position the hydrogen label opposite to this vector
     * @return the position
     */",238-267,"('usingCardinalDirection', {'INSTRUCTION': {'covered': 24, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",104.0,24.0,"By snapping to the cardinal direction (compass point) of the provided  vector, return the position opposite the 'snapped' coordinate.","Given a vector, it returns the position opposite the 'snapped' coordinate, obtained snapping the cardinal direction of the vector.","By snapping to the cardinal direction of the provided vector, you can return the position opposite the snapped coordinate.",1.04168763884289,"By clinging to the cardinal direction (cardinal point) of the vector provided, return the position opposite to the coordinate ""engaged""."
483,cdk,"public int[] transformPoint(double xCoord, double yCoord){
    double[] src = new double[] { xCoord, yCoord };
    double[] dest = new double[2];
    this.transform.transform(src, 0, dest, 0, 1);
    return new int[] { (int) dest[0], (int) dest[1] };
}",transformPoint,org/openscience/cdk/renderer/visitor/AbstractAWTDrawVisitor.java,/display/renderawt/src/main/java/org/openscience/cdk/renderer/visitor/AbstractAWTDrawVisitor.java,"/**
     * Transforms a point according to the current affine transformation,
     * converting a world coordinate into a screen coordinate.
     *
     * @param xCoord x-coordinate of the world point to transform
     * @param yCoord y-coordinate of the world point to transform
     * @return       the transformed screen coordinate
     */",45-58,"('transformPoint', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",80.0,19.0,"Transforms a point according to the current affine transformation,  converting a world coordinate into a screen coordinate.","Given the current affine transformation, change the point converting a world coordinate into a screen coordinate.",A world coordinate is converted into a screen coordinate by transforming a point.,0.648352057852984,"Transforms a point based on the current affine transformation, converting a world coordinate to screen coordinates."
484,matsim-libs,"private boolean bothLinksAreShorterThanThreshold(Link linkA, Link linkB, double thresholdLength){
    boolean hasTwoShortLinks = false;
    if (linkA.getLength() < thresholdLength && linkB.getLength() < thresholdLength) {
        hasTwoShortLinks = true;
    }
    return hasTwoShortLinks;
}",bothLinksAreShorterThanThreshold,org/matsim/core/network/algorithms/NetworkSimplifier.java,/matsim/src/main/java/org/matsim/core/network/algorithms/NetworkSimplifier.java,"/**
	 * Quick check to see whether <i>both</i> the links are shorter than the 
	 * given threshold.
	 * @param linkA
	 * @param linkB
	 * @param thresholdLength
	 * @return true if <i>both</i> links are shorter than the given threshold, 
	 * false otherwise. 
	 */",293-308,"('bothLinksAreShorterThanThreshold', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,21.0,Quick check to see whether <i>both</i> the links are shorter than the   given threshold.,"Given a couple of links and a thresholdLength, check if both the links are shorted than the threshold.",Check to see if the links are shorter than the threshold.,0.27563263378842,Quickly check if <i>the two</i> links are shorter than the given threshold.
485,cdk,"static void label(final IAtomContainer container, final int index, final String label){
    final IAtom atom = container.getAtom(index);
    final IPseudoAtom pseudoAtom = atom instanceof IPseudoAtom ? (IPseudoAtom) atom : container.getBuilder().newInstance(IPseudoAtom.class);
    if (atom.equals(pseudoAtom)) {
        pseudoAtom.setLabel(label);
    } else {
        pseudoAtom.setSymbol(label);
        pseudoAtom.setAtomicNumber(atom.getAtomicNumber());
        pseudoAtom.setPoint2d(atom.getPoint2d());
        pseudoAtom.setPoint3d(atom.getPoint3d());
        pseudoAtom.setMassNumber(atom.getMassNumber());
        pseudoAtom.setFormalCharge(atom.getFormalCharge());
        pseudoAtom.setValency(atom.getValency());
        pseudoAtom.setLabel(label);
        AtomContainerManipulator.replaceAtomByAtom(container, atom, pseudoAtom);
    }
}",label,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Labels the atom at the specified index with the provide label. If the
     * atom was not already a pseudo atom then the original atom is replaced.
     *
     * @param container structure
     * @param index     atom index to replace
     * @param label     the label for the atom
     * @see IPseudoAtom#setLabel(String)
     */",1771-1798,"('label', {'INSTRUCTION': {'covered': 62, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",167.0,12.0,Labels the atom at the specified index with the provide label.,"Using the provided label, labels the atom at the passed index. In case of the atom was not already a pseudo atom, we replace the original atom.",The provide label should be used to label the atom.,0.295336520584664,Label the atom at the specified index with the provide label.
486,cdk,"private static int[] indexElements(Map<IAtom, Integer> map, IStereoElement[] elements, Type[] types, IAtomContainer container){
    int[] indices = new int[container.getAtomCount()];
    int nElements = 0;
    for (IStereoElement element : container.stereoElements()) {
        if (element instanceof ITetrahedralChirality) {
            ITetrahedralChirality tc = (ITetrahedralChirality) element;
            int idx = map.get(tc.getChiralAtom());
            elements[idx] = element;
            types[idx] = Type.Tetrahedral;
            indices[nElements++] = idx;
        } else if (element instanceof IDoubleBondStereochemistry) {
            IDoubleBondStereochemistry dbs = (IDoubleBondStereochemistry) element;
            int idx1 = map.get(dbs.getStereoBond().getBegin());
            int idx2 = map.get(dbs.getStereoBond().getEnd());
            elements[idx2] = elements[idx1] = element;
            types[idx1] = types[idx2] = Type.Geometric;
            indices[nElements++] = idx1;
        }
    }
    return Arrays.copyOf(indices, nElements);
}",indexElements,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,"/**
     * Index the stereo elements of the {@code container} into the the {@code
     * elements} and {@code types} arrays. The {@code map} is used for looking
     * up the index of atoms.
     *
     * @param map       index of atoms
     * @param elements  array to fill with stereo elements
     * @param types     type of stereo element indexed
     * @param container the container to index the elements of
     * @return indices of atoms involved in stereo configurations
     */",351-383,"('indexElements', {'INSTRUCTION': {'covered': 92, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",214.0,27.0,Index the stereo elements of the {@code container} into the the {@code  elements} and {@code types} arrays.,"Set the index of a stereo element of the container into the array of elements and types. For looking up th index of the atoms, we use a map.",The @code container has stereo elements and the @code elements have code types.,1.02551738036246,Index the stereo elements of the {@code container} in the arrays {@code elements} and {@code types}.
487,tablesaw,"private void processNumberingFunctions(TableSlice slice){
    for (String toColumn : query.getArgumentList().getNumberingFunctions().keySet()) {
        if (rowComparator == null) {
            throw new IllegalArgumentException(""Cannot use Numbering Function without OrderBy"");
        }
        FunctionCall<NumberingFunctions> functionCall = query.getArgumentList().getNumberingFunctions().get(toColumn);
        NumberingFunctions numberingFunctions = functionCall.getFunction();
        NumberingFunction function = numberingFunctions.getImplementation();
        Column<Integer> destinationColumn = (Column<Integer>) destination.column(functionCall.getDestinationColumnName());
        int prevRowNumber = -1;
        for (Row row : slice) {
            if (row.getRowNumber() == 0) {
                function.addNextRow();
            } else {
                if (rowComparator.compare(slice.mappedRowNumber(prevRowNumber), slice.mappedRowNumber(row.getRowNumber())) == 0) {
                    function.addEqualRow();
                } else {
                    function.addNextRow();
                }
            }
            prevRowNumber = row.getRowNumber();
            destinationColumn.set(slice.mappedRowNumber(row.getRowNumber()), function.getValue());
        }
    }
}",processNumberingFunctions,tech/tablesaw/analytic/AnalyticQueryEngine.java,/core/src/main/java/tech/tablesaw/analytic/AnalyticQueryEngine.java,"/**
   * Execute all numbering functions for the given slice setting values in the appropriate
   * destination column.
   */",74-112,"('processNumberingFunctions', {'INSTRUCTION': {'covered': 88, 'missed': 5}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 21, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",217.0,16.0,Execute all numbering functions for the given slice setting values in the appropriate  destination column.,"Select the given slide and execute all numbering functions, setting the values in the correct destination columns.",The numbering functions for the slice setting values should be executed.,0.59140702152715,Perform all numbering functions for the slice parameter values given in the appropriate destination column.
488,matsim-libs,"Scenario loadScenario(){
    // String currentDir = new File(""tmp"").getAbsolutePath();
    // currentDir = currentDir.substring(0, currentDir.length() - 3);
    // log.info(""loading scenario from base directory: "" + currentDir);
    // the above is not used and thus only causing confusion in the log output.  kai, sep'18
    this.loadNetwork();
    this.loadActivityFacilities();
    this.loadPopulation();
    // tests internally if the file is there
    this.loadHouseholds();
    // tests internally if the file is there
    this.loadTransit();
    // tests internally if the file is there
    this.loadTransitVehicles();
    if (this.config.vehicles().getVehiclesFile() != null) {
        this.loadVehicles();
    }
    if (this.config.network().getLaneDefinitionsFile() != null) {
        this.loadLanes();
    }
    return this.scenario;
}",loadScenario,org/matsim/core/scenario/ScenarioLoaderImpl.java,/matsim/src/main/java/org/matsim/core/scenario/ScenarioLoaderImpl.java,"/**
	 * Loads all mandatory Scenario elements and
	 * if activated in config's scenario module/group
	 * optional elements.
	 * @return the Scenario
	 */",101-126,"('loadScenario', {'INSTRUCTION': {'covered': 27, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",95.0,16.0,Loads all mandatory Scenario elements and  if activated in config's scenario module/group  optional elements.,Return a scenario after loading all mandatory scenario elements and the one activated in config's scneario module and group.,"If activated in the scenario module, loads all mandatory Scenario elements.",0.57089295773783,"Loads all required scenario elements and, if enabled in the config scenario module/group, optional elements."
489,cdk,"public static List<List<CDKRMap>> makeAtomsMapsOfBondsMaps(List<List<CDKRMap>> list, IAtomContainer sourceGraph, IAtomContainer targetGraph){
    if (list == null) {
        return list;
    }
    if (targetGraph.getAtomCount() == 1) {
        return list;
    }
    List<List<CDKRMap>> result = new ArrayList<List<CDKRMap>>();
    for (List<CDKRMap> l2 : list) {
        result.add(makeAtomsMapOfBondsMap(l2, sourceGraph, targetGraph));
    }
    return result;
}",makeAtomsMapsOfBondsMaps,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,"/**
     *  This makes maps of matching atoms out of atom maps of matching bonds as produced by the get(Subgraph|Ismorphism)Maps methods.
     *
     * @param  list   The list produced by the getMap method.
     * @param  sourceGraph  The first atom container. Must not be atom IQueryAtomContainer.
     * @param  targetGraph  The second one (first and second as in getMap). May be an QueryAtomContaienr.
     * @return     A Vector of Vectors of CDKRMap objects of matching Atoms.
     */",686-707,"('makeAtomsMapsOfBondsMaps', {'INSTRUCTION': {'covered': 32, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",103.0,24.0,This makes maps of matching atoms out of atom maps of matching bonds as produced by the get(Subgraph|Ismorphism)Maps methods.,Returns a vector of vectors of CDKRMap objects that are maps of matching atoms and bonds as produced by the get(Subgraph|Ismorphism)Maps methods.,Maps of matching atoms are created by using the get(Subgraph)IsmorphismMaps methods.,0.513923222556707,This makes maps of corresponding atoms from maps of atoms of corresponding bonds as produced by the get(Subgraph| Ismorphism)Mapping methods.
490,acs-aem-commons,"private void checkValidity(ReplicationAction action, String path) throws ReplicationException{
    if (action.getType() != ReplicationActionType.ACTIVATE && action.getType() != ReplicationActionType.TEST) {
        logErrorMessage(""No re-fetch handling for replication action "" + action.getType().getName());
        throw new ReplicationException(""No re-fetch handling for replication action "" + action.getType().getName());
    }
    if (StringUtils.isEmpty(path)) {
        logErrorMessage(""No path found for re-fetch replication."");
        throw new ReplicationException(""No path found for re-fetch replication."");
    }
    if (!CONTENT_BUILDER_NAME.equals(action.getConfig().getSerializationType())) {
        String message = ""Serialization type '"" + action.getConfig().getSerializationType() + ""' not supported by Flush Re-Fetch Content Builder."";
        logErrorMessage(message);
        throw new ReplicationException(message);
    }
}",checkValidity,com/adobe/acs/commons/replication/dispatcher/impl/RefetchFlushContentBuilderImpl.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/impl/RefetchFlushContentBuilderImpl.java,"/**
     * Check the validity of the parameters received for this activation.
     *
     * @param action The replication action specifying properties of the activation.
     * @param path The path to the item to be activated.
     * @throws ReplicationException Throws a replication exception if invalid.
     */",274-299,"('checkValidity', {'INSTRUCTION': {'covered': 73, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",142.0,11.0,Check the validity of the parameters received for this activation.,"Given a parameter for the activation, check if it is valid.",The validity of the parameters received for this activation is checked.,0.468845264830202,Check the validity of the settings received for this activation.
491,cdk,"public boolean isIdentity(){
    for (int i = 0; i < this.values.length; i++) {
        if (this.values[i] != i) {
            return false;
        }
    }
    return true;
}",isIdentity,org/openscience/cdk/group/Permutation.java,/tool/group/src/main/java/org/openscience/cdk/group/Permutation.java,"/**
     * Check to see if this permutation is the identity permutation.
     *
     * @return true if for all i, p[i] = i
     */",98-110,"('isIdentity', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,11.0,Check to see if this permutation is the identity permutation.,Check whether the permutation is the identity permutation.,"If this permutation is the identity permutation, you should check it.",0.725224532941888,Check if this swap is the identity swap.
492,matsim-libs,"public boolean add(final E o, final double priority){
    if (o == null) {
        throw new NullPointerException();
    }
    PseudoEntry<E> entry = new PseudoEntry<E>(o, priority);
    if (this.lastEntry.containsKey(o)) {
        return false;
    }
    if (this.delegate.add(entry)) {
        this.lastEntry.put(o, entry);
        return true;
    }
    // this should never happen
    return false;
}",add,org/matsim/core/utils/collections/PseudoRemovePriorityQueue.java,/matsim/src/main/java/org/matsim/core/utils/collections/PseudoRemovePriorityQueue.java,"/**
	 * Adds the specified element to this priority queue, with the given priority.
	 * @param o
	 * @param priority
	 * @return <tt>true</tt> if the element was added to the collection.
	 */",59-79,"('add', {'INSTRUCTION': {'covered': 32, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,14.0,"Adds the specified element to this priority queue, with the given priority.","Given an element and a priority, add that element to the priority queue.",The specified element is added to the priority queue.,0.260794300237494,"Adds the specified item to this priority queue, with the priority given."
493,acs-aem-commons,"public AdapterType adaptTo(Class<AdapterType> type){
    AdapterType result = null;
    synchronized (this) {
        result = (AdapterType) this.adaptersCache.get(type);
        if (result == null) {
            AdapterManager mgr = Activator.getAdapterManager();
            if (mgr == null) {
                LOG.warn(""Unable to adapt request for path {} to {} because AdapterManager is null"", this.resource.getPath(), type);
            } else {
                result = mgr.getAdapter(this, type);
            }
            if (result != null) {
                this.adaptersCache.put(type, result);
            }
        }
        return result;
    }
}",adaptTo,com/adobe/acs/commons/util/OverridePathSlingRequestWrapper.java,/bundle/src/main/java/com/adobe/acs/commons/util/OverridePathSlingRequestWrapper.java,"/**
     * Overriding `adaptTo` to avoid using the original request as the adaptable.
     */",129-152,"('adaptTo', {'INSTRUCTION': {'covered': 34, 'missed': 8}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 10, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",115.0,14.0,Overriding `adaptTo` to avoid using the original request as the adaptable.,"In order to avoid the use of the orignal request as the adaptable, override the 'adaptTo' method.",To avoid using the original request as an adapted one.,0.436788666735597,Replace 'adaptTo' to avoid using the original query as adaptable.
494,weblogic-kubernetes-operator," static boolean mapEquals(Map<K, V> first, Map<K, V> second){
    return Objects.equals(first, second) || (isNullOrEmpty(first) && isNullOrEmpty(second));
}",mapEquals,oracle/kubernetes/operator/helpers/KubernetesUtils.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/KubernetesUtils.java,"/**
   * Returns true if the two maps of values match. A null map is considered to match an empty map.
   *
   * @param first  the first map to compare
   * @param second the second map to compare
   * @return true if the maps match.
   */",28-37,"('mapEquals', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,10.0,Returns true if the two maps of values match.,Returns true if the two maps match; if the map is null we consider a match with an empty map.,"If the two maps of values match, this is true.",1.18640110256941,Returns true if the two value cards match.
495,acs-aem-commons,"private List<Pattern> compileToPatterns(final List<String> regexes){
    final List<Pattern> patterns = new ArrayList<Pattern>();
    for (String regex : regexes) {
        if (StringUtils.isNotBlank(regex)) {
            patterns.add(Pattern.compile(regex));
        }
    }
    return patterns;
}",compileToPatterns,com/adobe/acs/commons/httpcache/config/impl/HttpCacheConfigImpl.java,/bundle/src/main/java/com/adobe/acs/commons/httpcache/config/impl/HttpCacheConfigImpl.java,"/**
     * Converts an array of Regex strings into compiled Patterns.
     *
     * @param regexes the regex strings to compile into Patterns
     * @return the list of compiled Patterns
     */",313-329,"('compileToPatterns', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,10.0,Converts an array of Regex strings into compiled Patterns.,"Given a list of regexes, converst these regexes into compiled patterns adding the result in a new patterns list.",A string is converted into a pattern.,0.302821686216636,Converts an array of Regex strings to compiled templates.
496,cdk,"public static float calculate(Map<String, Integer> features1, Map<String, Integer> features2){
    TreeSet<String> keys = new TreeSet<String>(features1.keySet());
    keys.addAll(features2.keySet());
    float sum = 0.0f;
    for (String key : keys) {
        Integer c1 = features1.get(key);
        Integer c2 = features2.get(key);
        c1 = c1 == null ? 0 : c1;
        c2 = c2 == null ? 0 : c2;
        sum += 1.0 - Math.abs(c1 - c2) / (c1 + c2);
    }
    return sum / keys.size();
}",calculate,org/openscience/cdk/similarity/LingoSimilarity.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/similarity/LingoSimilarity.java,"/**
     * Evaluate the LINGO similarity between two key,value sty;e fingerprints.
     *
     * The value will range from 0.0 to 1.0.
     *
     * @param features1
     * @param features2
     * @return similarity
     */",45-69,"('calculate', {'INSTRUCTION': {'covered': 72, 'missed': 4}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",135.0,14.0,"Evaluate the LINGO similarity between two key,value sty;e fingerprints.","Compute the LINGO similarity between the (key,value) and the (style, fingerprint) The similiary will range from 0.0 to 1.0",Evaluate the similarity between two fingerprints.,0.584847087544318,"Assess the LINGO similarity between two key fingerprints, sty;e values."
497,weblogic-kubernetes-operator,"public static String accessContinue(Object result){
    return Optional.ofNullable(result).filter(KubernetesListObject.class::isInstance).map(KubernetesListObject.class::cast).map(KubernetesListObject::getMetadata).map(V1ListMeta::getContinue).filter(Predicate.not(String::isEmpty)).orElse(null);
}",accessContinue,oracle/kubernetes/operator/calls/AsyncRequestStep.java,/operator/src/main/java/oracle/kubernetes/operator/calls/AsyncRequestStep.java,"/**
   * Access continue field, if any, from list metadata.
   * @param result Kubernetes list result
   * @return Continue value
   */",133-146,"('accessContinue', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,11.0,"Access continue field, if any, from list metadata.","From a list containing metadata, access the continue field.","If there is any access from the list scenography, the continue field is needed.",0.554546954704016,"Continue access, if any, from the list metadata field."
498,cdk,"private boolean isCisTransEndPoint(int idx){
    IAtom atom = container.getAtom(idx);
    if (atom.getAtomicNumber() == null || atom.getFormalCharge() == null || atom.getImplicitHydrogenCount() == null)
        return false;
    final int chg = atom.getFormalCharge();
    final int btypes = getBondTypes(idx);
    switch(atom.getAtomicNumber()) {
        case 6:
        case 14:
        case 32:
            return chg == 0 && btypes == 0x0102;
        case 7:
            if (chg == 0)
                return btypes == 0x0101;
            if (chg == +1)
                return btypes == 0x0102;
        default:
            return false;
    }
}",isCisTransEndPoint,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,"/**
     * Checks if the atom can be involved in a double-bond.
     * @param idx atom idx
     * @return the atom at index (idx) is valid for a double bond
     * @see <a href=""http://www.inchi-trust.org/download/104/InChI_TechMan.pdf"">Double bond stereochemistry, InChI Technical Manual</a>
     */",1258-1287,"('isCisTransEndPoint', {'INSTRUCTION': {'covered': 57, 'missed': 1}, 'BRANCH': {'covered': 16, 'missed': 5}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",126.0,11.0,Checks if the atom can be involved in a double-bond.,Inspects if the atom can be involved in a double-bond operation,The atom is checked if it can be involved in a double-bond.,0.291031766943147,Checks whether the atom can be involved in a double bond.
499,openapi-generator,"public static ValidationRule warn(String description, String failureMessage, Function<T, Result> fn){
    return new ValidationRule(Severity.WARNING, description, failureMessage, (Function<Object, Result>) fn);
}",warn,org/openapitools/codegen/validation/ValidationRule.java,/modules/openapi-generator-core/src/main/java/org/openapitools/codegen/validation/ValidationRule.java,"/**
     * Create an instance of a {@link ValidationRule} which should result in a warning should the evaluate of this rule fail.
     *
     * @param description A description to help differentiate this rule from others (not intended to be user-facing).
     * @param failureMessage The message to be displayed in the event of a test failure (intended to be user-facing).
     * @param fn The test condition to be applied as a part of this rule, when this function returns <code>true</code>,
     *             the evaluated instance will be considered ""valid"" according to this rule.
     * @param <T> The type of the object being evaluated.
     *
     * @return A new instance of a {@link ValidationRule}
     */",128-142,"('warn', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,24.0,Create an instance of a {@link ValidationRule} which should result in a warning should the evaluate of this rule fail.,"Constructs an instance of a {@link ValidationRule}. If the constraints are not satisfied, then such operation will fail the evaluation.","If the evaluate of this rule fails, create an instance of @link ValidationRule which should result in a warning.",1.25298247458377,Create an instance of a {@link ValidationRule} that should result in a warning if the evaluation of this rule fails.
500,cdk,"public synchronized void sortResultsByFragments(){
    Map<Integer, Map<Integer, Integer>> allFragmentMCS = new TreeMap<Integer, Map<Integer, Integer>>();
    Map<Integer, Map<IAtom, IAtom>> allFragmentAtomMCS = new TreeMap<Integer, Map<IAtom, IAtom>>();
    Map<Integer, Double> stereoScoreMap = new TreeMap<Integer, Double>();
    Map<Integer, Double> energyScoreMap = new TreeMap<Integer, Double>();
    Map<Integer, Integer> fragmentScoreMap = new TreeMap<Integer, Integer>();
    initializeMaps(allFragmentMCS, allFragmentAtomMCS, stereoScoreMap, fragmentScoreMap, energyScoreMap);
    int minFragmentScore = 9999;
    for (Integer key : allFragmentAtomMCS.keySet()) {
        Map<IAtom, IAtom> mcsAtom = allFragmentAtomMCS.get(key);
        int fragmentCount = getMappedMoleculeFragmentSize(mcsAtom);
        fragmentScoreMap.put(key, fragmentCount);
        if (minFragmentScore > fragmentCount) {
            minFragmentScore = fragmentCount;
        }
    }
    boolean flag = false;
    if (minFragmentScore < 9999) {
        flag = true;
        clear();
    }
    int counter = 0;
    for (Map.Entry<Integer, Integer> map : fragmentScoreMap.entrySet()) {
        if (minFragmentScore == map.getValue().intValue()) {
            addSolution(counter, map.getKey(), allFragmentAtomMCS, allFragmentMCS, stereoScoreMap, energyScoreMap, fragmentScoreMap);
            counter++;
        }
    }
    if (flag) {
        firstSolution.putAll(allMCS.get(0));
        firstAtomMCS.putAll(allAtomMCS.get(0));
        clear(allFragmentMCS, allFragmentAtomMCS, stereoScoreMap, fragmentScoreMap, energyScoreMap);
    }
}",sortResultsByFragments,org/openscience/cdk/smsd/filters/ChemicalFilters.java,/legacy/src/main/java/org/openscience/cdk/smsd/filters/ChemicalFilters.java,"/**
     * Sort solution by ascending order of the fragment count.
     */",257-304,"('sortResultsByFragments', {'INSTRUCTION': {'covered': 129, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 29, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",322.0,10.0,Sort solution by ascending order of the fragment count.,The solution is sorted by ascending order of the fragment count.,Sort solution by order of fragment count.,0.13402126514098,Sort the solution in ascending order of the number of fragments.
501,metrics," Result execute(){
    long start = clock().getTick();
    Result result;
    try {
        result = check();
    } catch (Exception e) {
        result = Result.unhealthy(e);
    }
    result.setDuration(TimeUnit.MILLISECONDS.convert(clock().getTick() - start, TimeUnit.NANOSECONDS));
    return result;
}",execute,io/dropwizard/metrics5/health/HealthCheck.java,/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/HealthCheck.java,"/**
     * Executes the health check, catching and handling any exceptions raised by {@link #check()}.
     *
     * @return if the component is healthy, a healthy {@link Result}; otherwise, an unhealthy {@link
     * Result} with a descriptive error message or exception
     */",363-379,"('execute', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,21.0,"Executes the health check, catching and handling any exceptions raised by {@link #check()}.","Runs a sanity check. If excpetions are rised, those will be captuted by {@link #check}.",The health check is executed and handled by the @link #check,0.743220811595653,"Performs health checking, intercepts, and handles all exceptions raised by {@link #check()}."
502,tablesaw,"private void addColumns(){
    this.destination.addColumns(query.getArgumentList().createEmptyDestinationColumns(query.getTable().rowCount()).toArray(new Column<?>[0]));
}",addColumns,tech/tablesaw/analytic/AnalyticQueryEngine.java,/core/src/main/java/tech/tablesaw/analytic/AnalyticQueryEngine.java,"/**
   * Creates empty columns that will be filled in when the analytic aggregate or numbering functions
   * are executed.
   */",128-138,"('addColumns', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,18.0,Creates empty columns that will be filled in when the analytic aggregate or numbering functions  are executed.,"Once the analytic aggregate or the numer functions are exectured, then create an empty column.","When the analytic aggregate or numbering functions are executed, the empty columns will be filled.",0.837655577360798,Creates empty columns that will be populated when performing the analytic aggregation or numbering functions.
503,cdk,"boolean assignLayout(IAtomContainer container){
    try {
        int n = container.getAtomCount();
        int[] ordering = new int[n];
        String smiles = cansmi(container, ordering);
        for (Point2d[] points : templateMap.getOrDefault(smiles, Collections.emptyList())) {
            for (int i = 0; i < n; i++) {
                container.getAtom(i).setPoint2d(new Point2d(points[ordering[i]]));
            }
            return true;
        }
    } catch (CDKException e) {
    }
    return false;
}",assignLayout,org/openscience/cdk/layout/IdentityTemplateLibrary.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/IdentityTemplateLibrary.java,"/**
     * Assign a 2D layout to the atom container using the contents of the library. If multiple
     * coordinates are available the first is choosen.
     *
     * @param container structure representation
     * @return a layout was assigned
     */",336-364,"('assignLayout', {'INSTRUCTION': {'covered': 50, 'missed': 1}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",114.0,15.0,Assign a 2D layout to the atom container using the contents of the library.,Allocates a 2D layout to the atom container using the external library. When multiple coordinates are available the pick the first one.,The contents of the library should be used to assign a 2D layout to the atom container.,0.587405600811485,Assign a 2D layout to the atom container using the contents of the library.
505,acs-aem-commons,"protected final Layer transform(Layer layer, final ValueMap imageTransformersWithParams){
    for (final String type : imageTransformersWithParams.keySet()) {
        if (StringUtils.equals(TYPE_QUALITY, type)) {
            continue;
        }
        final ImageTransformer imageTransformer = this.imageTransformers.get(type);
        if (imageTransformer == null) {
            log.warn(""Skipping transform. Missing ImageTransformer for type: {}"", type);
            continue;
        }
        final ValueMap transformParams = imageTransformersWithParams.get(type, EMPTY_PARAMS);
        if (transformParams != null) {
            layer = imageTransformer.transform(layer, transformParams);
        }
    }
    return layer;
}",transform,com/adobe/acs/commons/images/impl/NamedTransformImageServlet.java,/bundle/src/main/java/com/adobe/acs/commons/images/impl/NamedTransformImageServlet.java,"/**
     * Execute the ImageTransformers as specified by the Request's suffix segments against the Image layer.
     *
     * @param layer the Image layer
     * @param imageTransformersWithParams the transforms and their params
     * @return the transformed Image layer
     */",246-274,"('transform', {'INSTRUCTION': {'covered': 39, 'missed': 6}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 9, 'missed': 3}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",110.0,16.0,Execute the ImageTransformers as specified by the Request's suffix segments against the Image layer.,Creates a new ImageTransformer object and run the imageTransformer operation.,The image transformer is executed as specified by the Request's suffix segments.,0.22958947816613,Run the ImageTransformers as specified by the suffix segments of the request relative to the Image layer.
506,dcache,"private static Pattern toPattern(String name, String format){
    StringBuilder regex = new StringBuilder();
    Matcher matcher = ATTRIBUTE_PATTERN.matcher(format);
    int pos = 0;
    while (matcher.find()) {
        if (pos < matcher.start()) {
            regex.append(Pattern.quote(format.substring(pos, matcher.start())));
        }
        String expression = matcher.group(1);
        if (isIf(expression)) {
            regex.append(""(?:"");
        } else if (isElse(expression)) {
            regex.append(""|"");
        } else if (isEndIf(expression)) {
            regex.append("")"");
        } else {
            regex.append(""(?<"").append(toGroupName(expression)).append("">"");
            switch(expression) {
                case ""date"":
                    regex.append("".+?"");
                    break;
                case ""pnfsid"":
                    regex.append(""[0-9A-F]{24}(?:[0-9A-F]{12})?"");
                    break;
                case ""filesize"":
                case ""transferred"":
                case ""connectionTime"":
                case ""transactionTime"":
                case ""queuingTime"":
                case ""transferTime"":
                case ""rc"":
                case ""uid"":
                case ""gid"":
                    regex.append(""-?\\d+"");
                    break;
                case ""cached"":
                case ""created"":
                    regex.append(""(?:true|false)"");
                    break;
                case ""cellType"":
                    switch(name) {
                        case ""mover-info-message"":
                        case ""remove-file-info-message"":
                        case ""storage-info-message"":
                        case ""pool-hit-info-message"":
                            regex.append(""pool"");
                            break;
                        case ""door-request-info-message"":
                            regex.append(""door"");
                            break;
                        default:
                            regex.append(""\\w+"");
                            break;
                    }
                    break;
                case ""cellName"":
                    regex.append("".+?"");
                    break;
                case ""type"":
                    switch(name) {
                        case ""mover-info-message"":
                            regex.append(""transfer"");
                            break;
                        case ""remove-file-info-message"":
                            regex.append(""remove"");
                            break;
                        case ""storage-info-message"":
                            regex.append(""(?:re)?store"");
                            break;
                        case ""pool-hit-info-message"":
                            regex.append(""hit"");
                            break;
                        case ""warning-pnfs-file-info-message"":
                            regex.append(""warning"");
                            break;
                        default:
                            regex.append(""\\w+"");
                            break;
                    }
                    break;
                default:
                    regex.append("".*?"");
            }
            regex.append("")"");
        }
        pos = matcher.end();
    }
    if (pos < format.length()) {
        regex.append(Pattern.quote(format.substring(pos)));
    }
    return Pattern.compile(regex.toString(), Pattern.CASE_INSENSITIVE);
}",toPattern,org/dcache/services/billing/text/BillingParserBuilder.java,/modules/dcache/src/main/java/org/dcache/services/billing/text/BillingParserBuilder.java,"/**
     * Returns a Pattern for matching the provided billing format.
     * <p>
     * Attributes are turned into named capturing groups.
     */",153-250,"('toPattern', {'INSTRUCTION': {'covered': 171, 'missed': 14}, 'BRANCH': {'covered': 25, 'missed': 4}, 'LINE': {'covered': 47, 'missed': 5}, 'COMPLEXITY': {'covered': 17, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",463.0,10.0,Returns a Pattern for matching the provided billing format.,Builds and returns a pattern to march the provided billing format,The pattern is used to match the provided billing format.,0.234591062647353,Returns a template to match the billing format provided.
507,weblogic-kubernetes-operator," static boolean isMissingValues(Map<String, String> current, Map<String, String> required){
    if (!hasAllRequiredNames(current, required)) {
        return true;
    }
    for (String name : required.keySet()) {
        if (!Objects.equals(current.get(name), required.get(name))) {
            return true;
        }
    }
    return false;
}",isMissingValues,oracle/kubernetes/operator/helpers/KubernetesUtils.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/KubernetesUtils.java,"/**
   * Returns true if the current map is missing values from the required map. This method is
   * typically used to compare labels and annotations against specifications derived from the
   * domain.
   *
   * @param current  a map of the values found in a Kubernetes resource
   * @param required a map of the values specified for the resource by the domain
   * @return true if there is a problem that must be fixed by patching
   */",39-59,"('isMissingValues', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",80.0,14.0,Returns true if the current map is missing values from the required map.,"If the required map misses the current object, return true, false otherwise.","If the current map is missing values, this is true.",0.65390968752412,Returns true if the current adapter lacks values from the required adapter.
509,cdk,"public boolean contains(IAtom atom){
    if (atoms == null)
        return false;
    for (IAtom localAtom : atoms) {
        if (localAtom.equals(atom))
            return true;
    }
    return false;
}",contains,org/openscience/cdk/silent/Bond.java,/base/silent/src/main/java/org/openscience/cdk/silent/Bond.java,"/**
     * Returns true if the given atom participates in this bond.
     *
     * @param atom The atom to be tested if it participates in this bond
     * @return true if the atom participates in this bond
     */",305-318,"('contains', {'INSTRUCTION': {'covered': 28, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",42.0,11.0,Returns true if the given atom participates in this bond.,"If the bond is participated by the given atom, then returns true, false otherwise.","If the atom participates in the bond, it is true.",0.513135507233505,Returns true if the given atom participates in this bond.
510,tablesaw,"C mapInto(Function<? super T, ? extends R> fun, C into){
    for (int i = 0; i < size(); i++) {
        if (isMissing(i)) {
            into.setMissing(i);
        } else {
            into.set(i, fun.apply(get(i)));
        }
    }
    return into;
}",mapInto,tech/tablesaw/columns/Column.java,/core/src/main/java/tech/tablesaw/columns/Column.java,"/**
   * Maps the function across all rows, storing the results into the provided Column.
   *
   * <p>The target column must have at least the same number of rows.
   *
   * @param fun function to map
   * @param into Column into which results are set
   * @return the provided Column
   */",355-373,"('mapInto', {'INSTRUCTION': {'covered': 23, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,15.0,"Maps the function across all rows, storing the results into the provided Column.",For each row applies the function get and keep track of the results into the provided column.,The function is mapped across all rows and the results are in the Column.,0.401187256055389,"Maps the function to all rows, storing the results in the provided column."
511,dcache,"private static Set<T> extractAttributes(NamingEnumeration<SearchResult> sre, String attr, Function<String, T> mapper) throws NamingException{
    Set<T> attrs = new HashSet<>();
    while (sre.hasMore()) {
        T v = mapper.apply((String) sre.next().getAttributes().get(attr).get());
        attrs.add(v);
    }
    if (attrs.isEmpty()) {
        throw new NoSuchElementException();
    }
    return attrs;
}",extractAttributes,org/dcache/gplazma/plugins/Ldap.java,/modules/gplazma2-ldap/src/main/java/org/dcache/gplazma/plugins/Ldap.java,"/**
     * Get set of attributes extracted from the search result.
     *
     * @param <T>    type of extracted type.
     * @param sre    ldap search result.
     * @param attr   search result attribute.
     * @param mapper mapping function to apply to each result element.
     * @return set of attributes.
     * @throws NamingException
     */",632-656,"('extractAttributes', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",108.0,10.0,Get set of attributes extracted from the search result.,Returns a new HashSet object contining the set of attributes that have been extracted.,Get the set of attributes from the search result.,0.0617870595327414,Get a set of attributes extracted from the search result.
513,cdk,"public Partition refine(Partition coarser){
    Partition finer = new Partition(coarser);
    blocksToRefine = new LinkedList<Set<Integer>>();
    for (int i = 0; i < finer.size(); i++) {
        blocksToRefine.add(finer.copyBlock(i));
    }
    int numberOfVertices = refinable.getVertexCount();
    while (!blocksToRefine.isEmpty()) {
        Set<Integer> t = blocksToRefine.remove();
        currentBlockIndex = 0;
        while (currentBlockIndex < finer.size() && finer.size() < numberOfVertices) {
            if (!finer.isDiscreteCell(currentBlockIndex)) {
                Map<Invariant, SortedSet<Integer>> invariants = getInvariants(finer, t);
                split(invariants, finer);
            }
            currentBlockIndex++;
        }
        if (finer.size() == numberOfVertices) {
            return finer;
        }
    }
    return finer;
}",refine,org/openscience/cdk/group/EquitablePartitionRefiner.java,/tool/group/src/main/java/org/openscience/cdk/group/EquitablePartitionRefiner.java,"/**
     * Refines the coarse partition <code>a</code> into a finer one.
     *
     * @param coarser the partition to refine
     * @return a finer partition
     */",89-126,"('refine', {'INSTRUCTION': {'covered': 80, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",177.0,16.0,Refines the coarse partition <code>a</code> into a finer one.,Converts a coarse partition into a superior one,The partition is refined into a fine one.,0.175356290126768,Refines the coarse partition <code>has</code> into a thinner partition.
514,cdk,"private IChemFile readChemFile(IChemFile oFile){
    IChemSequence oSeq = oFile.getBuilder().newInstance(IChemSequence.class);
    IChemModel oModel = oFile.getBuilder().newInstance(IChemModel.class);
    IAtomContainerSet oSet = oFile.getBuilder().newInstance(IAtomContainerSet.class);
    String cCol;
    PDBAtom oAtom;
    PDBPolymer oBP = new PDBPolymer();
    IAtomContainer molecularStructure = oFile.getBuilder().newInstance(IAtomContainer.class);
    StringBuffer cResidue;
    String oObj;
    IMonomer oMonomer;
    String cRead = """";
    char chain = 'A';
    IStrand oStrand;
    int lineLength = 0;
    boolean isProteinStructure = false;
    atomNumberMap = new Hashtable<Integer, IAtom>();
    if (readConnect.isSet()) {
        bondsFromConnectRecords = new ArrayList<IBond>();
    }
    try {
        do {
            cRead = _oInput.readLine();
            logger.debug(""Read line: "", cRead);
            if (cRead != null) {
                lineLength = cRead.length();
                if (lineLength < 6) {
                    cRead = cRead + ""      "";
                }
                cCol = cRead.substring(0, 6);
                if (""SEQRES"".equalsIgnoreCase(cCol)) {
                    isProteinStructure = true;
                } else if (""ATOM  "".equalsIgnoreCase(cCol)) {
                    oAtom = readAtom(cRead, lineLength);
                    if (isProteinStructure) {
                        cResidue = new StringBuffer(8);
                        oObj = oAtom.getResName();
                        if (oObj != null) {
                            cResidue = cResidue.append(oObj.trim());
                        }
                        oObj = oAtom.getChainID();
                        if (oObj != null) {
                            cResidue = cResidue.append(String.valueOf(chain));
                        }
                        oObj = oAtom.getResSeq();
                        if (oObj != null) {
                            cResidue = cResidue.append(oObj.trim());
                        }
                        String strandName = oAtom.getChainID();
                        if (strandName == null || strandName.length() == 0) {
                            strandName = String.valueOf(chain);
                        }
                        oStrand = oBP.getStrand(strandName);
                        if (oStrand == null) {
                            oStrand = new PDBStrand();
                            oStrand.setStrandName(strandName);
                            oStrand.setID(String.valueOf(chain));
                        }
                        oMonomer = oBP.getMonomer(cResidue.toString(), String.valueOf(chain));
                        if (oMonomer == null) {
                            PDBMonomer monomer = new PDBMonomer();
                            monomer.setMonomerName(cResidue.toString());
                            monomer.setMonomerType(oAtom.getResName());
                            monomer.setChainID(oAtom.getChainID());
                            monomer.setICode(oAtom.getICode());
                            monomer.setResSeq(oAtom.getResSeq());
                            oMonomer = monomer;
                        }
                        oBP.addAtom(oAtom, oMonomer, oStrand);
                    } else {
                        molecularStructure.addAtom(oAtom);
                    }
                    if (readConnect.isSet() && atomNumberMap.put(oAtom.getSerial(), oAtom) != null) {
                        logger.warn(""Duplicate serial ID found for atom: "", oAtom);
                    }
                    logger.debug(""Added ATOM: "", oAtom);
                } else if (""HETATM"".equalsIgnoreCase(cCol)) {
                    oAtom = readAtom(cRead, lineLength);
                    oAtom.setHetAtom(true);
                    if (isProteinStructure) {
                        oBP.addAtom(oAtom);
                    } else {
                        molecularStructure.addAtom(oAtom);
                    }
                    if (atomNumberMap.put(oAtom.getSerial(), oAtom) != null) {
                        logger.warn(""Duplicate serial ID found for atom: "", oAtom);
                    }
                    logger.debug(""Added HETATM: "", oAtom);
                } else if (""TER   "".equalsIgnoreCase(cCol)) {
                    chain++;
                    oStrand = new PDBStrand();
                    oStrand.setStrandName(String.valueOf(chain));
                    logger.debug(""Added new STRAND"");
                } else if (""END   "".equalsIgnoreCase(cCol)) {
                    atomNumberMap.clear();
                    if (isProteinStructure) {
                        oSet.addAtomContainer(oBP);
                        if (useRebondTool.isSet()) {
                            try {
                                if (!createBondsWithRebondTool(oBP)) {
                                    logger.info(""Bonds could not be created using the RebondTool when PDB file was read."");
                                    oBP.removeAllBonds();
                                }
                            } catch (Exception exception) {
                                logger.info(""Bonds could not be created when PDB file was read."");
                                logger.debug(exception);
                            }
                        }
                    } else {
                        if (useRebondTool.isSet())
                            createBondsWithRebondTool(molecularStructure);
                        oSet.addAtomContainer(molecularStructure);
                    }
                } else if (cCol.equals(""MODEL "")) {
                    if (isProteinStructure) {
                        if (oBP.getAtomCount() > 0) {
                            oSet.addAtomContainer(oBP);
                            oModel.setMoleculeSet(oSet);
                            oSeq.addChemModel(oModel);
                            oBP = new PDBPolymer();
                            oModel = oFile.getBuilder().newInstance(IChemModel.class);
                            oSet = oFile.getBuilder().newInstance(IAtomContainerSet.class);
                            atomNumberMap.clear();
                        }
                    } else {
                        if (molecularStructure.getAtomCount() > 0) {
                            oSet.addAtomContainer(molecularStructure);
                            oModel.setMoleculeSet(oSet);
                            oSeq.addChemModel(oModel);
                            molecularStructure = oFile.getBuilder().newInstance(IAtomContainer.class);
                            oModel = oFile.getBuilder().newInstance(IChemModel.class);
                            oSet = oFile.getBuilder().newInstance(IAtomContainerSet.class);
                        }
                    }
                } else if (""REMARK"".equalsIgnoreCase(cCol)) {
                    Object comment = oFile.getProperty(CDKConstants.COMMENT);
                    if (comment == null) {
                        comment = """";
                    }
                    if (lineLength > 12) {
                        comment = comment.toString() + cRead.substring(11).trim() + ""\n"";
                        oFile.setProperty(CDKConstants.COMMENT, comment);
                    } else {
                        logger.warn(""REMARK line found without any comment!"");
                    }
                } else if (""COMPND"".equalsIgnoreCase(cCol)) {
                    String title = cRead.substring(10).trim();
                    oFile.setProperty(CDKConstants.TITLE, title);
                } else if (readConnect.isSet() && ""CONECT"".equalsIgnoreCase(cCol)) {
                    cRead.trim();
                    if (cRead.length() < 16) {
                        logger.debug(""Skipping unexpected empty CONECT line! : "", cRead);
                    } else {
                        int lineIndex = 6;
                        int atomFromNumber = -1;
                        int atomToNumber = -1;
                        IAtomContainer molecule = (isProteinStructure) ? oBP : molecularStructure;
                        while (lineIndex + 5 <= cRead.length()) {
                            String part = cRead.substring(lineIndex, lineIndex + 5).trim();
                            if (atomFromNumber == -1) {
                                try {
                                    atomFromNumber = Integer.parseInt(part);
                                } catch (NumberFormatException nfe) {
                                }
                            } else {
                                try {
                                    atomToNumber = Integer.parseInt(part);
                                } catch (NumberFormatException nfe) {
                                    atomToNumber = -1;
                                }
                                if (atomFromNumber != -1 && atomToNumber != -1) {
                                    addBond(molecule, atomFromNumber, atomToNumber);
                                    logger.debug(""Bonded "" + atomFromNumber + "" with "" + atomToNumber);
                                }
                            }
                            lineIndex += 5;
                        }
                    }
                } else if (""HELIX "".equalsIgnoreCase(cCol)) {
                    PDBStructure structure = new PDBStructure();
                    structure.setStructureType(PDBStructure.HELIX);
                    structure.setStartChainID(cRead.charAt(19));
                    structure.setStartSequenceNumber(Integer.parseInt(cRead.substring(21, 25).trim()));
                    structure.setStartInsertionCode(cRead.charAt(25));
                    structure.setEndChainID(cRead.charAt(31));
                    structure.setEndSequenceNumber(Integer.parseInt(cRead.substring(33, 37).trim()));
                    structure.setEndInsertionCode(cRead.charAt(37));
                    oBP.addStructure(structure);
                } else if (""SHEET "".equalsIgnoreCase(cCol)) {
                    PDBStructure structure = new PDBStructure();
                    structure.setStructureType(PDBStructure.SHEET);
                    structure.setStartChainID(cRead.charAt(21));
                    structure.setStartSequenceNumber(Integer.parseInt(cRead.substring(22, 26).trim()));
                    structure.setStartInsertionCode(cRead.charAt(26));
                    structure.setEndChainID(cRead.charAt(32));
                    structure.setEndSequenceNumber(Integer.parseInt(cRead.substring(33, 37).trim()));
                    structure.setEndInsertionCode(cRead.charAt(37));
                    oBP.addStructure(structure);
                } else if (""TURN  "".equalsIgnoreCase(cCol)) {
                    PDBStructure structure = new PDBStructure();
                    structure.setStructureType(PDBStructure.TURN);
                    structure.setStartChainID(cRead.charAt(19));
                    structure.setStartSequenceNumber(Integer.parseInt(cRead.substring(20, 24).trim()));
                    structure.setStartInsertionCode(cRead.charAt(24));
                    structure.setEndChainID(cRead.charAt(30));
                    structure.setEndSequenceNumber(Integer.parseInt(cRead.substring(31, 35).trim()));
                    structure.setEndInsertionCode(cRead.charAt(35));
                    oBP.addStructure(structure);
                }
            }
        } while (_oInput.ready() && (cRead != null));
    } catch (IOException | IllegalArgumentException | CDKException e) {
        logger.error(""Found a problem at line:"");
        logger.error(cRead);
        logger.error(""01234567890123456789012345678901234567890123456789012345678901234567890123456789"");
        logger.error(""          1         2         3         4         5         6         7         "");
        logger.error(""  error: "" + e.getMessage());
        logger.debug(e);
        e.printStackTrace();
    }
    try {
        _oInput.close();
    } catch (Exception e) {
        logger.debug(e);
    }
    oModel.setMoleculeSet(oSet);
    oSeq.addChemModel(oModel);
    oFile.addChemSequence(oSeq);
    return oFile;
}",readChemFile,org/openscience/cdk/io/PDBReader.java,/storage/pdb/src/main/java/org/openscience/cdk/io/PDBReader.java,"/**
     * Read a <code>ChemFile</code> from a file in PDB format. The molecules
     * in the file are stored as <code>BioPolymer</code>s in the
     * <code>ChemFile</code>. The residues are the monomers of the
     * <code>BioPolymer</code>, and their names are the concatenation of the
     * residue, chain id, and the sequence number. Separate chains (denoted by
     * TER records) are stored as separate <code>BioPolymer</code> molecules.
     *
     * <p>Connectivity information is not currently read.
     *
     * @return The ChemFile that was read from the PDB file.
     */",204-498,"('readChemFile', {'INSTRUCTION': {'covered': 656, 'missed': 159}, 'BRANCH': {'covered': 68, 'missed': 22}, 'LINE': {'covered': 148, 'missed': 38}, 'COMPLEXITY': {'covered': 28, 'missed': 18}, 'METHOD': {'covered': 1, 'missed': 0}})",1847.0,16.0,Read a <code>ChemFile</code> from a file in PDB format.,Reads and returns a ChemFile object in PDB format.,You can read the code from a file.,0.329927416817301,Read a <code>ChemFile</code> from a file in PDB format.
515,cdk,"public DescriptorValue calculate(IAtomContainer mol){
    try {
        mol = mol.clone();
    } catch (CloneNotSupportedException ex) {
    }
    double polar = 0, weight = 0;
    try {
        IChemObjectBuilder builder = mol.getBuilder();
        CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.getInstance(builder);
        for (IAtom atom : mol.atoms()) {
            IAtomType type = matcher.findMatchingAtomType(mol, atom);
            AtomTypeManipulator.configure(atom, type);
        }
        CDKHydrogenAdder adder = CDKHydrogenAdder.getInstance(builder);
        adder.addImplicitHydrogens(mol);
        TPSADescriptor tpsa = new TPSADescriptor();
        DescriptorValue value = tpsa.calculate(mol);
        polar = ((DoubleResult) value.getValue()).doubleValue();
        for (IAtom atom : mol.atoms()) {
            weight += Isotopes.getInstance().getMajorIsotope(atom.getSymbol()).getExactMass();
            Integer hcount = atom.getImplicitHydrogenCount();
            if (hcount != CDKConstants.UNSET)
                weight += hcount * 1.00782504;
        }
    } catch (CDKException | IOException exception) {
        return getDummyDescriptorValue(exception);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(weight == 0 ? 0 : polar / weight), getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/FractionalPSADescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/FractionalPSADescriptor.java,"/**
     * Calculates the topological polar surface area and expresses it as a ratio to molecule size.
     *
     * @param mol The {@link IAtomContainer} whose volume is to be calculated
     * @return descriptor(s) retaining to polar surface area
     */",104-145,"('calculate', {'INSTRUCTION': {'covered': 111, 'missed': 8}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 22, 'missed': 3}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",251.0,16.0,Calculates the topological polar surface area and expresses it as a ratio to molecule size.,"First computes the topological polar surface area, ultimately express this value as a ratio to molecule size.",The ratio to molecule size is calculated by summing the topological polar surface area.,0.346235219269334,Calculates the topological polar surface and expresses it as a ratio to the size of the molecule.
516,cdk,"public static List<IElement> elements(IMolecularFormula formula){
    List<IElement> elementList = new ArrayList<IElement>();
    List<String> stringList = new ArrayList<String>();
    for (IIsotope isotope : formula.isotopes()) {
        if (!stringList.contains(isotope.getSymbol())) {
            elementList.add(isotope);
            stringList.add(isotope.getSymbol());
        }
    }
    return elementList;
}",elements,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     *  Get a list of all Elements which are contained
     *  molecular.
     *
     *@param   formula The MolecularFormula to check
     *@return          The list with the IElements in this molecular formula
     */",169-188,"('elements', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,11.0,Get a list of all Elements which are contained  molecular.,Retrieves and returns a list of all the Elements which are contained into molecular.,Get a list of elements that are contained in a molecule.,0.192648846638216,Get a list of all the elements that are molecular contents.
517,matsim-libs,"public static void addCarrierVehicle(Carrier carrier, CarrierVehicle carrierVehicle){
    carrier.getCarrierCapabilities().getCarrierVehicles().put(carrierVehicle.getId(), carrierVehicle);
}",addCarrierVehicle,org/matsim/contrib/freight/carrier/CarrierUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/carrier/CarrierUtils.java,"/**
	 * Adds an carrierVehicle to the CarrierCapabilites of the Carrier.
	 * @param carrier
	 * @param carrierVehicle
	 */",19-26,"('addCarrierVehicle', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,10.0,Adds an carrierVehicle to the CarrierCapabilites of the Carrier.,Adds a carrierVehicle object to the CarrierCapabilities of the Carrirer.,The CarrierCapabilites are added to the carrier vehicle.,0.379942985479416,Adds a carrier vehicle to the Carrier's CarrierCapabilites.
518,weblogic-kubernetes-operator," boolean containsServer(@Nonnull String serverName){
    return getServerConfigs().stream().anyMatch(c -> serverName.equals(c.getName()));
}",containsServer,oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,"/**
   * Whether this cluster contains a server with the given server name,
   * including servers that are both configured and dynamic servers.
   *
   * @param serverName server name to be checked
   * @return True if the cluster contains a server with the given server name
   */",365-374,"('containsServer', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,22.0,"Whether this cluster contains a server with the given server name,  including servers that are both configured and dynamic servers.","Returns true if the cluster contains a server with the given server name, otherwise false.","Whether this cluster contains a server with a given name, or one that is configured and dynamic.",0.553052511352453,"If this cluster contains a server with the given server name, including servers that are both configured and dynamic servers."
519,cdk,"private PDBAtom readAtom(String cLine, int lineLength) throws CDKException{
    if (lineLength < 59) {
        throw new RuntimeException(""PDBReader error during readAtom(): line too short"");
    }
    boolean isHetatm = cLine.startsWith(""HETATM"");
    String atomName = cLine.substring(12, 16).trim();
    String resName = cLine.substring(17, 20).trim();
    String symbol = parseAtomSymbol(cLine);
    if (symbol == null)
        handleError(""Cannot parse symbol from "" + atomName);
    PDBAtom oAtom = new PDBAtom(symbol, new Point3d(Double.parseDouble(cLine.substring(30, 38)), Double.parseDouble(cLine.substring(38, 46)), Double.parseDouble(cLine.substring(46, 54))));
    if (useHetDictionary.isSet() && isHetatm) {
        String cdkType = typeHetatm(resName, atomName);
        oAtom.setAtomTypeName(cdkType);
        if (cdkType != null) {
            try {
                cdkAtomTypeFactory.configure(oAtom);
            } catch (CDKException cdke) {
                logger.warn(""Could not configure"", resName, "" "", atomName);
            }
        }
    }
    oAtom.setRecord(cLine);
    oAtom.setSerial(Integer.parseInt(cLine.substring(6, 11).trim()));
    oAtom.setName(atomName.trim());
    oAtom.setAltLoc(cLine.substring(16, 17).trim());
    oAtom.setResName(resName);
    oAtom.setChainID(cLine.substring(21, 22).trim());
    oAtom.setResSeq(cLine.substring(22, 26).trim());
    oAtom.setICode(cLine.substring(26, 27).trim());
    if (useHetDictionary.isSet() && isHetatm) {
        oAtom.setID(oAtom.getResName() + ""."" + atomName);
    } else {
        oAtom.setAtomTypeName(oAtom.getResName() + ""."" + atomName);
    }
    if (lineLength >= 59) {
        String frag = cLine.substring(54, Math.min(lineLength, 60)).trim();
        if (frag.length() > 0) {
            oAtom.setOccupancy(Double.parseDouble(frag));
        }
    }
    if (lineLength >= 65) {
        String frag = cLine.substring(60, Math.min(lineLength, 66)).trim();
        if (frag.length() > 0) {
            oAtom.setTempFactor(Double.parseDouble(frag));
        }
    }
    if (lineLength >= 75) {
        oAtom.setSegID(cLine.substring(72, Math.min(lineLength, 76)).trim());
    }
    if (lineLength >= 79) {
        String frag;
        if (lineLength >= 80) {
            frag = cLine.substring(78, 80).trim();
        } else {
            frag = cLine.substring(78);
        }
        if (frag.length() > 0) {
            if (frag.endsWith(""-"") || frag.endsWith(""+"")) {
                oAtom.setCharge(Double.parseDouble(new StringBuilder(frag).reverse().toString()));
            } else {
                oAtom.setCharge(Double.parseDouble(frag));
            }
        }
    }
    String oxt = cLine.substring(13, 16).trim();
    if (oxt.equals(""OXT"")) {
        oAtom.setOxt(true);
    } else {
        oAtom.setOxt(false);
    }
    return oAtom;
}",readAtom,org/openscience/cdk/io/PDBReader.java,/storage/pdb/src/main/java/org/openscience/cdk/io/PDBReader.java,"/**
     * Creates an <code>Atom</code> and sets properties to their values from
     * the ATOM or HETATM record. If the line is shorter than 80 characters, the
     * information past 59 characters is treated as optional. If the line is
     * shorter than 59 characters, a <code>RuntimeException</code> is thrown.
     *
     * @param cLine  the PDB ATOM or HEATATM record.
     * @return the <code>Atom</code> created from the record.
     * @throws RuntimeException if the line is too short (less than 59 characters).
     */",610-723,"('readAtom', {'INSTRUCTION': {'covered': 250, 'missed': 48}, 'BRANCH': {'covered': 27, 'missed': 9}, 'LINE': {'covered': 46, 'missed': 6}, 'COMPLEXITY': {'covered': 10, 'missed': 9}, 'METHOD': {'covered': 1, 'missed': 0}})",684.0,22.0,Creates an <code>Atom</code> and sets properties to their values from  the ATOM or HETATM record.,"Uses the ATOM or HETAM record of creating and setting their properties. For all those lines containing less than 80 characters,  the information longer than 50 is treated as optional. If the line contains less than 59 characters, then a RuntimeExcpetion is thrown.",The Atom or HETAm record is used to set the properties to their values.,0.311175817068947,Creates an <code>atom</code> and sets properties to their values from the ATOM or HETATM record.
520,dcache,"public boolean hasExpired(){
    Date now = new Date();
    return _whenIShouldExpire != null ? !now.before(_whenIShouldExpire) : false;
}",hasExpired,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,"/**
     * This function checks whether our parent should expunge us.
     */",175-183,"('hasExpired', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,10.0,This function checks whether our parent should expunge us.,Checks the cases in which the parent can destroy us.,The function checks if our parent should expunge us.,2.24886654103452,This function checks if our parent should write us off.
521,acs-aem-commons,"private boolean isChecksumable(Node node, ChecksumGeneratorOptions options) throws RepositoryException{
    final Set<String> nodeTypeIncludes = options.getIncludedNodeTypes();
    final Set<String> nodeTypeExcludes = options.getExcludedNodeTypes();
    final String primaryNodeType = node.getPrimaryNodeType().getName();
    return nodeTypeIncludes.contains(primaryNodeType) && !nodeTypeExcludes.contains(primaryNodeType);
}",isChecksumable,com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,"/**
     * Ensures the node's primary type is included in the Included Node Types and NOT in the Excluded Node Types and NOT in the Excluded Node Names.
     *
     * @param node    the candidate node
     * @param options the checksum options containing the included and excluded none types
     * @return true if the node represents a checksum-able node system
     * @throws RepositoryException
     */",142-157,"('isChecksumable', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",70.0,28.0,Ensures the node's primary type is included in the Included Node Types and NOT in the Excluded Node Types and NOT in the Excluded Node Names.,"Makes sure the node's primary type is included in the included node types, not included in the Excluded Node Types and not included in the Excluded Node Names.",The included and excluded types of the primary type of the node should be included.,1.43477965344178,Ensures that the primary node type is included in the included node types and NOT in the excluded node types and NOT in the excluded node names.
522,dcache,"public boolean equalsOrHasChild(StatePath otherPath){
    if (otherPath == null) {
        return false;
    }
    if (_elements.size() > otherPath._elements.size()) {
        return false;
    }
    for (int i = 0; i < _elements.size(); i++) {
        if (_elements.get(i) != otherPath._elements.get(i)) {
            return false;
        }
    }
    return true;
}",equalsOrHasChild,org/dcache/services/info/base/StatePath.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StatePath.java,"/**
     * Check whether otherPath points to the same location, or is a child of this path.  This is
     * true iff each element of this path is identical to the corresponding element in otherPath.
     * <pre>
     *  StatePath p1 = new StatePath(""foo.bar"");
     *  StatePath p2 = new StatePath(""foo.bar.baz"");
     *
     *  p1.equalsOrHasChild(p1) // true
     *  p2.equalsOrHasChild(p2) // true
     *  p1.equalsOrHasChild(p2) // true
     *  p2.equalsOrHasChild(p1) // false
     * </pre>
     *
     * @param otherPath the potential child path
     * @return true if otherPath is a child of this path.
     */",181-227,"('equalsOrHasChild', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,17.0,"Check whether otherPath points to the same location, or is a child of this path.",Implements the control needed to check whether otherPath is of the current path or a child. Returns true iff each element of the current path matches the corresponding element in otherPath.,"If otherpath points to the same location, it's a child of this path.",0.37755884263397,Check if otherPath points to the same location or if it is a child of that path.
523,jackson-databind,"public static T[] insertInListNoDup(T[] array, T element){
    final int len = array.length;
    for (int ix = 0; ix < len; ++ix) {
        if (array[ix] == element) {
            if (ix == 0) {
                return array;
            }
            T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len);
            System.arraycopy(array, 0, result, 1, ix);
            result[0] = element;
            ++ix;
            int left = len - ix;
            if (left > 0) {
                System.arraycopy(array, ix, result, ix, left);
            }
            return result;
        }
    }
    T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len + 1);
    if (len > 0) {
        System.arraycopy(array, 0, result, 1, len);
    }
    result[0] = element;
    return result;
}",insertInListNoDup,com/fasterxml/jackson/databind/util/ArrayBuilders.java,/src/main/java/com/fasterxml/jackson/databind/util/ArrayBuilders.java,"/**
     * Helper method for constructing a new array that contains specified
     * element followed by contents of the given array but never contains
     * duplicates.
     * If element already existed, one of two things happens: if the element
     * was already the first one in array, array is returned as is; but
     * if not, a new copy is created in which element has moved as the head.
     */",198-238,"('insertInListNoDup', {'INSTRUCTION': {'covered': 74, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",210.0,23.0,Helper method for constructing a new array that contains specified  element followed by contents of the given array but never contains  duplicates.,"Constructs a new array containing the specified elements (non-duplicated) followed by the content of the array given as input. If the element already exists, then it is returned as is if it belongs to the first position of the array. If not, a new copy is created, and the element is moved as the head.",The method for constructing a new array that contains specified element followed by contents of the given array but never contains duplicate elements is called the helpers method.,0.521407435142276,"A helper method for constructing a new array that contains a specified element followed by the contents of the given array, but never contains duplicates."
524,dataverse,"public static void checkForDuplicateFileNamesFinal(DatasetVersion version, List<DataFile> newFiles, DataFile fileToReplace){
    // Step 1: create list of existing path names from all FileMetadata in the DatasetVersion
    // unique path name: directoryLabel + file separator + fileLabel
    Set<String> pathNamesExisting = existingPathNamesAsSet(version, ((fileToReplace == null) ? null : fileToReplace.getFileMetadata()));
    // Step 2: check each new DataFile against the list of path names, if a duplicate create a new unique file name
    for (Iterator<DataFile> dfIt = newFiles.iterator(); dfIt.hasNext(); ) {
        FileMetadata fm = dfIt.next().getFileMetadata();
        fm.setLabel(duplicateFilenameCheck(fm, pathNamesExisting));
    }
}",checkForDuplicateFileNamesFinal,edu/harvard/iq/dataverse/ingest/IngestUtil.java,/src/main/java/edu/harvard/iq/dataverse/ingest/IngestUtil.java,"/**
     * Checks a list of new data files for duplicate names, renaming any
     * duplicates to ensure that they are unique.
     *
     * @param version the dataset version
     * @param newFiles the list of new data files to add to it
     * @param fileToReplace
     */",54-74,"('checkForDuplicateFileNamesFinal', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",94.0,21.0,"Checks a list of new data files for duplicate names, renaming any  duplicates to ensure that they are unique.",Renames duplicate names after those have been fetched from a list of new data files.,Checks a list of new data files for duplicate names and renames any duplicate files that are not unique.,0.257551523809955,"Checks a list of new data files for duplicate names, renaming all duplicates to make sure they are unique."
525,shardingsphere-elasticjob,"public static boolean isExtraction(final String appURL){
    for (String each : EXTRACTION_TYPES) {
        if (appURL.endsWith(each)) {
            return true;
        }
    }
    return false;
}",isExtraction,org/apache/shardingsphere/elasticjob/cloud/scheduler/mesos/SupportedExtractionType.java,/elasticjob-cloud/elasticjob-cloud-scheduler/src/main/java/org/apache/shardingsphere/elasticjob/cloud/scheduler/mesos/SupportedExtractionType.java,"/**
     * Check whether the url is supported to extract or not.
     *
     * @param appURL app url
     * @return true is the url supported, otherwise not
     */",45-58,"('isExtraction', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,11.0,Check whether the url is supported to extract or not.,Checks whether for each extraction type the URL supports the extraction or not.,Check if the url is supported to extract.,0.0865203559077897,Check if the URL is supported for fetching or not.
526,dcache,"private void addComponent(String childName, StateComponent newChild){
    StateComponent existingChild = _children.get(childName);
    if (newChild instanceof StateComposite) {
        StateComposite newComposite = (StateComposite) newChild;
        if (existingChild instanceof StateComposite) {
            StateComposite existingComposite = (StateComposite) existingChild;
            for (Map.Entry<String, StateComponent> entry : existingComposite._children.entrySet()) {
                if (!newComposite._children.containsKey(entry.getKey())) {
                    newComposite._children.put(entry.getKey(), entry.getValue());
                }
            }
            newComposite.updateEarliestChildExpiryDate(existingComposite.getEarliestChildExpiryDate());
            newComposite.updateWhenIShouldExpireDate(existingComposite.getExpiryDate());
        }
    }
    _children.put(childName, newChild);
    LOGGER.trace(""Child {} now {}"", childName, newChild);
}",addComponent,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,"/**
     * Add a new component to our list of children.
     * <p>
     *
     * @param childName the name under which this item should be recorded
     * @param newChild  the StateComponent to be stored.
     */",441-482,"('addComponent', {'INSTRUCTION': {'covered': 67, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",155.0,10.0,Add a new component to our list of children.,Expand our list of children by adding to it a new component.,We need to add a new component to our list.,0.552740472916092,Add a new component to our children's list.
527,cdk,"public IMolecularFormulaSet generate(double mass){
    if (mass <= 0.0) {
        logger.error(""Proposed mass is not valid: "", mass);
        return null;
    }
    IMolecularFormula minimalMF = MolecularFormulaRangeManipulator.getMinimalFormula(mfRange, builder);
    IMolecularFormula maximalMF = MolecularFormulaRangeManipulator.getMaximalFormula(mfRange, builder);
    double massMim = MolecularFormulaManipulator.getTotalExactMass(minimalMF) - tolerance;
    double massMap = MolecularFormulaManipulator.getTotalExactMass(maximalMF) + tolerance;
    if (massMim > mass || massMap < mass) {
        logger.error(""Proposed mass is out of the range: "", mass);
        return null;
    }
    IMolecularFormulaSet molecularFormulaSet = builder.newInstance(IMolecularFormulaSet.class);
    int[][] matrix = this.matrix_Base;
    int numberElements = mfRange.getIsotopeCount();
    List<IIsotope> isotopes_TO = new ArrayList<IIsotope>();
    Iterator<IIsotope> isIt = mfRange.isotopes().iterator();
    while (isIt.hasNext()) isotopes_TO.add(isIt.next());
    isotopes_TO = orderList(isotopes_TO);
    for (int i = 0; i < matrix.length; i++) {
        int[] value_In = new int[numberElements];
        for (int j = 0; j < numberElements; j++) {
            if (matrix[i][j] == 0)
                value_In[j] = 0;
            else
                value_In[j] = 1;
        }
        int count_E = 0;
        ArrayList<Integer> elem_Pos = new ArrayList<Integer>();
        for (int j = 0; j < matrix[1].length; j++) if (value_In[j] != 0) {
            count_E++;
            elem_Pos.add(j);
        }
        boolean flag = true;
        int possChan = 0;
        String lastMFString = """";
        while (flag) {
            boolean flagBreak = false;
            for (int j = 0; j < matrix[1].length; j++) {
                int min = mfRange.getIsotopeCountMin(isotopes_TO.get(j));
                if (value_In[j] == 0)
                    if (min != 0)
                        flagBreak = true;
            }
            if (flagBreak)
                break;
            int occurence = getMaxOccurence(mass, elem_Pos.get(possChan).intValue(), value_In, isotopes_TO);
            if (occurence == 0)
                break;
            int maxx = mfRange.getIsotopeCountMax(isotopes_TO.get(elem_Pos.get(possChan).intValue()));
            int minn = mfRange.getIsotopeCountMin(isotopes_TO.get(elem_Pos.get(possChan).intValue()));
            if (occurence < minn | maxx < occurence) {
                if (possChan < elem_Pos.size() - 1) {
                    if (maxx < occurence)
                        value_In[elem_Pos.get(possChan).intValue()] = maxx;
                    possChan++;
                } else {
                    boolean foundZ = false;
                    for (int z = possChan - 1; z >= 0; z--) {
                        if (value_In[elem_Pos.get(z).intValue()] != 1) {
                            possChan = z;
                            foundZ = true;
                            int newValue = value_In[elem_Pos.get(possChan).intValue()] - 1;
                            value_In[elem_Pos.get(possChan).intValue()] = newValue;
                            for (int j = possChan + 1; j < elem_Pos.size(); j++) {
                                int p = elem_Pos.get(j).intValue();
                                value_In[p] = 1;
                            }
                            possChan++;
                            break;
                        }
                    }
                    if (!foundZ)
                        break;
                }
                continue;
            }
            value_In[elem_Pos.get(possChan).intValue()] = occurence;
            double massT = calculateMassT(isotopes_TO, value_In);
            double diff_new = Math.abs(mass - (massT));
            if (diff_new < tolerance) {
                IMolecularFormula myMF = getFormula(isotopes_TO, value_In);
                String newMFString = MolecularFormulaManipulator.getString(myMF);
                if (!newMFString.equals(lastMFString)) {
                    molecularFormulaSet.addMolecularFormula(myMF);
                    lastMFString = newMFString;
                }
            }
            if (count_E == 1)
                break;
            if (possChan < elem_Pos.size() - 1) {
                possChan++;
            } else {
                boolean foundZ = false;
                for (int z = possChan - 1; z >= 0; z--) {
                    if (value_In[elem_Pos.get(z).intValue()] != 1) {
                        possChan = z;
                        foundZ = true;
                        int newValue = value_In[elem_Pos.get(possChan).intValue()] - 1;
                        value_In[elem_Pos.get(possChan).intValue()] = newValue;
                        for (int j = possChan + 1; j < elem_Pos.size(); j++) {
                            int p = elem_Pos.get(j).intValue();
                            value_In[p] = 1;
                        }
                        possChan++;
                        break;
                    }
                }
                if (!foundZ)
                    break;
            }
        }
    }
    return returnOrdered(mass, molecularFormulaSet);
}",generate,org/openscience/cdk/formula/MassToFormulaTool.java,/legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java,"/**
     * Method that actually does the work of extracting the molecular formula.
     *
     * @param  mass            molecular formula to create from the mass
     * @return                 the filled molecular formulas as IMolecularFormulaSet
     */",242-415,"('generate', {'INSTRUCTION': {'covered': 462, 'missed': 1}, 'BRANCH': {'covered': 61, 'missed': 3}, 'LINE': {'covered': 89, 'missed': 0}, 'COMPLEXITY': {'covered': 30, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",951.0,12.0,Method that actually does the work of extracting the molecular formula.,Extracts the molecur formula.,The method actually does the work of getting the formula.,0.427849231626354,Method that actually does the work of extracting the molecular formula.
528,cdk,"public void removeStrand(String name){
    if (strands.containsKey(name)) {
        Strand strand = (Strand) strands.get(name);
        this.remove(strand);
        strands.remove(name);
    }
}",removeStrand,org/openscience/cdk/silent/BioPolymer.java,/base/silent/src/main/java/org/openscience/cdk/silent/BioPolymer.java,"/**
     * Removes a particular strand, specified by its name.
     *
     * @param name name of the strand to remove
     */",241-253,"('removeStrand', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,10.0,"Removes a particular strand, specified by its name.",This method takes a String name as input and removes it from a paricular strand.,A strand is removed by its name.,0.755635781624249,"Deletes a particular strand, specified by its name."
529,cdk,"public boolean matches(IBond bond){
    bond = BondRef.deref(bond);
    if (bond instanceof PharmacophoreBond) {
        PharmacophoreBond pbond = (PharmacophoreBond) bond;
        double bondLength = round(pbond.getBondLength(), 2);
        return bondLength >= lower && bondLength <= upper;
    } else
        return false;
}",matches,org/openscience/cdk/pharmacophore/PharmacophoreQueryBond.java,/tool/pcore/src/main/java/org/openscience/cdk/pharmacophore/PharmacophoreQueryBond.java,"/**
     * Checks whether the query distance constraint matches a target distance.
     * 
     * This method checks whether a query constraint is satisfied by an observed
     * distance (represented by a {@link PharmacophoreBond} in the target molecule.
     * Note that distance are compared upto 2 decimal places.
     *
     * @param bond The distance relationship in a target molecule
     * @return true if the target distance lies within the range of the query constraint
     */",82-101,"('matches', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,11.0,Checks whether the query distance constraint matches a target distance.,"Returns true if the query distance constraint matches a target distance, false otherwise.",The query distance constraint is checked to see if it matches the target distance.,0.277198099299571,Checks whether the query distance constraint matches a target distance.
531,cdk,"public void distributePartners(IAtom atom, IAtomContainer placedNeighbours, Point2d sharedAtomsCenter, IAtomContainer unplacedNeighbours, double bondLength){
    double occupiedAngle = 0;
    IAtom[] sortedAtoms = null;
    double startAngle = 0.0;
    double addAngle = 0.0;
    double radius = 0.0;
    double remainingAngle = 0.0;
    Vector2d sharedAtomsCenterVector = new Vector2d(sharedAtomsCenter);
    Vector2d newDirection = new Vector2d(atom.getPoint2d());
    Vector2d occupiedDirection = new Vector2d(sharedAtomsCenter);
    occupiedDirection.sub(newDirection);
    if (Math.abs(occupiedDirection.length()) < 0.001)
        occupiedDirection = new Vector2d(0, 1);
    logger.debug(""distributePartners->occupiedDirection.lenght(): "" + occupiedDirection.length());
    List<IAtom> atomsToDraw = new ArrayList<IAtom>();
    logger.debug(""Number of shared atoms: "", placedNeighbours.getAtomCount());
    if (placedNeighbours.getAtomCount() == 1) {
        logger.debug(""Only one neighbour..."");
        for (int f = 0; f < unplacedNeighbours.getAtomCount(); f++) {
            atomsToDraw.add(unplacedNeighbours.getAtom(f));
        }
        addAngle = Math.PI * 2 / (unplacedNeighbours.getAtomCount() + placedNeighbours.getAtomCount());
        IAtom placedAtom = placedNeighbours.getAtom(0);
        double xDiff = placedAtom.getPoint2d().x - atom.getPoint2d().x;
        double yDiff = placedAtom.getPoint2d().y - atom.getPoint2d().y;
        logger.debug(""distributePartners->xdiff: "" + Math.toDegrees(xDiff));
        logger.debug(""distributePartners->ydiff: "" + Math.toDegrees(yDiff));
        startAngle = GeometryUtil.getAngle(xDiff, yDiff);
        logger.debug(""distributePartners->angle: "" + Math.toDegrees(startAngle));
        populatePolygonCorners(atomsToDraw, new Point2d(atom.getPoint2d()), startAngle, addAngle, bondLength);
        return;
    } else if (placedNeighbours.getAtomCount() == 0) {
        logger.debug(""First atom..."");
        for (int f = 0; f < unplacedNeighbours.getAtomCount(); f++) {
            atomsToDraw.add(unplacedNeighbours.getAtom(f));
        }
        addAngle = Math.PI * 2.0 / unplacedNeighbours.getAtomCount();
        startAngle = 0.0;
        populatePolygonCorners(atomsToDraw, new Point2d(atom.getPoint2d()), startAngle, addAngle, bondLength);
        return;
    }
    if (doAngleSnap(atom, placedNeighbours)) {
        int numTerminal = 0;
        for (IAtom unplaced : unplacedNeighbours.atoms()) if (molecule.getConnectedBondsCount(unplaced) == 1)
            numTerminal++;
        if (numTerminal == unplacedNeighbours.getAtomCount()) {
            final Vector2d a = newVector(placedNeighbours.getAtom(0).getPoint2d(), atom.getPoint2d());
            final Vector2d b = newVector(placedNeighbours.getAtom(1).getPoint2d(), atom.getPoint2d());
            final double d1 = GeometryUtil.getAngle(a.x, a.y);
            final double d2 = GeometryUtil.getAngle(b.x, b.y);
            double sweep = a.angle(b);
            if (sweep < Math.PI) {
                sweep = 2 * Math.PI - sweep;
            }
            startAngle = d2;
            if (d1 > d2 && d1 - d2 < Math.PI || d2 - d1 >= Math.PI) {
                startAngle = d1;
            }
            sweep /= (1 + unplacedNeighbours.getAtomCount());
            populatePolygonCorners(StreamSupport.stream(unplacedNeighbours.atoms().spliterator(), false).collect(Collectors.toList()), atom.getPoint2d(), startAngle, sweep, bondLength);
            markPlaced(unplacedNeighbours);
            return;
        } else {
            atom.removeProperty(MacroCycleLayout.MACROCYCLE_ATOM_HINT);
        }
    }
    sharedAtomsCenterVector.sub(newDirection);
    newDirection = sharedAtomsCenterVector;
    newDirection.normalize();
    newDirection.scale(bondLength);
    newDirection.negate();
    logger.debug(""distributePartners->newDirection.lenght(): "" + newDirection.length());
    Point2d distanceMeasure = new Point2d(atom.getPoint2d());
    distanceMeasure.add(newDirection);
    sortedAtoms = AtomContainerManipulator.getAtomArray(placedNeighbours);
    GeometryUtil.sortBy2DDistance(sortedAtoms, distanceMeasure);
    Vector2d closestPoint1 = new Vector2d(sortedAtoms[0].getPoint2d());
    Vector2d closestPoint2 = new Vector2d(sortedAtoms[1].getPoint2d());
    closestPoint1.sub(new Vector2d(atom.getPoint2d()));
    closestPoint2.sub(new Vector2d(atom.getPoint2d()));
    occupiedAngle = closestPoint1.angle(occupiedDirection);
    occupiedAngle += closestPoint2.angle(occupiedDirection);
    double angle1 = GeometryUtil.getAngle(sortedAtoms[0].getPoint2d().x - atom.getPoint2d().x, sortedAtoms[0].getPoint2d().y - atom.getPoint2d().y);
    double angle2 = GeometryUtil.getAngle(sortedAtoms[1].getPoint2d().x - atom.getPoint2d().x, sortedAtoms[1].getPoint2d().y - atom.getPoint2d().y);
    double angle3 = GeometryUtil.getAngle(distanceMeasure.x - atom.getPoint2d().x, distanceMeasure.y - atom.getPoint2d().y);
    if (debug) {
        try {
            logger.debug(""distributePartners->sortedAtoms[0]: "", (molecule.indexOf(sortedAtoms[0]) + 1));
            logger.debug(""distributePartners->sortedAtoms[1]: "", (molecule.indexOf(sortedAtoms[1]) + 1));
            logger.debug(""distributePartners->angle1: "", Math.toDegrees(angle1));
            logger.debug(""distributePartners->angle2: "", Math.toDegrees(angle2));
        } catch (Exception exc) {
            logger.debug(exc);
        }
    }
    IAtom startAtom = null;
    if (angle1 > angle3) {
        if (angle1 - angle3 < Math.PI) {
            startAtom = sortedAtoms[1];
        } else {
            startAtom = sortedAtoms[0];
        }
    } else {
        if (angle3 - angle1 < Math.PI) {
            startAtom = sortedAtoms[0];
        } else {
            startAtom = sortedAtoms[1];
        }
    }
    remainingAngle = (2 * Math.PI) - occupiedAngle;
    addAngle = remainingAngle / (unplacedNeighbours.getAtomCount() + 1);
    if (debug) {
        try {
            logger.debug(""distributePartners->startAtom: "" + (molecule.indexOf(startAtom) + 1));
            logger.debug(""distributePartners->remainingAngle: "" + Math.toDegrees(remainingAngle));
            logger.debug(""distributePartners->addAngle: "" + Math.toDegrees(addAngle));
            logger.debug(""distributePartners-> partners.getAtomCount(): "" + unplacedNeighbours.getAtomCount());
        } catch (Exception exc) {
            logger.debug(exc);
        }
    }
    for (int f = 0; f < unplacedNeighbours.getAtomCount(); f++) {
        atomsToDraw.add(unplacedNeighbours.getAtom(f));
    }
    radius = bondLength;
    startAngle = GeometryUtil.getAngle(startAtom.getPoint2d().x - atom.getPoint2d().x, startAtom.getPoint2d().y - atom.getPoint2d().y);
    logger.debug(""Before check: distributePartners->startAngle: "" + startAngle);
    logger.debug(""After check: distributePartners->startAngle: "" + startAngle);
    populatePolygonCorners(atomsToDraw, new Point2d(atom.getPoint2d()), startAngle, addAngle, radius);
}",distributePartners,org/openscience/cdk/layout/AtomPlacer.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/AtomPlacer.java,"/**
     *  Distribute the bonded atoms (neighbours) of an atom such that they fill the
     *  remaining space around an atom in a geometrically nice way.
     *  IMPORTANT: This method is not supposed to handle the
     *  case of one or no place neighbor. In the case of
     *  one placed neigbor, the chain placement methods
     *  should be used.
     *
     *@param  atom                The atom whose partners are to be placed
     *@param  placedNeighbours    The atoms which are already placed
     *@param  unplacedNeighbours  The partners to be placed
     *@param  bondLength          The standared bond length for the newly placed
     *      Atoms
     *@param  sharedAtomsCenter   The 2D centre of the placed Atoms
     */",97-306,"('distributePartners', {'INSTRUCTION': {'covered': 670, 'missed': 16}, 'BRANCH': {'covered': 32, 'missed': 2}, 'LINE': {'covered': 110, 'missed': 5}, 'COMPLEXITY': {'covered': 16, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",1389.0,26.0,Distribute the bonded atoms (neighbours) of an atom such that they fill the  remaining space around an atom in a geometrically nice way.,Fills the geometric missing space around an atom after having distributed the bonded atoms of an atom.,The atoms should be distributed in a way that they fill the remaining space around the atom in a nice way.,0.284689444054282,Distribute the bonded (neighboring) atoms of an atom so that they fill the remaining space around an atom in a geometrically pleasing way.
533,weblogic-kubernetes-operator,"public static boolean isDns1123Required(String fieldName){
    if (fieldName != null) {
        for (String dns1123Field : getDns1123Fields()) {
            if (dns1123Field.equalsIgnoreCase(fieldName)) {
                return true;
            }
        }
    }
    return false;
}",isDns1123Required,oracle/kubernetes/operator/helpers/LegalNames.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/LegalNames.java,"/**
   * Returns true if the value in the field is required to be DNS-1123 legal.
   *
   * @param fieldName Name of the field to be checked
   * @return true if the value needs to be DNS1123 legal, false otherwise
   */",195-210,"('isDns1123Required', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,15.0,Returns true if the value in the field is required to be DNS-1123 legal.,"Cheks whether the value in the field is required to be DNS-1123 legal. If that is the case, then return true, false otherwise.","If the field is required to be legal, this is true.",0.266453992110066,Returns true if the value of the field should be LEGAL DNS-1123.
534,tablesaw,"public static String removeZeroDecimal(final String str){
    if (Strings.isNullOrEmpty(str)) {
        return str;
    }
    return ZERO_DECIMAL_PATTERN.matcher(str).replaceFirst(EMPTY);
}",removeZeroDecimal,tech/tablesaw/util/StringUtils.java,/core/src/main/java/tech/tablesaw/util/StringUtils.java,"/**
   * Removes all trailing zero decimals from the given String, assuming all decimals are zero and
   * any zero decimals actually exist.
   *
   * <p>A {@code null} input String returns {@code null}.
   *
   * @param str the String to handle, may be null
   * @return string without trailing zero decimals
   */",526-540,"('removeZeroDecimal', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,22.0,"Removes all trailing zero decimals from the given String, assuming all decimals are zero and  any zero decimals actually exist.",Strips all the trailing zero decimals from the given string.,"If all decimals are zero and any zero decimals actually exist, then the trailing zero decimals are removed from the given string.",0.276878010133622,"Removes all end null decimals from the given string, assuming that all decimals are zero and all null decimals actually exist."
535,weblogic-kubernetes-operator,"public Map<String, Object> toTopology(){
    Map<String, Object> topology = new HashMap<>();
    topology.put(""domainValid"", ""true"");
    topology.put(""domain"", createDomainTopology());
    return topology;
}",toTopology,oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,"/**
   * Returns the topology equivalent of the domain configuration, as a map. It may be converted to
   * YAML or JSON via an object mapper.
   *
   * @return a map containing the topology
   */",434-445,"('toTopology', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",50.0,13.0,"Returns the topology equivalent of the domain configuration, as a map.",Returns a new Topology Map equivalent to the domain configuration.,The map is the equivalent of the domain configuration.,0.193336111920752,"Returns the topological equivalent of the domain configuration, as a mapping."
536,jooby,"public OpenAPI generate(@Nonnull String classname){
    ClassLoader classLoader = Optional.ofNullable(this.classLoader).orElseGet(getClass()::getClassLoader);
    ClassSource source = new ClassSource(classLoader);
    RouteParser routes = new RouteParser(metaInf);
    ParserContext ctx = new ParserContext(source, TypeFactory.fromJavaName(classname), debug);
    List<OperationExt> operations = routes.parse(ctx);
    String contextPath = ContextPathParser.parse(ctx);
    OpenAPIExt openapi = new OpenAPIExt();
    openapi.setSource(Optional.ofNullable(ctx.getMainClass()).orElse(classname));
    OpenAPIParser.parse(ctx, openapi);
    OpenAPIExt.fromTemplate(basedir, classLoader, templateName).ifPresent(template -> merge(openapi, template));
    defaults(classname, contextPath, openapi);
    ctx.schemas().forEach(schema -> openapi.schema(schema.getName(), schema));
    Map<String, Tag> globalTags = new LinkedHashMap<>();
    Paths paths = new Paths();
    for (OperationExt operation : operations) {
        String pattern = operation.getPattern();
        if (!includes(pattern) || excludes(pattern)) {
            log.debug(""skipping {}"", pattern);
            continue;
        }
        Map<String, String> regexMap = new HashMap<>();
        Router.pathKeys(pattern, (key, value) -> Optional.ofNullable(value).ifPresent(v -> regexMap.put(key, v)));
        if (regexMap.size() > 0) {
            for (Map.Entry<String, String> e : regexMap.entrySet()) {
                String name = e.getKey();
                String regex = e.getValue();
                operation.getParameter(name).ifPresent(parameter -> parameter.getSchema().setPattern(regex));
                if (regex.equals(""\\.*"")) {
                    if (name.equals(""*"")) {
                        pattern = pattern.substring(0, pattern.length() - 1) + ""{*}"";
                    } else {
                        pattern = pattern.replace(""*"" + name, ""{"" + name + ""}"");
                    }
                } else {
                    pattern = pattern.replace(name + "":"" + regex, name);
                }
            }
        }
        PathItem pathItem = paths.computeIfAbsent(pattern, k -> new PathItem());
        pathItem.operation(PathItem.HttpMethod.valueOf(operation.getMethod()), operation);
        Optional.ofNullable(operation.getPathSummary()).ifPresent(pathItem::setSummary);
        Optional.ofNullable(operation.getPathDescription()).ifPresent(pathItem::setDescription);
        operation.getGlobalTags().forEach(tag -> globalTags.put(tag.getName(), tag));
    }
    globalTags.values().forEach(tag -> {
        if (tag.getDescription() != null || tag.getExtensions() != null) {
            openapi.addTagsItem(tag);
        }
    });
    openapi.setOperations(operations);
    openapi.setPaths(paths);
    return openapi;
}",generate,io/jooby/openapi/OpenAPIGenerator.java,/modules/jooby-openapi/src/main/java/io/jooby/openapi/OpenAPIGenerator.java,"/**
   * Generate an {@link OpenAPI} model from Jooby class. This method parses class byte code and
   * generates an open api model from it. Compilation must be done with debug information and
   * parameters name available.
   *
   * Optionally, the <code>conf/openapi.yaml</code> is used as template and get merged into the
   * final model.
   *
   * @param classname Application class name.
   * @return Model.
   */",165-247,"('generate', {'INSTRUCTION': {'covered': 256, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 44, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",608.0,12.0,Generate an {@link OpenAPI} model from Jooby class.,Returns an OpenAPI object from Jooby Class by parsing the class byte code.,The model is from the class.,0.349624626329339,Generate an {@link OpenAPI} template from the Jooby class.
537,anserini,"public static float computeQueryDocumentScoreWithSimilarityAndAnalyzer(IndexReader reader, String docid, String q, Similarity similarity, Analyzer analyzer) throws IOException{
    IndexSearcher searcher = new IndexSearcher(reader);
    searcher.setSimilarity(similarity);
    Query query = new BagOfWordsQueryGenerator().buildQuery(IndexArgs.CONTENTS, analyzer, q);
    Query filterQuery = new ConstantScoreQuery(new TermQuery(new Term(IndexArgs.ID, docid)));
    BooleanQuery.Builder builder = new BooleanQuery.Builder();
    builder.add(filterQuery, BooleanClause.Occur.MUST);
    builder.add(query, BooleanClause.Occur.MUST);
    Query finalQuery = builder.build();
    TopDocs rs = searcher.search(finalQuery, 1);
    return rs.scoreDocs.length == 0 ? 0 : rs.scoreDocs[0].score - 1;
}",computeQueryDocumentScoreWithSimilarityAndAnalyzer,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,"/**
   * Computes the score of a document with respect to a query given a scoring function and an analyzer.
   *
   * @param reader index reader
   * @param docid docid of the document to score
   * @param q query
   * @param similarity scoring function
   * @param analyzer analyzer to use
   * @return the score of the document with respect to the query
   * @throws IOException if error encountered during query
   */",691-727,"('computeQueryDocumentScoreWithSimilarityAndAnalyzer', {'INSTRUCTION': {'covered': 64, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",161.0,19.0,Computes the score of a document with respect to a query given a scoring function and an analyzer.,Returns the score of a document wrt to a query given an analyzer and a scoring function.,The score of a document is computed by using a scoring function and an analyzer.,0.16578216515917,Calculates the score of a document against a query using a scoring function and a parser.
538,cdk,"private boolean refine(int row){
    int marking = -(row + 1);
    boolean changed;
    do {
        changed = false;
        for (int n = row + 1; n < matrix.nRows; n++) {
            for (int m = 0; m < matrix.mCols; m++) {
                if (matrix.get(n, m) && !verify(n, m)) {
                    matrix.mark(n, m, marking);
                    changed = true;
                    if (!hasCandidate(n))
                        return false;
                }
            }
        }
    } while (changed);
    return true;
}",refine,org/openscience/cdk/isomorphism/UllmannState.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/UllmannState.java,"/**
     * Refines the compatibility removing any mappings which have now become
     * invalid (since the last mapping). The matrix is refined from the row
     * after the current {@code row} - all previous rows are fixed. If when
     * refined we find a query vertex has no more candidates left in the target
     * we can never reach a feasible matching and refinement is aborted (false
     * is returned).
     *
     * @param row refine from here
     * @return match is still feasible
     */",161-194,"('refine', {'INSTRUCTION': {'covered': 56, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",122.0,18.0,Refines the compatibility removing any mappings which have now become  invalid (since the last mapping).,All those mappings that became invalid are removed and thus refined the compatibility.,"Since the last mapping, any mappings that have become invalid have been removed.",0.469509381829421,Refines compatibility by removing all mappings that have now become invalid (since the last mapping).
539,cdk,"private void searchAndPlaceBranches(IAtomContainer molecule, IAtomContainer chain, AtomPlacer3D ap3d, AtomTetrahedralLigandPlacer3D atlp3d, AtomPlacer atomPlacer) throws CDKException{
    List atoms = null;
    IAtomContainer branchAtoms = molecule.getBuilder().newInstance(IAtomContainer.class);
    IAtomContainer connectedAtoms = molecule.getBuilder().newInstance(IAtomContainer.class);
    for (int i = 0; i < chain.getAtomCount(); i++) {
        atoms = molecule.getConnectedAtomsList(chain.getAtom(i));
        for (int j = 0; j < atoms.size(); j++) {
            IAtom atom = (IAtom) atoms.get(j);
            if (!(atom.getSymbol()).equals(""H"") & !(atom.getFlag(CDKConstants.ISPLACED)) & !(atom.getFlag(CDKConstants.ISINRING))) {
                connectedAtoms.add(ap3d.getPlacedHeavyAtoms(molecule, chain.getAtom(i)));
                try {
                    setBranchAtom(molecule, atom, chain.getAtom(i), connectedAtoms, ap3d, atlp3d);
                } catch (CDKException ex2) {
                    logger.error(""SearchAndPlaceBranchERROR: Cannot find enough neighbour atoms due to"" + ex2.toString());
                    throw new CDKException(""SearchAndPlaceBranchERROR: Cannot find enough neighbour atoms: "" + ex2.getMessage(), ex2);
                }
                branchAtoms.addAtom(atom);
                connectedAtoms.removeAllElements();
            }
        }
    }
    placeLinearChains3D(molecule, branchAtoms, ap3d, atlp3d, atomPlacer);
}",searchAndPlaceBranches,org/openscience/cdk/modeling/builder3d/ModelBuilder3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/ModelBuilder3D.java,"/**
     * Search and place branches of a chain or ring.
     *
     *@param  chain          AtomContainer if atoms in an aliphatic chain or ring system
     */",454-491,"('searchAndPlaceBranches', {'INSTRUCTION': {'covered': 102, 'missed': 26}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 16, 'missed': 5}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",272.0,10.0,Search and place branches of a chain or ring.,For each chain or ring it searches and places branches.,Place branches of a chain.,0.0427948733839801,Find and place the branches of a chain or ring.
540,liquibase,"public boolean isSafeToRunUpdate() throws DatabaseException{
    DatabaseConnection connection = getConnection();
    if (connection == null) {
        return true;
    }
    String url = connection.getURL();
    if (url == null) {
        return false;
    }
    return (url.contains(""localhost"")) || (url.contains(""127.0.0.1""));
}",isSafeToRunUpdate,liquibase/database/AbstractJdbcDatabase.java,/liquibase-core/src/main/java/liquibase/database/AbstractJdbcDatabase.java,"/**
     * Default implementation, just look for ""local"" IPs. If the database returns a null URL we return false since we don't know it's safe to run the update.
     *
     * @throws liquibase.exception.DatabaseException
     *
     */",1238-1255,"('isSafeToRunUpdate', {'INSTRUCTION': {'covered': 22, 'missed': 4}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,11.0,"Default implementation, just look for ""local"" IPs.",Checks whether or not it is safe to run an update query on the database.,"Just look for ""local"" IPs.",0.503077154559152,"By default implementation, just look for ""local"" IP addresses."
541,acs-aem-commons,"protected String generatePropertyChecksums(final String aggregateNodePath, final Node node, final ChecksumGeneratorOptions options) throws RepositoryException, IOException{
    SortedMap<String, String> propertyChecksums = new TreeMap<>();
    PropertyIterator properties = node.getProperties();
    while (properties.hasNext()) {
        final Property property = properties.nextProperty();
        if (options.getExcludedProperties().contains(property.getName())) {
            log.debug(""Excluding property: {}"", node.getPath() + ""/@"" + property.getName());
            continue;
        }
        final List<String> checksums = new ArrayList<String>();
        final List<Value> values = getPropertyValues(property);
        for (final Value value : values) {
            if (value.getType() == PropertyType.BINARY) {
                checksums.add(getBinaryChecksum(value));
            } else {
                checksums.add(getStringChecksum(value));
            }
        }
        if (!options.getSortedProperties().contains(property.getName())) {
            Collections.sort(checksums);
        }
        if (log.isDebugEnabled()) {
            log.debug(""Property: {} ~> {}"", getChecksumKey(aggregateNodePath, property.getPath()), StringUtils.join(checksums, "",""));
        }
        propertyChecksums.put(getChecksumKey(aggregateNodePath, property.getPath()), StringUtils.join(checksums, "",""));
    }
    return aggregateChecksums(propertyChecksums);
}",generatePropertyChecksums,com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,"/**
     * Returns a lexicographically sorted map of the [PROPERTY PATH] : [CHECKSUM OF PROPERTIES].
     * @param aggregateNodePath the absolute path of the node being aggregated into a checksum
     * @param node  the node to collect and checksum the properties for
     * @param options the checksum generator options
     * @return the map of the properties and their checksums
     * @throws RepositoryException
     */",232-286,"('generatePropertyChecksums', {'INSTRUCTION': {'covered': 108, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",277.0,18.0,Returns a lexicographically sorted map of the [PROPERTY PATH] : [CHECKSUM OF PROPERTIES].,"Generates and returns a sorted lexicographically map of (PROPERTY PATH, CHECKSUM OF PROPERTIES).",A map of the [property PATH] is returned.,0.562213409274922,Returns a lexicographically sorted map of [PROPERTY PATH]: [PROPERTY CHECKSUM].
542,liquibase,"public boolean isRequiredFor(Database database){
    return getRequiredForDatabase().contains(ALL) || getRequiredForDatabase().contains(database.getShortName());
}",isRequiredFor,liquibase/change/ChangeParameterMetaData.java,/liquibase-core/src/main/java/liquibase/change/ChangeParameterMetaData.java,"/**
     * A convenience method for testing the value returned by {@link #getRequiredForDatabase()} against a given database.
     * Returns true if the {@link Database#getShortName()} method is contained in the required databases or the
     * required database list contains the string ""all""
     */",262-269,"('isRequiredFor', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,22.0,A convenience method for testing the value returned by {@link #getRequiredForDatabase()} against a given database.,"Return true whether the database contains the string ""all"" or the getShortName method is contained within it.",A convenience method for testing the value returned by @link #getRequiredForDatabase,0.686188281034788,A convenient method for testing the value returned by {@link #getRequiredForDatabase()} against a given database.
543,cdk,"public void changeBase(Permutation newBase){
    PermutationGroup h = new PermutationGroup(newBase);
    int firstDiffIndex = base.firstIndexOfDifference(newBase);
    for (int j = firstDiffIndex; j < size; j++) {
        for (int a = 0; a < size; a++) {
            Permutation g = permutations[j][a];
            if (g != null) {
                h.enter(g);
            }
        }
    }
    for (int j = 0; j < firstDiffIndex; j++) {
        for (int a = 0; a < size; a++) {
            Permutation g = permutations[j][a];
            if (g != null) {
                int hj = h.base.get(j);
                int x = g.get(hj);
                h.permutations[j][x] = new Permutation(g);
            }
        }
    }
    this.base = new Permutation(h.base);
    this.permutations = h.permutations.clone();
}",changeBase,org/openscience/cdk/group/PermutationGroup.java,/tool/group/src/main/java/org/openscience/cdk/group/PermutationGroup.java,"/**
     * Change the base of the group to the new base <code>newBase</code>.
     *
     * @param newBase the new base for the group
     */",326-357,"('changeBase', {'INSTRUCTION': {'covered': 95, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",199.0,18.0,Change the base of the group to the new base <code>newBase</code>.,"Given the newBase object for the group, it changes the current base of the group with the newBase object.",The base of the group should be changed to the new base.,0.353520151664309,Replace the group database with the new <code>newBase</code>.
544,acs-aem-commons,"public static List<Pattern> toPatterns(String[] values){
    List<Pattern> patterns = new ArrayList<Pattern>();
    if (values == null) {
        return patterns;
    }
    for (String value : values) {
        if (StringUtils.isNotBlank(value)) {
            patterns.add(Pattern.compile(value));
        }
    }
    return patterns;
}",toPatterns,com/adobe/acs/commons/util/ParameterUtil.java,/bundle/src/main/java/com/adobe/acs/commons/util/ParameterUtil.java,"/**
     * Util for converting a String[] into a List of compiled Patterns. Empty/blank strings will be skipped.
     * @param values the Strings to convert to patterns.
     * @return a List of Patterns
     */",204-223,"('toPatterns', {'INSTRUCTION': {'covered': 32, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,14.0,Util for converting a String[] into a List of compiled Patterns.,This method converts and returns an array of String into a list of Compiled Patterns. ,TheUtil is used to convert a string into a list of patterns.,0.324022219444801,Utility to convert a String[] into a list of compiled templates.
545,dataverse,"public boolean structuralContains(RoleAssignee ra){
    if (ra instanceof AuthenticatedUser) {
        if (containedAuthenticatedUsers.contains((AuthenticatedUser) ra)) {
            return true;
        }
    } else if (ra instanceof ExplicitGroup) {
        if (containedExplicitGroups.contains((ExplicitGroup) ra)) {
            return true;
        }
    } else {
        if (containedRoleAssignees.contains(ra.getIdentifier())) {
            return true;
        }
    }
    for (ExplicitGroup eg : containedExplicitGroups) {
        if (eg.structuralContains(ra)) {
            return true;
        }
    }
    return false;
}",structuralContains,edu/harvard/iq/dataverse/authorization/groups/impl/explicit/ExplicitGroup.java,/src/main/java/edu/harvard/iq/dataverse/authorization/groups/impl/explicit/ExplicitGroup.java,"/**
     * Looks at structural containment: whether {@code ra} is part of the
     * group's structure. It mostly the same as {@link #contains(edu.harvard.iq.dataverse.engine.command.DataverseRequest)},
     * except for logical containment. So if an ExplicitGroup contains {@link AuthenticatedUsers} but not
     * a specific {@link AuthenticatedUser} {@code u}, {@code structuralContains(u)}
     * would return {@code false} while {@code contains( request(u, ...) )} would return true;
     * 
     * @param ra
     * @return {@code true} iff the role assignee is structurally a part of the group.
     */",276-313,"('structuralContains', {'INSTRUCTION': {'covered': 50, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",107.0,19.0,Looks at structural containment: whether {@code ra} is part of the  group's structure.,"Determines whether or not the structural containment is a part of the groups's strucutre. Returns true if so, false otherwise.",Structural containment is the question of whether @codera is part of the group's structure.,0.710234688191095,Examines structural containment: if {@code ra} is part of the group structure.
546,cdk,"public static int[][] aaBondInfo(){
    if (aminoAcids == null) {
        createAAs();
    }
    int[][] info = new int[153][4];
    int counter = 0;
    int total = 0;
    for (int aa = 0; aa < aminoAcids.length; aa++) {
        AminoAcid acid = aminoAcids[aa];
        LOGGER.debug(""#bonds for "", acid.getProperty(RESIDUE_NAME).toString(), "" = "" + acid.getBondCount());
        total += acid.getBondCount();
        LOGGER.debug(""total #bonds: "", total);
        Iterator<IBond> bonds = acid.bonds().iterator();
        while (bonds.hasNext()) {
            IBond bond = (IBond) bonds.next();
            info[counter][0] = counter;
            info[counter][1] = acid.indexOf(bond.getBegin());
            info[counter][2] = acid.indexOf(bond.getEnd());
            info[counter][3] = bond.getOrder().numeric();
            counter++;
        }
    }
    if (counter > 153) {
        LOGGER.error(""Error while creating AA info! Bond count is too large: "", counter);
        return null;
    }
    return info;
}",aaBondInfo,org/openscience/cdk/templates/AminoAcids.java,/storage/pdb/src/main/java/org/openscience/cdk/templates/AminoAcids.java,"/**
     * Creates matrix with info about the bonds in the amino acids.
     * 0 = bond id, 1 = atom1 in bond, 2 = atom2 in bond, 3 = bond order.
     * @return info
     */",60-99,"('aaBondInfo', {'INSTRUCTION': {'covered': 112, 'missed': 14}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 20, 'missed': 3}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",249.0,12.0,Creates matrix with info about the bonds in the amino acids.,Using the information conveyed in the bonds creates and returns a matrix.,The matrix has information about the bonds in the amino acids.,0.231513824231473,Creates a matrix with information about the bonds in the amino acids.
548,cdk,"AtomSymbol center(double x, double y){
    Point2D center = getAlignmentCenter();
    return translate(x - center.getX(), y - center.getY());
}",center,org/openscience/cdk/renderer/generators/standard/AtomSymbol.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AtomSymbol.java,"/**
     * Convenience function to center an atom symbol on a specified point. The
     * centering depends on the symbol alignment.
     *
     * @param x x-axis location
     * @param y y-axis location
     * @return the centered symbol (new instance)
     */",233-244,"('center', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,12.0,Convenience function to center an atom symbol on a specified point.,Centers the atom's symbol on a specified point.,The convenience function centers an atom symbol.,0.710941404153197,Convenience function to center an atom symbol on a specified point.
549,cdk,"public boolean inSameCell(int elementI, int elementJ){
    for (int cellIndex = 0; cellIndex < size(); cellIndex++) {
        SortedSet<Integer> cell = getCell(cellIndex);
        if (cell.contains(elementI) && cell.contains(elementJ)) {
            return true;
        }
    }
    return false;
}",inSameCell,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,"/**
     * Check that two elements are in the same cell of the partition.
     *
     * @param elementI an element in the partition
     * @param elementJ an element in the partition
     * @return true if both elements are in the same cell
     */",400-415,"('inSameCell', {'INSTRUCTION': {'covered': 24, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,13.0,Check that two elements are in the same cell of the partition.,"Returns true if the two-element given as input are in the same cell of the partition; otherwise, false.",The partition has two elements in the same cell.,0.254367786245717,Verify that two items are in the same cell in the partition.
551,egeria,"public Map<String, RelationshipsContext> buildSchemaElementContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
    final String methodName = ""buildSchemaElementContext"";
    handlerHelper.validateAsset(entityDetail, methodName, supportedZones);
    Map<String, RelationshipsContext> context = new HashMap<>();
    final String typeDefName = entityDetail.getType().getTypeDefName();
    Set<GraphContext> columnContext = new HashSet<>();
    switch(typeDefName) {
        case TABULAR_COLUMN:
            if (!isInternalTabularColumn(userId, entityDetail)) {
                columnContext = buildTabularColumnContext(userId, entityDetail);
            }
            break;
        case TABULAR_FILE_COLUMN:
            columnContext = buildTabularColumnContext(userId, entityDetail);
            break;
        case RELATIONAL_COLUMN:
            columnContext = buildRelationalColumnContext(userId, entityDetail);
            break;
        case EVENT_SCHEMA_ATTRIBUTE:
            columnContext = buildEventSchemaAttributeContext(userId, entityDetail);
            break;
        default:
            return context;
    }
    context.put(AssetLineageEventType.COLUMN_CONTEXT_EVENT.getEventTypeName(), new RelationshipsContext(entityDetail.getGUID(), columnContext));
    return context;
}",buildSchemaElementContext,org/odpi/openmetadata/accessservices/assetlineage/handlers/AssetContextHandler.java,/open-metadata-implementation/access-services/asset-lineage/asset-lineage-server/src/main/java/org/odpi/openmetadata/accessservices/assetlineage/handlers/AssetContextHandler.java,"/**
     * Builds the context for a schema element without the asset context.
     *
     * @param userId       the unique identifier for the user
     * @param entityDetail the entity for which the context is build
     *
     * @return the context of the schema element
     *
     * @throws OCFCheckedExceptionBase checked exception for reporting errors found when using OCF connectors
     */",67-105,"('buildSchemaElementContext', {'INSTRUCTION': {'covered': 71, 'missed': 2}, 'BRANCH': {'covered': 6, 'missed': 1}, 'LINE': {'covered': 16, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",185.0,12.0,Builds the context for a schema element without the asset context.,Generates the context for a schema element having no asset context.,The asset context is built for a schema element.,0.411760121160342,Generates the context of a schema element without the context of the resource.
552,matsim-libs,"protected boolean addToPendingNodes(final Link l, final Node n, final RouterPriorityQueue<Node> pendingNodes, final double currTime, final double currCost, final Node toNode){
    final double travelTime = this.timeFunction.getLinkTravelTime(l, currTime, this.person, this.vehicle);
    final double travelCost = this.costFunction.getLinkTravelDisutility(l, currTime, this.person, this.vehicle);
    final DijkstraNodeData data = getData(n);
    if (!data.isVisited(getIterationId())) {
        visitNode(n, data, pendingNodes, currTime + travelTime, currCost + travelCost, l);
        return true;
    }
    final double nCost = data.getCost();
    final double totalCost = currCost + travelCost;
    if (totalCost < nCost) {
        revisitNode(n, data, pendingNodes, currTime + travelTime, totalCost, l);
        return true;
    } else if (totalCost == nCost) {
        Link prevLink = data.getPrevLink();
        if (prevLink != null && prevLink.getId().compareTo(l.getId()) > 0) {
            revisitNode(n, data, pendingNodes, currTime + travelTime, totalCost, l);
            return true;
        }
    }
    return false;
}",addToPendingNodes,org/matsim/core/router/Dijkstra.java,/matsim/src/main/java/org/matsim/core/router/Dijkstra.java,"/**
	 * Adds some parameters to the given Node then adds it to the set of pending
	 * nodes.
	 *
	 * @param l
	 *            The link from which we came to this Node.
	 * @param n
	 *            The Node to add to the pending nodes.
	 * @param pendingNodes
	 *            The set of pending nodes.
	 * @param currTime
	 *            The time at which we started to traverse l.
	 * @param currCost
	 *            The cost at the time we started to traverse l.
	 * @param toNode
	 *            The target Node of the route.
	 * @return true if the node was added to the pending nodes, false otherwise
	 * 		(e.g. when the same node already has an earlier visiting time).
	 */",430-476,"('addToPendingNodes', {'INSTRUCTION': {'covered': 95, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",236.0,17.0,Adds some parameters to the given Node then adds it to the set of pending  nodes.,New parameters are added to the node given as input.  Such a node is later added to the set of pending nodes.,Adds parameters to the given Node and adds them to the pending nodes.,0.196833692845059,Adds some parameters to the given node and then adds it to the set of pending nodes.
553,dcache,"public static EnumSet<LoA> withImpliedLoA(Optional<EntityDefinition> entity, Collection<LoA> asserted){
    Map<LoA, LoA> mapping = entity.filter(PERSON::equals).map(e -> PERSONAL_EQUIVALENT_LOA).orElse(GENERIC_EQUIVALENT_LOA);
    EnumSet<LoA> result = EnumSet.copyOf(asserted);
    Collection<LoA> considered = asserted;
    do {
        EnumSet<LoA> additional = considered.stream().map(mapping::get).filter(Objects::nonNull).collect(Collectors.toCollection(() -> EnumSet.noneOf(LoA.class)));
        result.addAll(additional);
        considered = additional;
    } while (!considered.isEmpty());
    return result;
}",withImpliedLoA,org/dcache/auth/LoAs.java,/modules/common/src/main/java/org/dcache/auth/LoAs.java,"/**
     * Convert a set of asserted LoAs so it includes all equivalent LoAs.
     *
     * @param entity   the kind of identity asserted, if known.
     * @param asserted a collection of LoA asserted by some external agent.
     * @return all LoAs for this identity.
     */",68-94,"('withImpliedLoA', {'INSTRUCTION': {'covered': 44, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",145.0,13.0,Convert a set of asserted LoAs so it includes all equivalent LoAs.,Translates a set of asserted LoAs in such a way to include all the equivalent LoAs.,All equivalent loAs can be converted so it includes a set of asserted loAs.,0.930003353639261,Convert a set of asserted LoAs so that it includes all equivalent LoAs.
554,cdk,"static void readNonStructuralData(final BufferedReader input, final IAtomContainer container) throws IOException{
    String line, header = null;
    boolean wrap = false;
    final StringBuilder data = new StringBuilder(80);
    while (!endOfRecord(line = input.readLine())) {
        final String newHeader = dataHeader(line);
        if (newHeader != null) {
            if (header != null)
                container.setProperty(header, data.toString());
            header = newHeader;
            wrap = false;
            data.setLength(0);
        } else {
            if (data.length() > 0 || !line.equals("" ""))
                line = line.trim();
            if (line.isEmpty())
                continue;
            if (!wrap && data.length() > 0)
                data.append('\n');
            data.append(line);
            wrap = line.length() == 80;
        }
    }
    if (header != null)
        container.setProperty(header, data.toString());
}",readNonStructuralData,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Read non-structural data from input and store as properties the provided
     * 'container'. Non-structural data appears in a structure data file (SDF)
     * after an Molfile and before the record deliminator ('$$$$'). The data
     * consists of one or more Data Header and Data blocks, an example is seen
     * below.
     *
     * <pre>{@code
     * > 29 <DENSITY>
     * 0.9132 - 20.0
     *
     * > 29 <BOILING.POINT>
     * 63.0 (737 MM)
     * 79.0 (42 MM)
     *
     * > 29 <ALTERNATE.NAMES>
     * SYLVAN
     *
     * > 29 <DATE>
     * 09-23-1980
     *
     * > 29 <CRC.NUMBER>
     * F-0213
     *
     * }</pre>
     *
     *
     * @param input     input source
     * @param container the container
     * @throws IOException an error occur whilst reading the input
     */",2226-2290,"('readNonStructuralData', {'INSTRUCTION': {'covered': 79, 'missed': 0}, 'BRANCH': {'covered': 20, 'missed': 0}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 11, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",200.0,14.0,Read non-structural data from input and store as properties the provided  'container'.,Stores non-structural data as a proporties into the provided container. ,Read non-structural data from input and store it as a container.,0.475639248930798,"Read the non-structural data from the input and store the provided ""container"" as properties."
555,matsim-libs,"public static List<PlanElement> insertTrip(final Plan plan, final Activity origin, final List<? extends PlanElement> trip, final Activity destination){
    return insertTrip(plan.getPlanElements(), origin, trip, destination);
}",insertTrip,org/matsim/core/router/TripRouter.java,/matsim/src/main/java/org/matsim/core/router/TripRouter.java,"/**
	 * Inserts a trip between two activities in the sequence of plan elements
	 * returned by the {@link Plan#getPlanElements()} method of a plan. Note
	 * that the plan will be modified only if the returned list is the internal
	 * reference!
	 * <p></p>
	 * Note that this methods returns a unique solution because it expects the activity object references as arguments, which are unique.
	 *
	 * @param plan the plan to modify
	 * @param origin the activity to use as origin. It must be a member of the list of plan elements.
	 * @param trip the trip to insert
	 * @param destination the destination activity. It must be a member of the list.
	 * @return the ""old trip"": the sequence of plan elements originally existing between the origin and the destination
	 */",226-250,"('insertTrip', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,29.0,Inserts a trip between two activities in the sequence of plan elements  returned by the {@link Plan#getPlanElements()} method of a plan.,Inserts and returns an old trip which includes a new trip destination.,The trip between the two activities is included in the plan elements returned by the @link Plan#getPlanElements,0.622542748187535,Inserts a path between two activities into the sequence of plan elements returned by the {@link Plan#getPlanElements()} method of a plan.
556,matsim-libs,"public static double calculateWeightFromLine(final Coordinate from, final Coordinate to, final Coordinate cellCentroid, final double smoothingRadius){
    if (smoothingRadius <= 0)
        throw new IllegalArgumentException(""smoothing radius must be greater 0"");
    double a = from.distance(cellCentroid) * from.distance(cellCentroid);
    double b = (to.x - from.x) * (from.x - cellCentroid.x) + (to.y - from.y) * (from.y - cellCentroid.y);
    double linkLength = from.distance(to);
    double c = (smoothingRadius * Math.sqrt(Math.PI) / (linkLength * 2)) * Math.exp(-(a - (b * b / (linkLength * linkLength))) / (smoothingRadius * smoothingRadius));
    double upperLimit = linkLength + b / linkLength;
    double lowerLimit = b / linkLength;
    double integrationUpperLimit = Erf.erf(upperLimit / smoothingRadius);
    double integrationLowerLimit = Erf.erf(lowerLimit / smoothingRadius);
    double weight = c * (integrationUpperLimit - integrationLowerLimit);
    if (weight < 0)
        throw new RuntimeException(""Weight may not be negative! Value: "" + weight);
    return weight;
}",calculateWeightFromLine,org/matsim/contrib/analysis/spatial/SpatialInterpolation.java,/contribs/analysis/src/main/java/org/matsim/contrib/analysis/spatial/SpatialInterpolation.java,"/**
     * This uses a gaussian distance weighting to calculate the impact of link based emissions onto the centroid of a
     * grid cell. The level of emission is assumed to be linear over the link. The calculation is described in Argawal's
     * PhD thesis https://depositonce.tu-berlin.de/handle/11303/6266 in Appendix A.2
     *
     * @param from         Link from coordinate
     * @param to           Link to coordinate
     * @param cellCentroid centroid of the impacted cell
     * @return weight factor by which the emission value should be multiplied to calculate the impact of the cell
     */",8-39,"('calculateWeightFromLine', {'INSTRUCTION': {'covered': 102, 'missed': 6}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",225.0,22.0,This uses a gaussian distance weighting to calculate the impact of link based emissions onto the centroid of a  grid cell.,"Computes and returns the distance weighting concerning the impact of the link, based emission onto the centroid of a grid cell.",The impact of link based emissions onto the centroid of a grid cell is calculated using a gaussian distance weighting.,0.190869346323013,This uses Gaussian distance weighting to calculate the impact of emissions based on the bond on the centroid of a grid cell.
557,cdk,"public DescriptorValue calculate(IAtomContainer atomContainer){
    double volume;
    try {
        volume = VABCVolume.calculate(clone(atomContainer));
    } catch (CDKException exception) {
        return getDummyDescriptorValue(exception);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(volume), getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/VABCDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/VABCDescriptor.java,"/**
     * Calculates the descriptor value using the {@link VABCVolume} class.
     *
     * @param atomContainer The {@link IAtomContainer} whose volume is to be calculated
     * @return A double containing the volume
     */",78-96,"('calculate', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,13.0,Calculates the descriptor value using the {@link VABCVolume} class.,Computs the descriptor value using the link VABCVolumne class.,The @link VABCVolume class is used to calculate the descriptor value.,0.782103403836211,Calculates the value of the descriptor using the {@link VABCVolume} class.
558,cdk,"public void writeMolecule(IAtomContainer container) throws Exception{
    final int dim = getNumberOfDimensions(container);
    StringBuilder line = new StringBuilder();
    Map<Integer, Integer> rgroups = null;
    Map<Integer, String> aliases = null;
    String title = container.getTitle();
    if (title == null)
        title = """";
    if (title.length() > 80)
        title = title.substring(0, 80);
    writer.write(title);
    writer.write('\n');
    writer.write(""  "");
    writer.write(getProgName());
    writer.write(new SimpleDateFormat(""MMddyyHHmm"").format(System.currentTimeMillis()));
    if (dim != 0) {
        writer.write(Integer.toString(dim));
        writer.write('D');
    }
    writer.write('\n');
    String comment = (String) container.getProperty(CDKConstants.REMARK);
    if (comment == null)
        comment = """";
    if (comment.length() > 80)
        comment = comment.substring(0, 80);
    writer.write(comment);
    writer.write('\n');
    Map<IAtom, ITetrahedralChirality> atomstereo = new HashMap<>();
    Map<IAtom, Integer> atomindex = new HashMap<>();
    for (IStereoElement element : container.stereoElements()) if (element instanceof ITetrahedralChirality)
        atomstereo.put(((ITetrahedralChirality) element).getChiralAtom(), (ITetrahedralChirality) element);
    for (IAtom atom : container.atoms()) atomindex.put(atom, atomindex.size());
    line.append(formatMDLInt(container.getAtomCount(), 3));
    line.append(formatMDLInt(container.getBondCount(), 3));
    Map<Integer, IAtom> atomLists = new LinkedHashMap<>();
    for (int f = 0; f < container.getAtomCount(); f++) {
        if (container.getAtom(f) instanceof IQueryAtom) {
            QueryAtom queryAtom = (QueryAtom) AtomRef.deref(container.getAtom(f));
            Expr expr = queryAtom.getExpression();
            if (isValidAtomListExpression(expr)) {
                atomLists.put(f, container.getAtom(f));
            }
        }
    }
    line.append(formatMDLInt(atomLists.size(), 3));
    line.append(""  0"");
    line.append(getChiralFlag(atomstereo.values()) ? ""  1"" : ""  0"");
    line.append(""  0  0  0  0  0999 V2000"");
    writer.write(line.toString());
    writer.write('\n');
    for (int f = 0; f < container.getAtomCount(); f++) {
        IAtom atom = container.getAtom(f);
        line.setLength(0);
        switch(dim) {
            case 0:
                line.append(""    0.0000    0.0000    0.0000 "");
                break;
            case 2:
                if (atom.getPoint2d() != null) {
                    line.append(formatMDLFloat((float) atom.getPoint2d().x));
                    line.append(formatMDLFloat((float) atom.getPoint2d().y));
                    line.append(""    0.0000 "");
                } else {
                    line.append(""    0.0000    0.0000    0.0000 "");
                }
                break;
            case 3:
                if (atom.getPoint3d() != null) {
                    line.append(formatMDLFloat((float) atom.getPoint3d().x));
                    line.append(formatMDLFloat((float) atom.getPoint3d().y));
                    line.append(formatMDLFloat((float) atom.getPoint3d().z)).append("" "");
                } else {
                    line.append(""    0.0000    0.0000    0.0000 "");
                }
                break;
        }
        if (container.getAtom(f) instanceof IPseudoAtom) {
            IPseudoAtom pseudoAtom = (IPseudoAtom) container.getAtom(f);
            String label = pseudoAtom.getLabel();
            if (label == null)
                label = """";
            Matcher matcher = NUMERED_R_GROUP.matcher(label);
            if (""R"".equals(pseudoAtom.getSymbol()) && !label.isEmpty() && matcher.matches()) {
                line.append(""R# "");
                if (rgroups == null) {
                    rgroups = new TreeMap<Integer, Integer>();
                }
                rgroups.put(f + 1, Integer.parseInt(matcher.group(1)));
            } else {
                if (label.length() > 3) {
                    if (aliases == null)
                        aliases = new TreeMap<Integer, String>();
                    aliases.put(f + 1, label);
                    line.append(formatMDLString(atom.getSymbol(), 3));
                } else {
                    if (!label.isEmpty())
                        line.append(formatMDLString(label, 3));
                    else
                        line.append(formatMDLString(atom.getSymbol(), 3));
                }
            }
        } else if (atomLists.containsKey(f)) {
            line.append(formatMDLString(""L"", 3));
        } else {
            line.append(formatMDLString(container.getAtom(f).getSymbol(), 3));
        }
        int[] atomprops = new int[12];
        atomprops[0] = determineIsotope(atom);
        atomprops[1] = determineCharge(container, atom);
        atomprops[2] = determineStereoParity(container, atomstereo, atomindex, atom);
        atomprops[5] = determineValence(container, atom);
        atomprops[9] = determineAtomMap(atom);
        line.append(formatMDLInt(atomprops[0], 2));
        line.append(formatMDLInt(atomprops[1], 3));
        int last = atomprops.length - 1;
        if (!writeDefaultProps.isSet()) {
            while (last >= 0) {
                if (atomprops[last] != 0)
                    break;
                last--;
            }
            if (last >= 2 && last < 5)
                last = 5;
        }
        for (int i = 2; i <= last; i++) line.append(formatMDLInt(atomprops[i], 3));
        line.append('\n');
        writer.write(line.toString());
    }
    for (IBond bond : container.bonds()) {
        line.setLength(0);
        if (bond.getAtomCount() != 2) {
            logger.warn(""Skipping bond with more/less than two atoms: "" + bond);
        } else {
            if (bond.getStereo() == IBond.Stereo.UP_INVERTED || bond.getStereo() == IBond.Stereo.DOWN_INVERTED || bond.getStereo() == IBond.Stereo.UP_OR_DOWN_INVERTED) {
                line.append(formatMDLInt(atomindex.get(bond.getEnd()) + 1, 3));
                line.append(formatMDLInt(atomindex.get(bond.getBegin()) + 1, 3));
            } else {
                line.append(formatMDLInt(atomindex.get(bond.getBegin()) + 1, 3));
                line.append(formatMDLInt(atomindex.get(bond.getEnd()) + 1, 3));
            }
            int bondType = 0;
            if (bond instanceof QueryBond) {
                QueryBond qbond = ((QueryBond) bond);
                Expr e = qbond.getExpression();
                switch(e.type()) {
                    case ALIPHATIC_ORDER:
                    case ORDER:
                        bondType = e.value();
                        break;
                    case IS_AROMATIC:
                        bondType = 4;
                        break;
                    case SINGLE_OR_DOUBLE:
                        bondType = 5;
                        break;
                    case SINGLE_OR_AROMATIC:
                        bondType = 6;
                        break;
                    case DOUBLE_OR_AROMATIC:
                        bondType = 7;
                        break;
                    case TRUE:
                        bondType = 8;
                        break;
                    case OR:
                        if (e.equals(new Expr(Expr.Type.ALIPHATIC_ORDER, 1).or(new Expr(Expr.Type.ALIPHATIC_ORDER, 2))) || e.equals(new Expr(Expr.Type.ALIPHATIC_ORDER, 2).or(new Expr(Expr.Type.ALIPHATIC_ORDER, 1))))
                            bondType = 5;
                        else if (e.equals(new Expr(Expr.Type.ALIPHATIC_ORDER, 1).or(new Expr(Expr.Type.IS_AROMATIC))) || e.equals(new Expr(Expr.Type.IS_AROMATIC).or(new Expr(Expr.Type.ALIPHATIC_ORDER, 1))))
                            bondType = 6;
                        else if (e.equals(new Expr(Expr.Type.ALIPHATIC_ORDER, 2).or(new Expr(Expr.Type.IS_AROMATIC))) || e.equals(new Expr(Expr.Type.IS_AROMATIC).or(new Expr(Expr.Type.ALIPHATIC_ORDER, 2))))
                            bondType = 6;
                        break;
                    default:
                        throw new IllegalArgumentException(""Unsupported bond type!"");
                }
            } else {
                if (bond.getOrder() != null) {
                    switch(bond.getOrder()) {
                        case SINGLE:
                        case DOUBLE:
                        case TRIPLE:
                            if (writeAromaticBondTypes.isSet() && bond.isAromatic())
                                bondType = 4;
                            else
                                bondType = bond.getOrder().numeric();
                            break;
                        case UNSET:
                            if (bond.isAromatic()) {
                                if (!writeAromaticBondTypes.isSet())
                                    throw new CDKException(""Bond at idx "" + container.indexOf(bond) + "" was an unspecific aromatic bond which should only be used for queries in Molfiles. These can be written if desired by enabling the option 'WriteAromaticBondTypes'."");
                                bondType = 4;
                            }
                            break;
                    }
                }
            }
            if (bondType == 0)
                throw new CDKException(""Bond at idx="" + container.indexOf(bond) + "" is not supported by Molfile, bond="" + bond.getOrder());
            line.append(formatMDLInt(bondType, 3));
            line.append(""  "");
            switch(bond.getStereo()) {
                case UP:
                    line.append(""1"");
                    break;
                case UP_INVERTED:
                    line.append(""1"");
                    break;
                case DOWN:
                    line.append(""6"");
                    break;
                case DOWN_INVERTED:
                    line.append(""6"");
                    break;
                case UP_OR_DOWN:
                    line.append(""4"");
                    break;
                case UP_OR_DOWN_INVERTED:
                    line.append(""4"");
                    break;
                case E_OR_Z:
                    line.append(""3"");
                    break;
                default:
                    line.append(""0"");
            }
            if (writeDefaultProps.isSet())
                line.append(""  0  0  0"");
            line.append('\n');
            writer.write(line.toString());
        }
    }
    for (int i = 0; i < container.getAtomCount(); i++) {
        IAtom atom = container.getAtom(i);
        if (atom.getProperty(CDKConstants.COMMENT) != null && atom.getProperty(CDKConstants.COMMENT) instanceof String && !((String) atom.getProperty(CDKConstants.COMMENT)).trim().equals("""")) {
            writer.write(""V  "");
            writer.write(formatMDLInt(i + 1, 3));
            writer.write("" "");
            writer.write((String) atom.getProperty(CDKConstants.COMMENT));
            writer.write('\n');
        }
    }
    for (int i = 0; i < container.getAtomCount(); i++) {
        IAtom atom = container.getAtom(i);
        Integer charge = atom.getFormalCharge();
        if (charge != null && charge != 0) {
            writer.write(""M  CHG  1 "");
            writer.write(formatMDLInt(i + 1, 3));
            writer.write("" "");
            writer.write(formatMDLInt(charge, 3));
            writer.write('\n');
        }
    }
    if (container.getSingleElectronCount() > 0) {
        Map<Integer, SPIN_MULTIPLICITY> atomIndexSpinMap = new LinkedHashMap<Integer, SPIN_MULTIPLICITY>();
        for (int i = 0; i < container.getAtomCount(); i++) {
            IAtom atom = container.getAtom(i);
            int eCount = container.getConnectedSingleElectronsCount(atom);
            switch(eCount) {
                case 0:
                    continue;
                case 1:
                    atomIndexSpinMap.put(i, SPIN_MULTIPLICITY.Monovalent);
                    break;
                case 2:
                    SPIN_MULTIPLICITY multiplicity = atom.getProperty(CDKConstants.SPIN_MULTIPLICITY);
                    if (multiplicity != null)
                        atomIndexSpinMap.put(i, multiplicity);
                    else {
                        atomIndexSpinMap.put(i, SPIN_MULTIPLICITY.DivalentSinglet);
                    }
                    break;
                default:
                    logger.debug(""Invalid number of radicals found: "" + eCount);
                    break;
            }
        }
        Iterator<Map.Entry<Integer, SPIN_MULTIPLICITY>> iterator = atomIndexSpinMap.entrySet().iterator();
        for (int i = 0; i < atomIndexSpinMap.size(); i += NN8) {
            if (atomIndexSpinMap.size() - i <= NN8) {
                writer.write(""M  RAD"" + formatMDLInt(atomIndexSpinMap.size() - i, WIDTH));
                writeRadicalPattern(iterator, 0);
            } else {
                writer.write(""M  RAD"" + formatMDLInt(NN8, WIDTH));
                writeRadicalPattern(iterator, 0);
            }
            writer.write('\n');
        }
    }
    for (int i = 0; i < container.getAtomCount(); i++) {
        IAtom atom = container.getAtom(i);
        if (!(atom instanceof IPseudoAtom)) {
            Integer atomicMass = atom.getMassNumber();
            if (!writeMajorIsotopes.isSet() && isMajorIsotope(atom))
                atomicMass = null;
            if (atomicMass != null) {
                writer.write(""M  ISO  1 "");
                writer.write(formatMDLInt(i + 1, 3));
                writer.write("" "");
                writer.write(formatMDLInt(atomicMass, 3));
                writer.write('\n');
            }
        }
    }
    if (rgroups != null) {
        StringBuilder rgpLine = new StringBuilder();
        int cnt = 0;
        for (Map.Entry<Integer, Integer> e : rgroups.entrySet()) {
            rgpLine.append(formatMDLInt(e.getKey(), 4));
            rgpLine.append(formatMDLInt(e.getValue(), 4));
            cnt++;
            if (cnt == 8) {
                rgpLine.insert(0, ""M  RGP"" + formatMDLInt(cnt, 3));
                writer.write(rgpLine.toString());
                writer.write('\n');
                rgpLine = new StringBuilder();
                cnt = 0;
            }
        }
        if (cnt != 0) {
            rgpLine.insert(0, ""M  RGP"" + formatMDLInt(cnt, 3));
            writer.write(rgpLine.toString());
            writer.write('\n');
        }
    }
    if (aliases != null) {
        for (Map.Entry<Integer, String> e : aliases.entrySet()) {
            writer.write(""A"" + formatMDLInt(e.getKey(), 5));
            writer.write('\n');
            String label = e.getValue();
            if (label.length() > 70)
                label = label.substring(0, 70);
            writer.write(label);
            writer.write('\n');
        }
    }
    writeAtomLists(atomLists, writer);
    writeSgroups(container, writer, atomindex);
    writer.write(""M  END"");
    writer.write('\n');
    writer.flush();
}",writeMolecule,org/openscience/cdk/io/MDLV2000Writer.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Writer.java,"/**
     * Writes a Molecule to an OutputStream in MDL sdf format.
     *
     * @param container Molecule that is written to an OutputStream
     */",361-803,"('writeMolecule', {'INSTRUCTION': {'covered': 1172, 'missed': 195}, 'BRANCH': {'covered': 130, 'missed': 45}, 'LINE': {'covered': 229, 'missed': 33}, 'COMPLEXITY': {'covered': 58, 'missed': 39}, 'METHOD': {'covered': 1, 'missed': 0}})",2943.0,11.0,Writes a Molecule to an OutputStream in MDL sdf format.,A new molecule is written into an OutputStream using the MDL sdf format.,A molecule is written to an output stream.,0.297034688823565,Writes a molecule in an OutputStream in MDL sdf format.
560,acs-aem-commons,"private boolean accept(final Resource resource) throws RepositoryException{
    if (resource == null || ResourceUtil.isNonExistingResource(resource)) {
        return false;
    }
    for (final Map.Entry<String, Pattern> nodeTypeAndPathRestriction : this.pathRestrictionByNodeType.entrySet()) {
        final String[] hierarchyNodeTypes = StringUtils.split(nodeTypeAndPathRestriction.getKey(), ""/"");
        boolean match = true;
        Resource walkingResource = resource;
        for (int i = (hierarchyNodeTypes.length - 1); i >= 0; i--) {
            if (walkingResource == null) {
                match = false;
                break;
            } else {
                final Node node = walkingResource.adaptTo(Node.class);
                if (node == null || !node.isNodeType(hierarchyNodeTypes[i])) {
                    match = false;
                    break;
                }
                walkingResource = walkingResource.getParent();
            }
        }
        if (match) {
            Pattern pathRestriction = nodeTypeAndPathRestriction.getValue();
            if (pathRestriction != null && !pathRestriction.matcher(resource.getPath()).matches()) {
                log.debug(""Path restriction '{}' prevents the resource at '{}' from getting its replication status updated!"", pathRestriction, resource.getPath());
                return false;
            }
            return true;
        }
    }
    return false;
}",accept,com/adobe/acs/commons/replication/status/impl/JcrPackageReplicationStatusEventHandler.java,/bundle/src/main/java/com/adobe/acs/commons/replication/status/impl/JcrPackageReplicationStatusEventHandler.java,"/**
     * Checks if the ReplicationStatusManager should make the provides resource w replication status.
     *
     * @param resource the return
     * @return true is the resource is markable resource
     * @throws RepositoryException
     */",397-445,"('accept', {'INSTRUCTION': {'covered': 74, 'missed': 15}, 'BRANCH': {'covered': 14, 'missed': 6}, 'LINE': {'covered': 17, 'missed': 6}, 'COMPLEXITY': {'covered': 5, 'missed': 6}, 'METHOD': {'covered': 1, 'missed': 0}})",230.0,13.0,Checks if the ReplicationStatusManager should make the provides resource w replication status.,"Returns true if the ReplicationStatusManager makes the provides resource with the replication status, otherwise false.",If the ReplicationStatusManager should make the provides resource.,0.208039910707078,Checks whether ReplicationStatusManager should set the replication status of the provided resource.
562,matsim-libs,"public final void createIterationDirectory(final int iteration){
    File dir = new File(getIterationPath(iteration));
    if (!dir.mkdir()) {
        if (this.overwriteFiles == OverwriteFileSetting.overwriteExistingFiles && dir.exists()) {
            log.info(""Iteration directory "" + getIterationPath(iteration) + "" exists already."");
        } else {
            log.warn(""Could not create iteration directory "" + getIterationPath(iteration) + ""."");
        }
    }
}",createIterationDirectory,org/matsim/core/controler/OutputDirectoryHierarchy.java,/matsim/src/main/java/org/matsim/core/controler/OutputDirectoryHierarchy.java,"/**
	 * Creates the path where all iteration-related data should be stored.
	 */",187-202,"('createIterationDirectory', {'INSTRUCTION': {'covered': 25, 'missed': 6}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 6, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",83.0,11.0,Creates the path where all iteration-related data should be stored.,Defines a new dedicated path for all the iteration-related data.,The path where all iteration-related data should be stored is created.,0.311819445209746,Creates the path where all iteration-related data should be stored.
563,incubator-shenyu,"public static LocalDateTime formatLocalDateTimeFromTimestampBySystemTimezone(final Long timestamp){
    return LocalDateTime.ofEpochSecond(timestamp / 1000, 0, OffsetDateTime.now().getOffset());
}",formatLocalDateTimeFromTimestampBySystemTimezone,org/apache/shenyu/common/utils/DateUtils.java,/shenyu-common/src/main/java/org/apache/shenyu/common/utils/DateUtils.java,"/**
     * Format local date time from timestamp by system time zone.
     *
     * @param timestamp the timestamp
     * @return the local date time
     */",91-99,"('formatLocalDateTimeFromTimestampBySystemTimezone', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,11.0,Format local date time from timestamp by system time zone.,"From a system time zone, it formats the local date and time.",Local date time from timestamp by system time zone,0.260007770078217,Format the local date and time from the timestamp by system time zone.
564,jackson-databind,"protected JsonNode _readTreeAndClose(JsonParser p0) throws IOException{
    try (JsonParser p = p0) {
        final JavaType valueType = constructType(JsonNode.class);
        DeserializationConfig cfg = getDeserializationConfig();
        cfg.initialize(p);
        JsonToken t = p.currentToken();
        if (t == null) {
            t = p.nextToken();
            if (t == null) {
                return cfg.getNodeFactory().missingNode();
            }
        }
        final JsonNode resultNode;
        final DefaultDeserializationContext ctxt = createDeserializationContext(p, cfg);
        if (t == JsonToken.VALUE_NULL) {
            resultNode = cfg.getNodeFactory().nullNode();
        } else {
            resultNode = (JsonNode) ctxt.readRootValue(p, valueType, _findRootDeserializer(ctxt, valueType), null);
        }
        if (cfg.isEnabled(DeserializationFeature.FAIL_ON_TRAILING_TOKENS)) {
            _verifyNoTrailingTokens(p, ctxt, valueType);
        }
        return resultNode;
    }
}",_readTreeAndClose,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Similar to {@link #_readMapAndClose} but specialized for <code>JsonNode</code>
     * reading.
     *
     * @since 2.9
     */",4685-4726,"('_readTreeAndClose', {'INSTRUCTION': {'covered': 70, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",177.0,20.0,Similar to {@link #_readMapAndClose} but specialized for <code>JsonNode</code>  reading.,Specialized method for JsonNode similar to readMapAndClose method.,It is similar to @link #_readMapAndClose but specialized for code reading.,0.789055260848287,Similar to {@link #_readMapAndClose} but specialized for <code>JsonNode</code> playback.
565,weblogic-kubernetes-operator,"public String formatMessage(String msgId, Object... params){
    if (params == null || params.length == 0) {
        return getResourceBundle().getString(msgId);
    }
    String msg = getResourceBundle().getString(msgId);
    MessageFormat formatter = new MessageFormat(msg);
    return formatter.format(params);
}",formatMessage,oracle/kubernetes/operator/logging/LoggingFacade.java,/operator/src/main/java/oracle/kubernetes/operator/logging/LoggingFacade.java,"/**
   * Formats message based on string loaded from the resource bundle backing this logger.
   * @param msgId Message id
   * @param params Parameters to message formatting
   * @return Formatted message
   */",608-622,"('formatMessage', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,14.0,Formats message based on string loaded from the resource bundle backing this logger.,Returns a formatted message based on a string loaded from the resource bundle backing.,The message is formatted based on the string in the resource bundle.,0.424212059667707,Formats the message based on the string loaded from the resource bundle supporting this recorder.
566,cucumber-reporting,"private void fillMissingSteps(){
    passedFeatures = fillMissingArray(passedFeatures);
    passedScenarios = fillMissingArray(passedScenarios);
    passedSteps = fillMissingArray(passedSteps);
    skippedSteps = fillMissingArray(skippedSteps);
    pendingSteps = fillMissingArray(pendingSteps);
    undefinedSteps = fillMissingArray(undefinedSteps);
}",fillMissingSteps,net/masterthought/cucumber/Trends.java,/src/main/java/net/masterthought/cucumber/Trends.java,"/**
     * Since pending and undefined steps were added later
     * there is need to fill missing data for those statuses.
     */",206-219,"('fillMissingSteps', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",49.0,19.0,Since pending and undefined steps were added later  there is need to fill missing data for those statuses.,"passedFeatures, passedScenarios, passedSteps, skippedSteps, pendingStep and undefinedStep are filled with  the function fillMissingArray. ",There is need to fill in missing data for the statuses since the pending and undefined steps were added later.,0.250017431661361,"Since the pending and undefined steps were added later, it is necessary to fill in the missing data for these statuses."
568,cdk,"private IMolecularFormula putInOrder(IMolecularFormula formula){
    IMolecularFormula new_formula = formula.getBuilder().newInstance(IMolecularFormula.class);
    for (int i = 0; i < orderElements.length; i++) {
        IElement element = builder.newInstance(IElement.class, orderElements[i]);
        if (MolecularFormulaManipulator.containsElement(formula, element)) {
            Iterator<IIsotope> isotopes = MolecularFormulaManipulator.getIsotopes(formula, element).iterator();
            while (isotopes.hasNext()) {
                IIsotope isotope = isotopes.next();
                new_formula.addIsotope(isotope, formula.getIsotopeCount(isotope));
            }
        }
    }
    return new_formula;
}",putInOrder,org/openscience/cdk/formula/MassToFormulaTool.java,/legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java,"/**
     * Put in order the elements of the molecular formula.
     *
     * @param formula The IMolecularFormula to put in order
     * @return        IMolecularFormula object
     */",499-519,"('putInOrder', {'INSTRUCTION': {'covered': 58, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",128.0,10.0,Put in order the elements of the molecular formula.,Sorts the elements of the molecular formula.,Put the elements in order.,0.302762126507745,Put the elements of the molecular formula in order.
569,tablesaw,"private Selection createMultiColSelection(Table table, int ri, List<Index> indexes, int selectionSize, List<Integer> joinColumnIndexes){
    Selection multiColSelection = Selection.withRange(0, selectionSize);
    int i = 0;
    for (Integer joinColumnIndex : joinColumnIndexes) {
        Column<?> col = table.column(joinColumnIndex);
        Selection oneColSelection = selectionForColumn(col, ri, indexes.get(i));
        multiColSelection = multiColSelection.and(oneColSelection);
        i++;
    }
    return multiColSelection;
}",createMultiColSelection,tech/tablesaw/joining/DataFrameJoiner.java,/core/src/main/java/tech/tablesaw/joining/DataFrameJoiner.java,"/**
   * Create a big multicolumn selection for all join columns in the given table. Joins two tables.
   *
   * @param table the table that used to generate Selection.
   * @param ri row number of row in table.
   * @param indexes a reverse index for every join column in the table.
   * @param selectionSize max size in table .
   * @param joinColumnIndexes the column index of join key in tables
   * @return selection created
   */",435-461,"('createMultiColSelection', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",98.0,14.0,Create a big multicolumn selection for all join columns in the given table.,"From a table given as input, it creates a multicolumn selection joining two tables.",A big multicolumn selection is needed for all the columns.,0.335703345899372,Create a large multi-column selection for all join columns in the given table.
570,jackson-databind,"public BeanPropertyMap withProperty(SettableBeanProperty newProp){
    String key = getPropertyName(newProp);
    for (int i = 1, end = _hashArea.length; i < end; i += 2) {
        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];
        if ((prop != null) && prop.getName().equals(key)) {
            return new BeanPropertyMap(this, newProp, i, _findFromOrdered(prop));
        }
    }
    final int slot = _hashCode(key);
    return new BeanPropertyMap(this, newProp, key, slot);
}",withProperty,com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java,/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java,"/**
     * Fluent copy method that creates a new instance that is a copy
     * of this instance except for one additional property that is
     * passed as the argument.
     * Note that method does not modify this instance but constructs
     * and returns a new one.
     */",307-329,"('withProperty', {'INSTRUCTION': {'covered': 50, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",110.0,27.0,Fluent copy method that creates a new instance that is a copy  of this instance except for one additional property that is  passed as the argument.,Creates a new instance representing a copy of the instance but for one additional property that is passed as a parameter to the method.,A fluent copy method creates a new instance that is a copy of this instance except for one property that is passed as the argument.,1.58590582873613,"Fluent copy method that creates a new instance that is a copy of that instance, except for an additional property that is passed as an argument."
573,dcache,"public static void putLong(byte[] bytes, int offset, long value) throws IllegalArgumentException{
    if (bytes.length - offset < 8) {
        throw new IllegalArgumentException(""not enough space to store long"");
    }
    bytes[offset] = (byte) (value >> 56);
    bytes[offset + 1] = (byte) (value >> 48);
    bytes[offset + 2] = (byte) (value >> 40);
    bytes[offset + 3] = (byte) (value >> 32);
    bytes[offset + 4] = (byte) (value >> 24);
    bytes[offset + 5] = (byte) (value >> 16);
    bytes[offset + 6] = (byte) (value >> 8);
    bytes[offset + 7] = (byte) value;
}",putLong,org/dcache/util/Bytes.java,/modules/common/src/main/java/org/dcache/util/Bytes.java,"/**
     * Puts a big-endian representation of {@code value} into <code>bytes</code> staring from
     * <code>offset</code>.
     *
     * @param bytes
     * @param offset
     * @param value
     * @throws IllegalArgumentException there is no enough room for 8 bytes.
     */",27-51,"('putLong', {'INSTRUCTION': {'covered': 88, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",168.0,28.0,Puts a big-endian representation of {@code value} into <code>bytes</code> staring from  <code>offset</code>.,Add big-endian representation of value into bytes starting from offset.,Puts a big-endian representation of @code value into code>bytes/code>.,0.658991034431953,Places a big-endian representation of {@code value} in <code>bytes</code> from the <code>offset</code>.
574,cdk,"long next(int[][] graph, int v, long[] current, long[] unique, long[] included, Suppressed suppressed){
    if (suppressed.contains(v))
        return current[v];
    long invariant = distribute(current[v]);
    int nUnique = 0;
    for (int w : graph[v]) {
        if (suppressed.contains(w))
            continue;
        long adjInv = current[w];
        int i = 0;
        while (i < nUnique && unique[i] != adjInv) {
            ++i;
        }
        included[i] = (i == nUnique) ? unique[nUnique++] = adjInv : rotate(included[i]);
        invariant ^= included[i];
    }
    return invariant;
}",next,org/openscience/cdk/hash/SuppressedAtomHashGenerator.java,/tool/hash/src/main/java/org/openscience/cdk/hash/SuppressedAtomHashGenerator.java,"/**
     * Determine the next value of the atom at index <i>v</i>. The value is
     * calculated by combining the current values of adjacent atoms. When a
     * duplicate value is found it can not be directly included and is
     * <i>rotated</i> the number of times it has previously been seen.
     *
     * @param graph      adjacency list representation of connected atoms
     * @param v          the atom to calculate the next value for
     * @param current    the current values
     * @param unique     buffer for working out which adjacent values are unique
     * @param included   buffer for storing the rotated <i>unique</i> value, this
     *                   value is <i>rotated</i> each time the same value is
     *                   found.
     * @param suppressed bit set indicates which atoms are 'suppressed'
     * @return the next value for <i>v</i>
     */",174-218,"('next', {'INSTRUCTION': {'covered': 82, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",155.0,17.0,Determine the next value of the atom at index <i>v</i>.,Computes and returns the subsequent value of the atom at index v.,The next value of the atom is determined by the index.,0.42398567281191,Determine the next value of the atom at index <i>v</i>.
575,glowstone,"public void sendItemChange(int slot, ItemStack item){
    if (invMonitor != null) {
        session.send(new SetWindowSlotMessage(invMonitor.getId(), slot, item));
    }
}",sendItemChange,net/glowstone/entity/GlowPlayer.java,/src/main/java/net/glowstone/entity/GlowPlayer.java,"/**
     * Sends a {@link SetWindowSlotMessage} to update the contents of an inventory slot.
     *
     * @param slot the slot ID
     * @param item the new contents
     */",3121-3131,"('sendItemChange', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,16.0,Sends a {@link SetWindowSlotMessage} to update the contents of an inventory slot.,Delivers a setWindowSlotMessage message to update the contents of an invetory set.,The contents of an inventory slot are updated by sending a @link SetWindowSlotMessage.,1.11979614170087,Sends a {@link SetWindowSlotMessage} to update the contents of an inventory location.
576,tablesaw,"public Row row(int rowIndex){
    Row row = new Row(Table.this);
    row.at(rowIndex);
    return row;
}",row,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,/** Returns a new Row object with its position set to the given zero-based row index. */,712-717,"('row', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,16.0,Returns a new Row object with its position set to the given zero-based row index.,"From a rowIndex given as input, return a new Row object based on that position.",A new Row object is returned with its position set to the zero-based row index.,0.268187710901695,Returns a new Row object whose position is set to the given zero baseline index.
577,liquibase,"public String escapeObjectName(String objectName, Class<? extends DatabaseObject> objectType){
    if ((quotingStrategy == ObjectQuotingStrategy.LEGACY) && hasMixedCase(objectName)) {
        return ""\"""" + objectName + ""\"""";
    } else if (objectType != null && LiquibaseColumn.class.isAssignableFrom(objectType)) {
        return (objectName != null && !objectName.isEmpty()) ? objectName.trim() : objectName;
    }
    return super.escapeObjectName(objectName, objectType);
}",escapeObjectName,liquibase/database/core/PostgresDatabase.java,/liquibase-core/src/main/java/liquibase/database/core/PostgresDatabase.java,"/**
     * This has special case logic to handle NOT quoting column names if they are
     * of type 'LiquibaseColumn' - columns in the DATABASECHANGELOG or DATABASECHANGELOGLOCK
     * tables.
     */",276-290,"('escapeObjectName', {'INSTRUCTION': {'covered': 39, 'missed': 1}, 'BRANCH': {'covered': 9, 'missed': 3}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,27.0,This has special case logic to handle NOT quoting column names if they are  of type 'LiquibaseColumn' - columns in the DATABASECHANGELOG or DATABASECHANGELOGLOCK  tables.,"Skips quoting the columns name of type ""LiquibaseColumn""",This has special case logic to not quote column names if they are in the DATABASECHANGELOG or DATABASECHANGELOGLOCK tables.,1.00962141269968,This has a special case logic to handle DO NOT quote column names if they are of type 'LiquibaseColumn' - columns in the DATABASECHANGELOG or DATABASECHANGELOGLOCK tables.
578,matsim-libs,"public void clusterInput(double radius, int minimumPoints){
    if (this.inputPoints.size() == 0) {
        log.warn(""DJCluster.clusterInput() called, but no points to cluster."");
    } else {
        if (!silent) {
            log.info(""Clustering input points. This may take a while."");
        }
        int clusterIndex = 0;
        int pointMultiplier = 1;
        int uPointCounter = 0;
        int cPointCounter = 0;
        /*
			 * Determine the extent of the QuadTree. 
			 */
        double xMin = Double.POSITIVE_INFINITY;
        double yMin = Double.POSITIVE_INFINITY;
        double xMax = Double.NEGATIVE_INFINITY;
        double yMax = Double.NEGATIVE_INFINITY;
        for (Node node : this.inputPoints) {
            Coord c = node.getCoord();
            /* TODO Remove if no NullPointerExceptions are thrown. */
            if (c == null) {
                log.warn(""Coord is null. Number of points in list: "" + inputPoints.size());
            } else {
                xMin = Math.min(xMin, c.getX());
                yMin = Math.min(yMin, c.getY());
                xMax = Math.max(xMax, c.getX());
                yMax = Math.max(yMax, c.getY());
            }
        }
        /*
			 * Build a new QuadTree, and place each point in the QuadTree as a ClusterActivity.
			 * The geographic coordinates of each point is used as the keys in the QuadTree.
			 * Initially all ClusterPoints will have a NULL reference to its DigicoreCluster. An 
			 * ArrayList of Points is also kept as iterator for unclustered points.
			 */
        if (!silent) {
            log.info(""Place points in QuadTree."");
        }
        quadTree = new QuadTree<ClusterActivity>(xMin - 1, yMin - 1, xMax + 1, yMax + 1);
        List<ClusterActivity> listOfPoints = new ArrayList<ClusterActivity>();
        for (int i = 0; i < this.inputPoints.size(); i++) {
            double x = inputPoints.get(i).getCoord().getX();
            double y = inputPoints.get(i).getCoord().getY();
            ClusterActivity cp = new ClusterActivity(Id.create(i, Coord.class), inputPoints.get(i), null);
            quadTree.put(x, y, cp);
            listOfPoints.add(cp);
        }
        if (!silent) {
            log.info(""Done placing activities."");
        }
        int pointCounter = 0;
        while (pointCounter < listOfPoints.size()) {
            // Get next point.
            ClusterActivity p = listOfPoints.get(pointCounter);
            if (p.getCluster() == null) {
                // Compute the density-based neighbourhood, N(p), of the point p
                Collection<ClusterActivity> neighbourhood = quadTree.getDisk(p.getCoord().getX(), p.getCoord().getY(), radius);
                List<ClusterActivity> uN = new ArrayList<ClusterActivity>(neighbourhood.size());
                List<ClusterActivity> cN = new ArrayList<ClusterActivity>(neighbourhood.size());
                for (ClusterActivity cp : neighbourhood) {
                    if (cp.getCluster() == null) {
                        uN.add(cp);
                    } else {
                        cN.add(cp);
                    }
                }
                if (neighbourhood.size() < minimumPoints) {
                    /* Point is considered to be noise.
						 * FIXME Not quite true... it may be incorporated into
						 * another cluster later! (JWJ - Mar '14)
						 */
                    lostPoints.put(p.getId(), p);
                    uPointCounter++;
                } else if (cN.size() > 0) {
                    /* 
						 * Merge all the clusters. Use the DigicoreCluster with the smallest clusterId
						 * value as the remaining DigicoreCluster.
						 */
                    List<Cluster> localClusters = new ArrayList<Cluster>();
                    Cluster smallestCluster = cN.get(0).getCluster();
                    for (int i = 1; i < cN.size(); i++) {
                        if (Integer.parseInt(cN.get(i).getCluster().getId().toString()) < Integer.parseInt(smallestCluster.getId().toString())) {
                            smallestCluster = cN.get(i).getCluster();
                        }
                        if (!localClusters.contains(cN.get(i).getCluster())) {
                            localClusters.add(cN.get(i).getCluster());
                        }
                    }
                    for (Cluster DigicoreCluster : localClusters) {
                        if (!DigicoreCluster.equals(smallestCluster)) {
                            List<ClusterActivity> thisClusterList = DigicoreCluster.getPoints();
                            for (int j = 0; j < thisClusterList.size(); j++) {
                                // Change the DigicoreCluster reference of the ClusterActivity.
                                thisClusterList.get(j).setCluster(smallestCluster);
                                // Add the ClusterActivity to the new DigicoreCluster.
                                smallestCluster.getPoints().add(thisClusterList.get(j));
                                // Remove the ClusterActivity from old DigicoreCluster.
                                /* 
									 * 20091009 - I've commented this out... this seems
									 * both dangerous and unnecessary. 
									 */
                                // DigicoreCluster.getPoints().remove(thisClusterList.get(j));
                            }
                        }
                    }
                    // Add unclustered points in the neighborhood.
                    for (ClusterActivity cp : uN) {
                        smallestCluster.getPoints().add(cp);
                        cp.setCluster(smallestCluster);
                        cPointCounter++;
                        if (lostPoints.containsKey(cp.getId())) {
                            lostPoints.remove(cp.getId());
                            uPointCounter--;
                        }
                    }
                } else {
                    // Create new DigicoreCluster and add all the points.
                    Cluster newCluster = new Cluster(Id.create(clusterIndex, Cluster.class));
                    clusterIndex++;
                    for (ClusterActivity cp : uN) {
                        cp.setCluster(newCluster);
                        newCluster.getPoints().add(cp);
                        cPointCounter++;
                        if (lostPoints.containsKey(cp.getId())) {
                            lostPoints.remove(cp.getId());
                            uPointCounter--;
                        }
                    }
                }
            }
            pointCounter++;
            // Report progress
            if (!silent) {
                if (pointCounter == pointMultiplier) {
                    log.info(""   Points clustered: "" + pointCounter);
                    pointMultiplier = (int) Math.max(pointCounter, pointMultiplier) * 2;
                }
            }
        }
        if (!silent) {
            log.info(""   Points clustered: "" + pointCounter + "" (Done)"");
            int sum = cPointCounter + uPointCounter;
            log.info(""Sum should add up: "" + cPointCounter + "" (clustered) + "" + uPointCounter + "" (unclustered) = "" + sum);
            /* Code added for Joubert & Meintjes paper (2014). */
            log.info(""Unclustered points: "");
            for (ClusterActivity ca : lostPoints.values()) {
                log.info(String.format(""   %.6f,%.6f"", ca.getCoord().getX(), ca.getCoord().getY()));
            }
            log.info(""New way of unclustered points:"");
            log.info(""   Number: "" + lostPoints.size());
        }
        /* 
			 * Build the DigicoreCluster list. Once built, I rename the clusterId field so as to
			 * start at '0', and increment accordingly. This allows me to directly use
			 * the clusterId field as 'row' and 'column' reference in the 2D matrices
			 * when determining adjacency in Social Network Analysis.
			 */
        if (!silent) {
            log.info(""Building the DigicoreCluster list (2 steps)"");
        }
        Map<Cluster, List<ClusterActivity>> clusterMap = new HashMap<Cluster, List<ClusterActivity>>();
        if (!silent) {
            log.info(""Step 1 of 2:"");
            log.info(""Number of ClusterPoints to process: "" + listOfPoints.size());
        }
        int cpCounter = 0;
        int cpMultiplier = 1;
        for (ClusterActivity ca : listOfPoints) {
            Cluster theCluster = ca.getCluster();
            if (theCluster != null) {
                // Removed 7/12/2011 (JWJ): Seems unnecessary computation.
                // theCluster.setCenterOfGravity();
                if (!clusterMap.containsKey(theCluster)) {
                    List<ClusterActivity> newList = new ArrayList<ClusterActivity>();
                    clusterMap.put(theCluster, newList);
                }
                clusterMap.get(theCluster).add(ca);
            }
            if (!silent) {
                if (++cpCounter == cpMultiplier) {
                    log.info(""   ClusterPoints processed: "" + cpCounter + "" ("" + String.format(""%3.2f"", ((double) cpCounter / (double) listOfPoints.size()) * 100) + ""%)"");
                    cpMultiplier *= 2;
                }
            }
        }
        if (!silent) {
            log.info(""   ClusterPoints processed: "" + cpCounter + "" (Done)"");
        }
        if (!silent) {
            log.info(""Step 2 of 2:"");
            log.info(""Number of clusters to process: "" + clusterMap.keySet().size());
        }
        int clusterCounter = 0;
        int clusterMultiplier = 1;
        int clusterNumber = 0;
        for (Map.Entry<Cluster, List<ClusterActivity>> e : clusterMap.entrySet()) {
            Cluster digicoreCluster = e.getKey();
            List<ClusterActivity> listOfClusterPoints = e.getValue();
            if (listOfClusterPoints.size() >= minimumPoints) {
                digicoreCluster.setClusterId(Id.create(clusterNumber++, Cluster.class));
                clusterNumber++;
                digicoreCluster.setCenterOfGravity();
                clusterList.add(digicoreCluster);
            } else if (!silent) {
                log.warn("" ... why do we HAVE a cluster with too few points?..."");
            }
            if (!silent) {
                if (++clusterCounter == clusterMultiplier) {
                    log.info(""   Clusters processed: "" + clusterCounter + "" ("" + String.format(""%3.2f"", ((double) clusterCounter / (double) clusterMap.keySet().size()) * 100) + ""%)"");
                    clusterMultiplier *= 2;
                }
            }
        }
        if (!silent) {
            log.info(""   Clusters processed: "" + clusterCounter + "" (Done)"");
            log.info(""DigicoreCluster list built."");
        }
    }
    // lost list must be made up of clusters without Id.
}",clusterInput,org/matsim/core/network/algorithms/intersectionSimplifier/DensityCluster.java,/matsim/src/main/java/org/matsim/core/network/algorithms/intersectionSimplifier/DensityCluster.java,"/**
	 * Building an <code>ArrayList</code> of <code>DigicoreCluster</code>s. The DJ-Clustering
	 * procedure of Zhou <i>et al</i> (2004) is followed. If there are no points to cluster, a
	 * warning message is logged, and the procedure bypassed.
	 */",97-341,"('clusterInput', {'INSTRUCTION': {'covered': 626, 'missed': 62}, 'BRANCH': {'covered': 72, 'missed': 12}, 'LINE': {'covered': 133, 'missed': 13}, 'COMPLEXITY': {'covered': 33, 'missed': 10}, 'METHOD': {'covered': 1, 'missed': 0}})",1543.0,19.0,Building an <code>ArrayList</code> of <code>DigicoreCluster</code>s.,Constructs an ArrayList of DigicoreCluster if present; otherwise log a warning message.,A code ofDigicoreCluster is built with code>ArrayList/code>.,0.822797363507703,Creation of an <code>ArrayList</code> of <code>DigicoreCluster</code>s.
579,dcache,"public void buildTransition(StatePath ourPath, StatePath newComponentPath, StateComponent newComponent, StateTransition transition) throws MetricStatePathException{
    String childName = newComponentPath.getFirstElement();
    StateChangeSet changeSet = transition.getOrCreateChangeSet(ourPath);
    if (this.isMortal() && newComponent.isMortal()) {
        Date newComponentExpiryDate = newComponent.getExpiryDate();
        changeSet.recordNewWhenIShouldExpireDate(newComponentExpiryDate);
    }
    if (newComponent.isImmortal()) {
        changeSet.recordChildIsImmortal();
    }
    changeSet.ensureChildNotRemoved(childName);
    if (newComponentPath.isSimplePath()) {
        if (_children.containsKey(childName)) {
            changeSet.recordUpdatedChild(childName, newComponent);
        } else {
            changeSet.recordNewChild(childName, newComponent);
        }
        if (newComponent instanceof StateComposite) {
            StateComposite newComposite = (StateComposite) newComponent;
            newComposite._metadataRef = getChildMetadata(childName);
        }
        return;
    }
    StateComponent child = _children.get(childName);
    if (child == null) {
        child = changeSet.getNewChildValue(childName);
        if (child == null) {
            child = new StateComposite(getChildMetadata(childName), DEFAULT_LIFETIME);
            changeSet.recordNewChild(childName, child);
        }
    }
    changeSet.recordChildItr(childName);
    child.buildTransition(buildChildPath(ourPath, childName), newComponentPath.childPath(), newComponent, transition);
}",buildTransition,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,"/**
     * Update a StateTransition object so a new StateComponent will be added to dCache's state.  The
     * changes are recorded in StateTransition so they can be applied later.
     *
     * @param ourPath          the StatePath to this StateComposite.
     * @param newComponentPath the StatePath to this StateComponent, relative to this
     *                         StateComposition
     * @param newComponent     the StateComponent to add.
     * @param transition       the StateTransition in which we will record these changes
     */",485-557,"('buildTransition', {'INSTRUCTION': {'covered': 96, 'missed': 0}, 'BRANCH': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 25, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",249.0,16.0,Update a StateTransition object so a new StateComponent will be added to dCache's state.,Stores the changes of an update StateTransition operation in the object transition.,A new StateComponent will be added to dCache's state if a StateTransition object is updated.,0.720138607788848,Update a StateTransition object so that a new StateComponent is added to the dCache state.
580,cdk,"private double calculateMassT(List<IIsotope> isoToCond_new, int[] value_In){
    double result = 0;
    for (int i = 0; i < isoToCond_new.size(); i++) {
        if (value_In[i] != 0) {
            result += isoToCond_new.get(i).getExactMass() * value_In[i];
        }
    }
    return result;
}",calculateMassT,org/openscience/cdk/formula/MassToFormulaTool.java,/legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java,"/**
     * Calculate the mass total given the elements and their respective occurrences.
     *
     * @param elemToCond_new  The IIsotope to calculate
     * @param value_In        Array matrix with occurrences
     * @return                The sum total
     */",521-536,"('calculateMassT', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,12.0,Calculate the mass total given the elements and their respective occurrences.,Computes the total mass from the elements and their related occurences.,The mass total is calculated by taking the elements and their occurrences.,0.707994339436549,Calculate the total mass according to the elements and their respective occurrences.
581,mybatis-3,"protected void addIfMatching(Test test, String fqn){
    try {
        String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');
        ClassLoader loader = getClassLoader();
        if (log.isDebugEnabled()) {
            log.debug(""Checking to see if class "" + externalName + "" matches criteria ["" + test + ""]"");
        }
        Class<?> type = loader.loadClass(externalName);
        if (test.matches(type)) {
            matches.add((Class<T>) type);
        }
    } catch (Throwable t) {
        log.warn(""Could not examine class '"" + fqn + ""'"" + "" due to a "" + t.getClass().getName() + "" with message: "" + t.getMessage());
    }
}",addIfMatching,org/apache/ibatis/io/ResolverUtil.java,/src/main/java/org/apache/ibatis/io/ResolverUtil.java,"/**
   * Add the class designated by the fully qualified class name provided to the set of
   * resolved classes if and only if it is approved by the Test supplied.
   *
   * @param test the test used to determine if the class matches
   * @param fqn the fully qualified name of a class
   */",274-298,"('addIfMatching', {'INSTRUCTION': {'covered': 53, 'missed': 16}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 11, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",146.0,29.0,Add the class designated by the fully qualified class name provided to the set of  resolved classes if and only if it is approved by the Test supplied.,Adds the class to the matches object using its fully qualified name iff has been approved by the Test supplied.,"If the class is approved by the test, add it to the set of resolved classes.",0.353967886663301,Add the class designated by the supplied display class name to the set of resolved classes if and only if it is approved by the supplied test.
582,cdk,"public Object clone() throws CloneNotSupportedException{
    ChemObject clone = (ChemObject) super.clone();
    clone.flags = getFlagValue().shortValue();
    if (properties != null)
        clone.properties = new HashMap<Object, Object>(getProperties());
    clone.chemObjectListeners = null;
    return clone;
}",clone,org/openscience/cdk/ChemObject.java,/base/data/src/main/java/org/openscience/cdk/ChemObject.java,"/**
     *  Clones this <code>IChemObject</code>. It clones the identifier, flags,
     *  properties and pointer vectors. The ChemObjectListeners are not cloned, and
     *  neither is the content of the pointer vectors.
     *
     *@return    The cloned object
     */",301-323,"('clone', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,10.0,Clones this <code>IChemObject</code>.,"Clones the identifiers, flags, properties and point vectors while discarding the ChemObjectListeners.",This is a clone of this code>IChemObject/code>.,0.545224491856714,Clone this <code>IChemObject</code>.
583,glowstone,"public boolean readBooleanNegated(@NonNls String key, Consumer<? super Boolean> consumer){
    return readTag(key, ByteTag.class, byteVal -> consumer.accept(byteVal == 0));
}",readBooleanNegated,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to a byte subtag if it is present, converting it to boolean and
     * negating it first.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */",524-536,"('readBooleanNegated', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,22.0,"Applies the given function to a byte subtag if it is present, converting it to boolean and  negating it first.",Returns the negation of a byte subtag that have been processed according to the function given as input.,"If the function is present, convert it to a byte subtag and then negating it.",0.284090532576447,"Applies the given function to a byte subtag if it is present, converting it to Boolean and denying it first."
584,cactoos,"private int copyPartial(final byte[] buffer, final byte[] response, final int num, final int read){
    final int result;
    if (num > 0) {
        System.arraycopy(response, read, response, 0, this.count - read);
        System.arraycopy(buffer, 0, response, this.count - read, read);
        result = this.count;
    } else {
        System.arraycopy(buffer, 0, response, 0, read);
        result = read;
    }
    return result;
}",copyPartial,org/cactoos/io/TailOf.java,/src/main/java/org/cactoos/io/TailOf.java,"/**
     * Copy buffer to response for read count smaller then buffer size.
     * @param buffer The buffer array
     * @param response The response array
     * @param num Number of bytes in response array from previous read
     * @param read Number of bytes read in the buffer
     * @return New count of bytes in the response array
     * @checkstyle ParameterNumberCheck (3 lines)
     */",117-140,"('copyPartial', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",107.0,12.0,Copy buffer to response for read count smaller then buffer size.,Copies buffer to response for reading count having a smaller size than the buffer size.,The buffer size should be copied to the response for read count.,0.232393394174537,Copy the buffer into the response for a read number that is less than the size of the buffer.
585,weblogic-kubernetes-operator,"CallerDetails inferCaller(){
    CallerDetails details = new CallerDetails();
    Throwable t = new Throwable();
    StackTraceElement[] stack = t.getStackTrace();
    int i = 0;
    while (i < stack.length) {
        StackTraceElement frame = stack[i];
        String cname = frame.getClassName();
        if (!cname.equals(CLASS)) {
            details.clazz = cname;
            details.method = frame.getMethodName();
            break;
        }
        i++;
    }
    return details;
}",inferCaller,oracle/kubernetes/operator/logging/LoggingFacade.java,/operator/src/main/java/oracle/kubernetes/operator/logging/LoggingFacade.java,"/**
   * Obtains caller details, class name and method, to be provided to the actual Logger. This code
   * is adapted from ODLLogRecord, which should yield consistency in reporting using PlatformLogger
   * versus a raw (ODL) Logger. JDK Logger does something similar but utilizes native methods
   * directly.
   */",624-649,"('inferCaller', {'INSTRUCTION': {'covered': 40, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",101.0,17.0,"Obtains caller details, class name and method, to be provided to the actual Logger.","Fetches all the caller details, class name, and method to be fed to the actual logger.","The actual Logger will get caller details, class name and method.",0.773724788143001,"Gets the caller details, class name, and method to provide to the actual recorder."
586,acs-aem-commons,"public static Session useBestWrapper(final Session session){
    if (session instanceof JackrabbitWrapper || session instanceof JcrWrapper) {
        return session;
    } else if (session instanceof JackrabbitSession) {
        return new JackrabbitWrapper((JackrabbitSession) session);
    } else if (session != null) {
        return new JcrWrapper(session);
    }
    return null;
}",useBestWrapper,com/adobe/acs/commons/wrap/impl/SessionLogoutGuardFactory.java,/bundle/src/main/java/com/adobe/acs/commons/wrap/impl/SessionLogoutGuardFactory.java,"/**
     * Return the best wrapped version of the provided session.
     *
     * @param session the session to wrap
     * @return a wrapped session
     */",82-97,"('useBestWrapper', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",64.0,10.0,Return the best wrapped version of the provided session.,"Given a session object as input, it returns the best-wrapped version of such object.",The best wrapped version of the session should be returned.,0.811648243329184,Return the best encapsulated version of the provided session.
587,zxing,"private void extractParameters(ResultPoint[] bullsEyeCorners) throws NotFoundException{
    if (!isValid(bullsEyeCorners[0]) || !isValid(bullsEyeCorners[1]) || !isValid(bullsEyeCorners[2]) || !isValid(bullsEyeCorners[3])) {
        throw NotFoundException.getNotFoundInstance();
    }
    int length = 2 * nbCenterLayers;
    int[] sides = { sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length), sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length), sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length), sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) };
    shift = getRotation(sides, length);
    long parameterData = 0;
    for (int i = 0; i < 4; i++) {
        int side = sides[(shift + i) % 4];
        if (compact) {
            parameterData <<= 7;
            parameterData += (side >> 1) & 0x7F;
        } else {
            parameterData <<= 10;
            parameterData += ((side >> 2) & (0x1f << 5)) + ((side >> 1) & 0x1F);
        }
    }
    int correctedData = getCorrectedParameterData(parameterData, compact);
    if (compact) {
        nbLayers = (correctedData >> 6) + 1;
        nbDataBlocks = (correctedData & 0x3F) + 1;
    } else {
        nbLayers = (correctedData >> 11) + 1;
        nbDataBlocks = (correctedData & 0x7FF) + 1;
    }
}",extractParameters,com/google/zxing/aztec/detector/Detector.java,/core/src/main/java/com/google/zxing/aztec/detector/Detector.java,"/**
   * Extracts the number of data layers and data blocks from the layer around the bull's eye.
   *
   * @param bullsEyeCorners the array of bull's eye corners
   * @throws NotFoundException in case of too many errors or invalid parameters
   */",100-154,"('extractParameters', {'INSTRUCTION': {'covered': 177, 'missed': 2}, 'BRANCH': {'covered': 10, 'missed': 4}, 'LINE': {'covered': 24, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",295.0,18.0,Extracts the number of data layers and data blocks from the layer around the bull's eye.,It Retrieves the number of data layers and blocks from the layer featuring the bull's eye.,The data layers and data blocks are taken from the bull's eye.,0.313825970076292,Gets the number of data layers and data blocks from the layer around the bull's eye.
588,openapi-generator,"private static ValidationRule.Result checkOneOfWithProperties(SchemaWrapper schemaWrapper){
    Schema schema = schemaWrapper.getSchema();
    ValidationRule.Result result = ValidationRule.Pass.empty();
    if (schema instanceof ComposedSchema) {
        final ComposedSchema composed = (ComposedSchema) schema;
        // check for loosely defined oneOf extension requirements.
        // This is a recommendation because the 3.0.x spec is not clear enough on usage of oneOf.
        // see https://json-schema.org/draft/2019-09/json-schema-core.html#rfc.section.9.2.1.3 and the OAS section on 'Composition and Inheritance'.
        if (composed.getOneOf() != null && composed.getOneOf().size() > 0) {
            if (composed.getProperties() != null && composed.getProperties().size() >= 1 && composed.getProperties().get(""discriminator"") == null) {
                // not necessarily ""invalid"" here, but we trigger the recommendation which requires the method to return false.
                result = ValidationRule.Fail.empty();
            }
        }
    }
    return result;
}",checkOneOfWithProperties,org/openapitools/codegen/validations/oas/OpenApiSchemaValidations.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/validations/oas/OpenApiSchemaValidations.java,"/**
     * JSON Schema defines oneOf as a validation property which can be applied to any schema.
     * <p>
     * OpenAPI Specification is a variant of JSON Schema for which oneOf is defined as:
     * ""Inline or referenced schema MUST be of a Schema Object and not a standard JSON Schema.""
     * <p>
     * Where the only examples of oneOf in OpenAPI Specification are used to define either/or type structures rather than validations.
     * Because of this ambiguity in the spec about what is non-standard about oneOf support, we'll warn as a recommendation that
     * properties on the schema defining oneOf relationships may not be intentional in the OpenAPI Specification.
     *
     * @param schemaWrapper An input schema, regardless of the type of schema
     * @return {@link ValidationRule.Pass} if the check succeeds, otherwise {@link ValidationRule.Fail}
     */",55-85,"('checkOneOfWithProperties', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 3}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",125.0,16.0,JSON Schema defines oneOf as a validation property which can be applied to any schema.,"If the schema is an instance of ComposedSchema, it returns {@link ValidationRule.pass}, otherwise {@link ValidationRule.fail}.",OneOf is a validation property which can be applied to any other database.,0.436173249497343,JSON Schema defines oneOf as a validation property that can be applied to any schema.
590,egeria,"private Optional<EntityDetail> findDatabaseEntity(String userId, String qualifiedName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, DATABASE_TYPE_NAME);
}",findDatabaseEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineRelationalDataHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineRelationalDataHandler.java,"/**
     * Find out if the Database object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the database to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",148-164,"('findDatabaseEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,13.0,Find out if the Database object is already stored in the repository.,Finds whether the database object has been previously stored in the repository using the fully qualified name.,"If the database object is already in the repository, you should find it.",0.0991593969483187,Check if the Database object is already stored in the repository.
591,cdk,"static List<Vector2d> newUnitVectors(final IAtom fromAtom, final List<IAtom> toAtoms){
    final List<Vector2d> unitVectors = new ArrayList<Vector2d>(toAtoms.size());
    for (final IAtom toAtom : toAtoms) {
        unitVectors.add(newUnitVector(fromAtom.getPoint2d(), toAtom.getPoint2d()));
    }
    return unitVectors;
}",newUnitVectors,org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,"/**
     * Create unit vectors from one atom to all other provided atoms.
     *
     * @param fromAtom reference atom (will become 0,0)
     * @param toAtoms list of to atoms
     * @return unit vectors
     */",97-110,"('newUnitVectors', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",73.0,12.0,Create unit vectors from one atom to all other provided atoms.,"Given a list of Atoms, it builds and returns unit vectors.",The unit is created from one atom to all the other atoms.,0.26408745386545,Create unit vectors from one atom to all the other atoms supplied.
592,acs-aem-commons,"void close() throws IOException{
    if (flushBufferOnClose) {
        if (ResponseWriteMethod.OUTPUTSTREAM.equals(this.writeMethod) && outputStream != null && getBufferedBytes().length > 0) {
            wrappedResponse.getOutputStream().write(getBufferedBytes());
        } else if (ResponseWriteMethod.WRITER.equals(this.writeMethod) && writer != null && getBufferedString().length() > 0) {
            wrappedResponse.getWriter().write(getBufferedString());
        }
    }
    if (flushWrappedBuffer) {
        wrappedResponse.flushBuffer();
    }
}",close,com/adobe/acs/commons/util/BufferedServletOutput.java,/bundle/src/main/java/com/adobe/acs/commons/util/BufferedServletOutput.java,"/** 
     * Closing leads to flushing the buffered output stream or writer to the underlying/wrapped response but only in case {@link #flushBufferOnClose} is set to {@code true}.
     * Also this will automatically commit the response in case {@link #flushBuffer} has been called previously!
     * 
     * @throws IOException */",186-202,"('close', {'INSTRUCTION': {'covered': 40, 'missed': 7}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",109.0,33.0,Closing leads to flushing the buffered output stream or writer to the underlying/wrapped response but only in case {@link #flushBufferOnClose} is set to {@code true}.,"Checks whether flushBufferOnClose is set to true. If that's the case, it closes the buffered output stream or the writer to the underlying/wrapped response.","If the code is true, closing will cause the buffer to be flushed to the underlying/wrapped response.",1.89990170100804,"Closing causes the buffered output stream or recorder to be flushed to the underlying/encapsulated response, but only if {@link #flushBufferOnClose} is set to {@code true}."
593,glowstone,"protected boolean tryFeed(Material type, GlowPlayer player){
    if (!getBreedingFoods().contains(type)) {
        return false;
    }
    if (canBreed() && getInLove() <= 0) {
        // TODO get the correct duration
        setInLove(1000);
        player.incrementStatistic(Statistic.ANIMALS_BRED);
        return true;
    }
    int growth = computeGrowthAmount(type);
    if (growth > 0) {
        grow(growth);
        return true;
    }
    return false;
}",tryFeed,net/glowstone/entity/GlowAnimal.java,/src/main/java/net/glowstone/entity/GlowAnimal.java,"/**
     * Determines whether this entity can eat an item while healthy, and if so, applies the effects
     * of eating it.
     *
     * @param player the player feeding the entity, for statistical purposes
     * @param type an item that may be food
     * @return true if the item should be consumed; false otherwise
     */",53-76,"('tryFeed', {'INSTRUCTION': {'covered': 29, 'missed': 5}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 2}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,22.0,"Determines whether this entity can eat an item while healthy, and if so, applies the effects  of eating it.","Returns true if the current entity can eat an item. If so, applies the effects of eating it, otherwise returns false.","If this entity can eat an item while healthy, and if so, how it effects the environment.",0.304613622848156,"Determines whether this entity can eat a healthy item and, if so, applies the effects of its consumption."
594,matsim-libs,"public void addNetworkChangeEvent(final NetworkChangeEvent event){
    this.networkChangeEvents.add(event);
    for (Link link : event.getLinks()) {
        if (link instanceof TimeVariantLinkImpl) {
            ((TimeVariantLinkImpl) link).applyEvent(event);
        } else {
            throw new IllegalArgumentException(""Link "" + link.getId().toString() + "" is not timeVariant. "" + ""Did you make the network factory time variant?  The easiest way to achieve this is "" + ""either in the config file, or syntax of the type\n"" + ""config.network().setTimeVariantNetwork(true);\n"" + ""Scenario scenario = ScenarioUtils.load/createScenario(config);\n"" + ""Note that the scenario needs to be created _after_ the config option is set, otherwise"" + ""the factory will already be there."");
        }
    }
}",addNetworkChangeEvent,org/matsim/core/network/NetworkImpl.java,/matsim/src/main/java/org/matsim/core/network/NetworkImpl.java,"/**
	 * Adds a single network change event and applies it to the corresponding
	 * links.
	 *
	 * @param event
	 *            a network change event.
	 */",299-322,"('addNetworkChangeEvent', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",86.0,14.0,Adds a single network change event and applies it to the corresponding  links.,Adds a new network change event by applying it to the corresponding links.,A single network change event is added and applied to the links.,0.172891680252344,Adds a single network change event and applies it to the corresponding links.
595,cron-utils,"public int mapTo(final int dayOfWeek, final WeekDay targetWeekDayDefinition){
    if (firstDayZero && targetWeekDayDefinition.isFirstDayZero()) {
        return bothSameStartOfRange(0, 6, this, targetWeekDayDefinition).apply(dayOfWeek);
    }
    if (!firstDayZero && !targetWeekDayDefinition.isFirstDayZero()) {
        return bothSameStartOfRange(1, 7, this, targetWeekDayDefinition).apply(dayOfWeek);
    }
    // start range is different for each case. We need to normalize ranges
    if (targetWeekDayDefinition.isFirstDayZero()) {
        // my range is 1-7. I normalize ranges, get the ""zero"" mapping and turn result into original scale
        return mapTo(dayOfWeek, new WeekDay(targetWeekDayDefinition.getMondayDoWValue() + 1, false)) - 1;
    } else {
        // my range is 0-6. I normalize ranges, get the ""one"" mapping and turn result into original scale
        return mapTo(dayOfWeek, new WeekDay(targetWeekDayDefinition.getMondayDoWValue() - 1, true)) + 1;
    }
}",mapTo,com/cronutils/mapper/WeekDay.java,/src/main/java/com/cronutils/mapper/WeekDay.java,"/**
     * Maps given WeekDay to representation hold by this instance.
     *
     * @param targetWeekDayDefinition - referred weekDay
     * @param dayOfWeek               - day of week to be mapped.
     *                                Value corresponds to this instance mapping.
     * @return - int result
     */",43-66,"('mapTo', {'INSTRUCTION': {'covered': 67, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",131.0,10.0,Maps given WeekDay to representation hold by this instance.,Maps the given WeekDay to a representation suitable for this instance.,Maps given WeekDay to representation hold this instance.,0.412562000397123,Cards given WeekDay to the representation held by this body.
596,cdk,"private static StereoEncoder axial2DEncoder(IAtomContainer container, IAtom start, List<IBond> startBonds, IAtom end, List<IBond> endBonds){
    Point2d[] ps = new Point2d[4];
    int[] es = new int[4];
    PermutationParity perm = new CombinedPermutationParity(fill2DCoordinates(container, start, startBonds, ps, es, 0), fill2DCoordinates(container, end, endBonds, ps, es, 2));
    GeometricParity geom = new Tetrahedral2DParity(ps, es);
    int u = container.indexOf(start);
    int v = container.indexOf(end);
    return new GeometryEncoder(new int[] { u, v }, perm, geom);
}",axial2DEncoder,org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,"/**
     * Create an encoder for axial 2D stereochemistry for the given start and
     * end atoms.
     *
     * @param container  the molecule
     * @param start      start of the cumulated system
     * @param startBonds bonds connected to the start
     * @param end        end of the cumulated system
     * @param endBonds   bonds connected to the end
     * @return an encoder
     */",160-186,"('axial2DEncoder', {'INSTRUCTION': {'covered': 54, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",137.0,15.0,Create an encoder for axial 2D stereochemistry for the given start and  end atoms.,"Given the start and end atoms, builds an encoder for axial 2D stereochemistry.",An Encoder is needed for the given start and end atoms.,0.459935271921157,Create an encoder for 2D axial stereochemistry for the given start and end atoms.
597,dcache,"private static ImmutableSetMultimap<Pattern, String> toPatterns(Map<String, String> formats){
    ImmutableSetMultimap.Builder<Pattern, String> builder = ImmutableSetMultimap.builder();
    for (Map.Entry<String, String> format : formats.entrySet()) {
        builder.putAll(toPattern(format.getKey(), format.getValue()), toAttributes(format.getValue()));
    }
    return builder.build();
}",toPatterns,org/dcache/services/billing/text/BillingParserBuilder.java,/modules/dcache/src/main/java/org/dcache/services/billing/text/BillingParserBuilder.java,"/**
     * Returns Patterns for the provided billing formats, as a Multimap mapping the Pattern to the
     * attributes contained in the pattern.
     */",140-151,"('toPatterns', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,22.0,"Returns Patterns for the provided billing formats, as a Multimap mapping the Pattern to the  attributes contained in the pattern.",Builds and returns a new multimap mapping the pattern to the attributes featuring the pattern.,The pattern is returned as a Multimap mapping the attributes contained in the pattern.,0.492086920732272,"Returns templates for the provided billing formats, in the form of a multi-card that maps the template to the attributes contained in the template."
598,dataverse,"protected void tidyUpFields(DatasetVersion dsv){
    Iterator<DatasetField> dsfIt = dsv.getDatasetFields().iterator();
    while (dsfIt.hasNext()) {
        if (dsfIt.next().removeBlankDatasetFieldValues()) {
            dsfIt.remove();
        }
    }
    Iterator<DatasetField> dsfItSort = dsv.getDatasetFields().iterator();
    while (dsfItSort.hasNext()) {
        dsfItSort.next().setValueDisplayOrder();
    }
    Iterator<DatasetField> dsfItTrim = dsv.getDatasetFields().iterator();
    while (dsfItTrim.hasNext()) {
        dsfItTrim.next().trimTrailingSpaces();
    }
}",tidyUpFields,edu/harvard/iq/dataverse/engine/command/impl/AbstractDatasetCommand.java,/src/main/java/edu/harvard/iq/dataverse/engine/command/impl/AbstractDatasetCommand.java,"/**
     * Removed empty fields, sets field value display order.
     *
     * @param dsv the dataset version show fields we want to tidy up.
     */",118-138,"('tidyUpFields', {'INSTRUCTION': {'covered': 30, 'missed': 10}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 9, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",127.0,10.0,"Removed empty fields, sets field value display order.",Updates fields by setting the field value display order and removing those that are empty.,The field value display order is set.,0.259218386415795,"Deleting empty fields, setting the order in which field values are displayed."
599,acs-aem-commons,"private void populateHeaders() throws RepositoryException{
    final Node headers = getOrCreateByPath(entryNode, JCRHttpCacheStoreConstants.PATH_HEADERS, OAK_UNSTRUCTURED, OAK_UNSTRUCTURED);
    for (Iterator<Map.Entry<String, List<String>>> entryIterator = cacheContent.getHeaders().entrySet().iterator(); entryIterator.hasNext(); ) {
        Map.Entry<String, List<String>> entry = entryIterator.next();
        final String key = entry.getKey();
        final List<String> values = entry.getValue();
        headers.setProperty(key, values.toArray(new String[values.size()]));
    }
}",populateHeaders,com/adobe/acs/commons/httpcache/store/jcr/impl/writer/EntryNodeWriter.java,/bundle/src/main/java/com/adobe/acs/commons/httpcache/store/jcr/impl/writer/EntryNodeWriter.java,"/**
     * Save the headers into a headers node under the cache entry node.
     * @throws RepositoryException
     */",114-128,"('populateHeaders', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",131.0,13.0,Save the headers into a headers node under the cache entry node.,"If the headers node is not null, save the new headers under the cache entry node.","Under the cache entry node, save the headers.",0.859167571442819,Save the headers to a header node under the cache input node.
600,cdk,"public DescriptorValue calculate(IAtomContainer ac){
    ac = clone(ac);
    int rotatableBondsCount = 0;
    int degree0;
    int degree1;
    IRingSet ringSet;
    try {
        ringSet = new SpanningTree(ac).getBasicRings();
    } catch (NoSuchAtomException e) {
        return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult((int) Double.NaN), getDescriptorNames(), e);
    }
    for (IBond bond : ac.bonds()) {
        if (ringSet.getRings(bond).getAtomContainerCount() > 0) {
            bond.setFlag(CDKConstants.ISINRING, true);
        }
    }
    for (IBond bond : ac.bonds()) {
        IAtom atom0 = bond.getBegin();
        IAtom atom1 = bond.getEnd();
        if (atom0.getAtomicNumber() == IElement.H || atom1.getAtomicNumber() == IElement.H)
            continue;
        if (bond.getOrder() == Order.SINGLE) {
            if ((BondManipulator.isLowerOrder(ac.getMaximumBondOrder(atom0), IBond.Order.TRIPLE)) && (BondManipulator.isLowerOrder(ac.getMaximumBondOrder(atom1), IBond.Order.TRIPLE))) {
                if (!bond.getFlag(CDKConstants.ISINRING)) {
                    if (excludeAmides && (isAmide(atom0, atom1, ac) || isAmide(atom1, atom0, ac))) {
                        continue;
                    }
                    degree0 = ac.getConnectedBondsCount(atom0) - getConnectedHCount(ac, atom0);
                    degree1 = ac.getConnectedBondsCount(atom1) - getConnectedHCount(ac, atom1);
                    if ((degree0 == 1) || (degree1 == 1)) {
                        if (includeTerminals) {
                            rotatableBondsCount += 1;
                        }
                    } else {
                        rotatableBondsCount += 1;
                    }
                }
            }
        }
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(rotatableBondsCount), getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/RotatableBondsCountDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/RotatableBondsCountDescriptor.java,"/**
     *  The method calculates the number of rotatable bonds of an atom container.
     *  If the boolean parameter is set to true, terminal bonds are included.
     *
     *@param  ac                AtomContainer
     *@return                   number of rotatable bonds
     */",135-190,"('calculate', {'INSTRUCTION': {'covered': 144, 'missed': 18}, 'BRANCH': {'covered': 26, 'missed': 4}, 'LINE': {'covered': 27, 'missed': 3}, 'COMPLEXITY': {'covered': 12, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",374.0,13.0,The method calculates the number of rotatable bonds of an atom container.,Computes the number of rotable bonds of an atom container.,The method calculates the number of bonds in the atom container.,0.383834125718478,The method calculates the number of rotating bonds of an atom container.
601,glowstone,"public static CompatibilityBundle fromConfig(String configValue){
    if (configValue == null || CharMatcher.whitespace().matchesAllOf(configValue)) {
        return CompatibilityBundle.CRAFTBUKKIT;
    }
    try {
        return valueOf(configValue.toUpperCase());
    } catch (IllegalArgumentException e) {
        return null;
    }
}",fromConfig,net/glowstone/util/CompatibilityBundle.java,/src/main/java/net/glowstone/util/CompatibilityBundle.java,"/**
     * Converts the given config value into the appropriate bundle. If the given value is blank or
     * null, the default value is returned. If the given value does not match any preprogrammmed
     * bundles case insensitively, then null is returned.
     *
     * @param configValue The value from the config file.
     */",44-60,"('fromConfig', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",57.0,10.0,Converts the given config value into the appropriate bundle.,"Given a String object configValue, returns null if no matches are found with respect to the preprogrammed bundles. Othewise returns the default value.",The given config value is converted into the appropriate bundle.,0.203398611956606,Converts the given configuration value to the appropriate bundle.
602,cdk,"public void placeAliphaticHeavyChain(IAtomContainer molecule, IAtomContainer chain) throws CDKException{
    int[] first = new int[2];
    int counter = 1;
    int nextAtomNr = 0;
    String id1 = """";
    String id2 = """";
    String id3 = """";
    first = findHeavyAtomsInChain(molecule, chain);
    distances = new double[first[1]];
    firstAtoms = new int[first[1]];
    angles = new double[first[1]];
    secondAtoms = new int[first[1]];
    dihedrals = new double[first[1]];
    thirdAtoms = new int[first[1]];
    firstAtoms[0] = first[0];
    molecule.getAtom(firstAtoms[0]).setFlag(CDKConstants.VISITED, true);
    int hybridisation = 0;
    for (int i = 0; i < chain.getAtomCount(); i++) {
        if (isHeavyAtom(chain.getAtom(i))) {
            if (!chain.getAtom(i).getFlag(CDKConstants.VISITED)) {
                nextAtomNr = molecule.indexOf(chain.getAtom(i));
                id2 = molecule.getAtom(firstAtoms[counter - 1]).getAtomTypeName();
                id1 = molecule.getAtom(nextAtomNr).getAtomTypeName();
                if (molecule.getBond(molecule.getAtom(firstAtoms[counter - 1]), molecule.getAtom(nextAtomNr)) == null)
                    throw new CDKException(""atoms do not form a chain, please use ModelBuilder3D"");
                distances[counter] = getBondLengthValue(id1, id2);
                firstAtoms[counter] = nextAtomNr;
                secondAtoms[counter] = firstAtoms[counter - 1];
                if (counter > 1) {
                    id3 = molecule.getAtom(firstAtoms[counter - 2]).getAtomTypeName();
                    hybridisation = getHybridisationState(molecule.getAtom(firstAtoms[counter - 1]));
                    angles[counter] = getAngleValue(id1, id2, id3);
                    if (angles[counter] == -1) {
                        if (hybridisation == 3) {
                            angles[counter] = DEFAULT_SP3_ANGLE;
                        } else if (hybridisation == 2) {
                            angles[counter] = DEFAULT_SP2_ANGLE;
                        } else if (hybridisation == 1) {
                            angles[counter] = DEFAULT_SP_ANGLE;
                        }
                    }
                    thirdAtoms[counter] = firstAtoms[counter - 2];
                } else {
                    angles[counter] = -1;
                    thirdAtoms[counter] = -1;
                }
                if (counter > 2) {
                    try {
                        if (getDoubleBondConfiguration2D(molecule.getBond(molecule.getAtom(firstAtoms[counter - 1]), molecule.getAtom(firstAtoms[counter - 2])), (molecule.getAtom(firstAtoms[counter])).getPoint2d(), (molecule.getAtom(firstAtoms[counter - 1])).getPoint2d(), (molecule.getAtom(firstAtoms[counter - 2])).getPoint2d(), (molecule.getAtom(firstAtoms[counter - 3])).getPoint2d()) == 5) {
                            dihedrals[counter] = DIHEDRAL_BRANCHED_CHAIN;
                        } else {
                            dihedrals[counter] = DIHEDRAL_EXTENDED_CHAIN;
                        }
                    } catch (CDKException ex1) {
                        dihedrals[counter] = DIHEDRAL_EXTENDED_CHAIN;
                    }
                } else {
                    dihedrals[counter] = -1;
                }
                counter++;
            }
        }
    }
}",placeAliphaticHeavyChain,org/openscience/cdk/modeling/builder3d/AtomPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomPlacer3D.java,"/**
     *  Method assigns 3D coordinates to the heavy atoms in an aliphatic chain.
     *
     * @param molecule        the reference molecule for the chain
     * @param  chain          the atoms to be assigned, must be connected
     * @throws CDKException the 'chain' was not a chain
     */",116-200,"('placeAliphaticHeavyChain', {'INSTRUCTION': {'covered': 297, 'missed': 30}, 'BRANCH': {'covered': 16, 'missed': 6}, 'LINE': {'covered': 50, 'missed': 7}, 'COMPLEXITY': {'covered': 8, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",634.0,13.0,Method assigns 3D coordinates to the heavy atoms in an aliphatic chain.,Attributes 3D coordinates to the heavy atoms in an alphatic chain.,The method assigns coordinates to the heavy atoms.,0.494898503283602,The method assigns 3D coordinates to heavy atoms in an aliphatic chain.
603,cdk,"public static double method1(ICountFingerprint fp1, ICountFingerprint fp2){
    long xy = 0, x = 0, y = 0;
    for (int i = 0; i < fp1.numOfPopulatedbins(); i++) {
        int hash = fp1.getHash(i);
        for (int j = 0; j < fp2.numOfPopulatedbins(); j++) {
            if (hash == fp2.getHash(j)) {
                xy += fp1.getCount(i) * fp2.getCount(j);
            }
        }
        x += fp1.getCount(i) * fp1.getCount(i);
    }
    for (int j = 0; j < fp2.numOfPopulatedbins(); j++) {
        y += fp2.getCount(j) * fp2.getCount(j);
    }
    return ((double) xy / (x + y - xy));
}",method1,org/openscience/cdk/similarity/Tanimoto.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/similarity/Tanimoto.java,"/**
     * Calculates Tanimoto distance for two count fingerprints using method 1.
     *
     * The feature/count type fingerprints may be of different length.
     * Uses Tanimoto method from {@cdk.cite Steffen09}.
     * 
     * @param fp1 count fingerprint 1
     * @param fp2 count fingerprint 2
     * @return a Tanimoto distance
     */",185-210,"('method1', {'INSTRUCTION': {'covered': 82, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",173.0,11.0,Calculates Tanimoto distance for two count fingerprints using method 1.,Computes the Tanimoto distance for two count fingerprints.,Method 1 calculates Tanimoto distance for two count fingerprints.,0.218860173233343,Calculates the Tanimoto distance for two counting fingerprints using Method 1.
605,shardingsphere-elasticjob,"public boolean isAllStarted(){
    return jobNodeStorage.isJobNodeExisted(GuaranteeNode.STARTED_ROOT) && configService.load(false).getShardingTotalCount() == jobNodeStorage.getJobNodeChildrenKeys(GuaranteeNode.STARTED_ROOT).size();
}",isAllStarted,org/apache/shardingsphere/elasticjob/lite/internal/guarantee/GuaranteeService.java,/elasticjob-lite/elasticjob-lite-core/src/main/java/org/apache/shardingsphere/elasticjob/lite/internal/guarantee/GuaranteeService.java,"/**
     * Judge whether job's sharding items are all started.
     *
     * @return job's sharding items are all started or not
     */",66-74,"('isAllStarted', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,10.0,Judge whether job's sharding items are all started.,Checks if the job's sharding items have been started.,"If the job's shards are all started, then you should judge it.",0.206966382240607,Judge whether the partitioning items of the task are all started.
606,cdk,"private static T[] grow(T[] array, int required){
    int oldCapacity = array.length;
    int newCapacity = oldCapacity == 0 ? DEFAULT_CAPACITY : oldCapacity + (oldCapacity >> 1);
    if (newCapacity < required)
        newCapacity = required;
    return Arrays.copyOf(array, newCapacity);
}",grow,org/openscience/cdk/AtomContainer.java,/base/data/src/main/java/org/openscience/cdk/AtomContainer.java,"/**
     * Generic grow function, expand an array by a varried amount to have
     * enough (required) space.
     *
     * @param array    the array to expand
     * @param required the minimum required space
     * @param <T>      array type
     * @return the expanded array
     */",1415-1432,"('grow', {'INSTRUCTION': {'covered': 20, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",62.0,19.0,"Generic grow function, expand an array by a varried amount to have  enough (required) space.",Expand an array space by a fixed amount.,A generic grow function expands an array by a certain amount.,0.303764397091673,"Generic growth function, expand an array of varying amounts to have enough space (required)."
607,dcache,"public QualityValue<U> mapWith(Function<String, U> conversion){
    return new QualityValue(rawValue, conversion.apply(rawValue), quality);
}",mapWith,org/dcache/util/QualityValue.java,/modules/dcache/src/main/java/org/dcache/util/QualityValue.java,"/**
     * Provide a new QualityValue with the same quality but with the value mapped to a different
     * type.
     *
     * @param <U>        The new type of the value
     * @param conversion the method to convert to the new type
     * @return The mapped QualityValue.
     */",73-83,"('mapWith', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,18.0,Provide a new QualityValue with the same quality but with the value mapped to a different  type.,Returns a mapped QualityValue having the same quality but a different mapped type.,A new QualityValue with the same quality but with a different type is provided.,1.01792868897779,Provide a new QualitativeValue value with the same quality but with the value mapped to a different type.
608,cdk,"private void breadthFirstSearch(IAtomContainer container, List<IAtom> sphere, List<IAtom> path) throws CDKException{
    IAtom nextAtom;
    List<IAtom> newSphere = new ArrayList<IAtom>();
    for (IAtom atom : sphere) {
        List bonds = container.getConnectedBondsList(atom);
        for (Object bond : bonds) {
            nextAtom = ((IBond) bond).getOther(atom);
            if ((container.getMaximumBondOrder(nextAtom) != IBond.Order.SINGLE || Math.abs(nextAtom.getFormalCharge()) >= 1 || nextAtom.getFlag(CDKConstants.ISAROMATIC) || nextAtom.getAtomicNumber() == IElement.N || nextAtom.getAtomicNumber() == IElement.O) & !nextAtom.getFlag(CDKConstants.VISITED)) {
                path.add(nextAtom);
                nextAtom.setFlag(CDKConstants.VISITED, true);
                if (container.getConnectedBondsCount(nextAtom) > 1) {
                    newSphere.add(nextAtom);
                }
            } else {
                nextAtom.setFlag(CDKConstants.VISITED, true);
            }
        }
    }
    if (newSphere.size() > 0) {
        breadthFirstSearch(container, newSphere, path);
    }
}",breadthFirstSearch,org/openscience/cdk/qsar/descriptors/molecular/LargestPiSystemDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/LargestPiSystemDescriptor.java,"/**
     * Performs a breadthFirstSearch in an AtomContainer starting with a
     * particular sphere, which usually consists of one start atom, and searches
     * for a pi system.
     *
     * @param container The AtomContainer to
     *                  be searched
     * @param sphere    A sphere of atoms to
     *                  start the search with
     * @param path      An array list which stores the atoms belonging to the pi system
     * @throws org.openscience.cdk.exception.CDKException
     *          Description of the
     *          Exception
     */",224-266,"('breadthFirstSearch', {'INSTRUCTION': {'covered': 102, 'missed': 0}, 'BRANCH': {'covered': 21, 'missed': 1}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 11, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",226.0,27.0,"Performs a breadthFirstSearch in an AtomContainer starting with a  particular sphere, which usually consists of one start atom, and searches  for a pi system.","Given a sphere of atoms and the AtomCointainer to be searched, performs a breadthFirstSearch in an AtomContainer.",A search for a pi system is performed in an atom container with a particular sphere and one start atom.,0.715066019209441,"Performs a breadthFirstSearch in an AtomContainer starting with a particular sphere, which usually consists of a starting atom, and looks for a pi system."
609,jeromq,"public Object[] recvPicture(Socket socket, String picture){
    if (!FORMAT.matcher(picture).matches()) {
        throw new ZMQException(picture + "" is not in expected format "" + FORMAT.pattern(), ZError.EPROTO);
    }
    Object[] elements = new Object[picture.length()];
    for (int index = 0; index < picture.length(); index++) {
        char pattern = picture.charAt(index);
        switch(pattern) {
            case 'i':
                {
                    elements[index] = Integer.valueOf(socket.recvStr());
                    break;
                }
            case '1':
                {
                    elements[index] = (0xff) & Integer.valueOf(socket.recvStr());
                    break;
                }
            case '2':
                {
                    elements[index] = (0xffff) & Integer.valueOf(socket.recvStr());
                    break;
                }
            case '4':
                {
                    elements[index] = (0xffffffff) & Integer.valueOf(socket.recvStr());
                    break;
                }
            case '8':
                {
                    elements[index] = Long.valueOf(socket.recvStr());
                    break;
                }
            case 's':
                {
                    elements[index] = socket.recvStr();
                    break;
                }
            case 'b':
            case 'c':
                {
                    elements[index] = socket.recv();
                    break;
                }
            case 'f':
                {
                    elements[index] = ZFrame.recvFrame(socket);
                    break;
                }
            case 'm':
                {
                    elements[index] = ZMsg.recvMsg(socket);
                    break;
                }
            case 'z':
                {
                    ZFrame zeroFrame = ZFrame.recvFrame(socket);
                    if (zeroFrame == null || zeroFrame.size() > 0) {
                        throw new ZMQException(""zero frame is not empty"", ZError.EPROTO);
                    }
                    elements[index] = new ZFrame((byte[]) null);
                    break;
                }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    return elements;
}",recvPicture,org/zeromq/proto/ZPicture.java,/src/main/java/org/zeromq/proto/ZPicture.java,"/**
     * Receive a 'picture' message to the socket (or actor).
     *
     *
     * @param picture The picture is a string that defines the type of each frame.
     *                This makes it easy to recv a complex multiframe message in
     *                one call. The picture can contain any of these characters,
     *                each corresponding to zero or one elements in the result:
     *
     *                <table>
     *               <caption> </caption>
     *                <tr><td>i = int (stores signed integer)</td></tr>
     *                <tr><td>1 = int (stores 8-bit unsigned integer)</td></tr>
     *                <tr><td>2 = int (stores 16-bit unsigned integer)</td></tr>
     *                <tr><td>4 = long (stores 32-bit unsigned integer)</td></tr>
     *                <tr><td>8 = long (stores 64-bit unsigned integer)</td></tr>
     *                <tr><td>s = String</td></tr>
     *                <tr><td>b = byte[]</td></tr>
     *                <tr><td>f = ZFrame (creates zframe)</td></tr>
     *                <tr><td>m = ZMsg (creates a zmsg with the remaing frames)</td></tr>
     *                <tr><td>z = null, asserts empty frame (0 arguments)</td></tr>
     *                </table>
     *
     *                Also see {@link #sendPicture(Socket, String, Object...)} how to send a
     *                multiframe picture.
     *
     * @return the picture elements as object array
     */",341-430,"('recvPicture', {'INSTRUCTION': {'covered': 129, 'missed': 22}, 'BRANCH': {'covered': 16, 'missed': 5}, 'LINE': {'covered': 29, 'missed': 2}, 'COMPLEXITY': {'covered': 12, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",380.0,13.0,Receive a 'picture' message to the socket (or actor).,A picture is received through the socket. The picture is represented as a string that defines the type of each frame.,Receive a picture message to the actor.,0.150573398064978,"Receive an ""image"" message on the socket (or actor)."
610,cdk,"private static boolean isIllPosed(double minMass, double maxMass, MolecularFormulaRange mfRange){
    // when the number of integers to decompose is incredible large
    // we have to adjust the internal settings (e.g. precision!)
    // instead we simply fallback to the full enumeration method
    if (maxMass - minMass >= 1)
        return true;
    if (maxMass > 400000)
        return true;
    // if the number of elements to decompose is very small
    // we fall back to the full enumeration methods as the
    // minimal decomposable mass of a certain residue class might
    // exceed the 32 bit integer space
    if (mfRange.getIsotopeCount() <= 2)
        return true;
    // if the mass of the smallest element in alphabet is large
    // it is more efficient to use the full enumeration method
    double smallestMass = Double.POSITIVE_INFINITY;
    for (IIsotope i : mfRange.isotopes()) {
        smallestMass = Math.min(smallestMass, i.getExactMass());
    }
    return smallestMass > 5;
}",isIllPosed,org/openscience/cdk/formula/MolecularFormulaGenerator.java,/tool/formula/src/main/java/org/openscience/cdk/formula/MolecularFormulaGenerator.java,"/**
     * Decides wheter to use the round robin algorithm or full enumeration algorithm.
     * The round robin implementation here is optimized for chemical elements in organic compounds. It gets slow
     * if
     * - the mass of the smallest element is very large (i.e. hydrogen is not allowed)
     * - the maximal mass to decompose is too large (round robin always decomposes integers. Therefore, the mass have
     *   to be small enough to be represented as 32 bit integer)
     * - the number of elements in the set is extremely small (in this case, however, the problem becomes trivial anyways)
     *
     * In theory we could handle these problems by optimizing the way DECOMP discretizes the masses. However, it's easier
     * to just fall back to the full enumeration method if a problem occurs (especially, because most of the problems
     * lead to trivial cases that are fast to compute).
     *
     * @return true if the problem is ill-posed (i.e. should be calculated by full enumeration method)
     */",79-114,"('isIllPosed', {'INSTRUCTION': {'covered': 46, 'missed': 2}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",89.0,13.0,Decides wheter to use the round robin algorithm or full enumeration algorithm.,"Return true if the number of elements to decompose is very small. In that case, the full enumeration algorithm will be used. Otherwise, returns false (the round robin algorithm will be used).",The round robin or full enumeration algorithm was the one that was decided on.,0.490103998132113,Decides to use the round robin algorithm or the full enumeration algorithm.
612,weblogic-kubernetes-operator,"public DomainStatus addCondition(DomainCondition newCondition){
    if (conditions.contains(newCondition)) {
        return this;
    }
    conditions = conditions.stream().filter(c -> preserve(c, newCondition.getType())).collect(Collectors.toList());
    conditions.add(newCondition);
    reason = newCondition.getStatusReason();
    message = newCondition.getStatusMessage();
    return this;
}",addCondition,oracle/kubernetes/weblogic/domain/model/DomainStatus.java,/operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainStatus.java,"/**
   * Adds a condition to the status, replacing any existing conditions with the same type, and removing other
   * conditions according to the domain rules.
   *
   * @param newCondition the condition to add.
   * @return this object.
   */",116-134,"('addCondition', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",82.0,26.0,"Adds a condition to the status, replacing any existing conditions with the same type, and removing other  conditions according to the domain rules.","Using the domain rules specification, adds a condition to the status and replaces any existing condition with the same  type while removing all the rest.","Adding a condition to the status, replacing any existing conditions with the same type, and removing other conditions according to the domain rules are all done this way.",0.500398196675479,"Adds a condition to the report, replaces all existing conditions with the same type, and removes other conditions based on domain rules."
613,cdk,"public String toCycleString(){
    int n = this.values.length;
    boolean[] p = new boolean[n];
    Arrays.fill(p, true);
    StringBuilder sb = new StringBuilder();
    int j = 0;
    for (int i = 0; i < n; i++) {
        if (p[i]) {
            sb.append('(');
            sb.append(i);
            p[i] = false;
            j = i;
            while (p[values[j]]) {
                sb.append("", "");
                j = values[j];
                sb.append(j);
                p[j] = false;
            }
            sb.append(')');
        }
    }
    return sb.toString();
}",toCycleString,org/openscience/cdk/group/Permutation.java,/tool/group/src/main/java/org/openscience/cdk/group/Permutation.java,"/**
     * An easily-readable version of the permutation as a product of cycles.
     *
     * @return the cycle form of the permutation as a string
     */",225-253,"('toCycleString', {'INSTRUCTION': {'covered': 73, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",153.0,12.0,An easily-readable version of the permutation as a product of cycles.,This method represents an enhanced version (readability-wise) of the permutation as a product of cycles.,The permutation is a product of cycles.,0.196538138034416,An easily readable version of swapping as a product of cycles.
614,matsim-libs,"public void applyConfiguration(Config config) throws ConfigurationException{
    List<String> configOptions = options.keySet().stream().filter(o -> o.startsWith(CONFIG_PREFIX + "":"")).collect(Collectors.toList());
    for (String option : configOptions) {
        processConfigOption(config, option, option.substring(CONFIG_PREFIX.length() + 1));
    }
}",applyConfiguration,org/matsim/core/config/CommandLine.java,/matsim/src/main/java/org/matsim/core/config/CommandLine.java,"/**
	 * Applies the command line configuration to a MATSim {@link Config} instance.
	 * See {@link CommandLine} for more information on the syntax.
	 * 
	 * @throws ConfigurationException
	 */",485-498,"('applyConfiguration', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",79.0,15.0,Applies the command line configuration to a MATSim {@link Config} instance.,The command line configuration is applied to the MATSim Instance.,The command line configuration can be applied to a MATSim.,0.76151875377528,Applies command-line configuration to a MATSim instance {@link Config}.
615,cdk,"private static int[] labels(int flavour, final IAtomContainer molecule) throws CDKException{
    long[] labels = SmiFlavor.isSet(flavour, SmiFlavor.Isomeric) ? inchiNumbers(molecule) : Canon.label(molecule, GraphUtil.toAdjList(molecule), createComparator(molecule, flavour));
    int[] cpy = new int[labels.length];
    for (int i = 0; i < labels.length; i++) cpy[i] = (int) labels[i] - 1;
    return cpy;
}",labels,org/openscience/cdk/smiles/SmilesGenerator.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/SmilesGenerator.java,"/**
     * Given a molecule (possibly disconnected) compute the labels which
     * would order the atoms by increasing canonical labelling. If the SMILES
     * are isomeric (i.e. stereo and isotope specific) the InChI numbers are
     * used. These numbers are loaded via reflection and the 'cdk-inchi' module
     * should be present on the classpath.
     *
     * @param molecule the molecule to
     * @return the permutation
     * @see Canon
     */",668-689,"('labels', {'INSTRUCTION': {'covered': 35, 'missed': 3}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",107.0,20.0,Given a molecule (possibly disconnected) compute the labels which  would order the atoms by increasing canonical labelling.,Computes the label of a molecule.This will result in ordering the atoms by increasing canonical labeling.,"If a molecule is disconnected, you can use the labels to order the atoms.",0.267162395519844,"Given a molecule (possibly disconnected), calculate the labels that would order the atoms by increasing the canonical labeling."
616,cdk,"private void addDoubleBondStereochemistry(Graph g, IAtomContainer ac){
    for (final Edge e : g.edges()) {
        if (e.bond() != Bond.DOUBLE)
            continue;
        int u = e.either();
        int v = e.other(u);
        Edge first = null;
        Edge second = null;
        if ((first = findDirectionalEdge(g, u)) != null) {
            if ((second = findDirectionalEdge(g, v)) != null) {
                Conformation conformation = first.bond(u) == second.bond(v) ? Conformation.TOGETHER : Conformation.OPPOSITE;
                IBond db = ac.getBond(ac.getAtom(u), ac.getAtom(v));
                IBond[] ligands = new IBond[] { ac.getBond(ac.getAtom(u), ac.getAtom(first.other(u))), ac.getBond(ac.getAtom(v), ac.getAtom(second.other(v))) };
                ac.addStereoElement(new DoubleBondStereochemistry(db, ligands, conformation));
            } else if (g.degree(v) == 2) {
                List<Edge> edges = new ArrayList<>();
                edges.add(e);
                Edge f = findCumulatedEdge(g, v, e);
                int beg = v;
                while (f != null) {
                    edges.add(f);
                    v = f.other(v);
                    f = findCumulatedEdge(g, v, f);
                    if (beg == v) {
                        beg = -1;
                        break;
                    }
                }
                if (beg < 0)
                    continue;
                if ((edges.size() & 0x1) == 0)
                    continue;
                second = findDirectionalEdge(g, v);
                if (second != null) {
                    int cfg = first.bond(u) == second.bond(v) ? IStereoElement.TOGETHER : IStereoElement.OPPOSITE;
                    Edge middleEdge = edges.get(edges.size() / 2);
                    IBond middleBond = ac.getBond(ac.getAtom(middleEdge.either()), ac.getAtom(middleEdge.other(middleEdge.either())));
                    IBond[] ligands = new IBond[] { ac.getBond(ac.getAtom(u), ac.getAtom(first.other(u))), ac.getBond(ac.getAtom(v), ac.getAtom(second.other(v))) };
                    ac.addStereoElement(new ExtendedCisTrans(middleBond, ligands, cfg));
                }
            }
        } else {
            Configuration uConf = g.configurationOf(u);
            Configuration vConf = g.configurationOf(v);
            if (uConf.type() == Configuration.Type.DoubleBond && vConf.type() == Configuration.Type.DoubleBond) {
                int[] nbrs = new int[6];
                int[] uNbrs = g.neighbors(u);
                int[] vNbrs = g.neighbors(v);
                if (uNbrs.length < 2 || uNbrs.length > 3)
                    continue;
                if (vNbrs.length < 2 || vNbrs.length > 3)
                    continue;
                int idx = 0;
                System.arraycopy(uNbrs, 0, nbrs, idx, uNbrs.length);
                idx += uNbrs.length;
                if (uNbrs.length == 2)
                    nbrs[idx++] = u;
                System.arraycopy(vNbrs, 0, nbrs, idx, vNbrs.length);
                idx += vNbrs.length;
                if (vNbrs.length == 2)
                    nbrs[idx] = v;
                Arrays.sort(nbrs, 0, 3);
                Arrays.sort(nbrs, 3, 6);
                int vPos = Arrays.binarySearch(nbrs, 0, 3, v);
                int uPos = Arrays.binarySearch(nbrs, 3, 6, u);
                int uhi = 0, ulo = 0;
                int vhi = 0, vlo = 0;
                uhi = nbrs[(vPos + 1) % 3];
                ulo = nbrs[(vPos + 2) % 3];
                vhi = nbrs[3 + ((uPos + 1) % 3)];
                vlo = nbrs[3 + ((uPos + 2) % 3)];
                if (uConf.shorthand() == Configuration.CLOCKWISE) {
                    int tmp = uhi;
                    uhi = ulo;
                    ulo = tmp;
                }
                if (vConf.shorthand() == Configuration.ANTI_CLOCKWISE) {
                    int tmp = vhi;
                    vhi = vlo;
                    vlo = tmp;
                }
                DoubleBondStereochemistry.Conformation conf = null;
                IBond[] bonds = new IBond[2];
                if (uhi != u) {
                    bonds[0] = ac.getBond(ac.getAtom(u), ac.getAtom(uhi));
                    if (vhi != v) {
                        conf = Conformation.TOGETHER;
                        bonds[1] = ac.getBond(ac.getAtom(v), ac.getAtom(vhi));
                    } else if (vlo != v) {
                        conf = Conformation.OPPOSITE;
                        bonds[1] = ac.getBond(ac.getAtom(v), ac.getAtom(vlo));
                    }
                } else if (ulo != u) {
                    bonds[0] = ac.getBond(ac.getAtom(u), ac.getAtom(ulo));
                    if (vhi != v) {
                        conf = Conformation.OPPOSITE;
                        bonds[1] = ac.getBond(ac.getAtom(v), ac.getAtom(vhi));
                    } else if (vlo != v) {
                        conf = Conformation.TOGETHER;
                        bonds[1] = ac.getBond(ac.getAtom(v), ac.getAtom(vlo));
                    }
                }
                ac.addStereoElement(new DoubleBondStereochemistry(ac.getBond(ac.getAtom(u), ac.getAtom(v)), bonds, conf));
            }
        }
    }
}",addDoubleBondStereochemistry,org/openscience/cdk/smiles/BeamToCDK.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/BeamToCDK.java,"/**
     * Adds double-bond conformations ({@link DoubleBondStereochemistry}) to the
     * atom-container.
     *
     * @param g  Beam graph object (for directional bonds)
     * @param ac The atom-container built from the Beam graph
     */",258-417,"('addDoubleBondStereochemistry', {'INSTRUCTION': {'covered': 515, 'missed': 2}, 'BRANCH': {'covered': 46, 'missed': 10}, 'LINE': {'covered': 99, 'missed': 2}, 'COMPLEXITY': {'covered': 19, 'missed': 10}, 'METHOD': {'covered': 1, 'missed': 0}})",1171.0,14.0,Adds double-bond conformations ({@link DoubleBondStereochemistry}) to the  atom-container.,The atom-container is enriched with double-bond conformations information.,Adds double-bonds to the atom-container.,0.533614233301549,Adds double-bonded conformations ({@link DoubleBondStereochemistry}) to the atom container.
617,cdk,"public void previsit(Collection<? extends IRenderingElement> elements){
    Deque<IRenderingElement> queue = new ArrayDeque<>(2 * elements.size());
    queue.addAll(elements);
    FreqMap<Color> strokeFreq = new FreqMap<>();
    FreqMap<Color> fillFreq = new FreqMap<>();
    FreqMap<Double> strokeWidthFreq = new FreqMap<>();
    while (!queue.isEmpty()) {
        IRenderingElement element = queue.poll();
        // wrappers first
        if (element instanceof Bounds) {
            queue.add(((Bounds) element).root());
        } else if (element instanceof MarkedElement) {
            queue.add(((MarkedElement) element).element());
        } else if (element instanceof ElementGroup) {
            for (IRenderingElement child : (ElementGroup) element) queue.add(child);
        } else if (element instanceof LineElement) {
            strokeFreq.add(((LineElement) element).color);
            strokeWidthFreq.add(scaled(((LineElement) element).width));
        } else if (element instanceof GeneralPath) {
            if (((GeneralPath) element).fill)
                fillFreq.add(((GeneralPath) element).color);
        } else {
            // ignored
        }
    }
    if (!defaultsWritten) {
        defaultFill = fillFreq.getMostFrequent();
        defaultStroke = strokeFreq.getMostFrequent();
        Double strokeWidth = strokeWidthFreq.getMostFrequent();
        if (strokeWidth != null)
            defaultStrokeWidth = toStr(strokeWidth);
    }
}",previsit,org/openscience/cdk/depict/SvgDrawVisitor.java,/app/depict/src/main/java/org/openscience/cdk/depict/SvgDrawVisitor.java,"/**
     * Pre-visit allows us to prepare the visitor for more optimal output.
     * Currently we
     * - find the most common stoke/fill/stroke-width values and set these as defaults
     *
     * @param elements elements to be visited
     */",215-258,"('previsit', {'INSTRUCTION': {'covered': 127, 'missed': 0}, 'BRANCH': {'covered': 16, 'missed': 4}, 'LINE': {'covered': 28, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",297.0,12.0,Pre-visit allows us to prepare the visitor for more optimal output.,Improves the output by implementing an ad-hoc previsit strategy for the visitor.,Pre-visit allows us to prepare the visitor for more.,0.543733127241395,The pre-visit allows us to prepare the visitor for a more optimal performance.
618,matsim-libs,"private boolean eitherLinkIsShorterThanThreshold(Link linkA, Link linkB, double thresholdLength){
    boolean hasShortLink = false;
    if (linkA.getLength() < thresholdLength || linkB.getLength() < thresholdLength) {
        hasShortLink = true;
    }
    return hasShortLink;
}",eitherLinkIsShorterThanThreshold,org/matsim/core/network/algorithms/NetworkSimplifier.java,/matsim/src/main/java/org/matsim/core/network/algorithms/NetworkSimplifier.java,"/**
	 * Quick check to see whether <i>either</i> the links are shorter than the 
	 * given threshold.
	 * @param linkA
	 * @param linkB
	 * @param thresholdLength
	 * @return true if <i>either</i> links are shorter than the given threshold, 
	 * false otherwise. 
	 */",310-325,"('eitherLinkIsShorterThanThreshold', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,21.0,Quick check to see whether <i>either</i> the links are shorter than the   given threshold.,Checks the length of the <i> either </i> links by comparing these with a given threshold.,Check to see if the links are shorter than the threshold.,0.257368532855515,Quickly check <i>if the</i> links are shorter than the given threshold.
619,cdk,"private boolean map(){
    if ((n == state.nMax() || m == state.mMax()) && !stack.empty())
        state.remove(n = stack.popN(), m = stack.popM());
    while ((m = state.nextM(n, m)) < state.mMax()) {
        if (state.add(n, m)) {
            stack.push(n, m);
            n = state.nextN(-1);
            m = -1;
            return n < state.nMax();
        }
    }
    return state.size() > 0 || m < state.mMax();
}",map,org/openscience/cdk/isomorphism/StateStream.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StateStream.java,"/**
     * Progress the state-machine - the function return false when a mapping is
     * found on the mapping is done.
     *
     * @return the state is partial
     */",95-117,"('map', {'INSTRUCTION': {'covered': 93, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",141.0,19.0,Progress the state-machine - the function return false when a mapping is  found on the mapping is done.,Returns true whether the size of the state is greater than 0 or the state is completed.,"When a mapping is done, the function return false.",0.263734048420747,Advance the state machine - the function returns false when a mapping is found on the mapping is performed.
620,cdk,"private static boolean has3DCoordinates(List<IBond> bonds){
    for (IBond bond : bonds) {
        if (bond.getBegin().getPoint3d() == null || bond.getEnd().getPoint3d() == null)
            return false;
    }
    return true;
}",has3DCoordinates,org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,"/**
     * Check if all atoms in the bond list have 3D coordinates. There is some
     * redundant checking but the list will typically be short.
     *
     * @param bonds the bonds to check
     * @return whether all atoms have 2D coordinates
     */",306-318,"('has3DCoordinates', {'INSTRUCTION': {'covered': 21, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,12.0,Check if all atoms in the bond list have 3D coordinates.,Checks whether all the atoms in the bond list have 3D coordinates.,"If all the atoms in the bond list have 3D coordinates, you should check them.",0.245116276778342,Check if all the atoms in the list of bonds have 3D coordinates.
621,dcache,"private boolean hasAuthorisationSubsumedBy(Authorisation other){
    EnumSet<Activity> disallowedOtherActivities = EnumSet.complementOf(other.activities);
    return authorisations.stream().anyMatch(ap -> disallowedOtherActivities.containsAll(EnumSet.complementOf(ap.activities)) && other.getPath().hasPrefix(ap.getPath()));
}",hasAuthorisationSubsumedBy,org/dcache/auth/attributes/MultiTargetedRestriction.java,/modules/common/src/main/java/org/dcache/auth/attributes/MultiTargetedRestriction.java,"/**
     * Return true iff this restriction has an Authorisation that is subsumed by other.
     */",176-185,"('hasAuthorisationSubsumedBy', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,14.0,Return true iff this restriction has an Authorisation that is subsumed by other.,Returns false when the current restriction does not have Authorisation subsumed by others.,Return true if the restriction has an Authorisation subsumed by other.,1.0002962127686,Return true if this restriction has a permission that is subsumed by others.
622,cdk,"private static List<String> extractInfo(String str){
    int beg = 0;
    int end = 0;
    int len = str.length();
    List<String> parts = new ArrayList<>();
    while (end < len && !Character.isSpaceChar(str.charAt(end))) end++;
    parts.add(str.substring(beg, end));
    while (end < len && Character.isSpaceChar(str.charAt(end))) end++;
    beg = end;
    while (end < len && !Character.isSpaceChar(str.charAt(end))) end++;
    parts.add(str.substring(beg, end));
    return parts;
}",extractInfo,org/openscience/cdk/qsar/descriptors/atomic/ProtonAffinityHOSEDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/ProtonAffinityHOSEDescriptor.java,"/**
     * Extract the information from a line which contains HOSE_ID & energy.
     *
     * @param str  String with the information
     * @return     List with String = HOSECode and String = energy
     */",307-328,"('extractInfo', {'INSTRUCTION': {'covered': 59, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",145.0,12.0,Extract the information from a line which contains HOSE_ID & energy.,Retrieve the needed information from all those lines containing HOSE_ID and energy.,The information is contained in a line.,0.172731220973627,Extract information from a line that contains HOSE_ID and energy.
623,mybatis-3,"public static void addImplClass(Class<? extends VFS> clazz){
    if (clazz != null) {
        USER_IMPLEMENTATIONS.add(clazz);
    }
}",addImplClass,org/apache/ibatis/io/VFS.java,/src/main/java/org/apache/ibatis/io/VFS.java,"/**
   * Adds the specified class to the list of {@link VFS} implementations. Classes added in this
   * manner are tried in the order they are added and before any of the built-in implementations.
   *
   * @param clazz The {@link VFS} implementation class to add.
   */",91-101,"('addImplClass', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,15.0,Adds the specified class to the list of {@link VFS} implementations.,A new class is added to the list of {@link VFS} implementations.,The specified class is added to the list of VFS implementations.,0.513934578911856,Adds the specified class to the list of implementations {@link VFS}.
624,cdk,"public List<IAtomType> possibleAtomTypes(IAtomContainer atomContainer, IAtom atom) throws CDKException{
    if (factory == null) {
        try {
            factory = AtomTypeFactory.getInstance(""org/openscience/cdk/config/data/structgen_atomtypes.xml"", atom.getBuilder());
        } catch (Exception ex1) {
            logger.error(ex1.getMessage());
            logger.debug(ex1);
            throw new CDKException(""Could not instantiate the AtomType list!"", ex1);
        }
    }
    double bondOrderSum = atomContainer.getBondOrderSum(atom);
    IBond.Order maxBondOrder = atomContainer.getMaximumBondOrder(atom);
    int charge = atom.getFormalCharge();
    int hcount = atom.getImplicitHydrogenCount();
    List<IAtomType> matchingTypes = new ArrayList<IAtomType>();
    IAtomType[] types = factory.getAtomTypes(atom.getSymbol());
    for (IAtomType type : types) {
        logger.debug(""   ... matching atom "", atom, "" vs "", type);
        if (bondOrderSum - charge + hcount <= type.getBondOrderSum() && !BondManipulator.isHigherOrder(maxBondOrder, type.getMaxBondOrder())) {
            matchingTypes.add(type);
        }
    }
    logger.debug(""    No Match"");
    return matchingTypes;
}",possibleAtomTypes,org/openscience/cdk/atomtype/StructGenAtomTypeGuesser.java,/tool/structgen/src/main/java/org/openscience/cdk/atomtype/StructGenAtomTypeGuesser.java,"/**
     * Finds the AtomType matching the Atom's element symbol, formal charge and
     * hybridization state.
     *
     * @param  atomContainer  AtomContainer
     * @param  atom            the target atom
     * @exception CDKException Exception thrown if something goes wrong
     * @return                 the matching AtomType
     */",57-96,"('possibleAtomTypes', {'INSTRUCTION': {'covered': 92, 'missed': 14}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 17, 'missed': 4}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",216.0,16.0,"Finds the AtomType matching the Atom's element symbol, formal charge and  hybridization state.","Given an Atom as input, checks whether the AtomType matches the Atom's element symbol. Returns the matches AtomType","The Atom's element symbol, formal charge and hybridization state are found by this.",0.339592057858739,"Finds the AtomType corresponding to the element symbol, formal load, and hybridization state of the Atom."
625,cdk,"public double resolveOverlap(IAtomContainer ac, IRingSet sssr){
    Vector overlappingAtoms = new Vector();
    Vector overlappingBonds = new Vector();
    logger.debug(""Start of resolveOverlap"");
    double overlapScore = getOverlapScore(ac, overlappingAtoms, overlappingBonds);
    if (overlapScore > 0) {
        overlapScore = displace(ac, overlappingAtoms, overlappingBonds);
    }
    logger.debug(""overlapScore = "" + overlapScore);
    logger.debug(""End of resolveOverlap"");
    return overlapScore;
}",resolveOverlap,org/openscience/cdk/layout/OverlapResolver.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/OverlapResolver.java,"/**
     * Main method to be called to resolve overlap situations.
     *
     * @param  ac    The atomcontainer in which the atom or bond overlap exists
     * @param  sssr  A ring set for this atom container if one exists, otherwhise null
     */",63-81,"('resolveOverlap', {'INSTRUCTION': {'covered': 42, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",85.0,10.0,Main method to be called to resolve overlap situations.,"In case of overlap, call the main method to resolve such an overlap.",The main method to resolve overlap situations is called.,1.37656541704012,The primary method to call to resolve overlap situations.
626,cdk,"private IsotopePattern cleanAbundance(IsotopePattern isopattern, double minIntensity){
    double intensity, biggestIntensity = 0.0f;
    for (IsotopeContainer sc : isopattern.getIsotopes()) {
        intensity = sc.getIntensity();
        if (intensity > biggestIntensity)
            biggestIntensity = intensity;
    }
    for (IsotopeContainer sc : isopattern.getIsotopes()) {
        intensity = sc.getIntensity();
        intensity /= biggestIntensity;
        if (intensity < 0)
            intensity = 0;
        sc.setIntensity(intensity);
    }
    IsotopePattern sortedIsoPattern = new IsotopePattern();
    sortedIsoPattern.setMonoIsotope(new IsotopeContainer(isopattern.getIsotopes().get(0)));
    for (int i = 1; i < isopattern.getNumberOfIsotopes(); i++) {
        if (isopattern.getIsotopes().get(i).getIntensity() >= (minIntensity)) {
            IsotopeContainer container = new IsotopeContainer(isopattern.getIsotopes().get(i));
            sortedIsoPattern.addIsotope(container);
        }
    }
    return sortedIsoPattern;
}",cleanAbundance,org/openscience/cdk/formula/IsotopePatternGenerator.java,/tool/formula/src/main/java/org/openscience/cdk/formula/IsotopePatternGenerator.java,"/**
     * Normalize the intensity (relative abundance) of all isotopes in relation
     * of the most abundant isotope.
     *
     * @param isopattern   The IsotopePattern object
     * @param minIntensity The minimum abundance
     * @return             The IsotopePattern cleaned
     */",254-292,"('cleanAbundance', {'INSTRUCTION': {'covered': 94, 'missed': 2}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",191.0,18.0,Normalize the intensity (relative abundance) of all isotopes in relation  of the most abundant isotope.,The most abundant isotope is used to normalize the intensity of all the isotopes.,Normalize the intensity of all the isotopes in relation to the most abundant.,1.13532177420255,Normalize the intensity (relative abundance) of all isotopes relative to the most abundant isotope.
627,cdk,"public static Model molecule2Model(IAtomContainer molecule){
    Model model = createCDKModel();
    Resource subject = model.createResource(createIdentifier(model, molecule));
    model.add(subject, RDF.type, CDK.MOLECULE);
    Map<IAtom, Resource> cdkToRDFAtomMap = new HashMap<IAtom, Resource>();
    for (IAtom atom : molecule.atoms()) {
        Resource rdfAtom = model.createResource(createIdentifier(model, atom));
        cdkToRDFAtomMap.put(atom, rdfAtom);
        model.add(subject, CDK.HASATOM, rdfAtom);
        if (atom instanceof IPseudoAtom) {
            model.add(rdfAtom, RDF.type, CDK.PSEUDOATOM);
            serializePseudoAtomFields(model, rdfAtom, (IPseudoAtom) atom);
        } else {
            model.add(rdfAtom, RDF.type, CDK.ATOM);
            serializeAtomFields(model, rdfAtom, atom);
        }
    }
    for (IBond bond : molecule.bonds()) {
        Resource rdfBond = model.createResource(createIdentifier(model, bond));
        model.add(rdfBond, RDF.type, CDK.BOND);
        for (IAtom atom : bond.atoms()) {
            model.add(rdfBond, CDK.BINDSATOM, cdkToRDFAtomMap.get(atom));
        }
        if (bond.getOrder() != null) {
            model.add(rdfBond, CDK.HASORDER, order2Resource(bond.getOrder()));
        }
        model.add(subject, CDK.HASBOND, rdfBond);
        serializeElectronContainerFields(model, rdfBond, bond);
    }
    return model;
}",molecule2Model,org/openscience/cdk/libio/jena/Convertor.java,/storage/iordf/src/main/java/org/openscience/cdk/libio/jena/Convertor.java,"/**
     * Converts a {@link IAtomContainer} into a {@link Model} representation using the CDK OWL.
     *
     * @param molecule {@link IAtomContainer} to serialize into a RDF graph.
     * @return the RDF graph representing the {@link IAtomContainer}.
     */",65-101,"('molecule2Model', {'INSTRUCTION': {'covered': 140, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 26, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",308.0,20.0,Converts a {@link IAtomContainer} into a {@link Model} representation using the CDK OWL.,"By using the CDK OWL representation, translates a {@link IAtomContainer} to a {@link Model}.",The CDK OWL is used to convert a @link IAtomContainer into a @link Model representation.,0.935437543989431,Converts an {@link IAtomContainer} to a {@link Model} representation using the OWL CDK.
628,dcache,"public P selectByAvailableSpace(List<P> pools, long filesize, Function<P, PoolCostInfo> getCost){
    int length = pools.size();
    double[] available = new double[length];
    double minLoad = Double.POSITIVE_INFINITY;
    for (int i = 0; i < length; i++) {
        PoolCostInfo info = getCost.apply(pools.get(i));
        double free = getAvailable(info.getSpaceInfo(), filesize);
        if (free > 0) {
            available[i] = free;
            minLoad = Math.min(minLoad, getLoad(info));
        }
    }
    if (minLoad == Double.POSITIVE_INFINITY) {
        return null;
    }
    double sum = 0.0;
    for (int i = 0; i < length; i++) {
        PoolCostInfo info = getCost.apply(pools.get(i));
        double normalizedLoad = getLoad(info) - minLoad;
        double weightedAvailable = getWeightedAvailable(info, available[i], normalizedLoad);
        sum += weightedAvailable;
        available[i] = sum;
    }
    double threshold = random() * sum;
    for (int i = 0; i < length; i++) {
        if (threshold < available[i]) {
            return pools.get(i);
        }
    }
    if (sum == Double.POSITIVE_INFINITY) {
        throw new IllegalStateException(""WASS overflow: Configured space cost factor ("" + spaceCostFactor + "") is too large."");
    }
    throw new RuntimeException(""Unreachable statement."");
}",selectByAvailableSpace,org/dcache/poolmanager/WeightedAvailableSpaceSelection.java,/modules/dcache/src/main/java/org/dcache/poolmanager/WeightedAvailableSpaceSelection.java,"/**
     * Selects a pool from a list using the WASS algorithm.
     * <p/>
     * Returns null if all pools are full.
     */",216-271,"('selectByAvailableSpace', {'INSTRUCTION': {'covered': 108, 'missed': 16}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 22, 'missed': 3}, 'COMPLEXITY': {'covered': 6, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",281.0,11.0,Selects a pool from a list using the WASS algorithm.,Uses the WASS algorithm to pick a pool from the list of pools given as input.,The WASS algorithm is used to select a pool.,0.726843314238114,Selects a pool from a list using the WASS algorithm.
629,jeromq,"public long timeout(){
    final long now = now();
    for (Entry<Timer, Long> entry : entries()) {
        final Timer timer = entry.getKey();
        final Long expiration = entry.getValue();
        if (timer.alive) {
            if (expiration - now > 0) {
                return expiration - now;
            } else {
                return 0;
            }
        }
        timers.remove(expiration, timer);
    }
    return -1;
}",timeout,zmq/util/Timers.java,/src/main/java/zmq/util/Timers.java,"/**
     * Returns the time in millisecond until the next timer.
     * @return the time in millisecond until the next timer.
     */",173-199,"('timeout', {'INSTRUCTION': {'covered': 41, 'missed': 7}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 2}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",93.0,10.0,Returns the time in millisecond until the next timer.,The timeout duration is returned in millisecond.,The time is returned in a second.,0.214134626518953,Returns the time in milliseconds to the next timer.
630,dcache,"public boolean equals(Object otherObject){
    if (!(otherObject instanceof StatePath)) {
        return false;
    }
    if (otherObject == this) {
        return true;
    }
    StatePath otherPath = (StatePath) otherObject;
    if (otherPath._elements.size() != _elements.size()) {
        return false;
    }
    for (int i = 0; i < _elements.size(); i++) {
        if (otherPath._elements.get(i) != _elements.get(i)) {
            return false;
        }
    }
    return true;
}",equals,org/dcache/services/info/base/StatePath.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StatePath.java,"/**
     * Check whether another path points to the same location.
     *
     * @param otherPath: the other path to compare
     * @return: whether the other path point to the same location.
     */",135-165,"('equals', {'INSTRUCTION': {'covered': 44, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",109.0,10.0,Check whether another path points to the same location.,"Returns true if the path points to the same location, false otherwise.","If another path points to the same location, check it.",0.339326755688063,Check if another path points to the same location.
631,cdk,"private static void arcConstructor(CDKRGraph graph, IAtomContainer ac1, IAtomContainer ac2) throws CDKException{
    for (int i = 0; i < graph.getGraph().size(); i++) {
        CDKRNode rNodeX = graph.getGraph().get(i);
        rNodeX.getForbidden().set(i);
    }
    IBond bondA1;
    IBond bondA2;
    IBond bondB1;
    IBond bondB2;
    graph.setFirstGraphSize(ac1.getBondCount());
    graph.setSecondGraphSize(ac2.getBondCount());
    for (int i = 0; i < graph.getGraph().size(); i++) {
        CDKRNode rNodeX = graph.getGraph().get(i);
        for (int j = i + 1; j < graph.getGraph().size(); j++) {
            CDKRNode rNodeY = graph.getGraph().get(j);
            bondA1 = ac1.getBond(graph.getGraph().get(i).getRMap().getId1());
            bondA2 = ac2.getBond(graph.getGraph().get(i).getRMap().getId2());
            bondB1 = ac1.getBond(graph.getGraph().get(j).getRMap().getId1());
            bondB2 = ac2.getBond(graph.getGraph().get(j).getRMap().getId2());
            if (bondA2 instanceof IQueryBond) {
                if (bondA1.equals(bondB1) || bondA2.equals(bondB2) || !queryAdjacencyAndOrder(bondA1, bondB1, bondA2, bondB2)) {
                    rNodeX.getForbidden().set(j);
                    rNodeY.getForbidden().set(i);
                } else if (hasCommonAtom(bondA1, bondB1)) {
                    rNodeX.getExtension().set(j);
                    rNodeY.getExtension().set(i);
                }
            } else {
                if (bondA1.equals(bondB1) || bondA2.equals(bondB2) || (!getCommonSymbol(bondA1, bondB1).equals(getCommonSymbol(bondA2, bondB2)))) {
                    rNodeX.getForbidden().set(j);
                    rNodeY.getForbidden().set(i);
                } else if (hasCommonAtom(bondA1, bondB1)) {
                    rNodeX.getExtension().set(j);
                    rNodeY.getExtension().set(i);
                }
            }
        }
    }
}",arcConstructor,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,"/**
     *  Build edges of the RGraphs
     *  This method create the edge of the CDKRGraph and
     *  calculates the incompatibility and neighbourhood
     *  relationships between CDKRGraph nodes.
     *
     * @param  graph   the rGraph
     * @param  ac1   first molecule. Must not be an IQueryAtomContainer.
     * @param  ac2   second molecule. May be an IQueryAtomContainer.
     * @throws org.openscience.cdk.exception.CDKException if it takes too long to get the overlaps
     */",837-898,"('arcConstructor', {'INSTRUCTION': {'covered': 176, 'missed': 0}, 'BRANCH': {'covered': 24, 'missed': 0}, 'LINE': {'covered': 29, 'missed': 0}, 'COMPLEXITY': {'covered': 13, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",474.0,24.0,Build edges of the RGraphs  This method create the edge of the CDKRGraph and  calculates the incompatibility and neighbourhood  relationships between CDKRGraph nodes.,Computes the incompatibility and neighborhood relationships between CDKRGraph nodes by creating a new edge  of type CDKRGraph.,The method builds the edges of the RGraphs and calculates the incompatibility and neighbourhood relationships between the CDKRGraph and the other RGraphs.,0.308610363987383,Construct RGraph edges This method creates the CDKRGraph edge and calculates the incompatibility and neighborhood relationships between the CDKRGraph nodes.
632,dataverse,"Optional<AbstractOAuth2AuthenticationProvider> parseStateFromRequest(@NotNull String state){
    if (state == null || state.trim().equals("""")) {
        logger.log(Level.INFO, ""No state present in request"");
        return Optional.empty();
    }
    String[] topFields = state.split(""~"", 2);
    if (topFields.length != 2) {
        logger.log(Level.INFO, ""Wrong number of fields in state string"", state);
        return Optional.empty();
    }
    AbstractOAuth2AuthenticationProvider idp = authenticationSvc.getOAuth2Provider(topFields[0]);
    if (idp == null) {
        logger.log(Level.INFO, ""Can''t find IDP ''{0}''"", topFields[0]);
        return Optional.empty();
    }
    String raw = StringUtil.decrypt(topFields[1], idp.clientSecret);
    String[] stateFields = raw.split(""~"", -1);
    if (idp.getId().equals(stateFields[0])) {
        long timeOrigin = Long.parseLong(stateFields[1]);
        long timeDifference = this.clock.millis() - timeOrigin;
        if (timeDifference > 0 && timeDifference < STATE_TIMEOUT) {
            if (stateFields.length > 3) {
                this.redirectPage = Optional.ofNullable(stateFields[3]);
            }
            return Optional.of(idp);
        } else {
            logger.info(""State timeout"");
            return Optional.empty();
        }
    } else {
        logger.log(Level.INFO, ""Invalid id field: ''{0}''"", stateFields[0]);
        return Optional.empty();
    }
}",parseStateFromRequest,edu/harvard/iq/dataverse/authorization/providers/oauth2/OAuth2LoginBackingBean.java,/src/main/java/edu/harvard/iq/dataverse/authorization/providers/oauth2/OAuth2LoginBackingBean.java,"/**
     * Parse and verify the state returned from the provider.
     *
     * As it contains the providers implementation ""id"" field when send by us,
     * we can return the corresponding provider object.
     *
     * This function is not side effect free: it will (if present) set {@link #redirectPage}
     * to the value received from the state.
     *
     * @param state The state string, created in  {@link #createState(AbstractOAuth2AuthenticationProvider, Optional)}, send and returned by provider
     * @return A corresponding provider object when state verification succeeded.
     */",156-204,"('parseStateFromRequest', {'INSTRUCTION': {'covered': 112, 'missed': 0}, 'BRANCH': {'covered': 15, 'missed': 1}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",301.0,10.0,Parse and verify the state returned from the provider.,"Checks, whether the state returned from the provider is parsable and sound.",Parse the state back from the provider.,0.112405884244875,Analyze and check the status returned by the provider.
633,cdk,"public int parity(){
    // create three vectors, v->u, v->w and u->x
    double[] vu = toVector(v, u);
    double[] vw = toVector(v, w);
    double[] ux = toVector(u, x);
    // normal vector (to compare against), the normal vector (n) looks like:
    // x     n w
    // \    |/
    // u = v
    double[] normal = crossProduct(vu, crossProduct(vu, vw));
    // compare the dot products of v->w and u->x, if the signs are the same
    // they are both pointing the same direction. if a value is close to 0
    // then it is at pi/2 radians (i.e. unspecified) however 3D coordinates
    // are generally discrete and do not normally represent on unspecified
    // stereo configurations so we don't check this
    int parity = (int) Math.signum(dot(normal, vw)) * (int) Math.signum(dot(normal, ux));
    // invert sign, this then matches with Sp2 double bond parity
    return parity * -1;
}",parity,org/openscience/cdk/hash/stereo/DoubleBond3DParity.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/DoubleBond3DParity.java,"/**
     * Calculate the configuration of the double bond as a parity.
     *
     * @return opposite (+1), together (-1)
     */",63-91,"('parity', {'INSTRUCTION': {'covered': 40, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",99.0,11.0,Calculate the configuration of the double bond as a parity.,Computes the configuration of the double bond as a parity.,The double bond has a configuration.,0.482424056307313,Calculate the dual link configuration as parity.
634,cdk,"public static Partition fromString(String strForm){
    if (strForm == null || strForm.isEmpty())
        throw new IllegalArgumentException(""null or empty string provided"");
    Partition p = new Partition();
    int index = 0;
    if (strForm.charAt(0) == '[') {
        index++;
    }
    int endIndex;
    if (strForm.charAt(strForm.length() - 1) == ']') {
        endIndex = strForm.length() - 2;
    } else {
        endIndex = strForm.length() - 1;
    }
    int currentCell = -1;
    int numStart = -1;
    while (index <= endIndex) {
        char c = strForm.charAt(index);
        if (Character.isDigit(c)) {
            if (numStart == -1) {
                numStart = index;
            }
        } else if (c == ',') {
            int element = Integer.parseInt(strForm.substring(numStart, index));
            if (currentCell == -1) {
                p.addCell(element);
                currentCell = 0;
            } else {
                p.addToCell(currentCell, element);
            }
            numStart = -1;
        } else if (c == '|') {
            int element = Integer.parseInt(strForm.substring(numStart, index));
            if (currentCell == -1) {
                p.addCell(element);
                currentCell = 0;
            } else {
                p.addToCell(currentCell, element);
            }
            currentCell++;
            p.addCell();
            numStart = -1;
        }
        index++;
    }
    int lastElement = Integer.parseInt(strForm.substring(numStart, endIndex + 1));
    p.addToCell(currentCell, lastElement);
    return p;
}",fromString,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,"/**
     * Parse a string like ""[0,2|1,3]"" to form the partition; cells are
     * separated by '|' characters and elements within the cell by commas.
     *
     * @param strForm the partition in string form
     * @return the partition corresponding to the string
     * @throws IllegalArgumentException thrown if the provided strFrom is
     *         null or empty
     */",442-500,"('fromString', {'INSTRUCTION': {'covered': 136, 'missed': 5}, 'BRANCH': {'covered': 19, 'missed': 3}, 'LINE': {'covered': 36, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",326.0,29.0,"Parse a string like ""[0,2|1,3]"" to form the partition; cells are  separated by '|' characters and elements within the cell by commas.",Creates a new partition by parsing the string given as input.,"Cells are separated by characters and elements within the cell by commas if youParse a string like ""[0,2|1,3]"" to form the partition.",1.25154097049388,"Analyze a string like ""[0.2|1.3]"" to form the partition; cells are separated by ""|"" characters and elements in the cell by commas."
635,glowstone,"public boolean readList(@NonNls String key, TagType type, Consumer<? super List<T>> consumer){
    if (isList(key, type)) {
        consumer.accept(getList(key, type));
        return true;
    }
    return false;
}",readList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to a list subtag if it is present, converting it to a list of
     * values first.
     *
     * @param <T> the type to convert the list entries to
     * @param key the key to look up
     * @param type the type that the list entries must be
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */",538-556,"('readList', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,22.0,"Applies the given function to a list subtag if it is present, converting it to a list of  values first.","Returns false is the subtag list cannot be converted into a list of values. Otherwise, transform the list and return true.","If the function is present, apply it to a list subtag and convert it to a list of values.",0.307965513719522,"Applies the given function to a list subtag if it is present, first converting it to a list of values."
636,dcache,"public static boolean hasUid(Subject subject, long uid){
    Set<UidPrincipal> principals = subject.getPrincipals(UidPrincipal.class);
    for (UidPrincipal principal : principals) {
        if (principal.getUid() == uid) {
            return true;
        }
    }
    return false;
}",hasUid,org/dcache/auth/Subjects.java,/modules/common/src/main/java/org/dcache/auth/Subjects.java,"/**
     * Returns true if and only if the subject has the given user ID.
     */",100-112,"('hasUid', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,14.0,Returns true if and only if the subject has the given user ID.,"Return false when the subject does not have the given user ID, true otherwsie.","If the subject has a user ID, this is true.",0.983925259306236,Returns true if and only if the object has the given user ID.
638,cdk,"private static int nStereoBonds(List<IBond> bonds){
    int count = 0;
    for (IBond bond : bonds) {
        IBond.Stereo stereo = bond.getStereo();
        switch(stereo) {
            case E_OR_Z:
            case UP_OR_DOWN:
            case UP_OR_DOWN_INVERTED:
                return -1;
            case UP:
            case DOWN:
            case UP_INVERTED:
            case DOWN_INVERTED:
                count++;
                break;
        }
    }
    return count;
}",nStereoBonds,org/openscience/cdk/hash/stereo/GeometricTetrahedralEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricTetrahedralEncoderFactory.java,"/**
     * access the number of stereo bonds in the provided bond list.
     *
     * @param bonds input list
     * @return number of UP/DOWN bonds in the list, -1 if a query bond was
     *         found
     */",222-248,"('nStereoBonds', {'INSTRUCTION': {'covered': 24, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,12.0,access the number of stereo bonds in the provided bond list.,"If the given list of bonds does not have matching stereo bonds returns -1.  Otherwise, reports the number of such items provided within the list.",The number of stereo bonds is provided.,0.340851279237202,Access the number of stereo links in the provided link list.
639,matsim-libs,"public void write(final String filename){
    try (OutputStream stream = IOUtils.getOutputStream(IOUtils.getFileUrl(filename), false)) {
        write(new PrintStream(stream));
    } catch (IOException e) {
        throw new UncheckedIOException(e);
    }
}",write,org/matsim/analysis/LegHistogram.java,/matsim/src/main/java/org/matsim/analysis/LegHistogram.java,"/**
	 * Writes the gathered data tab-separated into a text file.
	 *
	 * @param filename The name of a file where to write the gathered data.
	 */",132-143,"('write', {'INSTRUCTION': {'covered': 150, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 20, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,10.0,Writes the gathered data tab-separated into a text file.,Stores the retrieved data into a text file in a tab-separated form.,The data tab is written into a text file.,0.139714873757543,Writes the collected data separated by tabs to a text file.
640,acs-aem-commons,"private boolean containsJcrPackagePath(final String path){
    if (StringUtils.startsWith(path, ""/etc/packages/"") && StringUtils.endsWith(path, "".zip"")) {
        return true;
    }
    return false;
}",containsJcrPackagePath,com/adobe/acs/commons/replication/status/impl/JcrPackageReplicationStatusEventHandler.java,/bundle/src/main/java/com/adobe/acs/commons/replication/status/impl/JcrPackageReplicationStatusEventHandler.java,"/**
     * Checks if the given path looks like a Jcr Package path.
     *
     * Provides a very fast, String-based, in-memory check to weed out most false positives and avoid
     * resolving the path to a Jcr Package and ensure it is valid.
     *
     * @param path
     * @return true if at least one path looks like a Jcr Package path
     */",353-371,"('containsJcrPackagePath', {'INSTRUCTION': {'covered': 10, 'missed': 2}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,12.0,Checks if the given path looks like a Jcr Package path.,Controls whether the given path looks like a Jcr Package path.,"If the path looks like a Jcr Package path, it's time to check it.",0.399356720262175,Checks whether the given path resembles a Jcr package path.
641,cdk,"private void storeRingSystem(IAtomContainer mol, IRingSet ringSet){
    listOfRings = new ArrayList<Integer[]>();
    for (int r = 0; r < ringSet.getAtomContainerCount(); ++r) {
        IRing ring = (IRing) ringSet.getAtomContainer(r);
        Integer[] bondNumbers = new Integer[ring.getBondCount()];
        for (int i = 0; i < ring.getBondCount(); ++i) bondNumbers[i] = mol.indexOf(ring.getBond(i));
        listOfRings.add(bondNumbers);
    }
}",storeRingSystem,org/openscience/cdk/smiles/DeduceBondSystemTool.java,/legacy/src/main/java/org/openscience/cdk/smiles/DeduceBondSystemTool.java,"/**
     * Stores an IRingSet corresponding to a AtomContainer using the bond numbers.
     *
     * @param mol      The IAtomContainer for which to store the IRingSet.
     * @param ringSet  The IRingSet to store
     */",804-819,"('storeRingSystem', {'INSTRUCTION': {'covered': 45, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",114.0,12.0,Stores an IRingSet corresponding to a AtomContainer using the bond numbers.,Uses the bond numbers to keep track of an IRingSet corresponding to an AtomContainer.,Bond numbers are used to store an IRingSet that is related to a AtomContainer.,1.01612716575039,Stores an IRingSet corresponding to an AtomContainer using link numbers.
642,cdk,"public void writeMolecule(IAtomContainer molecule) throws CDKException{
    try {
        writeHeader();
        int atomNumber = 1;
        String hetatmRecordName = (writeAsHET.isSet()) ? ""HETATM"" : ""ATOM  "";
        String id = molecule.getID();
        String residueName = (id == null || id.equals("""")) ? ""MOL"" : id;
        String terRecordName = ""TER"";
        // Loop through the atoms and write them out:
        StringBuffer buffer = new StringBuffer();
        Iterator<IAtom> atoms = molecule.atoms().iterator();
        FormatStringBuffer fsb = new FormatStringBuffer("""");
        String[] connectRecords = null;
        if (writeCONECTRecords.isSet()) {
            connectRecords = new String[molecule.getAtomCount()];
        }
        while (atoms.hasNext()) {
            buffer.setLength(0);
            buffer.append(hetatmRecordName);
            fsb.reset(SERIAL_FORMAT).format(atomNumber);
            buffer.append(fsb.toString());
            buffer.append(' ');
            IAtom atom = atoms.next();
            String name;
            if (useElementSymbolAsAtomName.isSet()) {
                name = atom.getSymbol();
            } else {
                if (atom.getID() == null || atom.getID().equals("""")) {
                    name = atom.getSymbol();
                } else {
                    name = atom.getID();
                }
            }
            fsb.reset(ATOM_NAME_FORMAT).format(name);
            buffer.append(fsb.toString());
            fsb.reset(RESIDUE_FORMAT).format(residueName);
            buffer.append(fsb).append(""     0    "");
            Point3d position = atom.getPoint3d();
            fsb.reset(POSITION_FORMAT).format(position.x);
            buffer.append(fsb.toString());
            fsb.reset(POSITION_FORMAT).format(position.y);
            buffer.append(fsb.toString());
            fsb.reset(POSITION_FORMAT).format(position.z);
            buffer.append(fsb.toString());
            // occupancy + temperature factor
            buffer.append(""  1.00  0.00           "").append(atom.getSymbol());
            Integer formalCharge = atom.getFormalCharge();
            if (formalCharge == CDKConstants.UNSET) {
                buffer.append(""+0"");
            } else {
                if (formalCharge < 0) {
                    buffer.append(formalCharge);
                } else {
                    buffer.append('+').append(formalCharge);
                }
            }
            if (connectRecords != null && writeCONECTRecords.isSet()) {
                List<IAtom> neighbours = molecule.getConnectedAtomsList(atom);
                if (neighbours.size() != 0) {
                    StringBuffer connectBuffer = new StringBuffer(""CONECT"");
                    connectBuffer.append(String.format(""%5d"", atomNumber));
                    for (IAtom neighbour : neighbours) {
                        int neighbourNumber = molecule.indexOf(neighbour) + 1;
                        connectBuffer.append(String.format(""%5d"", neighbourNumber));
                    }
                    connectRecords[atomNumber - 1] = connectBuffer.toString();
                } else {
                    connectRecords[atomNumber - 1] = null;
                }
            }
            writer.write(buffer.toString(), 0, buffer.length());
            writer.write('\n');
            ++atomNumber;
        }
        if (writeTERRecord.isSet()) {
            writer.write(terRecordName, 0, terRecordName.length());
            writer.write('\n');
        }
        if (connectRecords != null && writeCONECTRecords.isSet()) {
            for (String connectRecord : connectRecords) {
                if (connectRecord != null) {
                    writer.write(connectRecord);
                    writer.write('\n');
                }
            }
        }
        if (writeENDRecord.isSet()) {
            writer.write(""END   "");
            writer.write('\n');
        }
    } catch (IOException exception) {
        throw new CDKException(""Error while writing file: "" + exception.getMessage(), exception);
    }
}",writeMolecule,org/openscience/cdk/io/PDBWriter.java,/storage/pdb/src/main/java/org/openscience/cdk/io/PDBWriter.java,"/**
     * Writes a single frame in PDB format to the Writer.
     *
     * @param molecule the Molecule to write
     */",173-281,"('writeMolecule', {'INSTRUCTION': {'covered': 311, 'missed': 48}, 'BRANCH': {'covered': 27, 'missed': 13}, 'LINE': {'covered': 66, 'missed': 8}, 'COMPLEXITY': {'covered': 9, 'missed': 12}, 'METHOD': {'covered': 1, 'missed': 0}})",743.0,11.0,Writes a single frame in PDB format to the Writer.,Stores a single frame in PDB format into the Writer.,A single frame is written in PDB format.,0.317801571899294,Writes a single image in PDB format to the writer.
643,matsim-libs,"public static void addShipment(Carrier carrier, CarrierShipment carrierShipment){
    carrier.getShipments().put(carrierShipment.getId(), carrierShipment);
}",addShipment,org/matsim/contrib/freight/carrier/CarrierUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/carrier/CarrierUtils.java,"/**
	 * Adds an {@link CarrierShipment} to the {@link Carrier}.
	 * @param carrier
	 * @param carrierShipment
	 */",53-60,"('addShipment', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,15.0,Adds an {@link CarrierShipment} to the {@link Carrier}.,Appends an {@link CarrierShipment} to the {@link Carrier}.,The @link Carrier is now an @link CarrierShipment.,1.20709854382521,Adds a {@link CarrierShipment} to the {@link Carrier}.
644,matsim-libs,"private double calcDistanceIndicator(final double x, final double y){
    double distanceX;
    double distanceY;
    if (this.minX <= x && x <= this.maxX) {
        distanceX = 0;
    } else {
        distanceX = Math.min(Math.abs(this.minX - x), Math.abs(this.maxX - x));
    }
    if (this.minY <= y && y <= this.maxY) {
        distanceY = 0;
    } else {
        distanceY = Math.min(Math.abs(this.minY - y), Math.abs(this.maxY - y));
    }
    return distanceX * distanceX + distanceY * distanceY;
}",calcDistanceIndicator,org/matsim/core/network/LinkQuadTree.java,/matsim/src/main/java/org/matsim/core/network/LinkQuadTree.java,"/**
		 * Calculates the distance of a given point to the border of the
		 * rectangle. If the point lies within the rectangle, the distance
		 * is zero.
		 *
		 * @param x left-right location
		 * @param y up-down location
		 * @return distance to border, 0 if inside rectangle or on border
		 */",284-310,"('calcDistanceIndicator', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",133.0,14.0,Calculates the distance of a given point to the border of the  rectangle.,"Given a point expressed through (x,y) coordinates, compute the distance of such a point to the rectangle's border.",The distance is calculated from a point to the border.,0.263664508405957,Calculates the distance from a given point to the border of the rectangle.
645,activiti,"protected void makeProcessDefinitionsConsistentWithPersistedVersions(ParsedDeployment parsedDeployment){
    for (ProcessDefinitionEntity processDefinition : parsedDeployment.getAllProcessDefinitions()) {
        ProcessDefinitionEntity persistedProcessDefinition = bpmnDeploymentHelper.getPersistedInstanceOfProcessDefinition(processDefinition);
        if (persistedProcessDefinition != null) {
            processDefinition.setId(persistedProcessDefinition.getId());
            processDefinition.setVersion(persistedProcessDefinition.getVersion());
            processDefinition.setAppVersion(persistedProcessDefinition.getAppVersion());
            processDefinition.setSuspensionState(persistedProcessDefinition.getSuspensionState());
        }
    }
}",makeProcessDefinitionsConsistentWithPersistedVersions,org/activiti/engine/impl/bpmn/deployer/BpmnDeployer.java,/activiti-core/activiti-engine/src/main/java/org/activiti/engine/impl/bpmn/deployer/BpmnDeployer.java,"/**
     * Loads the persisted version of each process definition and set values on the in-memory
     * version to be consistent.
     */",268-284,"('makeProcessDefinitionsConsistentWithPersistedVersions', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,19.0,Loads the persisted version of each process definition and set values on the in-memory  version to be consistent.,Dispatches the persisted version of each process definition while setting the values on the in-memory version for consistency.,Set values on the in-memory version of the persisted version of the process definition to make sure it is consistent.,0.376543263106742,Loads the persistent version of each process definition and sets the values on the in-memory version so that they are consistent.
646,cdk,"public String toString(){
    if (differences.size() == 0)
        return """";
    StringBuffer diffBuffer = new StringBuffer();
    diffBuffer.append(this.name).append('{');
    Iterator<IDifference> children = getChildren().iterator();
    while (children.hasNext()) {
        diffBuffer.append(children.next().toString());
        if (children.hasNext()) {
            diffBuffer.append("", "");
        }
    }
    diffBuffer.append('}');
    return diffBuffer.toString();
}",toString,org/openscience/cdk/tools/diff/tree/Point3dDifference.java,/misc/diff/src/main/java/org/openscience/cdk/tools/diff/tree/Point3dDifference.java,"/**
     * Returns a {@link String} representation for this {@link IDifference}.
     *
     * @return a {@link String}
     */",63-84,"('toString', {'INSTRUCTION': {'covered': 44, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",112.0,16.0,Returns a {@link String} representation for this {@link IDifference}.,Returns a String represention for the object IDifference.,This is a representation of the @link IDifference.,0.993309842181613,Returns a {@link String} representation for this {@link IDifference}.
647,liquibase,"private static boolean isCommand(String arg){
    return COMMANDS.MIGRATE.equals(arg) || COMMANDS.MIGRATE_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE.equalsIgnoreCase(arg) || COMMANDS.UPDATE_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE_COUNT.equalsIgnoreCase(arg) || COMMANDS.UPDATE_COUNT_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE_TO_TAG.equalsIgnoreCase(arg) || COMMANDS.UPDATE_TO_TAG_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_TO_DATE.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_COUNT.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_TO_DATE_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_COUNT_SQL.equalsIgnoreCase(arg) || COMMANDS.REGISTER_CHANGELOG.equalsIgnoreCase(arg) || COMMANDS.DEACTIVATE_CHANGELOG.equalsIgnoreCase(arg) || COMMANDS.FUTURE_ROLLBACK_SQL.equalsIgnoreCase(arg) || COMMANDS.FUTURE_ROLLBACK_COUNT_SQL.equalsIgnoreCase(arg) || COMMANDS.FUTURE_ROLLBACK_FROM_TAG_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE_TESTING_ROLLBACK.equalsIgnoreCase(arg) || COMMANDS.TAG.equalsIgnoreCase(arg) || COMMANDS.TAG_EXISTS.equalsIgnoreCase(arg) || COMMANDS.LIST_LOCKS.equalsIgnoreCase(arg) || COMMANDS.HISTORY.equalsIgnoreCase(arg) || COMMANDS.DROP_ALL.equalsIgnoreCase(arg) || COMMANDS.RELEASE_LOCKS.equalsIgnoreCase(arg) || COMMANDS.STATUS.equalsIgnoreCase(arg) || COMMANDS.UNEXPECTED_CHANGESETS.equalsIgnoreCase(arg) || COMMANDS.VALIDATE.equalsIgnoreCase(arg) || COMMANDS.HELP.equalsIgnoreCase(arg) || COMMANDS.DIFF.equalsIgnoreCase(arg) || COMMANDS.DIFF_CHANGELOG.equalsIgnoreCase(arg) || COMMANDS.GENERATE_CHANGELOG.equalsIgnoreCase(arg) || COMMANDS.SNAPSHOT.equalsIgnoreCase(arg) || COMMANDS.SNAPSHOT_REFERENCE.equalsIgnoreCase(arg) || COMMANDS.SYNC_HUB.equalsIgnoreCase(arg) || COMMANDS.EXECUTE_SQL.equalsIgnoreCase(arg) || COMMANDS.CALCULATE_CHECKSUM.equalsIgnoreCase(arg) || COMMANDS.CLEAR_CHECKSUMS.equalsIgnoreCase(arg) || COMMANDS.DB_DOC.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC_TO_TAG.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC_TO_TAG_SQL.equalsIgnoreCase(arg) || COMMANDS.MARK_NEXT_CHANGESET_RAN.equalsIgnoreCase(arg) || COMMANDS.MARK_NEXT_CHANGESET_RAN_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_ONE_CHANGE_SET.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_ONE_CHANGE_SET_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_ONE_UPDATE.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_ONE_UPDATE_SQL.equalsIgnoreCase(arg);
}",isCommand,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,"/**
     * Returns true if the given arg is a valid main command of Liquibase.
     *
     * @param arg the String to test
     * @return true if it is a valid main command, false if not
     */",621-678,"('isCommand', {'INSTRUCTION': {'covered': 204, 'missed': 0}, 'BRANCH': {'covered': 70, 'missed': 30}, 'LINE': {'covered': 50, 'missed': 0}, 'COMPLEXITY': {'covered': 21, 'missed': 30}, 'METHOD': {'covered': 1, 'missed': 0}})",461.0,14.0,Returns true if the given arg is a valid main command of Liquibase.,Checks whether the arg matches a valid main command or not.,"If the given arg is a valid main command, then this is true.",1.02144227788678,Returns true if the given arg is a valid Liquibase master command.
648,jooby," int intValue(){
    try {
        return Integer.parseInt(value());
    } catch (NumberFormatException x) {
        throw new TypeMismatchException(name(), int.class, x);
    }
}",intValue,io/jooby/Value.java,/jooby/src/main/java/io/jooby/Value.java,"/**
   * Convert this value to int (if possible).
   *
   * @return Int value.
   */",87-98,"('intValue', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,10.0,Convert this value to int (if possible).,Converts and returns an Integer value whenever possible.,"If possible, convert this value to int.",0.189182784632411,Convert this value to int (if possible).
649,cdk,"static int processCx(final String str, final CxSmilesState state){
    final CharIter iter = new CharIter(str);
    if (!iter.nextIf('|'))
        return -1;
    while (iter.hasNext()) {
        switch(iter.next()) {
            case '$':
                Map<Integer, String> dest;
                if (iter.nextIf(""_AV:""))
                    dest = state.atomValues = new TreeMap<>();
                else
                    dest = state.atomLabels = new TreeMap<>();
                if (!processAtomLabels(iter, dest))
                    return -1;
                break;
            case '(':
                if (!processCoords(iter, state))
                    return -1;
                break;
            case 'c':
            case 't':
                if (iter.nextIf(':')) {
                    if (!skipIntList(iter, COMMA_SEPARATOR))
                        return -1;
                } else if (iter.nextIf(""tu:"")) {
                    if (!skipIntList(iter, COMMA_SEPARATOR))
                        return -1;
                }
                break;
            case '&':
                if (!processStereoGrps(state, iter, IStereoElement.GRP_RAC))
                    return -1;
                break;
            case 'o':
                if (!processStereoGrps(state, iter, IStereoElement.GRP_REL))
                    return -1;
                break;
            case 'a':
                if (!processStereoGrps(state, iter, IStereoElement.GRP_ABS))
                    return -1;
                break;
            case 'r':
                if (iter.nextIf(':')) {
                    state.racemicFrags = new ArrayList<>();
                    if (!processIntList(iter, ',', state.racemicFrags))
                        return -1;
                } else {
                    state.racemic = true;
                    if (!iter.nextIf(',') && iter.curr() != '|')
                        return -1;
                }
                break;
            case 'l':
                if (!iter.nextIf(""p:""))
                    return -1;
                if (!skipIntMap(iter))
                    return -1;
                break;
            case 'f':
                if (!iter.nextIf(':'))
                    return -1;
                if (!processFragmentGrouping(iter, state))
                    return -1;
                break;
            case 'S':
                if (iter.nextIf(""g:"")) {
                    if (!processPolymerSgroups(iter, state))
                        return -1;
                } else if (iter.nextIf(""gD:"")) {
                    if (!processDataSgroups(iter, state))
                        return -1;
                    if (iter.nextIf(','))
                        break;
                } else if (iter.nextIf(""gH:"")) {
                    if (!processSgroupsHierarchy(iter, state))
                        return -1;
                } else {
                    return -1;
                }
                break;
            case 'm':
                if (!iter.nextIf(':'))
                    return -1;
                if (!processPositionalVariation(iter, state))
                    return -1;
                break;
            case '^':
                if (!processRadicals(iter, state))
                    return -1;
                break;
            case 'C':
            case 'H':
                if (!iter.nextIf(':'))
                    return -1;
                while (iter.hasNext() && isDigit(iter.curr())) {
                    if (!skipIntList(iter, DOT_SEPARATOR))
                        return -1;
                    iter.nextIf(',');
                }
                break;
            case '|':
                if (!iter.nextIf(' '))
                    iter.nextIf('\t');
                return iter.pos;
            case 'L':
                if (iter.nextIf('O')) {
                    if (!iter.nextIf(':'))
                        return -1;
                    if (!processLigandOrdering(iter, state))
                        return -1;
                } else {
                    return -1;
                }
                break;
            default:
                return -1;
        }
    }
    return -1;
}",processCx,org/openscience/cdk/smiles/CxSmilesParser.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/CxSmilesParser.java,"/**
     * Parse an string possibly containing CXSMILES into an intermediate state
     * ({@link CxSmilesState}) representation.
     *
     * @param str input character string (SMILES title field)
     * @param state output CXSMILES state
     * @return position where CXSMILES ends (below 0 means no CXSMILES)
     */",425-569,"('processCx', {'INSTRUCTION': {'covered': 206, 'missed': 48}, 'BRANCH': {'covered': 66, 'missed': 26}, 'LINE': {'covered': 49, 'missed': 24}, 'COMPLEXITY': {'covered': 28, 'missed': 26}, 'METHOD': {'covered': 1, 'missed': 0}})",708.0,19.0,Parse an string possibly containing CXSMILES into an intermediate state  ({@link CxSmilesState}) representation.,"Given a string as input, it converts such string into an intermediate state (CxSmileState) representation.",Parse a string containing a symbol into a representation.,0.615026040518977,Parse a string that may contain CXSMILES in an intermediate state representation ({@link CxSmilesState}).
650,matsim-libs,"public static Map<String, PreparedGeometry> createGridFromNetworkWithinServiceArea(Network network, double cellsize, List<PreparedGeometry> serviceAreaGeoms){
    Map<String, PreparedGeometry> grid = createGridFromNetwork(network, cellsize);
    log.info(""total number of created grid zones = "" + grid.size());
    log.info(""searching for grid zones within the drt service area..."");
    Counter counter = new Counter(""dealt with zone "");
    Map<String, PreparedGeometry> zonesWithinServiceArea = EntryStream.of(grid).peekKeys(id -> counter.incCounter()).filterValues(cell -> serviceAreaGeoms.stream().anyMatch(serviceArea -> serviceArea.intersects(cell.getGeometry()))).toMap();
    log.info(""number of remaining grid zones = "" + zonesWithinServiceArea.size());
    return zonesWithinServiceArea;
}",createGridFromNetworkWithinServiceArea,org/matsim/contrib/drt/analysis/zonal/DrtGridUtils.java,/contribs/drt/src/main/java/org/matsim/contrib/drt/analysis/zonal/DrtGridUtils.java,"/**
	 * First creates a grid based on the network bounding box. Then removes all zones that do not intersect the service area.
	 * Result may contain zones that are barely included in the service area. But as passengers may walk into the service area,
	 * it seems appropriate that the DrtZonalSystem, which is used for demand estimation, is larger than the service area.
	 * The {@code cellsize} indirectly determines, how much larger the DrtZonalSystem may get.
	 *
	 * @param network
	 * @param cellsize
	 * @param serviceAreaGeoms geometries that define the service area
	 * @return
	 */",75-101,"('createGridFromNetworkWithinServiceArea', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",141.0,11.0,First creates a grid based on the network bounding box.,Returns a Map representing a grid based on the network bounding boxes from which all the zones that do not  intersect the service area have been stripped away.,The network bounding box is used to create a grid.,0.381773038145617,"First, creates a grid based on the network bounding box."
651,egeria,"private List<FileFolder> extractFolders(String pathName, String externalSourceName, String methodName) throws InvalidParameterException{
    boolean fileSeparatorReversed = false;
    if (pathName.contains(""\\"")) {
        pathName = pathName.replace(""\\"", ""/"");
        fileSeparatorReversed = true;
    }
    Path path = Paths.get(pathName);
    File parentFile = path.toFile().getParentFile();
    invalidParameterHandler.validateObject(parentFile, ""pathName"", methodName);
    List<FileFolder> folders = new ArrayList<>();
    while (parentFile != null) {
        String parentFilePath = fileSeparatorReversed ? parentFile.getPath().replace(""/"", ""\\"") : parentFile.getPath();
        FileFolder folder = buildFileFolder(parentFilePath, externalSourceName);
        folders.add(folder);
        parentFile = parentFile.getParentFile();
    }
    return folders;
}",extractFolders,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineFolderHierarchyHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineFolderHierarchyHandler.java,"/**
     * Extracts each folder path and builds FileFolders, with the qualified name of the form
     * '<externalSourceName>::<path>'. The order is important, meaning the first folder is the one containing the file
     * and the last one the root, and used in creating the folder hierarchy structure al the way to the SoftwareServerCapability
     *
     * @param pathName           file path
     * @param externalSourceName name of SoftwareServerCapability
     * @param methodName         method name
     *
     * @return list of FileFolders
     */",163-197,"('extractFolders', {'INSTRUCTION': {'covered': 47, 'missed': 13}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 13, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",158.0,26.0,"Extracts each folder path and builds FileFolders, with the qualified name of the form  '<externalSourceName>::<path>'.",Returns a file folder list of FileFolders by extracting each folder path with the form's qualified name <externalSourceName>::path.,The form 'external SourceName>::path>' is used to build the file folder.,0.537247964039791,"Gets each folder path and generates FileFolders, with the qualified name of the form '<externalSourceName>::<path>'."
652,cdk,"public static IsotopePattern normalize(IsotopePattern isotopeP){
    IsotopeContainer isoHighest = null;
    double biggestAbundance = 0;
    /* Extraction of the isoContainer with the highest abundance */
    for (IsotopeContainer isoContainer : isotopeP.getIsotopes()) {
        double abundance = isoContainer.getIntensity();
        if (biggestAbundance < abundance) {
            biggestAbundance = abundance;
            isoHighest = isoContainer;
        }
    }
    /* Normalize */
    IsotopePattern isoNormalized = new IsotopePattern();
    for (IsotopeContainer isoContainer : isotopeP.getIsotopes()) {
        double inten = isoContainer.getIntensity() / isoHighest.getIntensity();
        IsotopeContainer icClone;
        try {
            icClone = (IsotopeContainer) isoContainer.clone();
            icClone.setIntensity(inten);
            if (isoHighest.equals(isoContainer))
                isoNormalized.setMonoIsotope(icClone);
            else
                isoNormalized.addIsotope(icClone);
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }
    isoNormalized.setCharge(isotopeP.getCharge());
    return isoNormalized;
}",normalize,org/openscience/cdk/formula/IsotopePatternManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/formula/IsotopePatternManipulator.java,"/**
     * Return the isotope pattern normalized to the highest abundance.
     *
     * @param isotopeP  The IsotopePattern object to normalize
     * @return          The IsotopePattern normalized
     */",17-55,"('normalize', {'INSTRUCTION': {'covered': 74, 'missed': 3}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 20, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",169.0,10.0,Return the isotope pattern normalized to the highest abundance.,"Given an IsotopePattern as input, it returns its normalized version to the highest abundance.",Return the pattern normalized to the highest amount.,0.119449781234633,Restore the standardized isotopic pattern to the highest abundance.
653,cdk,"public void replaceAtomContainer(int position, IAtomContainer container){
    IAtomContainer old = atomContainers[position];
    old.removeListener(this);
    atomContainers[position] = container;
    container.addListener(this);
    notifyChanged();
}",replaceAtomContainer,org/openscience/cdk/AtomContainerSet.java,/base/data/src/main/java/org/openscience/cdk/AtomContainerSet.java,"/**
     * Replace the AtomContainer at a specific position (array has to be large enough).
     *
     * @param position   position in array for AtomContainer
     * @param container  the replacement AtomContainer
     */",134-147,"('replaceAtomContainer', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,16.0,Replace the AtomContainer at a specific position (array has to be large enough).,The AtomContainer will be replaced at a specific given position.,Thearray has to be large enough to replace the AtomContainer.,0.33482061321682,Replace the AtomContainer at a specific position (the array must be large enough).
654,dataverse,"public static short[] allIndices(){
    short[] retVal = new short[64];
    for (short s = 0; s < 64; s++) retVal[s] = s;
    return retVal;
}",allIndices,edu/harvard/iq/dataverse/util/BitSet.java,/src/main/java/edu/harvard/iq/dataverse/util/BitSet.java,"/**
	 * Returns all the indices a bit set may have. Can be used for 
	 * cheap for-each loops (i.e. no boxing/unboxing).
	 * @return All the indices a BitSet has [0..63]
	 */",30-39,"('allIndices', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,10.0,Returns all the indices a bit set may have.,All the indiced featuring a bit set will be returned.,A bit set may have all the indices.,0.290372684467222,Returns all indexes that a bit set can have.
655,jackson-databind,"public void serialize(JsonGenerator g, SerializerProvider provider) throws IOException{
    @SuppressWarnings(""deprecation"")
    boolean trimEmptyArray = (provider != null) && !provider.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS);
    g.writeStartObject(this);
    for (Map.Entry<String, JsonNode> en : _children.entrySet()) {
        BaseJsonNode value = (BaseJsonNode) en.getValue();
        if (trimEmptyArray && value.isArray() && value.isEmpty(provider)) {
            continue;
        }
        g.writeFieldName(en.getKey());
        value.serialize(g, provider);
    }
    g.writeEndObject();
}",serialize,com/fasterxml/jackson/databind/node/ObjectNode.java,/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java,"/**
     * Method that can be called to serialize this node and
     * all of its descendants using specified JSON generator.
     */",301-331,"('serialize', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 3}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",124.0,19.0,Method that can be called to serialize this node and  all of its descendants using specified JSON generator.,Serialized the current node and all of its descendants using JSON generator.,This method can be used toserialize this and all of its descendants.,0.428614995217112,A method that can be called to serialize this node and all its descendants using a specified JSON generator.
656,openapi-generator,"public ValidationResult validate(TInput input){
    ValidationResult result = new ValidationResult();
    if (rules != null) {
        rules.forEach(it -> {
            ValidationRule.Result attempt = it.evaluate(input);
            if (attempt.passed()) {
                result.addResult(Validated.valid(it));
            } else {
                result.addResult(Validated.invalid(it, it.getFailureMessage(), attempt.getDetails()));
            }
        });
    }
    return result;
}",validate,org/openapitools/codegen/validation/GenericValidator.java,/modules/openapi-generator-core/src/main/java/org/openapitools/codegen/validation/GenericValidator.java,"/**
     * Validates input, resulting in a instance of {@link ValidationResult} which provides details on all validations performed (success, error, warning).
     *
     * @param input The object instance to be validated.
     *
     * @return A {@link ValidationResult} which details the success, error, and warning validation results.
     */",38-59,"('validate', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",99.0,28.0,"Validates input, resulting in a instance of {@link ValidationResult} which provides details on all validations performed (success, error, warning).","Once the input has been validated, it returns the resulting instance, which provides details on the validation status.","Validates input, resulting in a instance of @link ValidationResult which provides details on all validations.",0.99211923973508,"Validates the input, resulting in an instance of {@link ValidationResult} that provides details about all validations performed (success, error, warning)."
657,cdk,"public boolean partialCharges(IAtomContainer mol){
    int[][] adjList = mol.getProperty(MMFF_ADJLIST_CACHE);
    GraphUtil.EdgeToBondMap edgeMap = mol.getProperty(MMFF_EDGEMAP_CACHE);
    if (adjList == null || edgeMap == null)
        throw new IllegalArgumentException(""Invoke assignAtomTypes first."");
    effectiveCharges(mol);
    for (int v = 0; v < mol.getAtomCount(); v++) {
        IAtom atom = mol.getAtom(v);
        String symbType = atom.getAtomTypeName();
        final int thisType = mmffParamSet.intType(symbType);
        if (thisType == 0)
            continue;
        double pbci = mmffParamSet.getPartialBondChargeIncrement(thisType).doubleValue();
        for (int w : adjList[v]) {
            int otherType = mmffParamSet.intType(mol.getAtom(w).getAtomTypeName());
            if (otherType == 0)
                continue;
            IBond bond = edgeMap.get(v, w);
            int bondCls = mmffParamSet.getBondCls(thisType, otherType, bond.getOrder().numeric(), bond.getProperty(MMFF_AROM) != null);
            BigDecimal bci = mmffParamSet.getBondChargeIncrement(bondCls, thisType, otherType);
            if (bci != null) {
                atom.setCharge(atom.getCharge() - bci.doubleValue());
            } else {
                atom.setCharge(atom.getCharge() + (pbci - mmffParamSet.getPartialBondChargeIncrement(otherType).doubleValue()));
            }
        }
    }
    return true;
}",partialCharges,org/openscience/cdk/forcefield/mmff/Mmff.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/Mmff.java,"/**
     * Assign the partial charges, all existing charges are cleared.
     * Atom types must be assigned first. 
     *
     * @param mol molecule
     * @return charges were assigned
     * @see #effectiveCharges(IAtomContainer)
     * @see #assignAtomTypes(IAtomContainer)
     */",165-218,"('partialCharges', {'INSTRUCTION': {'covered': 119, 'missed': 19}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 21, 'missed': 2}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",282.0,11.0,"Assign the partial charges, all existing charges are cleared.","Clears all the existing charges, and it assigns those marked as partial.",All charges are cleared if the partial charges are assigned.,0.309121802584668,"Assign partial charges, all existing fees are erased."
658,shardingsphere-elasticjob,"public boolean isAllCompleted(){
    return jobNodeStorage.isJobNodeExisted(GuaranteeNode.COMPLETED_ROOT) && configService.load(false).getShardingTotalCount() <= jobNodeStorage.getJobNodeChildrenKeys(GuaranteeNode.COMPLETED_ROOT).size();
}",isAllCompleted,org/apache/shardingsphere/elasticjob/lite/internal/guarantee/GuaranteeService.java,/elasticjob-lite/elasticjob-lite-core/src/main/java/org/apache/shardingsphere/elasticjob/lite/internal/guarantee/GuaranteeService.java,"/**
     * Judge whether job's sharding items are all completed.
     *
     * @return job's sharding items are all completed or not
     */",109-117,"('isAllCompleted', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,10.0,Judge whether job's sharding items are all completed.,Checks if the job's sharding items have completed the task.,"If the job's shards are complete, judge.",0.189488081764545,Judge whether the partitioning items of the task are all complete.
659,cdk,"private static boolean hasCommonAtom(IBond bondA, IBond bondB){
    return bondA.contains(bondB.getBegin()) || bondA.contains(bondB.getEnd());
}",hasCommonAtom,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,"/**
     * Determines if two bonds have at least one atom in common.
     *
     * @param  atom  first bondA1
     * @param  bondB  second bondA1
     * @return    the symbol of the common atom or """" if
     *            the 2 bonds have no common atom
     */",900-910,"('hasCommonAtom', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,12.0,Determines if two bonds have at least one atom in common.,Checks whether two bonds have at least one atom in common.,"If two bonds have the same atom, it's a sign that they are related.",1.06275679338011,Determines whether two bonds have at least one atom in common.
660,jooby,"public static Config systemProperties(){
    return ConfigFactory.parseProperties(System.getProperties(), ConfigParseOptions.defaults().setOriginDescription(""system properties""));
}",systemProperties,io/jooby/Environment.java,/jooby/src/main/java/io/jooby/Environment.java,"/**
   * Creates a {@link Config} object from {@link System#getProperties()}.
   *
   * @return Configuration object.
   */",256-264,"('systemProperties', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,19.0,Creates a {@link Config} object from {@link System#getProperties()}.,A new Config object is created by calling the method getProperties().,The @link Config object is created from the @link System#getProperties,0.539425309075955,Creates a {@link Config} object from {@link System#getProperties()}.
661,cdk,"public boolean encode(long[] current, long[] next){
    int p = permutation.parity(current);
    // if is a permutation parity (all neighbors are different)
    if (p != 0) {
        // multiple with the geometric parity
        int q = geometric.parity() * p;
        // configure anticlockwise/clockwise
        if (q > 0) {
            for (int i : centres) {
                next[i] = current[i] * ANTICLOCKWISE;
            }
        } else if (q < 0) {
            for (int i : centres) {
                next[i] = current[i] * CLOCKWISE;
            }
        }
        // 0 parity ignored
        return true;
    }
    return false;
}",encode,org/openscience/cdk/hash/stereo/GeometryEncoder.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometryEncoder.java,"/**
     * Encodes the {@code centres[]} specified in the constructor as either
     * clockwise/anticlockwise or none. If there is a permutation parity but no
     * geometric parity then we can not encode the configuration and 'true' is
     * returned to indicate the perception is done. If there is no permutation
     * parity this may changed with the next {@code current[]} values and so
     * 'false' is returned.
     *
     *{@inheritDoc}
     */",82-119,"('encode', {'INSTRUCTION': {'covered': 72, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",110.0,19.0,Encodes the {@code centres[]} specified in the constructor as either  clockwise/anticlockwise or none.,"Returns true if the encoding of the centres[] as clockwise/anticlockwise has been successfull, false otherwise.",The @code centres[] specified in the constructor is either clockwise or anticlockwise.,1.22763530734978,Encodes the {@code centers[]} specified in the manufacturer clockwise/counterclockwise or counterclockwise or none.
662,cdk,"private boolean checkGeometric(int u1, int u2, int[] mapping){
    int v1 = mapping[u1];
    int v2 = mapping[u2];
    if (targetTypes[v1] != Type.Geometric || targetTypes[v2] != Type.Geometric)
        return false;
    IDoubleBondStereochemistry queryElement = (IDoubleBondStereochemistry) queryElements[u1];
    IDoubleBondStereochemistry targetElement = (IDoubleBondStereochemistry) targetElements[v1];
    if (!targetElement.getStereoBond().contains(target.getAtom(v1)) || !targetElement.getStereoBond().contains(target.getAtom(v2)))
        return false;
    boolean swap = false;
    if (!targetElement.getStereoBond().getBegin().equals(target.getAtom(v1))) {
        int tmp = v1;
        v1 = v2;
        v2 = tmp;
        swap = true;
    }
    IBond[] queryBonds = queryElement.getBonds();
    IBond[] targetBonds = targetElement.getBonds();
    int p = parity(queryElement.getStereo());
    int q = parity(targetElement.getStereo());
    int uLeft = queryMap.get(queryBonds[0].getOther(query.getAtom(u1)));
    int uRight = queryMap.get(queryBonds[1].getOther(query.getAtom(u2)));
    int vLeft = targetMap.get(targetBonds[0].getOther(target.getAtom(v1)));
    int vRight = targetMap.get(targetBonds[1].getOther(target.getAtom(v2)));
    if (swap) {
        int tmp = vLeft;
        vLeft = vRight;
        vRight = tmp;
    }
    if (mapping[uLeft] != vLeft)
        p *= -1;
    if (mapping[uRight] != vRight)
        p *= -1;
    return p == q;
}",checkGeometric,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,"/**
     * Verify the geometric stereochemistry (cis/trans) of the double bond
     * {@code u1=u2} is preserved in the target when the {@code mapping} is
     * used.
     *
     * @param u1      one index of the double bond
     * @param u2      other index of the double bond
     * @param mapping mapping of vertices
     * @return the geometric configuration is preserved
     */",222-280,"('checkGeometric', {'INSTRUCTION': {'covered': 150, 'missed': 26}, 'BRANCH': {'covered': 10, 'missed': 8}, 'LINE': {'covered': 21, 'missed': 7}, 'COMPLEXITY': {'covered': 2, 'missed': 8}, 'METHOD': {'covered': 1, 'missed': 0}})",354.0,31.0,Verify the geometric stereochemistry (cis/trans) of the double bond  {@code u1=u2} is preserved in the target when the {@code mapping} is  used.,Checks whether the geometric stereochemistry configuration is preserved.,The double bond @codeu1 is preserved in the target when the @code mapping is used.,0.755641271847901,Verify that the geometric stereochemistry (cis/trans) of the double link {@code u1=u2} is retained in the target when the {@code mapping} is used.
663,cdk,"public static PermutationGroup makeSymN(int size){
    List<Permutation> generators = new ArrayList<Permutation>();
    // p1 is (0, 1)
    int[] p1 = new int[size];
    p1[0] = 1;
    p1[1] = 0;
    for (int i = 2; i < size; i++) {
        p1[i] = i;
    }
    // p2 is (1, 2, ...., n, 0)
    int[] p2 = new int[size];
    p2[0] = 1;
    for (int i = 1; i < size - 1; i++) {
        p2[i] = i + 1;
    }
    p2[size - 1] = 0;
    generators.add(new Permutation(p1));
    generators.add(new Permutation(p2));
    return new PermutationGroup(size, generators);
}",makeSymN,org/openscience/cdk/group/PermutationGroup.java,/tool/group/src/main/java/org/openscience/cdk/group/PermutationGroup.java,"/**
     * Make the symmetric group Sym(N) for N. That is, a group of permutations
     * that represents _all_ permutations of size N.
     *
     * @param size the size of the permutation
     * @return a group for all permutations of N
     */",152-182,"('makeSymN', {'INSTRUCTION': {'covered': 74, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",157.0,11.0,Make the symmetric group Sym(N) for N.,Returns a group of permutations representing all the permutations of size N.,Sym(N) is a group for N.,0.398552998573338,Create the symmetric group Sym(N) for N.
664,acs-aem-commons,"private Map<String, String[]> formatExtensions(final Map<String, String> configuredExtensions){
    final Map<String, String[]> extensions = new LinkedHashMap<>();
    for (final Map.Entry<String, String> entry : configuredExtensions.entrySet()) {
        final String ext = entry.getKey().trim();
        extensions.put(ext, entry.getValue().trim().split(""&""));
    }
    return extensions;
}",formatExtensions,com/adobe/acs/commons/replication/dispatcher/impl/RefetchFlushContentBuilderImpl.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/impl/RefetchFlushContentBuilderImpl.java,"/**
     * Take the mapped extensions and organize them by individual extension.
     * @param configuredExtensions Map of extension mappings
     * @return Map with extension as keys
     */",126-140,"('formatExtensions', {'INSTRUCTION': {'covered': 33, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",100.0,11.0,Take the mapped extensions and organize them by individual extension.,"Given as input a configuredExtension object, unfold it by individual extension.",Take the mapped extensions and organize them by extension.,0.364883395267714,Take the mapped extensions and organize them by individual extension.
665,tablesaw,"public IntColumn asIntColumn(){
    IntColumn result = IntColumn.create(name());
    for (double d : data) {
        if (DoubleColumnType.valueIsMissing(d)) {
            result.appendMissing();
        } else {
            result.append((int) d);
        }
    }
    return result;
}",asIntColumn,tech/tablesaw/api/DoubleColumn.java,/core/src/main/java/tech/tablesaw/api/DoubleColumn.java,"/**
   * Returns a new IntColumn containing a value for each value in this column, truncating if
   * necessary.
   *
   * <p>A narrowing primitive conversion such as this one may lose information about the overall
   * magnitude of a numeric value and may also lose precision and range. Specifically, if the value
   * is too small (a negative value of large magnitude or negative infinity), the result is the
   * smallest representable value of type int.
   *
   * <p>Similarly, if the value is too large (a positive value of large magnitude or positive
   * infinity), the result is the largest representable value of type int.
   *
   * <p>Despite the fact that overflow, underflow, or other loss of information may occur, a
   * narrowing primitive conversion never results in a run-time exception.
   *
   * <p>A missing value in the receiver is converted to a missing value in the result
   */",566-594,"('asIntColumn', {'INSTRUCTION': {'covered': 27, 'missed': 4}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,18.0,"Returns a new IntColumn containing a value for each value in this column, truncating if  necessary.","A new intColumn containing a value for each value in the column is returned. When needed, the truncate operation might be applied.","If necessary, returns a new IntColumn with a value for each value in it.",0.325515867148405,"Returns a new IntColumn containing a value for each value in this column, truncating if necessary."
666,cdk,"private static Trie insert(Trie trie, String str, int i){
    if (trie == null)
        trie = new Trie();
    if (i == str.length()) {
        trie.token = str;
    } else {
        final char c = str.charAt(i);
        trie.children[c] = insert(trie.children[c], str, i + 1);
    }
    return trie;
}",insert,org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,"/**
     * Insert a string (str) into the trie.
     *
     * @param trie trie node
     * @param str  the string to insert
     * @param i    index in the string
     * @return a created child node or null
     */",427-445,"('insert', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,10.0,Insert a string (str) into the trie.,Insert the string given as input into the trie and it returns a new child node.,A string is inserted into the trie.,0.269462279063584,Insert a string (str) into the sort.
667,dcache,"public boolean isParentOf(StatePath otherPath){
    if (otherPath == null) {
        return false;
    }
    if ((_elements.size() + 1) != otherPath._elements.size()) {
        return false;
    }
    for (int i = 0; i < _elements.size(); i++) {
        if (_elements.get(i) != otherPath._elements.get(i)) {
            return false;
        }
    }
    return true;
}",isParentOf,org/dcache/services/info/base/StatePath.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StatePath.java,"/**
     * Check whether otherPath points to a location that is a child of this location.  This is true
     * iff each element of this path is identical to the corresponding element in otherPath and
     * otherPath has length precisely greater by one.
     * <pre>
     *  StatePath p1 = new StatePath(""foo.bar"");
     *  StatePath p2 = new StatePath(""foo.bar.baz"");
     *  StatePath p3 = new StatePath(""foo.bar.baz.other"");
     *
     *  p1.isParentOf(p1) // false
     *  p1.isParentOf(p2) // true
     *  p1.isParentOf(p3) // false
     *  p2.isParentOf(p1) // false
     *  p2.isParentOf(p2) // false
     *  p2.isParentOf(p3) // true
     * </pre>
     *
     * @param otherPath
     * @return
     */",229-266,"('isParentOf', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,15.0,Check whether otherPath points to a location that is a child of this location.,Returns true if the object otherPath points to a location that is a child of the current location; false otherwise.,"If otherpath points to a child of this location, you should check it.",0.292471395428758,Check if otherPath points to a location that is a child of that location.
668,tablesaw,"LongColumn timeWindow(ChronoUnit unit, int n, LocalDateTime start){
    String newColumnName = """" + n + "" "" + unit.toString() + "" window ["" + name() + ""]"";
    long packedStartDate = pack(start);
    LongColumn numberColumn = LongColumn.create(newColumnName, size());
    for (int i = 0; i < size(); i++) {
        long packedDate = getLongInternal(i);
        long result;
        switch(unit) {
            case MINUTES:
                result = minutesUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case HOURS:
                result = hoursUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case DAYS:
                result = daysUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case WEEKS:
                result = weeksUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case MONTHS:
                result = monthsUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case YEARS:
                result = yearsUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            default:
                throw new UnsupportedTemporalTypeException(""The ChronoUnit "" + unit + "" is not supported for timeWindows on dates"");
        }
    }
    numberColumn.setPrintFormatter(NumberColumnFormatter.ints());
    return numberColumn;
}",timeWindow,tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,"/**
   * Returns a column containing integers representing the nth group (0-based) that a date falls
   * into.
   *
   * <p>Example: When Unit = ChronoUnit.DAY and n = 5, we form 5 day groups. a Date that is 2 days
   * after the start is assigned to the first (""0"") group. A day 7 days after the start is assigned
   * to the second (""1"") group.
   *
   * @param unit A ChronoUnit greater than or equal to a minute
   * @param n The number of units in each group.
   * @param start The starting point of the first group; group boundaries are offsets from this
   *     point
   */",378-430,"('timeWindow', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",271.0,18.0,Returns a column containing integers representing the nth group (0-based) that a date falls  into.,An integer value representing the number of the column will be returned according to the position the date falls into.,A column containing numbers representing the nth group that a date falls into.,0.403572245159453,Returns a column containing integers representing the nth group (based on 0) in which a date is located.
669,egeria,"private RelationshipsContext buildDataFileContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
    Set<GraphContext> context = new HashSet<>();
    addConnectionToAssetContext(userId, entityDetail, context);
    EntityDetail fileFolder = handlerHelper.addContextForRelationships(userId, entityDetail, NESTED_FILE, context);
    addContextForFileFolder(userId, fileFolder, context);
    return new RelationshipsContext(entityDetail.getGUID(), context);
}",buildDataFileContext,org/odpi/openmetadata/accessservices/assetlineage/handlers/AssetContextHandler.java,/open-metadata-implementation/access-services/asset-lineage/asset-lineage-server/src/main/java/org/odpi/openmetadata/accessservices/assetlineage/handlers/AssetContextHandler.java,"/**
     * Builds the data file context for a tabular column.
     *
     * @param userId       the unique identifier for the user
     * @param entityDetail the entity for which the context is build
     *
     * @return the data file context of the tabular column
     *
     * @throws OCFCheckedExceptionBase checked exception for reporting errors found when using OCF connectors
     */",305-325,"('buildDataFileContext', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,10.0,Builds the data file context for a tabular column.,Builds and returns the data file context for a tabular column.,The data file context is built.,0.0955800495017509,Generates the context of the data file for a tabular column.
674,jooby,"static List<String> expandOptionalVariables(@Nonnull String pattern){
    if (pattern == null || pattern.isEmpty() || pattern.equals(""/"")) {
        return Collections.singletonList(""/"");
    }
    int len = pattern.length();
    AtomicInteger key = new AtomicInteger();
    Map<Integer, StringBuilder> paths = new HashMap<>();
    BiConsumer<Integer, StringBuilder> pathAppender = (index, segment) -> {
        for (int i = index; i < index - 1; i++) {
            paths.get(i).append(segment);
        }
        paths.computeIfAbsent(index, current -> {
            StringBuilder value = new StringBuilder();
            if (current > 0) {
                StringBuilder previous = paths.get(current - 1);
                if (!previous.toString().equals(""/"")) {
                    value.append(previous);
                }
            }
            return value;
        }).append(segment);
    };
    StringBuilder segment = new StringBuilder();
    boolean isLastOptional = false;
    for (int i = 0; i < len; ) {
        char ch = pattern.charAt(i);
        if (ch == '/') {
            if (segment.length() > 0) {
                pathAppender.accept(key.get(), segment);
                segment.setLength(0);
            }
            segment.append(ch);
            i += 1;
        } else if (ch == '{') {
            segment.append(ch);
            int curly = 1;
            int j = i + 1;
            while (j < len) {
                char next = pattern.charAt(j++);
                segment.append(next);
                if (next == '{') {
                    curly += 1;
                } else if (next == '}') {
                    curly -= 1;
                    if (curly == 0) {
                        break;
                    }
                }
            }
            if (j < len && pattern.charAt(j) == '?') {
                j += 1;
                isLastOptional = true;
                if (paths.isEmpty()) {
                    paths.put(0, new StringBuilder(""/""));
                }
                pathAppender.accept(key.incrementAndGet(), segment);
            } else {
                isLastOptional = false;
                pathAppender.accept(key.get(), segment);
            }
            segment.setLength(0);
            i = j;
        } else {
            segment.append(ch);
            i += 1;
        }
    }
    if (paths.isEmpty()) {
        return Collections.singletonList(pattern);
    }
    if (segment.length() > 0) {
        pathAppender.accept(key.get(), segment);
        if (isLastOptional) {
            paths.put(key.incrementAndGet(), segment);
        }
    }
    return paths.values().stream().map(StringBuilder::toString).collect(Collectors.toList());
}",expandOptionalVariables,io/jooby/Router.java,/jooby/src/main/java/io/jooby/Router.java,"/**
   * Look for optional path parameter and expand the given pattern into multiple pattern.
   *
   * <pre>
   *   /path =&gt; [/path]
   *   /{id} =&gt; [/{id}]
   *   /path/{id} =&gt; [/path/{id}]
   *
   *   /{id}? =&gt; [/, /{id}]
   *   /path/{id}? =&gt; [/path, /path/{id}]
   *   /path/{id}/{start}?/{end}? =&gt; [/path/{id}, /path/{id}/{start}, /path/{id}/{start}/{end}]
   *   /path/{id}?/suffix =&gt; [/path, /path/{id}, /path/suffix]
   * </pre>
   *
   * @param pattern Pattern.
   * @return One or more patterns.
   */",1174-1270,"('expandOptionalVariables', {'INSTRUCTION': {'covered': 183, 'missed': 0}, 'BRANCH': {'covered': 33, 'missed': 1}, 'LINE': {'covered': 53, 'missed': 0}, 'COMPLEXITY': {'covered': 17, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",565.0,14.0,Look for optional path parameter and expand the given pattern into multiple pattern.,"Searches for optional path parameters, and it grows the given pattern into several of these.","If you want to expand the pattern into multiple patterns, look for optional path parameters.",0.420741924919468,Locate the optional path parameter and expand the given template into multiple templates.
675,cdk,"public DescriptorValue calculate(IAtomContainer atomContainer){
    if (checkRingSystem)
        Cycles.markRingAtomsAndBonds(atomContainer);
    final Set<IAtom> included = new HashSet<>();
    for (IAtom atom : atomContainer.atoms()) {
        if (!atom.isInRing() && atom.getAtomicNumber() != 1)
            included.add(atom);
    }
    IAtomContainer subset = subsetMol(atomContainer, included);
    AllPairsShortestPaths apsp = new AllPairsShortestPaths(subset);
    int max = 0;
    int numAtoms = subset.getAtomCount();
    for (int i = 0; i < numAtoms; i++) {
        for (int j = i + 1; j < numAtoms; j++) {
            int len = apsp.from(i).pathTo(j).length;
            if (len > max)
                max = len;
        }
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(max), getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/LargestChainDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/LargestChainDescriptor.java,"/**
     * Calculate the count of atoms of the largest chain in the supplied {@link IAtomContainer}.
     *
     * @param atomContainer The {@link IAtomContainer} for which this descriptor is to be calculated
     * @return the number of atoms in the largest chain of this AtomContainer
     * @see #setParameters
     */",149-184,"('calculate', {'INSTRUCTION': {'covered': 92, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",192.0,18.0,Calculate the count of atoms of the largest chain in the supplied {@link IAtomContainer}.,Computes the count of largest atom's chain in the provided IAtomCointainer.,The supplied IAtomContainer has a count of the largest chain.,0.536082797090362,Calculate the number of atoms of the largest chain in the provided {@link IAtomContainer}.
676,jeromq,"public static boolean startsWith(Msg msg, String data, boolean includeLength){
    final int length = data.length();
    assert (length < 256);
    int start = includeLength ? 1 : 0;
    if (msg.size() < length + start) {
        return false;
    }
    boolean comparison = includeLength ? length == (msg.get(0) & 0xff) : true;
    if (comparison) {
        for (int idx = start; idx < length; ++idx) {
            comparison = (msg.get(idx) == data.charAt(idx - start));
            if (!comparison) {
                break;
            }
        }
    }
    return comparison;
}",startsWith,zmq/io/Msgs.java,/src/main/java/zmq/io/Msgs.java,"/**
     * Checks if the message starts with the given string.
     *
     * @param msg the message to check.
     * @param data the string to check the message with. Shall be shorter than 256 characters.
     * @param includeLength true if the string in the message is prefixed with the length, false if not.
     * @return true if the message starts with the given string, otherwise false.
     */",12-39,"('startsWith', {'INSTRUCTION': {'covered': 62, 'missed': 6}, 'BRANCH': {'covered': 17, 'missed': 3}, 'LINE': {'covered': 11, 'missed': 1}, 'COMPLEXITY': {'covered': 8, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",133.0,10.0,Checks if the message starts with the given string.,"Returns true if the message starts with the string provided as input, false otherwise","If the message starts with a string, it's checked.",0.0674189870349301,Checks whether the message starts with the given string.
679,cdk,"public static float[] generateMoments(IAtomContainer atomContainer) throws CDKException{
    // lets check if we have 3D coordinates
    Iterator<IAtom> atoms;
    int natom = atomContainer.getAtomCount();
    Point3d ctd = getGeometricCenter(atomContainer);
    Point3d cst = new Point3d();
    Point3d fct = new Point3d();
    Point3d ftf = new Point3d();
    double[] distCtd = new double[natom];
    double[] distCst = new double[natom];
    double[] distFct = new double[natom];
    double[] distFtf = new double[natom];
    atoms = atomContainer.atoms().iterator();
    int counter = 0;
    double min = Double.MAX_VALUE;
    double max = Double.MIN_VALUE;
    // eval dist to centroid
    while (atoms.hasNext()) {
        IAtom atom = atoms.next();
        Point3d p = atom.getPoint3d();
        double d = p.distance(ctd);
        distCtd[counter++] = d;
        if (d < min) {
            cst.x = p.x;
            cst.y = p.y;
            cst.z = p.z;
            min = d;
        }
        if (d > max) {
            fct.x = p.x;
            fct.y = p.y;
            fct.z = p.z;
            max = d;
        }
    }
    // eval dist to cst
    atoms = atomContainer.atoms().iterator();
    counter = 0;
    while (atoms.hasNext()) {
        IAtom atom = atoms.next();
        Point3d p = atom.getPoint3d();
        double d = p.distance(cst);
        distCst[counter++] = d;
    }
    // eval dist to fct
    atoms = atomContainer.atoms().iterator();
    counter = 0;
    max = Double.MIN_VALUE;
    while (atoms.hasNext()) {
        IAtom atom = atoms.next();
        Point3d p = atom.getPoint3d();
        double d = p.distance(fct);
        distFct[counter++] = d;
        if (d > max) {
            ftf.x = p.x;
            ftf.y = p.y;
            ftf.z = p.z;
            max = d;
        }
    }
    // eval dist to ftf
    atoms = atomContainer.atoms().iterator();
    counter = 0;
    while (atoms.hasNext()) {
        IAtom atom = atoms.next();
        Point3d p = atom.getPoint3d();
        double d = p.distance(ftf);
        distFtf[counter++] = d;
    }
    float[] moments = new float[12];
    float mean = mu1(distCtd);
    float sigma2 = mu2(distCtd, mean);
    float skewness = mu3(distCtd, mean, Math.sqrt(sigma2));
    moments[0] = mean;
    moments[1] = sigma2;
    moments[2] = skewness;
    mean = mu1(distCst);
    sigma2 = mu2(distCst, mean);
    skewness = mu3(distCst, mean, Math.sqrt(sigma2));
    moments[3] = mean;
    moments[4] = sigma2;
    moments[5] = skewness;
    mean = mu1(distFct);
    sigma2 = mu2(distFct, mean);
    skewness = mu3(distFct, mean, Math.sqrt(sigma2));
    moments[6] = mean;
    moments[7] = sigma2;
    moments[8] = skewness;
    mean = mu1(distFtf);
    sigma2 = mu2(distFtf, mean);
    skewness = mu3(distFtf, mean, Math.sqrt(sigma2));
    moments[9] = mean;
    moments[10] = sigma2;
    moments[11] = skewness;
    return moments;
}",generateMoments,org/openscience/cdk/similarity/DistanceMoment.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/similarity/DistanceMoment.java,"/**
     * Evaluate the 12 descriptors used to characterize the 3D shape of a molecule.
     *
     * @param atomContainer The molecule to consider, should have 3D coordinates
     * @return A 12 element array containing the descriptors.
     * @throws CDKException if there are no 3D coordinates
     */",81-199,"('generateMoments', {'INSTRUCTION': {'covered': 311, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 85, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",711.0,14.0,Evaluate the 12 descriptors used to characterize the 3D shape of a molecule.,The method helps in evaluating the 12 descriptors that are used to distinguish the 3D shape of a molecule.,Evaluate the 12 descriptors used to make a molecule.,0.481512051991809,Evaluate the 12 descriptors used to characterize the 3D shape of a molecule.
680,acs-aem-commons,"public static void write(Layer layer, double quality, OutputStream out) throws IOException{
    ImageWriter writer = null;
    ImageOutputStream imageOut = null;
    try {
        ImageWriteParam iwp = new JPEGImageWriteParam(null);
        iwp.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
        iwp.setProgressiveMode(ImageWriteParam.MODE_DEFAULT);
        iwp.setCompressionQuality((float) quality);
        writer = ImageIO.getImageWritersBySuffix(""jpeg"").next();
        imageOut = ImageIO.createImageOutputStream(out);
        writer.setOutput(imageOut);
        BufferedImage image = getRgbImage(layer);
        writer.write(null, new IIOImage(image, null, null), iwp);
    } finally {
        if (writer != null) {
            writer.dispose();
        }
        if (imageOut != null) {
            try {
                imageOut.close();
            } catch (IOException e) {
                // ignore
            }
        }
    }
}",write,com/adobe/acs/commons/images/impl/ProgressiveJpeg.java,/bundle/src/main/java/com/adobe/acs/commons/images/impl/ProgressiveJpeg.java,"/**
     * For JPEG images, this method behaves similar to {@link Layer#write(String, double, OutputStream)}. The major
     * difference is that it uses progressive encoding.
     *
     * @param layer   the layer with the image to write to the output stream
     * @param quality JPEG compression quality between 0 and 1
     * @param out     target output stream
     * @throws IOException if anything goes wrong
     */",43-80,"('write', {'INSTRUCTION': {'covered': 53, 'missed': 1}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 17, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",165.0,24.0,"For JPEG images, this method behaves similar to {@link Layer#write(String, double, OutputStream)}.",Writes a JPEG image using a progressive encoding.,"This method behaves similar to @link Layer#write(String, double, OutputStream) for JPEG images.",1.13257370480507,"For JPEG images, this method behaves in the same way as {@link Layer#write(String, double, OutputStream)}."
681,cdk,"public double predict(IAtomContainer mol) throws CDKException{
    if (mol == null || mol.getAtomCount() == 0)
        throw new CDKException(""Molecule cannot be blank or null."");
    CircularFingerprinter circ = new CircularFingerprinter(classType);
    circ.setPerceiveStereo(optPerceiveStereo);
    circ.calculate(mol);
    final int AND_BITS = folding - 1;
    Set<Integer> hashset = new HashSet<Integer>();
    for (int n = circ.getFPCount() - 1; n >= 0; n--) {
        int code = circ.getFP(n).hashCode;
        if (folding > 0)
            code &= AND_BITS;
        hashset.add(code);
    }
    double val = 0;
    for (int h : hashset) {
        Double c = contribs.get(h);
        if (c != null)
            val += c;
    }
    return val;
}",predict,org/openscience/cdk/fingerprint/model/Bayesian.java,/tool/model/src/main/java/org/openscience/cdk/fingerprint/model/Bayesian.java,"/**
     * For a given molecule, determines its fingerprints and uses them to calculate a Bayesian prediction. Note that this
     * value is unscaled, and so it only has relative meaning within the confines of the model, i.e. higher is more likely to
     * be active.
     * 
     * @param mol molecular structure which cannot be blank or null
     * @return predictor value
     */",265-297,"('predict', {'INSTRUCTION': {'covered': 83, 'missed': 5}, 'BRANCH': {'covered': 8, 'missed': 4}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",165.0,17.0,"For a given molecule, determines its fingerprints and uses them to calculate a Bayesian prediction.",Using a Bayesian prediction schema computes the molecule's fingerprint.,A molecule's fingerprints are used to calculate a prediction.,0.296310049973236,"For a given molecule, determines its fingerprints and uses them to calculate a Bayesian prediction."
682,cdk,"private static int readMolfileInt(final String line, final int index){
    int sign = 1;
    int result = 0;
    char c;
    switch((c = line.charAt(index))) {
        case ' ':
            break;
        case '-':
            sign = -1;
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            result = (c - '0');
            break;
        default:
            return 0;
    }
    if (index + 1 == line.length())
        return sign * result;
    switch((c = line.charAt(index + 1))) {
        case ' ':
            if (result > 0)
                return sign * result;
            break;
        case '-':
            if (result > 0)
                return sign * result;
            sign = -1;
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            result = (result * 10) + (c - '0');
            break;
        default:
            return sign * result;
    }
    if (index + 2 == line.length())
        return sign * result;
    switch((c = line.charAt(index + 2))) {
        case ' ':
            if (result > 0)
                return sign * result;
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            result = (result * 10) + (c - '0');
            break;
        default:
            return sign * result;
    }
    return sign * result;
}",readMolfileInt,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Optimised method for reading a integer from 3 characters in a string at a
     * specified index. MDL V2000 Molfile make heavy use of the 3 character ints
     * in the atom/bond and property blocks. The integer may be signed and
     * pre/post padded with white space.
     *
     * @param line  input
     * @param index start index
     * @return the value specified in the string
     */",1687-1769,"('readMolfileInt', {'INSTRUCTION': {'covered': 89, 'missed': 19}, 'BRANCH': {'covered': 16, 'missed': 5}, 'LINE': {'covered': 22, 'missed': 5}, 'COMPLEXITY': {'covered': 9, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",335.0,17.0,Optimised method for reading a integer from 3 characters in a string at a  specified index.,Reads and returns an integer from the starting index position given as input down to its +3 characaters.,The method for reading a string from 3 characters is improved.,1.72061288905061,Optimized method to read an integer from 3 characters in a string at a specified index.
683,glowstone,"private void processArmorChanges(){
    GlowPlayer player = null;
    if (this instanceof GlowPlayer) {
        player = ((GlowPlayer) this);
    }
    boolean armorUpdate = false;
    List<EquipmentMonitor.Entry> armorChanges = getEquipmentMonitor().getArmorChanges();
    if (armorChanges.size() > 0) {
        for (EquipmentMonitor.Entry entry : armorChanges) {
            if (player != null && needsArmorUpdate) {
                player.getSession().send(new EntityEquipmentMessage(0, entry.slot, entry.item));
            }
            armorUpdate = true;
        }
    }
    if (armorUpdate) {
        getAttributeManager().setProperty(AttributeManager.Key.KEY_ARMOR, ArmorConstants.getDefense(getEquipment().getArmorContents()));
        getAttributeManager().setProperty(AttributeManager.Key.KEY_ARMOR_TOUGHNESS, ArmorConstants.getToughness(getEquipment().getArmorContents()));
    }
    needsArmorUpdate = true;
}",processArmorChanges,net/glowstone/entity/GlowHumanEntity.java,/src/main/java/net/glowstone/entity/GlowHumanEntity.java,"/**
     * Process changes to the human enitity's armor, and update the entity's armor attributes
     * accordingly.
     */",191-217,"('processArmorChanges', {'INSTRUCTION': {'covered': 70, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 4}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",172.0,18.0,"Process changes to the human enitity's armor, and update the entity's armor attributes  accordingly.",The method changes the human entity's armor and updates the entity's armor attributes.,"Process changes to the human enitity's armor, and update the entity's armor attributes accordingly.",0.584180218490568,Process changes to the human entity's armor and update the entity's armor attributes accordingly.
684,cdk,"public Permutation multiply(Permutation other){
    Permutation newPermutation = new Permutation(values.length);
    for (int i = 0; i < values.length; i++) {
        newPermutation.values[i] = this.values[other.values[i]];
    }
    return newPermutation;
}",multiply,org/openscience/cdk/group/Permutation.java,/tool/group/src/main/java/org/openscience/cdk/group/Permutation.java,"/**
     * Multiply this permutation by another such that for all i,
     * this[i] = this[other[i]].
     *
     * @param other the other permutation to use
     * @return a new permutation with the result of multiplying the permutations
     */",197-210,"('multiply', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,24.0,"Multiply this permutation by another such that for all i,  this[i] = this[other[i]].",Returns a new permutation representing the results of multiplying such a permutation with the parameter given as input (other).,"If you add this permutation to another, you get this other.",0.477751690973469,"Multiply this permutation by another such that for any i, this[i] = this[other[i]]."
685,egeria,"private RelationshipsContext buildRelationalTableContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
    Set<GraphContext> context = new HashSet<>();
    EntityDetail schemaType = handlerHelper.addContextForRelationships(userId, entityDetail, ATTRIBUTE_FOR_SCHEMA, context);
    EntityDetail deployedSchemaType = handlerHelper.addContextForRelationships(userId, schemaType, ASSET_SCHEMA_TYPE, context);
    EntityDetail database = handlerHelper.addContextForRelationships(userId, deployedSchemaType, DATA_CONTENT_FOR_DATA_SET, context);
    if (database != null) {
        addConnectionToAssetContext(userId, database, context);
    }
    return new RelationshipsContext(entityDetail.getGUID(), context);
}",buildRelationalTableContext,org/odpi/openmetadata/accessservices/assetlineage/handlers/AssetContextHandler.java,/open-metadata-implementation/access-services/asset-lineage/asset-lineage-server/src/main/java/org/odpi/openmetadata/accessservices/assetlineage/handlers/AssetContextHandler.java,"/**
     * Builds the relational table context for a relational column.
     *
     * @param userId       the unique identifier for the user
     * @param entityDetail the entity for which the context is build
     *
     * @return the relational table context of the relational column
     *
     * @throws OCFCheckedExceptionBase checked exception for reporting errors found when using OCF connectors
     */",264-288,"('buildRelationalTableContext', {'INSTRUCTION': {'covered': 42, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,10.0,Builds the relational table context for a relational column.,"Sets a new relational table context for a relational column. Than, return such a new table.",The context for a column in the table is built.,0.19475915921374,Generates the relational table context for a relational column.
686,matsim-libs,"public boolean replanCurrentLegRoute(Leg leg, Person person, int currentLinkIndex, double time){
    Route route = leg.getRoute();
    if (!(route instanceof NetworkRoute)) {
        log.warn(""route not instance of NetworkRoute"");
        return false;
    }
    return relocateCurrentLegRoute(leg, person, currentLinkIndex, route.getEndLinkId(), time);
}",replanCurrentLegRoute,org/matsim/withinday/utils/EditRoutes.java,/matsim/src/main/java/org/matsim/withinday/utils/EditRoutes.java,"/**
	 * We create a new Plan which contains only the Leg that should be replanned and its previous and next
	 * Activities. By doing so the PlanAlgorithm will only change the Route of that Leg.
	 *
	 * Use currentNodeIndex from a DriverAgent if possible!
	 *
	 * Otherwise code it as following:
	 * startLink - Node1 - routeLink1 - Node2 - routeLink2 - Node3 - endLink
	 * The currentNodeIndex has to Point to the next Node
	 * (which is the endNode of the current Link)
	 */",352-376,"('replanCurrentLegRoute', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,21.0,We create a new Plan which contains only the Leg that should be replanned and its previous and next  Activities.,"Returns true if the newly created plan contains only the leg that should be replanned with all its previous and subsequent activities. False, otherwise.",We create a new plan that only has the Leg that should be replanned and its previous and next activities.,0.188782948125546,We create a new plan that contains only the leg that should be replanned and its previous and subsequent activities.
687,cdk,"static Vector2d scale(final Tuple2d vector, final double factor){
    final Vector2d cpy = new Vector2d(vector);
    cpy.scale(factor);
    return cpy;
}",scale,org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,"/**
     * Scale a vector by a given factor, the input vector is not modified.
     *
     * @param vector a vector to scale
     * @param factor how much the input vector should be scaled
     * @return scaled vector
     */",135-146,"('scale', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,15.0,"Scale a vector by a given factor, the input vector is not modified.",Creates and returns a new vector representing a scaled version of the one given as input.,The input is not modified when scales a vector by a factor.,0.362141942345613,"Scaling a vector by a given factor, the input vector is not modified."
688,acs-aem-commons,"private Optional<Class> upgradeToArray(Optional<Class> a, Optional<Class> b){
    if (!a.isPresent()) {
        return b;
    }
    if (!b.isPresent()) {
        return a;
    }
    if (a.get().equals(b.get()) || b.get() == Object.class) {
        return getArrayType(a);
    } else {
        return getArrayType(b);
    }
}",upgradeToArray,com/adobe/acs/commons/data/Spreadsheet.java,/bundle/src/main/java/com/adobe/acs/commons/data/Spreadsheet.java,"/**
     * Consider if a column is seen twice then that column type should be
     * considered an array. Because String is a default assumption when no type
     * is specified, any redefinition of a column to a more specific type will
     * be then assumed for that property altogether.
     *
     * @param a
     * @param b
     * @return
     */",374-396,"('upgradeToArray', {'INSTRUCTION': {'covered': 20, 'missed': 7}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 4, 'missed': 3}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",93.0,17.0,Consider if a column is seen twice then that column type should be  considered an array.,"Checks whether a column is seen twice. If so, the column type should be considered as an array.","If a column is seen twice, then it should be considered an array.",0.167183413713482,"Consider if a column is viewed twice, this type of column should be considered a table."
689,weblogic-kubernetes-operator," static WlsClusterConfig create(Map<String, Object> clusterConfigMap, Map<String, WlsServerConfig> serverTemplates, String domainName){
    String clusterName = (String) clusterConfigMap.get(""name"");
    WlsDynamicServersConfig dynamicServersConfig = WlsDynamicServersConfig.create((Map<String, Object>) clusterConfigMap.get(""dynamicServers""), serverTemplates, clusterName, domainName);
    // set dynamicServersConfig only if the cluster contains dynamic servers, i.e., its dynamic
    // servers configuration
    // contains non-null server template name
    if (dynamicServersConfig.getServerTemplate() == null) {
        dynamicServersConfig = null;
    }
    return new WlsClusterConfig(clusterName, dynamicServersConfig);
}",create,oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,"/**
   * Creates a WlsClusterConfig object using an ""clusters"" item parsed from JSON result from WLS
   * REST call.
   *
   * @param clusterConfigMap Map containing ""cluster"" item parsed from JSON result from WLS REST
   *     call
   * @param serverTemplates Map containing all server templates configuration read from the WLS
   *     domain
   * @param domainName Name of the WLS domain that this WLS cluster belongs to
   * @return A new WlsClusterConfig object created based on the JSON result
   */",53-83,"('create', {'INSTRUCTION': {'covered': 23, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,19.0,"Creates a WlsClusterConfig object using an ""clusters"" item parsed from JSON result from WLS  REST call.","Generates and returns a new WisClusterConfig object using a ""clusters"" item that has been previously parsed from JSON result from WLS REST call.","The object is created using a ""clusters"" item from the WLS call.",0.442807941150879,"Creates a WlsClusterConfig object using a crawled ""clusters"" element from the JSON result of the WLS REST call."
690,anserini,"public Map<String, Result[]> batchSearchFields(List<String> queries, List<String> qids, int k, int threads, Map<String, Float> fields){
    QueryGenerator generator = new BagOfWordsQueryGenerator();
    return batchSearchFields(generator, queries, qids, k, threads, fields);
}",batchSearchFields,io/anserini/search/SimpleSearcher.java,/src/main/java/io/anserini/search/SimpleSearcher.java,"/**
   * Searches the provided fields weighted by their boosts, using multiple threads.
   * Batch version of {@link #searchFields(String, Map, int)}.
   *
   * @param queries list of queries
   * @param qids list of unique query ids
   * @param k number of hits
   * @param threads number of threads
   * @param fields map of fields to search with weights
   * @return a map of query id to search results
   */",438-453,"('batchSearchFields', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",63.0,13.0,"Searches the provided fields weighted by their boosts, using multiple threads.",Returns a map of the query IDs matching the provided fields weighted by their boost.,The fields are weighted by their boost.,1.23640044776934,"Searches for the provided fields weighted by their boosts, using multiple threads."
691,cdk,"public void removeListener(IChemObjectListener col){
    if (chemObjectListeners == null) {
        return;
    }
    List<IChemObjectListener> listeners = lazyChemObjectListeners();
    if (listeners.contains(col)) {
        listeners.remove(col);
    }
}",removeListener,org/openscience/cdk/ChemObject.java,/base/data/src/main/java/org/openscience/cdk/ChemObject.java,"/**
     *  Use this to remove a ChemObjectListener from the ListenerList of this
     *  IChemObject. It will then not be notified of change in this object anymore.
     *
     *@param  col  The ChemObjectListener to be removed
     *@see         #addListener
     */",150-167,"('removeListener', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,13.0,Use this to remove a ChemObjectListener from the ListenerList of this  IChemObject.,Remove an element from the ListenerList of the given object.,This can be used to remove a ChemObjectListener from the Listener List.,0.681545904504381,Use this option to remove a ChemObjectListener from the ListenerList of that IChemObject.
692,acs-aem-commons,"protected String generatedNodeChecksum(final String aggregateNodePath, final Node node, final ChecksumGeneratorOptions options) throws RepositoryException, IOException{
    if (isExcludedSubTree(node, options)) {
        return """";
    }
    final Map<String, String> checksums = new LinkedHashMap<>();
    if (!isExcludedNodeName(node, options)) {
        final String checksum = generatePropertyChecksums(aggregateNodePath, node, options);
        if (checksum != null) {
            checksums.put(getChecksumKey(aggregateNodePath, node.getPath()), checksum);
        }
    }
    final Map<String, String> lexicographicallySortedChecksums = new TreeMap<>();
    final boolean hasOrderedChildren = hasOrderedChildren(node);
    final NodeIterator children = node.getNodes();
    while (children.hasNext()) {
        final Node child = children.nextNode();
        if (isExcludedSubTree(child, options)) {
        } else if (!isExcludedNodeType(child, options)) {
            if (hasOrderedChildren) {
                final String checksum = generatedNodeChecksum(aggregateNodePath, child, options);
                if (checksum != null) {
                    checksums.put(getChecksumKey(aggregateNodePath, child.getPath()), checksum);
                    log.debug(""Aggregated Ordered Node: {} ~> {}"", getChecksumKey(aggregateNodePath, child.getPath()), checksum);
                }
            } else {
                final String checksum = generatedNodeChecksum(aggregateNodePath, child, options);
                if (checksum != null) {
                    lexicographicallySortedChecksums.put(getChecksumKey(aggregateNodePath, child.getPath()), checksum);
                    log.debug(""Aggregated Unordered Node: {} ~> {}"", getChecksumKey(aggregateNodePath, child.getPath()), checksum);
                }
            }
        }
    }
    if (!hasOrderedChildren && lexicographicallySortedChecksums.size() > 0) {
        checksums.putAll(lexicographicallySortedChecksums);
    }
    final String nodeChecksum = aggregateChecksums(checksums);
    log.debug(""Node [ {} ] has a aggregated checksum of [ {} ]"", getChecksumKey(aggregateNodePath, node.getPath()), nodeChecksum);
    return nodeChecksum;
}",generatedNodeChecksum,com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,"/**
     * Generates a checksum for a single node and its node sub-system, respecting the options.
     * @param aggregateNodePath the absolute path of the node being aggregated into a checksum
     * @param node the node whose subsystem to create a checksum for
     * @param options the {@link ChecksumGeneratorOptions} options
     * @return a map containing 1 entry in the form [ node.getPath() ] : [ CHECKSUM OF NODE SYSTEM ]
     * @throws RepositoryException
     * @throws IOException
     */",159-230,"('generatedNodeChecksum', {'INSTRUCTION': {'covered': 138, 'missed': 2}, 'BRANCH': {'covered': 19, 'missed': 3}, 'LINE': {'covered': 31, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",363.0,16.0,"Generates a checksum for a single node and its node sub-system, respecting the options.",Generate a checksum for a single node and its nested one,A single checksum is generated for a single system.,0.73595743179915,"Generates a checksum for a single node and its node subsystem, respecting the options."
693,glowstone,"public boolean readFloat(@NonNls String key, FloatConsumer consumer){
    if (isFloat(key)) {
        consumer.accept(getFloat(key));
        return true;
    }
    return false;
}",readFloat,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to a float subtag if it is present.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */",372-386,"('readFloat', {'INSTRUCTION': {'covered': 11, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,13.0,Applies the given function to a float subtag if it is present.,Add a key to a float subtag if present,"If the function is present, apply it to the float subtag.",0.272370444749086,Applies the given function to a float subtag if it is present.
694,matsim-libs,"public void finish(){
    if (iteration == -1) {
        throw new RuntimeException(""Please initialize me before the iteration starts."");
    }
    controlerListenerManager.fireControlerAfterMobsimEvent(iteration, isLastIteration);
    scoringFunctionsForPopulation.finishScoringFunctions();
    newScoreAssigner.assignNewScores(this.iteration, scoringFunctionsForPopulation, population);
    finished = true;
}",finish,org/matsim/core/scoring/EventsToScore.java,/matsim/src/main/java/org/matsim/core/scoring/EventsToScore.java,"/**
	 * Finishes the calculation of the plans' scores and assigns the new scores
	 * to the plans if desired.
	 */",116-128,"('finish', {'INSTRUCTION': {'covered': 27, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,19.0,Finishes the calculation of the plans' scores and assigns the new scores  to the plans if desired.,Complete the calculation of the plans' scores and prepare for the new iteration if requried,"If you want, assign the new scores to the plans.",0.213211098090783,Finish calculating the scores of the plans and assign the new scores to the plans if you wish.
696,jackson-databind,"public ObjectReader readerForListOf(Class<?> type){
    return _newReader(getDeserializationConfig(), _typeFactory.constructCollectionType(List.class, type), null, null, _injectableValues);
}",readerForListOf,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Factory method for constructing {@link ObjectReader} that will
     * read or update instances of a type {@code List<type>}.
     * Functionally same as:
     *<pre>
     *    readerFor(new TypeReference&lt;List&lt;type&gt;&gt;() { });
     *</pre>
     *
     * @since 2.11
     */",4161-4175,"('readerForListOf', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,27.0,Factory method for constructing {@link ObjectReader} that will  read or update instances of a type {@code List<type>}.,Factory constructor for object of type ObjectReader that will read or update instances of type List<type>,The method for constructing @link ObjectReader will read or update instances of a type.,1.04000551532831,A factory method for constructing {@link ObjectReader} that will read or update instances of a {@code List<type>} type.
697,cdk,"public static List<Map<Integer, Integer>> filter(List<List<Integer>> mappings){
    FinalMappings finalMappings = FinalMappings.getInstance();
    if (mappings != null && !mappings.isEmpty()) {
        finalMappings.set(removeRedundantMapping(mappings));
        mappings.clear();
    } else {
        finalMappings.set(new ArrayList<Map<Integer, Integer>>());
    }
    return finalMappings.getFinalMapping();
}",filter,org/openscience/cdk/smsd/filters/PostFilter.java,/legacy/src/main/java/org/openscience/cdk/smsd/filters/PostFilter.java,"/**
     *
     * Creates a new instance of Post Filter and removes
     * redundant mapping(s).
     *
     * @param mappings
     * @return Filtered non-redundant mappings
     */",51-68,"('filter', {'INSTRUCTION': {'covered': 17, 'missed': 5}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 5, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,15.0,Creates a new instance of Post Filter and removes  redundant mapping(s).,Generate a new object of type PostFilter and remove reduntances,A new instance of Post Filter is created.,0.808242215916587,Creates an instance of Post Filter and removes the redundant mapping(s).
698,jooby,"public Path export(@Nonnull OpenAPI openAPI, @Nonnull Format format) throws IOException{
    Path output;
    if (openAPI instanceof OpenAPIExt) {
        String source = ((OpenAPIExt) openAPI).getSource();
        String[] names = source.split(""\\."");
        output = Stream.of(names).limit(names.length - 1).reduce(outputDir, Path::resolve, Path::resolve);
        String appname = names[names.length - 1];
        if (appname.endsWith(""Kt"")) {
            appname = appname.substring(0, appname.length() - 2);
        }
        output = output.resolve(appname + ""."" + format.extension());
    } else {
        output = outputDir.resolve(""openapi."" + format.extension());
    }
    if (!Files.exists(output.getParent())) {
        Files.createDirectories(output.getParent());
    }
    String content = format.toString(this, openAPI);
    Files.write(output, Collections.singleton(content));
    return output;
}",export,io/jooby/openapi/OpenAPIGenerator.java,/modules/jooby-openapi/src/main/java/io/jooby/openapi/OpenAPIGenerator.java,"/**
   * Export an {@link OpenAPI} model to the given format.
   *
   * @param openAPI Model.
   * @param format Format.
   * @throws IOException
   * @return Output file.
   */",132-163,"('export', {'INSTRUCTION': {'covered': 78, 'missed': 21}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 14, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",217.0,13.0,Export an {@link OpenAPI} model to the given format.,Export an OpenAPI object in the required format,The model should be exported to the given format.,0.782738905185232,Export a {@link OpenAPI} template in the given format.
699,matsim-libs,"public static List<ModelLane> createLanes(Link link, LanesToLinkAssignment lanesToLinkAssignment){
    List<ModelLane> queueLanes = new ArrayList<>();
    List<Lane> sortedLanes = new ArrayList<>(lanesToLinkAssignment.getLanes().values());
    sortedLanes.sort(Comparator.comparingDouble(Lane::getStartsAtMeterFromLinkEnd).thenComparing((l1, l2) -> {
        boolean l1Outgoing = l1.getToLinkIds() != null && !l1.getToLinkIds().isEmpty();
        boolean l2Outgoing = l2.getToLinkIds() != null && !l2.getToLinkIds().isEmpty();
        if (l1Outgoing && !l2Outgoing)
            return -1;
        else if (l2Outgoing && !l1Outgoing)
            return 1;
        else
            return 0;
    }));
    Collections.reverse(sortedLanes);
    List<ModelLane> laneList = new LinkedList<>();
    Lane firstLane = sortedLanes.remove(0);
    if (firstLane.getStartsAtMeterFromLinkEnd() != link.getLength()) {
        throw new IllegalStateException(""First Lane Id "" + firstLane.getId() + "" on Link Id "" + link.getId() + ""isn't starting at the beginning of the link!"");
    }
    ModelLane firstQLane = new ModelLane(firstLane);
    laneList.add(firstQLane);
    Stack<ModelLane> laneStack = new Stack<>();
    while (!laneList.isEmpty()) {
        ModelLane lastQLane = laneList.remove(0);
        laneStack.push(lastQLane);
        queueLanes.add(lastQLane);
        List<Id<Lane>> toLaneIds = lastQLane.getLaneData().getToLaneIds();
        double nextMetersFromLinkEnd = 0.0;
        double laneLength = 0.0;
        if (toLaneIds != null && (!toLaneIds.isEmpty())) {
            for (Id<Lane> toLaneId : toLaneIds) {
                Lane currentLane = lanesToLinkAssignment.getLanes().get(toLaneId);
                nextMetersFromLinkEnd = currentLane.getStartsAtMeterFromLinkEnd();
                ModelLane currentQLane = new ModelLane(currentLane);
                laneList.add(currentQLane);
                lastQLane.addAToLane(currentQLane);
            }
            laneLength = lastQLane.getLaneData().getStartsAtMeterFromLinkEnd() - nextMetersFromLinkEnd;
            lastQLane.setEndsAtMetersFromLinkEnd(nextMetersFromLinkEnd);
        } else {
            laneLength = lastQLane.getLaneData().getStartsAtMeterFromLinkEnd();
            lastQLane.setEndsAtMetersFromLinkEnd(0.0);
        }
        lastQLane.setLength(laneLength);
    }
    while (!laneStack.isEmpty()) {
        ModelLane qLane = laneStack.pop();
        if (qLane.getToLanes() == null || (qLane.getToLanes().isEmpty())) {
            for (Id<Link> toLinkId : qLane.getLaneData().getToLinkIds()) {
                qLane.addDestinationLink(toLinkId);
            }
        } else {
            for (ModelLane subsequentLane : qLane.getToLanes()) {
                for (Id<Link> toLinkId : subsequentLane.getDestinationLinkIds()) {
                    qLane.addDestinationLink(toLinkId);
                }
            }
        }
    }
    Collections.sort(queueLanes, new Comparator<ModelLane>() {

        @Override
        public int compare(ModelLane o1, ModelLane o2) {
            if (o1.getEndsAtMeterFromLinkEnd() < o2.getEndsAtMeterFromLinkEnd()) {
                return -1;
            } else if (o1.getEndsAtMeterFromLinkEnd() > o2.getEndsAtMeterFromLinkEnd()) {
                return 1;
            } else {
                return 0;
            }
        }
    });
    return queueLanes;
}",createLanes,org/matsim/lanes/LanesUtils.java,/matsim/src/main/java/org/matsim/lanes/LanesUtils.java,"/**
	 * Creates a sorted list of lanes for a link. 
	 * @param link
	 * @param lanesToLinkAssignment
	 * @return sorted list with the most upstream lane at the first position. 
	 */",107-200,"('createLanes', {'INSTRUCTION': {'covered': 195, 'missed': 9}, 'BRANCH': {'covered': 19, 'missed': 3}, 'LINE': {'covered': 45, 'missed': 1}, 'COMPLEXITY': {'covered': 9, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",623.0,10.0,Creates a sorted list of lanes for a link.,Create a list of lanes sorted for links,A sorted list of lanes is created.,0.11067021796592,Creates a sorted list of channels for a link.
700,cucumber-reporting,"public static List<Hook> eliminateEmptyHooks(Hook[] hooks){
    return Arrays.asList(hooks).stream().filter(Hook::hasContent).collect(Collectors.toList());
}",eliminateEmptyHooks,net/masterthought/cucumber/util/Util.java,/src/main/java/net/masterthought/cucumber/util/Util.java,"/**
     * Helper method that removes empty hooks from passed array and packs it into new collection.
     *
     * @param hooks hooks to be reduced
     * @return no empty hooks
     */",85-95,"('eliminateEmptyHooks', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",43.0,16.0,Helper method that removes empty hooks from passed array and packs it into new collection.,Remove empty hooks from the ginven array and pack it into a new collection,The method removes empty hooks from the array and puts them in a new collection.,0.349730014366683,A helper method that removes empty hooks from the past table and packages it into a new collection.
701,jeromq,"public boolean containsPublicKey(byte[] publicKey){
    Utils.checkArgument(publicKey.length == 32, ""publickey needs to have a size of 32 bytes. got only "" + publicKey.length);
    return containsPublicKey(ZMQ.Curve.z85Encode(publicKey));
}",containsPublicKey,org/zeromq/ZCertStore.java,/src/main/java/org/zeromq/ZCertStore.java,"/**
     * Check if a public key is in the certificate store.
     * @param publicKey needs to be a 32 byte array representing the public key
     */",174-184,"('containsPublicKey', {'INSTRUCTION': {'covered': 24, 'missed': 1}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,11.0,Check if a public key is in the certificate store.,Verify if the public key is in the certificate container,"If the public key is in the store, you should check it.",0.0938031333959624,Check if a public key is in the certificate store.
702,dcache,"private Class<? extends Callable<? extends Serializable>> cast(Class<?> clazz){
    if (EXPECTED_TYPE.isSupertypeOf(clazz)) {
        return (Class<? extends Callable<? extends Serializable>>) clazz.asSubclass(Callable.class);
    }
    throw new RuntimeException(""This is a bug. Please notify support@dcache.org ("" + clazz + "" does not implement Callable<? extends Serializable>)."");
}",cast,org/dcache/util/cli/AnnotatedCommandScanner.java,/modules/common-cli/src/main/java/org/dcache/util/cli/AnnotatedCommandScanner.java,"/**
     * Verifies that clazz implements Callable<? extends Serializable> and casts it to that type.
     *
     * @param clazz The clazz of the command object
     * @return clazz cast to Callable<? extends Serializable>
     */",24-38,"('cast', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,17.0,Verifies that clazz implements Callable<? extends Serializable> and casts it to that type.,Check if clazz implements Callable<? extends Serializable> and if possible cast it,Verifies that Callable is implemented by the clazz.,0.737343717807301,Verifies that clazz implements Callable<? extends Serializable> and throws it to that type.
703,egeria,"public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
        return false;
    }
    Annotation that = (Annotation) objectToCompare;
    return confidenceLevel == that.confidenceLevel && numAttachedAnnotations == that.numAttachedAnnotations && Objects.equals(annotationType, that.annotationType) && Objects.equals(summary, that.summary) && Objects.equals(expression, that.expression) && Objects.equals(explanation, that.explanation) && Objects.equals(analysisStep, that.analysisStep) && Objects.equals(jsonProperties, that.jsonProperties) && annotationStatus == that.annotationStatus && Objects.equals(reviewDate, that.reviewDate) && Objects.equals(steward, that.steward) && Objects.equals(reviewComment, that.reviewComment) && Objects.equals(additionalProperties, that.additionalProperties);
}",equals,org/odpi/openmetadata/frameworks/discovery/properties/Annotation.java,/open-metadata-implementation/frameworks/open-discovery-framework/src/main/java/org/odpi/openmetadata/frameworks/discovery/properties/Annotation.java,"/**
     * Compare the values of the supplied object with those stored in the current object.
     *
     * @param objectToCompare supplied object
     * @return boolean result of comparison
     */",412-443,"('equals', {'INSTRUCTION': {'covered': 96, 'missed': 0}, 'BRANCH': {'covered': 20, 'missed': 12}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 12}, 'METHOD': {'covered': 1, 'missed': 0}})",178.0,15.0,Compare the values of the supplied object with those stored in the current object.,Compare the values of the given object with the values store in itself,The values of the supplied object and the current object should be compared.,0.76530146755942,Compare the values of the supplied object with those stored in the current object.
704,cdk,"public static boolean deAromatize(IRing ring){
    boolean allaromatic = true;
    for (int i = 0; i < ring.getBondCount(); i++) {
        if (!ring.getBond(i).getFlag(CDKConstants.ISAROMATIC))
            allaromatic = false;
    }
    if (!allaromatic)
        return false;
    for (int i = 0; i < ring.getBondCount(); i++) {
        if (ring.getBond(i).getFlag(CDKConstants.ISAROMATIC))
            ring.getBond(i).setOrder(IBond.Order.SINGLE);
    }
    boolean result = false;
    IMolecularFormula formula = MolecularFormulaManipulator.getMolecularFormula(ring);
    // Map elementCounts = new MFAnalyser(ring).getFormulaHashtable();
    if (ring.getRingSize() == 6) {
        if (MolecularFormulaManipulator.getElementCount(formula, new Element(""C"")) == 6) {
            result = DeAromatizationTool.deAromatizeBenzene(ring);
        } else if (MolecularFormulaManipulator.getElementCount(formula, new Element(""C"")) == 5 && MolecularFormulaManipulator.getElementCount(formula, new Element(""N"")) == 1) {
            result = DeAromatizationTool.deAromatizePyridine(ring);
        }
    }
    if (ring.getRingSize() == 5) {
        if (MolecularFormulaManipulator.getElementCount(formula, new Element(""C"")) == 4 && MolecularFormulaManipulator.getElementCount(formula, new Element(""N"")) == 1) {
            result = deAromatizePyrolle(ring);
        }
    }
    return result;
}",deAromatize,org/openscience/cdk/tools/DeAromatizationTool.java,/legacy/src/main/java/org/openscience/cdk/tools/DeAromatizationTool.java,"/**
     * Methods that takes a ring of which all bonds are aromatic, and assigns single
     * and double bonds. It does this in a non-general way by looking at the ring
     * size and take everything as a special case.
     *
     * @param ring Ring to dearomatize
     * @return  False if it could not convert the aromatic ring bond into single and double bonds
     */",58-93,"('deAromatize', {'INSTRUCTION': {'covered': 87, 'missed': 19}, 'BRANCH': {'covered': 15, 'missed': 9}, 'LINE': {'covered': 16, 'missed': 3}, 'COMPLEXITY': {'covered': 6, 'missed': 7}, 'METHOD': {'covered': 1, 'missed': 0}})",271.0,19.0,"Methods that takes a ring of which all bonds are aromatic, and assigns single  and double bonds.",This method receives a ring of aromatic bonds and assigns single and double bonds,A method that takes a ring of aromatic bonds and assigns single and double bonds.,0.220286136569859,"Methods that take a ring whose all bonds are aromatic, and assign single and double bonds."
705,matsim-libs,"private String encodeAttributeValue(final String attributeValue){
    if (attributeValue == null) {
        return null;
    }
    int len = attributeValue.length();
    boolean encode = false;
    for (int pos = 0; pos < len; pos++) {
        char ch = attributeValue.charAt(pos);
        if (ch == '<') {
            encode = true;
            break;
        } else if (ch == '>') {
            encode = true;
            break;
        } else if (ch == '\""') {
            encode = true;
            break;
        } else if (ch == '&') {
            encode = true;
            break;
        }
    }
    if (encode) {
        StringBuilder bf = new StringBuilder(attributeValue.length() + 30);
        for (int pos = 0; pos < len; pos++) {
            char ch = attributeValue.charAt(pos);
            if (ch == '<') {
                bf.append(""&lt;"");
            } else if (ch == '>') {
                bf.append(""&gt;"");
            } else if (ch == '\""') {
                bf.append(""&quot;"");
            } else if (ch == '&') {
                bf.append(""&amp;"");
            } else {
                bf.append(ch);
            }
        }
        return bf.toString();
    }
    return attributeValue;
}",encodeAttributeValue,org/matsim/core/events/algorithms/EventWriterXML.java,/matsim/src/main/java/org/matsim/core/events/algorithms/EventWriterXML.java,"/**
	 * Encodes the given string in such a way that it no longer contains
	 * characters that have a special meaning in xml.
	 * 
	 * @see <a href=""http://www.w3.org/International/questions/qa-escapes#use"">http://www.w3.org/International/questions/qa-escapes#use</a>
	 * @param attributeValue
	 * @return String with some characters replaced by their xml-encoding.
	 */",98-149,"('encodeAttributeValue', {'INSTRUCTION': {'covered': 98, 'missed': 8}, 'BRANCH': {'covered': 22, 'missed': 2}, 'LINE': {'covered': 30, 'missed': 3}, 'COMPLEXITY': {'covered': 11, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",250.0,22.0,Encodes the given string in such a way that it no longer contains  characters that have a special meaning in xml.,Encodes the given string preventing XML collisions,The given string no longer contains characters that have a special meaning in the xml.,0.657877000963501,Encodes the given string so that it no longer contains characters that have a special meaning in xml.
706,cdk,"public int lastIndexOf(Object o){
    IAtomContainer atomContainer = (IAtomContainer) o;
    if (!atomContainer.getTitle().equals(title))
        return -1;
    if (atomContainer.getAtomCount() != coordinates.get(0).length)
        return -1;
    boolean coordsMatch;
    for (int j = coordinates.size() - 1; j >= 0; j--) {
        Point3d[] coords = coordinates.get(j);
        coordsMatch = true;
        for (int i = 0; i < atomContainer.getAtomCount(); i++) {
            Point3d p = atomContainer.getAtom(i).getPoint3d();
            if (!(p.x == coords[i].x && p.y == coords[i].y && p.z == coords[i].z)) {
                coordsMatch = false;
                break;
            }
        }
        if (coordsMatch)
            return j;
    }
    return -1;
}",lastIndexOf,org/openscience/cdk/ConformerContainer.java,/base/data/src/main/java/org/openscience/cdk/ConformerContainer.java,"/**
     * Returns the highest index at which the specific IAtomContainer appears in the list or -1 if is not found.
     * 
     * A given IAtomContainer will occur in the list if the title matches the stored title for
     * the conformers in this container and if the coordinates for each atom in the specified molecule
     * are equal to the coordinates of the corresponding atoms in a conformer.
     *
     * @param o The IAtomContainer whose presence is being tested
     * @return The index where o was found
     */",400-431,"('lastIndexOf', {'INSTRUCTION': {'covered': 80, 'missed': 6}, 'BRANCH': {'covered': 11, 'missed': 5}, 'LINE': {'covered': 12, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",188.0,20.0,Returns the highest index at which the specific IAtomContainer appears in the list or -1 if is not found.,Get the highest index of the IAtomContainer in a list or -1 if it is not found,"If the IAtomContainer is not found, the highest index will be the one that it appears in.",0.265808058070117,Returns the highest index at which the specific IAtomContainer appears in the list or -1 if it cannot be found.
707,dataverse,"public boolean isInReview(){
    if (versionState != null && versionState.equals(VersionState.DRAFT)) {
        return getDataset().isLockedFor(DatasetLock.Reason.InReview);
    } else {
        return false;
    }
}",isInReview,edu/harvard/iq/dataverse/DatasetVersion.java,/src/main/java/edu/harvard/iq/dataverse/DatasetVersion.java,"/**
     * The only time a dataset can be in review is when it is in draft.
     * @return if the dataset is being reviewed
     */",279-289,"('isInReview', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,16.0,The only time a dataset can be in review is when it is in draft.,Check if the dataset can be reviewed because still in draft mode,When a dataset is in draft is the only time it can be reviewed.,0.280886913544161,The only time a dataset can be revised is when it is in draft.
710,acs-aem-commons,"public static T toObjectType(String data, Class<T> klass){
    if (Double.class.equals(klass)) {
        try {
            return klass.cast(Double.parseDouble(data));
        } catch (NumberFormatException ex) {
            return null;
        }
    } else if (Long.class.equals(klass)) {
        try {
            return klass.cast(Long.parseLong(data));
        } catch (NumberFormatException ex) {
            return null;
        }
    } else if (Integer.class.equals(klass)) {
        try {
            return klass.cast(Long.parseLong(data));
        } catch (NumberFormatException ex) {
            return null;
        }
    } else if (StringUtils.equalsIgnoreCase(""true"", data)) {
        return klass.cast(Boolean.TRUE);
    } else if (StringUtils.equalsIgnoreCase(""false"", data)) {
        return klass.cast(Boolean.FALSE);
    } else if (JSON_DATE.matcher(data).matches()) {
        long epochSeconds = OffsetDateTime.parse(data).toInstant().toEpochMilli();
        return klass.cast(new Date(epochSeconds));
    } else {
        return klass.cast(data);
    }
}",toObjectType,com/adobe/acs/commons/util/TypeUtil.java,/bundle/src/main/java/com/adobe/acs/commons/util/TypeUtil.java,"/**
     * Converts a limited set of String representations to their corresponding Objects
     * <p/>
     * Supports
     * * Double
     * * Long
     * * Integer
     * * Boolean (true/false)
     * * Dates in string format of ISODateTimeFormat
     * <p/>
     * Else, null is returned.
     *
     * @param data  the String representation of the data
     * @param klass the target class type of the provided data
     * @param <T>   the target class type of the provided data
     * @return the derived object representing the data as specified by the klass
     */",120-166,"('toObjectType', {'INSTRUCTION': {'covered': 61, 'missed': 15}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 7}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",240.0,37.0,"Converts a limited set of String representations to their corresponding Objects  <p/>  Supports   Double   Long   Integer   Boolean (true/false)   Dates in string format of ISODateTimeFormat  <p/>  Else, null is returned.",Transforms a limited set of String representations to their corresponding Objects,The dates in the string are converted to the corresponding objects.,0.142416895467571,"Converts a limited set of String representations to their corresponding objects <p/> Supports long double integer (true/false) Boolean dates in ISODateTimeFormat <p/> Else string format, null is returned."
711,metrics,"public void report(){
    synchronized (this) {
        report(registry.getGauges(filter), registry.getCounters(filter), registry.getHistograms(filter), registry.getMeters(filter), registry.getTimers(filter));
    }
}",report,io/dropwizard/metrics5/ScheduledReporter.java,/metrics-core/src/main/java/io/dropwizard/metrics5/ScheduledReporter.java,"/**
     * Report the current values of all metrics in the registry.
     */",248-259,"('report', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,11.0,Report the current values of all metrics in the registry.,Reports the values of all metrics in the registry,The current values of all metrics should be reported.,0.565100616141404,Specify the current values for all measures in the registry.
712,cdk,"public static IDifference difference(IChemObject first, IChemObject second){
    if (!(first instanceof IAtomType && second instanceof IAtomType)) {
        return null;
    }
    IAtomType firstElem = (IAtomType) first;
    IAtomType secondElem = (IAtomType) second;
    ChemObjectDifference totalDiff = new ChemObjectDifference(""AtomTypeDiff"");
    totalDiff.addChild(StringDifference.construct(""N"", firstElem.getAtomTypeName(), secondElem.getAtomTypeName()));
    totalDiff.addChild(BondOrderDifference.construct(""MBO"", firstElem.getMaxBondOrder(), secondElem.getMaxBondOrder()));
    totalDiff.addChild(DoubleDifference.construct(""BOS"", firstElem.getBondOrderSum(), secondElem.getBondOrderSum()));
    totalDiff.addChild(IntegerDifference.construct(""FC"", firstElem.getFormalCharge(), secondElem.getFormalCharge()));
    totalDiff.addChild(AtomTypeHybridizationDifference.construct(""H"", firstElem.getHybridization(), secondElem.getHybridization()));
    totalDiff.addChild(IntegerDifference.construct(""NC"", firstElem.getFormalNeighbourCount(), secondElem.getFormalNeighbourCount()));
    totalDiff.addChild(DoubleDifference.construct(""CR"", firstElem.getCovalentRadius(), secondElem.getCovalentRadius()));
    totalDiff.addChild(IntegerDifference.construct(""V"", firstElem.getValency(), secondElem.getValency()));
    totalDiff.addChild(IsotopeDiff.difference(first, second));
    if (totalDiff.childCount() > 0) {
        return totalDiff;
    } else {
        return null;
    }
}",difference,org/openscience/cdk/tools/diff/AtomTypeDiff.java,/misc/diff/src/main/java/org/openscience/cdk/tools/diff/AtomTypeDiff.java,"/**
     * Compare two {@link IChemObject} classes and return the difference as an {@link IDifference}.
     *
     * @param first  the first of the two classes to compare
     * @param second the second of the two classes to compare
     * @return an {@link IDifference} representation of the difference between the first and second {@link IChemObject}.
     */",62-96,"('difference', {'INSTRUCTION': {'covered': 93, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 22, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",283.0,20.0,Compare two {@link IChemObject} classes and return the difference as an {@link IDifference}.,Return as a IDifference the differences between two objcts of type IChemObject,You can compare two classes and return a difference.,0.264099018806769,Compare two classes {@link IChemObject} and return the difference as a {@link IDifference}.
713,tablesaw,"public Table reorderColumns(String... columnNames){
    Preconditions.checkArgument(columnNames.length == columnCount());
    Table table = Table.create(name);
    for (String name : columnNames) {
        table.addColumns(column(name));
    }
    return table;
}",reorderColumns,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,"/**
   * Return a new table (shallow copy) that contains all the columns in this table, in the order
   * given in the argument. Throw an IllegalArgument exception if the number of names given does not
   * match the number of columns in this table. NOTE: This does not make a copy of the columns, so
   * they are shared between the two tables.
   *
   * @param columnNames a column name or array of names
   */",305-320,"('reorderColumns', {'INSTRUCTION': {'covered': 41, 'missed': 1}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,25.0,"Return a new table (shallow copy) that contains all the columns in this table, in the order  given in the argument.",This method get a new shallow copy of the table containing all the columns in this table,Return a new table that contains all the columns in the argument.,0.265904541084934,"Return a new table (superficial copy) that contains all the columns in that table, in the order specified in the argument."
714,logstash-logback-encoder,"public static WaitStrategy createWaitStrategyFromString(String waitStrategyType){
    if (waitStrategyType == null) {
        return null;
    }
    waitStrategyType = waitStrategyType.trim().toLowerCase();
    if (waitStrategyType.isEmpty()) {
        return null;
    }
    if (waitStrategyType.equals(""blocking"")) {
        return new BlockingWaitStrategy();
    }
    if (waitStrategyType.equals(""busyspin"")) {
        return new BusySpinWaitStrategy();
    }
    if (waitStrategyType.equals(""liteblocking"")) {
        return new LiteBlockingWaitStrategy();
    }
    if (waitStrategyType.startsWith(""sleeping"")) {
        if (waitStrategyType.equals(""sleeping"")) {
            return new SleepingWaitStrategy();
        } else {
            List<Object> params = parseParams(waitStrategyType, Integer.class, Long.class);
            return new SleepingWaitStrategy((Integer) params.get(0), (Long) params.get(1));
        }
    }
    if (waitStrategyType.equals(""yielding"")) {
        return new YieldingWaitStrategy();
    }
    if (waitStrategyType.startsWith(""phasedbackoff"")) {
        List<Object> params = parseParams(waitStrategyType, Long.class, Long.class, TimeUnit.class, WaitStrategy.class);
        return new PhasedBackoffWaitStrategy((Long) params.get(0), (Long) params.get(1), (TimeUnit) params.get(2), (WaitStrategy) params.get(3));
    }
    if (waitStrategyType.startsWith(""timeoutblocking"")) {
        List<Object> params = parseParams(waitStrategyType, Long.class, TimeUnit.class);
        return new TimeoutBlockingWaitStrategy((Long) params.get(0), (TimeUnit) params.get(1));
    }
    if (waitStrategyType.startsWith(""litetimeoutblocking"")) {
        List<Object> params = parseParams(waitStrategyType, Long.class, TimeUnit.class);
        return new LiteTimeoutBlockingWaitStrategy((Long) params.get(0), (TimeUnit) params.get(1));
    }
    throw new IllegalArgumentException(""Unknown wait strategy type: "" + waitStrategyType);
}",createWaitStrategyFromString,net/logstash/logback/appender/WaitStrategyFactory.java,/src/main/java/net/logstash/logback/appender/WaitStrategyFactory.java,"/**
     * Creates a {@link WaitStrategy} from a string.
     * <p>
     * The following strategies are supported:
     * <ul>
     * <li><code>blocking</code> - {@link BlockingWaitStrategy}</li>
     * <li><code>busySpin</code> - {@link BusySpinWaitStrategy}</li>
     * <li><code>liteBlocking</code> - {@link LiteBlockingWaitStrategy}</li>
     * <li><code>sleeping{retries,sleepTimeNs}</code> - {@link SleepingWaitStrategy}
     *         - <code>retries</code> an integer number of times to spin before sleeping. (default = 200)
     *           <code>sleepTimeNs</code> nanosecond time to sleep each iteration after spinning (default = 100)
     * </li>
     * <li><code>yielding</code> - {@link YieldingWaitStrategy}</li>
     * <li><code>phasedBackoff{spinTimeout,yieldTimeout,timeUnit,fallackStrategy}</code> - {@link PhasedBackoffWaitStrategy}
     *         - <code>spinTimeout</code> and <code>yieldTimeout</code> are long values.
     *           <code>timeUnit</code> is a string name of one of the {@link TimeUnit} values.
     *           <code>fallbackStrategy</code> is a wait strategy string (e.g. <code>blocking</code>).
     * </li>
     * <li><code>timeoutBlocking{timeout,timeUnit}</code> - {@link TimeoutBlockingWaitStrategy}
     *         - <code>timeout</code> is a long value.
     *           <code>timeUnit</code> is a string name of one of the {@link TimeUnit} values.
     * </li>
     * <li><code>liteTimeoutBlocking{timeout,timeUnit}</code> - {@link LiteTimeoutBlockingWaitStrategy}
     *         - <code>timeout</code> is a long value.
     *           <code>timeUnit</code> is a string name of one of the {@link TimeUnit} values.
     * </li>
     * </ul>
     *
     * @param waitStrategyType the name of the desired wait strategy
     * @return a {@link WaitStrategy} instance or {@code null} if the supplied name is {@code null} or empty
     * @throws IllegalArgumentException if an unknown wait strategy type is given, or the parameters are unable to be parsed.
     */",41-136,"('createWaitStrategyFromString', {'INSTRUCTION': {'covered': 191, 'missed': 12}, 'BRANCH': {'covered': 21, 'missed': 1}, 'LINE': {'covered': 37, 'missed': 1}, 'COMPLEXITY': {'covered': 11, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",391.0,11.0,Creates a {@link WaitStrategy} from a string.,Build a waiting strategy from the input string,A @link WaitStrategy is created from a string.,0.954793545975364,Creates a {waitStrategy} {@link from a string.
715,cdk,"private static List<List<CDKRMap>> makeAtomsMapOfBondsMap(List<CDKRMap> rMapList, IAtomContainer graph1, IAtomContainer graph2){
    if (rMapList == null) {
        return (null);
    }
    List<List<CDKRMap>> result = null;
    if (rMapList.size() == 1) {
        result = makeAtomsMapOfBondsMapSingleBond(rMapList, graph1, graph2);
    } else {
        List<CDKRMap> resultLocal = new ArrayList<CDKRMap>();
        for (int i = 0; i < rMapList.size(); i++) {
            IBond qBond = graph1.getBond(rMapList.get(i).getId1());
            IBond tBond = graph2.getBond(rMapList.get(i).getId2());
            IAtom[] qAtoms = BondManipulator.getAtomArray(qBond);
            IAtom[] tAtoms = BondManipulator.getAtomArray(tBond);
            for (int j = 0; j < 2; j++) {
                List<IBond> bondsConnectedToAtom1j = graph1.getConnectedBondsList(qAtoms[j]);
                for (int k = 0; k < bondsConnectedToAtom1j.size(); k++) {
                    if (!bondsConnectedToAtom1j.get(k).equals(qBond)) {
                        IBond testBond = bondsConnectedToAtom1j.get(k);
                        for (int m = 0; m < rMapList.size(); m++) {
                            IBond testBond2;
                            if ((rMapList.get(m)).getId1() == graph1.indexOf(testBond)) {
                                testBond2 = graph2.getBond((rMapList.get(m)).getId2());
                                for (int n = 0; n < 2; n++) {
                                    List<IBond> bondsToTest = graph2.getConnectedBondsList(tAtoms[n]);
                                    if (bondsToTest.contains(testBond2)) {
                                        CDKRMap map;
                                        if (j == n) {
                                            map = new CDKRMap(graph1.indexOf(qAtoms[0]), graph2.indexOf(tAtoms[0]));
                                        } else {
                                            map = new CDKRMap(graph1.indexOf(qAtoms[1]), graph2.indexOf(tAtoms[0]));
                                        }
                                        if (!resultLocal.contains(map)) {
                                            resultLocal.add(map);
                                        }
                                        CDKRMap map2;
                                        if (j == n) {
                                            map2 = new CDKRMap(graph1.indexOf(qAtoms[1]), graph2.indexOf(tAtoms[1]));
                                        } else {
                                            map2 = new CDKRMap(graph1.indexOf(qAtoms[0]), graph2.indexOf(tAtoms[1]));
                                        }
                                        if (!resultLocal.contains(map2)) {
                                            resultLocal.add(map2);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        result = new ArrayList<List<CDKRMap>>();
        result.add(resultLocal);
    }
    return result;
}",makeAtomsMapOfBondsMap,org/openscience/cdk/smsd/algorithm/rgraph/CDKRMapHandler.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKRMapHandler.java,"/**
     *  This makes sourceAtom map of matching atoms out of sourceAtom map of matching bonds as produced by the get(Subgraph|Ismorphism)Map methods.
     *
     * @param  rMapList   The list produced by the getMap method.
     * @param  graph1  first molecule. Must not be an IQueryAtomContainer.
     * @param  graph2  second molecule. May be an IQueryAtomContainer.
     * @return     The mapping found projected on graph1. This is sourceAtom List of CDKRMap objects containing Ids of matching atoms.
     */",327-396,"('makeAtomsMapOfBondsMap', {'INSTRUCTION': {'covered': 213, 'missed': 2}, 'BRANCH': {'covered': 27, 'missed': 1}, 'LINE': {'covered': 38, 'missed': 1}, 'COMPLEXITY': {'covered': 14, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",553.0,25.0,This makes sourceAtom map of matching atoms out of sourceAtom map of matching bonds as produced by the get(Subgraph|Ismorphism)Map methods.,This method makes sourceAtom map of matching atoms out of sourceAtom map of matching bonds,This makes sourceAtom map of matching atoms out of sourceAtom map of matching bonds as produced by the get method.,1.22088264636658,This makes sourceAtom map of corresponding atoms out of sourceAtom map of corresponding bonds as produced by the get(Subgraph| Ismorphism)Cartographic methods.
718,weblogic-kubernetes-operator,"public Watchable<V1Service> createServiceWatch(String namespace) throws ApiException{
    return FACTORY.createWatch(callParams, V1Service.class, new ListNamespacedServiceCall(namespace));
}",createServiceWatch,oracle/kubernetes/operator/builders/WatchBuilder.java,/operator/src/main/java/oracle/kubernetes/operator/builders/WatchBuilder.java,"/**
   * Creates a web hook object to track service calls.
   *
   * @param namespace the namespace
   * @return the active web hook
   * @throws ApiException if there is an error on the call that sets up the web hook.
   */",47-56,"('createServiceWatch', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,10.0,Creates a web hook object to track service calls.,This method build a web hook object to track service the calls,A web hook object is created to track service calls.,0.417658018832292,Creates a Web hook object to track service calls.
719,cdk,"public int numberOfElements(){
    int n = 0;
    for (SortedSet<Integer> cell : cells) {
        n += cell.size();
    }
    return n;
}",numberOfElements,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,"/**
     * Calculate the size of the partition as the sum of the sizes of the cells.
     *
     * @return the number of elements in the partition
     */",128-139,"('numberOfElements', {'INSTRUCTION': {'covered': 21, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,16.0,Calculate the size of the partition as the sum of the sizes of the cells.,Calculate the sum of the sizes of the partition in cells,The partition's size should be calculated as the sum of the cells' sizes.,0.217072358679807,Calculate the partition size as the sum of the cell sizes.
720,dcache,"public static StringBuilder appendDuration(StringBuilder sb, Duration duration, TimeUnitFormat unitFormat){
    return appendDuration(sb, duration.toMillis(), MILLISECONDS, unitFormat);
}",appendDuration,org/dcache/util/TimeUtils.java,/modules/common/src/main/java/org/dcache/util/TimeUtils.java,"/**
     * Provide a short, simple human understandable string describing the supplied duration.  The
     * duration is a non-negative value.  The output is appended to the supplied StringBuilder and
     * has the form {@code <number> <space> <units>}, where {@code <number>} is an integer and
     * {@code <units>} is defined by the value of unitFormat.
     */",369-383,"('appendDuration', {'INSTRUCTION': {'covered': 31, 'missed': 2}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,13.0,"Provide a short, simple human understandable string describing the supplied duration.",Return a compact human understandable string describing the supplied duration,A short human understandable string describing the duration is what you should provide.,0.146690811795572,Provide a short and simple string that can be understood by man describing the duration provided.
721,jackson-databind,"private static int indexOfNonDigit(String string, int offset){
    for (int i = offset; i < string.length(); i++) {
        char c = string.charAt(i);
        if (c < '0' || c > '9')
            return i;
    }
    return string.length();
}",indexOfNonDigit,com/fasterxml/jackson/databind/util/ISO8601Utils.java,/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java,"/**
     * Returns the index of the first character in the string that is not a digit, starting at offset.
     */",311-320,"('indexOfNonDigit', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",63.0,20.0,"Returns the index of the first character in the string that is not a digit, starting at offset.","Get the index of the first character in the string that is not a digit, starting at the given offset",The first character in the string is not a digit.,0.432245904045886,"Returns the index of the first character in the string that is not a number, starting with offset."
722,cdk,"public boolean isConnectedTo(IBond bond){
    for (IAtom atom : atoms) {
        if (bond.contains(atom))
            return true;
    }
    return false;
}",isConnectedTo,org/openscience/cdk/silent/Bond.java,/base/silent/src/main/java/org/openscience/cdk/silent/Bond.java,"/**
     * Checks whether a bond is connected to another one.
     * This can only be true if the bonds have an Atom in common.
     *
     * @param bond The bond which is checked to be connect with this one
     * @return true if the bonds share an atom, otherwise false
     */",506-519,"('isConnectedTo', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,10.0,Checks whether a bond is connected to another one.,Checks if a bond is connected to another one,Does it check if a bond is connected to another one.,0.641120125504382,Checks whether one link is connected to another.
723,matsim-libs,"private double findMinimalAdditionalDistance(JobInsertionContext context, TourActivity newInvestigatedPickup, TourActivity nextAct){
    double minimalAdditionalDistance = 0;
    if (context.getAssociatedActivities().get(1) instanceof DeliverShipment) {
        TourActivity assignedDelivery = context.getAssociatedActivities().get(1);
        minimalAdditionalDistance = 0;
        int indexNextActicity = nextAct.getIndex();
        int tourPositionOfAcitivityBehindNewPickup = 0;
        int countIndex = 0;
        Vehicle newVehicle = context.getNewVehicle();
        VehicleRoute route = context.getRoute();
        a: for (TourActivity tourActivity : route.getTourActivities().getActivities()) {
            if (tourActivity.getIndex() == indexNextActicity) {
                while (countIndex < route.getTourActivities().getActivities().size()) {
                    if (route.getTourActivities().getActivities().get(countIndex).getIndex() == indexNextActicity) {
                        tourPositionOfAcitivityBehindNewPickup = countIndex;
                        break a;
                    }
                    countIndex++;
                }
            }
        }
        while ((tourPositionOfAcitivityBehindNewPickup + 1) < route.getTourActivities().getActivities().size()) {
            TourActivity activityBefore = route.getTourActivities().getActivities().get(tourPositionOfAcitivityBehindNewPickup);
            TourActivity activityAfter = route.getTourActivities().getActivities().get(tourPositionOfAcitivityBehindNewPickup + 1);
            double possibleAdditionalDistance = getDistance(activityBefore, assignedDelivery, newVehicle) + getDistance(assignedDelivery, activityAfter, newVehicle) - getDistance(activityBefore, activityAfter, newVehicle);
            minimalAdditionalDistance = findMinimalDistance(minimalAdditionalDistance, possibleAdditionalDistance);
            tourPositionOfAcitivityBehindNewPickup++;
        }
        if (route.getTourActivities().getActivities().size() > 0) {
            TourActivity activityLastDelivery = route.getTourActivities().getActivities().get(route.getTourActivities().getActivities().size() - 1);
            TourActivity activityEnd = route.getEnd();
            double possibleAdditionalDistance = getDistance(activityLastDelivery, assignedDelivery, newVehicle) + getDistance(assignedDelivery, activityEnd, newVehicle) - getDistance(activityLastDelivery, activityEnd, newVehicle);
            minimalAdditionalDistance = findMinimalDistance(minimalAdditionalDistance, possibleAdditionalDistance);
            TourActivity activityAfter = route.getTourActivities().getActivities().get(tourPositionOfAcitivityBehindNewPickup);
            possibleAdditionalDistance = getDistance(newInvestigatedPickup, assignedDelivery, newVehicle) + getDistance(assignedDelivery, activityAfter, newVehicle) - getDistance(newInvestigatedPickup, activityAfter, newVehicle);
            minimalAdditionalDistance = findMinimalDistance(minimalAdditionalDistance, possibleAdditionalDistance);
        }
    }
    return minimalAdditionalDistance;
}",findMinimalAdditionalDistance,org/matsim/contrib/freight/jsprit/DistanceConstraint.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/jsprit/DistanceConstraint.java,"/**
         * Finds a minimal additional distance for the tour, when a pickup is added to
         * the plan. The AssociatedActivities contains both activities of a job which
         * should be added to the existing tour. The TourActivities which are already in
         * the tour are found in context.getRoute().getTourActivities. In this method
         * the position of the new pickup is fixed and three options of the location of
         * the delivery activity will be checked: delivery between every other activity
         * after the pickup, delivery as the last activity before the end and delivery
         * directly behind the new pickup. This method gives back the minimal distance
         * of this three options.
         *
         * @param context
         * @param newInvestigatedPickup
         * @param nextAct
         * @return minimal distance of the associated delivery
         */",208-285,"('findMinimalAdditionalDistance', {'INSTRUCTION': {'covered': 170, 'missed': 20}, 'BRANCH': {'covered': 8, 'missed': 6}, 'LINE': {'covered': 38, 'missed': 5}, 'COMPLEXITY': {'covered': 4, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",441.0,18.0,"Finds a minimal additional distance for the tour, when a pickup is added to  the plan.","This method calculates the minimal additional distance for the tour, when a pickup is added to the plan","When a pickup is added to the plan, it adds a little more distance for the tour.",0.178772382734351,"Find a minimum additional distance for the tour, when pickup is added to the plan."
724,anserini,"public static String documentRaw(IndexReader reader, String docid){
    try {
        return reader.document(convertDocidToLuceneDocid(reader, docid)).get(IndexArgs.RAW);
    } catch (Exception e) {
        return null;
    }
}",documentRaw,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,"/**
   * Returns the ""raw"" field of a document based on a collection docid. The method is named to be consistent with
   * Lucene's {@link IndexReader#document(int)}, contra Java's standard method naming conventions.
   *
   * @param reader index reader
   * @param docid collection docid
   * @return the ""raw"" field the document
   */",538-553,"('documentRaw', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,15.0,"Returns the ""raw"" field of a document based on a collection docid.",Returns the raw document based on a collection docid.,"The document's ""raw"" field is returned.",0.707419521079904,"Returns the ""raw"" field of a document based on a collection docid."
725,liquibase,"public static CheckSum parse(String checksumValue){
    if (checksumValue == null) {
        return null;
    }
    // The general layout of a checksum is:
    // <1 digit: algorithm version number>:<1..n characters alphanumeric checksum>
    // Example: 7:2cdf9876e74347162401315d34b83746
    Matcher matcher = CHECKSUM_PATTERN.matcher(checksumValue);
    if (matcher.find()) {
        return new CheckSum(matcher.group(2), Integer.parseInt(matcher.group(1)));
    } else {
        // No version information found
        return new CheckSum(checksumValue, 1);
    }
}",parse,liquibase/change/CheckSum.java,/liquibase-core/src/main/java/liquibase/change/CheckSum.java,"/**
     * Parse the given storedCheckSum string value and return a new CheckSum object.
     */",41-58,"('parse', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,13.0,Parse the given storedCheckSum string value and return a new CheckSum object.,Process the given storedCheckSum string and return a new CheckSum object,Parse the string value and then return a new object.,0.309061826184427,Parse the given storedCheckSum string value and return a new CheckSum object.
726,cdk,"public void write(IChemObject object) throws CDKException{
    customizeJob();
    try {
        if (object instanceof IChemFile) {
            writeChemFile((IChemFile) object);
            return;
        } else if (object instanceof IChemModel) {
            IChemFile file = object.getBuilder().newInstance(IChemFile.class);
            IChemSequence sequence = object.getBuilder().newInstance(IChemSequence.class);
            sequence.addChemModel((IChemModel) object);
            file.addChemSequence(sequence);
            writeChemFile((IChemFile) file);
            return;
        } else if (object instanceof IAtomContainer) {
            writeMolecule((IAtomContainer) object);
            return;
        }
    } catch (Exception ex) {
        logger.error(ex.getMessage());
        logger.debug(ex);
        throw new CDKException(""Exception while writing MDL file: "" + ex.getMessage(), ex);
    }
    throw new CDKException(""Only supported is writing of IChemFile, "" + ""IChemModel, and IAtomContainer objects."");
}",write,org/openscience/cdk/io/MDLV2000Writer.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Writer.java,"/**
     * Writes a {@link IChemObject} to the MDL molfile formated output.
     * It can only output ChemObjects of type {@link IChemFile},
     * {@link IChemObject} and {@link IAtomContainer}.
     *
     * @param object {@link IChemObject} to write
     * @see #accepts(Class)
     */",294-326,"('write', {'INSTRUCTION': {'covered': 65, 'missed': 11}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 16, 'missed': 4}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",172.0,14.0,Writes a {@link IChemObject} to the MDL molfile formated output.,This method writes a IChemObject to the molfile formated output,The MDL molfile formated output is written in a @link IChemObject.,1.29306577608778,Writes an {@link IChemObject} in the output in molfile MDL format.
727,logstash-logback-encoder,"public final T acquire(){
    Holder<T> holder = this.threadLocal.get();
    if (holder.leased) {
        throw new IllegalStateException(""ThreadLocal value is already in use and not yet released."");
    }
    if (holder.value == null) {
        holder.value = Objects.requireNonNull(createInstance());
    }
    holder.leased = true;
    return holder.value;
}",acquire,net/logstash/logback/util/ThreadLocalHolder.java,/src/main/java/net/logstash/logback/util/ThreadLocalHolder.java,"/**
     * Get the value assigned to the current thread, creating a new one if none is assigned yet or the
     * previous has been disposed.
     * 
     * The value must be {@link #release()} to ensure proper life cycle before it can be {@link #acquire()}
     * again.
     * 
     * @return the value assigned to this thread
     * @throws IllegalStateException if the value is already in use and {@link #release()} was not yet invoked.
     */",87-110,"('acquire', {'INSTRUCTION': {'covered': 24, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",71.0,25.0,"Get the value assigned to the current thread, creating a new one if none is assigned yet or the  previous has been disposed.",Return the value assigned to the current thread by creating a new one if none is assigned yet or the previous has been disposed,"If no one assigns the current value yet or the previous has been removed, create a new one.",0.562010510055811,"Get the value assigned to the current thread, creating a new one if none is yet assigned or if the previous one has been deleted."
728,tablesaw,"private void crossProduct(Table destination, Table table1, Table table2, Selection table1Rows, Selection table2Rows, Set<Integer> ignoreColumns, boolean keepTable2JoinKeyColumns){
    for (int c = 0; c < table1.columnCount() + table2.columnCount(); c++) {
        if (!keepTable2JoinKeyColumns && ignoreColumns.contains(c)) {
            continue;
        }
        int table2Index = c - table1.columnCount();
        for (int r1 : table1Rows) {
            for (int r2 : table2Rows) {
                if (c < table1.columnCount()) {
                    Column t1Col = table1.column(c);
                    destination.column(c).append(t1Col, r1);
                } else {
                    Column t2Col = table2.column(table2Index);
                    destination.column(c).append(t2Col, r2);
                }
            }
        }
    }
}",crossProduct,tech/tablesaw/joining/DataFrameJoiner.java,/core/src/main/java/tech/tablesaw/joining/DataFrameJoiner.java,"/**
   * Creates cross product for the selection of two tables.
   *
   * @param destination the destination table.
   * @param table1 the table on left of join.
   * @param table2 the table on right of join.
   * @param table1Rows the selection of rows in table1.
   * @param table2Rows the selection of rows in table2.
   * @param ignoreColumns a set of column indexes in the result to ignore. They are redundant join
   *     columns.
   */",836-873,"('crossProduct', {'INSTRUCTION': {'covered': 76, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",164.0,10.0,Creates cross product for the selection of two tables.,This method builds a cross product for the selection of two tables,Cross product is created for the two tables.,0.459693205897626,Creates a crossover product for selecting two tables.
729,jackson-databind,"public static String classNameOf(Object inst){
    if (inst == null) {
        return ""[null]"";
    }
    Class<?> raw = (inst instanceof Class<?>) ? (Class<?>) inst : inst.getClass();
    return nameOf(raw);
}",classNameOf,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * Helper method used to construct appropriate description
     * when passed either type (Class) or an instance; in latter
     * case, class of instance is to be used.
     *
     * @since 2.9
     */",703-716,"('classNameOf', {'INSTRUCTION': {'covered': 14, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",56.0,30.0,"Helper method used to construct appropriate description  when passed either type (Class) or an instance; in latter  case, class of instance is to be used.",Get the class name of the given object,"The class is used in the latter case, as the class is the one used in the Helper method.",0.772924977519198,"A helper method used to construct an appropriate description when passed to the type (Class) or instance; in the latter case, the instance class must be used."
730,sonar-cxx,"public static void load(NewRepository repository, String languageKey, Iterable<Class> ruleClasses){
    new AnnotationBasedRulesDefinition(repository, languageKey).addRuleClasses(true, ruleClasses);
}",load,org/sonar/cxx/squidbridge/annotations/AnnotationBasedRulesDefinition.java,/cxx-squid-bridge/src/main/java/org/sonar/cxx/squidbridge/annotations/AnnotationBasedRulesDefinition.java,"/**
   * Adds annotated rule classes to an instance of NewRepository. Fails if one the classes has no SQALE annotation.
   */",69-74,"('load', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,10.0,Adds annotated rule classes to an instance of NewRepository.,This method adds annotated rule classes to the input instance,Adds annotated rule classes to a NewRepository instance.,0.412436340611489,Adds annotated rule classes to an instance of NewRepository.
731,matsim-libs,"public static void reportNetworkStatistics(Network network){
    LOG.info(""--- Network statistics: ------------------------------------------------------"");
    LOG.info(""   Network description: "" + network.getName());
    LOG.info(""       Number of nodes: "" + network.getNodes().size());
    LOG.info(""       Number of links: "" + network.getLinks().size());
    LOG.info(""------------------------------------------------------------------------------"");
}",reportNetworkStatistics,org/matsim/core/network/algorithms/intersectionSimplifier/IntersectionSimplifier.java,/matsim/src/main/java/org/matsim/core/network/algorithms/intersectionSimplifier/IntersectionSimplifier.java,"/**
	 * Provides basic statistics of a given {@link Network}.  
	 * @param network
	 */",221-231,"('reportNetworkStatistics', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",71.0,12.0,Provides basic statistics of a given {@link Network}.,Get the statistics of a given input Network,Provides basic statistics of a network.,0.2167337197545,Provides basic statistics for a given {@link Network}.
732,cdk,"private ILigand[] order(ILigand[] ligands){
    ILigand[] newLigands = new ILigand[ligands.length];
    System.arraycopy(ligands, 0, newLigands, 0, ligands.length);
    Arrays.sort(newLigands, numberRule);
    ILigand[] reverseLigands = new ILigand[newLigands.length];
    for (int i = 0; i < newLigands.length; i++) {
        reverseLigands[(newLigands.length - 1) - i] = newLigands[i];
    }
    return reverseLigands;
}",order,org/openscience/cdk/geometry/cip/rules/CIPLigandRule.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/rules/CIPLigandRule.java,"/**
     * Order the ligands from high to low precedence according to atomic and mass numbers.
     */",84-98,"('order', {'INSTRUCTION': {'covered': 40, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",104.0,15.0,Order the ligands from high to low precedence according to atomic and mass numbers.,Order the ligands in ascendent precedence according to atomic and mass numbers,The ligands should be ordered from high to low precedence.,0.195606414689206,Order high to low priority ligands based on atomic and mass numbers.
733,metrics,"private ByteBuffer signPacket(ByteBuffer packet){
    final byte[] signature = sign(password, (ByteBuffer) ByteBuffer.allocate(packet.remaining() + username.length).put(username).put(packet).flip());
    return (ByteBuffer) ByteBuffer.allocate(BUFFER_SIZE).putShort((short) TYPE_SIGN_SHA256).putShort((short) (username.length + SIGNATURE_LEN)).put(signature).put(username).put((ByteBuffer) packet.flip()).flip();
}",signPacket,io/dropwizard/metrics5/collectd/PacketWriter.java,/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/PacketWriter.java,"/**
     * Signs the provided packet, so a CollectD server can verify that its authenticity.
     * Wire format:
     * <pre>
     * +-------------------------------+-------------------------------+
     * ! Type (0x0200)                 ! Length                        !
     * +-------------------------------+-------------------------------+
     * ! Signature (SHA2(username + packet))                           \
     * +-------------------------------+-------------------------------+
     * ! Username                      ! Packet                        \
     * +---------------------------------------------------------------+
     * </pre>
     *
     * @see <a href=""https://collectd.org/wiki/index.php/Binary_protocol#Signature_part"">
     * Binary protocol - CollectD | Signature part</a>
     */",140-168,"('signPacket', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",111.0,15.0,"Signs the provided packet, so a CollectD server can verify that its authenticity.",This method signs the provided packet to allow that a CollectD server can verify that its authenticity.,A server can verify the authenticity of the packet if it is signs.,0.571408820282323,Signs the package provided so that a CollectD server can verify its authenticity.
735,cdk,"public void addMolecule(IAtomContainer mol, boolean active) throws CDKException{
    if (mol == null || mol.getAtomCount() == 0)
        throw new CDKException(""Molecule cannot be blank or null."");
    CircularFingerprinter circ = new CircularFingerprinter(classType);
    circ.setPerceiveStereo(optPerceiveStereo);
    circ.calculate(mol);
    final int AND_BITS = folding - 1;
    Set<Integer> hashset = new TreeSet<Integer>();
    for (int n = circ.getFPCount() - 1; n >= 0; n--) {
        int code = circ.getFP(n).hashCode;
        if (folding > 0)
            code &= AND_BITS;
        hashset.add(code);
    }
    int[] hashes = new int[hashset.size()];
    int p = 0;
    for (Integer h : hashset) hashes[p++] = h;
    if (active)
        numActive++;
    training.add(hashes);
    activity.add(active);
    for (int h : hashes) {
        int[] stash = inHash.get(h);
        if (stash == null)
            stash = new int[] { 0, 0 };
        if (active)
            stash[0]++;
        stash[1]++;
        inHash.put(h, stash);
    }
}",addMolecule,org/openscience/cdk/fingerprint/model/Bayesian.java,/tool/model/src/main/java/org/openscience/cdk/fingerprint/model/Bayesian.java,"/**
     * Appends a new row to the model source data, which consists of a molecule and whether or not it
     * is considered active.
     * 
     * @param mol molecular structure, which must be non-blank
     * @param active whether active or not
     */",181-221,"('addMolecule', {'INSTRUCTION': {'covered': 155, 'missed': 5}, 'BRANCH': {'covered': 16, 'missed': 2}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",251.0,24.0,"Appends a new row to the model source data, which consists of a molecule and whether or not it  is considered active.",This method appends a new row to the model source data,The row that wasAppended is a molecule and whether or not it is considered active.,0.695066251826251,"Adds a new row to the model source data, which consists of a molecule and whether it is considered active or not."
736,cdk,"private void solution(BitSet traversed) throws CDKException{
    boolean included = false;
    BitSet projG1 = projectG1(traversed);
    BitSet projG2 = projectG2(traversed);
    if (isContainedIn(getSourceBitSet(), projG1) && isContainedIn(getTargetBitSet(), projG2)) {
        for (Iterator<BitSet> i = getSolutionList().listIterator(); i.hasNext() && !included; ) {
            BitSet sol = i.next();
            checkTimeOut();
            if (!sol.equals(traversed)) {
                if (isFindAllMap() && (projG1.equals(projectG1(sol)) || projG2.equals(projectG2(sol)))) {
                } else if (isContainedIn(projG1, projectG1(sol)) || isContainedIn(projG2, projectG2(sol))) {
                    included = true;
                } else if (isContainedIn(projectG1(sol), projG1) || isContainedIn(projectG2(sol), projG2)) {
                    i.remove();
                }
            } else {
                included = true;
            }
        }
        if (included == false) {
            getSolutionList().add(traversed);
        }
        if (!isFindAllStructure()) {
            setStop(true);
        }
    }
}",solution,org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,"/**
     * Checks if a potential solution is a real one
     * (not included in a previous solution)
     *  and add this solution to the solution list
     * in case of success.
     *
     * @param  traversed  new potential solution
     */",322-375,"('solution', {'INSTRUCTION': {'covered': 107, 'missed': 2}, 'BRANCH': {'covered': 27, 'missed': 1}, 'LINE': {'covered': 19, 'missed': 1}, 'COMPLEXITY': {'covered': 14, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",235.0,30.0,Checks if a potential solution is a real one  (not included in a previous solution)  and add this solution to the solution list  in case of success.,This method verifies if a potential solution is a real one and add it to the solution list,"If a potential solution is a real one, it should be added to the solution list in case of success.",0.17503093579343,Checks whether a potential solution is real (not included in a previous solution) and adds that solution to the list of solutions if successful.
737,matsim-libs,"public T selectPlan(final HasPlansAndId<T, I> person){
    // current plan and random plan:
    T currentPlan = person.getSelectedPlan();
    T otherPlan = new RandomPlanSelector<T, I>().selectPlan(person);
    if (currentPlan == null) {
        // this case should only happen when the agent has no plans at all
        return null;
    }
    if ((currentPlan.getScore() == null) || (otherPlan.getScore() == null)) {
        /* With the previous behavior, Double.NaN was returned if no score was available.
			 * This resulted in weight=NaN below as well, and then ultimately in returning
			 * the currentPlan---what we're doing right now as well.
			 */
        if (currentPlan.getScore() != null && otherPlan.getScore() == null) {
            if (scoreWrnFlag) {
                log.error(""yyyyyy not switching to other plan although it needs to be explored.  "" + ""Possibly a serious bug; ask kai if you encounter this.  kai, sep'10"");
                scoreWrnFlag = false;
            }
        }
        return currentPlan;
    }
    // defending against NaN (which should not happen, but happens):
    if (currentPlan.getScore().isNaN()) {
        return otherPlan;
    }
    if (otherPlan.getScore().isNaN()) {
        return currentPlan;
    }
    double currentScore = currentPlan.getScore().doubleValue();
    double otherScore = otherPlan.getScore().doubleValue();
    if (betaWrnFlag) {
        log.warn(""Would make sense to revise this once more.  See comments in code.  kai, nov08"");
        /**
         * Gunnar says, rightly I think, that what is below hits the ""0.01*weight > 1"" threshold fairly quickly.
         *   An alternative might be to divide by exp(0.5*beta*oS)+exp(0.5*beta*cS), or the max of these two numbers.  But:
         *   (1) someone would need to go through the theory to make sure that we remain within what we have said before
         *       (convergence to logit and proba of jump between equal options = 0.01
         *   (2) someone would need to test if the ""traffic"" results are similar
         */
        betaWrnFlag = false;
    }
    double weight = Math.exp(0.5 * this.beta * (otherScore - currentScore));
    // (so far, this is >1 if otherScore>currentScore, and <=1 otherwise)
    // (beta is the slope (strength) of the operation: large beta means strong reaction)
    if (MatsimRandom.getRandom().nextDouble() < 0.01 * weight) {
        // as of now, 0.01 is hardcoded (proba to change when both
        // scores are the same)
        return otherPlan;
    }
    return currentPlan;
}",selectPlan,org/matsim/core/replanning/selectors/ExpBetaPlanChanger.java,/matsim/src/main/java/org/matsim/core/replanning/selectors/ExpBetaPlanChanger.java,"/**
         * Changes to another plan with a probability proportional to exp( Delta scores ).
         * Need to think through if this goes to Nash Equilibrium or to SUE !!!
         */",44-104,"('selectPlan', {'INSTRUCTION': {'covered': 78, 'missed': 4}, 'BRANCH': {'covered': 16, 'missed': 4}, 'LINE': {'covered': 21, 'missed': 2}, 'COMPLEXITY': {'covered': 7, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",240.0,15.0,Changes to another plan with a probability proportional to exp( Delta scores ).,This method changes to another plan with a probability proportional to exp scores,Changes to another plan with a probability that is proportional to exp.,0.30970305887481,Changes to another plane with probability proportional to exp( Delta) scores.
738,cdk,"public Point3d rescaleBondLength(IAtom atom1, IAtom atom2, Point3d point2){
    Point3d point1 = atom1.getPoint3d();
    Double d1 = atom1.getCovalentRadius();
    Double d2 = atom2.getCovalentRadius();
    double distance = (d1 == null || d2 == null) ? 1.0 : d1 + d2;
    if (pSet != null) {
        distance = getDistanceValue(atom1.getAtomTypeName(), atom2.getAtomTypeName());
    }
    Vector3d vect = new Vector3d(point2);
    vect.sub(point1);
    vect.normalize();
    vect.scale(distance);
    Point3d newPoint = new Point3d(point1);
    newPoint.add(vect);
    return newPoint;
}",rescaleBondLength,org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,"/**
     *  Rescales Point2 so that length 1-2 is sum of covalent radii.
     *  If covalent radii cannot be found, use bond length of 1.0
     *
     *@param  atom1          stationary atom
     *@param  atom2          movable atom
     *@param  point2         coordinates for atom 2
     *@return                new coordinates for atom 2
     */",123-148,"('rescaleBondLength', {'INSTRUCTION': {'covered': 54, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",134.0,12.0,Rescales Point2 so that length 1-2 is sum of covalent radii.,This method rescales the input Point2 so that length 1-2 is sum of covalent radii,Point2 is the sum of covalent radii.,0.975162576490632,Resizes point2 so that length 1-2 is the sum of the covalent rays.
739,jackson-databind,"protected void _collectIgnorals(String name){
    if (!_forSerialization && (name != null)) {
        if (_ignoredPropertyNames == null) {
            _ignoredPropertyNames = new HashSet<String>();
        }
        _ignoredPropertyNames.add(name);
    }
}",_collectIgnorals,com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java,/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java,"/**
     * Helper method called to add explicitly ignored properties to a list
     * of known ignored properties; this helps in proper reporting of
     * errors.
     */",935-948,"('_collectIgnorals', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,24.0,Helper method called to add explicitly ignored properties to a list  of known ignored properties; this helps in proper reporting of  errors.,This method adds explicitly ignored properties to a list of known ignored properties,Adding explicitly ignored properties to a list helps in reporting errors.,0.200780945532397,A helper method called to add explicitly ignored properties to a list of known ignored properties; this helps to report errors correctly.
740,anserini,"public static int convertDocidToLuceneDocid(IndexReader reader, String docid){
    try {
        IndexSearcher searcher = new IndexSearcher(reader);
        Query q = new TermQuery(new Term(IndexArgs.ID, docid));
        TopDocs rs = searcher.search(q, 1);
        ScoreDoc[] hits = rs.scoreDocs;
        if (hits == null || hits.length == 0) {
            return -1;
        }
        return hits[0].doc;
    } catch (IOException e) {
        return -1;
    }
}",convertDocidToLuceneDocid,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,"/**
   * Converts a collection docid to a Lucene internal docid.
   *
   * @param reader index reader
   * @param docid collection docid
   * @return corresponding Lucene internal docid, or -1 if docid not found
   */",731-755,"('convertDocidToLuceneDocid', {'INSTRUCTION': {'covered': 34, 'missed': 3}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",100.0,10.0,Converts a collection docid to a Lucene internal docid.,This method converts a collection docid to a Lucene internal docid,A collection docid is converted to a Lucene internal docid.,0.709551861673088,Converts a collection docid to an internal Lucene docid.
741,egeria,"public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
        return false;
    }
    if (!super.equals(objectToCompare)) {
        return false;
    }
    AssetResponse that = (AssetResponse) objectToCompare;
    return getCertificationCount() == that.getCertificationCount() && getCommentCount() == that.getCommentCount() && getConnectionCount() == that.getConnectionCount() && getExternalIdentifierCount() == that.getExternalIdentifierCount() && getExternalReferencesCount() == that.getExternalReferencesCount() && getInformalTagCount() == that.getInformalTagCount() && getLicenseCount() == that.getLicenseCount() && getLikeCount() == that.getLikeCount() && getKnownLocationsCount() == that.getKnownLocationsCount() && getNoteLogsCount() == that.getNoteLogsCount() && getRatingsCount() == that.getRatingsCount() && getRelatedAssetCount() == that.getRelatedAssetCount() && getRelatedMediaReferenceCount() == that.getRelatedMediaReferenceCount() && getSchemaType() == that.getSchemaType() && getLastAttachment() == that.getLastAttachment() && Objects.equals(getAsset(), that.getAsset());
}",equals,org/odpi/openmetadata/commonservices/ocf/metadatamanagement/rest/AssetResponse.java,/open-metadata-implementation/common-services/ocf-metadata-management/ocf-metadata-api/src/main/java/org/odpi/openmetadata/commonservices/ocf/metadatamanagement/rest/AssetResponse.java,"/**
     * Return comparison result based on the content of the properties.
     *
     * @param objectToCompare test object
     * @return result of comparison
     */",505-543,"('equals', {'INSTRUCTION': {'covered': 107, 'missed': 1}, 'BRANCH': {'covered': 24, 'missed': 16}, 'LINE': {'covered': 23, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 16}, 'METHOD': {'covered': 1, 'missed': 0}})",230.0,11.0,Return comparison result based on the content of the properties.,Implment an equals method for the given objectToCompare,The result is based on the properties.,0.0778393773816239,Return the result of the comparison based on the content of the properties.
744,acs-aem-commons,"private int purgeExpiredEntries(){
    int result = 0;
    for (int i = 0; i < timestamps.length; i++) {
        long now = clock.instant().toEpochMilli();
        if (now - timestamps[i].toEpochMilli() > ONE_MINUTE) {
            timestamps[i] = Instant.EPOCH;
            result++;
        }
    }
    return result;
}",purgeExpiredEntries,com/adobe/acs/commons/throttling/ThrottlingState.java,/bundle/src/main/java/com/adobe/acs/commons/throttling/ThrottlingState.java,"/**
     * cleanup the timestamps array and replace all expired entries with
     * Instant.EPOCH;
     *
     * @return the number of emptied slots
     */",108-129,"('purgeExpiredEntries', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,12.0,cleanup the timestamps array and replace all expired entries with  Instant.,This method purges the timestamps array and replace all expired entries with Instant.EPOCH,All expired entries should be replaced with Instant.,0.268556484708331,Clean the timestamp table and replace all expired entries with Instant.
745,cdk,"public static boolean compare(IMolecularFormula formula1, IMolecularFormula formula2){
    if (!Objects.equals(formula1.getCharge(), formula2.getCharge()))
        return false;
    if (formula1.getIsotopeCount() != formula2.getIsotopeCount())
        return false;
    for (IIsotope isotope : formula1.isotopes()) {
        if (!formula2.contains(isotope))
            return false;
        if (formula1.getIsotopeCount(isotope) != formula2.getIsotopeCount(isotope))
            return false;
    }
    for (IIsotope isotope : formula2.isotopes()) {
        if (!formula1.contains(isotope))
            return false;
        if (formula2.getIsotopeCount(isotope) != formula1.getIsotopeCount(isotope))
            return false;
    }
    return true;
}",compare,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * Compare two IMolecularFormula looking at type and number of IIsotope and
     * charge of the formula.
     *
     * @param formula1   The first IMolecularFormula
     * @param formula2   The second IMolecularFormula
     * @return           True, if the both IMolecularFormula are the same
     */",1256-1283,"('compare', {'INSTRUCTION': {'covered': 67, 'missed': 4}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",146.0,16.0,Compare two IMolecularFormula looking at type and number of IIsotope and  charge of the formula.,This method compares two IMolecularFormula by looking at type and number of IIsotope and charge of the formula,Two IMolecularFormulas look at type and number of IIsotope and charge of the formula.,0.444083029451502,Compare two IMolecularFormula by looking at the type and number of IIsotope and the load of the formula.
747,cdk,"private static double[] toVector(Point3d src, Point3d dest){
    return new double[] { dest.x - src.x, dest.y - src.y, dest.z - src.z };
}",toVector,org/openscience/cdk/hash/stereo/DoubleBond3DParity.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/DoubleBond3DParity.java,"/**
     * Create a vector by specifying the source and destination coordinates.
     *
     * @param src  start point of the vector
     * @param dest end point of the vector
     * @return a new vector
     */",93-102,"('toVector', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,11.0,Create a vector by specifying the source and destination coordinates.,Get a subvector by specifying the source and destination indexes,You can create a vector by specifying the source and destination coordinates.,0.411465353300869,Create a vector by specifying the source and destination coordinates.
748,jackson-databind,"public static Enum<?> findFirstAnnotatedEnumValue(Class<Enum<?>> enumClass, Class<T> annotationClass){
    Field[] fields = enumClass.getDeclaredFields();
    for (Field field : fields) {
        if (field.isEnumConstant()) {
            Annotation defaultValueAnnotation = field.getAnnotation(annotationClass);
            if (defaultValueAnnotation != null) {
                final String name = field.getName();
                for (Enum<?> enumValue : enumClass.getEnumConstants()) {
                    if (name.equals(enumValue.name())) {
                        return enumValue;
                    }
                }
            }
        }
    }
    return null;
}",findFirstAnnotatedEnumValue,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * A method that will look for the first Enum value annotated with the given Annotation.
     * <p>
     * If there's more than one value annotated, the first one found will be returned. Which one exactly is used is undetermined.
     *
     * @param enumClass The Enum class to scan for a value with the given annotation
     * @param annotationClass The annotation to look for.
     * @return the Enum value annotated with the given Annotation or {@code null} if none is found.
     * @throws IllegalArgumentException if there's a reflection issue accessing the Enum
     * @since 2.8
     */",1093-1121,"('findFirstAnnotatedEnumValue', {'INSTRUCTION': {'covered': 58, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",120.0,16.0,A method that will look for the first Enum value annotated with the given Annotation.,This method looks for the first Enum value annotated with the given Annotation,A method that will look for the first Enum value.,0.582890931189884,Method; looks for the first Enum value annotated with the given annotation.
749,cdk,"public synchronized void sortResultsByStereoAndBondMatch() throws CDKException{
    // System.out.println(""\n\n\n\nSort By ResultsByStereoAndBondMatch"");
    Map<Integer, Map<Integer, Integer>> allStereoMCS = new HashMap<Integer, Map<Integer, Integer>>();
    Map<Integer, Map<IAtom, IAtom>> allStereoAtomMCS = new HashMap<Integer, Map<IAtom, IAtom>>();
    Map<Integer, Integer> fragmentScoreMap = new TreeMap<Integer, Integer>();
    Map<Integer, Double> energyScoreMap = new TreeMap<Integer, Double>();
    Map<Integer, Double> stereoScoreMap = new HashMap<Integer, Double>();
    initializeMaps(allStereoMCS, allStereoAtomMCS, stereoScoreMap, fragmentScoreMap, energyScoreMap);
    boolean stereoMatchFlag = getStereoBondChargeMatch(stereoScoreMap, allStereoMCS, allStereoAtomMCS);
    boolean flag = false;
    if (stereoMatchFlag) {
        // Higher Score is mapped preferred over lower
        stereoScoreMap = sortMapByValueInDecendingOrder(stereoScoreMap);
        double higestStereoScore = stereoScoreMap.isEmpty() ? 0 : stereoScoreMap.values().iterator().next();
        double secondhigestStereoScore = higestStereoScore;
        for (Integer key : stereoScoreMap.keySet()) {
            if (secondhigestStereoScore < higestStereoScore && stereoScoreMap.get(key) > secondhigestStereoScore) {
                secondhigestStereoScore = stereoScoreMap.get(key);
            } else if (secondhigestStereoScore == higestStereoScore && stereoScoreMap.get(key) < secondhigestStereoScore) {
                secondhigestStereoScore = stereoScoreMap.get(key);
            }
        }
        if (!stereoScoreMap.isEmpty()) {
            flag = true;
            clear();
        }
        /* Put back the sorted solutions */
        int counter = 0;
        for (Integer i : stereoScoreMap.keySet()) {
            // System.out.println(""Sorted Map key "" + I + "" Sorted Value: "" + stereoScoreMap.get(I));
            // System.out.println(""Stereo MCS "" + allStereoMCS.get(I) + "" Stereo Value: ""
            // + stereoScoreMap.get(I));
            if (higestStereoScore == stereoScoreMap.get(i).doubleValue()) {
                // || secondhigestStereoScore == stereoScoreMap.get(I).doubleValue()) {
                addSolution(counter, i, allStereoAtomMCS, allStereoMCS, stereoScoreMap, energyScoreMap, fragmentScoreMap);
                counter++;
                // System.out.println(""Sorted Map key "" + I + "" Sorted Value: "" + stereoScoreMap.get(I));
                // System.out.println(""Stereo MCS "" + allStereoMCS.get(I) + "" Stereo Value: ""
                // + stereoScoreMap.get(I));
            }
        }
        if (flag) {
            firstSolution.putAll(allMCS.get(0));
            firstAtomMCS.putAll(allAtomMCS.get(0));
            clear(allStereoMCS, allStereoAtomMCS, stereoScoreMap, fragmentScoreMap, energyScoreMap);
        }
    }
}",sortResultsByStereoAndBondMatch,org/openscience/cdk/smsd/filters/ChemicalFilters.java,/legacy/src/main/java/org/openscience/cdk/smsd/filters/ChemicalFilters.java,"/**
     * Sort MCS solution by stereo and bond type matches.
     * @throws CDKException
     */",190-255,"('sortResultsByStereoAndBondMatch', {'INSTRUCTION': {'covered': 160, 'missed': 9}, 'BRANCH': {'covered': 17, 'missed': 5}, 'LINE': {'covered': 32, 'missed': 1}, 'COMPLEXITY': {'covered': 7, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",376.0,10.0,Sort MCS solution by stereo and bond type matches.,This method sorts the MCS solution by stereo and bound type matches,Sort by stereo and bond type.,0.339482616459886,Sort the MCS solution by stereo correspondence and link type.
750,egeria,"public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
        return false;
    }
    TypeDefPatch that = (TypeDefPatch) objectToCompare;
    return applyToVersion == that.applyToVersion && updateToVersion == that.updateToVersion && Objects.equals(typeDefGUID, that.typeDefGUID) && Objects.equals(typeDefName, that.typeDefName) && typeDefStatus == that.typeDefStatus && Objects.equals(newVersionName, that.newVersionName) && Objects.equals(updatedBy, that.updatedBy) && Objects.equals(updateTime, that.updateTime) && Objects.equals(description, that.description) && Objects.equals(descriptionGUID, that.descriptionGUID) && Objects.equals(superType, that.superType) && Objects.equals(propertyDefinitions, that.propertyDefinitions) && Objects.equals(typeDefOptions, that.typeDefOptions) && Objects.equals(externalStandardMappings, that.externalStandardMappings) && Objects.equals(validInstanceStatusList, that.validInstanceStatusList) && initialStatus == that.initialStatus && Objects.equals(validEntityDefs, that.validEntityDefs) && Objects.equals(endDef1, that.endDef1) && Objects.equals(endDef2, that.endDef2);
}",equals,org/odpi/openmetadata/repositoryservices/connectors/stores/metadatacollectionstore/properties/typedefs/TypeDefPatch.java,/open-metadata-implementation/repository-services/repository-services-apis/src/main/java/org/odpi/openmetadata/repositoryservices/connectors/stores/metadatacollectionstore/properties/typedefs/TypeDefPatch.java,"/**
     * Validate that an object is equal depending on their stored values.
     *
     * @param objectToCompare object
     * @return boolean result
     */",615-652,"('equals', {'INSTRUCTION': {'covered': 133, 'missed': 0}, 'BRANCH': {'covered': 27, 'missed': 17}, 'LINE': {'covered': 21, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 17}, 'METHOD': {'covered': 1, 'missed': 0}})",239.0,12.0,Validate that an object is equal depending on their stored values.,Check if the given object is equal depending on their stored values,"If you can show that an object is equal, you have done your job.",1.3188804327794,Verify that an object is equal based on its stored values.
751,matsim-libs,"public static Coord orthogonalProjectionOnLineSegment(final Coord lineFrom, final Coord lineTo, final Coord point){
    if (!lineFrom.hasZ() && !lineTo.hasZ() && !point.hasZ()) {
        double lineDX = lineTo.getX() - lineFrom.getX();
        double lineDY = lineTo.getY() - lineFrom.getY();
        if ((lineDX == 0.0) && (lineDY == 0.0)) {
            return lineFrom;
        }
        double u = ((point.getX() - lineFrom.getX()) * lineDX + (point.getY() - lineFrom.getY()) * lineDY) / (lineDX * lineDX + lineDY * lineDY);
        if (u <= 0) {
            return lineFrom;
        }
        if (u >= 1) {
            return lineTo;
        }
        return new Coord(lineFrom.getX() + u * lineDX, lineFrom.getY() + u * lineDY);
    } else if (lineFrom.hasZ() && lineTo.hasZ() && point.hasZ()) {
        Coord direction = minus(lineTo, lineFrom);
        double t0 = dotProduct(direction, minus(point, lineFrom)) / dotProduct(direction, direction);
        Coord q = plus(lineFrom, scalarMult(t0, direction));
        return q;
    } else {
        if (!onlyOnceWarnGiven) {
            Logger.getLogger(CoordUtils.class).warn(""Mix of 2D / 3D coordinates. Assuming 2D only.\n"" + Gbl.ONLYONCE);
            onlyOnceWarnGiven = true;
        }
        return orthogonalProjectionOnLineSegment(new Coord(lineFrom.getX(), lineFrom.getY()), new Coord(lineTo.getX(), lineTo.getY()), new Coord(point.getX(), point.getY()));
    }
}",orthogonalProjectionOnLineSegment,org/matsim/core/utils/geometry/CoordUtils.java,/matsim/src/main/java/org/matsim/core/utils/geometry/CoordUtils.java,"/**
         * Calculates the coordinate of the intersection point of the orthogonal projection
         * of a given point on a line segment with that line segment. The line segment
         * is given by two points, <code>lineFrom</code> and <code>lineTo</code>. If the
         * projection point does not lie *on* the line segment (but only somewhere on
         * the extension of the line segment, i.e. the infinite line), the end point of
         * the line segment which is closest to the given point is returned.
         *
         * <br><br>
         * The 3D version was adapted from the documentation of 
         * <a href=""http://www.geometrictools.com/Documentation/DistancePointLine.pdf"">
         * David Eberly/a>. 
         *
         * @param lineFrom The start point of the line segment
         * @param lineTo The end point of the line segment
         * @param point The point whose distance to the line segment should be calculated
         * @return the <code>coordinate</code> of the intersection point of the orthogonal
         * projection of a given point on a line segment with that line segment
         *
         * @author dziemke, jwjoubert
         */",331-394,"('orthogonalProjectionOnLineSegment', {'INSTRUCTION': {'covered': 114, 'missed': 31}, 'BRANCH': {'covered': 15, 'missed': 7}, 'LINE': {'covered': 16, 'missed': 4}, 'COMPLEXITY': {'covered': 6, 'missed': 6}, 'METHOD': {'covered': 1, 'missed': 0}})",344.0,24.0,Calculates the coordinate of the intersection point of the orthogonal projection  of a given point on a line segment with that line segment.,Get the coordinate of the intersection point of the orthogonal projection of the given point on a line segment with that line segment,The coordinate of the intersection point of the two lines is calculated.,1.19948391220226,Calculates the coordinate of the intersection point of the orthogonal projection of a given point on a line segment with that line segment.
752,cactoos,"private T fallback(final Throwable exp) throws Exception{
    final Iterator<Map.Entry<Fallback<T>, Integer>> candidates = new Sorted<>(Comparator.comparing(Map.Entry::getValue), new Filtered<>(new org.cactoos.func.Flattened<>(entry -> new Not(new Equals<Integer, Integer>(entry::getValue, new Constant<>(Integer.MIN_VALUE)))), new MapOf<>(fbk -> fbk, fbk -> fbk.support(exp), this.fallbacks).entrySet().iterator()));
    if (candidates.hasNext()) {
        return candidates.next().getKey().apply(exp);
    } else {
        throw new Exception(""No fallback found - throw the original exception"", exp);
    }
}",fallback,org/cactoos/scalar/ScalarWithFallback.java,/src/main/java/org/cactoos/scalar/ScalarWithFallback.java,"/**
     * Finds the best fallback for the given exception type and apply it to
     * the exception or throw the original error if no fallback found.
     * @param exp The original exception
     * @return Result of the most suitable fallback
     * @throws Exception The original exception if no fallback found
     */",99-135,"('fallback', {'INSTRUCTION': {'covered': 40, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",162.0,25.0,Finds the best fallback for the given exception type and apply it to  the exception or throw the original error if no fallback found.,This method finds the best fallback for the given exception type and applies it to the exception or throw the original error if no fallback found,"If no fallback is found, apply it to the exception or throw the original error.",0.600200248885917,Finds the best fallback for the given exception type and applies it to the exception or throws the original error if no fallback is found.
753,cdk,"private void handleFragmentGrouping(IReaction rxn, CxSmilesState cxstate){
    if (cxstate.fragGroups == null && cxstate.racemicFrags == null)
        return;
    final int reactant = 1;
    final int agent = 2;
    final int product = 3;
    List<IAtomContainer> fragMap = new ArrayList<>();
    Map<IAtomContainer, Integer> roleMap = new HashMap<>();
    for (IAtomContainer mol : rxn.getReactants().atomContainers()) {
        fragMap.add(mol);
        roleMap.put(mol, reactant);
    }
    for (IAtomContainer mol : rxn.getAgents().atomContainers()) {
        fragMap.add(mol);
        roleMap.put(mol, agent);
    }
    for (IAtomContainer mol : rxn.getProducts().atomContainers()) {
        fragMap.add(mol);
        roleMap.put(mol, product);
    }
    if (cxstate.racemicFrags != null) {
        for (Integer grp : cxstate.racemicFrags) {
            if (grp >= fragMap.size())
                continue;
            IAtomContainer mol = fragMap.get(grp);
            if (mol == null)
                continue;
            for (IStereoElement<?, ?> e : mol.stereoElements()) {
                if (e.getConfigClass() == IStereoElement.TH) {
                    e.setGroupInfo(IStereoElement.GRP_RAC1);
                }
            }
        }
    }
    if (cxstate.fragGroups != null) {
        boolean invalid = false;
        Set<Integer> visit = new HashSet<>();
        for (List<Integer> grouping : cxstate.fragGroups) {
            if (grouping.get(0) >= fragMap.size())
                continue;
            IAtomContainer dest = fragMap.get(grouping.get(0));
            if (dest == null)
                continue;
            if (!visit.add(grouping.get(0)))
                invalid = true;
            for (int i = 1; i < grouping.size(); i++) {
                if (!visit.add(grouping.get(i)))
                    invalid = true;
                if (grouping.get(i) >= fragMap.size())
                    continue;
                IAtomContainer src = fragMap.get(grouping.get(i));
                if (src != null) {
                    dest.add(src);
                    roleMap.put(src, 0);
                }
            }
        }
        if (!invalid) {
            rxn.getReactants().removeAllAtomContainers();
            rxn.getAgents().removeAllAtomContainers();
            rxn.getProducts().removeAllAtomContainers();
            for (IAtomContainer mol : fragMap) {
                switch(roleMap.get(mol)) {
                    case reactant:
                        rxn.getReactants().addAtomContainer(mol);
                        break;
                    case product:
                        rxn.getProducts().addAtomContainer(mol);
                        break;
                    case agent:
                        rxn.getAgents().addAtomContainer(mol);
                        break;
                }
            }
        }
    }
}",handleFragmentGrouping,org/openscience/cdk/smiles/SmilesParser.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/SmilesParser.java,"/**
     * Handle fragment grouping of a reaction that specifies certain disconnected components
     * are actually considered a single molecule. Normally used for salts, [Na+].[OH-].
     *
     * @param rxn     reaction
     * @param cxstate state
     */",379-474,"('handleFragmentGrouping', {'INSTRUCTION': {'covered': 272, 'missed': 7}, 'BRANCH': {'covered': 40, 'missed': 8}, 'LINE': {'covered': 59, 'missed': 6}, 'COMPLEXITY': {'covered': 18, 'missed': 8}, 'METHOD': {'covered': 1, 'missed': 0}})",566.0,18.0,Handle fragment grouping of a reaction that specifies certain disconnected components  are actually considered a single molecule.,This method handles fragment grouping of a reaction that specifies certain disconnected components are actually considered a single molecule,A single molecule is a reaction that specifies certain disconnected components.,0.253068547939175,Manipulate the grouping of fragments of a reaction that specifies that some disconnected components are actually considered a single molecule.
754,matsim-libs,"public synchronized List<? extends PlanElement> calcRoute(final String mainMode, final Facility fromFacility, final Facility toFacility, final double departureTime, final Person person){
    Gbl.assertNotNull(fromFacility);
    Gbl.assertNotNull(toFacility);
    RoutingModule module = routingModules.get(mainMode);
    if (module != null) {
        List<? extends PlanElement> trip = module.calcRoute(fromFacility, toFacility, departureTime, person);
        if (trip == null) {
            trip = fallbackRoutingModule.calcRoute(fromFacility, toFacility, departureTime, person);
        }
        for (Leg leg : TripStructureUtils.getLegs(trip)) {
            TripStructureUtils.setRoutingMode(leg, mainMode);
        }
        return trip;
    }
    throw new UnknownModeException(""unregistered main mode |"" + mainMode + ""|: does not pertain to "" + routingModules.keySet());
}",calcRoute,org/matsim/core/router/TripRouter.java,/matsim/src/main/java/org/matsim/core/router/TripRouter.java,"/**
         * Routes a trip between the given O/D pair, with the given main mode.
         *
         * @param mainMode the main mode for the trip
         * @param fromFacility a {@link Facility} representing the departure location
         * @param toFacility a {@link Facility} representing the arrival location
         * @param departureTime the departure time
         * @param person the {@link Person} to route
         * @return a list of {@link PlanElement}, in proper order, representing the trip.
         *
         * @throws UnknownModeException if no RoutingModule is registered for the
         * given mode.
         */",145-190,"('calcRoute', {'INSTRUCTION': {'covered': 46, 'missed': 9}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 12, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",151.0,15.0,"Routes a trip between the given O/D pair, with the given main mode.",Calculate the route between the given inputs with the given main mode,The given main mode is used to route a trip between the O/D pair.,0.531367862154735,"Routes a path between the given O/D pair, with the given main mode."
755,acs-aem-commons,"private Optional<Class> detectTypeFromName(String name){
    boolean isArray = false;
    Class detectedClass = Object.class;
    if (name.contains(""@"")) {
        String typeStr = StringUtils.substringAfter(name, ""@"");
        if (typeStr.contains(""["")) {
            typeStr = StringUtils.substringBefore(typeStr, ""["");
        }
        detectedClass = getClassFromName(typeStr);
    }
    if (name.endsWith(""]"")) {
        isArray = true;
        String delimiter = StringUtils.substringBetween(name, ""["", ""]"");
        if (!StringUtils.isEmpty(delimiter)) {
            String colName = convertHeaderName(name);
            delimiters.put(colName, delimiter);
        }
    }
    if (isArray) {
        return getArrayType(Optional.of(detectedClass));
    } else {
        return Optional.of(detectedClass);
    }
}",detectTypeFromName,com/adobe/acs/commons/data/Spreadsheet.java,/bundle/src/main/java/com/adobe/acs/commons/data/Spreadsheet.java,"/**
     * Look for type hints in the name of a column to extract a usable type.
     * Also look for array hints as well. <br>
     * Possible formats:
     * <ul>
     * <li>column-name - A column named ""column-name"" </li>
     * <li>col@int - An integer column named ""col"" </li>
     * <li>col2@int[] - An integer array colum named ""col2"", assumes standard
     * delimiter (,) </li>
     * <li>col3@string[] or col3@[] - A String array named ""col3"", assumes
     * standard delimiter (,)</li>
     * <li>col4@string[||] - A string array where values are using a custom
     * delimiter (||)</li>
     * </ul>
     *
     * @param name
     * @return
     */",306-347,"('detectTypeFromName', {'INSTRUCTION': {'covered': 57, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",162.0,16.0,Look for type hints in the name of a column to extract a usable type.,Infer types from their column's names,The name of the column should give hints about the type.,0.352398113042188,Look for type hints in the name of a column to retrieve a usable type.
756,matsim-libs,"private Map<Id<Node>, Node> findCluster(final Node startNode, final Network network){
    final Map<Node, DoubleFlagRole> nodeRoles = new HashMap<>(network.getNodes().size());
    ArrayList<Node> pendingForward = new ArrayList<>();
    ArrayList<Node> pendingBackward = new ArrayList<>();
    TreeMap<Id<Node>, Node> clusterNodes = new TreeMap<>();
    clusterNodes.put(startNode.getId(), startNode);
    DoubleFlagRole r = getDoubleFlag(startNode, nodeRoles);
    r.forwardFlag = true;
    r.backwardFlag = true;
    pendingForward.add(startNode);
    pendingBackward.add(startNode);
    // step through the network in forward mode
    while (pendingForward.size() > 0) {
        int idx = pendingForward.size() - 1;
        // get the last element to prevent object shifting in the array
        Node currNode = pendingForward.remove(idx);
        for (Link link : currNode.getOutLinks().values()) {
            Node node = link.getToNode();
            r = getDoubleFlag(node, nodeRoles);
            if (!r.forwardFlag) {
                r.forwardFlag = true;
                pendingForward.add(node);
            }
        }
    }
    // now step through the network in backward mode
    while (pendingBackward.size() > 0) {
        int idx = pendingBackward.size() - 1;
        // get the last element to prevent object shifting in the array
        Node currNode = pendingBackward.remove(idx);
        for (Link link : currNode.getInLinks().values()) {
            Node node = link.getFromNode();
            r = getDoubleFlag(node, nodeRoles);
            if (!r.backwardFlag) {
                r.backwardFlag = true;
                pendingBackward.add(node);
                if (r.forwardFlag) {
                    // the node can be reached forward and backward, add it to the cluster
                    clusterNodes.put(node.getId(), node);
                }
            }
        }
    }
    return clusterNodes;
}",findCluster,org/matsim/core/network/algorithms/NetworkCleaner.java,/matsim/src/main/java/org/matsim/core/network/algorithms/NetworkCleaner.java,"/**
         * Finds the cluster of nodes of which <code>startNode</code> is part of. The cluster
         * contains all nodes which can be reached starting at <code>startNode</code>
         * and from where it is also possible to return again to <code>startNode</code>.
         *
         * @param startNode the node to start building the cluster
         * @param network the network the startNode is part of
         * @return cluster of nodes of which <code>startNode</code> is part of
         */",51-109,"('findCluster', {'INSTRUCTION': {'covered': 142, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 35, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",344.0,18.0,Finds the cluster of nodes of which <code>startNode</code> is part of.,Get the cluster of nodes in which the given input startNode is part of,The cluster of the startNode is found.,0.490835011860756,Finds the cluster of nodes of which <code>startNode</code> is a part.
757,cdk,"private void applyMDLValenceModel(IAtom atom, int explicitValence, int unpaired){
    if (atom.getValency() != null) {
        if (atom.getValency() >= explicitValence)
            atom.setImplicitHydrogenCount(atom.getValency() - (explicitValence - unpaired));
        else
            atom.setImplicitHydrogenCount(0);
    } else {
        Integer element = atom.getAtomicNumber();
        if (element == null)
            element = 0;
        Integer charge = atom.getFormalCharge();
        if (charge == null)
            charge = 0;
        int implicitValence = MDLValence.implicitValence(element, charge, explicitValence);
        if (implicitValence < explicitValence) {
            atom.setValency(explicitValence);
            atom.setImplicitHydrogenCount(0);
        } else {
            atom.setValency(implicitValence);
            atom.setImplicitHydrogenCount(implicitValence - explicitValence);
        }
    }
}",applyMDLValenceModel,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Applies the MDL valence model to atoms using the explicit valence (bond
     * order sum) and charge to determine the correct number of implicit
     * hydrogens. The model is not applied if the explicit valence is less than
     * 0 - this is the case when a query bond was read for an atom.
     *
     * @param atom            the atom to apply the model to
     * @param unpaired        unpaired electron count
     * @param explicitValence the explicit valence (bond order sum)
     */",566-599,"('applyMDLValenceModel', {'INSTRUCTION': {'covered': 61, 'missed': 9}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",158.0,27.0,Applies the MDL valence model to atoms using the explicit valence (bond  order sum) and charge to determine the correct number of implicit  hydrogens.,This method applies the MDL valence model to atoms using the explicit valence and charge to determine the correct number of implicit hydrogens,The MDL model is applied to atoms using the explicit valence and charge to determine the correct number of implicit hydrogens.,0.428813681600703,Applies the MDL valence model to atoms using explicit valence (sum of bond order) and charge to determine the correct number of implicit hydrogens.
758,weblogic-kubernetes-operator,"private void addToSplitResult(DataEntry entry){
    while (entry.getRemainingLength() > 0) {
        remainingRoom -= entry.addToMap(current, remainingRoom);
        if (remainingRoom == 0) {
            recordSplitResult();
            startSplitResult();
        }
    }
}",addToSplitResult,oracle/kubernetes/operator/helpers/ConfigMapSplitter.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/ConfigMapSplitter.java,"/**
   * Adds the specified data entry to one or more split results, recording its location if it is not wholly
   * in the first split result.
   * @param entry a data entry
   */",74-87,"('addToSplitResult', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,26.0,"Adds the specified data entry to one or more split results, recording its location if it is not wholly  in the first split result.",Adds the specified data entry to one or more split results,"If the data entry is not wholly in the first split result, it is recorded as a location.",0.197241656435893,"Adds the specified data entry to one or more split results, saving its location if it is not entirely in the first split result."
759,jackson-databind,"public static String quotedOr(Object str, String forNull){
    if (str == null) {
        return forNull;
    }
    return String.format(""\""%s\"""", str);
}",quotedOr,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * Returns either quoted value (with double-quotes) -- if argument non-null
     * String -- or String NULL (no quotes) (if null).
     *
     * @since 2.9
     */",648-659,"('quotedOr', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,26.0,Returns either quoted value (with double-quotes) -- if argument non-null  String -- or String NULL (no quotes) (if null).,This method returns append quotes if the input is not null,"If the argument is non-null, the value will be quoted or null.",0.77976307005835,Returns either a value in quotation marks (with double quotes) -- if the argument is not null String -- or String NULL (no quotation marks) (if null).
760,dataverse,"public static boolean isTrue(String s){
    return (s != null) && TRUE_VALUES.contains(s.trim().toLowerCase());
}",isTrue,edu/harvard/iq/dataverse/util/StringUtil.java,/src/main/java/edu/harvard/iq/dataverse/util/StringUtil.java,"/**
     * Checks if {@code s} contains a ""truthy"" value.
     * @param s
     * @return {@code true} iff {@code s} is not {@code null} and is ""truthy"" word.
     * @see #TRUE_VALUES
     */",80-88,"('isTrue', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,14.0,"Checks if {@code s} contains a ""truthy"" value.",Verify if the input contains a true value,"If @code s contains a ""truthy"" value, it's checked.",0.719791179358768,"Checks whether {@code s} contains a ""truthy"" value."
761,cdk,"static int indexOfHetro(int[] cycle, int[] contribution){
    int index = -1;
    for (int i = 0; i < cycle.length - 1; i++) {
        if (contribution[cycle[i]] == 2)
            index = index == -1 ? i : -2;
    }
    return index;
}",indexOfHetro,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,"/**
     * Find the index of a hetroatom in a cycle. A hetroatom in MMFF is the unique atom that
     * contributes a pi-lone-pair to the aromatic system.
     *
     * @param cycle        aromatic cycle, |C| = 5
     * @param contribution vector of p electron contributions from each vertex
     * @return index of hetroatom, if none found index is < 0.
     */",316-330,"('indexOfHetro', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,10.0,Find the index of a hetroatom in a cycle.,Get the index of a hetroatom in a cycle. ,The hetroatom's index is found in a cycle.,0.238992412887403,Find the index of a hetroatoma in a cycle.
762,cdk,"private static int findOther(int[] vs, int u, int x){
    for (int v : vs) {
        if (v != u && v != x)
            return v;
    }
    throw new IllegalArgumentException(""vs[] did not contain another vertex"");
}",findOther,org/openscience/cdk/hash/stereo/DoubleBondElementEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/DoubleBondElementEncoderFactory.java,"/**
     * Finds a vertex in 'vs' which is not 'u' or 'x'.
     * .
     * @param vs fixed size array of 3 elements
     * @param u  a vertex in 'vs'
     * @param x  another vertex in 'vs'
     * @return the other vertex
     */",119-132,"('findOther', {'INSTRUCTION': {'covered': 24, 'missed': 5}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,17.0,Finds a vertex in 'vs' which is not 'u' or 'x'.,Get a vertex in 'vs' which is not 'u' or 'x'.,A person finds a difference between 'u' and 'x' in a piece of paper.,1.36243093621775,Find a vertex in 'vs' that is not 'u' or 'x'.
763,cdk,"private String parseLevelOfTheory(String line){
    StringBuffer summary = new StringBuffer();
    summary.append(line);
    try {
        do {
            line = input.readLine().trim();
            summary.append(line);
        } while (!(line.indexOf('@') >= 0));
    } catch (Exception exc) {
        logger.debug(""syntax problem while parsing summary of g98 section: "");
        logger.debug(exc);
    }
    logger.debug(""parseLoT(): "" + summary.toString());
    StringTokenizer st1 = new StringTokenizer(summary.toString(), ""\\"");
    if (st1.countTokens() < 6) {
        return null;
    }
    for (int i = 0; i < 4; ++i) {
        st1.nextToken();
    }
    return st1.nextToken() + ""/"" + st1.nextToken();
}",parseLevelOfTheory,org/openscience/cdk/io/Gaussian98Reader.java,/storage/io/src/main/java/org/openscience/cdk/io/Gaussian98Reader.java,"/**
     * Select the theory and basis set from the first archive line.
     *
     * @param line Description of the Parameter
     * @return Description of the Return Value
     */",463-496,"('parseLevelOfTheory', {'INSTRUCTION': {'covered': 67, 'missed': 9}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 12, 'missed': 4}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",165.0,12.0,Select the theory and basis set from the first archive line.,Get the theory and basis set from the first archive line.,The basis and theory can be found in the first archive line.,0.237863388574842,Select the theory and base set from the first archive line.
767,incubator-shenyu,"public ShenyuAdminResult deleteShenyuDicts(@RequestBody @NotEmpty final List<@NotBlank String> ids){
    Integer deleteCount = shenyuDictService.deleteShenyuDicts(ids);
    return ShenyuAdminResult.success(ShenyuResultMessage.DELETE_SUCCESS, deleteCount);
}",deleteShenyuDicts,org/apache/shenyu/admin/controller/ShenyuDictController.java,/shenyu-admin/src/main/java/org/apache/shenyu/admin/controller/ShenyuDictController.java,"/**
     * batch delete some shenyu dicts by some id list.
     *
     * @param ids shenyu dict id list.
     * @return {@linkplain ShenyuAdminResult}
     */",126-136,"('deleteShenyuDicts', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,10.0,batch delete some shenyu dicts by some id list.,Delete some shenyu dicts by some id list.,Some shenyu dicts should be deleted by some id list.,0.576351733677674,delete in batches some shenyu dicts by a list of identifiers.
770,jooby,"public static Usage parameterNameNotPresent(@Nonnull Parameter parameter){
    Executable executable = parameter.getDeclaringExecutable();
    int p = Stream.of(executable.getParameters()).collect(Collectors.toList()).indexOf(parameter);
    String message = ""Unable to provision parameter at position: '"" + p + ""', require by: "" + ProvisioningException.toString(parameter.getDeclaringExecutable()) + "". Parameter's name is missing"";
    return new Usage(message, ""bean-converter-parameter-name-missing"");
}",parameterNameNotPresent,io/jooby/Usage.java,/jooby/src/main/java/io/jooby/Usage.java,"/**
   * Thrown when the reflective bean converter has no access to a parameter name. Compilation
   * must be done using <code>parameters</code> compiler option.
   *
   * @param parameter Parameter.
   * @return Usage exception.
   */",45-59,"('parameterNameNotPresent', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",80.0,14.0,Thrown when the reflective bean converter has no access to a parameter name.,Check if the parameter name is not present,Thrown when the bean is not able to access a name.,0.200686079023569,Lifted when the reflective bean converter does not have access to a parameter name.
771,cdk,"private StereoEncoderFactory makeStereoEncoderFactory(){
    if (stereoEncoders.isEmpty()) {
        return StereoEncoderFactory.EMPTY;
    } else if (stereoEncoders.size() == 1) {
        return stereoEncoders.get(0);
    } else {
        StereoEncoderFactory factory = new ConjugatedEncoderFactory(stereoEncoders.get(0), stereoEncoders.get(1));
        for (int i = 2; i < stereoEncoders.size(); i++) {
            factory = new ConjugatedEncoderFactory(factory, stereoEncoders.get(i));
        }
        return factory;
    }
}",makeStereoEncoderFactory,org/openscience/cdk/hash/HashGeneratorMaker.java,/tool/hash/src/main/java/org/openscience/cdk/hash/HashGeneratorMaker.java,"/**
     * Combines the separate stereo encoder factories into a single factory.
     *
     * @return a single stereo encoder factory
     */",272-289,"('makeStereoEncoderFactory', {'INSTRUCTION': {'covered': 50, 'missed': 6}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,11.0,Combines the separate stereo encoder factories into a single factory.,This method combines the separate stereo encoder factories into a single factory,The stereo Encoder factories are combined into a single factory.,0.635240705602855,Combines separate stereo encoder factories into a single factory.
772,cdk,"private boolean hasCandidate(int n){
    for (int j = (n * matrix.mCols), end = (j + matrix.mCols); j < end; j++) if (matrix.get(j))
        return true;
    return false;
}",hasCandidate,org/openscience/cdk/isomorphism/UllmannState.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/UllmannState.java,"/**
     * Check if there are any feasible mappings left for the query vertex n. We
     * scan the compatibility matrix to see if any value is > 0.
     *
     * @param n query vertex
     * @return a candidate is present
     */",219-230,"('hasCandidate', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,14.0,Check if there are any feasible mappings left for the query vertex n.,Verify if there are any feasible mappings left for the query vertex,"If there are any feasible mappings left, check them out.",0.275562067462428,Check to see if there are any feasible mappings left for the n query vertex.
773,cdk,"public void add3DCoordinatesForSinglyBondedLigands(IAtomContainer atomContainer) throws CDKException{
    IAtom refAtom = null;
    IAtom atomC = null;
    int nwanted = 0;
    for (int i = 0; i < atomContainer.getAtomCount(); i++) {
        refAtom = atomContainer.getAtom(i);
        if (refAtom.getAtomicNumber() != IElement.H && hasUnsetNeighbour(refAtom, atomContainer)) {
            IAtomContainer noCoords = getUnsetAtomsInAtomContainer(refAtom, atomContainer);
            IAtomContainer withCoords = getPlacedAtomsInAtomContainer(refAtom, atomContainer);
            if (withCoords.getAtomCount() > 0) {
                atomC = getPlacedHeavyAtomInAtomContainer(withCoords.getAtom(0), refAtom, atomContainer);
            }
            if (refAtom.getFormalNeighbourCount() == 0 && refAtom.getAtomicNumber() == IElement.C) {
                nwanted = noCoords.getAtomCount();
            } else if (refAtom.getFormalNeighbourCount() == 0 && refAtom.getAtomicNumber() != IElement.C) {
                nwanted = 4;
            } else {
                nwanted = refAtom.getFormalNeighbourCount() - withCoords.getAtomCount();
            }
            Point3d[] newPoints = get3DCoordinatesForLigands(refAtom, noCoords, withCoords, atomC, nwanted, DEFAULT_BOND_LENGTH_H, -1);
            for (int j = 0; j < noCoords.getAtomCount(); j++) {
                IAtom ligand = noCoords.getAtom(j);
                Point3d newPoint = rescaleBondLength(refAtom, ligand, newPoints[j]);
                ligand.setPoint3d(newPoint);
                ligand.setFlag(CDKConstants.ISPLACED, true);
            }
            noCoords.removeAllElements();
            withCoords.removeAllElements();
        }
    }
}",add3DCoordinatesForSinglyBondedLigands,org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,"/**
     *  Generate coordinates for all atoms which are singly bonded and have no
     *  coordinates. This is useful when hydrogens are present but have no coordinates.
     *  It knows about C, O, N, S only and will give tetrahedral or trigonal
     *  geometry elsewhere. Bond lengths are computed from covalent radii or taken
     *  out of a parameter set if available. Angles are tetrahedral or trigonal
     *
     * @param  atomContainer  the set of atoms involved
     * @throws CDKException
     * @cdk.keyword           coordinate calculation
     * @cdk.keyword           3D model
     */",77-121,"('add3DCoordinatesForSinglyBondedLigands', {'INSTRUCTION': {'covered': 106, 'missed': 17}, 'BRANCH': {'covered': 12, 'missed': 6}, 'LINE': {'covered': 22, 'missed': 2}, 'COMPLEXITY': {'covered': 6, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",296.0,14.0,Generate coordinates for all atoms which are singly bonded and have no  coordinates.,This method generates the coordinates for all atoms which are singly bonded and have no coordinates,All atoms have no coordinates.,0.171842265585327,Generate coordinates for all atoms that are individually bonded and do not have coordinates.
774,jackson-databind,"public static List<Class<?>> findSuperClasses(Class<?> cls, Class<?> endBefore, boolean addClassItself){
    List<Class<?>> result = new ArrayList<Class<?>>(8);
    if ((cls != null) && (cls != endBefore)) {
        if (addClassItself) {
            result.add(cls);
        }
        while ((cls = cls.getSuperclass()) != null) {
            if (cls == endBefore) {
                break;
            }
            result.add(cls);
        }
    }
    return result;
}",findSuperClasses,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * Method for finding all super classes (but not super interfaces) of given class,
     * starting with the immediate super class and ending in the most distant one.
     * Class itself is included if <code>addClassItself</code> is true.
     *<p>
     * NOTE: mostly/only called to resolve mix-ins as that's where we do not care
     * about fully-resolved types, just associated annotations.
     *
     * @since 2.7
     */",83-108,"('findSuperClasses', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",114.0,30.0,"Method for finding all super classes (but not super interfaces) of given class,  starting with the immediate super class and ending in the most distant one.",This method retrieves all super classes of a given class,The method for finding all super classes in a class is starting with the immediate super class and ending in the most distant one.,0.393550049906369,"Method for finding all super classes (but not super interfaces) of a given class, starting with the immediate superclass and ending with the furthest one."
775,cdk,"private static boolean testSubgraphHeuristics(IAtomContainer ac1, IAtomContainer ac2) throws CDKException{
    if (ac1 instanceof IQueryAtomContainer) {
        throw new CDKException(""The first IAtomContainer must not be an IQueryAtomContainer"");
    }
    int ac1SingleBondCount = 0;
    int ac1DoubleBondCount = 0;
    int ac1TripleBondCount = 0;
    int ac1AromaticBondCount = 0;
    int ac2SingleBondCount = 0;
    int ac2DoubleBondCount = 0;
    int ac2TripleBondCount = 0;
    int ac2AromaticBondCount = 0;
    int ac1SCount = 0;
    int ac1OCount = 0;
    int ac1NCount = 0;
    int ac1FCount = 0;
    int ac1ClCount = 0;
    int ac1BrCount = 0;
    int ac1ICount = 0;
    int ac1CCount = 0;
    int ac2SCount = 0;
    int ac2OCount = 0;
    int ac2NCount = 0;
    int ac2FCount = 0;
    int ac2ClCount = 0;
    int ac2BrCount = 0;
    int ac2ICount = 0;
    int ac2CCount = 0;
    IBond bond;
    IAtom atom;
    for (int i = 0; i < ac1.getBondCount(); i++) {
        bond = ac1.getBond(i);
        if (bond.getFlag(CDKConstants.ISAROMATIC)) {
            ac1AromaticBondCount++;
        } else if (bond.getOrder() == IBond.Order.SINGLE) {
            ac1SingleBondCount++;
        } else if (bond.getOrder() == IBond.Order.DOUBLE) {
            ac1DoubleBondCount++;
        } else if (bond.getOrder() == IBond.Order.TRIPLE) {
            ac1TripleBondCount++;
        }
    }
    for (int i = 0; i < ac2.getBondCount(); i++) {
        bond = ac2.getBond(i);
        if (bond instanceof IQueryBond) {
            continue;
        }
        if (bond.getFlag(CDKConstants.ISAROMATIC)) {
            ac2AromaticBondCount++;
        } else if (bond.getOrder() == IBond.Order.SINGLE) {
            ac2SingleBondCount++;
        } else if (bond.getOrder() == IBond.Order.DOUBLE) {
            ac2DoubleBondCount++;
        } else if (bond.getOrder() == IBond.Order.TRIPLE) {
            ac2TripleBondCount++;
        }
    }
    if (ac2SingleBondCount > ac1SingleBondCount) {
        return false;
    }
    if (ac2AromaticBondCount > ac1AromaticBondCount) {
        return false;
    }
    if (ac2DoubleBondCount > ac1DoubleBondCount) {
        return false;
    }
    if (ac2TripleBondCount > ac1TripleBondCount) {
        return false;
    }
    for (int i = 0; i < ac1.getAtomCount(); i++) {
        atom = ac1.getAtom(i);
        if (atom.getSymbol().equals(""S"")) {
            ac1SCount++;
        } else if (atom.getSymbol().equals(""N"")) {
            ac1NCount++;
        } else if (atom.getSymbol().equals(""O"")) {
            ac1OCount++;
        } else if (atom.getSymbol().equals(""F"")) {
            ac1FCount++;
        } else if (atom.getSymbol().equals(""Cl"")) {
            ac1ClCount++;
        } else if (atom.getSymbol().equals(""Br"")) {
            ac1BrCount++;
        } else if (atom.getSymbol().equals(""I"")) {
            ac1ICount++;
        } else if (atom.getSymbol().equals(""C"")) {
            ac1CCount++;
        }
    }
    for (int i = 0; i < ac2.getAtomCount(); i++) {
        atom = ac2.getAtom(i);
        if (atom instanceof IQueryAtom) {
            continue;
        }
        if (atom.getSymbol().equals(""S"")) {
            ac2SCount++;
        } else if (atom.getSymbol().equals(""N"")) {
            ac2NCount++;
        } else if (atom.getSymbol().equals(""O"")) {
            ac2OCount++;
        } else if (atom.getSymbol().equals(""F"")) {
            ac2FCount++;
        } else if (atom.getSymbol().equals(""Cl"")) {
            ac2ClCount++;
        } else if (atom.getSymbol().equals(""Br"")) {
            ac2BrCount++;
        } else if (atom.getSymbol().equals(""I"")) {
            ac2ICount++;
        } else if (atom.getSymbol().equals(""C"")) {
            ac2CCount++;
        }
    }
    if (ac1SCount < ac2SCount) {
        return false;
    }
    if (ac1NCount < ac2NCount) {
        return false;
    }
    if (ac1OCount < ac2OCount) {
        return false;
    }
    if (ac1FCount < ac2FCount) {
        return false;
    }
    if (ac1ClCount < ac2ClCount) {
        return false;
    }
    if (ac1BrCount < ac2BrCount) {
        return false;
    }
    if (ac1ICount < ac2ICount) {
        return false;
    }
    return ac1CCount >= ac2CCount;
}",testSubgraphHeuristics,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,"/**
     *  Checks some simple heuristics for whether the subgraph query can
     *  realistically be atom subgraph of the supergraph. If, for example, the
     *  number of nitrogen atoms in the query is larger than that of the supergraph
     *  it cannot be part of it.
     *
     * @param  ac1  the supergraph to be checked. Must not be an IQueryAtomContainer.
     * @param  ac2  the subgraph to be tested for. May be an IQueryAtomContainer.
     * @return    true if the subgraph ac2 has atom chance to be atom subgraph of ac1
     * @throws org.openscience.cdk.exception.CDKException if the first molecule is an instance
     * of IQueryAtomContainer
     */",1010-1163,"('testSubgraphHeuristics', {'INSTRUCTION': {'covered': 270, 'missed': 60}, 'BRANCH': {'covered': 56, 'missed': 30}, 'LINE': {'covered': 82, 'missed': 27}, 'COMPLEXITY': {'covered': 16, 'missed': 28}, 'METHOD': {'covered': 1, 'missed': 0}})",872.0,18.0,Checks some simple heuristics for whether the subgraph query can  realistically be atom subgraph of the supergraph.,Test if some simple heuristics for whether the subgraph query can realistically be atom subgraph of the supergraph.,The subgraph query can be considered an atom subgraph of the supergraph.,0.661331478498849,Check some simple heuristics to see if the subgraph query can realistically be an atom subgraph of the supergraph.
778,dcache,"public static boolean hasGid(Subject subject, long gid){
    Set<GidPrincipal> principals = subject.getPrincipals(GidPrincipal.class);
    for (GidPrincipal principal : principals) {
        if (principal.getGid() == gid) {
            return true;
        }
    }
    return false;
}",hasGid,org/dcache/auth/Subjects.java,/modules/common/src/main/java/org/dcache/auth/Subjects.java,"/**
     * Returns true if and only if the subject has the given group ID.
     */",114-126,"('hasGid', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,14.0,Returns true if and only if the subject has the given group ID.,Check if the given input has the given group ID,"If the subject has a group ID, this is true.",1.07957542541475,Returns true if and only if the object has the given group ID.
779,logstash-logback-encoder,"private void writeFieldsOfNode(JsonGenerator generator, JsonNode node) throws IOException{
    if (node != null) {
        for (Iterator<Entry<String, JsonNode>> fields = node.fields(); fields.hasNext(); ) {
            Entry<String, JsonNode> field = fields.next();
            generator.writeFieldName(field.getKey());
            generator.writeTree(field.getValue());
        }
    }
}",writeFieldsOfNode,net/logstash/logback/composite/GlobalCustomFieldsJsonProvider.java,/src/main/java/net/logstash/logback/composite/GlobalCustomFieldsJsonProvider.java,"/**
     * Writes the fields of the given node into the generator.
     */",53-64,"('writeFieldsOfNode', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",86.0,11.0,Writes the fields of the given node into the generator.,This method writes the fields of the given node into the generator,The fields are written into the generator.,0.323792363435738,Writes the fields of the given node to the generator.
780,matsim-libs,"public static double calcProjectedEuclideanDistance(Coord coord, Coord other){
    double xDiff = other.getX() - coord.getX();
    double yDiff = other.getY() - coord.getY();
    return Math.sqrt((xDiff * xDiff) + (yDiff * yDiff));
}",calcProjectedEuclideanDistance,org/matsim/core/utils/geometry/CoordUtils.java,/matsim/src/main/java/org/matsim/core/utils/geometry/CoordUtils.java,"/**
         * Method to deal with distance calculation when only the x and y-components
         * of the coordinates are used. The elevation (z component) is ignored,
         * whether it is available or not. 
         * (xy-plane)
         * @param coord
         * @param other
         * @return
         */",192-205,"('calcProjectedEuclideanDistance', {'INSTRUCTION': {'covered': 21, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,18.0,Method to deal with distance calculation when only the x and y-components  of the coordinates are used.,Calculate the distance when only x an y components are provided,"When only the x and y-components of the coordinates are used, the method is used.",0.551656199171314,Method for processing distance calculation when only the x and y components of the coordinates are used.
781,egeria,"public String createPortAlias(String userId, PortAlias portAlias, String processGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    return createPort(userId, portAlias, PORT_ALIAS_TYPE_NAME, processGUID, externalSourceName);
}",createPortAlias,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,"/**
     * Create the port alias and attach it to the process.
     *
     * @param userId             the name of the calling user
     * @param portAlias          the port alias values
     * @param processGUID        the unique identifier of the process
     * @param externalSourceName the unique name of the external source
     *
     * @return unique identifier of the port alias in the repository
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",100-118,"('createPortAlias', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,11.0,Create the port alias and attach it to the process.,This method builds the port alias and attach it to the process.,Attach the port to the process.,1.02391563562097,Create the port alias and attach it to the process.
782,cdk,"private IChemFile readChemFile(IChemFile chemFile){
    IChemSequence chemSequence;
    IChemModel chemModel;
    ICrystal crystal;
    try {
        String line = readLine();
        while (input.ready() && line != null) {
            if (line.startsWith(""%%Header Start"")) {
                while (input.ready() && line != null && !(line.startsWith(""%%Header End""))) {
                    if (line.startsWith(""%%Version Number"")) {
                        String version = readLine().trim();
                        if (!version.equals(""3.00"")) {
                            logger.error(""The PMPReader only supports PMP files with version 3.00"");
                            return null;
                        }
                    }
                    line = readLine();
                }
            } else if (line.startsWith(""%%Model Start"")) {
                modelStructure = chemFile.getBuilder().newInstance(IAtomContainer.class);
                while (input.ready() && line != null && !(line.startsWith(""%%Model End""))) {
                    Matcher objHeaderMatcher = objHeader.matcher(line);
                    if (objHeaderMatcher.matches()) {
                        String object = objHeaderMatcher.group(2);
                        constructObject(chemFile.getBuilder(), object);
                        int id = Integer.parseInt(objHeaderMatcher.group(1));
                        line = readLine();
                        while (input.ready() && line != null && !(line.trim().equals("")""))) {
                            Matcher objCommandMatcher = objCommand.matcher(line);
                            objHeaderMatcher = objHeader.matcher(line);
                            if (objHeaderMatcher.matches()) {
                                object = objHeaderMatcher.group(2);
                                id = Integer.parseInt(objHeaderMatcher.group(1));
                                constructObject(chemFile.getBuilder(), object);
                            } else if (objCommandMatcher.matches()) {
                                String format = objCommandMatcher.group(1);
                                String command = objCommandMatcher.group(2);
                                String field = objCommandMatcher.group(3);
                                processModelCommand(object, command, format, field);
                            } else {
                                logger.warn(""Skipping line: "" + line);
                            }
                            line = readLine();
                        }
                        if (chemObject instanceof IAtom) {
                            atomids.put(id, modelStructure.getAtomCount());
                            atomGivenIds.put(Integer.valueOf((String) chemObject.getProperty(PMP_ID)), id);
                            modelStructure.addAtom((IAtom) chemObject);
                        } else if (chemObject instanceof IBond) {
                        } else {
                            logger.error(""chemObject is not initialized or of bad class type"");
                        }
                    }
                    line = readLine();
                }
                assert line != null;
                if (line.startsWith(""%%Model End"")) {
                    int bondsFound = bondids.size();
                    logger.debug(""Found #bonds: "", bondsFound);
                    logger.debug(""#atom ones: "", bondAtomOnes.size());
                    logger.debug(""#atom twos: "", bondAtomTwos.size());
                    logger.debug(""#orders: "", bondOrders.size());
                    for (Integer index : bondids.keySet()) {
                        double order = (bondOrders.get(index) != null ? bondOrders.get(index) : 1.0);
                        logger.debug(""index: "", index);
                        logger.debug(""ones: "", bondAtomOnes.get(index));
                        IAtom atom1 = modelStructure.getAtom(atomids.get(bondAtomOnes.get(index)));
                        IAtom atom2 = modelStructure.getAtom(atomids.get(bondAtomTwos.get(index)));
                        IBond bond = modelStructure.getBuilder().newInstance(IBond.class, atom1, atom2);
                        if (order == 1.0) {
                            bond.setOrder(IBond.Order.SINGLE);
                        } else if (order == 2.0) {
                            bond.setOrder(IBond.Order.DOUBLE);
                        } else if (order == 3.0) {
                            bond.setOrder(IBond.Order.TRIPLE);
                        } else if (order == 4.0) {
                            bond.setOrder(IBond.Order.QUADRUPLE);
                        }
                        modelStructure.addBond(bond);
                    }
                }
            } else if (line.startsWith(""%%Traj Start"")) {
                chemSequence = chemFile.getBuilder().newInstance(IChemSequence.class);
                double energyFragment = 0.0;
                double energyTotal = 0.0;
                int Z = 1;
                while (input.ready() && line != null && !(line.startsWith(""%%Traj End""))) {
                    if (line.startsWith(""%%Start Frame"")) {
                        chemModel = chemFile.getBuilder().newInstance(IChemModel.class);
                        crystal = chemFile.getBuilder().newInstance(ICrystal.class);
                        while (input.ready() && line != null && !(line.startsWith(""%%End Frame""))) {
                            if (line.startsWith(""%%Atom Coords"")) {
                                if (energyFragment != 0.0 && energyTotal != 0.0) {
                                    Z = (int) Math.round(energyTotal / energyFragment);
                                    logger.debug(""Z derived from energies: "", Z);
                                }
                                int expatoms = modelStructure.getAtomCount();
                                for (int molCount = 1; molCount <= Z; molCount++) {
                                    IAtomContainer clone = modelStructure.getBuilder().newInstance(IAtomContainer.class);
                                    for (int i = 0; i < expatoms; i++) {
                                        line = readLine();
                                        IAtom a = clone.getBuilder().newInstance(IAtom.class);
                                        StringTokenizer st = new StringTokenizer(line, "" "");
                                        a.setPoint3d(new Point3d(Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken())));
                                        a.setCovalentRadius(0.6);
                                        IAtom modelAtom = modelStructure.getAtom(atomids.get(atomGivenIds.get(i + 1)));
                                        a.setSymbol(modelAtom.getSymbol());
                                        clone.addAtom(a);
                                    }
                                    rebonder.rebond(clone);
                                    crystal.add(clone);
                                }
                            } else if (line.startsWith(""%%E/Frag"")) {
                                line = readLine().trim();
                                energyFragment = Double.parseDouble(line);
                            } else if (line.startsWith(""%%Tot E"")) {
                                line = readLine().trim();
                                energyTotal = Double.parseDouble(line);
                            } else if (line.startsWith(""%%Lat Vects"")) {
                                StringTokenizer st;
                                line = readLine();
                                st = new StringTokenizer(line, "" "");
                                crystal.setA(new Vector3d(Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken())));
                                line = readLine();
                                st = new StringTokenizer(line, "" "");
                                crystal.setB(new Vector3d(Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken())));
                                line = readLine();
                                st = new StringTokenizer(line, "" "");
                                crystal.setC(new Vector3d(Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken())));
                            } else if (line.startsWith(""%%Space Group"")) {
                                line = readLine().trim();
                                if (""P 21 21 21 (1)"".equals(line)) {
                                    crystal.setSpaceGroup(""P 2_1 2_1 2_1"");
                                } else {
                                    crystal.setSpaceGroup(""P1"");
                                }
                            }
                            line = readLine();
                        }
                        chemModel.setCrystal(crystal);
                        chemSequence.addChemModel(chemModel);
                    }
                    line = readLine();
                }
                chemFile.addChemSequence(chemSequence);
            }
            line = readLine();
        }
    } catch (IOException e) {
        logger.error(""An IOException happened: "", e.getMessage());
        logger.debug(e);
        chemFile = null;
    } catch (CDKException e) {
        logger.error(""An CDKException happened: "", e.getMessage());
        logger.debug(e);
        chemFile = null;
    }
    return chemFile;
}",readChemFile,org/openscience/cdk/io/PMPReader.java,/storage/io/src/main/java/org/openscience/cdk/io/PMPReader.java,"/**
     *  Private method that actually parses the input to read a ChemFile
     *  object.
     *
     *  Each PMP frame is stored as a Crystal in a ChemModel. The PMP
     *  file is stored as a ChemSequence of ChemModels.
     *
     * @return A ChemFile containing the data parsed from input.
     */",181-383,"('readChemFile', {'INSTRUCTION': {'covered': 690, 'missed': 64}, 'BRANCH': {'covered': 69, 'missed': 25}, 'LINE': {'covered': 123, 'missed': 16}, 'COMPLEXITY': {'covered': 25, 'missed': 23}, 'METHOD': {'covered': 1, 'missed': 0}})",1532.0,13.0,Private method that actually parses the input to read a ChemFile  object.,This method parses the input to read a ChemFile  object,Private method that reads the input to the ChemFile object.,0.252968077086194,A private method that actually parses the input to read a ChemFile object.
783,glowstone,"public void remove(){
    removed = true;
    active = false;
    boundingBox = null;
    world.getEntityManager().unregister(this);
    server.getEntityIdManager().deallocate(this);
    this.setPassenger(null);
    leaveVehicle();
    ImmutableList.copyOf(this.leashedEntities).forEach(e -> unleash(e, UnleashReason.HOLDER_GONE));
    if (isLeashed()) {
        unleash(this, UnleashReason.HOLDER_GONE);
    }
}",remove,net/glowstone/entity/GlowEntity.java,/src/main/java/net/glowstone/entity/GlowEntity.java,"/**
     * Destroys this entity by removing it from the world and marking it as not being active.
     */",1126-1144,"('remove', {'INSTRUCTION': {'covered': 36, 'missed': 4}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 11, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,17.0,Destroys this entity by removing it from the world and marking it as not being active.,Delete this entity by removing it from the world and marking it as not being active,Removes this entity from the world and marks it as inactive.,0.236270404387271,Destroys this entity by removing it from the world and marking it as not being active.
784,cdk,"private static int permParity(final ILigand[] ligands){
    int swaps = 0;
    for (int j = 1, hi = ligands.length; j < hi; j++) {
        ILigand ligand = ligands[j];
        int i = j - 1;
        int cmp = 0;
        while ((i >= 0) && (cmp = cipRule.compare(ligand, ligands[i])) > 0) {
            ligands[i + 1] = ligands[i--];
            swaps++;
        }
        if (cmp == 0)
            return 0;
        ligands[i + 1] = ligand;
    }
    return (swaps & 0x1) == 0x1 ? -1 : +1;
}",permParity,org/openscience/cdk/geometry/cip/CIPTool.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/CIPTool.java,"/**
     * Obtain the permutation parity (-1,0,+1) to put the ligands in descending
     * order (highest first). A parity of 0 indicates two or more ligands were
     * equivalent.
     *
     * @param ligands the ligands to sort
     * @return parity, odd (-1), even (+1) or none (0)
     */",249-278,"('permParity', {'INSTRUCTION': {'covered': 63, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",137.0,21.0,"Obtain the permutation parity (-1,0,+1) to put the ligands in descending  order (highest first).",Get the permutation parity to put the ligands in descending order,The permutation parity is needed to place the ligands in descending order.,0.333805003665781,"Get the permutation parity (-1.0,+1) to put the ligands in descending order (highest first)."
785,cdk,"private Map<String, String> loadHydrogenDefinitions(InputStream hdefIn) throws IOException{
    final Map<String, String> hdefs = new HashMap<String, String>(200);
    BufferedReader br = new BufferedReader(new InputStreamReader(hdefIn));
    br.readLine();
    String line = null;
    while ((line = br.readLine()) != null) {
        String[] cols = line.split(""\t"");
        hdefs.put(cols[0].trim(), cols[3].trim());
    }
    return hdefs;
}",loadHydrogenDefinitions,org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,"/**
     * Hydrogen atom types are assigned based on their parent types. The mmff-symb-mapping file
     * provides this mapping.
     *
     * @param hdefIn input stream of mmff-symb-mapping.tsv
     * @return mapping of parent to hydrogen definitions
     * @throws IOException
     */",243-268,"('loadHydrogenDefinitions', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",114.0,11.0,Hydrogen atom types are assigned based on their parent types.,Loads hydrogen atom types based on their parent types,The hydrogen atom types are assigned based on their parent types.,0.324086402264527,The types of hydrogen atoms are assigned according to their parent types.
786,dcache,"private synchronized Map<String, Level> computeEffectiveMap(LoggerName logger){
    Map<String, Level> inheritedMap = getInheritedMap(logger);
    if (!isRoot(logger)) {
        LoggerName parent = logger.getParent();
        if (parent != null) {
            Map<String, Level> mergedMap = computeEffectiveMap(parent);
            mergedMap.putAll(inheritedMap);
            return mergedMap;
        }
    }
    return inheritedMap;
}",computeEffectiveMap,dmg/util/logback/FilterThresholdSet.java,/modules/cells/src/main/java/dmg/util/logback/FilterThresholdSet.java,"/**
     * Returns a map from appenders to levels for a logger.
     * <p>
     * The map contains the effective log levels, that is, the levels used for filtering log
     * events.
     */",193-210,"('computeEffectiveMap', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",81.0,11.0,Returns a map from appenders to levels for a logger.,Get a map from appenders to levels for a logger,A map is returned from the appenders to the levels.,0.463027028272017,Returns a map of the appendages at the levels of a recorder.
787,cdk,"public static IMolecularFormula removeElement(IMolecularFormula formula, IElement element){
    for (IIsotope isotope : getIsotopes(formula, element)) {
        formula.removeIsotope(isotope);
    }
    return formula;
}",removeElement,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * Removes all isotopes from a given element in the MolecularFormula.
     *
     * @param  formula   IMolecularFormula molecularFormula
     * @param  element   The IElement of the IIsotopes to be removed
     * @return           The molecularFormula with the isotopes removed
     */",206-218,"('removeElement', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,11.0,Removes all isotopes from a given element in the MolecularFormula.,This methods removes all isotopes from a given input in the MolecularFormula.,All elements in the MolecularFormula are removed.,0.396108163388387,Removes all isotopes of a given element in the MolecularFormula.
789,glowstone,"public void putDoubleList(@NonNls String key, List<Double> list){
    putList(key, TagType.DOUBLE, list, DoubleTag::new);
}",putDoubleList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Adds or replaces a list subtag with a list of doubles.
     *
     * @param key the key to write to
     * @param list the list contents as doubles, to convert to double tags
     */",977-985,"('putDoubleList', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,12.0,Adds or replaces a list subtag with a list of doubles.,Replaces or add a list subtag with a list of doubles,A list subtag is added or replaced with a list of doubles.,0.0885202813797454,Adds or replaces a list subtag with a duplicate list.
790,cdk,"public boolean contains(IIsotope isotope){
    for (IIsotope thisIsotope : isotopes()) {
        if (isTheSame(thisIsotope, isotope)) {
            return true;
        }
    }
    return false;
}",contains,org/openscience/cdk/formula/MolecularFormula.java,/base/data/src/main/java/org/openscience/cdk/formula/MolecularFormula.java,"/**
     *  True, if the MolecularFormula contains the given IIsotope object and not
     *  the instance. The method looks for other isotopes which has the same
     *  symbol, natural abundance and exact mass.
     *
     * @param  isotope  The IIsotope this MolecularFormula is searched for
     * @return          True, if the MolecularFormula contains the given isotope object
     */",133-149,"('contains', {'INSTRUCTION': {'covered': 21, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,15.0,"True, if the MolecularFormula contains the given IIsotope object and not  the instance.",This method returns true if the MolecularFormula contains the given IIsotope object and false otherwise,"If the MolecularFormula contains the IIsotope object, it's true.",0.347816804911243,"True, if molecularFormula contains the given IIsotope object, not the instance."
791,logstash-logback-encoder,"private NodeWriter<Event> initializeNodeWriter() throws JsonPatternException{
    AbstractJsonPatternParser<Event> parser = createParser(this.jsonFactory);
    parser.setOmitEmptyFields(omitEmptyFields);
    return parser.parse(pattern);
}",initializeNodeWriter,net/logstash/logback/composite/AbstractPatternJsonProvider.java,/src/main/java/net/logstash/logback/composite/AbstractPatternJsonProvider.java,"/**
     * Parses the pattern into a {@link NodeWriter}.
     * 
     * @return a {@link NodeWriter}
     * @throws JsonPatternException thrown in case of invalid pattern
     */",95-105,"('initializeNodeWriter', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,11.0,Parses the pattern into a {@link NodeWriter}.,Return a parser for a NodeWriter object,Parses the pattern into a writing program.,0.327252634615025,Parses the template in a {NodeWriter @link}.
792,jackson-databind,"public ObjectReader withValueToUpdate(Object value){
    if (value == _valueToUpdate)
        return this;
    if (value == null) {
        return _new(this, _config, _valueType, _rootDeserializer, null, _schema, _injectableValues, _dataFormatReaders);
    }
    JavaType t;
    if (_valueType == null) {
        t = _config.constructType(value.getClass());
    } else {
        t = _valueType;
    }
    return _new(this, _config, t, _rootDeserializer, value, _schema, _injectableValues, _dataFormatReaders);
}",withValueToUpdate,com/fasterxml/jackson/databind/ObjectReader.java,/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java,"/**
     * Method for constructing a new instance with configuration that
     * updates passed Object (as root value), instead of constructing 
     * a new value.
     *<p>
     * Note that the method does NOT change state of this reader, but
     * rather construct and returns a newly configured instance.
     */",792-822,"('withValueToUpdate', {'INSTRUCTION': {'covered': 54, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",97.0,25.0,"Method for constructing a new instance with configuration that  updates passed Object (as root value), instead of constructing   a new value.",Build a new instance with configuration that updates passed Object instead of constructing a new value.,The method for constructing a new instance with configuration that updates passed object is different from constructing a new value.,0.609135081155519,"A method of constructing a new instance with a configuration that updates the passed object (as a root value), instead of constructing a new value."
793,cdk,"public List vertexList(){
    List vertices = new ArrayList(edgeSet().size());
    Object startVertex = vertexSet().iterator().next();
    Object vertex = startVertex;
    Object previousVertex = null;
    Object nextVertex = null;
    while (nextVertex != startVertex) {
        assert (degreeOf(vertex) == 2);
        List edges = edgesOf(vertex);
        vertices.add(vertex);
        Edge edge = (Edge) edges.get(0);
        nextVertex = edge.oppositeVertex(vertex);
        if (nextVertex == previousVertex) {
            edge = (Edge) edges.get(1);
            nextVertex = edge.oppositeVertex(vertex);
        }
        previousVertex = vertex;
        vertex = nextVertex;
    }
    return vertices;
}",vertexList,org/openscience/cdk/ringsearch/cyclebasis/SimpleCycle.java,/legacy/src/main/java/org/openscience/cdk/ringsearch/cyclebasis/SimpleCycle.java,"/**
     * Returns a list of the vertices contained in this cycle.
     * The vertices are in the order of a traversal of the cycle.
     *
     * @return a list of the vertices contained in this cycle
     */",100-135,"('vertexList', {'INSTRUCTION': {'covered': 64, 'missed': 4}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",147.0,11.0,Returns a list of the vertices contained in this cycle.,Get a list of all the vertices in this cycle,The list contains the vertices.,0.373500147961908,Returns a list of the vertices in this cycle.
794,acs-aem-commons,"public Resource create(@Nonnull final Resource ensuredDefinition, @Nonnull final Resource oakIndexes) throws RepositoryException{
    final Node oakIndex = JcrUtil.copy(ensuredDefinition.adaptTo(Node.class), oakIndexes.adaptTo(Node.class), ensuredDefinition.getName());
    oakIndex.setPrimaryType(NT_OAK_QUERY_INDEX_DEFINITION);
    oakIndex.setProperty(JcrConstants.JCR_CREATED, Calendar.getInstance());
    oakIndex.setProperty(JcrConstants.JCR_CREATED_BY, ENSURE_OAK_INDEX_USER_NAME);
    log.info(""Created Oak Index at [ {} ] with Ensure Definition [ {} ]"", oakIndex.getPath(), ensuredDefinition.getPath());
    return ensuredDefinition.getResourceResolver().getResource(oakIndex.getPath());
}",create,com/adobe/acs/commons/oak/impl/EnsureOakIndexJobHandler.java,/bundle/src/main/java/com/adobe/acs/commons/oak/impl/EnsureOakIndexJobHandler.java,"/**
     * Create the oak index based on the ensure definition.
     *
     * @param ensuredDefinition the ensure definition
     * @param oakIndexes        the parent oak index folder
     * @return the updated oak index resource
     * @throws PersistenceException
     * @throws RepositoryException
     */",350-375,"('create', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",121.0,10.0,Create the oak index based on the ensure definition.,This method creates the oak index based on the ensure definition,The oak index is created based on the ensure definition.,0.338558939560389,Create the oak index based on the warranty definition.
795,cdk,"public int test(Permutation permutation){
    for (int i = 0; i < size; i++) {
        int x = permutation.get(base.get(i));
        Permutation h = permutations[i][x];
        if (h == null) {
            return i;
        } else {
            permutation.setTo(h.invert().multiply(permutation));
        }
    }
    return size;
}",test,org/openscience/cdk/group/PermutationGroup.java,/tool/group/src/main/java/org/openscience/cdk/group/PermutationGroup.java,"/**
     * Test a permutation to see if it is in the group. Note that this also
     * alters the permutation passed in.
     *
     * @param permutation the one to test
     * @return the position it should be in the group, if any
     */",384-402,"('test', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,12.0,Test a permutation to see if it is in the group.,Check if a permutation is in the group,"If you can test a permutation, it is in the group.",0.523861045048062,Test a swap to see if it is in the group.
796,shardingsphere-elasticjob,"public static CoordinatorRegistryCenter createCoordinatorRegistryCenter(final String connectString, final String namespace, final String digest){
    Hasher hasher = Hashing.sha256().newHasher().putString(connectString, StandardCharsets.UTF_8).putString(namespace, StandardCharsets.UTF_8);
    if (!Strings.isNullOrEmpty(digest)) {
        hasher.putString(digest, StandardCharsets.UTF_8);
    }
    HashCode hashCode = hasher.hash();
    return REG_CENTER_REGISTRY.computeIfAbsent(hashCode, unused -> {
        CoordinatorRegistryCenter result = newCoordinatorRegistryCenter(connectString, namespace, digest);
        result.init();
        return result;
    });
}",createCoordinatorRegistryCenter,org/apache/shardingsphere/elasticjob/lite/lifecycle/internal/reg/RegistryCenterFactory.java,/elasticjob-lite/elasticjob-lite-lifecycle/src/main/java/org/apache/shardingsphere/elasticjob/lite/lifecycle/internal/reg/RegistryCenterFactory.java,"/**
     * Create a {@link CoordinatorRegistryCenter} or return the existing one if there is one set up with the same {@code connectionString}, {@code namespace} and {@code digest} already.
     *
     * @param connectString registry center connect string
     * @param namespace registry center namespace
     * @param digest registry center digest
     * @return registry center
     */",43-62,"('createCoordinatorRegistryCenter', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",116.0,40.0,"Create a {@link CoordinatorRegistryCenter} or return the existing one if there is one set up with the same {@code connectionString}, {@code namespace} and {@code digest} already.",Build a CoordinatorRegistryCenter or return the existing one if there is one set up with the given connection string,"If there is one set up with the same @code connectionString, @code namespace and @code digest already, then create a @link coordinators or return the existing one.",1.09079148669036,"Create a {@link CoordinatorRegistryCenter} or return the existing one if there is already one with the same {@code connectionString}, {@code namespace} and {@code digest}."
799,dcache,"public StatePath childPath(){
    if (_elements == null || _elements.size() <= 1) {
        return null;
    }
    return new StatePath(_elements.subList(1, _elements.size()), _elements.size() - 1);
}",childPath,org/dcache/services/info/base/StatePath.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StatePath.java,"/**
     * Build a new StatePath that points to the same location from the immediate child's
     * point-of-view.  For example, if the current path is characterised as <tt>aa.bb.cc</tt>, then
     * the returned StatePath is characterised by <tt>bb.cc</tt>.
     * <p>
     * If the path has no children of children, null is returned.
     *
     * @return the path for the child element, or null if there is no child.
     */",377-392,"('childPath', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",52.0,17.0,Build a new StatePath that points to the same location from the immediate child's  point-of-view.,Create a new StatePath that points to the same location from the immediate child's point-of-view,A new StatePath should point to the same location as the one the child is currently in.,0.235997393693633,Create a new StatePath that points to the same location from the perspective of the immediate child.
800,weblogic-kubernetes-operator," static WlsDynamicServerConfig create(String name, int index, String clusterName, String domainName, boolean calculatedListenPorts, WlsServerConfig serverTemplate){
    Integer listenPort = serverTemplate.getListenPort();
    Integer sslListenPort = serverTemplate.getSslListenPort();
    List<NetworkAccessPoint> networkAccessPoints = new ArrayList<>();
    if (serverTemplate.getNetworkAccessPoints() != null) {
        for (NetworkAccessPoint networkAccessPoint : serverTemplate.getNetworkAccessPoints()) {
            Integer networkAccessPointListenPort = networkAccessPoint.getListenPort();
            if (calculatedListenPorts) {
                networkAccessPointListenPort = networkAccessPointListenPort == null ? (DEFAULT_NAP_LISTEN_PORT_RANGE_BASE + index) : networkAccessPointListenPort + index;
            }
            networkAccessPoints.add(new NetworkAccessPoint(networkAccessPoint.getName(), networkAccessPoint.getProtocol(), networkAccessPointListenPort, networkAccessPoint.getPublicPort()));
        }
    }
    // calculate listen ports if configured to do so
    if (calculatedListenPorts) {
        listenPort = (listenPort == null) ? (DEFAULT_LISTEN_PORT_RANGE_BASE + index) : (listenPort + index);
        sslListenPort = (sslListenPort == null) ? (DEFAULT_SSL_LISTEN_PORT_RANGE_BASE + index) : (sslListenPort + index);
    }
    MacroSubstitutor macroSubstitutor = new MacroSubstitutor(index, name, clusterName, domainName, serverTemplate.getMachineName());
    return new WlsDynamicServerConfig(name, listenPort, macroSubstitutor.substituteMacro(serverTemplate.getListenAddress()), sslListenPort, macroSubstitutor.substituteMacro(serverTemplate.getMachineName()), serverTemplate.getAdminPort(), networkAccessPoints);
}",create,oracle/kubernetes/operator/wlsconfig/WlsDynamicServerConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsDynamicServerConfig.java,"/**
   * Create a dynamic server config using server template and index number of this server.
   *
   * @param name Name of the server
   * @param index index of this server within the cluster, for example, the index of dserver-2 would
   *     be 2
   * @param clusterName name of the WLS cluster that this server belongs to
   * @param domainName name of the WLS domain that this server belongs to
   * @param calculatedListenPorts whether listen ports are calculated according to configuration in
   *     the dynamic cluster
   * @param serverTemplate server template used for servers in the dynamic cluster
   * @return a dynamic server configuration object containing configuration of this dynamic server
   */",47-106,"('create', {'INSTRUCTION': {'covered': 109, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 26, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",248.0,15.0,Create a dynamic server config using server template and index number of this server.,Build a dynamic server config using server template with the given index number,The server template and index number are used to create a dynamic server config.,0.322253237376107,Create a dynamic server configuration using the server model and index number of that server.
801,matsim-libs,"public static double calculateSpeedIfNoSpeedTag(double linkLength, LinkProperties properties){
    if (properties.hierarchyLevel > LinkProperties.LEVEL_MOTORWAY && properties.hierarchyLevel <= LinkProperties.LEVEL_TERTIARY && linkLength <= 300) {
        return ((2.7778 + (properties.freespeed - 2.7778) / 300 * linkLength));
    }
    return properties.freespeed;
}",calculateSpeedIfNoSpeedTag,org/matsim/contrib/osm/networkReader/LinkProperties.java,/contribs/osm/src/main/java/org/matsim/contrib/osm/networkReader/LinkProperties.java,"/**
         * For links with unknown max speed we assume that links with a length of less than 300m are urban links. For urban
         * links with a length of 0m the speed is 10km/h. For links with a length of 300m the speed is the default freespeed
         * property for that highway type. For links with a length between 0 and 300m the speed is interpolated linearly.
         * (2.778m/s ~ 10km/h)
         *
         * All links longer than 300m the default freesped property is assumed
         */",174-188,"('calculateSpeedIfNoSpeedTag', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,21.0,For links with unknown max speed we assume that links with a length of less than 300m are urban links.,Calculate the speed if the given speed tag is not provided,We assume links with a length of less than 300m are urban links.,0.340750096988916,"For links with an unknown maximum speed, we assume that links with a length of less than 300 m are urban links."
802,matsim-libs,"public static URL resolveFileOrResource(String filename) throws UncheckedIOException{
    try {
        // I) do not handle URLs
        if (filename.startsWith(""jar:file:"") || filename.startsWith(""file:"") || filename.startsWith(""https:"")) {
            // looks like an URI
            return new URL(filename);
        }
        // II) Replace home identifier
        if (filename.startsWith(""~"" + File.separator)) {
            filename = System.getProperty(""user.home"") + filename.substring(1);
        }
        // III.1) First, try to find the file in the file system
        File file = new File(filename);
        if (file.exists()) {
            logger.info(String.format(""Resolved %s to %s"", filename, file));
            return file.toURI().toURL();
        }
        // III.2) Try to find file with an additional postfix for compression
        for (String postfix : COMPRESSION_EXTENSIONS.keySet()) {
            file = new File(filename + ""."" + postfix);
            if (file.exists()) {
                logger.info(String.format(""Resolved %s to %s"", filename, file));
                return file.toURI().toURL();
            }
        }
        // IV.1) First, try to find the file in the class path
        URL resource = IOUtils.class.getClassLoader().getResource(filename);
        if (resource != null) {
            logger.info(String.format(""Resolved %s to %s"", filename, resource));
            return resource;
        }
        // IV.2) Second, try to find the resource with a compression extension
        for (String postfix : COMPRESSION_EXTENSIONS.keySet()) {
            resource = IOUtils.class.getClassLoader().getResource(filename + ""."" + postfix);
            if (resource != null) {
                logger.info(String.format(""Resolved %s to %s"", filename, resource));
                return resource;
            }
        }
        throw new FileNotFoundException(filename);
    } catch (FileNotFoundException | MalformedURLException e) {
        throw new UncheckedIOException(e);
    }
}",resolveFileOrResource,org/matsim/core/utils/io/IOUtils.java,/matsim/src/main/java/org/matsim/core/utils/io/IOUtils.java,"/**
         * This function takes a path and tries to find the file in the file system or
         * in the resource path. The order of resolution is as follows:
         * 
         * <ol>
         * <li>Find path in file system</li>
         * <li>Find path in file system with compression extension (e.g. *.gz)</li>
         * <li>Find path in class path as resource</li>
         * <li>Find path in class path with compression extension</li>
         * </ol>
         *
         * In case the filename is a URL (i.e. starting with ""file:"" or ""jar:file:""),
         * then no resolution is done but the provided filename returned as URL.
         * 
         * @throws UncheckedIOException
         */",154-223,"('resolveFileOrResource', {'INSTRUCTION': {'covered': 159, 'missed': 7}, 'BRANCH': {'covered': 17, 'missed': 3}, 'LINE': {'covered': 26, 'missed': 1}, 'COMPLEXITY': {'covered': 8, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",311.0,21.0,This function takes a path and tries to find the file in the file system or  in the resource path.,This function tries to find in the given path if the file is in the file system or in the resource path,The function tries to find the file in the file system or the resource path.,0.429762610946329,This function takes a path and attempts to find the file in the file system or in the resource path.
804,cdk,"public void addMolecule(IAtomContainer molecule){
    if (!GeometryUtil.has2DCoordinates(molecule))
        throw new IllegalArgumentException(""Template did not have 2D coordinates"");
    GeometryUtil.scaleMolecule(molecule, GeometryUtil.getScaleFactor(molecule, StructureDiagramGenerator.DEFAULT_BOND_LENGTH));
    templates.add(molecule);
    anonPatterns.add(VentoFoggia.findSubstructure(molecule, anonAtomMatcher, anonBondMatcher));
    elemPatterns.add(VentoFoggia.findSubstructure(molecule, elemAtomMatcher, anonBondMatcher));
}",addMolecule,org/openscience/cdk/layout/TemplateHandler.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/TemplateHandler.java,"/**
     * Adds a Molecule to the list of templates use by this TemplateHandler.
     *
     * @param molecule The molecule to be added to the TemplateHandler
     */",151-171,"('addMolecule', {'INSTRUCTION': {'covered': 34, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",83.0,13.0,Adds a Molecule to the list of templates use by this TemplateHandler.,This method adds the given molecule to the list of templates use by this TemplateHandler,A Molecule is added to the list of templates.,0.548572477539528,Adds a molecule to the list of templates used by this TemplateHandler.
805,openapi-generator,"public static boolean isMapSchema(Schema schema){
    if (schema instanceof MapSchema) {
        return true;
    }
    if (schema == null) {
        return false;
    }
    if (schema.getAdditionalProperties() instanceof Schema) {
        return true;
    }
    if (schema.getAdditionalProperties() instanceof Boolean && (Boolean) schema.getAdditionalProperties()) {
        return true;
    }
    return false;
}",isMapSchema,org/openapitools/codegen/utils/ModelUtils.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ModelUtils.java,"/**
     * Return true if the specified 'schema' is an object that can be extended with additional properties.
     * Additional properties means a Schema should support all explicitly defined properties plus any
     * undeclared properties.
     *
     * A MapSchema differs from an ObjectSchema in the following way:
     * - An ObjectSchema is not extensible, i.e. it has a fixed number of properties.
     * - A MapSchema is an object that can be extended with an arbitrary set of properties.
     *   The payload may include dynamic properties.
     *
     * Note that isMapSchema returns true for a composed schema (allOf, anyOf, oneOf) that also defines
     * additionalproperties.
     *
     * For example, an OpenAPI schema is considered a MapSchema in the following scenarios:
     *
     *   type: object
     *   additionalProperties: true
     *
     *   type: object
     *   additionalProperties:
     *     type: object
     *     properties:
     *       code:
     *         type: integer
     *
     *   allOf:
     *     - $ref: '#/components/schemas/Class1'
     *     - $ref: '#/components/schemas/Class2'
     *   additionalProperties: true
     *
     * @param schema the OAS schema
     * @return true if the specified schema is a Map schema.
     */",477-528,"('isMapSchema', {'INSTRUCTION': {'covered': 24, 'missed': 4}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 7, 'missed': 2}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,18.0,Return true if the specified 'schema' is an object that can be extended with additional properties.,Check if the specified 'schema' is an object that can be extended with additional properties.,"If the specified'schema' is an object that can be extended with additional properties, return true.",0.516999053887491,Return true if the specified 'schema' is an object that can be extended with additional properties.
806,cdk,"private int sortClockwise(int[] indices, IAtom focus, IAtom[] atoms, int n){
    int x = 0;
    for (int j = 1; j < n; j++) {
        int v = indices[j];
        int i = j - 1;
        while ((i >= 0) && less(v, indices[i], atoms, focus.getPoint2d())) {
            indices[i + 1] = indices[i--];
            x++;
        }
        indices[i + 1] = v;
    }
    return indexParity(x);
}",sortClockwise,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,"/**
     * Sort the {@code indices}, which correspond to an index in the {@code atoms} array in
     * clockwise order.
     *
     * @param indices indices, 0 to n
     * @param focus   the central atom
     * @param atoms   the neighbors of the focus
     * @param n       the number of neighbors
     * @return the permutation parity of the sort
     */",1135-1157,"('sortClockwise', {'INSTRUCTION': {'covered': 49, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",117.0,25.0,"Sort the {@code indices}, which correspond to an index in the {@code atoms} array in  clockwise order.",This method sorts the given indices in clockwise order,Sort the @code indices by their index in the @code atoms array.,0.808115623973241,"Sort the {@code indices}, which correspond to an index in the table {@code atoms} clockwise."
807,liquibase,"private void parseDefaultPropertyFileFromFile(File potentialPropertyFile) throws IOException, CommandLineParsingException{
    try (FileInputStream stream = new FileInputStream(potentialPropertyFile)) {
        parsePropertiesFile(stream);
    }
}",parseDefaultPropertyFileFromFile,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,"/**
     * Open a regular property file (not embedded in a resource - use {@link #parseDefaultPropertyFileFromResource}
     * for that) and parse it.
     *
     * @param potentialPropertyFile path and file name to the the property file
     * @throws IOException                 if the file cannot be opened
     * @throws CommandLineParsingException if an error occurs during parsing
     */",799-812,"('parseDefaultPropertyFileFromFile', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,26.0,Open a regular property file (not embedded in a resource - use {@link #parseDefaultPropertyFileFromResource}  for that) and parse it.,Open a regular property file and parse it,Parse a regular property file if it is not embedded in a resource.,0.273177176905171,Open a standard properties file (not embedded in a resource - use {@link #parseDefaultPropertyFileFromResource} for this) and parse it.
808,matsim-libs,"private void visitNode(final Node n, final AStarNodeData data, final RouterPriorityQueue<Node> pendingNodes, final double time, final double cost, final double expectedRemainingCost, final Link outLink){
    data.setExpectedRemainingCost(expectedRemainingCost);
    super.visitNode(n, data, pendingNodes, time, cost, outLink);
}",visitNode,org/matsim/core/router/AStarEuclidean.java,/matsim/src/main/java/org/matsim/core/router/AStarEuclidean.java,"/**
         * Inserts the given Node n into the pendingNodes queue and updates its time and cost information.
         * 
         * @param n The Node that is revisited.
         * @param data The data for node.
         * @param pendingNodes The nodes visited and not processed yet.
         * @param time The time of the visit of n.
         * @param cost The accumulated cost at the time of the visit of n.
         * @param expectedRemainingCost The expected remaining travel cost when
         * traveling from n to the target node of the route.
         * @param outLink The link from which we came visiting n.
         */",184-200,"('visitNode', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,17.0,Inserts the given Node n into the pendingNodes queue and updates its time and cost information.,Add the given Node into the pendingNodes queue and updates its time and cost information,The given Node n is put into the pendingNodes queue and updated with time and cost information.,0.929030666264896,Inserts the given node n into the pendingNodes queue and updates its time and cost information.
809,dataverse," Optional<MailDomainGroup> findByAlias(String groupAlias){
    try {
        return Optional.of(em.createNamedQuery(""MailDomainGroup.findByPersistedGroupAlias"", MailDomainGroup.class).setParameter(""persistedGroupAlias"", groupAlias).getSingleResult());
    } catch (NoResultException nre) {
        return Optional.empty();
    }
}",findByAlias,edu/harvard/iq/dataverse/authorization/groups/impl/maildomain/MailDomainGroupServiceBean.java,/src/main/java/edu/harvard/iq/dataverse/authorization/groups/impl/maildomain/MailDomainGroupServiceBean.java,"/**
     * Find a specific mail domain group by it's alias.
     * @param groupAlias
     * @return
     */",114-129,"('findByAlias', {'INSTRUCTION': {'covered': 12, 'missed': 3}, 'LINE': {'covered': 4, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",56.0,11.0,Find a specific mail domain group by it's alias.,This method returns a specific mail domain group by it is alias,You can find a mail domain group by it's name.,0.496816643003777,Find a specific email domain group by its alias.
810,metrics,"public void addListener(MetricRegistryListener listener){
    listeners.add(listener);
    for (Map.Entry<MetricName, Metric> entry : metrics.entrySet()) {
        notifyListenerOfAddedMetric(listener, entry.getValue(), entry.getKey());
    }
}",addListener,io/dropwizard/metrics5/MetricRegistry.java,/metrics-core/src/main/java/io/dropwizard/metrics5/MetricRegistry.java,"/**
     * Adds a {@link MetricRegistryListener} to a collection of listeners that will be notified on
     * metric creation.  Listeners will be notified in the order in which they are added.
     * <p>
     * <b>N.B.:</b> The listener will be notified of all existing metrics when it first registers.
     *
     * @param listener the listener that will be notified
     */",395-409,"('addListener', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,20.0,Adds a {@link MetricRegistryListener} to a collection of listeners that will be notified on  metric creation.,This method adds a MetricRegistryListener to a collection of listeners that will be notified on metric creation event,A collection of listeners that will be notified on metric creation is added.,0.402212933612295,Adds a {@link MetricRegistryListener} to a collection of listeners that will be notified when the metric is created.
811,cdk,"public void removeMonomer(String name){
    if (monomers.containsKey(name)) {
        Monomer monomer = (Monomer) monomers.get(name);
        this.remove(monomer);
        monomers.remove(name);
    }
}",removeMonomer,org/openscience/cdk/Polymer.java,/base/data/src/main/java/org/openscience/cdk/Polymer.java,"/**
     * Removes a particular monomer, specified by its name.
     *
     * @param name The name of the monomer to remove
     */",129-141,"('removeMonomer', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,10.0,"Removes a particular monomer, specified by its name.",This method deletes a particular monomer by its name,A particular monomer is removed.,0.278849097620756,"Removes a particular monomer, specified by name."
812,glowstone,"public static int calculateNeededBits(int number){
    int count = 0;
    do {
        count++;
        number >>>= 1;
    } while (number != 0);
    return count;
}",calculateNeededBits,net/glowstone/util/VariableValueArray.java,/src/main/java/net/glowstone/util/VariableValueArray.java,"/**
     * Calculates the number of bits that would be needed to store the given value.
     *
     * @param number the value
     * @return The number of bits that would be needed to store the value.
     */",40-53,"('calculateNeededBits', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,15.0,Calculates the number of bits that would be needed to store the given value.,This method returns the number of bits that would be needed to store the given value,The number of bits needed to store the value is calculated.,0.317824860098832,Calculates the number of bits needed to store the given value.
813,matsim-libs,"public Iterator<E> iterator(){
    return new Iterator<E>() {

        final Iterator<E> iterDelegate = PseudoRemovePriorityQueue.this.lastEntry.keySet().iterator();

        @Override
        public boolean hasNext() {
            return this.iterDelegate.hasNext();
        }

        @Override
        public E next() {
            return this.iterDelegate.next();
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    };
}",iterator,org/matsim/core/utils/collections/PseudoRemovePriorityQueue.java,/matsim/src/main/java/org/matsim/core/utils/collections/PseudoRemovePriorityQueue.java,"/**
         * Returns an iterator over the elements in this queue. The iterator
         * does not return the elements in any particular order. Removing
         * elements is not supported via the iterator.
         *
         * @return an iterator over the elements in this queue.
         */",164-192,"('iterator', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",93.0,10.0,Returns an iterator over the elements in this queue.,This method get an iterator over the elements in this queue,The elements are in this queue.,0.313138569855149,Returns an iterator on the items in this queue.
815,dcache,"public static CompletableFuture<T> fromListenableFuture(ListenableFuture<T> listenable){
    final CompletableFuture<T> completable = new CompletableFuture<T>() {

        @Override
        public boolean cancel(boolean mayInterruptIfRunning) {
            boolean result = listenable.cancel(mayInterruptIfRunning);
            super.cancel(mayInterruptIfRunning);
            return result;
        }
    };
    Futures.addCallback(listenable, new FutureCallback<T>() {

        @Override
        public void onSuccess(T result) {
            completable.complete(result);
        }

        @Override
        public void onFailure(Throwable t) {
            completable.completeExceptionally(t);
        }
    }, MoreExecutors.directExecutor());
    return completable;
}",fromListenableFuture,org/dcache/util/CompletableFutures.java,/modules/common/src/main/java/org/dcache/util/CompletableFutures.java,"/**
     * Create a CompletableFuture from guava's ListenableFuture to help migration from Guava to
     * Java8.
     *
     * @param listenable ListenableFuture to convert.
     * @return new CompletableFuture.
     */",80-112,"('fromListenableFuture', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",126.0,15.0,Create a CompletableFuture from guava's ListenableFuture to help migration from Guava to  Java8.,This method helps to migration from Guava to Java8 by building a CompletableFuture from Guava's ListenableFuture,The ListenableFuture can be used to help migrate from Guava to Java8.,0.64040416481572,Create a CompleteableFuture from Guava's ListenableFuture to make it easier to migrate from Guava to Java8.
816,cdk,"private static boolean has2DCoordinates(List<IBond> bonds){
    for (IBond bond : bonds) {
        if (bond.getBegin().getPoint2d() == null || bond.getEnd().getPoint2d() == null)
            return false;
    }
    return true;
}",has2DCoordinates,org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,"/**
     * Check if all atoms in the bond list have 2D coordinates. There is some
     * redundant checking but the list will typically be short.
     *
     * @param bonds the bonds to check
     * @return whether all atoms have 2D coordinates
     */",292-304,"('has2DCoordinates', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,12.0,Check if all atoms in the bond list have 2D coordinates.,Verify if all atoms in the bond list have 2D coordinates or not,"If all the atoms in the bond list have 2D coordinates, you should check them.",0.253433606725007,Check if all the atoms in the list of bonds have 2D coordinates.
817,cdk,"public static Rectangle2D shiftContainer(IAtomContainer container, Rectangle2D bounds, Rectangle2D last, double gap){
    if (last.getMaxX() + gap >= bounds.getMinX()) {
        double xShift = last.getMaxX() + gap - bounds.getMinX();
        Vector2d shift = new Vector2d(xShift, 0.0);
        GeometryTools.translate2D(container, shift);
        return new Rectangle2D.Double(bounds.getX() + xShift, bounds.getY(), bounds.getWidth(), bounds.getHeight());
    } else {
        return bounds;
    }
}",shiftContainer,org/openscience/cdk/geometry/GeometryTools.java,/legacy/src/main/java/org/openscience/cdk/geometry/GeometryTools.java,"/**
     * Shift the container horizontally to the right to make its bounds not
     * overlap with the other bounds.
     *
     * @param container the {@link IAtomContainer} to shift to the right
     * @param bounds    the {@link Rectangle2D} of the {@link IAtomContainer}
     *                  to shift
     * @param last      the bounds that is used as reference
     * @param gap       the gap between the two {@link Rectangle2D}s
     * @return          the {@link Rectangle2D} of the {@link IAtomContainer}
     *                  after the shift
     */",1637-1660,"('shiftContainer', {'INSTRUCTION': {'covered': 39, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",113.0,18.0,Shift the container horizontally to the right to make its bounds not  overlap with the other bounds.,This method shifts the given container horizontally from left to the right to make its bounds not overlap with the other bounds,The container's bounds should not overlap with the other bounds.,0.337983073458898,Move the container horizontally to the right so that its boundaries do not overlap with the other boundaries.
818,cdk,"public boolean hasNext(){
    if (nextAvailableIsKnown) {
        return hasNext;
    }
    hasNext = false;
    nextMolecule = null;
    try {
        currentFormat = (IChemFormat) MDLFormat.getInstance();
        int lineNum = 0;
        buffer.setLength(0);
        while ((currentLine = input.readLine()) != null) {
            buffer.append(currentLine).append(LINE_SEPARATOR);
            lineNum++;
            if (lineNum == 4) {
                Matcher versionMatcher = MDL_VERSION.matcher(currentLine);
                if (versionMatcher.find()) {
                    currentFormat = ""2000"".equals(versionMatcher.group(1)) ? (IChemFormat) MDLV2000Format.getInstance() : (IChemFormat) MDLV3000Format.getInstance();
                }
            }
            if (currentLine.startsWith(M_END)) {
                logger.debug(""MDL file part read: "", buffer);
                IAtomContainer molecule = null;
                try {
                    ISimpleChemObjectReader reader = getReader(currentFormat);
                    reader.setReader(new StringReader(buffer.toString()));
                    molecule = reader.read(builder.newAtomContainer());
                } catch (Exception exception) {
                    logger.error(""Error while reading next molecule: "" + exception.getMessage());
                    logger.debug(exception);
                }
                if (molecule != null) {
                    readDataBlockInto(molecule);
                    hasNext = true;
                    nextAvailableIsKnown = true;
                    nextMolecule = molecule;
                    return true;
                } else if (skip) {
                    String line;
                    while ((line = input.readLine()) != null) {
                        if (line.startsWith(SDF_RECORD_SEPARATOR)) {
                            break;
                        }
                    }
                } else {
                    return false;
                }
                buffer.setLength(0);
                lineNum = 0;
            }
            if (currentLine.startsWith(SDF_RECORD_SEPARATOR)) {
                buffer.setLength(0);
                lineNum = 0;
            }
        }
    } catch (IOException exception) {
        logger.error(""Error while reading next molecule: "" + exception.getMessage());
        logger.debug(exception);
    }
    return false;
}",hasNext,org/openscience/cdk/io/iterator/IteratingSDFReader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/iterator/IteratingSDFReader.java,"/**
     * Returns true if another {@link IAtomContainer} can be read.
     */",217-304,"('hasNext', {'INSTRUCTION': {'covered': 157, 'missed': 27}, 'BRANCH': {'covered': 18, 'missed': 4}, 'LINE': {'covered': 40, 'missed': 7}, 'COMPLEXITY': {'covered': 8, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",368.0,13.0,Returns true if another {@link IAtomContainer} can be read.,Check if the another IAtomContainer can be read,"If another @link IAtomContainer can be read, this is true.",1.01752169623892,Returns true if another {@link IAtomContainer} can be read.
819,cdk,"TextOutline positionSubscript(TextOutline label, TextOutline subscript){
    final Rectangle2D hydrogenBounds = label.getBounds();
    final Rectangle2D hydrogenCountBounds = subscript.getBounds();
    subscript = subscript.translate((hydrogenBounds.getMaxX() + padding) - hydrogenCountBounds.getMinX(), (hydrogenBounds.getMaxY() + (hydrogenCountBounds.getHeight() / 2)) - hydrogenCountBounds.getMaxY());
    return subscript;
}",positionSubscript,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,"/**
     * Positions an outline in the subscript position relative to another 'primary' label.
     *
     * @param label     a label outline
     * @param subscript the label outline to position as subscript
     * @return positioned subscript outline
     */",462-475,"('positionSubscript', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",81.0,14.0,Positions an outline in the subscript position relative to another 'primary' label.,Move the outline in the subscript position relative to another 'primary' label,An outline is placed in the subscript position.,0.438770897641128,"Positions an outline in the subscript position relative to another ""primary"" label."
820,cdk,"public int firstIndexOfDifference(Permutation other){
    int r = 0;
    while ((r < values.length) && values[r] == other.get(r)) {
        r++;
    }
    return r;
}",firstIndexOfDifference,org/openscience/cdk/group/Permutation.java,/tool/group/src/main/java/org/openscience/cdk/group/Permutation.java,"/**
     * Find an r such that this[r] != other[r].
     * @param other the other permutation to compare with
     * @return the first point at which the two permutations differ
     */",140-151,"('firstIndexOfDifference', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,16.0,Find an r such that this[r] != other[r].,Return the index such that this[index] != other[index].,Find an r such that this is the other.,0.478617271546198,Find an r such as this[r]!= other[r].
821,tablesaw,"protected PrimitiveIterator.OfInt sourceRowNumberIterator(){
    if (this.isSorted()) {
        return Arrays.stream(sortOrder).iterator();
    } else if (this.hasSelection()) {
        return selection.iterator();
    }
    return Selection.withRange(0, table.rowCount()).iterator();
}",sourceRowNumberIterator,tech/tablesaw/table/TableSlice.java,/core/src/main/java/tech/tablesaw/table/TableSlice.java,"/**
   * IntIterator of source table row numbers that are present in this view. This can be used to in
   * combination with the source table to iterate over the cells of a column in a sorted order
   * without copying the column.
   *
   * @return an int iterator of row numbers in the source table that are present in this view.
   */",191-205,"('sourceRowNumberIterator', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,13.0,IntIterator of source table row numbers that are present in this view.,Creates the IntIterator of source table row numbers that are present in this view,There are source table row numbers in this view.,0.206926173967,IntIterator of the row numbers of the source table present in this view.
822,cdk,"static IAtomContainer apply(IAtomContainer container){
    int n = container.getAtomCount();
    int[] valences = new int[n];
    Map<IAtom, Integer> atomToIndex = new HashMap<>(2 * n);
    for (IAtom atom : container.atoms()) atomToIndex.put(atom, atomToIndex.size());
    // compute the bond order sums
    for (IBond bond : container.bonds()) {
        int u = atomToIndex.get(bond.getBegin());
        int v = atomToIndex.get(bond.getEnd());
        int bondOrder = bond.getOrder().numeric();
        valences[u] += bondOrder;
        valences[v] += bondOrder;
    }
    for (int i = 0; i < n; i++) {
        IAtom atom = container.getAtom(i);
        Integer charge = atom.getFormalCharge();
        Integer element = atom.getAtomicNumber();
        if (element == null)
            continue;
        // unset = 0 in this case
        charge = charge == null ? 0 : charge;
        int explicit = valences[i];
        // if there was a valence read from the mol file use that otherwise
        // use the default value from the valence model to set the correct
        // number of implied hydrogens
        if (atom.getValency() != null) {
            atom.setImplicitHydrogenCount(atom.getValency() - explicit);
        } else {
            int implicit = implicitValence(element, charge, valences[i]);
            atom.setImplicitHydrogenCount(implicit - explicit);
            atom.setValency(implicit);
        }
    }
    return container;
}",apply,org/openscience/cdk/io/MDLValence.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLValence.java,"/**
     * Apply the MDL valence model to the provided atom container.
     *
     * @param container an atom container loaded from an MDL format
     * @return the container (for convenience)
     */",54-107,"('apply', {'INSTRUCTION': {'covered': 139, 'missed': 3}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 25, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",271.0,11.0,Apply the MDL valence model to the provided atom container.,This method applies the MDL valence model to the provided atom container.,The provided atom container has a MDL model applied to it.,0.267411522528055,Apply the MDL valence model to the supplied atom container.
823,cdk,"public static List<IAtomContainer> sample(IAtomContainer ac){
    LOGGER.debug(""RandomGenerator->mutate() Start"");
    List<IAtomContainer> structures = new ArrayList<IAtomContainer>();
    int nrOfAtoms = ac.getAtomCount();
    double a11 = 0, a12 = 0, a22 = 0, a21 = 0;
    double b11 = 0, lowerborder = 0, upperborder = 0;
    double b12 = 0;
    double b21 = 0;
    double b22 = 0;
    double[] cmax = new double[4];
    double[] cmin = new double[4];
    IAtomContainer newAc = null;
    IAtom ax1 = null, ax2 = null, ay1 = null, ay2 = null;
    IBond b1 = null, b2 = null, b3 = null, b4 = null;
    // int[] choices = new int[3];
    /* We need at least two non-zero bonds in order to be successful */
    int nonZeroBondsCounter = 0;
    for (int x1 = 0; x1 < nrOfAtoms; x1++) {
        for (int x2 = x1 + 1; x2 < nrOfAtoms; x2++) {
            for (int y1 = x2 + 1; y1 < nrOfAtoms; y1++) {
                for (int y2 = y1 + 1; y2 < nrOfAtoms; y2++) {
                    nonZeroBondsCounter = 0;
                    ax1 = ac.getAtom(x1);
                    ay1 = ac.getAtom(y1);
                    ax2 = ac.getAtom(x2);
                    ay2 = ac.getAtom(y2);
                    /* Get four bonds for these four atoms */
                    b1 = ac.getBond(ax1, ay1);
                    if (b1 != null) {
                        a11 = BondManipulator.destroyBondOrder(b1.getOrder());
                        nonZeroBondsCounter++;
                    } else {
                        a11 = 0;
                    }
                    b2 = ac.getBond(ax1, ay2);
                    if (b2 != null) {
                        a12 = BondManipulator.destroyBondOrder(b2.getOrder());
                        nonZeroBondsCounter++;
                    } else {
                        a12 = 0;
                    }
                    b3 = ac.getBond(ax2, ay1);
                    if (b3 != null) {
                        a21 = BondManipulator.destroyBondOrder(b3.getOrder());
                        nonZeroBondsCounter++;
                    } else {
                        a21 = 0;
                    }
                    b4 = ac.getBond(ax2, ay2);
                    if (b4 != null) {
                        a22 = BondManipulator.destroyBondOrder(b4.getOrder());
                        nonZeroBondsCounter++;
                    } else {
                        a22 = 0;
                    }
                    if (nonZeroBondsCounter > 1) {
                        /*
                             * Compute the range for b11 (see Faulons formulae
                             * for details)
                             */
                        cmax[0] = 0;
                        cmax[1] = a11 - a22;
                        cmax[2] = a11 + a12 - 3;
                        cmax[3] = a11 + a21 - 3;
                        cmin[0] = 3;
                        cmin[1] = a11 + a12;
                        cmin[2] = a11 + a21;
                        cmin[3] = a11 - a22 + 3;
                        lowerborder = MathTools.max(cmax);
                        upperborder = MathTools.min(cmin);
                        for (b11 = lowerborder; b11 <= upperborder; b11++) {
                            if (b11 != a11) {
                                b12 = a11 + a12 - b11;
                                b21 = a11 + a21 - b11;
                                b22 = a22 - a11 + b11;
                                LOGGER.debug(""Trying atom combination : "" + x1 + "":"" + x2 + "":"" + y1 + "":"" + y2);
                                try {
                                    newAc = (IAtomContainer) ac.clone();
                                    change(newAc, x1, y1, x2, y2, b11, b12, b21, b22);
                                    if (ConnectivityChecker.isConnected(newAc)) {
                                        structures.add(newAc);
                                    } else {
                                        LOGGER.debug(""not connected"");
                                    }
                                } catch (CloneNotSupportedException e) {
                                    LOGGER.error(""Cloning exception: "" + e.getMessage());
                                    LOGGER.debug(e);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return structures;
}",sample,org/openscience/cdk/structgen/VicinitySampler.java,/tool/structgen/src/main/java/org/openscience/cdk/structgen/VicinitySampler.java,"/**
     * Choose any possible quadruple of the set of atoms
     * in ac and establish all of the possible bonding schemes according to
     * Faulon's equations.
     */",53-163,"('sample', {'INSTRUCTION': {'covered': 307, 'missed': 18}, 'BRANCH': {'covered': 23, 'missed': 1}, 'LINE': {'covered': 66, 'missed': 4}, 'COMPLEXITY': {'covered': 12, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",693.0,25.0,Choose any possible quadruple of the set of atoms  in ac and establish all of the possible bonding schemes according to  Faulon's equations.,Sample any possible quadruple of the set of atoms in ac and establish all of the possible bonding schemes according to Faulon's equations,Pick any possible set of atoms in ac and then use the equations of Faulon to create bonding schemes.,0.393632317962405,Choose any possible quadruple of the set of atoms in ac and establish all possible bonding schemes according to Faulon's equations.
824,cdk,"private IAtom findAtomByPosition(IAtomContainer container, int position){
    String pos = String.valueOf(position);
    for (IAtom atom : container.atoms()) {
        if (atom.getID().equals(pos))
            return atom;
    }
    return null;
}",findAtomByPosition,org/openscience/cdk/tautomers/InChITautomerGenerator.java,/tool/tautomer/src/main/java/org/openscience/cdk/tautomers/InChITautomerGenerator.java,"/**
     * Helper method that locates an atom based on its InChI atom table
     * position, which has been set as ID.
     * @param container input container
     * @param position InChI atom table position
     * @return atom on the position
     */",624-637,"('findAtomByPosition', {'INSTRUCTION': {'covered': 22, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,21.0,"Helper method that locates an atom based on its InChI atom table  position, which has been set as ID.","This method locates an atom based on its InChI atom table position, which has been set as ID.",The method locates an atom by looking at the InChI atom table position.,0.646215500777016,"An assistive method that locates an atom based on its InChI atom table position, which has been defined as ID."
825,cdk,"private String[] generateOrderE(){
    String[] listElements = new String[] { ""C"", ""H"", ""O"", ""N"", ""Si"", ""P"", ""S"", ""F"", ""Cl"", ""Br"", ""I"", ""Sn"", ""B"", ""Pb"", ""Tl"", ""Ba"", ""In"", ""Pd"", ""Pt"", ""Os"", ""Ag"", ""Zr"", ""Se"", ""Zn"", ""Cu"", ""Ni"", ""Co"", ""Fe"", ""Cr"", ""Ti"", ""Ca"", ""K"", ""Al"", ""Mg"", ""Na"", ""Ce"", ""Hg"", ""Au"", ""Ir"", ""Re"", ""W"", ""Ta"", ""Hf"", ""Lu"", ""Yb"", ""Tm"", ""Er"", ""Ho"", ""Dy"", ""Tb"", ""Gd"", ""Eu"", ""Sm"", ""Pm"", ""Nd"", ""Pr"", ""La"", ""Cs"", ""Xe"", ""Te"", ""Sb"", ""Cd"", ""Rh"", ""Ru"", ""Tc"", ""Mo"", ""Nb"", ""Y"", ""Sr"", ""Rb"", ""Kr"", ""As"", ""Ge"", ""Ga"", ""Mn"", ""V"", ""Sc"", ""Ar"", ""Ne"", ""Be"", ""Li"", ""Tl"", ""Pb"", ""Bi"", ""Po"", ""At"", ""Rn"", ""Fr"", ""Ra"", ""Ac"", ""Th"", ""Pa"", ""U"", ""Np"", ""Pu"" };
    return listElements;
}",generateOrderE,org/openscience/cdk/formula/MassToFormulaTool.java,/legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java,"/**
     * generate the order of the Elements according probability occurrence.,
     * beginning the C, H, O, N, Si, P, S, F, Cl, Br, I, Sn, B, Pb, Tl, Ba, In, Pd,
     * Pt, Os, Ag, Zr, Se, Zn, Cu, Ni, Co, Fe, Cr, Ti, Ca, K, Al, Mg, Na, Ce,
     * Hg, Au, Ir, Re, W, Ta, Hf, Lu, Yb, Tm, Er, Ho, Dy, Tb, Gd, Eu, Sm, Pm,
     * Nd, Pr, La, Cs, Xe, Te, Sb, Cd, Rh, Ru, Tc, Mo, Nb, Y, Sr, Rb, Kr, As,
     * Ge, Ga, Mn, V, Sc, Ar, Ne, Be, Li, Tl, Pb, Bi, Po, At, Rn, Fr, Ra, Ac,
     * Th, Pa, U, Np, Pu.
     *
     * @return  Array with the elements ordered.
     *
     */",438-458,"('generateOrderE', {'INSTRUCTION': {'covered': 385, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",213.0,10.0,generate the order of the Elements according probability occurrence.,This method defines the order of the Elements according probability occurrence,The order of the Elements can be generated.,0.492583832220475,generate the order of the elements according to the probability occurrence.
826,cdk,"public DescriptorValue calculate(IAtomContainer mol){
    mol = clone(mol);
    int lipinskifailures = 0;
    IMolecularDescriptor xlogP = new XLogPDescriptor();
    Object[] xlogPparams = { checkAromaticity, Boolean.TRUE };
    try {
        xlogP.setParameters(xlogPparams);
        double xlogPvalue = ((DoubleResult) xlogP.calculate(mol).getValue()).doubleValue();
        IMolecularDescriptor acc = new HBondAcceptorCountDescriptor();
        Object[] hBondparams = { checkAromaticity };
        acc.setParameters(hBondparams);
        int acceptors = ((IntegerResult) acc.calculate(mol).getValue()).intValue();
        IMolecularDescriptor don = new HBondDonorCountDescriptor();
        don.setParameters(hBondparams);
        int donors = ((IntegerResult) don.calculate(mol).getValue()).intValue();
        IMolecularDescriptor mw = new WeightDescriptor();
        Object[] mwparams = { ""*"" };
        mw.setParameters(mwparams);
        double mwvalue = ((DoubleResult) mw.calculate(mol).getValue()).doubleValue();
        IMolecularDescriptor rotata = new RotatableBondsCountDescriptor();
        Object[] rotatableBondsParams = { false, true };
        rotata.setParameters(rotatableBondsParams);
        int rotatablebonds = ((IntegerResult) rotata.calculate(mol).getValue()).intValue();
        if (xlogPvalue > 5.0) {
            lipinskifailures += 1;
        }
        if (acceptors > 10) {
            lipinskifailures += 1;
        }
        if (donors > 5) {
            lipinskifailures += 1;
        }
        if (mwvalue > 500.0) {
            lipinskifailures += 1;
        }
        if (rotatablebonds > 10.0) {
            lipinskifailures += 1;
        }
    } catch (CDKException e) {
        new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult((int) Double.NaN), getDescriptorNames(), e);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(lipinskifailures), getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/RuleOfFiveDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/RuleOfFiveDescriptor.java,"/**
     *  the method take a boolean checkAromaticity: if the boolean is true, it means that
     *  aromaticity has to be checked.
     *
     *@param  mol   AtomContainer for which this descriptor is to be calculated
     *@return    The number of failures of the Lipinski rule
     */",136-199,"('calculate', {'INSTRUCTION': {'covered': 156, 'missed': 20}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 32, 'missed': 5}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",383.0,22.0,"the method take a boolean checkAromaticity: if the boolean is true, it means that  aromaticity has to be checked.",Check if the aromaticity of the input has been previously checked,"If the boolean is true, it means that aromaticity has to be checked.",0.642492097252484,"the method takes a Boolean controlAromaticity: if the Boolean is true, it means that the aromaticity must be checked."
827,shardingsphere-elasticjob,"public List<TaskRunningStatistics> findTaskRunningStatisticsWeekly(){
    if (!isRdbConfigured()) {
        return Collections.emptyList();
    }
    return rdbRepository.findTaskRunningStatistics(StatisticTimeUtils.getStatisticTime(StatisticInterval.DAY, -7));
}",findTaskRunningStatisticsWeekly,org/apache/shardingsphere/elasticjob/cloud/scheduler/statistics/StatisticManager.java,/elasticjob-cloud/elasticjob-cloud-scheduler/src/main/java/org/apache/shardingsphere/elasticjob/cloud/scheduler/statistics/StatisticManager.java,"/**
     * Get the collection of task statistics in the most recent week.
     * 
     * @return Collection of running task statistics data objects
     */",225-235,"('findTaskRunningStatisticsWeekly', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,12.0,Get the collection of task statistics in the most recent week.,Find the collection of task statistics in the most recent week,The collection of task statistics is available.,0.113247346116951,Get the most recent week's task statistics collection.
828,jeromq,"public String popString(){
    ZFrame frame = pop();
    if (frame == null) {
        return null;
    }
    return frame.toString();
}",popString,org/zeromq/ZMsg.java,/src/main/java/org/zeromq/ZMsg.java,"/**
     * Pop a ZFrame and return the toString() representation of it.
     *
     * @return toString version of pop'ed frame, or null if no frame exists.
     */",687-700,"('popString', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,13.0,Pop a ZFrame and return the toString() representation of it.,Remove a ZFrame and return the toString() representation of it,Return the toString() representation of the ZFrame.,0.583365391442508,Display a ZFrame and return the toString() representation of it.
829,glowstone,"public boolean readFloatList(@NonNls String key, Consumer<? super List<Float>> consumer){
    return readList(key, TagType.FLOAT, consumer);
}",readFloatList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to a list subtag if it is present and its contents are float
     * tags.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */",596-606,"('readFloatList', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,19.0,Applies the given function to a list subtag if it is present and its contents are float  tags.,Read the float list if it is present,"If the function is present and the contents are float tags, apply it to the list subtag.",0.512949622910349,Applies the given function to a list subtag if it is present and its contents consist of floating tags.
830,cdk,"private double calculateSquaredDistanceBetweenTwoAtoms(IAtom atom1, IAtom atom2){
    double distance = 0;
    double tmp = 0;
    Point3d firstPoint = atom1.getPoint3d();
    Point3d secondPoint = atom2.getPoint3d();
    tmp = firstPoint.distance(secondPoint);
    distance = tmp * tmp;
    return distance;
}",calculateSquaredDistanceBetweenTwoAtoms,org/openscience/cdk/charges/InductivePartialCharges.java,/tool/charges/src/main/java/org/openscience/cdk/charges/InductivePartialCharges.java,"/**
     *  Evaluate the square of the Euclidean distance between two atoms.
     *
     *@param  atom1  first atom
     *@param  atom2  second atom
     *@return        squared distance between the 2 atoms
     */",372-387,"('calculateSquaredDistanceBetweenTwoAtoms', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",58.0,11.0,Evaluate the square of the Euclidean distance between two atoms.,This method calculates the square of the Euclidean distance between two atoms,Evaluate the distance between two atoms.,0.0744706836657519,Evaluate the square of the Euclidean distance between two atoms.
831,cdk,"static void reverse(List<String> tokens){
    Collections.reverse(tokens);
    Deque<String> numbers = new ArrayDeque<>();
    for (int i = 0; i < tokens.size(); i++) {
        String token = tokens.get(i);
        if (token.equals(""("")) {
            tokens.set(i, "")"");
            String num = numbers.pop();
            if (!num.isEmpty()) {
                tokens.add(i + 1, num);
                i++;
            }
        } else if (token.equals("")"")) {
            tokens.set(i, ""("");
            if (i > 0 && isNumber(tokens.get(i - 1))) {
                numbers.push(tokens.remove(i - 1));
                i--;
            } else {
                numbers.push("""");
            }
        }
    }
}",reverse,org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,"/**
     * Reverse a list of tokens for display, flipping
     * brackets as needed.
     *
     * @param tokens list of tokens
     */",270-300,"('reverse', {'INSTRUCTION': {'covered': 76, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",184.0,13.0,"Reverse a list of tokens for display, flipping  brackets as needed.","This method reverses a list of tokens for display, flipping brackets as needed",Pull the list of token and flip them as needed.,0.322845809017359,"Invert a list of tokens to display, flipping the square brackets if necessary."
832,sonar-cxx,"public String toString(){
    var stream = new ByteArrayOutputStream();
    save(stream);
    return stream.toString(StandardCharsets.UTF_8);
}",toString,org/sonar/cxx/config/CxxSquidConfiguration.java,/cxx-squid/src/main/java/org/sonar/cxx/config/CxxSquidConfiguration.java,"/**
   * Returns a string representation of the object: XML/UTF-8 encoded.
   *
   * @return object XML encoded
   */",404-413,"('toString', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,11.0,Returns a string representation of the object: XML/UTF-8 encoded.,Get the string representation of the input object encoded in XML/UTF-8,The object is represented by a string.,0.663478655368489,Returns a string representation of the encoded XML/UTF-8 object.
833,weblogic-kubernetes-operator,"public void scheduleOnce(long timeout, TimeUnit unit, Runnable runnable){
    this.owner.getExecutor().schedule(runnable, timeout, unit);
}",scheduleOnce,oracle/kubernetes/operator/work/Fiber.java,/operator/src/main/java/oracle/kubernetes/operator/work/Fiber.java,"/**
   * Use this fiber's executor to schedule an operation for some time in the future.
   * @param timeout the interval before the check should run, in units
   * @param unit the unit of time that defines the interval
   * @param runnable the operation to run
   */",106-115,"('scheduleOnce', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,16.0,Use this fiber's executor to schedule an operation for some time in the future.,Schedule an operation at the given time in the future,Use the fiber's executor to schedule an operation in the future.,0.294299937812538,Use the executor of this fiber to schedule an operation for a certain time in the future.
834,cdk,"private static boolean skipLine(String line){
    return line.isEmpty() || line.charAt(0) == '*' || line.charAt(0) == '$';
}",skipLine,org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,"/**
     * A line is skipped if it is empty or is a comment. MMFF files use '*' to mark comments and '$'
     * for end of file.
     *
     * @param line an input line
     * @return whether to skip this line
     */",270-279,"('skipLine', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,13.0,A line is skipped if it is empty or is a comment.,This method skips a line if it is empty,"If a line is empty or a comment, it is skipped.",0.291511969668511,A row is ignored if it is empty or if it is a comment.
835,jooby,"static String normalizePath(@Nullable String path){
    if (path == null || path.length() == 0 || path.equals(""/"")) {
        return ""/"";
    }
    int len = path.length();
    boolean modified = false;
    int p = 0;
    char[] buff = new char[len + 1];
    if (path.charAt(0) != '/') {
        buff[p++] = '/';
        modified = true;
    }
    for (int i = 0; i < path.length(); i++) {
        char ch = path.charAt(i);
        if (ch != '/') {
            buff[p++] = ch;
        } else if (i == 0 || path.charAt(i - 1) != '/') {
            buff[p++] = ch;
        } else {
            modified = true;
        }
    }
    return modified ? new String(buff, 0, p) : path;
}",normalizePath,io/jooby/Router.java,/jooby/src/main/java/io/jooby/Router.java,"/**
   * Normalize a path by removing consecutive <code>/</code>(slashes).
   *
   * @param path Path to process.
   * @return Safe path pattern.
   */",1065-1096,"('normalizePath', {'INSTRUCTION': {'covered': 84, 'missed': 0}, 'BRANCH': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",190.0,17.0,Normalize a path by removing consecutive <code>/</code>(slashes).,This method clean path by removing consecutive slashes,Remove the code from a path.,0.360315043614332,Normalize a path by removing <code>consecutive /() forward slashes</code>.
836,twilio-java,"public static WorkflowRuleTarget fromJson(String json) throws IOException{
    ObjectMapper mapper = new ObjectMapper();
    return mapper.readValue(json, WorkflowRuleTarget.class);
}",fromJson,com/twilio/taskrouter/WorkflowRuleTarget.java,/src/main/java/com/twilio/taskrouter/WorkflowRuleTarget.java,"/**
     * Converts a JSON workflow configuration to a workflow configuration object.
     *
     * @param json JSON for workflow rule target
     * @return a workflow rule target object
     * @throws IOException if unable to create object
     */",147-157,"('fromJson', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,11.0,Converts a JSON workflow configuration to a workflow configuration object.,Parse a JSON workflow in the propoer workflow configuration object,A workflows configuration is converted to a object.,0.297076118714806,Converts a JSON workflow configuration to a workflow configuration object.
838,egeria,"public Optional<EntityDetail> findProcessEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, PROCESS_TYPE_NAME);
}",findProcessEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineProcessHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineProcessHandler.java,"/**
     * Find out if the Process object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",148-164,"('findProcessEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,13.0,Find out if the Process object is already stored in the repository.,Check if the Process object is already stored in the repository.,"If the Process object is already in the repository, you should find it.",0.137592533755924,Check if the Process object is already stored in the repository.
839,cdk,"public HashGeneratorMaker encode(AtomEncoder encoder){
    if (encoder == null)
        throw new NullPointerException(""no encoder provided"");
    customEncoders.add(encoder);
    return this;
}",encode,org/openscience/cdk/hash/HashGeneratorMaker.java,/tool/hash/src/main/java/org/openscience/cdk/hash/HashGeneratorMaker.java,"/**
     * Add a custom encoder to the hash generator which will be built. Although
     * not enforced, the encoder should be stateless and should not modify any
     * passed inputs.
     *
     * @param encoder an atom encoder
     * @return fluent API reference (self)
     * @throws NullPointerException no encoder provided
     */",257-270,"('encode', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,13.0,Add a custom encoder to the hash generator which will be built.,Add the custom passed encoder to the hash generator which will be built. ,The generator will be built with a custom encoder.,0.705514667978287,Add a custom encoder to the hash generator that will be built.
840,cdk,"private static String[] readSMARTSPattern(String filename) throws Exception{
    InputStream ins = StandardSubstructureSets.class.getClassLoader().getResourceAsStream(filename);
    BufferedReader reader = new BufferedReader(new InputStreamReader(ins));
    List<String> tmp = new ArrayList<String>();
    String line;
    while ((line = reader.readLine()) != null) {
        if (line.startsWith(""#"") || line.trim().length() == 0)
            continue;
        String[] toks = line.split("":"");
        StringBuffer s = new StringBuffer();
        for (int i = 1; i < toks.length - 1; i++) s.append(toks[i] + "":"");
        s.append(toks[toks.length - 1]);
        tmp.add(s.toString().trim());
    }
    return tmp.toArray(new String[] {});
}",readSMARTSPattern,org/openscience/cdk/fingerprint/StandardSubstructureSets.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/StandardSubstructureSets.java,"/**
     * Load a list of SMARTS patterns from the specified file.
     *
     * Each line in the file corresponds to a pattern with the following structure:
     * PATTERN_DESCRIPTION: SMARTS_PATTERN, <i>e.g., Thioketone: [#6][CX3](=[SX1])[#6]</i>
     *
     * Empty lines and lines starting with a ""#"" are skipped.
     *
     * @param filename list of the SMARTS pattern to be loaded
     * @return list of strings containing the loaded SMARTS pattern
     * @throws Exception if there is an error parsing SMILES patterns
     */",46-74,"('readSMARTSPattern', {'INSTRUCTION': {'covered': 84, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",191.0,11.0,Load a list of SMARTS patterns from the specified file.,Get a list of smart patterns from the specified file,A list of SMARTS patterns can be loaded.,0.309366533746837,Load a list of SMARTS templates from the specified file.
841,matsim-libs,"public T selectPlan(final HasPlansAndId<T, I> person){
    // this used to use person.getRandomPlan(), but I inlined the function here in order to get rid of the function of the data class.
    // kai, nov'13
    if (person.getPlans().size() == 0) {
        return null;
    }
    int index = (int) (MatsimRandom.getRandom().nextDouble() * person.getPlans().size());
    // yyyy As far as I can tell, this produces race conditions when running multi-threaded.  I.e. when running the same
    // setup twice, this function may return different results per thread or per person.  kai, jun'14
    return person.getPlans().get(index);
}",selectPlan,org/matsim/core/replanning/selectors/RandomPlanSelector.java,/matsim/src/main/java/org/matsim/core/replanning/selectors/RandomPlanSelector.java,"/**
         * Choose a random plan from the person and return it.
         * @return The newly selected plan for this person; <code>null</code> if the person has no plans.
         */",35-52,"('selectPlan', {'INSTRUCTION': {'covered': 21, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,11.0,Choose a random plan from the person and return it.,Select a random plan from the person and return it,Pick a random plan from the person and return it.,0.181932803787602,Choose a random plan of the person and flip it over.
842,acs-aem-commons,"public void doPost(SlingHttpServletRequest request, SlingHttpServletResponse response) throws IOException, ServletException{
    response.setContentType(""application/json"");
    response.setCharacterEncoding(""UTF-8"");
    final ValueMap properties = request.getResource().adaptTo(ModifiableValueMap.class);
    final Parameters parameters = new Parameters(request);
    properties.put(GROUP_FILTER, parameters.getGroupFilter());
    properties.put(GROUPS, parameters.getGroups());
    properties.put(CUSTOM_PROPERTIES, parameters.getCustomProperties());
    request.getResourceResolver().commit();
}",doPost,com/adobe/acs/commons/exporters/impl/users/UsersSaveServlet.java,/bundle/src/main/java/com/adobe/acs/commons/exporters/impl/users/UsersSaveServlet.java,"/**
     * Persists the Users to CSV form data to the underlying jcr:content node.
     * @param request the Sling HTTP Request object
     * @param response the Sling HTTP Response object
     * @throws IOException
     * @throws ServletException
     */",45-64,"('doPost', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",106.0,15.0,Persists the Users to CSV form data to the underlying jcr:content node.,Add the Users to CSV form data to the underlying jcr,Users form data to the jcr:content.,1.33924433312161,Keeps users' CSV form data in the underlying jcr:content node.
843,openapi-generator,"public String toEnumValue(String value, String datatype){
    if (""number"".equalsIgnoreCase(datatype) || ""boolean"".equalsIgnoreCase(datatype)) {
        return value;
    } else {
        return ""\"""" + escapeText(value) + ""\"""";
    }
}",toEnumValue,org/openapitools/codegen/DefaultCodegen.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java,"/**
     * Return the enum value in the language specified format
     * e.g. status becomes ""status""
     *
     * @param value    enum variable name
     * @param datatype data type
     * @return the sanitized value for enum
     */",754-768,"('toEnumValue', {'INSTRUCTION': {'covered': 21, 'missed': 2}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,11.0,Return the enum value in the language specified format  e.,Get the enum value in the language specified format,Return the value in the language specified.,0.145657789897354,Return the enum value in the specified language in e format.
844,jackson-databind,"protected SequenceWriter _newSequenceWriter(boolean wrapInArray, JsonGenerator gen, boolean managedInput) throws IOException{
    return new SequenceWriter(_serializerProvider(), _configureGenerator(gen), managedInput, _prefetch).init(wrapInArray);
}",_newSequenceWriter,com/fasterxml/jackson/databind/ObjectWriter.java,/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java,"/**
     * Overridable factory method called by {@link #writeValues(OutputStream)}
     * method (and its various overrides), and initializes it as necessary.
     * 
     * @since 2.5
     */",248-262,"('_newSequenceWriter', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,28.0,"Overridable factory method called by {@link #writeValues(OutputStream)}  method (and its various overrides), and initializes it as necessary.",Create a default overridable sequence writer,The factory method called by @link #writeValues(OutputStream) method is over-simplified and has various overrides.,1.06452764766966,A substitutable factory method called by the {@link #writeValues(OutputStream)} method (and its various substitutions) and initializes if necessary.
845,cdk,"public AtomHashGenerator atomic(){
    if (depth < 0)
        throw new IllegalArgumentException(""no depth specified, use .depth(int)"");
    List<AtomEncoder> encoders = new ArrayList<AtomEncoder>();
    for (AtomEncoder encoder : encoderSet) {
        encoders.add(encoder);
    }
    encoders.addAll(this.customEncoders);
    boolean suppress = suppression != AtomSuppression.unsuppressed();
    AtomEncoder encoder = new ConjugatedAtomEncoder(encoders);
    SeedGenerator seeds = new SeedGenerator(encoder, suppression);
    AbstractAtomHashGenerator simple = suppress ? new SuppressedAtomHashGenerator(seeds, new Xorshift(), makeStereoEncoderFactory(), suppression, depth) : new BasicAtomHashGenerator(seeds, new Xorshift(), makeStereoEncoderFactory(), depth);
    if (equivSetFinder != null) {
        return new PerturbedAtomHashGenerator(seeds, simple, new Xorshift(), makeStereoEncoderFactory(), equivSetFinder, suppression);
    } else {
        return simple;
    }
}",atomic,org/openscience/cdk/hash/HashGeneratorMaker.java,/tool/hash/src/main/java/org/openscience/cdk/hash/HashGeneratorMaker.java,"/**
     * Given the current configuration create an {@link AtomHashGenerator}.
     *
     * @return instance of the generator
     * @throws IllegalArgumentException no depth or encoders were configured
     */",311-349,"('atomic', {'INSTRUCTION': {'covered': 101, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",167.0,12.0,Given the current configuration create an {@link AtomHashGenerator}.,Create a configuration starting from a given current configuration,The current configuration would make it possible to create an @link AtomHashGenerator.,1.25851225733188,"Given the current configuration, create a {@link AtomHashGenerator}."
846,cdk,"static boolean normaliseCycle(int[] cycle, int[] contribution){
    int offset = indexOfHetro(cycle, contribution);
    if (offset < 0)
        return false;
    if (offset == 0)
        return true;
    int[] cpy = Arrays.copyOf(cycle, cycle.length);
    int len = cycle.length - 1;
    for (int j = 0; j < len; j++) {
        cycle[j] = cpy[(offset + j) % len];
    }
    cycle[len] = cycle[0];
    return true;
}",normaliseCycle,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,"/**
     * Normalises a 5-member 'cycle' such that the hetroatom contributing the lone-pair is in
     * position 1 (index 0). The alpha atoms are then in index 1 and 4 whilst the beta atoms are in
     * index 2 and 3. If the ring contains more than one hetroatom the cycle is not normalised
     * (return=false).
     *
     * @param cycle        aromatic cycle to normalise, |C| = 5
     * @param contribution vector of p electron contributions from each vertex (size |V|)
     * @return whether the cycle was normalised
     */",332-353,"('normaliseCycle', {'INSTRUCTION': {'covered': 47, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",114.0,21.0,Normalises a 5-member 'cycle' such that the hetroatom contributing the lone-pair is in  position 1 (index 0).,This method normalises a 5-member 'cycle' such that the hetroatom contributing the lone-pair is in position 1,"Normalises a 5-membercycle, such that the hetroatom contributes the lone-pair.",0.663485710982068,"Normalizes a 5-limb ""cycle"" so that the hetroatoma contributing to the solitary pair is in position 1 (index 0)."
847,egeria,"private String computeDisplayName(String pathName){
    return new File(pathName).getName().length() < 1 ? pathName : new File(pathName).getName();
}",computeDisplayName,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineFolderHierarchyHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineFolderHierarchyHandler.java,"/**
     * Will return the name of the last folder in pathName. Takes root folder into account.
     * When called with argument ""/folder"", return value is ""folder"".
     * When called with argument ""/"", return value is ""/""
     *
     * @param pathName path
     *
     * @return folder name
     */",209-220,"('computeDisplayName', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,11.0,Will return the name of the last folder in pathName.,This method returns the name of the last folder in pathName,Will return the name of the last folder.,0.0341194067124681,Returns the name of the last folder in pathName.
848,cdk,"long[] combine(long[][] perturbed){
    int n = perturbed.length;
    int m = perturbed[0].length;
    long[] combined = new long[n];
    long[] rotated = new long[m];
    for (int i = 0; i < n; i++) {
        Arrays.sort(perturbed[i]);
        for (int j = 0; j < m; j++) {
            if (j > 0 && perturbed[i][j] == perturbed[i][j - 1]) {
                combined[i] ^= rotated[j] = rotate(rotated[j - 1]);
            } else {
                combined[i] ^= rotated[j] = perturbed[i][j];
            }
        }
    }
    return combined;
}",combine,org/openscience/cdk/hash/PerturbedAtomHashGenerator.java,/tool/hash/src/main/java/org/openscience/cdk/hash/PerturbedAtomHashGenerator.java,"/**
     * Combines the values in an n x m matrix into a single array of size n.
     * This process scans the rows and xors all unique values in the row
     * together. If a duplicate value is found it is rotated using a
     * pseudorandom number generator.
     *
     * @param perturbed n x m, matrix
     * @return the combined values of each row
     */",167-200,"('combine', {'INSTRUCTION': {'covered': 83, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",165.0,17.0,Combines the values in an n x m matrix into a single array of size n.,This method combines the values in an n x m matrix into a single array of size n,The values in an n x m matrix are combined into a single array of size n.,0.364388068720225,Combines the values of a matrix n x m into a single array of size n.
849,dcache,"public void addType(ChecksumType type) throws IOException{
    synchronized (_digests) {
        if (_digests.stream().map(MessageDigest::getAlgorithm).noneMatch(t -> t.equals(type.getName()))) {
            MessageDigest digest = type.createMessageDigest();
            if (_isChecksumViable) {
                try {
                    updateFromChannel(Collections.singleton(digest), 0L, _nextChecksumOffset);
                } catch (IOException e) {
                    throw new IOException(""Failed when reading received data: "" + messageOrClassName(e), e);
                }
            }
            _digests.add(digest);
        }
    }
}",addType,org/dcache/pool/movers/ChecksumChannel.java,/modules/dcache/src/main/java/org/dcache/pool/movers/ChecksumChannel.java,"/**
     * Ensure that a Checksum is calculated for the supplied ChecksumType.  If the ChecksumType is
     * already registered then this method does nothing, otherwise the ChecksumChannel is updated to
     * calculate the new ChecksumType. If the ChecksumChannel has accepted a contiguous range of
     * data from offset 0 then this method will reread that contiguous range.
     *
     * @param type The algorithm this ChecksumChannel should calculate.
     * @throws IOException if the Channel has already started accepting data and an attempt to
     *                     reread data from disk fails.
     */",116-145,"('addType', {'INSTRUCTION': {'covered': 37, 'missed': 9}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 11, 'missed': 3}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",110.0,11.0,Ensure that a Checksum is calculated for the supplied ChecksumType.,Add a Checksum to the supplied ChecksumType,Ensure that the Checksum is calculated.,0.368537726356744,Make sure that a checksum is calculated for the type of checksum provided.
850,jackson-databind,"public JsonNode putIfAbsent(String propertyName, JsonNode value){
    if (value == null) {
        value = nullNode();
    }
    return _children.putIfAbsent(propertyName, value);
}",putIfAbsent,com/fasterxml/jackson/databind/node/ObjectNode.java,/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java,"/**
     * Method that will set value of specified property if (and only if)
     * it had no set value previously.
     * Note that explicitly set {@code null} is a value.
     * Functionally equivalent to:
     *<code>
     *  if (get(propertyName) == null) {
     *      set(propertyName, value);
     *      return null;
     *  } else {
     *      return get(propertyName);
     *  }
     *</code>
     *
     * @param propertyName Name of property to set
     * @param value Value to set to property (if and only if it had no value previously);
     *  if null, will be converted to a {@link NullNode} first.
     *
     * @return Old value of the property, if any (in which case value was not changed);
     *     null if there was no old value (in which case value is now set)
     *
     * @since 2.13
     */",523-552,"('putIfAbsent', {'INSTRUCTION': {'covered': 9, 'missed': 3}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,21.0,Method that will set value of specified property if (and only if)  it had no set value previously.,Set a value of a specified property,"If the property had no set value before, the method will set the value.",0.804823132570538,Method; sets the value of the specified property if (and only if) it did not have a previously defined value.
851,jeromq,"public ZFrame unwrap(){
    if (size() == 0) {
        return null;
    }
    ZFrame f = pop();
    ZFrame empty = getFirst();
    if (empty.hasData() && empty.size() == 0) {
        empty = pop();
        empty.destroy();
    }
    return f;
}",unwrap,org/zeromq/ZMsg.java,/src/main/java/org/zeromq/ZMsg.java,"/**
     * Pop frame off front of message, caller now owns frame.
     * If next frame is empty, pops and destroys that empty frame
     * (e.g. useful when unwrapping ROUTER socket envelopes)
     * @return
     *          Unwrapped frame
     */",129-148,"('unwrap', {'INSTRUCTION': {'covered': 22, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,12.0,"Pop frame off front of message, caller now owns frame.",Pop frames off the front of the message,The caller now owns the frame.,0.164138892923141,"Pop frame off front of message, the caller now owns frame."
853,logstash-logback-encoder,"private void appendRootCauseLast(StringBuilder builder, String prefix, int indent, IThrowableProxy throwableProxy, Deque<String> stackHashes){
    if (throwableProxy == null || builder.length() > maxLength) {
        return;
    }
    String hash = stackHashes == null || stackHashes.isEmpty() ? null : stackHashes.removeFirst();
    appendFirstLine(builder, prefix, indent, throwableProxy, hash);
    appendStackTraceElements(builder, indent, throwableProxy);
    IThrowableProxy[] suppressedThrowableProxies = throwableProxy.getSuppressed();
    if (suppressedThrowableProxies != null) {
        for (IThrowableProxy suppressedThrowableProxy : suppressedThrowableProxies) {
            appendRootCauseLast(builder, CoreConstants.SUPPRESSED, indent + ThrowableProxyUtil.SUPPRESSED_EXCEPTION_INDENT, suppressedThrowableProxy, null);
        }
    }
    appendRootCauseLast(builder, CoreConstants.CAUSED_BY, indent, throwableProxy.getCause(), stackHashes);
}",appendRootCauseLast,net/logstash/logback/stacktrace/ShortenedThrowableConverter.java,/src/main/java/net/logstash/logback/stacktrace/ShortenedThrowableConverter.java,"/**
     * Appends a throwable and recursively appends its causedby/suppressed throwables
     * in ""normal"" order (Root cause last).
     */",320-347,"('appendRootCauseLast', {'INSTRUCTION': {'covered': 70, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 3}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",151.0,20.0,"Appends a throwable and recursively appends its causedby/suppressed throwables  in ""normal"" order (Root cause last).",Appends recursively the root cause,Appends a throwable and then adds it to the normal order.,2.19599717760306,"Adds a disposable and recursively adds its caused/deleted disposables in the ""normal"" order (first cause last)."
855,acs-aem-commons,"private List<JackrabbitAccessControlList> findAcls(ResourceResolver resourceResolver, String principalName, JackrabbitAccessControlManager accessControlManager){
    final Set<String> paths = new HashSet<String>();
    final List<JackrabbitAccessControlList> acls = new ArrayList<JackrabbitAccessControlList>();
    final Map<String, String> params = new HashMap<String, String>();
    params.put(""type"", PROP_NT_REP_ACE);
    params.put(""property"", PROP_REP_PRINCIPAL_NAME);
    params.put(""property.value"", principalName);
    params.put(""p.limit"", ""-1"");
    Query query = queryBuilder.createQuery(PredicateGroup.create(params), resourceResolver.adaptTo(Session.class));
    QueryUtil.setResourceResolverOn(resourceResolver, query);
    for (final Hit hit : query.getResult().getHits()) {
        try {
            final Resource aceResource = resourceResolver.getResource(hit.getPath());
            final Resource contentResource = aceResource.getParent().getParent();
            if (!paths.contains(contentResource.getPath())) {
                paths.add(contentResource.getPath());
                for (AccessControlPolicy policy : accessControlManager.getPolicies(contentResource.getPath())) {
                    if (policy instanceof JackrabbitAccessControlList) {
                        acls.add((JackrabbitAccessControlList) policy);
                        break;
                    }
                }
            }
        } catch (RepositoryException e) {
            log.error(""Failed to get resource for query result."", e);
        }
    }
    return acls;
}",findAcls,com/adobe/acs/commons/users/impl/EnsureAce.java,/bundle/src/main/java/com/adobe/acs/commons/users/impl/EnsureAce.java,"/**
     * Locates by query all the ACLs that the principal participates in.
     *
     * @param resourceResolver     the resource resolver to perform the user management
     * @param principalName        the principal name
     * @param accessControlManager Jackrabbit access control manager
     * @return a list of ACLs that principal participates in.
     */",225-271,"('findAcls', {'INSTRUCTION': {'covered': 111, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 23, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",270.0,12.0,Locates by query all the ACLs that the principal participates in.,Locates all the ACLs that participates in the principal.,The principal participates in theACLs.,0.595035480238705,Locates by query all access control lists in which the principal participates.
856,cdk,"private void fixNCNTypes(String[] symbs, int[][] graph){
    for (int v = 0; v < graph.length; v++) {
        if (""NCN+"".equals(symbs[v])) {
            boolean foundCNN = false;
            for (int w : graph[v]) {
                foundCNN = foundCNN || ""CNN+"".equals(symbs[w]) || ""CIM+"".equals(symbs[w]);
            }
            if (!foundCNN) {
                symbs[v] = ""NC=N"";
            }
        }
    }
}",fixNCNTypes,org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,"/**
     * Special case, 'NCN+' matches entries that the validation suite say should actually be 'NC=N'.
     * We can achieve 100% compliance by checking if NCN+ is still next to CNN+ or CIM+ after
     * aromatic types are assigned
     *
     * @param symbs symbolic types
     * @param graph adjacency list graph
     */",141-161,"('fixNCNTypes', {'INSTRUCTION': {'covered': 59, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,18.0,"Special case, 'NCN+' matches entries that the validation suite say should actually be 'NC=N'.",Fix a special case in which 'NCN+' matches entries that the validation suite say should actually be 'NC=N',The validation suite say that the entries should be 'NC+'.,0.1272514193519,"In a particular case, 'NCN+' corresponds to the entries which, according to the validation sequence, should actually be 'NC=N'."
857,cdk,"private boolean isContainedIn(BitSet sourceBitSet, BitSet targetBitSet){
    boolean result = false;
    if (sourceBitSet.isEmpty()) {
        return true;
    }
    BitSet setA = (BitSet) sourceBitSet.clone();
    setA.and(targetBitSet);
    if (setA.equals(sourceBitSet)) {
        result = true;
    }
    return result;
}",isContainedIn,org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,"/**
     *  Test if set sourceBitSet is contained in  set targetBitSet.
     * @param  sourceBitSet  a bitSet
     * @param  targetBitSet  a bitSet
     * @return    true if  sourceBitSet is contained in  targetBitSet
     */",562-583,"('isContainedIn', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,10.0,Test if set sourceBitSet is contained in set targetBitSet.,Check if the set sourceBitSet is contained in the set targetBitSet,"If sourceBitSet is contained in set targetBitSet, you can test it.",0.243493481349462,Test whether set sourceBitSet is contained in set targetBitSet.
858,dataverse,"public void applyDisplayInfo(AuthenticatedUserDisplayInfo inf){
    setFirstName(inf.getFirstName());
    setLastName(inf.getLastName());
    if (nonEmpty(inf.getEmailAddress())) {
        setEmail(inf.getEmailAddress());
    }
    if (nonEmpty(inf.getAffiliation())) {
        setAffiliation(inf.getAffiliation());
    }
    if (nonEmpty(inf.getPosition())) {
        setPosition(inf.getPosition());
    }
}",applyDisplayInfo,edu/harvard/iq/dataverse/authorization/users/AuthenticatedUser.java,/src/main/java/edu/harvard/iq/dataverse/authorization/users/AuthenticatedUser.java,"/**
     * Takes the passed info object and updated the internal fields according to it.
     * @param inf the info from which we update the fields.
    */",178-194,"('applyDisplayInfo', {'INSTRUCTION': {'covered': 33, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",93.0,14.0,Takes the passed info object and updated the internal fields according to it.,Update the internal fields according to the passed object values,The internal fields were updated according to the passed info object.,0.340017106162112,Takes the transmitted information object and updates the internal fields based on it.
859,jackson-databind,"protected JsonToken _initForReading(JsonParser p, JavaType targetType) throws IOException{
    _deserializationConfig.initialize(p);
    JsonToken t = p.currentToken();
    if (t == null) {
        t = p.nextToken();
        if (t == null) {
            throw MismatchedInputException.from(p, targetType, ""No content to map due to end-of-input"");
        }
    }
    return t;
}",_initForReading,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Method called to ensure that given parser is ready for reading
     * content for data binding.
     *
     * @return First token to be used for data binding after this call:
     *  can never be null as exception will be thrown if parser cannot
     *  provide more tokens.
     *
     * @throws IOException if the underlying input source has problems during
     *   parsing
     */",4740-4770,"('_initForReading', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,16.0,Method called to ensure that given parser is ready for reading  content for data binding.,Check if the given parser is ready for reading content for data binding,The method was used to make sure that the given scribal is ready for reading.,0.996743435882625,Method called to ensure that the given parser is ready to read content for data binding.
860,cdk,"public void addCDKChangeListener(ICDKChangeListener listener){
    if (listeners == null) {
        listeners = new ArrayList<ICDKChangeListener>();
    }
    if (!listeners.contains(listener)) {
        listeners.add(listener);
    }
}",addCDKChangeListener,org/openscience/cdk/renderer/RendererModel.java,/display/render/src/main/java/org/openscience/cdk/renderer/RendererModel.java,"/**
     * Adds a change listener to the list of listeners.
     *
     * @param listener
     *            The listener added to the list
     */",379-392,"('addCDKChangeListener', {'INSTRUCTION': {'covered': 14, 'missed': 5}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,10.0,Adds a change listener to the list of listeners.,This method appends a change listener to the list of listeners,A change listener is added to the list.,0.430362730176571,Adds a change listener to the list of listeners.
861,acs-aem-commons,"public static V doWithTccl(ClassLoader classLoader, Callable<V> task) throws Exception{
    ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
    Thread.currentThread().setContextClassLoader(classLoader);
    try {
        return task.call();
    } finally {
        Thread.currentThread().setContextClassLoader(oldClassLoader);
    }
}",doWithTccl,com/adobe/acs/commons/util/ThreadContextClassLoaderTaskExecutor.java,/bundle/src/main/java/com/adobe/acs/commons/util/ThreadContextClassLoaderTaskExecutor.java,"/**
     * Execute the task while the Thread Context Class Loader is set to the provided
     * Class Loader.
     * 
     * @param classLoader the requested class loader
     * @param task the task
     * @param <V> the return type of the task
     * @return the return value
     * @throws Exception the exception throw, if any, by the task
     */",35-53,"('doWithTccl', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,17.0,Execute the task while the Thread Context Class Loader is set to the provided  Class Loader.,This method executes the task while the Thread Context Class Loader is set to the provided Class Loader,The Thread Context Class Loader is set to execute the task.,0.306690775590389,Run the task when thread context class Loader is set to the supplied Class Loader.
862,weblogic-kubernetes-operator,"static void addPatches(JsonPatchBuilder patchBuilder, String basePath, Map<String, String> current, Map<String, String> required){
    for (String name : required.keySet()) {
        String encodedPath = basePath + name.replace(""~"", ""~0"").replace(""/"", ""~1"");
        if (!current.containsKey(name)) {
            patchBuilder.add(encodedPath, required.get(name));
        } else {
            patchBuilder.replace(encodedPath, required.get(name));
        }
    }
}",addPatches,oracle/kubernetes/operator/helpers/KubernetesUtils.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/KubernetesUtils.java,"/**
   * Adds patches to the specified patch builder to correct differences in the current vs required
   * maps.
   *
   * @param patchBuilder a builder for the patches
   * @param basePath     the base for the patch path (excluding the name)
   * @param current      a map of the values found in a Kubernetes resource
   * @param required     a map of the values specified for the resource by the domain
   */",65-91,"('addPatches', {'INSTRUCTION': {'covered': 44, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,17.0,Adds patches to the specified patch builder to correct differences in the current vs required  maps.,This method adds the patches to the specified patch builder to correct differences in the current vs required maps,Patching is done to correct differences in the current vs required maps.,0.380973896617421,Adds patches to the specified patch builder to correct differences between current and required adapters.
863,cdk,"public Partition splitAfter(int cellIndex, int splitElement){
    Partition r = new Partition();
    for (int j = 0; j < cellIndex; j++) {
        r.addCell(this.copyBlock(j));
    }
    SortedSet<Integer> splitBlock = this.copyBlock(cellIndex);
    splitBlock.remove(splitElement);
    r.addCell(splitBlock);
    r.addSingletonCell(splitElement);
    for (int j = cellIndex + 1; j < this.size(); j++) {
        r.addCell(this.copyBlock(j));
    }
    return r;
}",splitAfter,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,"/**
     * Splits this partition by taking the cell at cellIndex and making two
     * new cells - the first with the the rest of the elements from that cell
     * and the second with the singleton splitElement.
     *
     * @param cellIndex the index of the cell to split on
     * @param splitElement the element to put in its own cell
     * @return a new (finer) Partition
     */",242-269,"('splitAfter', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",119.0,35.0,Splits this partition by taking the cell at cellIndex and making two  new cells - the first with the the rest of the elements from that cell  and the second with the singleton splitElement.,This method splits the given partition by taking the cell at cellIndex and making two new cells,The first cell with the rest of the elements from that cell and the second with the singleton splitElement is split.,0.322982723963472,Divides this partition by taking the cell to cellIndex and creating two new cells - the first with the rest of the elements of this cell and the second with the singleton splitElement.
864,cdk,"private static IAtom findOtherSinglyBonded(IAtomContainer container, IAtom atom, IAtom exclude){
    for (final IBond bond : container.getConnectedBondsList(atom)) {
        if (!IBond.Order.SINGLE.equals(bond.getOrder()) || bond.contains(exclude))
            continue;
        return bond.getOther(atom);
    }
    return atom;
}",findOtherSinglyBonded,org/openscience/cdk/inchi/InChIToStructure.java,/storage/inchi/src/main/java/org/openscience/cdk/inchi/InChIToStructure.java,"/**
     * Finds a neighbor attached to 'atom' that is singley bonded and isn't
     * 'exclude'. If no such atom exists, the 'atom' is returned.
     *
     * @param container a molecule container
     * @param atom      the atom to find the neighbor or
     * @param exclude   don't find this atom
     * @return the other atom (or 'atom')
     */",400-415,"('findOtherSinglyBonded', {'INSTRUCTION': {'covered': 25, 'missed': 3}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,17.0,Finds a neighbor attached to 'atom' that is singley bonded and isn't  'exclude'.,Gets a neighbor attached to 'atom' that is singley bonded and is not excluded,A neighbor is attached to 'atom' and not 'exclude'.,0.603202269618759,"Find a neighbor attached to ""atom"" that is bound to one and is not ""excluded""."
865,matsim-libs,"public static FixedBordersDiscretizer create(double[] samples, int size){
    TDoubleArrayList borders;
    double min = Double.MAX_VALUE;
    double max = -Double.MAX_VALUE;
    TDoubleIntHashMap hist = new TDoubleIntHashMap(samples.length);
    for (int i = 0; i < samples.length; i++) {
        hist.adjustOrPutValue(samples[i], 1, 1);
        min = Math.min(min, samples[i]);
        max = Math.max(max, samples[i]);
    }
    double[] keys = hist.keys();
    Arrays.sort(keys);
    borders = new TDoubleArrayList(keys.length);
    borders.add(min - 1E-10);
    int binsize = 0;
    int n = 0;
    for (int i = 0; i < keys.length; i++) {
        int nBin = hist.get(keys[i]);
        binsize += nBin;
        n += nBin;
        if (binsize >= size && i > 0) {
            // sufficient samples for the
            // current bin
            if (samples.length - n >= binsize) {
                // sufficient remaining
                // samples to fill the
                // next bin
                borders.add(keys[i]);
                binsize = 0;
            }
        }
    }
    if (binsize > 0)
        borders.add(max);
    return new FixedBordersDiscretizer(borders.toArray());
}",create,org/matsim/contrib/common/stats/FixedSampleSizeDiscretizer.java,/contribs/common/src/main/java/org/matsim/contrib/common/stats/FixedSampleSizeDiscretizer.java,"/**
         * Creates a new discretizer with bin borders defined such that each bin
         * would contain approximately <tt>size</tt> samples from <tt>samples</tt>.
         * 
         * Samples are sorted into bins in ascending order. If there are not
         * sufficient (less than <tt>size</tt>) samples to fill a further bin, the
         * remaining samples are sorted into the last bin. That is, the last bin is
         * the only bin that may contain more than <tt>size</tt> samples.
         * 
         * @param samples
         *            an array with samples.
         * @param size
         *            the number of samples per bin.
         * @return a new discretizer.
         */",37-92,"('create', {'INSTRUCTION': {'covered': 112, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",252.0,32.0,Creates a new discretizer with bin borders defined such that each bin  would contain approximately <tt>size</tt> samples from <tt>samples</tt>.,Creates a new discretizer with bin borders defined such that each bin would contain approximately the size samples from the given samples,A new discretizer is created with bin borders that allow for the size of the samples in each bin to be determined.,0.570409461821323,Creates a new discretizer with tray borders defined so that each tray contains approximate <tt>sample sizes</tt> <tt>from samples</tt>.
866,cdk,"private void readPartialCharges(IChemModel model) throws CDKException, IOException{
    logger.info(""Reading partial atomic charges"");
    IAtomContainerSet moleculeSet = model.getMoleculeSet();
    IAtomContainer molecule = moleculeSet.getAtomContainer(0);
    String line = input.readLine();
    while (input.ready()) {
        line = input.readLine();
        logger.debug(""Read charge block line: "" + line);
        if ((line == null) || (line.indexOf(""Sum of Mulliken charges"") >= 0)) {
            logger.debug(""End of charge block found"");
            break;
        }
        StringReader sr = new StringReader(line);
        StreamTokenizer tokenizer = new StreamTokenizer(sr);
        if (tokenizer.nextToken() == StreamTokenizer.TT_NUMBER) {
            int atomCounter = (int) tokenizer.nval;
            tokenizer.nextToken();
            double charge;
            if (tokenizer.nextToken() == StreamTokenizer.TT_NUMBER) {
                charge = tokenizer.nval;
                logger.debug(""Found charge for atom "" + atomCounter + "": "" + charge);
            } else {
                throw new CDKException(""Error while reading charge: expected double."");
            }
            IAtom atom = molecule.getAtom(atomCounter - 1);
            atom.setCharge(charge);
        }
    }
}",readPartialCharges,org/openscience/cdk/io/Gaussian98Reader.java,/storage/io/src/main/java/org/openscience/cdk/io/Gaussian98Reader.java,"/**
     * Reads partial atomic charges and add the to the given ChemModel.
     *
     * @param model Description of the Parameter
     * @throws CDKException Description of the Exception
     * @throws IOException  Description of the Exception
     */",332-371,"('readPartialCharges', {'INSTRUCTION': {'covered': 97, 'missed': 5}, 'BRANCH': {'covered': 6, 'missed': 4}, 'LINE': {'covered': 22, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",218.0,12.0,Reads partial atomic charges and add the to the given ChemModel.,This method reads the partial atomic charges and add the them to the given model,Add the ChemModel to the partial atomic charges read.,0.264426528064113,Reads the partial atomic charges and adds them to the given ChemModel.
867,cdk,"public static ILigand[] order(ILigand[] ligands){
    ILigand[] newLigands = new ILigand[ligands.length];
    System.arraycopy(ligands, 0, newLigands, 0, ligands.length);
    Arrays.sort(newLigands, cipRule);
    return newLigands;
}",order,org/openscience/cdk/geometry/cip/CIPTool.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/CIPTool.java,"/**
     * Reorders the {@link ILigand} objects in the array according to the CIP rules.
     *
     * @param ligands Array of {@link ILigand}s to be reordered.
     * @return        Reordered array of {@link ILigand}s.
     */",235-247,"('order', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",56.0,17.0,Reorders the {@link ILigand} objects in the array according to the CIP rules.,Reorder the given object according to the CIP rules,The @link ILigand objects should be ordered according to the rules.,1.04138019028815,Rearranges the {@link ILigand} objects in the array according to CIP rules.
868,lettuce-core,"protected ConnectionFuture<T> initializeChannelAsync(ConnectionBuilder connectionBuilder){
    Mono<SocketAddress> socketAddressSupplier = connectionBuilder.socketAddress();
    if (clientResources.eventExecutorGroup().isShuttingDown()) {
        throw new IllegalStateException(""Cannot connect, Event executor group is terminated."");
    }
    CompletableFuture<SocketAddress> socketAddressFuture = new CompletableFuture<>();
    CompletableFuture<Channel> channelReadyFuture = new CompletableFuture<>();
    socketAddressSupplier.doOnError(socketAddressFuture::completeExceptionally).doOnNext(socketAddressFuture::complete).subscribe(redisAddress -> {
        if (channelReadyFuture.isCancelled()) {
            return;
        }
        initializeChannelAsync0(connectionBuilder, channelReadyFuture, redisAddress);
    }, channelReadyFuture::completeExceptionally);
    return new DefaultConnectionFuture<>(socketAddressFuture, channelReadyFuture.thenApply(channel -> (T) connectionBuilder.connection()));
}",initializeChannelAsync,io/lettuce/core/AbstractRedisClient.java,/src/main/java/io/lettuce/core/AbstractRedisClient.java,"/**
     * Connect and initialize a channel from {@link ConnectionBuilder}.
     *
     * @param connectionBuilder must not be {@code null}.
     * @return the {@link ConnectionFuture} to synchronize the connection process.
     * @since 4.4
     */",346-377,"('initializeChannelAsync', {'INSTRUCTION': {'covered': 49, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",145.0,12.0,Connect and initialize a channel from {@link ConnectionBuilder}.,This method connects and initializes a channel from the passed parameter,You can connect and create a channel from @link ConnectionBuilder.,1.23840411699481,Connect and initialize a channel from {@link ConnectionBuilder}.
869,cdk,"private List<Integer> tryDoubleBondCombinations(IAtomContainer container, int dblBondsAdded, int bondOffSet, int doubleBondMax, List<IAtom> atomsInNeedOfFix){
    int offSet = bondOffSet;
    List<Integer> dblBondPositions = null;
    while (offSet < container.getBondCount() && dblBondPositions == null) {
        IBond bond = container.getBond(offSet);
        if (atomsInNeedOfFix.contains(bond.getBegin()) && atomsInNeedOfFix.contains(bond.getEnd())) {
            bond.setOrder(IBond.Order.DOUBLE);
            dblBondsAdded = dblBondsAdded + 1;
            if (dblBondsAdded == doubleBondMax) {
                boolean validDoubleBondConfig = true;
                CHECK: for (IAtom atom : container.atoms()) {
                    if (atom.getValency() != atom.getImplicitHydrogenCount() + getConnectivity(atom, container)) {
                        validDoubleBondConfig = false;
                        break CHECK;
                    }
                }
                if (validDoubleBondConfig) {
                    dblBondPositions = new ArrayList<Integer>();
                    for (int idx = 0; idx < container.getBondCount(); idx++) {
                        if (container.getBond(idx).getOrder().equals(IBond.Order.DOUBLE))
                            dblBondPositions.add(idx);
                    }
                    return dblBondPositions;
                }
            } else {
                dblBondPositions = tryDoubleBondCombinations(container, dblBondsAdded, offSet + 1, doubleBondMax, atomsInNeedOfFix);
            }
            bond.setOrder(IBond.Order.SINGLE);
            dblBondsAdded = dblBondsAdded - 1;
        }
        offSet++;
    }
    return dblBondPositions;
}",tryDoubleBondCombinations,org/openscience/cdk/tautomers/InChITautomerGenerator.java,/tool/tautomer/src/main/java/org/openscience/cdk/tautomers/InChITautomerGenerator.java,"/**
     * Tries double bond combinations for a certain input container of which the double bonds have been stripped
     * around the mobile hydrogen positions. Recursively.
     *
     * @param container
     * @param dblBondsAdded counts double bonds added so far
     * @param bondOffSet offset for next double bond position to consider
     * @param doubleBondMax maximum number of double bonds to add
     * @param atomsInNeedOfFix atoms that require more bonds
     * @return a list of double bond positions (index) that make a valid combination, null if none found
     */",639-688,"('tryDoubleBondCombinations', {'INSTRUCTION': {'covered': 113, 'missed': 0}, 'BRANCH': {'covered': 20, 'missed': 0}, 'LINE': {'covered': 27, 'missed': 0}, 'COMPLEXITY': {'covered': 11, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",278.0,23.0,Tries double bond combinations for a certain input container of which the double bonds have been stripped  around the mobile hydrogen positions.,This method recursively tries double bond combinations for a certain input container of which the double bonds have been stripped around the mobile hydrogen positions,Double bonds have been stripped around the mobile hydrogen positions for a certain input container of tries double bond combinations.,0.625384318017966,Try double bond combinations for a certain inlet vessel whose double bonds have been stripped around the mobile positions of hydrogen.
870,cdk,"private static int findChargePosition(String formula){
    int end = formula.length() - 1;
    int pos = end;
    while (pos >= 0 && isSign(formula.charAt(pos))) pos--;
    int mark1 = pos;
    while (pos >= 0 && isDigit(formula.charAt(pos))) pos--;
    int mark2 = pos;
    while (pos >= 0 && isSign(formula.charAt(pos))) pos--;
    if (pos == mark2 && formula.charAt(pos) != ']')
        pos = mark1;
    return pos + 1;
}",findChargePosition,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * Extract the charge position given a molecular formula format [O3S]2-.
     *
     * @param formula The formula to inspect
     * @return        The charge position in the string
     */",805-825,"('findChargePosition', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",117.0,14.0,Extract the charge position given a molecular formula format [O3S]2-.,Given a molecular this method extracts the charge position,The charge position is given in a formula format.,0.156022130724962,Extract the charging position according to a molecular formula format [O3S]2-.
871,shardingsphere-elasticjob,"public boolean isRegisterStartSuccess(final Collection<Integer> shardingItems){
    for (int each : shardingItems) {
        if (!jobNodeStorage.isJobNodeExisted(GuaranteeNode.getStartedNode(each))) {
            return false;
        }
    }
    return true;
}",isRegisterStartSuccess,org/apache/shardingsphere/elasticjob/lite/internal/guarantee/GuaranteeService.java,/elasticjob-lite/elasticjob-lite-core/src/main/java/org/apache/shardingsphere/elasticjob/lite/internal/guarantee/GuaranteeService.java,"/**
     * Judge whether current sharding items are all register start success.
     *
     * @param shardingItems current sharding items
     * @return current sharding items are all start success or not
     */",51-64,"('isRegisterStartSuccess', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,11.0,Judge whether current sharding items are all register start success.,Check whether current sharding items are all register start success,"If current items are all register start success, judge.",0.513562870430424,Determine if the current partitioning items are all registry startup successes.
872,cdk,"private int parity(ITetrahedralChirality.Stereo stereo){
    switch(stereo) {
        case CLOCKWISE:
            return -1;
        case ANTI_CLOCKWISE:
            return +1;
        default:
            return 0;
    }
}",parity,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,"/**
     * Obtain the parity (winding) of a tetrahedral element. The parity is -1
     * for clockwise (odd), +1 for anticlockwise (even) and 0 for unspecified.
     *
     * @param stereo configuration
     * @return the parity
     */",978-994,"('parity', {'INSTRUCTION': {'covered': 9, 'missed': 2}, 'BRANCH': {'covered': 2, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,11.0,Obtain the parity (winding) of a tetrahedral element.,This method winds a tetrahedral element,The element has a parity.,0.0464146088728633,Obtain parity (winding) of a tetrahedral element.
873,cdk,"public IAtomContainer assignGasteigerMarsiliSigmaPartialCharges(IAtomContainer ac, boolean setCharge) throws Exception{
    for (int i = 0; i < ac.getAtomCount(); i++) ac.getAtom(i).setCharge(0.0);
    double[] gasteigerFactors = assignGasteigerSigmaMarsiliFactors(ac);
    double alpha = 1.0;
    double q;
    double deoc;
    IAtom[] atoms = null;
    int atom1 = 0;
    int atom2 = 0;
    double[] q_old = new double[ac.getAtomCount()];
    for (int i = 0; i < q_old.length; i++) q_old[0] = 20.0;
    out: for (int i = 0; i < MX_ITERATIONS; i++) {
        alpha *= MX_DAMP;
        boolean isDifferent = false;
        for (int j = 0; j < ac.getAtomCount(); j++) {
            q = gasteigerFactors[STEP_SIZE * j + j + 5];
            double difference = Math.abs(q_old[j]) - Math.abs(q);
            if (Math.abs(difference) > 0.001)
                isDifferent = true;
            q_old[j] = q;
            gasteigerFactors[STEP_SIZE * j + j + 4] = gasteigerFactors[STEP_SIZE * j + j + 2] * q * q + gasteigerFactors[STEP_SIZE * j + j + 1] * q + gasteigerFactors[STEP_SIZE * j + j];
        }
        if (!isDifferent)
            break out;
        Iterator<IBond> bonds = ac.bonds().iterator();
        while (bonds.hasNext()) {
            IBond bond = (IBond) bonds.next();
            atom1 = ac.indexOf(bond.getBegin());
            atom2 = ac.indexOf(bond.getEnd());
            if (gasteigerFactors[STEP_SIZE * atom1 + atom1 + 4] >= gasteigerFactors[STEP_SIZE * atom2 + atom2 + 4]) {
                if (""H"".equals(ac.getAtom(atom2).getSymbol())) {
                    deoc = DEOC_HYDROGEN;
                } else {
                    deoc = gasteigerFactors[STEP_SIZE * atom2 + atom2 + 3];
                }
            } else {
                if (""H"".equals(ac.getAtom(atom1).getSymbol())) {
                    deoc = DEOC_HYDROGEN;
                } else {
                    deoc = gasteigerFactors[STEP_SIZE * atom1 + atom1 + 3];
                }
            }
            q = (gasteigerFactors[STEP_SIZE * atom1 + atom1 + 4] - gasteigerFactors[STEP_SIZE * atom2 + atom2 + 4]) / deoc;
            gasteigerFactors[STEP_SIZE * atom1 + atom1 + 5] -= (q * alpha);
            gasteigerFactors[STEP_SIZE * atom2 + atom2 + 5] += (q * alpha);
        }
    }
    for (int i = 0; i < ac.getAtomCount(); i++) {
        ac.getAtom(i).setCharge(gasteigerFactors[STEP_SIZE * i + i + 5]);
    }
    return ac;
}",assignGasteigerMarsiliSigmaPartialCharges,org/openscience/cdk/charges/GasteigerMarsiliPartialCharges.java,/tool/charges/src/main/java/org/openscience/cdk/charges/GasteigerMarsiliPartialCharges.java,"/**
     *  Main method which assigns Gasteiger Marisili partial sigma charges.
     *
     *@param  ac             AtomContainer
     *@param setCharge            The Charge
     *@return                AtomContainer with partial charges
     *@exception  Exception  Possible Exceptions
     */",117-197,"('assignGasteigerMarsiliSigmaPartialCharges', {'INSTRUCTION': {'covered': 312, 'missed': 4}, 'BRANCH': {'covered': 21, 'missed': 1}, 'LINE': {'covered': 39, 'missed': 1}, 'COMPLEXITY': {'covered': 11, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",557.0,10.0,Main method which assigns Gasteiger Marisili partial sigma charges.,This method assigns partial sigma charges,The main method assigns partial sigma charges.,0.4369889151423,The main method that assigns Gasteiger Marisili partial sigma charges.
874,cdk,"public static void breadthFirstSearch(IAtomContainer ac, List<IAtom> sphere, IAtomContainer[] pathes) throws CDKException{
    IAtom atom = null;
    IAtom nextAtom = null;
    int atomNr;
    int nextAtomNr;
    List<IAtom> newSphere = new ArrayList<IAtom>();
    logger.debug(""Start of breadthFirstSearch"");
    for (int f = 0; f < sphere.size(); f++) {
        atom = sphere.get(f);
        if (!atom.getFlag(CDKConstants.ISINRING)) {
            atomNr = ac.indexOf(atom);
            logger.debug(""BreadthFirstSearch around atom "" + (atomNr + 1));
            List bonds = ac.getConnectedBondsList(atom);
            for (int g = 0; g < bonds.size(); g++) {
                IBond curBond = (IBond) bonds.get(g);
                nextAtom = curBond.getOther(atom);
                if (!nextAtom.getFlag(CDKConstants.VISITED) && !nextAtom.getFlag(CDKConstants.ISPLACED)) {
                    nextAtomNr = ac.indexOf(nextAtom);
                    logger.debug(""BreadthFirstSearch is meeting new atom "" + (nextAtomNr + 1));
                    pathes[nextAtomNr] = ac.getBuilder().newInstance(IAtomContainer.class, pathes[atomNr]);
                    logger.debug(""Making copy of path "" + (atomNr + 1) + "" to form new path "" + (nextAtomNr + 1));
                    pathes[nextAtomNr].addAtom(nextAtom);
                    logger.debug(""Adding atom "" + (nextAtomNr + 1) + "" to path "" + (nextAtomNr + 1));
                    pathes[nextAtomNr].addBond(curBond);
                    if (ac.getConnectedBondsCount(nextAtom) > 1) {
                        newSphere.add(nextAtom);
                    }
                }
            }
        }
    }
    if (newSphere.size() > 0) {
        for (int f = 0; f < newSphere.size(); f++) {
            newSphere.get(f).setFlag(CDKConstants.VISITED, true);
        }
        breadthFirstSearch(ac, newSphere, pathes);
    }
    logger.debug(""End of breadthFirstSearch"");
}",breadthFirstSearch,org/openscience/cdk/layout/AtomPlacer.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/AtomPlacer.java,"/**
     *  Performs a breadthFirstSearch in an AtomContainer starting with a
     *  particular sphere, which usually consists of one start atom, and searches
     *  for the longest aliphatic chain which is yet unplaced. If the search
     *  encounters an unplaced ring atom, it is also appended to the chain so that
     *  this last bond of the chain can also be laid out. This gives us the
     *  orientation for the attachment of the ring system.
     *
     *@param  ac                                              The AtomContainer to
     *      be searched
     *@param  sphere                                          A sphere of atoms to
     *      start the search with
     *@param  pathes                                          A vector of N pathes
     *      (N = no of heavy atoms).
     *@exception  org.openscience.cdk.exception.CDKException  Description of the
     *      Exception
     */",659-718,"('breadthFirstSearch', {'INSTRUCTION': {'covered': 186, 'missed': 0}, 'BRANCH': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 29, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",392.0,32.0,"Performs a breadthFirstSearch in an AtomContainer starting with a  particular sphere, which usually consists of one start atom, and searches  for the longest aliphatic chain which is yet unplaced.",This method performs a breadth first search in the given container starting with a particular sphere,The breadth first search is performed in an atom container with a sphere and searches for the longest aliphatic chain which is yet unplace.,0.936232493801435,"Performs a breadthFirstSearch in an AtomContainer starting with a particular sphere, which usually consists of a starting atom, and looks for the longest aliphatic chain that is not yet placed."
875,sonar-cxx,"private static boolean isGeneratedNodeExcluded(AstNode astNode){
    var prev = astNode.getPreviousAstNode();
    return prev != null && prev.getTokenLine() == astNode.getTokenLine() && prev.isCopyBookOrGeneratedNode();
}",isGeneratedNodeExcluded,org/sonar/cxx/checks/metrics/TooManyStatementsPerLineCheck.java,/cxx-checks/src/main/java/org/sonar/cxx/checks/metrics/TooManyStatementsPerLineCheck.java,"/**
   * Exclude subsequent generated nodes, if they are consecutive and on the same line.
   */",56-64,"('isGeneratedNodeExcluded', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",42.0,15.0,"Exclude subsequent generated nodes, if they are consecutive and on the same line.",If subsequent generated nodes are consecutive and on the same line this method excludes them,"If they are on the same line, exclude subsequent generated nodes.",0.347080853396962,"Exclude the following generated nodes, if they are consecutive and on the same line."
877,matsim-libs,"public final ConfigGroup createModule(final String name){
    if (this.modules.containsKey(name)) {
        throw new IllegalArgumentException(""Module "" + name + "" exists already."");
    }
    ConfigGroup m = new ConfigGroup(name);
    this.modules.put(name, m);
    return m;
}",createModule,org/matsim/core/config/Config.java,/matsim/src/main/java/org/matsim/core/config/Config.java,"/**
         * Creates a new module / config-group with the specified name.
         *
         * @param name
         *            The name of the config-group to be created.
         *
         * @return the newly created config group
         * @throws IllegalArgumentException
         *             if a config-group with the specified name already exists.
         */",226-243,"('createModule', {'INSTRUCTION': {'covered': 18, 'missed': 6}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",58.0,11.0,Creates a new module / config-group with the specified name.,Creates a new config-group with a specified name,A new module is created with the name specified.,0.527388237642134,Creates a configuration module/group with the specified name.
878,jackson-databind,"protected JsonDeserializer<Object> _prefetchRootDeserializer(JavaType valueType){
    if ((valueType == null) || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {
        return null;
    }
    JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);
    if (deser == null) {
        try {
            DeserializationContext ctxt = createDummyDeserializationContext();
            deser = ctxt.findRootValueDeserializer(valueType);
            if (deser != null) {
                _rootDeserializers.put(valueType, deser);
            }
            return deser;
        } catch (JacksonException e) {
        }
    }
    return deser;
}",_prefetchRootDeserializer,com/fasterxml/jackson/databind/ObjectReader.java,/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java,"/**
     * Method called to locate deserializer ahead of time, if permitted
     * by configuration. Method also is NOT to throw an exception if
     * access fails.
     */",2360-2386,"('_prefetchRootDeserializer', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,14.0,"Method called to locate deserializer ahead of time, if permitted  by configuration.","Prefetch deserializer ahead of time, if permitted by configuration","If allowed by configuration, method to locate deserializer ahead of time.",0.891610588174616,"Method called to locate the deserializer in advance, if the configuration allows it."
879,cdk,"static GeometricParity geometric(IAtomContainer mol, int l, int r, int l1, int l2, int r1, int r2){
    Point2d l2d = mol.getAtom(l).getPoint2d();
    Point2d r2d = mol.getAtom(r).getPoint2d();
    Point2d l12d = mol.getAtom(l1).getPoint2d();
    Point2d l22d = mol.getAtom(l2).getPoint2d();
    Point2d r12d = mol.getAtom(r1).getPoint2d();
    Point2d r22d = mol.getAtom(r2).getPoint2d();
    if (l2d != null && r2d != null && l12d != null && l22d != null && r12d != null && r22d != null) {
        return new DoubleBond2DParity(l2d, r2d, l12d, l22d, r12d, r22d);
    }
    Point3d l3d = mol.getAtom(l).getPoint3d();
    Point3d r3d = mol.getAtom(r).getPoint3d();
    Point3d l13d = mol.getAtom(l1).getPoint3d();
    Point3d r13d = mol.getAtom(r1).getPoint3d();
    if (l3d != null && r3d != null && l13d != null && r13d != null)
        return new DoubleBond3DParity(l3d, r3d, l13d, r13d);
    return null;
}",geometric,org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,"/**
     * Generate a new geometric parity (2D or 3D) for the given molecule and
     * atom indices. This method ensure that 2D and 3D coordinates are available
     * on the specified atoms and returns null if the 2D or 3D coordinates are
     * not fully available.
     *
     * @param mol a molecule
     * @param l   left double bonded atom
     * @param r   right double bonded atom
     * @param l1  first substituent atom of <i>l</i>
     * @param l2  second substituent atom of <i>l</i> or <i>l</i> if there is
     *            none
     * @param r1  first substituent atom of <i>r</i>
     * @param r2  second substituent atom of <i>r</i> or <i>r</i> if there is
     *            none
     * @return geometric parity or null
     */",148-194,"('geometric', {'INSTRUCTION': {'covered': 90, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 8}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 8}, 'METHOD': {'covered': 1, 'missed': 0}})",246.0,18.0,Generate a new geometric parity (2D or 3D) for the given molecule and  atom indices.,This method generates a new geometric parity for the given molecule and atom indices,A new geometric parity is created for the given molecule and atom indices.,0.404368086266465,Generate a new geometric parity (2D or 3D) for the given molecule and atom indices.
880,weblogic-kubernetes-operator,"static Map<String, String> loadContents(Path rootDir) throws IOException{
    try (Stream<Path> walk = Files.walk(rootDir, 1)) {
        return walk.filter(path -> !Files.isDirectory(path)).collect(Collectors.toMap(FileGroupReader::asString, FileGroupReader::readContents));
    }
}",loadContents,oracle/kubernetes/operator/helpers/FileGroupReader.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/FileGroupReader.java,"/**
   * Given a file path, loads the contents of the files into a map.
   *
   * @param rootDir the path to the top-level directory
   * @return a map of file names to string contents.
   * @throws IOException if an error occurs during the read
   */",45-57,"('loadContents', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,15.0,"Given a file path, loads the contents of the files into a map.",Loads the contents of the files into a map from a given file path,Load the contents of the files into a map.,0.28029309509853,"Because of a path to the file, loads the contents of the files into a map."
881,egeria,"public Optional<EntityDetail> findEntity(String userId, String qualifiedName, String entityTypeName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    final String methodName = ""findEntity"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateName(qualifiedName, CommonMapper.QUALIFIED_NAME_PROPERTY_NAME, methodName);
    qualifiedName = repositoryHelper.getExactMatchRegex(qualifiedName);
    InstanceProperties properties = repositoryHelper.addStringPropertyToInstance(serviceName, null, CommonMapper.QUALIFIED_NAME_PROPERTY_NAME, qualifiedName, methodName);
    TypeDef entityTypeDef = repositoryHelper.getTypeDefByName(userId, entityTypeName);
    Optional<EntityDetail> retrievedEntity = Optional.ofNullable(repositoryHandler.getUniqueEntityByName(userId, qualifiedName, CommonMapper.QUALIFIED_NAME_PROPERTY_NAME, properties, entityTypeDef.getGUID(), entityTypeDef.getName(), methodName));
    log.trace(""Searching for entity with qualifiedName: {}. Result is {}"", qualifiedName, retrievedEntity.map(InstanceHeader::getGUID).orElse(null));
    return retrievedEntity;
}",findEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCommonHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCommonHandler.java,"/**
     * Find out if the entity is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId         the name of the calling user
     * @param qualifiedName  the qualifiedName name of the entity to be searched
     * @param entityTypeName the type name of the entity
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",160-195,"('findEntity', {'INSTRUCTION': {'covered': 59, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",159.0,12.0,Find out if the entity is already stored in the repository.,Check if the given entity is already stored in the repository,"If the entity is already in the repository, you should find out.",0.205241507725891,Check if the entity is already stored in the repository.
882,cdk,"private void mapInputMoleculeToInchiMolgraph(IAtomContainer inchiMolGraph, IAtomContainer mol) throws CDKException{
    Iterator<Map<IAtom, IAtom>> iter = org.openscience.cdk.isomorphism.VentoFoggia.findIdentical(inchiMolGraph, AtomMatcher.forElement(), BondMatcher.forAny()).matchAll(mol).limit(1).toAtomMap().iterator();
    if (iter.hasNext()) {
        for (Map.Entry<IAtom, IAtom> e : iter.next().entrySet()) {
            IAtom src = e.getKey();
            IAtom dst = e.getValue();
            String position = src.getID();
            dst.setID(position);
            LOGGER.debug(""Mapped InChI "", src.getSymbol(), "" "", src.getID(), "" to "", dst.getSymbol(), "" "" + dst.getID());
        }
    } else {
        throw new IllegalArgumentException(CANSMI.create(inchiMolGraph) + "" "" + CANSMI.create(mol));
    }
}",mapInputMoleculeToInchiMolgraph,org/openscience/cdk/tautomers/InChITautomerGenerator.java,/tool/tautomer/src/main/java/org/openscience/cdk/tautomers/InChITautomerGenerator.java,"/**
     * Atom-atom mapping of the input molecule to the bare container constructed from the InChI connection table.
     * This makes it possible to map the positions of the mobile hydrogens in the InChI back to the input molecule.
     * @param inchiMolGraph molecule (bare) as defined in InChI
     * @param mol user input molecule
     * @throws CDKException
     */",315-342,"('mapInputMoleculeToInchiMolgraph', {'INSTRUCTION': {'covered': 84, 'missed': 18}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",199.0,17.0,Atom-atom mapping of the input molecule to the bare container constructed from the InChI connection table.,Create an Atom-atom mapping of the input molecule to the bare container constructed from the InChI connection table,The input molecule is mapped to the bare container from the InChI connection table.,1.59036224566433,Atom-atom mapping of the input molecule to the bare container built from the InChI connection table.
883,dcache,"public boolean awaitChangeUntil(int value, Date deadline) throws InterruptedException{
    _lock.lock();
    try {
        inLock();
        return _counter != value || _updated.awaitUntil(deadline);
    } finally {
        _lock.unlock();
    }
}",awaitChangeUntil,org/dcache/util/AtomicCounter.java,/modules/common/src/main/java/org/dcache/util/AtomicCounter.java,"/**
     * Waits for the counter to change to a value different from
     * <code>value</code>.
     * <p>
     * The method returns when one of the following happens:
     * <p>
     * * The current counter value is different from the
     * <code>value</code> argument; or
     * <p>
     * * Some other thread invokes the <code>increment</code> method for this AtomicCounter; or
     * <p>
     * * Some other thread interrupts the current thread; or
     * <p>
     * * The specified deadline elapses; or
     * <p>
     * * A ""spurious wakeup"" occurs.
     *
     * @param value    the value to wait for the counter to change away from
     * @param deadline the absolute time to wait until
     * @return true if the counter has a different value than {@code value} upon return
     * @throw InterruptedException if the current thread is interrupted
     */",45-76,"('awaitChangeUntil', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,19.0,Waits for the counter to change to a value different from  <code>value</code>.,Wait that the counter changes to the given value ,Waits for the counter to change to a different value.,0.525471010106787,Waits for the counter to change to a value other than the <code>value</code>.
884,cdk,"public static Rectangle2D shiftReactionVertical(IReaction reaction, Rectangle2D bounds, Rectangle2D last, double gap){
    if (last.getMaxY() + gap >= bounds.getMinY()) {
        double yShift = bounds.getHeight() + last.getHeight() + gap;
        Vector2d shift = new Vector2d(0, yShift);
        List<IAtomContainer> containers = ReactionManipulator.getAllAtomContainers(reaction);
        for (IAtomContainer container : containers) {
            translate2D(container, shift);
        }
        return new Rectangle2D.Double(bounds.getX(), bounds.getY() + yShift, bounds.getWidth(), bounds.getHeight());
    } else {
        return bounds;
    }
}",shiftReactionVertical,org/openscience/cdk/geometry/GeometryTools.java,/legacy/src/main/java/org/openscience/cdk/geometry/GeometryTools.java,"/**
     * Shift the containers in a reaction vertically upwards to not overlap
     * with the reference Rectangle2D. The shift is such that the given
     * gap is realized, but only if the reactions are actually overlapping.
     *
     * @param reaction the reaction to shift
     * @param bounds   the bounds of the reaction to shift
     * @param last     the bounds of the last reaction
     * @return         the Rectangle2D of the shifted reaction
     */",1699-1723,"('shiftReactionVertical', {'INSTRUCTION': {'covered': 53, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",133.0,16.0,Shift the containers in a reaction vertically upwards to not overlap  with the reference Rectangle2D.,Shift the given containers vertically upwards to not overlap with the reference Rectangle2D,The containers should be shifted vertically upwards to not overlap with the reference.,0.353401222210984,Move the containers vertically upwards so as not to overlap the Rectangle2D reference.
885,cdk,"public void addSingletonCell(int element){
    SortedSet<Integer> cell = new TreeSet<Integer>();
    cell.add(element);
    this.cells.add(cell);
}",addSingletonCell,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,"/**
     * Add a new singleton cell to the end of the partition containing only
     * this element.
     *
     * @param element the element to add in its own cell
     */",309-319,"('addSingletonCell', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,16.0,Add a new singleton cell to the end of the partition containing only  this element.,Add a singleton to the end of the partition that contains this element only.,The partition contains only one element and should be added with a new singleton cell.,0.5637347271794,Add a new singleton cell to the end of the partition containing only this item.
886,dcache,"public static Map<PnfsId, EnumSet<EventType>> fromZkData(byte[] data){
    checkArgument(data.length > 1, ""Too little data"");
    checkArgument(data[0] == 0, ""Wrong format"");
    Map<PnfsId, EnumSet<EventType>> deserialised = new HashMap<>();
    int index = 1;
    while (index < data.length) {
        checkArgument(data.length - index >= 3, ""Too little data for bitmask"");
        short bitmask = (short) (data[index++] << 8 | data[index++] & 0xFF);
        EnumSet<EventType> eventTypes = Arrays.stream(EventType.values()).filter(t -> (bitmask & 1 << t.ordinal()) != 0).collect(Collectors.toCollection(() -> EnumSet.noneOf(EventType.class)));
        byte length = data[index++];
        checkArgument(data.length - index >= length, ""Too little data for PNFSID"");
        PnfsId id = new PnfsId(BaseEncoding.base16().encode(data, index, length));
        index += length;
        deserialised.put(id, eventTypes);
        LOGGER.debug(""Adding id={} bitmask={} types={}"", id, bitmask, eventTypes);
    }
    return deserialised;
}",fromZkData,diskCacheV111/namespace/EventNotifier.java,/modules/dcache/src/main/java/diskCacheV111/namespace/EventNotifier.java,"/**
     * Convert a binary representation back into an event receiver's list of desired events.
     *
     * @param data the binary data
     * @return a Map between the target and its set of desired event types.
     * @throws IllegalArgumentException if the data is badly formatted.
     */",143-173,"('fromZkData', {'INSTRUCTION': {'covered': 115, 'missed': 4}, 'BRANCH': {'covered': 6, 'missed': 4}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",242.0,15.0,Convert a binary representation back into an event receiver's list of desired events.,Convert a binary representation back into list of desired events of the event receiver.,A receiver wants a list of desired events.,0.532418879175502,Convert a binary representation back into a list of events desired by an event receiver.
887,cdk,"private static void exch(long[] values, int i, int j){
    long k = values[i];
    values[i] = values[j];
    values[j] = k;
}",exch,org/openscience/cdk/graph/invariant/InChINumbersTools.java,/storage/inchi/src/main/java/org/openscience/cdk/graph/invariant/InChINumbersTools.java,"/**
     * Exchange the elements at index i with that at index j.
     *
     * @param values an array of values
     * @param i an index
     * @param j another index
     */",193-204,"('exch', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",43.0,12.0,Exchange the elements at index i with that at index j.,Replace the elements at i with the ones at j.,Exchange elements at index i and j.,0.163197373453167,Swap the items in index i with those in index j.
888,cron-utils,"private void buildMappings(final CronDefinition from, final CronDefinition to){
    final Map<CronFieldName, FieldDefinition> sourceFieldDefinitions = getFieldDefinitions(from);
    final Map<CronFieldName, FieldDefinition> destFieldDefinitions = getFieldDefinitions(to);
    boolean startedDestMapping = false;
    boolean startedSourceMapping = false;
    for (final CronFieldName name : CronFieldName.values()) {
        final FieldDefinition destinationFieldDefinition = destFieldDefinitions.get(name);
        final FieldDefinition sourceFieldDefinition = sourceFieldDefinitions.get(name);
        if (destinationFieldDefinition != null) {
            startedDestMapping = true;
        }
        if (sourceFieldDefinition != null) {
            startedSourceMapping = true;
        }
        if (startedDestMapping && destinationFieldDefinition == null) {
            break;
        }
        if (!startedSourceMapping && destinationFieldDefinition != null) {
            mappings.put(name, returnOnZeroExpression(name));
        }
        if (startedSourceMapping && sourceFieldDefinition == null && destinationFieldDefinition != null) {
            mappings.put(name, returnAlwaysExpression(name));
        }
        if (sourceFieldDefinition == null || destinationFieldDefinition == null) {
            continue;
        }
        if (CronFieldName.DAY_OF_WEEK.equals(name)) {
            mappings.put(name, dayOfWeekMapping((DayOfWeekFieldDefinition) sourceFieldDefinition, (DayOfWeekFieldDefinition) destinationFieldDefinition));
        } else if (CronFieldName.DAY_OF_MONTH.equals(name)) {
            mappings.put(name, dayOfMonthMapping(sourceFieldDefinition, destinationFieldDefinition));
        } else {
            mappings.put(name, returnSameExpression());
        }
    }
}",buildMappings,com/cronutils/mapper/CronMapper.java,/src/main/java/com/cronutils/mapper/CronMapper.java,"/**
     * Builds functions that map the fields from source CronDefinition to target.
     *
     * @param from - source CronDefinition
     * @param to   - target CronDefinition
     */",175-217,"('buildMappings', {'INSTRUCTION': {'covered': 115, 'missed': 0}, 'BRANCH': {'covered': 26, 'missed': 2}, 'LINE': {'covered': 25, 'missed': 0}, 'COMPLEXITY': {'covered': 13, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",262.0,12.0,Builds functions that map the fields from source CronDefinition to target.,Builds procedures that associate the fields from the source CronDefinition to the target.,Functions that map the fields from source to target were built.,0.361086964306062,Generates functions that map fields from the source CronDefinition to the target.
889,cdk,"boolean hasPriority(int focus, int i, int j){
    if (tetrahedralElements[i] == null && tetrahedralElements[j] != null)
        return true;
    if (tetrahedralElements[i] != null && tetrahedralElements[j] == null)
        return false;
    if (doubleBondElements[i] == null && doubleBondElements[j] != null)
        return true;
    if (doubleBondElements[i] != null && doubleBondElements[j] == null)
        return false;
    IAtom iAtom = container.getAtom(i);
    IAtom jAtom = container.getAtom(j);
    boolean iIsSp3 = isSp3Carbon(iAtom, graph[i].length);
    boolean jIsSp3 = isSp3Carbon(jAtom, graph[j].length);
    if (iIsSp3 != jIsSp3)
        return !iIsSp3;
    if (tetrahedralElements[i] == null && tetrahedralElements[j] != null)
        return true;
    if (tetrahedralElements[i] != null && tetrahedralElements[j] == null)
        return false;
    boolean iCyclic = focus >= 0 ? ringSearch.cyclic(focus, i) : ringSearch.cyclic(i);
    boolean jCyclic = focus >= 0 ? ringSearch.cyclic(focus, j) : ringSearch.cyclic(j);
    if (!iCyclic && jCyclic)
        return true;
    if (iCyclic && !jCyclic)
        return false;
    if (iAtom.getAtomicNumber() > 0 && jAtom.getAtomicNumber() == 0)
        return true;
    if (iAtom.getAtomicNumber() == 0 && jAtom.getAtomicNumber() > 0)
        return false;
    final int iDegree = graph[i].length;
    int iElem = iAtom.getAtomicNumber();
    final int jDegree = graph[j].length;
    int jElem = jAtom.getAtomicNumber();
    if (iElem == 6)
        iElem = 256;
    if (jElem == 6)
        jElem = 256;
    if (iDegree == 1 && jDegree > 1)
        return true;
    if (jDegree == 1 && iDegree > 1)
        return false;
    if (iElem < jElem)
        return true;
    if (iElem > jElem)
        return false;
    if (iDegree < jDegree)
        return true;
    if (iDegree > jDegree)
        return false;
    return false;
}",hasPriority,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,"/**
     * Does the atom at index {@code i} have priority over the atom at index
     * {@code j} for the tetrahedral atom {@code focus}.
     *
     * @param focus tetrahedral centre (or -1 if double bond)
     * @param i     adjacent atom index
     * @param j     adjacent atom index
     * @return whether atom i has priority
     */",1065-1133,"('hasPriority', {'INSTRUCTION': {'covered': 217, 'missed': 18}, 'BRANCH': {'covered': 58, 'missed': 10}, 'LINE': {'covered': 35, 'missed': 2}, 'COMPLEXITY': {'covered': 26, 'missed': 9}, 'METHOD': {'covered': 1, 'missed': 0}})",421.0,32.0,Does the atom at index {@code i} have priority over the atom at index  {@code j} for the tetrahedral atom {@code focus}.,Checks if the atom at index {@code i} has priority over the one at index {@code j} for the tetrahedral atom {@code focus}.,Does the atom at index @code i have priority over the atom at index @code j for the tetrahedral atom?,0.664531766827107,Does the atom with the index {@code i} have priority over the atom at the index {@code j} for the tetrahedral atom {@code focus}.
890,egeria,"public Optional<EntityDetail> findPortImplementationEntity(String userId, String qualifiedName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, PORT_IMPLEMENTATION_TYPE_NAME);
}",findPortImplementationEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,"/**
     * Find out if the PortImplementation object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",331-347,"('findPortImplementationEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,13.0,Find out if the PortImplementation object is already stored in the repository.,Checks whether the PortImplementation object is already stored in the repository. It relies on the fully qualified name to get the entity.,"If the PortImplementation object is already in the repository, you should find it.",0.173286932716251,Check if the PortImplementation object is already stored in the repository.
892,cdk,"public static boolean checkIfAllLigandsAreDifferent(ILigand[] ligands){
    for (int i = 0; i < (ligands.length - 1); i++) {
        if (cipRule.compare(ligands[i], ligands[i + 1]) == 0)
            return false;
    }
    return true;
}",checkIfAllLigandsAreDifferent,org/openscience/cdk/geometry/cip/CIPTool.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/CIPTool.java,"/**
     * Checks if each next {@link ILigand} is different from the previous
     * one according to the {@link CIPLigandRule}. It assumes that the input
     * is sorted based on that rule.
     *
     * @param ligands array of {@link ILigand} to check
     * @return true, if all ligands are different
     */",220-233,"('checkIfAllLigandsAreDifferent', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,24.0,Checks if each next {@link ILigand} is different from the previous  one according to the {@link CIPLigandRule}.,"Returns true if all the lingards {@link ILigand} are different from the previous one, based on the {@link CIPLigandRule}. This method assumes that the input lingards are sorted based on the rule.",Checks if the previous one is different from the next one.,0.179617955641623,Checks whether each following {@link ILigand} is different from the previous one according to the {@link CIPLigandRule}.
893,cdk,"public static IAtomContainer fromSignatureString(String signatureString, IChemObjectBuilder coBuilder){
    ColoredTree tree = AtomSignature.parse(signatureString);
    MoleculeFromSignatureBuilder builder = new MoleculeFromSignatureBuilder(coBuilder);
    builder.makeFromColoredTree(tree);
    return builder.getAtomContainer();
}",fromSignatureString,org/openscience/cdk/signature/MoleculeSignature.java,/descriptor/signature/src/main/java/org/openscience/cdk/signature/MoleculeSignature.java,"/**
     * Builder for molecules (rather, for atom containers) from signature
     * strings.
     *
     * @param signatureString the signature string to use
     * @param coBuilder {@link IChemObjectBuilder} to build the returned atom container from
     * @return an atom container
     */",171-184,"('fromSignatureString', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,14.0,"Builder for molecules (rather, for atom containers) from signature  strings.",Allows to build molecules from strings that represent their signatures.,Molecules and atom containers are built from signature strings.,0.401865835723998,Manufacturer of molecules (rather containers of atoms) from signature chains.
894,tablesaw,"Column<T> first(final int numRows){
    int newRowCount = Math.min(numRows, size());
    return inRange(0, newRowCount);
}",first,tech/tablesaw/columns/Column.java,/core/src/main/java/tech/tablesaw/columns/Column.java,/** Returns a column of the same type containing the first {@code numRows} of this column. */,654-658,"('first', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,19.0,Returns a column of the same type containing the first {@code numRows} of this column.,"Returns a column of the same type which only includes the first ""numRows"" of such a column.",The first @code numRows of this column is returned.,0.57451134197374,Returns a column of the same type containing the first {@code numRows} in that column.
895,tablesaw,"StringColumn yearMonth(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & month"");
    for (int r = 0; r < this.size(); r++) {
        long c1 = this.getLongInternal(r);
        if (DateTimeColumn.valueIsMissing(c1)) {
            newColumn.append(StringColumnType.missingValueIndicator());
        } else {
            String ym = String.valueOf(getYear(c1));
            ym = ym + ""-"" + Strings.padStart(String.valueOf(getMonthValue(c1)), 2, '0');
            newColumn.append(ym);
        }
    }
    return newColumn;
}",yearMonth,tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,"/**
   * Returns a StringColumn with the year and month from this column concatenated into a String that
   * will sort lexicographically in temporal order.
   *
   * <p>This simplifies the production of plots and tables that aggregate values into standard
   * temporal units (e.g., you want monthly data but your source data is more than a year long and
   * you don't want months from different years aggregated together).
   */",215-236,"('yearMonth', {'INSTRUCTION': {'covered': 52, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",125.0,23.0,Returns a StringColumn with the year and month from this column concatenated into a String that  will sort lexicographically in temporal order.,"Returns a StringColumn that contains, for each row, the year and month from this column. Such data are concatenated so that it will be possible to sort the column in lexicographical order to obtain temporal order. This makes the production of plots and tables in temporal order easier.",The year and month from this column will be combined into a String that will sort lexicographically in temporal order.,0.962798330709575,Returns a StringColumn with the year and month of this column concatenated into a String that will sort lexicographically in temporal order.
896,matsim-libs,"private void reportOptions(){
    logger.info(String.format(""Received %d positional command line arguments:"", positionalArguments.size()));
    logger.info(""   "" + String.join("" , "", positionalArguments));
    Map<String, List<String>> prefixedOptions = new HashMap<>();
    List<String> nonPrefixedOptions = new LinkedList<>();
    for (String option : options.keySet()) {
        int separatorIndex = option.indexOf(':');
        if (separatorIndex > -1) {
            String prefix = option.substring(0, separatorIndex);
            option = option.substring(separatorIndex + 1);
            if (!prefixedOptions.containsKey(prefix)) {
                prefixedOptions.put(prefix, new LinkedList<>());
            }
            prefixedOptions.get(prefix).add(option);
        } else {
            nonPrefixedOptions.add(option);
        }
    }
    logger.info(String.format(""Received %d command line options with %d prefixes:"", options.size(), prefixedOptions.size()));
    Collections.sort(nonPrefixedOptions);
    for (String option : nonPrefixedOptions) {
        logger.info(String.format(""   %s = %s"", option, options.get(option)));
    }
    List<String> orderedPrefixes = new LinkedList<>(prefixedOptions.keySet());
    Collections.sort(orderedPrefixes);
    for (String prefix : orderedPrefixes) {
        logger.info(String.format(""   Prefix %s:"", prefix));
        for (String option : prefixedOptions.get(prefix)) {
            logger.info(String.format(""      %s = %s"", option, options.get(prefix + "":"" + option)));
        }
    }
}",reportOptions,org/matsim/core/config/CommandLine.java,/matsim/src/main/java/org/matsim/core/config/CommandLine.java,"/**
	 * Reports on the options that have been inserted into the MATSim {@link Config}
	 * via the command line.
	 */",500-546,"('reportOptions', {'INSTRUCTION': {'covered': 194, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 30, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",323.0,21.0,Reports on the options that have been inserted into the MATSim {@link Config}  via the command line.,Writes the options that have been added into the MATSim using the command line.,Reports on the options that have been inserted into the MATSim.,0.243643074012951,Indicates the options that have been inserted into MATSim {@link Config} via the command line.
897,cdk,"private List<IIsotope> isotopesList(){
    List<IIsotope> isotopes = new ArrayList<IIsotope>();
    Iterator<IMolecularFormula> componentIterator = components.iterator();
    while (componentIterator.hasNext()) {
        Iterator<IIsotope> compIsotopes = componentIterator.next().isotopes().iterator();
        while (compIsotopes.hasNext()) {
            IIsotope isotope = compIsotopes.next();
            if (!isotopes.contains(isotope)) {
                isotopes.add(isotope);
            }
        }
    }
    return isotopes;
}",isotopesList,org/openscience/cdk/formula/AdductFormula.java,/base/data/src/main/java/org/openscience/cdk/formula/AdductFormula.java,"/**
     *  Returns a List for looping over all isotopes in this adduct formula.
     *
     * @return    A List with the isotopes in this adduct formula
     */",194-212,"('isotopesList', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",107.0,13.0,Returns a List for looping over all isotopes in this adduct formula.,Returns a list for cycling over all the isotopes in this adduct formula.,This adduct formula returns a List for looping over all the isotopes.,1.0252007974211,Returns a list for the loop on all isotopes of this adduct formula.
898,cdk,"public Partition splitBefore(int cellIndex, int splitElement){
    Partition r = new Partition();
    for (int j = 0; j < cellIndex; j++) {
        r.addCell(this.copyBlock(j));
    }
    r.addSingletonCell(splitElement);
    SortedSet<Integer> splitBlock = this.copyBlock(cellIndex);
    splitBlock.remove(splitElement);
    r.addCell(splitBlock);
    for (int j = cellIndex + 1; j < this.size(); j++) {
        r.addCell(this.copyBlock(j));
    }
    return r;
}",splitBefore,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,"/**
     * Splits this partition by taking the cell at cellIndex and making two
     * new cells - the first with the singleton splitElement and the second
     * with the rest of the elements from that cell.
     *
     * @param cellIndex the index of the cell to split on
     * @param splitElement the element to put in its own cell
     * @return a new (finer) Partition
     */",213-240,"('splitBefore', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",119.0,34.0,Splits this partition by taking the cell at cellIndex and making two  new cells - the first with the singleton splitElement and the second  with the rest of the elements from that cell.,"Splits this partition into two new cells, the first of which contains the singleton splitElement and the second of which contains the remaining items from the cell at cellIndex.    ",The first cell with the singleton splitElement is used to split the partition and the second with the rest of the elements from that cell.,0.818558101104882,Divides this partition by taking the cell to cellIndex and creating two new cells - the first with the singleton splitElement and the second with the rest of the elements in this cell.
899,matsim-libs,"public boolean decreaseKey(E value, double cost){
    int index = indices[this.getIndex(value)];
    if (index < 0) {
        return this.add(value, cost);
    }
    double oldCost = costs[index];
    if (oldCost < cost)
        return false;
    siftUp(index, value, cost);
    return true;
}",decreaseKey,org/matsim/core/router/priorityqueue/BinaryMinHeap.java,/matsim/src/main/java/org/matsim/core/router/priorityqueue/BinaryMinHeap.java,"/**
         * Increases the priority (=decrease the given double value) of the element.
         * If the element ins not part of the queue, it is added. If the new priority
         * is lower than the existing one, the method returns <tt>false</tt>
         *
         * @return <tt>true</tt> if the elements priority was decreased.
         */",313-339,"('decreaseKey', {'INSTRUCTION': {'covered': 30, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",72.0,14.0,Increases the priority (=decrease the given double value) of the element.,Decreases the specified double value while increasing the element's priority. The element is added if it is not already in the queue. The method returns false if the new priority is lower than the current one.,The priority is increased by decreasing the double value.,0.302780900210906,Increases the priority (= decrease the double value given) of the element.
900,cdk,"private void layoutMolecule(List ringSetMolecule, IAtomContainer molecule, AtomPlacer3D ap3d, AtomTetrahedralLigandPlacer3D atlp3d, AtomPlacer atomPlacer) throws CDKException, IOException, CloneNotSupportedException{
    IAtomContainer ac = null;
    int safetyCounter = 0;
    IAtom atom = null;
    do {
        safetyCounter++;
        atom = ap3d.getNextPlacedHeavyAtomWithUnplacedRingNeighbour(molecule);
        if (atom != null) {
            IAtom unplacedAtom = ap3d.getUnplacedRingHeavyAtom(molecule, atom);
            IRingSet ringSetA = getRingSetOfAtom(ringSetMolecule, unplacedAtom);
            IAtomContainer ringSetAContainer = RingSetManipulator.getAllInOneContainer(ringSetA);
            templateHandler.mapTemplates(ringSetAContainer, ringSetAContainer.getAtomCount());
            if (checkAllRingAtomsHasCoordinates(ringSetAContainer)) {
            } else {
                throw new IOException(""RingAtomLayoutError: Not every ring atom is placed! Molecule cannot be layout.Sorry"");
            }
            Point3d firstAtomOriginalCoord = unplacedAtom.getPoint3d();
            Point3d centerPlacedMolecule = ap3d.geometricCenterAllPlacedAtoms(molecule);
            setBranchAtom(molecule, unplacedAtom, atom, ap3d.getPlacedHeavyAtoms(molecule, atom), ap3d, atlp3d);
            layoutRingSystem(firstAtomOriginalCoord, unplacedAtom, ringSetA, centerPlacedMolecule, atom, ap3d);
            searchAndPlaceBranches(molecule, ringSetAContainer, ap3d, atlp3d, atomPlacer);
            ringSetA = null;
            unplacedAtom = null;
            firstAtomOriginalCoord = null;
            centerPlacedMolecule = null;
        } else {
            setAtomsToUnVisited(molecule);
            atom = ap3d.getNextPlacedHeavyAtomWithUnplacedAliphaticNeighbour(molecule);
            if (atom != null) {
                ac = atom.getBuilder().newInstance(IAtomContainer.class);
                ac.addAtom(atom);
                searchAndPlaceBranches(molecule, ac, ap3d, atlp3d, atomPlacer);
                ac = null;
            }
        }
    } while (!ap3d.allHeavyAtomsPlaced(molecule) || safetyCounter > molecule.getAtomCount());
}",layoutMolecule,org/openscience/cdk/modeling/builder3d/ModelBuilder3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/ModelBuilder3D.java,"/**
     * Layout the molecule, starts with ring systems and than aliphatic chains.
     *
     *@param  ringSetMolecule  ringSystems of the molecule
     */",260-312,"('layoutMolecule', {'INSTRUCTION': {'covered': 97, 'missed': 25}, 'BRANCH': {'covered': 6, 'missed': 4}, 'LINE': {'covered': 26, 'missed': 5}, 'COMPLEXITY': {'covered': 2, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",297.0,13.0,"Layout the molecule, starts with ring systems and than aliphatic chains.","Starting with ring systems and moving on to aliphatic chains, the molecule is laid out. ",The molecule starts with ring systems and aliphatic chains.,0.401767762688681,The arrangement of the molecule begins with ring systems and then aliphatic chains.
901,dataverse,"public static boolean conflictsWithExistingFilenames(String pathPlusFilename, List<FileMetadata> fileMetadatas){
    List<String> filePathsAndNames = getPathsAndFileNames(fileMetadatas);
    return filePathsAndNames.contains(pathPlusFilename);
}",conflictsWithExistingFilenames,edu/harvard/iq/dataverse/ingest/IngestUtil.java,/src/main/java/edu/harvard/iq/dataverse/ingest/IngestUtil.java,"/**
     * Given a new proposed label or directoryLabel for a file, check against
     * existing files if a duplicate directoryLabel/label combination would be
     * created.
     */",125-133,"('conflictsWithExistingFilenames', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,24.0,"Given a new proposed label or directoryLabel for a file, check against  existing files if a duplicate directoryLabel/label combination would be  created.",Check existing files to see if a duplicate directoryLabel/label combination would be produced if a new label or directoryLabel is proposed for a file.,"If a duplicate directoryLabel/label combination is created, check against existing files.",0.840980661428584,"Given a new label or directory proposedlabel for a file, check against existing files if a duplicate directory/label combination would be created."
902,glowstone,"public boolean readDoubleList(@NonNls String key, Consumer<? super List<Double>> consumer){
    return readList(key, TagType.DOUBLE, consumer);
}",readDoubleList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to a list subtag if it is present and its contents are double
     * tags.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */",608-618,"('readDoubleList', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,19.0,Applies the given function to a list subtag if it is present and its contents are double  tags.,"If a list subtag is present and its contents are double tags, it applies the specified function to it. ","If the function is present and the contents are double tags, apply it to the list subtag.",0.505753964242334,Applies the given function to a list subtag if it is present and its contents consist of double tags.
903,cdk,"TextOutline positionMassLabel(TextOutline massLabel, TextOutline elementLabel){
    final Rectangle2D elementBounds = elementLabel.getBounds();
    final Rectangle2D massBounds = massLabel.getBounds();
    return massLabel.translate((elementBounds.getMinX() - padding) - massBounds.getMaxX(), (elementBounds.getMinY() - (massBounds.getHeight() / 2)) - massBounds.getMinY());
}",positionMassLabel,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,"/**
     * Position the mass label relative to the element label. The mass adjunct is position to the
     * top left of the element label.
     *
     * @param massLabel    mass label outline
     * @param elementLabel element label outline
     * @return positioned mass label
     */",528-541,"('positionMassLabel', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,10.0,Position the mass label relative to the element label.,Place the element label in relation to the mass label. The mass adjunct is located above the element label on the left.,The mass label should be placed relative to the element label.,0.47803109772495,Position the mass label relative to the item label.
904,acs-aem-commons,"protected final void searchAndUpdateResourceType(String oldResourceType, String newResourceType) throws RepositoryException{
    Map<String, String> map = new HashMap<>();
    map.put(""p.limit"", ""-1"");
    map.put(""path"", ""/content"");
    map.put(""1_property"", SLING_RESOURCE_TYPE);
    map.put(""1_property.value"", oldResourceType);
    logger.info(""Finding all nodes under /content with resource type: {}"", oldResourceType);
    final QueryBuilder queryBuilder = resourceResolver.adaptTo(QueryBuilder.class);
    if (queryBuilder != null) {
        Query query = queryBuilder.createQuery(PredicateGroup.create(map), session);
        QueryUtil.setResourceResolverOn(resourceResolver, query);
        SearchResult result = query.getResult();
        Iterator<Node> nodeItr = result.getNodes();
        if (nodeItr.hasNext()) {
            while (nodeItr.hasNext()) {
                Node node = nodeItr.next();
                updateResourceType(node, newResourceType);
            }
        } else {
            logger.info(""No nodes found with resource type: {}"", oldResourceType);
        }
    }
}",searchAndUpdateResourceType,com/adobe/acs/commons/ondeploy/scripts/OnDeployScriptBase.java,/bundle/src/main/java/com/adobe/acs/commons/ondeploy/scripts/OnDeployScriptBase.java,"/**
     * Searches for the current sling:resourceType under /content and replaces any nodes it finds
     * with the newResourceType.
     *
     * @param oldResourceType The current sling:resourceType.
     * @param newResourceType The new sling:resourceType to be used.
     */",182-213,"('searchAndUpdateResourceType', {'INSTRUCTION': {'covered': 75, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",191.0,19.0,Searches for the current sling:resourceType under /content and replaces any nodes it finds  with the newResourceType.,"/content is searched for the current sling:resourceType, and any nodes it finds are changed with the newResourceType. ",The current sling:resourceType is searched under /content and replaced with the newResourceType.,0.46389417722212,Finds the current sling:resourceType under /content and replaces all nodes it finds with the newResourceType.
905,anserini,"public String documentRaw(int ldocid){
    try {
        return reader.document(ldocid).get(IndexArgs.RAW);
    } catch (Exception e) {
        return null;
    }
}",documentRaw,io/anserini/search/SimpleImpactSearcher.java,/src/main/java/io/anserini/search/SimpleImpactSearcher.java,"/**
     * Returns the ""raw"" field of a document based on an internal Lucene docid.
     * The method is named to be consistent with Lucene's {@link IndexReader#document(int)}, contra Java's standard
     * method naming conventions.
     *
     * @param ldocid internal Lucene docid
     * @return the ""raw"" field the document
     */",346-361,"('documentRaw', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,16.0,"Returns the ""raw"" field of a document based on an internal Lucene docid.","Gives back a document's ""raw"" field based on an internal Lucene docid. Unlike Java's typical method naming standards, the method is named to be consistent  with Lucene's @link IndexReader#document(int).","The ""raw"" field is based on an internal docid.",0.968394096741965,"Returns the ""raw"" field of a document based on an internal Lucene docid."
906,glowstone,"public boolean matches(CompoundTag other){
    for (Entry<String, Tag> entry : value.entrySet()) {
        if (!other.value.containsKey(entry.getKey())) {
            return false;
        }
        Tag value = entry.getValue();
        Tag otherValue = other.value.get(entry.getKey());
        if ((value == null && otherValue != null) || (value != null && otherValue == null)) {
            return false;
        }
        if (value != null) {
            if (value.getClass() != otherValue.getClass()) {
                return false;
            }
            if (value instanceof CompoundTag) {
                if (!((CompoundTag) value).matches((CompoundTag) otherValue)) {
                    return false;
                }
            } else if (value instanceof IntArrayTag) {
                if (!Arrays.equals(((IntArrayTag) value).getValue(), ((IntArrayTag) otherValue).getValue())) {
                    return false;
                }
            } else if (value instanceof ByteArrayTag) {
                if (!Arrays.equals(((ByteArrayTag) value).getValue(), ((ByteArrayTag) otherValue).getValue())) {
                    return false;
                }
            } else if (!value.equals(otherValue)) {
                return false;
            }
        }
    }
    return true;
}",matches,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Checks to see if this tag is a strict, deep submap of the given CompoundTag.
     *
     * @param other The CompoundTag that should contain our values.
     */",85-125,"('matches', {'INSTRUCTION': {'covered': 80, 'missed': 16}, 'BRANCH': {'covered': 18, 'missed': 12}, 'LINE': {'covered': 18, 'missed': 7}, 'COMPLEXITY': {'covered': 5, 'missed': 11}, 'METHOD': {'covered': 1, 'missed': 0}})",265.0,17.0,"Checks to see if this tag is a strict, deep submap of the given CompoundTag.","Checks if this tag is a strict and deep submap of the given CompoundTag, which contains our values.","If this tag is a deep submap of the CompoundTag, we need to check it.",0.252647609626212,Checks whether this tag is a strict and deep submap of the given CompoundTag.
907,cdk,"private Integer massNumber(int atomicNumber, double exactMass) throws IOException{
    String symbol = PeriodicTable.getSymbol(atomicNumber);
    IIsotope isotope = Isotopes.getInstance().getIsotope(symbol, exactMass, 0.001);
    return isotope != null ? isotope.getMassNumber() : null;
}",massNumber,org/openscience/cdk/modeling/builder3d/MMFF94BasedParameterSetReader.java,/tool/forcefield/src/main/java/org/openscience/cdk/modeling/builder3d/MMFF94BasedParameterSetReader.java,"/**
     * Mass number for a atom with a given atomic number and exact mass.
     *
     * @param atomicNumber atomic number
     * @param exactMass    exact mass
     * @return the mass number (or null) if no mass number was found
     * @throws IOException isotope configuration could not be loaded
     */",562-574,"('massNumber', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,14.0,Mass number for a atom with a given atomic number and exact mass.,"For an atom with a specific atomic number and mass, returns its mass number. ",The mass number is the atomic number for the atom.,0.464625742652082,The number of masses for an atom with a given atomic number and an exact mass.
908,cdk,"public boolean matches(IAtom atom){
    PharmacophoreAtom patom = PharmacophoreAtom.get(atom);
    return patom.getSymbol().equals(getSymbol());
}",matches,org/openscience/cdk/pharmacophore/PharmacophoreQueryAtom.java,/tool/pcore/src/main/java/org/openscience/cdk/pharmacophore/PharmacophoreQueryAtom.java,"/**
     * Checks whether this query atom matches a target atom.
     * 
     * Currently a query pharmacophore atom will match a target pharmacophore group if the
     * symbols of the two groups match. This is based on the assumption that
     * pharmacophore groups with the same symbol will have the same SMARTS
     * pattern.
     *
     * @param atom A target pharmacophore group
     * @return true if the current query group has the same symbol as the target group
     */",104-119,"('matches', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,10.0,Checks whether this query atom matches a target atom.,"Determines if the destination atom matches the query atom. Currently, if the symbols of the two groups match, a query pharmacophore atom will match a target pharmacophore group. This is predicated on the idea that pharmacophore  groups sharing a symbol will have a similar SMARTS pattern. ",Does the query atom match the target atom?,0.733197961810215,Checks whether this query atom corresponds to a target atom.
909,tablesaw,"DoubleColumn neg(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[neg]"", size());
    for (int i = 0; i < size(); i++) {
        newColumn.set(i, getDouble(i) * -1);
    }
    return newColumn;
}",neg,tech/tablesaw/columns/numbers/NumberMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/numbers/NumberMapFunctions.java,"/**
   * For each item in the column, returns the same number with the sign changed. For example: -1.3
   * returns 1.3, 2.135 returns -2.135 0 returns 0
   */",336-346,"('neg', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,16.0,"For each item in the column, returns the same number with the sign changed.",Returns the same number with a new sign for each item in the column. For instance: -1.3 yields 1.3; and 2.135 yields -2.135; 0 yields 0.,The number is returned for each item in the column.,0.403218119683488,"For each item in the column, returns the same number with the modified sign."
910,matsim-libs,"private static void copyShipments(Carrier carrierWS, Carrier carrier){
    for (CarrierShipment carrierShipment : carrier.getShipments().values()) {
        log.debug(""Copy CarrierShipment: "" + carrierShipment.toString());
        CarrierUtils.addShipment(carrierWS, carrierShipment);
    }
}",copyShipments,org/matsim/contrib/freight/utils/FreightUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/utils/FreightUtils.java,"/**
	 * Copy all shipments from the existing carrier to the new carrier with
	 * shipments.
	 *
	 * @param carrierWS the ""new"" carrier with Shipments
	 * @param carrier   the already existing carrier
	 */",250-262,"('copyShipments', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",52.0,14.0,Copy all shipments from the existing carrier to the new carrier with  shipments.,Transfer every shipment made with the old carrier to the new one. ,All shipments from the old carrier to the new carrier should be copied.,0.415829637398229,Copy all shipments from the existing carrier to the new carrier with the shipments.
911,cdk,"static List<Point2D> pointsOf(final Shape shape){
    final List<Point2D> points = new ArrayList<Point2D>();
    final double[] coordinates = new double[6];
    for (PathIterator i = shape.getPathIterator(null); !i.isDone(); i.next()) {
        switch(i.currentSegment(coordinates)) {
            case PathIterator.SEG_CLOSE:
                break;
            case PathIterator.SEG_MOVETO:
            case PathIterator.SEG_LINETO:
                points.add(new Point2D.Double(coordinates[0], coordinates[1]));
                break;
            case PathIterator.SEG_QUADTO:
                points.add(new Point2D.Double(coordinates[0], coordinates[1]));
                points.add(new Point2D.Double(coordinates[2], coordinates[3]));
                break;
            case PathIterator.SEG_CUBICTO:
                points.add(new Point2D.Double(coordinates[0], coordinates[1]));
                points.add(new Point2D.Double(coordinates[2], coordinates[3]));
                points.add(new Point2D.Double(coordinates[4], coordinates[5]));
                break;
        }
    }
    if (!points.isEmpty() && points.get(points.size() - 1).equals(points.get(0))) {
        points.remove(points.size() - 1);
    }
    return points;
}",pointsOf,org/openscience/cdk/renderer/generators/standard/ConvexHull.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/ConvexHull.java,"/**
     * Convert a Java 2D shape to a list of points.
     *
     * @param shape a shape
     * @return list of point
     */",128-161,"('pointsOf', {'INSTRUCTION': {'covered': 120, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 2}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",287.0,11.0,Convert a Java 2D shape to a list of points.,Returns a list of points related to the given Java 2D shape.,A Java 2D shape can be converted to a list of points.,0.179186457343141,Convert a Java 2D shape to a list of points.
912,cdk,"public DescriptorValue calculate(IAtomContainer container){
    boolean[] originalFlag4 = new boolean[container.getAtomCount()];
    for (int i = 0; i < originalFlag4.length; i++) {
        originalFlag4[i] = container.getAtom(i).getFlag(CDKConstants.VISITED);
    }
    if (checkAromaticity) {
        try {
            AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(container);
            Aromaticity.cdkLegacy().apply(container);
        } catch (CDKException e) {
            return getDummyDescriptorValue(e);
        }
    }
    int largestPiSystemAtomsCount = 0;
    List<IAtom> startSphere;
    List<IAtom> path;
    for (int i = 0; i < container.getAtomCount(); i++) {
        container.getAtom(i).setFlag(CDKConstants.VISITED, false);
    }
    for (int i = 0; i < container.getAtomCount(); i++) {
        if ((container.getMaximumBondOrder(container.getAtom(i)) != IBond.Order.SINGLE || Math.abs(container.getAtom(i).getFormalCharge()) >= 1 || container.getAtom(i).getFlag(CDKConstants.ISAROMATIC) || container.getAtom(i).getAtomicNumber() == IElement.N || container.getAtom(i).getAtomicNumber() == IElement.O) && !container.getAtom(i).getFlag(CDKConstants.VISITED)) {
            startSphere = new ArrayList<IAtom>();
            path = new ArrayList<IAtom>();
            startSphere.add(container.getAtom(i));
            try {
                breadthFirstSearch(container, startSphere, path);
            } catch (CDKException e) {
                return getDummyDescriptorValue(e);
            }
            if (path.size() > largestPiSystemAtomsCount) {
                largestPiSystemAtomsCount = path.size();
            }
        }
    }
    for (int i = 0; i < originalFlag4.length; i++) {
        container.getAtom(i).setFlag(CDKConstants.VISITED, originalFlag4[i]);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(largestPiSystemAtomsCount), getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/LargestPiSystemDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/LargestPiSystemDescriptor.java,"/**
     * Calculate the count of atoms of the largest pi system in the supplied {@link IAtomContainer}.
     * 
     * <p>The method require one parameter:
     * <ol>
     * <li>if checkAromaticity is true, the method check the aromaticity,
     * <li>if false, means that the aromaticity has already been checked
     * </ol>
     *
     * @param container The {@link IAtomContainer} for which this descriptor is to be calculated
     * @return the number of atoms in the largest pi system of this AtomContainer
     * @see #setParameters
     */",141-206,"('calculate', {'INSTRUCTION': {'covered': 147, 'missed': 17}, 'BRANCH': {'covered': 22, 'missed': 2}, 'LINE': {'covered': 24, 'missed': 7}, 'COMPLEXITY': {'covered': 11, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",416.0,19.0,Calculate the count of atoms of the largest pi system in the supplied {@link IAtomContainer}.,"Find the greatest pi system's atom count in the provided IAtomContainer. If ""checkAromaticity"" is true, the method checks the aromaticity. If ""checkAromaticity"" is false, it means that the aromaticity has already been verified. The method requires only one parameter.",The count of the largest pi system is calculated by using the supplied IAtomContainer.,0.306199009087694,Calculate the number of atoms of the largest pi system in the supplied {@link IAtomContainer}.
913,acs-aem-commons,"private boolean pathMatchesFilter(final String[] filters, String path){
    boolean matches = false;
    for (String filter : filters) {
        try {
            if (filter.equals(""*"") || path.matches(filter)) {
                matches = true;
                break;
            }
        } catch (PatternSyntaxException ex) {
            logErrorMessage(""Ignoring invalid regex filter: ["" + filter + ""].  Reason: "" + ex.getMessage());
        }
    }
    return matches;
}",pathMatchesFilter,com/adobe/acs/commons/replication/dispatcher/impl/RefetchFlushContentBuilderImpl.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/impl/RefetchFlushContentBuilderImpl.java,"/**
     * See if any of the provided filter patterns match the current path.  TRUE, if no filters are received.
     *
     * @param filters An array of string making up the regex to match with the path.  They should never
     *                be empty since there is a DEFAULT value.
     * @param path The path to interrogate.
     * @return true (match found) or false (no match)
     */",347-369,"('pathMatchesFilter', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",81.0,13.0,See if any of the provided filter patterns match the current path.,"Analyze the current path to see whether any of the specified filter patterns fit it. If no filters are received, it returns true.","If any of the filters match the current path, you should.",0.180484239687758,Check if any of the filter templates provided match the current path.
914,cdk,"private static boolean failParse(String label, List<String> tokens){
    tokens.clear();
    tokens.add(label);
    return false;
}",failParse,org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,"/**
     * Abort call when a label could not be parsed. The tokens are cleared
     * and replaced with the original label.
     *
     * @param label  the original label
     * @param tokens the current tokens
     * @return always returns false
     */",249-261,"('failParse', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,10.0,Abort call when a label could not be parsed.,"When a label can not be parsed, end the request. The tokens are cleared, and the original label is put in their place. ","When a label could not be read, abort.",0.317289471382304,Abort the call when a label could not be analyzed.
915,dcache,"private Set<Checksum> finalizeChecksums(){
    _ioStateWriteLock.lock();
    try {
        _isWritable = false;
    } finally {
        _ioStateWriteLock.unlock();
    }
    synchronized (_dataRangeSet) {
        synchronized (_digests) {
            try {
                if (_dataRangeSet.asRanges().size() != 1 || _nextChecksumOffset == 0) {
                    feedZerosToDigesterForRangeGaps();
                }
                return _digests.stream().map(Checksum::new).collect(Collectors.toSet());
            } catch (IOException e) {
                _log.info(""Unable to generate checksum of sparse file: {}"", e.toString());
                return Collections.emptySet();
            }
        }
    }
}",finalizeChecksums,org/dcache/pool/movers/ChecksumChannel.java,/modules/dcache/src/main/java/org/dcache/pool/movers/ChecksumChannel.java,"/**
     * Returns the computed digest or null if overlapping writes have been detected.
     *
     * @return Checksum
     */",239-271,"('finalizeChecksums', {'INSTRUCTION': {'covered': 43, 'missed': 10}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 3}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",121.0,13.0,Returns the computed digest or null if overlapping writes have been detected.,Gives back the calculated digest. Returns null if overlapping writes were encountered. ,"If there are overlap writes, returns the computed digest.",0.377351046018884,Returns the calculated summary or null if overlapping writes were detected.
916,jackson-databind,"public String writeValueAsString(Object value) throws JsonProcessingException{
    SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());
    try {
        _writeValueAndClose(createGenerator(sw), value);
    } catch (JsonProcessingException e) {
        throw e;
    } catch (IOException e) {
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
    return sw.getAndClear();
}",writeValueAsString,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Method that can be used to serialize any Java value as
     * a String. Functionally equivalent to calling
     * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}
     * and constructing String, but more efficient.
     *<p>
     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
     */",3807-3828,"('writeValueAsString', {'INSTRUCTION': {'covered': 20, 'missed': 4}, 'LINE': {'covered': 6, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,14.0,Method that can be used to serialize any Java value as  a String.,"A method for serializing any Java value to a String. Functionally equal to creating a String by using ""StringWriter#writeValue(Writer,Object)"", but more quick. ",The method can be used toserialize any Java value.,1.07561336036725,A method that can be used to serialize any Java value as a String.
917,tablesaw,"DoubleColumn log10(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[log10]"", size());
    for (int i = 0; i < size(); i++) {
        newColumn.set(i, Math.log10(getDouble(i)));
    }
    return newColumn;
}",log10,tech/tablesaw/columns/numbers/NumberMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/numbers/NumberMapFunctions.java,/** Returns the base 10 log of the values in this column as a NumberColumn. */,285-292,"('log10', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",62.0,15.0,Returns the base 10 log of the values in this column as a NumberColumn.,Returns the values in this column's base-10 log as a NumberColumn.,The base 10 log of the values is returned as a NumberColumn.,0.378569996567353,Returns the base 10 log of the values in this column as a Number column.
918,cdk,"public void write(IChemObject object) throws CDKException{
    if (object instanceof IReactionSet) {
        writeReactionSet((IReactionSet) object);
    } else if (object instanceof IReaction) {
        writeReaction((IReaction) object);
    } else {
        throw new CDKException(""Only supported is writing ReactionSet, Reaction objects."");
    }
}",write,org/openscience/cdk/io/MDLRXNWriter.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLRXNWriter.java,"/**
     * Writes a IChemObject to the MDL RXN file formated output.
     * It can only output ChemObjects of type Reaction
     *
     * @param object class must be of type Molecule or MoleculeSet.
     *
     * @see org.openscience.cdk.ChemFile
     */",177-194,"('write', {'INSTRUCTION': {'covered': 17, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,11.0,Writes a IChemObject to the MDL RXN file formated output.,IChemObject is written to the output in MDL RXN file format. Only ChemObjects of the type Reaction can be produced by it. ,The MDL RXN file formated output is written in a IChemObject.,0.27447922925773,Writes an IChemObject in the formatted output of the RXN MDL file.
919,acs-aem-commons,"private void replaceInArray(JsonNode node, Map<String, Object> contentVariableReplacements){
    if (node.get(0) != null && node.get(0).isTextual()) {
        List<String> updated = new LinkedList<>();
        for (JsonNode arrayItem : node) {
            String current = arrayItem.asText();
            updated.add(replaceInString(current, contentVariableReplacements));
        }
        ((ArrayNode) node).removeAll();
        for (int i = 0; i < updated.size(); i++) {
            ((ArrayNode) node).insert(i, updated.get(i));
        }
    } else if (node.get(0) != null && node.get(0).isContainerNode()) {
        for (JsonNode arrayItem : node) {
            replaceInElements(arrayItem, contentVariableReplacements);
        }
    }
}",replaceInArray,com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,/bundle/src/main/java/com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,"/**
     * Iterates through array items and replaces any placeholders found.
     *
     * @param node Array node
     * @param contentVariableReplacements current map of content variables
     */",172-194,"('replaceInArray', {'INSTRUCTION': {'covered': 81, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",175.0,10.0,Iterates through array items and replaces any placeholders found.,Replaces the placeholders in the array items,Iterates through array items.,1.94278108772124,Browses table elements and replaces all found placeholders.
920,soul,"protected void updateCache(final ConfigGroupEnum group, final List<T> data){
    String json = GsonUtils.getInstance().toJson(data);
    ConfigDataCache newVal = new ConfigDataCache(group.name(), json, Md5Utils.md5(json), System.currentTimeMillis());
    ConfigDataCache oldVal = CACHE.put(newVal.getGroup(), newVal);
    LOG.info(""update config cache[{}], old: {}, updated: {}"", group, oldVal, newVal);
}",updateCache,org/apache/shenyu/admin/listener/AbstractDataChangedListener.java,/shenyu-admin/src/main/java/org/apache/shenyu/admin/listener/AbstractDataChangedListener.java,"/**
     * if md5 is not the same as the original, then update lcoal cache.
     * @param group ConfigGroupEnum
     * @param <T> the type of class
     * @param data the new config data
     */",225-236,"('updateCache', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,15.0,"if md5 is not the same as the original, then update lcoal cache.",Update the local cache if the MD5 does not equal the original,"If md5 is different from the original, then update the cache.",0.183585960514276,"If md5 is not the same as the original, update the lcoal cache."
921,cdk,"private String formatMDLInt(int i, int l){
    String s = """", fs = """";
    NumberFormat nf = NumberFormat.getNumberInstance(Locale.ENGLISH);
    nf.setParseIntegerOnly(true);
    nf.setMinimumIntegerDigits(1);
    nf.setMaximumIntegerDigits(l);
    nf.setGroupingUsed(false);
    s = nf.format(i);
    l = l - s.length();
    for (int f = 0; f < l; f++) fs += "" "";
    fs += s;
    return fs;
}",formatMDLInt,org/openscience/cdk/io/MDLRXNWriter.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLRXNWriter.java,"/**
     * Formats an int to fit into the connectiontable and changes it
     * to a String.
     *
     * @param   i  The int to be formated
     * @param   l  Length of the String
     * @return     The String to be written into the connectiontable
     */",323-344,"('formatMDLInt', {'INSTRUCTION': {'covered': 56, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,15.0,Formats an int to fit into the connectiontable and changes it  to a String.,Converts an integer to a String after formatting it to fit in the connectiontable. ,The int is formatted to fit into the connectiontable and changed to a String.,0.630791158575775,Formats an int to fit the connection table and replaces it with a string.
922,cdk,"private static boolean processAtomLabels(final CharIter iter, final Map<Integer, String> dest){
    int atomIdx = 0;
    while (iter.hasNext()) {
        // fast forward through empty labels
        while (iter.nextIf(';')) atomIdx++;
        char c = iter.next();
        if (c == '$') {
            // optional
            iter.nextIf(',');
            // end of atom label
            return true;
        } else {
            // push back
            iter.pos--;
            int beg = iter.pos;
            int rollback = beg;
            while (iter.hasNext()) {
                if (iter.pos == beg && iter.curr() == '_' && iter.peek() == 'R') {
                    ++beg;
                }
                // correct step over of escaped label
                if (iter.curr() == '&') {
                    rollback = iter.pos;
                    if (iter.nextIf('&') && iter.nextIf('#') && iter.nextIfDigit()) {
                        // more digits
                        while (iter.nextIfDigit()) {
                        }
                        if (!iter.nextIf(';')) {
                            iter.pos = rollback;
                        } else {
                        }
                    } else {
                        iter.pos = rollback;
                    }
                } else if (iter.curr() == ';')
                    break;
                else if (iter.curr() == '$')
                    break;
                else
                    iter.next();
            }
            dest.put(atomIdx, unescape(iter.substr(beg, iter.pos)));
            atomIdx++;
            if (iter.nextIf('$')) {
                // optional
                iter.nextIf(',');
                return true;
            }
            if (!iter.nextIf(';'))
                return false;
        }
    }
    return false;
}",processAtomLabels,org/openscience/cdk/smiles/CxSmilesParser.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/CxSmilesParser.java,"/**
     * Process atom labels from extended SMILES in a char iter.
     *
     * @param iter char iteration
     * @param dest destination of labels (atomidx->label)
     * @return parse success/failure
     */",62-124,"('processAtomLabels', {'INSTRUCTION': {'covered': 118, 'missed': 10}, 'BRANCH': {'covered': 30, 'missed': 4}, 'LINE': {'covered': 34, 'missed': 2}, 'COMPLEXITY': {'covered': 14, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",309.0,11.0,Process atom labels from extended SMILES in a char iter.,Handle expanded SMILES' atom labels in a char iter. ,atom labels are processed in a char iter.,0.252647615578951,Process extended SMILES atom labels in a tank.
923,jackson-databind,"public ArrayNode insertPOJO(int index, Object pojo){
    return _insert(index, (pojo == null) ? nullNode() : pojoNode(pojo));
}",insertPOJO,com/fasterxml/jackson/databind/node/ArrayNode.java,/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java,"/**
     * Method that will construct a POJONode and
     * insert it at specified position in this array.
     *
     * @return This array node, to allow chaining
     */",625-633,"('insertPOJO', {'INSTRUCTION': {'covered': 9, 'missed': 3}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,16.0,Method that will construct a POJONode and  insert it at specified position in this array.,Creates a POJONode and insets it into this array at the provided position.,The method will construct a POJONode and place it in this array.,0.931629513328207,Method that will construct a POJONode and insert it at the position specified in this array.
924,cdk,"public Point3d[] calculate3DCoordinates1(Point3d aPoint, Point3d bPoint, Point3d cPoint, int nwanted, double length, double angle){
    Point3d[] points = new Point3d[nwanted];
    Vector3d ba = new Vector3d(aPoint);
    ba.sub(bPoint);
    ba.normalize();
    if (cPoint == null) {
        Vector3d cVector = getNonColinearVector(ba);
        cPoint = new Point3d(cVector);
    }
    Vector3d cb = new Vector3d(bPoint);
    cb.sub(cPoint);
    cb.normalize();
    double cbdotba = cb.dot(ba);
    if (cbdotba > 0.999999) {
        Vector3d cVector = getNonColinearVector(ba);
        cPoint = new Point3d(cVector);
        cb = new Vector3d(bPoint);
        cb.sub(cPoint);
    }
    Vector3d cbxba = new Vector3d();
    cbxba.cross(cb, ba);
    cbxba.normalize();
    Vector3d ax = new Vector3d();
    ax.cross(cbxba, ba);
    ax.normalize();
    double drot = Math.PI * 2.0 / (double) nwanted;
    for (int i = 0; i < nwanted; i++) {
        double rot = (double) i * drot;
        points[i] = new Point3d(aPoint);
        Vector3d vx = new Vector3d(ba);
        vx.scale(-Math.cos(angle) * length);
        Vector3d vy = new Vector3d(ax);
        vy.scale(Math.cos(rot) * length);
        Vector3d vz = new Vector3d(cbxba);
        vz.scale(Math.sin(rot) * length);
        points[i].add(vx);
        points[i].add(vy);
        points[i].add(vz);
    }
    return points;
}",calculate3DCoordinates1,org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,"/**
     *  Calculate new point(s) X in a B-A system to form B-A-X. Use C as reference
     *  for * staggering about the B-A bond (1a) 1 ligand(B) of refAtom (A) which
     *  itself has a ligand (C) (i) 1 points required; vector along AB vector (ii)
     *  2 points: 2 vectors in ABC plane, staggered and eclipsed wrt C (iii) 3
     *  points: 1 staggered wrt C, the others +- gauche wrt C If C is null, a
     *  random non-colinear C is generated
     *
     *@param  aPoint   to which substituents are added
     *@param  nwanted  number of points to calculate (1-3)
     *@param  length   A-X length
     *@param  angle    B-A-X angle
     *@param  bPoint   Description of the Parameter
     *@param  cPoint   Description of the Parameter
     *@return          Point3d[] nwanted points (or zero if failed)
     */",370-436,"('calculate3DCoordinates1', {'INSTRUCTION': {'covered': 137, 'missed': 17}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 32, 'missed': 4}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",354.0,15.0,Calculate new point(s) X in a B-A system to form B-A-X.,"To create a B-A-X system, this method determines new point(s) X in a B-A system. For reference, it uses C when talking about the B-A bond (1a) 1 ligand (B) of a refAtom (A), which possesses a ligand (C) of its own. (i) one point is needed; the vector follows the AB vector (ii) Two points: two vectors in the ABC plane, shadowed and spaced apart from C (iii) Three points: one left wrt C whereas the others were staggered. A random non-colinear C is created if C is null.",B-A-X is formed by calculating new point(s) X in a B-A system.,0.490037157452595,Calculate new X points in a B-A system to form B-A-X.
925,cdk,"public static Point3d[] zmatrixToCartesian(double[] distances, int[] first_atoms, double[] angles, int[] second_atoms, double[] dihedrals, int[] third_atoms){
    Point3d[] cartesianCoords = new Point3d[distances.length];
    for (int index = 0; index < distances.length; index++) {
        if (index == 0) {
            cartesianCoords[index] = new Point3d(0d, 0d, 0d);
        } else if (index == 1) {
            cartesianCoords[index] = new Point3d(distances[1], 0d, 0d);
        } else if (index == 2) {
            cartesianCoords[index] = new Point3d(-Math.cos((angles[2] / 180) * Math.PI) * distances[2] + distances[1], Math.sin((angles[2] / 180) * Math.PI) * distances[2], 0d);
            if (first_atoms[index] == 0)
                cartesianCoords[index].x = (cartesianCoords[index].x - distances[1]) * -1;
        } else {
            Vector3d cd = new Vector3d();
            cd.sub(cartesianCoords[third_atoms[index]], cartesianCoords[second_atoms[index]]);
            Vector3d bc = new Vector3d();
            bc.sub(cartesianCoords[second_atoms[index]], cartesianCoords[first_atoms[index]]);
            Vector3d n1 = new Vector3d();
            n1.cross(cd, bc);
            Vector3d n2 = rotate(n1, bc, -dihedrals[index]);
            Vector3d ba = rotate(bc, n2, -angles[index]);
            ba.normalize();
            ba.scale(distances[index]);
            Point3d result = new Point3d();
            result.add(cartesianCoords[first_atoms[index]], ba);
            cartesianCoords[index] = result;
        }
    }
    return cartesianCoords;
}",zmatrixToCartesian,org/openscience/cdk/geometry/ZMatrixTools.java,/storage/io/src/main/java/org/openscience/cdk/geometry/ZMatrixTools.java,"/**
     * Takes the given Z Matrix coordinates and converts them to cartesian coordinates.
     * The first Atom end up in the origin, the second on on the x axis, and the third
     * one in the XY plane. The rest is added by applying the Zmatrix distances, angles
     * and dihedrals. Angles are in degrees.
     *
     * @param distances     Array of distance variables of the Z matrix
     * @param angles        Array of angle variables of the Z matrix
     * @param dihedrals     Array of distance variables of the Z matrix
     * @param first_atoms   Array of atom ids of the first invoked atom in distance, angle and dihedral
     * @param second_atoms  Array of atom ids of the second invoked atom in angle and dihedral
     * @param third_atoms   Array of atom ids of the third invoked atom in dihedral
     *
     * @cdk.dictref blue-obelisk:zmatrixCoordinatesIntoCartesianCoordinates
     */",42-91,"('zmatrixToCartesian', {'INSTRUCTION': {'covered': 178, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",384.0,13.0,Takes the given Z Matrix coordinates and converts them to cartesian coordinates.,"Transforms the supplied Z Matrix coordinates to cartesian coordinates. The first atom is found at the point of origin, the second is found on the x-axis, and the third is found in the XY plane. Applying the Zmatrix distances, angles, and dihedrals adds the remaining information. Angles have a degree value. ",The Z Matrix coordinates are converted to cartesian coordinates.,0.477558458624275,Takes the coordinates of the given Z matrix and converts them to Cartesian coordinates.
928,glowstone,"public void putLongList(@NonNls String key, List<Long> list){
    putList(key, TagType.LONG, list, LongTag::new);
}",putLongList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Adds or replaces a list subtag with a list of longs.
     *
     * @param key the key to write to
     * @param list the list contents as longs, to convert to long tags
     */",987-995,"('putLongList', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,12.0,Adds or replaces a list subtag with a list of longs.,"Substitutes a list subtag with a list of longs, or adds one.",A list subtag is replaced with a list of longs.,0.176201704914121,Adds or replaces a list subtag with a list of long ones.
929,shardingsphere-elasticjob,"public List<JobRunningStatistics> findJobRunningStatisticsWeekly(){
    if (!isRdbConfigured()) {
        return Collections.emptyList();
    }
    return rdbRepository.findJobRunningStatistics(StatisticTimeUtils.getStatisticTime(StatisticInterval.DAY, -7));
}",findJobRunningStatisticsWeekly,org/apache/shardingsphere/elasticjob/cloud/scheduler/statistics/StatisticManager.java,/elasticjob-cloud/elasticjob-cloud-scheduler/src/main/java/org/apache/shardingsphere/elasticjob/cloud/scheduler/statistics/StatisticManager.java,"/**
     * Get the collection of job statistics in the most recent week.
     * 
     * @return collection of running task statistics data objects
     */",237-247,"('findJobRunningStatisticsWeekly', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,12.0,Get the collection of job statistics in the most recent week.,Obtain the most recent week's data on employment. ,The collection of job statistics is available.,0.16924381998587,Get the most recent week's employment statistics collection.
930,cdk,"public static double evalValenceIndex(IAtomContainer atomContainer, List<List<Integer>> fragList) throws CDKException{
    try {
        IsotopeFactory ifac = Isotopes.getInstance();
        ifac.configureAtoms(atomContainer);
    } catch (IOException e) {
        throw new CDKException(""IO problem occurred when using the CDK atom config\n"" + e.getMessage(), e);
    }
    double sum = 0;
    for (List<Integer> aFragList : fragList) {
        List<Integer> frag = aFragList;
        double prod = 1.0;
        for (Object aFrag : frag) {
            int atomSerial = (Integer) aFrag;
            IAtom atom = atomContainer.getAtom(atomSerial);
            String sym = atom.getSymbol();
            if (sym.equals(""S"")) {
                double tmp = deltavSulphur(atom, atomContainer);
                if (tmp != -1) {
                    prod = prod * tmp;
                    continue;
                }
            }
            if (sym.equals(""P"")) {
                double tmp = deltavPhosphorous(atom, atomContainer);
                if (tmp != -1) {
                    prod = prod * tmp;
                    continue;
                }
            }
            int z = atom.getAtomicNumber();
            int zv = getValenceElectronCount(atom);
            int hsupp = atom.getImplicitHydrogenCount();
            double deltav = (double) (zv - hsupp) / (double) (z - zv - 1);
            prod = prod * deltav;
        }
        if (prod != 0)
            sum += 1.0 / Math.sqrt(prod);
    }
    return sum;
}",evalValenceIndex,org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,"/**
     * Evaluates the valence corrected chi index for a set of fragments.
     * 
     * This method takes into account the S and P atom types described in
     * Kier & Hall (1986), page 20 for which empirical delta V values are used.
     *
     * @param atomContainer The target <code>AtomContainer</code>
     * @param fragList      A list of fragments
     * @return The valence corrected chi index
     * @throws CDKException if the <code>IsotopeFactory</code> cannot be created
     */",122-178,"('evalValenceIndex', {'INSTRUCTION': {'covered': 113, 'missed': 20}, 'BRANCH': {'covered': 12, 'missed': 2}, 'LINE': {'covered': 28, 'missed': 4}, 'COMPLEXITY': {'covered': 6, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",279.0,12.0,Evaluates the valence corrected chi index for a set of fragments.,"For a group of fragments, this method determines the valence corrected chi index.  The S and P atom types mentioned in Kier & Hall (1986), page 20, for which empirical delta V values are utilized, are taken into consideration by this method.",Evaluates the chi index for a set of fragments.,0.141464324381515,Evaluates the valence-corrected chi index for a set of fragments.
931,matsim-libs,"public boolean put(final double x, final double y, final T value){
    if (!this.top.bounds.containsOrEquals(x, y)) {
        throw new IllegalArgumentException(""cannot add a point at x="" + x + "", y="" + y + "" with bounds "" + this.top.bounds);
    }
    if (this.top.put(x, y, value)) {
        incrementSize();
        return true;
    }
    return false;
}",put,org/matsim/core/utils/collections/QuadTree.java,/matsim/src/main/java/org/matsim/core/utils/collections/QuadTree.java,"/**
         * Associates the specified value with the specified coordinates in this
         * QuadTree.
         *
         * @param x x-coordinate where the specified value is to be associated.
         * @param y y-coordinate where the specified value is to be associated.
         * @param value value to be associated with the specified coordinates.
         *
         * @return true if insertion was successful and the data structure changed,
         *         false otherwise.
         */",75-95,"('put', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,12.0,Associates the specified value with the specified coordinates in this  QuadTree.,"In this QuadTree, a connection is made between the supplied value and the specified coordinates. ",The QuadTree has specified coordinates.,0.299165802015411,Associates the specified value with the coordinates specified in this QuadTree.
932,cdk,"public Object clone() throws CloneNotSupportedException{
    Mapping clone = (Mapping) super.clone();
    if (relation != null) {
        clone.relation = new IChemObject[relation.length];
        for (int f = 0; f < relation.length; f++) {
            if (relation[f] != null) {
                clone.relation[f] = (IChemObject) relation[f].clone();
            }
        }
    }
    return clone;
}",clone,org/openscience/cdk/silent/Mapping.java,/base/silent/src/main/java/org/openscience/cdk/silent/Mapping.java,"/**
     * Clones this <code>Mapping</code> and the mapped <code>IChemObject</code>s.
     *
     * @return  The cloned object
     */",118-136,"('clone', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,21.0,Clones this <code>Mapping</code> and the mapped <code>IChemObject</code>s.,Copies both this mapping and the IChemObjects it contains. ,This is a clone of the mapped code>IChemObject/code>s.,0.796903573317898,Clone this <code>mapping</code> and the mapped <code>IChemObjects</code>.
933,tablesaw,"private void withMissingLeftJoin(Table destination, Table table1, Selection table1Rows, Set<Integer> ignoreColumns, boolean keepTable2JoinKeyColumns){
    for (int c = 0; c < destination.columnCount(); c++) {
        if (!keepTable2JoinKeyColumns && ignoreColumns.contains(c)) {
            continue;
        }
        if (c < table1.columnCount()) {
            Column t1Col = table1.column(c);
            for (int index : table1Rows) {
                destination.column(c).append(t1Col, index);
            }
        } else {
            for (int r1 = 0; r1 < table1Rows.size(); r1++) {
                destination.column(c).appendMissing();
            }
        }
    }
}",withMissingLeftJoin,tech/tablesaw/joining/DataFrameJoiner.java,/core/src/main/java/tech/tablesaw/joining/DataFrameJoiner.java,"/**
   * Adds rows to destination for each row in table1 with the columns from table2 added as missing
   * values.
   */",875-901,"('withMissingLeftJoin', {'INSTRUCTION': {'covered': 58, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",139.0,19.0,Adds rows to destination for each row in table1 with the columns from table2 added as missing  values.,"Every row in table 1 will have additional rows added to the destination, with the columns from table 2 being used to fill in any gaps.",Adding rows to destination for each row in table1 and columns to table2 adds missing values.,0.615075144398616,Adds destination rows for each row in table1 with the columns in table2 added as missing values.
934,dataverse,"public boolean isLockedFor(DatasetLock.Reason reason){
    for (DatasetLock l : getLocks()) {
        if (l.getReason() == reason) {
            return true;
        }
    }
    return false;
}",isLockedFor,edu/harvard/iq/dataverse/Dataset.java,/src/main/java/edu/harvard/iq/dataverse/Dataset.java,"/**
     * Checks whether {@code this} dataset is locked for a given reason.
     * @param reason the reason we test for.
     * @return {@code true} iff the data set is locked for {@code reason}.
     */",164-176,"('isLockedFor', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,15.0,Checks whether {@code this} dataset is locked for a given reason.,Determines if this dataset is locked for the specified reason. ,Does a check to see if the dataset is locked for a reason.,1.46130920833579,Checks whether the dataset {@code this} is locked for a given reason.
935,cdk,"public Object clone() throws CloneNotSupportedException{
    SingleElectron clone = (SingleElectron) super.clone();
    if (atom != null) {
        clone.atom = (IAtom) ((IAtom) atom).clone();
    }
    return clone;
}",clone,org/openscience/cdk/SingleElectron.java,/base/data/src/main/java/org/openscience/cdk/SingleElectron.java,"/**
     * Clones this SingleElectron object, including a clone of the atom for which the
     * SingleElectron is defined.
     *
     * @return    The cloned object
     */",143-157,"('clone', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",50.0,18.0,"Clones this SingleElectron object, including a clone of the atom for which the  SingleElectron is defined.","Copies this SingleElectron object, including a copy of the atom for which it is defined.","The SingleElectron object is cloned, along with the atom for which it is defined.",0.827882426759804,"Clone this SingleElectron object, including a clone of the atom for which the SingleElectron is defined."
936,cdk,"protected static double deltavSulphur(IAtom atom, IAtomContainer atomContainer){
    if (atom.getAtomicNumber() != IElement.S)
        return -1;
    List<IAtom> connected = atomContainer.getConnectedAtomsList(atom);
    for (IAtom connectedAtom : connected) {
        if (connectedAtom.getAtomicNumber() == IElement.S && atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.SINGLE)
            return .89;
    }
    int count = 0;
    for (IAtom connectedAtom : connected) {
        if (connectedAtom.getAtomicNumber() == IElement.O && atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.DOUBLE)
            count++;
    }
    if (count == 1)
        return 1.33;
    else if (count == 2)
        return 2.67;
    return -1;
}",deltavSulphur,org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,"/**
     * Evaluates the empirical delt V for some S environments.
     * 
     * The method checks to see whether a S atom is in a -S-S-,
     * -SO-, -SO2- group and returns the empirical values noted
     * in Kier & Hall (1986), page 20.
     *
     * @param atom          The S atom in question
     * @param atomContainer The molecule containing the S
     * @return The empirical delta V if it is present in one of the above
     *         environments, -1 otherwise
     */",185-217,"('deltavSulphur', {'INSTRUCTION': {'covered': 63, 'missed': 11}, 'BRANCH': {'covered': 13, 'missed': 5}, 'LINE': {'covered': 14, 'missed': 1}, 'COMPLEXITY': {'covered': 6, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",156.0,10.0,Evaluates the empirical delt V for some S environments.,"The empirical delt V for some S settings is evaluated.  The approach returns the empirical values mentioned in Kier & Hall (1986), page 20, and determines if a S atom is a member of a -S-S-, -SO-, or -SO2- group.",Evaluates the empirical delt V for S environments.,0.403647046060232,Evaluates empirical delt V for selected S environments.
937,weblogic-kubernetes-operator,"public boolean isLocalAdminProtocolChannelSecure(){
    boolean adminProtocolPortSecure = false;
    boolean adminProtocolPortFound = false;
    if (networkAccessPoints != null) {
        for (NetworkAccessPoint nap : networkAccessPoints) {
            if (nap.isAdminProtocol()) {
                adminProtocolPortFound = true;
                adminProtocolPortSecure = true;
                break;
            }
        }
    }
    if (!adminProtocolPortFound) {
        if (adminPort != null) {
            adminProtocolPortSecure = true;
        } else if (sslListenPort != null) {
            adminProtocolPortSecure = true;
        } else if (listenPort != null) {
            adminProtocolPortSecure = false;
        }
    }
    return adminProtocolPortSecure;
}",isLocalAdminProtocolChannelSecure,oracle/kubernetes/operator/wlsconfig/WlsServerConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsServerConfig.java,"/**
   * Check if the admin protocol channel is using a secure protocol like T3S or HTTPS.
   * @return true is a secure protocol is being used
   */",383-409,"('isLocalAdminProtocolChannelSecure', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 13, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",102.0,16.0,Check if the admin protocol channel is using a secure protocol like T3S or HTTPS.,"Verify whether the admin protocol channel is employing a secure protocol, such as HTTPS or T3S.","If the admin protocol channel uses a secure protocol, you should check it.",0.112277984682776,Check if the administration protocol channel uses a secure protocol such as T3S or HTTPS.
938,dcache,"public void addChild(BulkJob job){
    Preconditions.checkArgument(job.getParentKey().getRequestId().equals(job.getKey().getRequestId()), ""Job completion listener is "" + ""being shared between two "" + ""different requests! "" + ""This is a bug."");
    synchronized (descendants) {
        Long parentId = job.getParentKey().getJobId();
        Long childId = job.getKey().getJobId();
        descendants.put(parentId, childId);
        LOGGER.trace(""addChild: parent {}, child {}; descendants {}."", parentId, childId, descendants.size());
    }
}",addChild,org/dcache/services/bulk/handlers/BulkJobCompletionHandler.java,/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/handlers/BulkJobCompletionHandler.java,"/**
     * When a job is submitted, it adds itself as the child of a parent job.  When it terminates, it
     * removes itself from the parent list.  The multimap implementation automatically removes the
     * parent key from the table when its child collection is empty.
     * <p>
     * Breadth-first directories do not remove themselves from the map until all their children are
     * registered.
     * <p>
     * Depth-first directories wait for their immediate children to terminate.  Subdirectories of
     * the root expansion node do not add themselves as children, since the expansion is done by
     * recursion rather than exec'ing a new job (as in breadth-first).
     */",107-134,"('addChild', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",103.0,17.0,"When a job is submitted, it adds itself as the child of a parent job.","A job inserts itself as a child of a parent job when it is submitted. It eliminates itself from the parent list when it ends. When the child collection of a multimap implementation is empty, the parent key is automatically deleted from the table.  Breadth-first directories wait until all of their offspring have registered before removing themselves from the map.   Depth-first directories watch for the termination of their immediate children. Since the expansion is performed through recursion rather than by executing a new job, subdirectories of the root expansion node do not add themselves as children (as in breadth-first). ","When a job is submitted, it becomes the child of a parent job.",0.218577652547556,"When a task is submitted, it is added as a child of a parent task."
939,egeria,"private String createPort(String userId, Port port, String entityTpeName, String processGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    final String methodName = ""createPort"";
    validatePortParameters(userId, port.getQualifiedName(), port.getDisplayName(), methodName);
    invalidParameterHandler.validateGUID(processGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    String externalSourceGUID = registrationHandler.getExternalDataEngine(userId, externalSourceName);
    return portHandler.createPort(userId, externalSourceGUID, externalSourceName, processGUID, PROCESS_GUID_PARAMETER_NAME, port.getQualifiedName(), port.getDisplayName(), port.getPortType().getOrdinal(), port.getAdditionalProperties(), entityTpeName, null, methodName);
}",createPort,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,"/**
     * Create the port and attach it to the process.
     *
     * @param userId             the name of the calling user
     * @param port               the port values
     * @param entityTpeName      the type name
     * @param externalSourceName the unique name of the external source
     * @param processGUID        the unique identifier of the process containing the port
     *
     * @return unique identifier of the port in the repository
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",157-183,"('createPort', {'INSTRUCTION': {'covered': 43, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",127.0,10.0,Create the port and attach it to the process.,"Creates the given port, then associates it to the given process, given its unique identifier. It returns the unique identifier of the port in the repository. ",Attach the port to the process.,0.590499991565058,Create the port and attach it to the process.
940,logstash-logback-encoder,"private NodeWriter<Event> parseNode(JsonPointer location, JsonNode node) throws JsonPatternException{
    if (node.isTextual()) {
        try {
            ValueGetter<Event, ?> getter = makeComputableValueGetter(node.asText());
            return new ValueWriter<>(getter);
        } catch (RuntimeException e) {
            String msg = ""Invalid JSON property '"" + location + ""' (was '"" + node.asText() + ""'): "" + e.getMessage();
            throw new JsonPatternException(msg, e);
        }
    }
    if (node.isArray()) {
        return parseArray(location, (ArrayNode) node);
    }
    if (node.isObject()) {
        return parseObject(location, (ObjectNode) node);
    }
    return new ValueWriter<>(g -> node);
}",parseNode,net/logstash/logback/pattern/AbstractJsonPatternParser.java,/src/main/java/net/logstash/logback/pattern/AbstractJsonPatternParser.java,"/**
     * Parse a {@link JsonNode} and produce the corresponding {@link NodeWriter}.
     * 
     * @param node the {@link JsonNode} to parse.
     * @return a {@link NodeWriter} corresponding to the given JSON node
     * @throws JsonPatternException denotes an invalid pattern
     */",307-333,"('parseNode', {'INSTRUCTION': {'covered': 63, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",148.0,17.0,Parse a {@link JsonNode} and produce the corresponding {@link NodeWriter}.,Create the corresponding NodeWriter by parsing a JsonNode. ,Parse a @link JsonNode and then produce the corresponding @link NodeWriter.,1.10049863697193,Analyze a {JsonNode} @link and produce the corresponding {@link NodeWriter}.
941,matsim-libs," static SumoNetworkHandler read(File file) throws ParserConfigurationException, SAXException, IOException{
    SAXParserFactory factory = SAXParserFactory.newInstance();
    SAXParser saxParser = factory.newSAXParser();
    SumoNetworkHandler sumoHandler = new SumoNetworkHandler();
    saxParser.parse(file, sumoHandler);
    return sumoHandler;
}",read,org/matsim/contrib/sumo/SumoNetworkHandler.java,/contribs/sumo/src/main/java/org/matsim/contrib/sumo/SumoNetworkHandler.java,"/**
     * Creates a new sumo handler by reading data from xml file.
     */",78-87,"('read', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,12.0,Creates a new sumo handler by reading data from xml file.,Reads information from an xml file to create a new sumo handler. ,A new sumo handler is created by reading data.,0.533066407682523,Creates a sumo handler by reading the data in the xml file.
942,weblogic-kubernetes-operator,"public static Collection<String> parseNamespaceList(String namespaceString){
    Collection<String> namespaces = Stream.of(namespaceString.split("","")).filter(s -> !isNullOrEmpty(s)).map(String::trim).collect(Collectors.toUnmodifiableList());
    return namespaces.isEmpty() ? Collections.singletonList(getOperatorNamespace()) : namespaces;
}",parseNamespaceList,oracle/kubernetes/operator/helpers/NamespaceHelper.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/NamespaceHelper.java,"/**
   * Parse a string of namespace names and return them as a collection.
   * @param namespaceString a comma-separated list of namespace names
   * @return Namespace list
   */",36-49,"('parseNamespaceList', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",76.0,13.0,Parse a string of namespace names and return them as a collection.,Identifies namespace names in the given string and it returns them,Return a string of names as a collection.,0.738350184684208,Parse a string of namespace names and return them as a collection.
943,jeromq,"public Object[] recvBinaryPicture(Socket socket, final String picture){
    if (!BINARY_FORMAT.matcher(picture).matches()) {
        throw new ZMQException(picture + "" is not in expected binary format "" + BINARY_FORMAT.pattern(), ZError.EPROTO);
    }
    ZFrame frame = ZFrame.recvFrame(socket);
    if (frame == null) {
        return null;
    }
    ZNeedle needle = new ZNeedle(frame);
    Object[] results = new Object[picture.length()];
    for (int index = 0; index < picture.length(); index++) {
        char pattern = picture.charAt(index);
        switch(pattern) {
            case '1':
                {
                    results[index] = needle.getNumber1();
                    break;
                }
            case '2':
                {
                    results[index] = needle.getNumber2();
                    break;
                }
            case '4':
                {
                    results[index] = needle.getNumber4();
                    break;
                }
            case '8':
                {
                    results[index] = needle.getNumber8();
                    break;
                }
            case 's':
                {
                    results[index] = needle.getString();
                    break;
                }
            case 'S':
                {
                    results[index] = needle.getLongString();
                    break;
                }
            case 'b':
            case 'c':
                {
                    int size = needle.getNumber4();
                    results[index] = needle.getBlock(size);
                    break;
                }
            case 'f':
                {
                    results[index] = ZFrame.recvFrame(socket);
                    break;
                }
            case 'm':
                {
                    results[index] = ZMsg.recvMsg(socket);
                    break;
                }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    return results;
}",recvBinaryPicture,org/zeromq/proto/ZPicture.java,/src/main/java/org/zeromq/proto/ZPicture.java,"/**
     * Receive a binary encoded 'picture' message from the socket (or actor).
     * This method is similar to {@link org.zeromq.ZMQ.Socket#recv()}, except the arguments are encoded
     * in a binary format that is compatible with zproto, and is designed to
     * reduce memory allocations.
     *
     * @param picture The picture argument is a string that defines
     *                the type of each argument. See {@link #sendBinaryPicture(Socket, String, Object...)}
     *                for the supported argument types.
     * @return the picture elements as object array
     **/",171-245,"('recvBinaryPicture', {'INSTRUCTION': {'covered': 113, 'missed': 18}, 'BRANCH': {'covered': 14, 'missed': 4}, 'LINE': {'covered': 29, 'missed': 2}, 'COMPLEXITY': {'covered': 11, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",324.0,15.0,Receive a binary encoded 'picture' message from the socket (or actor).,"Obtain a ""image"" message in binary from the socket (or actor).  This approach resembles org.zeromq.ZMQ.Socket#recv(), but is intended to use less memory because the arguments are encoded in a binary format that is compatible with zproto. ",Receive a picture message from the actor.,0.129101639715445,Receive a binary encoded 'image' message from the socket (or actor).
944,tablesaw," Column<T> last(final int numRows){
    int newRowCount = Math.min(numRows, size());
    return inRange(size() - newRowCount, size());
}",last,tech/tablesaw/columns/Column.java,/core/src/main/java/tech/tablesaw/columns/Column.java,/** Returns a column of the same type containing the last {@code numRows} of this column. */,660-664,"('last', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,19.0,Returns a column of the same type containing the last {@code numRows} of this column.,returns a column of the same type that contains this column's final numRows rows. ,The last @code numRows of this column is returned.,0.708129896546577,Returns a column of the same type containing the last {@code numRows} in that column.
945,acs-aem-commons,"private void replaceInObject(JsonNode node, Map<String, Object> contentVariableReplacements){
    Iterator<String> fieldNames = node.fieldNames();
    while (fieldNames.hasNext()) {
        String name = fieldNames.next();
        JsonNode nodeValue = node.get(name);
        if (nodeValue.isContainerNode()) {
            replaceInElements(nodeValue, contentVariableReplacements);
        } else if (nodeValue.isTextual()) {
            String current = nodeValue.asText();
            String replaced = replaceInString(current, contentVariableReplacements);
            if (!StringUtils.equals(current, replaced)) {
                ((ObjectNode) node).put(name, replaced);
            }
        }
    }
}",replaceInObject,com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,/bundle/src/main/java/com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,"/**
     * Iterates over keys to replace any placeholders in the values.
     *
     * @param node Object node
     * @param contentVariableReplacements current map of content variables
     */",196-217,"('replaceInObject', {'INSTRUCTION': {'covered': 45, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",133.0,11.0,Iterates over keys to replace any placeholders in the values.,Replaces any placeholders in the values by iterating across the keys. ,Iterates over keys to replace the values.,2.08847534306106,Be on keys to replace placeholders in values.
946,cdk,"protected static List<IAtomContainer> splitMolecule(IAtomContainer atomContainer, IBond bond){
    List<IAtomContainer> ret = new ArrayList<IAtomContainer>();
    for (IAtom atom : bond.atoms()) {
        // later on we'll want to make sure that the fragment doesn't contain
        // the bond joining the current atom and the atom that is on the other side
        IAtom excludedAtom;
        if (atom.equals(bond.getBegin()))
            excludedAtom = bond.getEnd();
        else
            excludedAtom = bond.getBegin();
        List<IBond> part = new ArrayList<IBond>();
        part.add(bond);
        part = traverse(atomContainer, atom, part);
        // at this point we have a partion which contains the bond we
        // split. This partition should actually 2 partitions:
        // - one with the splitting bond
        // - one without the splitting bond
        // note that this will lead to repeated fragments when we  do this
        // with adjacent bonds, so when we gather all the fragments we need
        // to check for repeats
        IAtomContainer partContainer;
        partContainer = makeAtomContainer(atom, part, excludedAtom);
        // by checking for more than 2 atoms, we exclude single bond fragments
        // also if a fragment has the same number of atoms as the parent molecule,
        // it is the parent molecule, so we exclude it.
        if (partContainer.getAtomCount() > 2 && partContainer.getAtomCount() != atomContainer.getAtomCount())
            ret.add(partContainer);
        part.remove(0);
        partContainer = makeAtomContainer(atom, part, excludedAtom);
        if (partContainer.getAtomCount() > 2 && partContainer.getAtomCount() != atomContainer.getAtomCount())
            ret.add(partContainer);
    }
    return ret;
}",splitMolecule,org/openscience/cdk/fragment/FragmentUtils.java,/tool/fragment/src/main/java/org/openscience/cdk/fragment/FragmentUtils.java,"/**
     * Non destructively split a molecule into two parts at the specified bond.
     *
     * Note that if a ring bond is specified, the resultant list will contain
     * teh opened ring twice.
     *
     * @param atomContainer The molecule to split
     * @param bond The bond to split at
     * @return A list containing the two parts of the molecule
     */",44-93,"('splitMolecule', {'INSTRUCTION': {'covered': 83, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",201.0,13.0,Non destructively split a molecule into two parts at the specified bond.,"At the designated bond, nondestructively divide a molecule into two pieces.   It should be noted that the opened ring will appear twice in the resultant list if a ring bond is supplied. ",A molecule is split into two parts.,0.24225738585216,Non-destructively divide a molecule into two parts at the specified bond.
947,cdk,"private static List<List<CDKRMap>> makeAtomsMapOfBondsMapSingleBond(List<CDKRMap> list, IAtomContainer sourceGraph, IAtomContainer targetGraph){
    if (list == null) {
        return null;
    }
    Map<IBond, IBond> bondMap = new HashMap<IBond, IBond>(list.size());
    for (CDKRMap solBondMap : list) {
        int id1 = solBondMap.getId1();
        int id2 = solBondMap.getId2();
        IBond qBond = sourceGraph.getBond(id1);
        IBond tBond = targetGraph.getBond(id2);
        bondMap.put(qBond, tBond);
    }
    List<CDKRMap> result1 = new ArrayList<CDKRMap>();
    List<CDKRMap> result2 = new ArrayList<CDKRMap>();
    for (IBond qbond : sourceGraph.bonds()) {
        if (bondMap.containsKey(qbond)) {
            IBond tbond = bondMap.get(qbond);
            CDKRMap map00 = null;
            CDKRMap map01 = null;
            CDKRMap map10 = null;
            CDKRMap map11 = null;
            if ((qbond.getBegin().getSymbol().equals(tbond.getBegin().getSymbol())) && (qbond.getEnd().getSymbol().equals(tbond.getEnd().getSymbol()))) {
                map00 = new CDKRMap(sourceGraph.indexOf(qbond.getBegin()), targetGraph.indexOf(tbond.getBegin()));
                map11 = new CDKRMap(sourceGraph.indexOf(qbond.getEnd()), targetGraph.indexOf(tbond.getEnd()));
                if (!result1.contains(map00)) {
                    result1.add(map00);
                }
                if (!result1.contains(map11)) {
                    result1.add(map11);
                }
            }
            if ((qbond.getBegin().getSymbol().equals(tbond.getEnd().getSymbol())) && (qbond.getEnd().getSymbol().equals(tbond.getBegin().getSymbol()))) {
                map01 = new CDKRMap(sourceGraph.indexOf(qbond.getBegin()), targetGraph.indexOf(tbond.getEnd()));
                map10 = new CDKRMap(sourceGraph.indexOf(qbond.getEnd()), targetGraph.indexOf(tbond.getBegin()));
                if (!result2.contains(map01)) {
                    result2.add(map01);
                }
                if (!result2.contains(map10)) {
                    result2.add(map10);
                }
            }
        }
    }
    List<List<CDKRMap>> result = new ArrayList<List<CDKRMap>>();
    if (result1.size() == result2.size()) {
        result.add(result1);
        result.add(result2);
    } else if (result1.size() > result2.size()) {
        result.add(result1);
    } else {
        result.add(result2);
    }
    return result;
}",makeAtomsMapOfBondsMapSingleBond,org/openscience/cdk/smsd/algorithm/rgraph/CDKRMapHandler.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKRMapHandler.java,"/**
     *  This makes atom map of matching atoms out of atom map of matching bonds as produced by the get(Subgraph|Ismorphism)Map methods.
     *  Added by Asad since CDK one doesn't pick up the correct changes
     * @param  list   The list produced by the getMap method.
     * @param  sourceGraph  first molecule. Must not be an IQueryAtomContainer.
     * @param  targetGraph  second molecule. May be an IQueryAtomContainer.
     * @return     The mapping found projected on sourceGraph. This is atom List of CDKRMap objects containing Ids of matching atoms.
     */",398-467,"('makeAtomsMapOfBondsMapSingleBond', {'INSTRUCTION': {'covered': 207, 'missed': 16}, 'BRANCH': {'covered': 16, 'missed': 12}, 'LINE': {'covered': 44, 'missed': 4}, 'COMPLEXITY': {'covered': 4, 'missed': 11}, 'METHOD': {'covered': 1, 'missed': 0}})",580.0,25.0,This makes atom map of matching atoms out of atom map of matching bonds as produced by the get(Subgraph|Ismorphism)Map methods.,"By using the get(Subgraph|Ismorphism)Map methods, this method creates an atom map of matching atoms from an atom map of matching bonds.  Asad added it because CDK One doesn't detect the proper changes. ",The get(Subgraph)IsmorphismMap methods make atom map of matching atoms out of atom map of matching bonds.,0.982019504526801,This makes the map of the atoms of corresponding atoms from the atom map of the corresponding bonds as produced by the get(Subgraph| Ismorphism)Cartographic methods.
948,liquibase,"public boolean generateStatementsVolatile(SqlStatement statement, Database database){
    for (SqlGenerator generator : getGenerators(statement, database)) {
        if (generator.generateStatementsIsVolatile(database)) {
            return true;
        }
    }
    return false;
}",generateStatementsVolatile,liquibase/sqlgenerator/SqlGeneratorFactory.java,/liquibase-core/src/main/java/liquibase/sqlgenerator/SqlGeneratorFactory.java,"/**
     * Return true if the SqlStatement class queries the database in any way to determine Statements to execute.
     * If the statement queries the database, it cannot be used in updateSql type operations
     */",223-234,"('generateStatementsVolatile', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",43.0,18.0,Return true if the SqlStatement class queries the database in any way to determine Statements to execute.,"If the SqlStatement class makes any kind of database query to select which Statements to execute, this method returns true.  The statement cannot be used for updateSql type actions if it queries the database. ","If the SqlStatement class queries the database to determine statements to execute, return true.",0.910369825771863,Return true if the SqlStatement class queries the database in any way to determine which statements to execute.
950,cdk,"public boolean isOK(IAtomContainer m) throws CDKException{
    // OK, we take advantage here from the fact that this class does not take
    // into account rings larger than 7 atoms. See fixAromaticBondOrders().
    IRingSet rs = allRingsFinder.findAllRings(m, 7);
    storeRingSystem(m, rs);
    boolean StructureOK = this.isStructureOK(m);
    IRingSet irs = this.removeExtraRings(m);
    if (irs == null)
        throw new CDKException(""error in AllRingsFinder.findAllRings"");
    int count = this.getBadCount(m, irs);
    return StructureOK && count == 0;
}",isOK,org/openscience/cdk/smiles/DeduceBondSystemTool.java,/legacy/src/main/java/org/openscience/cdk/smiles/DeduceBondSystemTool.java,"/**
     * Determines if, according to the algorithms implemented in this class, the given
     * AtomContainer has properly distributed double bonds.
     *
     * @param  m {@link IAtomContainer} to check the bond orders for.
     * @return true, if bond orders are properly distributed
     * @throws CDKException thrown when something went wrong
     */",95-116,"('isOK', {'INSTRUCTION': {'covered': 32, 'missed': 6}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",82.0,21.0,"Determines if, according to the algorithms implemented in this class, the given  AtomContainer has properly distributed double bonds.",Checks to see if the given AtomContainer contains evenly distributed double bonds according to the algorithms used in this class. ,"The given AtomContainer has properly distributed double bonds, if the method is implemented in this class.",0.560601552920656,"Determines whether, based on the algorithms implemented in this class, the given AtomContainer correctly distributed the double bindings."
951,liquibase,"public PrimaryKey addColumn(int position, Column column){
    if (position >= getColumns().size()) {
        for (int i = getColumns().size() - 1; i < position; i++) {
            this.getColumns().add(null);
        }
    }
    this.getColumns().set(position, column);
    return this;
}",addColumn,liquibase/structure/core/PrimaryKey.java,/liquibase-core/src/main/java/liquibase/structure/core/PrimaryKey.java,"/**
     * Adds a new column to the column list of this PrimaryKey. The first column has the position 0.
     * If you specify a position that is greater than the number of columns present, undefined
     * columns (NULL expressions) will be added as padding. If a position that is already
     * occupied by a column is specified, that column will be replaced.
     *
     * @param position the position where to insert or replace the column
     * @param column   the new column
     * @return a reference to the updated PrimaryKey object.
     */",69-87,"('addColumn', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,12.0,Adds a new column to the column list of this PrimaryKey.,Adds a new column to this PrimaryKey's list of columns. Position 0 is present in the first column. Undefined columns (NULL expressions) will be inserted as padding if the position you give exceeds the number of columns already present. A column will be replaced if a position that it now occupies is specified.,A new column is added to the PrimaryKey.,0.572069577823675,Adds a new column to the list of columns for this primary key.
952,tablesaw,"public static String repeat(final String str, final int repeat){
    if (str == null) {
        return null;
    }
    if (repeat <= 0) {
        return EMPTY;
    }
    final int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
        return str;
    }
    if (inputLength == 1 && repeat <= PAD_LIMIT) {
        return repeat(str.charAt(0), repeat);
    }
    final int outputLength = inputLength * repeat;
    switch(inputLength) {
        case 1:
            return repeat(str.charAt(0), repeat);
        case 2:
            final char ch0 = str.charAt(0);
            final char ch1 = str.charAt(1);
            final char[] output2 = new char[outputLength];
            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                output2[i] = ch0;
                output2[i + 1] = ch1;
            }
            return new String(output2);
        default:
            final StringBuilder buf = new StringBuilder(outputLength);
            for (int i = 0; i < repeat; i++) {
                buf.append(str);
            }
            return buf.toString();
    }
}",repeat,tech/tablesaw/util/StringUtils.java,/core/src/main/java/tech/tablesaw/util/StringUtils.java,"/**
   * Repeat a String {@code repeat} times to form a new String.
   *
   * <pre>
   * StringUtils.repeat(null, 2) = null
   * StringUtils.repeat("""", 0)   = """"
   * StringUtils.repeat("""", 2)   = """"
   * StringUtils.repeat(""a"", 3)  = ""aaa""
   * StringUtils.repeat(""ab"", 2) = ""abab""
   * StringUtils.repeat(""a"", -2) = """"
   * </pre>
   *
   * @param str the String to repeat, may be null
   * @param repeat number of times to repeat str, negative treated as zero
   * @return a new String consisting of the original String repeated, {@code null} if null String
   *     input
   */",200-254,"('repeat', {'INSTRUCTION': {'covered': 22, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",242.0,15.0,Repeat a String {@code repeat} times to form a new String.,Creates a new String by repeating a given String repeat several times. ,A new String can be formed by repeating a string @code repeat times.,1.20258873442126,Repeat a string {@code repeat} times to form a new string.
953,matsim-libs,"public Path calcLeastCostPath(final Node fromNode, final Node toNode, final double startTime, final Person person2, final Vehicle vehicle2){
    checkNodeBelongToNetwork(fromNode);
    checkNodeBelongToNetwork(toNode);
    augmentIterationId();
    this.person = person2;
    this.vehicle = vehicle2;
    if (this.pruneDeadEnds) {
        this.deadEndEntryNode = getPreProcessData(toNode).getDeadEndEntryNode();
    }
    RouterPriorityQueue<Node> pendingNodes = (RouterPriorityQueue<Node>) createRouterPriorityQueue();
    initFromNode(fromNode, toNode, startTime, pendingNodes);
    Node foundToNode = searchLogic(fromNode, toNode, pendingNodes);
    if (foundToNode == null)
        return null;
    else {
        DijkstraNodeData outData = getData(foundToNode);
        double arrivalTime = outData.getTime();
        return constructPath(fromNode, foundToNode, startTime, arrivalTime);
    }
}",calcLeastCostPath,org/matsim/core/router/Dijkstra.java,/matsim/src/main/java/org/matsim/core/router/Dijkstra.java,"/**
         * Calculates the cheapest route from Node 'fromNode' to Node 'toNode' at
         * starting time 'startTime'.
         *
         * @param fromNode
         *            The Node at which the route should start.
         * @param toNode
         *            The Node at which the route should end.
         * @param startTime
         *            The time at which the route should start.
         * @see org.matsim.core.router.util.LeastCostPathCalculator#calcLeastCostPath(org.matsim.api.core.v01.network.Node, org.matsim.api.core.v01.network.Node, double, org.matsim.api.core.v01.population.Person, org.matsim.vehicles.Vehicle)
         */",198-244,"('calcLeastCostPath', {'INSTRUCTION': {'covered': 56, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",153.0,18.0,Calculates the cheapest route from Node 'fromNode' to Node 'toNode' at  starting time 'startTime'.,Finds the shortest path between Nodes 'fromNode' and 'toNode' at the specified start time. ,The cheapest route from the beginning to the end is 'fromNode' to 'toNode'.,0.520737728612463,Calculates the cheapest route from the 'fromNode' node to the 'toNode' node at the 'startTime' departure time.
954,cdk,"public StereoEncoder create(IAtomContainer container, int[][] graph){
    List<StereoEncoder> encoders = new ArrayList<StereoEncoder>(5);
    for (IBond bond : container.bonds()) {
        // if double bond and not E or Z query bond
        if (DOUBLE.equals(bond.getOrder()) && !E_OR_Z.equals(bond.getStereo())) {
            IAtom left = bond.getBegin();
            IAtom right = bond.getEnd();
            // skip -N=N- double bonds which exhibit inversion
            if (Integer.valueOf(7).equals(left.getAtomicNumber()) && Integer.valueOf(7).equals(right.getAtomicNumber()))
                continue;
            StereoEncoder encoder = newEncoder(container, left, right, right, left, graph);
            if (encoder != null) {
                encoders.add(encoder);
            }
        }
    }
    return encoders.isEmpty() ? StereoEncoder.EMPTY : new MultiStereoEncoder(encoders);
}",create,org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,"/**
     * Create a stereo encoder for all potential 2D and 3D double bond stereo
     * configurations.
     *
     * @param container an atom container
     * @param graph     adjacency list representation of the container
     * @return a new encoder for tetrahedral elements
     */",58-92,"('create', {'INSTRUCTION': {'covered': 63, 'missed': 7}, 'BRANCH': {'covered': 10, 'missed': 4}, 'LINE': {'covered': 11, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",175.0,15.0,Create a stereo encoder for all potential 2D and 3D double bond stereo  configurations.,"For each possible 2D and 3D double bond stereo configuration, create a stereo encoder.",A stereo Encoder is needed for all double bond stereo configurations.,0.50970645988885,Create a stereo encoder for all potential dual-link 2D and 3D stereo configurations.
955,dataverse,"public String asString(){
    if (protocol == null || authority == null || identifier == null) {
        return """";
    }
    return protocol + "":"" + authority + ""/"" + identifier;
}",asString,edu/harvard/iq/dataverse/GlobalId.java,/src/main/java/edu/harvard/iq/dataverse/GlobalId.java,"/**
     * Returns {@code this}' string representation. Differs from {@link #toString}
     * which can also contain debug data, if needed.
     * 
     * @return The string representation of this global id.
     */",110-121,"('asString', {'INSTRUCTION': {'covered': 17, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,10.0,Returns {@code this}' string representation.,"Returns a string representation of this. It differs from toString, which, if necessary, can also contain debug data. ",The string representation is returned.,0.387611331798701,Returns the representation as a string {@code this}'.
956,cdk,"private List<List<Integer>> assignRingGroups(List<Integer[]> rBondsArray){
    List<List<Integer>> ringGroups;
    ringGroups = new ArrayList<List<Integer>>();
    for (int i = 0; i < rBondsArray.size() - 1; i++) {
        for (int j = 0; j < rBondsArray.get(i).length; j++) {
            for (int k = i + 1; k < rBondsArray.size(); k++) {
                for (int l = 0; l < rBondsArray.get(k).length; l++) {
                    if (Objects.equals(rBondsArray.get(i)[j], rBondsArray.get(k)[l])) {
                        if (i != k) {
                            ringGroups.add(new ArrayList<Integer>());
                            ringGroups.get(ringGroups.size() - 1).add(i);
                            ringGroups.get(ringGroups.size() - 1).add(k);
                        }
                    }
                }
            }
        }
    }
    while (combineGroups(ringGroups)) ;
    for (int i = 0; i < rBondsArray.size(); i++) {
        boolean found = false;
        for (int j = 0; j < ringGroups.size(); j++) {
            if (ringGroups.get(j).contains(i)) {
                found = true;
                break;
            }
        }
        if (!found) {
            ringGroups.add(new ArrayList<Integer>());
            ringGroups.get(ringGroups.size() - 1).add(i);
        }
    }
    return ringGroups;
}",assignRingGroups,org/openscience/cdk/smiles/FixBondOrdersTool.java,/legacy/src/main/java/org/openscience/cdk/smiles/FixBondOrdersTool.java,"/**
     * Assigns a set of rings to groups each sharing a bond.
     *
     * @param rBondsArray
     * @return A List of Lists each containing the ring indices of a set of fused rings
     */",285-330,"('assignRingGroups', {'INSTRUCTION': {'covered': 145, 'missed': 2}, 'BRANCH': {'covered': 20, 'missed': 2}, 'LINE': {'covered': 21, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",334.0,12.0,Assigns a set of rings to groups each sharing a bond.,Gives to each group a link a set of rings.,A set of rings is given to groups.,0.176721640836169,Assigns a set of rings to groups that each share a link.
958,cdk," static HydrogenPosition usingDefaultPlacement(final IAtom atom){
    if (PREFIXED_H.contains(Elements.ofNumber(atom.getAtomicNumber())))
        return Left;
    return Right;
}",usingDefaultPlacement,org/openscience/cdk/renderer/generators/standard/HydrogenPosition.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/HydrogenPosition.java,"/**
     * Access the default position of the hydrogen label when the atom has no
     * bonds.
     *
     * @param atom hydrogens will be labelled
     * @return the position
     */",269-279,"('usingDefaultPlacement', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,15.0,Access the default position of the hydrogen label when the atom has no  bonds.,"When the atom has no bonds, this method accesses the hydrogen label's default position. ",The hydrogen label has a default position when the atom has no bonds.,0.472448249795105,Go to the default position of the hydrogen label when the atom has no bonds.
959,weblogic-kubernetes-operator,"static WlsServerConfig create(Map<String, Object> serverConfigMap){
    // parse the configured network access points or channels
    Map networkAccessPointsMap = (Map<String, Object>) serverConfigMap.get(""networkAccessPoints"");
    List<NetworkAccessPoint> networkAccessPoints = new ArrayList<>();
    if (networkAccessPointsMap != null) {
        List<Map<String, Object>> networkAccessPointItems = (List<Map<String, Object>>) networkAccessPointsMap.get(""items"");
        if (networkAccessPointItems != null && networkAccessPointItems.size() > 0) {
            for (Map<String, Object> networkAccessPointConfigMap : networkAccessPointItems) {
                NetworkAccessPoint networkAccessPoint = new NetworkAccessPoint(networkAccessPointConfigMap);
                networkAccessPoints.add(networkAccessPoint);
            }
        }
    }
    // parse the SSL configuration
    Map<String, Object> sslMap = (Map<String, Object>) serverConfigMap.get(""SSL"");
    Integer sslListenPort = (sslMap == null) ? null : (Integer) sslMap.get(""listenPort"");
    boolean sslPortEnabled = sslMap != null && sslMap.get(""listenPort"") != null;
    // parse the administration port
    return new WlsServerConfig((String) serverConfigMap.get(""name""), (String) serverConfigMap.get(""listenAddress""), getMachineNameFromJsonMap(serverConfigMap), (Integer) serverConfigMap.get(""listenPort""), sslListenPort, (Integer) serverConfigMap.get(""adminPort""), networkAccessPoints);
}",create,oracle/kubernetes/operator/wlsconfig/WlsServerConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsServerConfig.java,"/**
   * Creates a WLSServerConfig object using an ""servers"" or ""serverTemplates"" item parsed from JSON
   * result from WLS REST call.
   *
   * @param serverConfigMap A Map containing the parsed ""servers"" or ""serverTemplates"" element for a
   *     WLS server or WLS server template.
   * @return A new WlsServerConfig object using the provided configuration from the configuration
   *     map
   */",71-111,"('create', {'INSTRUCTION': {'covered': 89, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 2}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",242.0,23.0,"Creates a WLSServerConfig object using an ""servers"" or ""serverTemplates"" item parsed from JSON  result from WLS REST call.","Uses a ""servers"" or ""serverTemplates"" item parsed from the JSON response of the WLS REST call to create a WLSServerConfig object. ","The item that is created is a serverconfig object and is created using a ""servers"" or ""serverTemplates"" item.",1.64504311636287,"Creates a WLSServerConfig object using a ""servers"" or ""serverTemplates"" element that is scanned from the JSON result of the WLS REST call."
960,weblogic-kubernetes-operator,"public static SchemaGenerator createCrdSchemaGenerator(){
    SchemaGenerator generator = new SchemaGenerator();
    generator.defineAdditionalProperties(Quantity.class, ""string"");
    generator.setForbidAdditionalProperties(false);
    generator.setSupportObjectReferences(false);
    generator.setIncludeSchemaReference(false);
    generator.addPackageToSuppressDescriptions(""io.kubernetes.client.openapi.models"");
    generator.defineEnabledFeatures(Optional.ofNullable(TuningParameters.getInstance()).map(TuningParameters::getFeatureGates).map(TuningParameters.FeatureGates::getEnabledFeatures).orElse(Collections.emptyList()));
    return generator;
}",createCrdSchemaGenerator,oracle/kubernetes/weblogic/domain/model/CrdSchemaGenerator.java,/operator/src/main/java/oracle/kubernetes/weblogic/domain/model/CrdSchemaGenerator.java,"/**
   * Creates a schema generator, suitably customized for generating Kubernetes CRD schemas.
   */",15-31,"('createCrdSchemaGenerator', {'INSTRUCTION': {'covered': 33, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",99.0,13.0,"Creates a schema generator, suitably customized for generating Kubernetes CRD schemas.",Creates a schema generator that is specifically tailored to produce Kubernetes CRD schemas. ,A custom-made generator is created for generating Kubernetes CRD schemas.,0.950001974546631,"Creates a schema builder, customized appropriately to generate Kubernetes CRD schemas."
961,logstash-logback-encoder,"private static int findParamEndIndex(String paramsString, int startIndex){
    int nestLevel = 0;
    for (int c = startIndex; c < paramsString.length(); c++) {
        char character = paramsString.charAt(c);
        if (character == PARAM_START_CHAR) {
            nestLevel++;
        } else if (character == PARAM_END_CHAR) {
            nestLevel--;
            if (nestLevel < 0) {
                throw new IllegalArgumentException(String.format(""Unbalanced '}' at character position %d in %s"", c, paramsString));
            }
        } else if (character == PARAM_SEPARATOR_CHAR && nestLevel == 0) {
            return c;
        }
    }
    if (nestLevel != 0) {
        throw new IllegalArgumentException(String.format(""Unbalanced '{' in %s"", paramsString));
    }
    return paramsString.length();
}",findParamEndIndex,net/logstash/logback/appender/WaitStrategyFactory.java,/src/main/java/net/logstash/logback/appender/WaitStrategyFactory.java,"/**
     * Finds the end character index of the parameter within the paramsString that starts at startIndex.
     *
     * Takes into account nesting of parameters.
     *
     * @param paramsString
     * @param startIndex index within paramsString to start looking
     * @return index at which the parameter string ends (e.g. the next comma, or paramsString length if no comma found)
     *
     * @throws IllegalArgumentException if the parameter is not well formed
     */",192-222,"('findParamEndIndex', {'INSTRUCTION': {'covered': 66, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",140.0,16.0,Finds the end character index of the parameter within the paramsString that starts at startIndex.,"Identifies the parameter's final character index within the paramsString, which begins at startIndex. Considers the nesting of parameters. ",The end character index of the parameter is found by looking at the startIndex.,0.283611829702436,Looks for the end character index of the parameter in the ParamsString that starts at startIndex.
962,cdk,"public static String[] generateOrderEle(){
    return new String[] { ""C"", ""H"", ""O"", ""N"", ""Si"", ""P"", ""S"", ""F"", ""Cl"", ""Br"", ""I"", ""Sn"", ""B"", ""Pb"", ""Tl"", ""Ba"", ""In"", ""Pd"", ""Pt"", ""Os"", ""Ag"", ""Zr"", ""Se"", ""Zn"", ""Cu"", ""Ni"", ""Co"", ""Fe"", ""Cr"", ""Ti"", ""Ca"", ""K"", ""Al"", ""Mg"", ""Na"", ""Ce"", ""Hg"", ""Au"", ""Ir"", ""Re"", ""W"", ""Ta"", ""Hf"", ""Lu"", ""Yb"", ""Tm"", ""Er"", ""Ho"", ""Dy"", ""Tb"", ""Gd"", ""Eu"", ""Sm"", ""Pm"", ""Nd"", ""Pr"", ""La"", ""Cs"", ""Xe"", ""Te"", ""Sb"", ""Cd"", ""Rh"", ""Ru"", ""Tc"", ""Mo"", ""Nb"", ""Y"", ""Sr"", ""Rb"", ""Kr"", ""As"", ""Ge"", ""Ga"", ""Mn"", ""V"", ""Sc"", ""Ar"", ""Ne"", ""He"", ""Be"", ""Li"", ""Bi"", ""Po"", ""At"", ""Rn"", ""Fr"", ""Ra"", ""Ac"", ""Th"", ""Pa"", ""U"", ""Np"", ""Pu"", ""Am"", ""Cm"", ""Bk"", ""Cf"", ""Es"", ""Fm"", ""Md"", ""No"", ""Lr"", ""Rf"", ""Db"", ""Sg"", ""Bh"", ""Hs"", ""Mt"", ""Ds"", ""Rg"", ""Cn"", ""R"" };
}",generateOrderEle,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * Returns the Elements ordered according to (approximate) probability of occurrence.
     *
     * <p>This begins with the ""elements of life"" C, H, O, N, (Si, P, S, F, Cl),
     * then continues with the ""common"" chemical synthesis ingredients, closing off
     * with the tail-end of the periodic table in atom-number order and finally
     * the generic R-group.
     *
     * @return  fixed-order array
     *
     */",1183-1214,"('generateOrderEle', {'INSTRUCTION': {'covered': 455, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",243.0,13.0,Returns the Elements ordered according to (approximate) probability of occurrence.,"Returns the Elements arranged in order of (approximate) likelihood of occurrence. The ""elements of life"" C, H, O, N, (Si, P, S, F, Cl), followed by the ""common"" chemical synthesis ingredients, the tail end of the periodic table in atom-number order, and lastly the generic R-group, make up the first section of this. ",The Elements are ordered according to the probability of occurrence.,0.164178117445616,Returns items ordered based on the (approximate) probability of occurrence.
963,cdk,"public static Bayesian deserialise(String str) throws IOException{
    BufferedReader rdr = new BufferedReader(new StringReader(str));
    Bayesian model = deserialise(rdr);
    rdr.close();
    return model;
}",deserialise,org/openscience/cdk/fingerprint/model/Bayesian.java,/tool/model/src/main/java/org/openscience/cdk/fingerprint/model/Bayesian.java,"/**
     * Converts a given string into a Bayesian model instance, or throws an exception if it is not valid.
     * 
     * @param str string containing the serialised model
     * @return instantiated model that can be used for predictions
     */",530-541,"('deserialise', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",42.0,20.0,"Converts a given string into a Bayesian model instance, or throws an exception if it is not valid.","Creates a Bayesian model instance from a specified string, or raises an error if the string is invalid. ","If the string is not valid, it can be converted into a model instance.",0.661809302039093,Converts a given string to a Bayesian model instance or throws an exception if it is invalid.
964,logstash-logback-encoder,"protected boolean recycleInstance(T instance){
    if (instance instanceof Lifecycle) {
        return ((Lifecycle) instance).recycle();
    } else {
        return true;
    }
}",recycleInstance,net/logstash/logback/util/ThreadLocalHolder.java,/src/main/java/net/logstash/logback/util/ThreadLocalHolder.java,"/**
     * Recycle the instance before returning it to the pool.
     * Sub-classes may override this method if they wish to implement their own custom logic.
     * 
     * @param instance the instance to recycle
     * @return {@code true} if the instance can be recycled and returned to the pool, {@code false} if not.
     */",247-260,"('recycleInstance', {'INSTRUCTION': {'covered': 7, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,10.0,Recycle the instance before returning it to the pool.,"Before putting the instance back in the pool, recycle it. If a subclass wants to add their own custom logic, they can override this function. ","Before returning the instance to the pool, recycle it.",1.33180019615599,Recycle the instance before returning it to the pool.
965,tablesaw,"private void renameDuplicateColumnHeaders(String[] headerNames){
    Map<String, Integer> nameCounter = new HashMap<>();
    for (int i = 0; i < headerNames.length; i++) {
        String name = headerNames[i];
        Integer count = nameCounter.get(name);
        if (count == null) {
            nameCounter.put(name, 1);
        } else {
            count++;
            nameCounter.put(name, count);
            headerNames[i] = name + ""-"" + count;
        }
    }
}",renameDuplicateColumnHeaders,tech/tablesaw/io/FileReader.java,/core/src/main/java/tech/tablesaw/io/FileReader.java,"/**
   * Renames any column header that appears more than once. Subsequent appearances have ""-[count]""
   * appended; For example, the first (or only) appearance of ""foo"" is named ""foo"", the second
   * appearance is named ""foo-2"" The header array is modified in place.
   *
   * @param headerNames The header names to be potentially adjusted.
   */",133-153,"('renameDuplicateColumnHeaders', {'INSTRUCTION': {'covered': 61, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,10.0,Renames any column header that appears more than once.,"Any column header that appears more than once is given a new name. The suffix ""-[count]"" is applied to subsequent appearances; for instance, ""foo"" is named ""foo"" for its first (or sole) appearance, and ""foo-2"" for its second. The header array is changed on the fly.",Rename any column that appears more than once.,0.65289809014547,Renames any column header that appears multiple times.
966,cdk,"public void partitionPartners(IAtom atom, IAtomContainer unplacedPartners, IAtomContainer placedPartners){
    List atoms = molecule.getConnectedAtomsList(atom);
    for (int i = 0; i < atoms.size(); i++) {
        IAtom curatom = (IAtom) atoms.get(i);
        if (curatom.getFlag(CDKConstants.ISPLACED)) {
            placedPartners.addAtom(curatom);
        } else {
            unplacedPartners.addAtom(curatom);
        }
    }
}",partitionPartners,org/openscience/cdk/layout/AtomPlacer.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/AtomPlacer.java,"/**
     *  Partition the bonding partners of a given atom into placed (coordinates
     *  assinged) and not placed.
     *
     *@param  atom              The atom whose bonding partners are to be
     *      partitioned
     *@param  unplacedPartners  A vector for the unplaced bonding partners to go in
     *@param  placedPartners    A vector for the placed bonding partners to go in
     */",542-561,"('partitionPartners', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,18.0,Partition the bonding partners of a given atom into placed (coordinates  assinged) and not placed.,Divide the bonding partners of a specific atom among those that are put (coordinates assigned) and those that are not. ,The bonding partners of a given atom should be placed and not placed.,0.775809300864485,Partition the bond partners of a given atom into placed (associated coordinates) and non-placed.
967,cdk,"public static IDifference construct(String name, Point3d first, Point3d second){
    if (first == null && second == null)
        return null;
    Point3dDifference totalDiff = new Point3dDifference(name);
    totalDiff.addChild(DoubleDifference.construct(""x"", first == null ? null : first.x, second == null ? null : second.x));
    totalDiff.addChild(DoubleDifference.construct(""y"", first == null ? null : first.y, second == null ? null : second.y));
    totalDiff.addChild(DoubleDifference.construct(""z"", first == null ? null : first.z, second == null ? null : second.z));
    if (totalDiff.childCount() == 0) {
        return null;
    }
    return totalDiff;
}",construct,org/openscience/cdk/tools/diff/tree/Point3dDifference.java,/misc/diff/src/main/java/org/openscience/cdk/tools/diff/tree/Point3dDifference.java,"/**
     * Constructs a new {@link IDifference} object.
     *
     * @param name   a name reflecting the nature of the created {@link IDifference}
     * @param first  the first object to compare
     * @param second the second object to compare
     * @return       an {@link IDifference} reflecting the differences between the first and second object
     */",39-61,"('construct', {'INSTRUCTION': {'covered': 72, 'missed': 0}, 'BRANCH': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",152.0,10.0,Constructs a new {@link IDifference} object.,"Creates a new IDifference object, given its name and the two objects to compare.",A new object is created.,0.305586218041028,Constructs a new {@link IDifference} object.
968,matsim-libs,"static AfterLinkCreated adjustFreespeed(final double factor){
    return (link, osmTags, direction) -> {
        if (osmTags.containsKey(OsmTags.MAXSPEED)) {
            if (link.getFreespeed() < 51 / 3.6)
                link.setFreespeed(link.getFreespeed() * factor);
        }
    };
}",adjustFreespeed,org/matsim/contrib/osm/networkReader/SupersonicOsmNetworkReader.java,/contribs/osm/src/main/java/org/matsim/contrib/osm/networkReader/SupersonicOsmNetworkReader.java,"/**
     * Creates a function to adjust the freespeed for urban links.
     * @see LinkProperties#DEFAULT_FREESPEED_FACTOR
     *
     * @apiNote Can be used as example, but no public access currently
     */",64-77,"('adjustFreespeed', {'INSTRUCTION': {'covered': 3, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,11.0,Creates a function to adjust the freespeed for urban links.,A function is created to change the freespeed for urban links. ,The function adjusts the freespeed for urban links.,0.181377000437248,Creates a function to adjust the free speed for urban connections.
969,cdk,"public String toString(){
    StringBuffer resultString = new StringBuffer();
    resultString.append(""LonePair("");
    resultString.append(this.hashCode());
    if (atom != null) {
        resultString.append("", "").append(atom.toString());
    }
    resultString.append(')');
    return resultString.toString();
}",toString,org/openscience/cdk/silent/LonePair.java,/base/silent/src/main/java/org/openscience/cdk/silent/LonePair.java,"/**
     * Returns a one line string representation of this LonePair.
     * This method is conform RFC #9.
     *
     * @return    The string representation of this LonePair
     */",133-149,"('toString', {'INSTRUCTION': {'covered': 23, 'missed': 8}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",71.0,10.0,Returns a one line string representation of this LonePair.,This LonePair is represented by a single line of text in the response. This technique complies with RFC #9.,A one line string representation of this Lone Pair is returned.,0.299933043231155,Returns a string representation of a row of this LonePair.
970,logstash-logback-encoder,"public NodeWriter<Event> parse(String pattern) throws JsonPatternException{
    if (StringUtils.isEmpty(pattern)) {
        return null;
    }
    final ObjectNode node;
    try (JsonParser jsonParser = jsonFactory.createParser(pattern)) {
        node = JsonReadingUtils.readFullyAsObjectNode(jsonFactory, pattern);
    } catch (IOException e) {
        throw new JsonPatternException(""pattern is not a valid JSON object"", e);
    }
    NodeWriter<Event> nodeWriter = new RootWriter<>(parseObject(JsonPointer.compile(""/""), node));
    if (omitEmptyFields) {
        nodeWriter = new OmitEmptyFieldWriter<>(nodeWriter);
    }
    return nodeWriter;
}",parse,net/logstash/logback/pattern/AbstractJsonPatternParser.java,/src/main/java/net/logstash/logback/pattern/AbstractJsonPatternParser.java,"/**
     * Parse a JSON pattern and produce the corresponding {@link NodeWriter}.
     * Returns <em>null</em> if the pattern is invalid, null or empty. An error status is
     * logged when the pattern is invalid and parsing failed.
     * 
     * @param pattern the JSON pattern to parse
     * @return a {@link NodeWriter} configured according to the pattern
     * @throws JsonPatternException denotes an invalid pattern
     */",279-305,"('parse', {'INSTRUCTION': {'covered': 40, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",116.0,14.0,Parse a JSON pattern and produce the corresponding {@link NodeWriter}.,"Create the appropriate NodeWriter by parsing a JSON pattern. If the pattern is incorrect, empty, or null, it returns null. When the pattern is invalid and parsing fails, an error status is recorded. ",Parse a pattern and then send it to the link.,0.485211359461548,Analyze a JSON template and produce the corresponding {nodewriter @link}.
971,glowstone,"public void putList(@NonNls String key, TagType type, List<V> value, Function<? super V, ? extends Tag> tagCreator){
    List<Tag> result = new ArrayList<>(value.size());
    for (V item : value) {
        result.add(tagCreator.apply(item));
    }
    put(key, new ListTag<>(type, result));
}",putList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Adds or replaces a list subtag, converting the list entries to tags.
     *
     * @param <V> the list elements' Java type
     * @param key the key to write to
     * @param type the list elements' tag type
     * @param value the list contents, as objects to convert to tags
     * @param tagCreator a function that will convert each V to an element tag
     */",925-941,"('putList', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",86.0,14.0,"Adds or replaces a list subtag, converting the list entries to tags.",Converts the list entries into tags by adding or removing a list subtag. ,Adding or replacing a list subtag converts the list entries to tags.,0.253062237448111,"Adds or replaces a list subtag, converting list entries to tags."
972,cdk,"private StereoBond findStereoBond(IAtom atom){
    for (IBond bond : stereoBonds) if (bond.contains(atom))
        return (StereoBond) bond;
    return null;
}",findStereoBond,org/openscience/cdk/smiles/smarts/parser/SmartsQueryVisitor.java,/legacy/src/main/java/org/openscience/cdk/smiles/smarts/parser/SmartsQueryVisitor.java,"/**
     * Locate a stereo bond adjacent to the {@code atom}.
     *
     * @param atom an atom
     * @return a stereo bond or null if non found
     */",339-349,"('findStereoBond', {'INSTRUCTION': {'covered': 21, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,13.0,Locate a stereo bond adjacent to the {@code atom}.,Find a stereo bond that is close to the atom. ,There is a stereo bond next to the @code atom.,0.840962581487483,Locate a stereo link adjacent to the atom {@code}.
973,acs-aem-commons,"protected boolean accepts(SlingHttpServletRequest request){
    if (!StringUtils.equalsIgnoreCase(POST_METHOD, request.getMethod())) {
        return false;
    } else if (!DAM_FOLDER_SHARE_OPERATION.equals(request.getParameter(OPERATION))) {
        return false;
    } else if (!StringUtils.startsWith(request.getResource().getPath(), DAM_PATH_PREFIX)) {
        return false;
    } else if (!request.getResource().isResourceType(JcrResourceConstants.NT_SLING_FOLDER) && !request.getResource().isResourceType(JcrResourceConstants.NT_SLING_ORDERED_FOLDER)) {
        return false;
    }
    return true;
}",accepts,com/adobe/acs/commons/dam/impl/AssetsFolderPropertiesSupport.java,/bundle/src/main/java/com/adobe/acs/commons/dam/impl/AssetsFolderPropertiesSupport.java,"/**
     * Gateway method the Filter uses to determine if the request is a candidate for processing by Assets Folder Properties Support.
     * These checks should be fast and fail broadest and fastest first.
     *
     * @param request the request
     * @return true if Assets Folder Properties Support should process this request.
     */",148-174,"('accepts', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",116.0,21.0,Gateway method the Filter uses to determine if the request is a candidate for processing by Assets Folder Properties Support.,This is a gateway method that the Filter employs a to decide whether or not the request qualifies for processing by the Assets Folder Properties Support. These tests ought to be quick and fail the broadest and quickest first.,The Filter uses a gateway method to determine if the request is a candidate for processing.,0.206820285415467,The gateway method used by the filter to determine whether the request is likely to be processed by supporting the properties of the Assets folder.
974,cdk,"public String generate(int[] atomIdxs){
    if (atomIdxs == null)
        throw new NullPointerException(""No atom indexes provided"");
    if (atomIdxs.length == 0)
        return null;
    if (atomIdxs.length == 1 && mode == MODE_EXACT)
        return aexpr[atomIdxs[0]];
    Arrays.fill(rbnds, 0);
    Arrays.fill(avisit, 0);
    for (int atmIdx : atomIdxs) avisit[atmIdx] = -1;
    numVisit = 1;
    for (int atomIdx : atomIdxs) {
        if (avisit[atomIdx] < 0)
            markRings(atomIdx, -1);
    }
    numVisit = 1;
    for (int atmIdx : atomIdxs) avisit[atmIdx] = -1;
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < atomIdxs.length; i++) {
        if (avisit[atomIdxs[i]] < 0) {
            if (i > 0)
                sb.append('.');
            encodeExpr(atomIdxs[i], -1, sb);
        }
    }
    return sb.toString();
}",generate,org/openscience/cdk/smarts/SmartsFragmentExtractor.java,/tool/smarts/src/main/java/org/openscience/cdk/smarts/SmartsFragmentExtractor.java,"/**
     * Generate a SMARTS for the substructure formed of the provided
     * atoms.
     *
     * @param atomIdxs atom indexes
     * @return SMARTS, null if an empty array is passed
     */",189-235,"('generate', {'INSTRUCTION': {'covered': 132, 'missed': 11}, 'BRANCH': {'covered': 19, 'missed': 3}, 'LINE': {'covered': 21, 'missed': 2}, 'COMPLEXITY': {'covered': 9, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",211.0,12.0,Generate a SMARTS for the substructure formed of the provided  atoms.,Create a SMARTS for the substructure built with the atoms you've provided. ,The provided atoms have a substructure.,0.19161171849055,Generate a SMARTS for the substructure formed by the supplied atoms.
976,cdk,"public void add(IRingSet ringSet){
    for (int f = 0; f < ringSet.getAtomContainerCount(); f++) {
        if (!contains(ringSet.getAtomContainer(f))) {
            addAtomContainer(ringSet.getAtomContainer(f));
        }
    }
}",add,org/openscience/cdk/silent/RingSet.java,/base/silent/src/main/java/org/openscience/cdk/silent/RingSet.java,"/**
     * Adds all rings of another RingSet if they are not already part of this ring set.
     *
     * If you want to add a single ring to the set use {@link #addAtomContainer(org.openscience.cdk.interfaces.IAtomContainer)}
     *
     * @param   ringSet  the ring set to be united with this one.
     */",120-134,"('add', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,17.0,Adds all rings of another RingSet if they are not already part of this ring set.,"If they are not already a part of this ring set, adds all rings from another RingSet.  Use #addAtomContainer(org.openscience.cdk.interfaces.IAtomContainer) to add a single ring to the set","If they are not part of the ring set, add all of them.",0.228937688416791,Adds all rings from another RingSet if they are not already part of that ring set.
978,dcache,"private void becomeMortal(long lifetime){
    _whenIShouldExpire = new Date(System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(lifetime));
}",becomeMortal,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,"/**
     * Initialise our expiry time to some point in the future.
     *
     * @param lifetime the time, in seconds.
     */",202-210,"('becomeMortal', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,11.0,Initialise our expiry time to some point in the future.,Set our expiration period as far in the future as possible. ,We should initialise our time to the future.,0.326143655612421,Initialize our expiration time at some point in the future.
979,tablesaw,"public Iterator<Row> iterator(){
    return new Iterator<Row>() {

        private final Row row = new Row(TableSlice.this);

        @Override
        public Row next() {
            return row.next();
        }

        @Override
        public boolean hasNext() {
            return row.hasNext();
        }
    };
}",iterator,tech/tablesaw/table/TableSlice.java,/core/src/main/java/tech/tablesaw/table/TableSlice.java,"/**
   * Iterate over the underlying rows in the source table. If you set one of the rows while
   * iterating it will change the row in the source table.
   */",224-245,"('iterator', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,10.0,Iterate over the underlying rows in the source table.,Go through the source table's underlying rows iteratively. The row in the source table will change if one of the rows is set during iterating. ,Over the underlying rows in the source table.,0.129867450211606,Iterate over the underlying rows in the source table.
980,tablesaw,"public static String capitalize(final String str){
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    final int firstCodepoint = str.codePointAt(0);
    final int newCodePoint = Character.toTitleCase(firstCodepoint);
    if (firstCodepoint == newCodePoint) {
        return str;
    }
    final int[] newCodePoints = new int[strLen];
    int outOffset = 0;
    newCodePoints[outOffset++] = newCodePoint;
    for (int inOffset = Character.charCount(firstCodepoint); inOffset < strLen; ) {
        final int codepoint = str.codePointAt(inOffset);
        newCodePoints[outOffset++] = codepoint;
        inOffset += Character.charCount(codepoint);
    }
    return new String(newCodePoints, 0, outOffset);
}",capitalize,tech/tablesaw/util/StringUtils.java,/core/src/main/java/tech/tablesaw/util/StringUtils.java,"/**
   * Capitalizes a String changing the first character to title case as per {@link
   * Character#toTitleCase(int)}. No other characters are changed.
   *
   * <p>A {@code null} input String returns {@code null}.
   *
   * <pre>
   * StringUtils.capitalize(null)  = null
   * StringUtils.capitalize("""")    = """"
   * StringUtils.capitalize(""cat"") = ""Cat""
   * StringUtils.capitalize(""cAt"") = ""CAt""
   * StringUtils.capitalize(""'cat'"") = ""'cat'""
   * </pre>
   *
   * @param str the String to capitalize, may be null
   * @return the capitalized String, {@code null} if null String input
   * @since 2.0
   */",301-341,"('capitalize', {'INSTRUCTION': {'covered': 55, 'missed': 4}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 13, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",153.0,23.0,Capitalizes a String changing the first character to title case as per {@link  Character#toTitleCase(int)}.,Capitalizes a String changing the first character to title case as per Character#toTitleCase(int). No other characters are changed.  A null input String returns null.,The capitalizes a string changing the first character to the title case.,0.272532820587144,Caps a string by replacing the first character with the title case according to {@link Character#toTitleCase(int)}.
981,cdk,"private Rectangle2D transformedBounds(Shape shape){
    Rectangle2D rectangle2D = shape.getBounds2D();
    Point2D minPoint = new Point2D.Double(rectangle2D.getMinX(), rectangle2D.getMinY());
    Point2D maxPoint = new Point2D.Double(rectangle2D.getMaxX(), rectangle2D.getMaxY());
    transform.transform(minPoint, minPoint);
    transform.transform(maxPoint, maxPoint);
    double minX = Math.min(minPoint.getX(), maxPoint.getX());
    double maxX = Math.max(minPoint.getX(), maxPoint.getX());
    double minY = Math.min(minPoint.getY(), maxPoint.getY());
    double maxY = Math.max(minPoint.getY(), maxPoint.getY());
    return new Rectangle2D.Double(minX, minY, maxX - minX, maxY - minY);
}",transformedBounds,org/openscience/cdk/renderer/generators/standard/TextOutline.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/TextOutline.java,"/**
     * Access the bounds of a shape that have been transformed.
     *
     * @param shape any shape
     * @return the bounds of the shape transformed
     */",135-156,"('transformedBounds', {'INSTRUCTION': {'covered': 67, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",177.0,11.0,Access the bounds of a shape that have been transformed.,Access the boundaries of a modified shape. ,The bounds of a shape have been changed.,0.207072108029742,Navigate to the boundaries of a shape that have been transformed.
982,jackson-databind,"protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException{
    final SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);
    final DefaultSerializerProvider context = _serializerProvider(config);
    TokenBuffer buf = context.bufferForValueConversion(this);
    if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
        buf = buf.forceUseOfBigDecimal(true);
    }
    try {
        context.serializeValue(buf, fromValue);
        final JsonParser p = buf.asParser();
        Object result;
        final DeserializationConfig deserConfig = getDeserializationConfig();
        JsonToken t = _initForReading(p, toValueType);
        if (t == JsonToken.VALUE_NULL) {
            DeserializationContext ctxt = createDeserializationContext(p, deserConfig);
            result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);
        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
            result = null;
        } else {
            DeserializationContext ctxt = createDeserializationContext(p, deserConfig);
            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);
            result = deser.deserialize(p, ctxt);
        }
        p.close();
        return result;
    } catch (IOException e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    }
}",_convert,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Actual conversion implementation: instead of using existing read
     * and write methods, much of code is inlined. Reason for this is
     * that we must avoid root value wrapping/unwrapping both for efficiency and
     * for correctness. If root value wrapping/unwrapping is actually desired,
     * caller must use explicit <code>writeValue</code> and
     * <code>readValue</code> methods.
     */",4347-4395,"('_convert', {'INSTRUCTION': {'covered': 81, 'missed': 7}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 19, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",232.0,19.0,"Actual conversion implementation: instead of using existing read  and write methods, much of code is inlined.",Actual conversion implementation: Much of the code is inlined rather than using the read and write methods that are already in place. This is necessary to prevent root value wrapping and unwrapping for both performance and correctness. Caller must utilize explicit writeValue and readValue methods if root value wrapping or unwrapping is genuinely desired. ,The actual conversion implementation is inlined.,0.334738157034902,"Actual conversion implementation: Instead of using existing read and write methods, much of the code is integrated."
983,cdk,"private static boolean validCorrelation(IMolecularFormula formulaMin, IMolecularFormula formulamax){
    for (IElement element : MolecularFormulaManipulator.elements(formulaMin)) {
        if (!MolecularFormulaManipulator.containsElement(formulamax, element))
            return false;
    }
    return true;
}",validCorrelation,org/openscience/cdk/tools/manipulator/MolecularFormulaSetManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaSetManipulator.java,"/**
     * In the minimal IMolecularFormula must contain all those IElement found in the
     * minimal IMolecularFormula.
     *
     * @param formulaMax  A IMolecularFormula which contains the maximal representation of the Elements
     * @param formulaMin  A IMolecularFormula which contains the minimal representation of the Elements
     * @return            True, if the correlation is valid
     */",150-164,"('validCorrelation', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,15.0,In the minimal IMolecularFormula must contain all those IElement found in the  minimal IMolecularFormula.,All the IElements contained in the minimal IMolecularFormula must be present in the minimal IMolecularFormula. ,The minimal IMolecularFormula must contain all the I Elements.,0.363023957882471,In the minimum IMolecularFormula must contain all the IElement found in the minimum IMolecularFormula.
984,acs-aem-commons," EnumMap<ReportColumns, Object> report(WorkflowRemovalStatus status){
    final EnumMap<ReportColumns, Object> row = new EnumMap<>(ReportColumns.class);
    row.put(ReportColumns.STARTED, status.getStartedAt());
    row.put(ReportColumns.CHECKED, status.getChecked());
    row.put(ReportColumns.REMOVED, status.getRemoved());
    row.put(ReportColumns.COMPLETED, status.getCompletedAt());
    row.put(ReportColumns.ERRED, status.getErredAt());
    row.put(ReportColumns.INITIATED_BY, status.getInitiatedBy());
    return row;
}",report,com/adobe/acs/commons/mcp/impl/processes/WorkflowRemover.java,/bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/WorkflowRemover.java,"/**
     * Collect and return a report row for the workflow status.  Method is package scope for unit tests.
     * @param status the status to report upon.
     * @return the row of data
     */",145-162,"('report', {'INSTRUCTION': {'covered': 45, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",125.0,11.0,Collect and return a report row for the workflow status.,Create and provide a report row that details the workflow state. This method is package scope because of unit tests. ,Return a report row for the status of the workflow.,0.243243600869384,Collect and return a report row for the status of the workflow.
985,jooby,"public static Config defaults(){
    Path tmpdir = Paths.get(System.getProperty(""user.dir""), ""tmp"");
    Map<String, String> defaultMap = new HashMap<>();
    defaultMap.put(""application.tmpdir"", tmpdir.toString());
    defaultMap.put(""application.charset"", ""UTF-8"");
    String pid = pid();
    if (pid != null) {
        System.setProperty(""PID"", pid);
        defaultMap.put(""pid"", pid);
    }
    return ConfigFactory.parseMap(defaultMap, ""defaults"");
}",defaults,io/jooby/Environment.java,/jooby/src/main/java/io/jooby/Environment.java,"/**
   * Creates a default configuration properties with some common values like: application.tmpdir,
   * application.charset and pid (process ID).
   *
   * @return A configuration object.
   */",377-395,"('defaults', {'INSTRUCTION': {'covered': 42, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,13.0,Creates a default configuration properties with some common values like: application.,"A default configuration property is created with several widely used values, such as application.tmpdir, application.charset, and pid (process ID). ",The default configuration properties are: application.,0.657112375791891,Creates default configuration properties with common values such as: application.
986,cdk,"private IRingSet removeExtraRings(IAtomContainer m) throws Exception{
    IRingSet rs = Cycles.sssr(m).toRingSet();
    Iterator<IAtomContainer> i = rs.atomContainers().iterator();
    while (i.hasNext()) {
        IRing r = (IRing) i.next();
        if (r.getAtomCount() > 8) {
            i.remove();
        } else {
            for (IAtom a : r.atoms()) {
                Hybridization h = a.getHybridization();
                if (h == CDKConstants.UNSET || !(h == Hybridization.SP2 || h == Hybridization.PLANAR3)) {
                    i.remove();
                    break;
                }
            }
        }
    }
    return rs;
}",removeExtraRings,org/openscience/cdk/smiles/FixBondOrdersTool.java,/legacy/src/main/java/org/openscience/cdk/smiles/FixBondOrdersTool.java,"/**
     * Removes rings which do not have all sp2/planar3 aromatic atoms.
     * and also gets rid of rings that have more than 8 atoms in them.
     *
     * @param m The {@link IAtomContainer} from which we want to remove rings
     * @return The set of reduced rings
     */",233-261,"('removeExtraRings', {'INSTRUCTION': {'covered': 49, 'missed': 3}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 13, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",142.0,11.0,Removes rings which do not have all sp2/planar3 aromatic atoms.,Removes rings with more than 8 atoms as well as rings that don't include all sp2/planar3 aromatic atoms.,The rings do not have all the aromatic atoms.,0.530830392353091,Removes rings that do not have all the aromatic atoms sp2/planar3.
