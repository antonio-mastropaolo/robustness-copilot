index,project,body,methodName,relativePath,absolutePath,javaDoc,spanMethod,coverage,tokensPerMethod,tokensFirstLine,javaDocFirstSentence,perturbed_eval_1,pegasusPerturbed,pegagusPerturbedEntropy,pivotingPerturbed,generatedResultOriginal,generatedResultEvaluator,generatedResultPegasus,generatedResultPivoting,mvnTestResultOriginal,mvnTestResultEvaluator,mvnTestResultPivoting,mvnTestResultPegasus,CodeBleuOriginal,CodeBleuEvaluator,CodeBleuPivoting,CodeBleuPegasus,levenshteinTarget-Original-Code,levenshteinTarget-Original-Code-Normalized,levenshteinTarget-Evaluator-Code,levenshteinTarget-Evaluator-Code-Normalized,levenshteinTarget-Pivoting-Code,levenshteinTarget-Pivoting-Code-Normalized,levenshteinTarget-Pegasus-Code,levenshteinTarget-Pegasus-Code-Normalized,levenshteinOriginal-Evaluator-Code,levenshteinOriginal-Evaluator-Code-Normalized,levenshteinOriginal-Pivoting-Code,levenshteinOriginal-Pivoting-Code-Normalized,levenshteinOriginal-Pegasus-Code,levenshteinOriginal-Pegasus-Code-Normalized,levenshteinOriginal-Evaluator-JavaDoc,levenshteinOriginal-Evaluator-JavaDoc-Normalized,levenshteinOriginal-Pivoting-JavaDoc,levenshteinOriginal-Pivoting-JavaDoc-Normalized,levenshteinOriginal-Pegasus-JavaDoc,levenshteinOriginal-Pegasus-JavaDoc-Normalized
1,cdk,"static AtomTypePattern[] loadPatterns(InputStream smaIn) throws IOException{
    List<AtomTypePattern> matchers = new ArrayList<AtomTypePattern>();
    BufferedReader br = new BufferedReader(new InputStreamReader(smaIn));
    String line = null;
    while ((line = br.readLine()) != null) {
        if (skipLine(line))
            continue;
        String[] cols = line.split("" "");
        String sma = cols[0];
        String symb = cols[1];
        try {
            matchers.add(new AtomTypePattern(SmartsPattern.create(sma).setPrepare(false), symb));
        } catch (IllegalArgumentException ex) {
            throw new IOException(ex);
        }
    }
    return matchers.toArray(new AtomTypePattern[matchers.size()]);
}",loadPatterns,org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,"/**
     * Internal - load the SMARTS patterns for each atom type from MMFFSYMB.sma.
     *
     * @param smaIn input stream of MMFFSYMB.sma
     * @return array of patterns
     * @throws IOException
     */",215-241,"('loadPatterns', {'INSTRUCTION': {'covered': 62, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",154.0,13.0,Internal - load the SMARTS patterns for each atom type from MMFFSYMB., Internal - for each type of atom from MMFFSYMB.sma loads the SMARTS models.,Load the patterns for each atom type from MMFFSYMB.,0.393088244380532,  Internal - load SMARTS models for each type of atom from MMFFSYMB.,"static AtomTypePattern[] loadPatterns(InputStream smaIn) throws IOException{
        List<AtomTypePattern> patterns = new ArrayList<AtomTypePattern>();
        BufferedReader reader = new BufferedReader(new InputStreamReader(smaIn));
        String line;
        while ((line = reader.readLine()) != null) {
            if (line.startsWith(""#"")) continue;
            String[] tokens = line.split(""\\s+"");
            if (tokens.length != 3) continue;
            patterns.add(new AtomTypePattern(tokens[0], tokens[1], tokens[2]));
        }
        reader.close();
        return patterns.toArray(new AtomTypePattern[patterns.size()]);      
 }","static AtomTypePattern[] loadPatterns(InputStream smaIn) throws IOException{
        List<AtomTypePattern> patterns = new ArrayList<AtomTypePattern>();
        BufferedReader reader = new BufferedReader(new InputStreamReader(smaIn));
        String line;
        while ((line = reader.readLine()) != null) {
            if (line.startsWith(""#"")) continue;
            String[] tokens = line.split(""\\s+"");
            if (tokens.length != 3) continue;
            String symb = tokens[0];
            String smarts = tokens[2];
            patterns.add(new AtomTypePattern(symb, smarts));
        }
        reader.close();
        return patterns.toArray(new AtomTypePattern[patterns.size()]);      
 }","static AtomTypePattern[] loadPatterns(InputStream smaIn) throws IOException{
        final List<AtomTypePattern> patterns = new ArrayList<AtomTypePattern>();
        final BufferedReader reader = new BufferedReader(new InputStreamReader(smaIn));
        String line;
        while ((line = reader.readLine()) != null) {
            if (line.startsWith(""#"")) {
                continue;
            }
            final String[] parts = line.split(""\\s+"");
            if (parts.length != 3) {
                throw new IllegalArgumentException(""Invalid line: "" + line);
            }
            patterns.add(new AtomTypePattern(parts[0], parts[1], parts[2]));
        }
        return patterns.toArray(new AtomTypePattern[patterns.size()]);      
 }","static AtomTypePattern[] loadPatterns(InputStream smaIn) throws IOException{
        List<AtomTypePattern> patterns = new ArrayList<AtomTypePattern>();
        BufferedReader reader = new BufferedReader(new InputStreamReader(smaIn));
        String line;
        while ((line = reader.readLine()) != null) {
            if (line.startsWith(""#"")) continue;
            String[] tokens = line.split(""\\s+"");
            if (tokens.length != 3) continue;
            patterns.add(new AtomTypePattern(tokens[0], tokens[1], tokens[2]));
        }
        return patterns.toArray(new AtomTypePattern[patterns.size()]);      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.48508766906633943,  0.5107152603758844,  0.48278469680624186,  0.47040399412440015,57.0,0.36774193548387096,54.0,0.34838709677419355,58.0,0.3741935483870968,65.0,0.41935483870967744,23.0,0.1597222222222222,6.0,0.04316546762589928,26.0,0.17687074829931973,11.0,0.7857142857142857,5.0,0.38461538461538464,4.0,0.3076923076923077
3,dcache,"private static String toGroupName(String attribute){
    int pos = attribute.indexOf(';');
    if (pos > -1) {
        attribute = attribute.substring(0, pos);
    }
    return attribute.replace(""X"", ""XX"").replace(""."", ""X"");
}",toGroupName,org/dcache/services/billing/text/BillingParserBuilder.java,/modules/dcache/src/main/java/org/dcache/services/billing/text/BillingParserBuilder.java,"/**
     * Translates a attribute name into a name suitable for a named capturing group.
     */",252-261,"('toGroupName', {'INSTRUCTION': {'covered': 15, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",57.0,14.0,Translates a attribute name into a name suitable for a named capturing group.," Given an attribute name as input, it translates an attribute name into a name suitable  for a named capturing group.",A name is translated into a name suitable for a group.,0.0938992682120705,  Translates an attribute name into a name that is appropriate for a named capture group.,"private static String toGroupName(String attribute){
        return attribute.replaceAll(""[^a-zA-Z0-9]"", ""_"");
    }","private static String toGroupName(String attribute){
        return attribute.replaceAll(""[^a-zA-Z0-9]"", ""_"");
    }","private static String toGroupName(String attribute){
        return attribute.replaceAll(""[^a-zA-Z0-9]"", ""_"");
    }","private static String toGroupName(String attribute){
        return attribute.replaceAll(""[^a-zA-Z0-9]"", ""_"");
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.1897859910092181,  0.1897859910092181,  0.1897859910092181,  0.1897859910092181,40.0,0.6896551724137931,40.0,0.6896551724137931,40.0,0.6896551724137931,40.0,0.6896551724137931,0.0,0.0,0.0,0.0,0.0,0.0,9.0,0.42857142857142855,5.0,0.3125,6.0,0.42857142857142855
4,matsim-libs," void revisitNode(final Node n, final DijkstraNodeData data, final RouterPriorityQueue<Node> pendingNodes, final double time, final double cost, final Link outLink){
    pendingNodes.remove(n);
    data.visit(outLink, cost, time, getIterationId());
    pendingNodes.add(n, getPriority(data));
}",revisitNode,org/matsim/pt/router/TransitLeastCostPathTree.java,/matsim/src/main/java/org/matsim/pt/router/TransitLeastCostPathTree.java,"/**
	 * Changes the position of the given Node n in the pendingNodes queue and
	 * updates its time and cost information.
	 *
	 * @param n
	 *            The Node that is revisited.
	 * @param data
	 *            The data for n.
	 * @param pendingNodes
	 *            The nodes visited and not processed yet.
	 * @param time
	 *            The time of the visit of n.
	 * @param cost
	 *            The accumulated cost at the time of the visit of n.
	 * @param outLink
	 *            The link from which we came visiting n.
	 */",482-506,"('revisitNode', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,20.0,Changes the position of the given Node n in the pendingNodes queue and  updates its time and cost information., Updates time and cost information as node node location changes.   The parameter outLink is the link through which we came to visit n.,The given Node n is in the pendingNodes queue and can be changed.,1.1552558115937,  Changes the position of the given node n in the pendingNodes queue and updates its time and cost information.,"  void revisitNode(final Node n, final DijkstraNodeData data, final RouterPriorityQueue<Node> pendingNodes, final double time, final double cost, final Link outLink){
	 data.revisit(outLink, cost, time, getIterationId());
	  pendingNodes.setPriority(n, getPriority(data));			
  }","  void revisitNode(final Node n, final DijkstraNodeData data, final RouterPriorityQueue<Node> pendingNodes, final double time, final double cost, final Link outLink){
	  data.revisit(outLink, cost, time, getIterationId());
	  pendingNodes.add(n, getPriority(data));			
  }","  void revisitNode(final Node n, final DijkstraNodeData data, final RouterPriorityQueue<Node> pendingNodes, final double time, final double cost, final Link outLink){
	  data.revisit(outLink, cost, time, getIterationId());
	  pendingNodes.setPriority(n, getPriority(data));			
  }","  void revisitNode(final Node n, final DijkstraNodeData data, final RouterPriorityQueue<Node> pendingNodes, final double time, final double cost, final Link outLink){
	  data.revisit(outLink, cost, time, getIterationId());
	  pendingNodes.setPriority(n, getPriority(data));			
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8361135378836434,  0.8558788213818532,  0.8361135378836434,  0.8361135378836434,9.0,0.13432835820895522,8.0,0.11940298507462686,9.0,0.13432835820895522,9.0,0.13432835820895522,1.0,0.016666666666666666,0.0,0.0,0.0,0.0,23.0,0.9583333333333334,1.0,0.05,12.0,0.6
5,cdk,"private static int[] insert(int v, int[] vs){
    final int n = vs.length;
    final int[] ws = Arrays.copyOf(vs, n + 1);
    ws[n] = v;
    for (int i = n; i > 0 && ws[i] < ws[i - 1]; i--) {
        int tmp = ws[i];
        ws[i] = ws[i - 1];
        ws[i - 1] = tmp;
    }
    return ws;
}",insert,org/openscience/cdk/smiles/BeamToCDK.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/BeamToCDK.java,"/**
     * Insert the vertex 'v' into sorted position in the array 'vs'.
     *
     * @param v  a vertex (int id)
     * @param vs array of vertices (int ids)
     * @return array with 'u' inserted in sorted order
     */",581-602,"('insert', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",109.0,15.0,Insert the vertex 'v' into sorted position in the array 'vs'., Starting from the array 'vs' insert the vertex 'v' in ordinal position.,The array 'vs' has the 'v' inserted into it.,1.07879688690664,  Insert the vertex 'v' in the sorted position in the 'vs' table.,"private static int[] insert(int v, int[] vs){
        int[] tmp = new int[vs.length + 1];
        int i = 0;
        while (i < vs.length && vs[i] < v) {
            tmp[i] = vs[i];
            i++;
        }
        tmp[i++] = v;
        while (i < vs.length) {
            tmp[i] = vs[i - 1];
            i++;
        }
        return tmp;
    }","private static int[] insert(int v, int[] vs){
        int[] tmp = new int[vs.length + 1];
        int i = 0;
        for (; i < vs.length; i++) {
            if (vs[i] == v) break;
            tmp[i] = vs[i];
        }
        tmp[i] = v;
        for (; i < vs.length; i++) {
            tmp[i + 1] = vs[i];
        }
        return tmp;
    }","private static int[] insert(int v, int[] vs){
        int[] newVs = new int[vs.length + 1];
        System.arraycopy(vs, 0, newVs, 0, v);
        newVs[v] = v;
        System.arraycopy(vs, v, newVs, v + 1, vs.length - v);
        return newVs;
    }","private static int[] insert(int v, int[] vs){
        int[] newVs = new int[vs.length + 1];
        int i = 0;
        while (i < vs.length && vs[i] < v) {
            newVs[i] = vs[i];
            i++;
        }
        newVs[i] = v;
        while (i < vs.length) {
            newVs[i+1] = vs[i];
            i++;
        }
        return newVs;
    }",NOT PASS,NOT PASS,PASS,NOT PASS,  0.4291006566716161,  0.4231852363244657,  0.3946747020325023,  0.33539910490860414,66.0,0.6,69.0,0.6272727272727273,66.0,0.6,74.0,0.6727272727272727,28.0,0.25688073394495414,10.0,0.09615384615384616,56.0,0.5384615384615384,11.0,0.8461538461538461,4.0,0.3076923076923077,11.0,0.9166666666666666
6,acs-aem-commons,"private void createOrUpdateNodesForJsonObject(final ResourceResolver remoteAssetsResolver, final String key, final Resource parentResource) throws IOException, RepositoryException{
    if (PROTECTED_NODES.contains(key)) {
        return;
    }
    String objectPath = String.format(""%s/%s"", parentResource.getPath(), key);
    JsonObject jsonObjectWithChildren = getJsonFromUri(objectPath);
    String resourcePrimaryType = jsonObjectWithChildren.getAsJsonPrimitive(JcrConstants.JCR_PRIMARYTYPE).getAsString();
    Resource resource = getOrCreateNode(remoteAssetsResolver, objectPath, resourcePrimaryType);
    createOrUpdateNodes(remoteAssetsResolver, jsonObjectWithChildren, resource);
    ValueMap resourceProperties = resource.adaptTo(ModifiableValueMap.class);
    if (DamConstants.NT_DAM_ASSET.equals(parentResource.getValueMap().get(JcrConstants.JCR_PRIMARYTYPE, String.class)) && DamConstants.NT_DAM_ASSETCONTENT.equals(resourceProperties.get(JcrConstants.JCR_PRIMARYTYPE, String.class))) {
        resourceProperties.put(RemoteAssets.IS_REMOTE_ASSET, true);
        LOG.trace(""Property '{}' added for resource '{}'."", RemoteAssets.IS_REMOTE_ASSET, resource.getPath());
        this.saveRefreshCount++;
        if (this.saveRefreshCount == this.remoteAssetsConfig.getSaveInterval()) {
            this.saveRefreshCount = 0;
            remoteAssetsResolver.commit();
            remoteAssetsResolver.refresh();
            LOG.info(""Executed incremental save of node sync."");
        }
    }
}",createOrUpdateNodesForJsonObject,com/adobe/acs/commons/remoteassets/impl/RemoteAssetsNodeSyncImpl.java,/bundle/src/main/java/com/adobe/acs/commons/remoteassets/impl/RemoteAssetsNodeSyncImpl.java,"/**
     * Handler for when a JSON element is an Object, representing a resource.
     *
     * @param key String
     * @param parentResource Resource
     * @throws IOException exception
     * @throws RepositoryException exception
     */",208-242,"('createOrUpdateNodesForJsonObject', {'INSTRUCTION': {'covered': 95, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",232.0,14.0,"Handler for when a JSON element is an Object, representing a resource.", Handler used when a resource is represented by an Object that is a JSON element.   ,"When a resource is represented by an object, the handler is needed.",0.19668287806293,"  Handler when a JSON element is an object, representing a resource."," private void createOrUpdateNodesForJsonObject(final ResourceResolver remoteAssetsResolver, final String key, final Resource parentResource) throws IOException, RepositoryException{
        JsonObject jsonObject = jsonObject.getAsJsonObject(key);
        String resourcePrimaryType = jsonObject.getAsJsonPrimitive(JcrConstants.JCR_PRIMARYTYPE).getAsString();
        Resource resource = getOrCreateNode(remoteAssetsResolver, parentResource.getPath() + ""/"" + key, resourcePrimaryType);
        createOrUpdateNodes(remoteAssetsResolver, jsonObject, resource);        
 }"," private void createOrUpdateNodesForJsonObject(final ResourceResolver remoteAssetsResolver, final String key, final Resource parentResource) throws IOException, RepositoryException{
        JsonObject jsonObject = (JsonObject) parentResource.getValueMap().get(key);
        if (jsonObject == null) {
            jsonObject = new JsonObject();
        }
        for (Map.Entry<String, JsonElement> jsonEntry : jsonObject.entrySet()) {
            JsonElement jsonElement = jsonEntry.getValue();
            if (jsonElement.isJsonObject()) {
                createOrUpdateNodesForJsonObject(remoteAssetsResolver, jsonEntry.getKey(), parentResource);
            } else if (jsonElement.isJsonArray()) {
                setNodeArrayProperty(remoteAssetsResolver, jsonEntry.getKey(), jsonElement.getAsJsonArray(), parentResource);
            } else {
                setNodeProperty(remoteAssetsResolver, jsonEntry.getKey(), jsonObject, parentResource);
            }
        }
    }"," private void createOrUpdateNodesForJsonObject(final ResourceResolver remoteAssetsResolver, final String key, final Resource parentResource) throws IOException, RepositoryException{
        JsonObject jsonObject = jsonObject.getAsJsonObject(key);
        String resourcePrimaryType = jsonObject.getAsJsonPrimitive(JcrConstants.JCR_PRIMARYTYPE).getAsString();
        Resource resource = getOrCreateNode(remoteAssetsResolver, parentResource.getPath() + ""/"" + key, resourcePrimaryType);
        createOrUpdateNodes(remoteAssetsResolver, jsonObject, resource);        
 }"," private void createOrUpdateNodesForJsonObject(final ResourceResolver remoteAssetsResolver, final String key, final Resource parentResource) throws IOException, RepositoryException{
        JsonObject jsonObject = jsonObject.getAsJsonObject(key);
        String resourcePrimaryType = jsonObject.getAsJsonPrimitive(JcrConstants.JCR_PRIMARYTYPE).getAsString();
        Resource resource = getOrCreateNode(remoteAssetsResolver, parentResource.getPath() + ""/"" + key, resourcePrimaryType);
        createOrUpdateNodes(remoteAssetsResolver, jsonObject, resource);        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.27287273250614624,  0.2514378914952671,  0.26902657865999235,  0.2651804248138385,169.0,0.7253218884120172,157.0,0.6738197424892703,169.0,0.7253218884120172,169.0,0.7253218884120172,98.0,0.632258064516129,0.0,0.0,0.0,0.0,10.0,0.625,2.0,0.15384615384615385,12.0,0.9230769230769231
7,twilio-java,"public static Workflow fromJson(String json) throws IOException{
    ObjectMapper mapper = new ObjectMapper();
    return mapper.readValue(json, Workflow.class);
}",fromJson,com/twilio/taskrouter/Workflow.java,/src/main/java/com/twilio/taskrouter/Workflow.java,"/**
     * Converts a JSON workflow configuration to a workflow object.
     *
     * @param json JSON for workflow
     * @return a workflow rule target object
     * @throws IOException if unable to create object
     */",55-65,"('fromJson', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,10.0,Converts a JSON workflow configuration to a workflow object.,Converts a JSON workflow configuration to a workflow object.,A configuration is converted to a object.,0.170327249771777,  Converts a JSON workflow configuration to a workflow object.," public static Workflow fromJson(String json) throws IOException{
        ObjectMapper mapper = new ObjectMapper();
        return mapper.readValue(json, Workflow.class);      
 }"," public static Workflow fromJson(String json) throws IOException{
        ObjectMapper mapper = new ObjectMapper();
        return mapper.readValue(json, Workflow.class);      
 }"," public static Workflow fromJson(String json) throws IOException{
        return new ObjectMapper().readValue(json, Workflow.class);      
 }"," public static Workflow fromJson(String json) throws IOException{
        ObjectMapper mapper = new ObjectMapper();
        return mapper.readValue(json, Workflow.class);      
 }",PASS,PASS,PASS,NOT PASS,  1.0,  1.0,  1.0,  0.6102596348817327,0.0,0.0,0.0,0.0,0.0,0.0,6.0,0.18181818181818182,0.0,0.0,0.0,0.0,6.0,0.18181818181818182,0.0,0.0,0.0,0.0,6.0,0.6
8,jeromq,"public long timeout(){
    if (tickets.isEmpty()) {
        return -1;
    }
    sortIfNeeded();
    Ticket first = tickets.get(0);
    return first.start - now() + first.delay;
}",timeout,org/zeromq/timer/ZTicket.java,/src/main/java/org/zeromq/timer/ZTicket.java,"/**
     * Returns the time in millisecond until the next ticket.
     * @return the time in millisecond until the next ticket.
     */",160-173,"('timeout', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,10.0,Returns the time in millisecond until the next ticket.,The time until the next ticket is returned in milliseconds. Return the time in millisecond until the next ticket.,The time is returned in a second.,0.274892268365893,  Returns the time in milliseconds to the next ticket.,"public long timeout(){
        if (tickets.isEmpty()) {
            return -1;
        }
        final long now = now();
        final long next = tickets.get(0).start + tickets.get(0).delay;
        return next - now;
    }"," public long timeout(){
        return nextTicket().delay;
    }"," public long timeout(){
        return timeout(TimeUnit.SECONDS);       
 }","public long timeout(){
        if (tickets.isEmpty()) {
            return -1;
        }
        final long now = now();
        final Ticket next = tickets.get(0);
        return next.start + next.delay - now;       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6058979476177951,  0.1536676932095671,  0.6542755535370106,  0.18918917367362248,23.0,0.40350877192982454,35.0,0.7142857142857143,15.0,0.28846153846153844,36.0,0.7346938775510204,43.0,0.7543859649122807,12.0,0.21052631578947367,44.0,0.7719298245614035,11.0,0.55,2.0,0.2,8.0,0.8
9,weblogic-kubernetes-operator,"public void useKubernetesVersion(String version) throws IOException{
    KubernetesSchemaReference reference = KubernetesSchemaReference.create(version);
    URL cacheUrl = reference.getKubernetesSchemaCacheUrl();
    if (cacheUrl == null) {
        throw new IOException(""No schema cached for Kubernetes "" + version);
    }
    addExternalSchema(reference.getKubernetesSchemaUrl(), cacheUrl);
}",useKubernetesVersion,oracle/kubernetes/json/SchemaGenerator.java,/json-schema-generator/src/main/java/oracle/kubernetes/json/SchemaGenerator.java,"/**
   * Specifies the version of the Kubernetes schema to use.
   *
   * @param version a Kubernetes version string, such as ""1.9.0""
   * @throws IOException if no schema for that version is cached.
   */",97-111,"('useKubernetesVersion', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",58.0,10.0,Specifies the version of the Kubernetes schema to use.,"Show the version of the Kubernetes schema to be used. Indicate a  Kubernetes version string, for example ""1.8.0""  and return IOException if no schema exists in the cached for the given version.",The version of the Kubernetes schema that is used is specified.,0.311401150484418,  Specifies the version of the Kubernetes schema to use.," public void useKubernetesVersion(String version) throws IOException{
    schemaUrls.put(""kubernetes"", ""https://raw.githubusercontent.com/kubernetes/kubernetes/v"" + version + ""/api/openapi-spec/swagger.json"");
  }"," public void useKubernetesVersion(String version) throws IOException{
    String schemaUrl = schemaUrls.get(version);
    if (schemaUrl == null) {
      throw new IOException(""No schema found for Kubernetes version "" + version);
    }
    schemaUrls.put(EXTERNAL_CLASS, schemaUrl);
  }",Not Valid,Not Valid,NOT PASS,NOT PASS,Not Valid,Not Valid,  0.16523072903456043,  0.5646624438295359,None,None,41.0,0.6949152542372882,21.0,0.3559322033898305,None,None,None,None,29.0,0.6041666666666666,None,None,None,None,25.0,0.7575757575757576,0.0,0.0,7.0,0.5833333333333334
10,dcache,"public synchronized void addCacheEntry(CacheEntry entry) throws CacheException, InterruptedException{
    FileAttributes fileAttributes = entry.getFileAttributes();
    String storageClass = fileAttributes.getStorageClass();
    String hsmName = fileAttributes.getHsm().toLowerCase();
    String composedName = storageClass + ""@"" + hsmName;
    StorageClassInfo classInfo = _storageClasses.get(composedName);
    if (classInfo == null) {
        classInfo = new StorageClassInfo(_storageHandler, hsmName, storageClass);
        StorageClassInfo tmpInfo = _storageClasses.get(""*@"" + hsmName);
        if (tmpInfo != null) {
            classInfo.setExpiration(tmpInfo.getExpiration());
            classInfo.setPending(tmpInfo.getPending());
            classInfo.setMaxSize(tmpInfo.getMaxSize());
            classInfo.setOpen(tmpInfo.isOpen());
        }
        _storageClasses.put(composedName, classInfo);
    }
    classInfo.add(entry);
    _pnfsIds.put(entry.getPnfsId(), classInfo);
}",addCacheEntry,org/dcache/pool/classic/StorageClassContainer.java,/modules/dcache/src/main/java/org/dcache/pool/classic/StorageClassContainer.java,"/**
     * adds a CacheEntry to the list of HSM storage requests.
     *
     * @param entry
     */",157-190,"('addCacheEntry', {'INSTRUCTION': {'covered': 72, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",177.0,11.0,adds a CacheEntry to the list of HSM storage requests.,based on the storage requests HSM adds a ChacheEntry .,The list of storage requests has a cache entry added.,0.313729244562084,  Adds a CacheEntry to the list of HSM storage requests.," public synchronized void addCacheEntry(CacheEntry entry) throws CacheException, InterruptedException{
        PnfsId pnfsId = entry.getPnfsId();
        StorageClassInfo info = _pnfsIds.get(pnfsId);
        if (info == null) {
            info = defineStorageClass(entry.getHsmName(), entry.getStorageClass());
        }
        info.add(entry);
        _pnfsIds.put(pnfsId, info);
    }"," public synchronized void addCacheEntry(CacheEntry entry) throws CacheException, InterruptedException{
        PnfsId pnfsId = entry.getPnfsId();
        StorageClassInfo info = _pnfsIds.get(pnfsId);
        if (info == null) {
            info = defineStorageClass(entry.getHsmName(), entry.getStorageClass());
        }
        info.add(entry);
        _pnfsIds.put(pnfsId, info);
    }"," public synchronized void addCacheEntry(CacheEntry entry) throws CacheException, InterruptedException{
        PnfsId pnfsId = entry.getPnfsId();
        StorageClassInfo info = _pnfsIds.get(pnfsId);
        if (info == null) {
            info = defineStorageClass(entry.getHsmName(), entry.getStorageClass());
            _pnfsIds.put(pnfsId, info);
        }
        info.add(entry);        
 }"," public synchronized void addCacheEntry(CacheEntry entry) throws CacheException, InterruptedException{
        PnfsId pnfsId = entry.getPnfsId();
        StorageClassInfo info = _pnfsIds.get(pnfsId);
        if (info == null) {
            info = defineStorageClass(entry.getHsmName(), entry.getStorageClass());
            _pnfsIds.put(pnfsId, info);
        }
        info.add(entry);        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.28815603734008455,  0.28815603734008455,  0.2757113939774027,  0.28091972731073606,120.0,0.6741573033707865,120.0,0.6741573033707865,121.0,0.6797752808988764,121.0,0.6797752808988764,0.0,0.0,12.0,0.16,12.0,0.16,10.0,0.9090909090909091,1.0,0.09090909090909091,10.0,0.9090909090909091
11,cdk,"private static int findPrefix(Trie trie, String string, int i, int best){
    if (trie == null)
        return best;
    if (trie.token != null)
        best = i;
    if (i == string.length())
        return best;
    final char c = norm(string.charAt(i));
    if (c > 128)
        return best;
    return findPrefix(trie.children[c], string, i + 1, best);
}",findPrefix,org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,"/**
     * Find the longest prefix from position (i) in this string that
     * is present in the trie symbol table.
     *
     * @param trie   trie node (start with root)
     * @param string string to find a prefix of
     * @param i      the position in the string
     * @param best   best score so far (-1 to start)
     * @return the length of the prefix
     */",404-425,"('findPrefix', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",95.0,21.0,Find the longest prefix from position (i) in this string that  is present in the trie symbol table.,"Find, within the trie symbol table, the longest prefix from position (i).  ",The trie symbol table has a string that is the longest from position i.,0.32955872235036,  Look for the longest prefix of position (i) in this string in the sort symbol table.,"private static int findPrefix(Trie trie, String string, int i, int best){
        if (i == string.length()) return best;
        char c = string.charAt(i);
        if (trie.contains(c)){
            best = i + 1;
            trie = trie.get(c);
        }
        return findPrefix(trie, string, i + 1, best);
    }","private static int findPrefix(Trie trie, String string, int i, int best){
        if (i == string.length()) return best;
        char c = string.charAt(i);
        if (trie.contains(c)) {
            best = i + 1;
            return findPrefix(trie.get(c), string, i + 1, best);
        } else {
            return best;
        }
    }","private static int findPrefix(Trie trie, String string, int i, int best){
        if (i == string.length()) return best;
        int j = trie.find(string, i);
        if (j == -1) return best;
        return findPrefix(trie, string, j + 1, Math.max(best, j + 1));
    }","private static int findPrefix(Trie trie, String string, int i, int best){
        if (i == string.length()) return best;
        int j = trie.findPrefix(string, i);
        if (j > best) best = j;
        return findPrefix(trie, string, i + 1, best);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6102296626240524,  0.624272968757846,  0.5485055288808511,  0.5317774705342636,47.0,0.4895833333333333,46.0,0.4791666666666667,41.0,0.4270833333333333,49.0,0.5104166666666666,16.0,0.18823529411764706,26.0,0.3132530120481928,35.0,0.42168674698795183,18.0,0.9473684210526315,7.0,0.3684210526315789,15.0,0.7894736842105263
12,mybatis-3,"public static int hashCode(Object obj){
    if (obj == null) {
        // for consistency with Arrays#hashCode() and Objects#hashCode()
        return 0;
    }
    final Class<?> clazz = obj.getClass();
    if (!clazz.isArray()) {
        return obj.hashCode();
    }
    final Class<?> componentType = clazz.getComponentType();
    if (long.class.equals(componentType)) {
        return Arrays.hashCode((long[]) obj);
    } else if (int.class.equals(componentType)) {
        return Arrays.hashCode((int[]) obj);
    } else if (short.class.equals(componentType)) {
        return Arrays.hashCode((short[]) obj);
    } else if (char.class.equals(componentType)) {
        return Arrays.hashCode((char[]) obj);
    } else if (byte.class.equals(componentType)) {
        return Arrays.hashCode((byte[]) obj);
    } else if (boolean.class.equals(componentType)) {
        return Arrays.hashCode((boolean[]) obj);
    } else if (float.class.equals(componentType)) {
        return Arrays.hashCode((float[]) obj);
    } else if (double.class.equals(componentType)) {
        return Arrays.hashCode((double[]) obj);
    } else {
        return Arrays.hashCode((Object[]) obj);
    }
}",hashCode,org/apache/ibatis/reflection/ArrayUtil.java,/src/main/java/org/apache/ibatis/reflection/ArrayUtil.java,"/**
   * Returns a hash code for {@code obj}.
   *
   * @param obj
   *          The object to get a hash code for. May be an array or <code>null</code>.
   * @return A hash code of {@code obj} or 0 if {@code obj} is <code>null</code>
   */",25-61,"('hashCode', {'INSTRUCTION': {'covered': 84, 'missed': 0}, 'BRANCH': {'covered': 20, 'missed': 0}, 'LINE': {'covered': 23, 'missed': 0}, 'COMPLEXITY': {'covered': 11, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",296.0,11.0,Returns a hash code for {@code obj}.,Yields a hash code for {@code obj}. The meethod return A hash code of {@code obj} or 0 if {@code obj} is <code>null</code>,A code is returned for @code obj.,0.879059222536263,  Returns a hash code for {@code obj}.,"public static int hashCode(Object obj){
  if (obj == null) {
   return 0;
  }
  if (obj.getClass().isArray()) {
   int hash = obj.getClass().hashCode();
   for (int i = 0; i < Array.getLength(obj); i++) {
    hash = hash * 31 + hashCode(Array.get(obj, i));
   }
   return hash;
  } else {
   return obj.hashCode();
  }     
 }","public static int hashCode(Object obj){
   	if(obj == null){
 		return 0;
 	}
 	if(obj.getClass().isArray()){
 		int result = 1;
 		int length = Array.getLength(obj);
 		for(int i = 0; i < length; i++){
 			Object element = Array.get(obj, i);
 			result = 31 * result + (element == null ? 0 : element.hashCode());
 		}
 		return result;
 	}
 	return obj.hashCode();    
 }","public static int hashCode(Object obj){
   	if(obj == null){
 		return 0;
 	}
 	if(obj.getClass().isArray()){
 		int result = 1;
 		int length = Array.getLength(obj);
 		for(int i = 0; i < length; i++){
 			Object element = Array.get(obj, i);
 			result = 31 * result + (element == null ? 0 : element.hashCode());
 		}
 		return result;
 	}
 	return obj.hashCode();    
 }","public static int hashCode(Object obj){
  if (obj == null) {
   return 0;
  }
  if (obj.getClass().isArray()) {
   int hash = obj.getClass().hashCode();
   for (int i = 0; i < Array.getLength(obj); i++) {
    hash = hash * 31 + hashCode(Array.get(obj, i));
   }
   return hash;
  } else {
   return obj.hashCode();
  }     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.23644982799139708,  0.20363787348952325,  0.23644982799139708,  0.20363787348952325,224.0,0.7542087542087542,230.0,0.7744107744107744,224.0,0.7542087542087542,230.0,0.7744107744107744,41.0,0.3761467889908257,0.0,0.0,41.0,0.3761467889908257,17.0,0.7083333333333334,0.0,0.0,6.0,0.75
13,cdk,"public void writeMolecule(IAtomContainer mol) throws IOException{
    matcher = SybylAtomTypeMatcher.getInstance(mol.getBuilder());
    try {
        logger.debug(""Writing header..."");
        if (mol.getTitle() != null) {
            writer.write(""#        Name: "" + mol.getTitle());
            writer.write('\n');
        }
        writer.write('\n');
        logger.debug(""Writing molecule block..."");
        writer.write(""@<TRIPOS>MOLECULE"");
        writer.write('\n');
        if (mol.getID() == null) {
            writer.write(""CDKMolecule"");
        } else {
            writer.write(mol.getID());
        }
        writer.write('\n');
        writer.write(mol.getAtomCount() + "" "" + mol.getBondCount());
        writer.write('\n');
        writer.write(""SMALL"");
        writer.write('\n');
        writer.write(""NO CHARGES"");
        writer.write('\n');
        logger.debug(""Writing atom block..."");
        writer.write(""@<TRIPOS>ATOM"");
        writer.write('\n');
        for (int i = 0; i < mol.getAtomCount(); i++) {
            IAtom atom = mol.getAtom(i);
            writer.write((i + 1) + "" "" + atom.getSymbol() + (mol.indexOf(atom) + 1) + "" "");
            if (atom.getPoint3d() != null) {
                writer.write(atom.getPoint3d().x + "" "");
                writer.write(atom.getPoint3d().y + "" "");
                writer.write(atom.getPoint3d().z + "" "");
            } else if (atom.getPoint2d() != null) {
                writer.write(atom.getPoint2d().x + "" "");
                writer.write(atom.getPoint2d().y + "" "");
                writer.write("" 0.000 "");
            } else {
                writer.write(""0.000 0.000 0.000 "");
            }
            IAtomType sybylType = null;
            try {
                sybylType = matcher.findMatchingAtomType(mol, atom);
            } catch (CDKException e) {
                e.printStackTrace();
            }
            if (sybylType != null) {
                writer.write(sybylType.getAtomTypeName());
            } else {
                writer.write(atom.getSymbol());
            }
            writer.write('\n');
        }
        logger.debug(""Writing bond block..."");
        writer.write(""@<TRIPOS>BOND"");
        writer.write('\n');
        int counter = 0;
        for (IBond bond : mol.bonds()) {
            String sybylBondOrder = ""-1"";
            if (bond.getOrder().equals(IBond.Order.SINGLE))
                sybylBondOrder = ""1"";
            else if (bond.getOrder().equals(IBond.Order.DOUBLE))
                sybylBondOrder = ""2"";
            else if (bond.getOrder().equals(IBond.Order.TRIPLE))
                sybylBondOrder = ""3"";
            if (bond.getFlag(CDKConstants.ISAROMATIC))
                sybylBondOrder = ""ar"";
            final IAtom bondAtom1 = bond.getBegin();
            final IAtom bondAtom2 = bond.getEnd();
            try {
                final IAtomType bondAtom1Type = matcher.findMatchingAtomType(mol, bondAtom1);
                final IAtomType bondAtom2Type = matcher.findMatchingAtomType(mol, bondAtom2);
                if (bondAtom1Type != null && bondAtom2Type != null && ((bondAtom1Type.getAtomTypeName().equals(""N.am"") && bondAtom2Type.getAtomTypeName().equals(""C.2"")) || (bondAtom2Type.getAtomTypeName().equals(""N.am"") && bondAtom1Type.getAtomTypeName().equals(""C.2"")))) {
                    sybylBondOrder = ""am"";
                }
            } catch (CDKException e) {
                e.printStackTrace();
            }
            writer.write((counter + 1) + "" "" + (mol.indexOf(bond.getBegin()) + 1) + "" "" + (mol.indexOf(bond.getEnd()) + 1) + "" "" + sybylBondOrder);
            writer.write('\n');
            counter++;
        }
    } catch (IOException e) {
        throw e;
    }
}",writeMolecule,org/openscience/cdk/io/Mol2Writer.java,/storage/io/src/main/java/org/openscience/cdk/io/Mol2Writer.java,"/**
     * Writes a single frame in XYZ format to the Writer.
     *
     * @param mol the Molecule to write
     * @throws java.io.IOException if there is an error during writing
     */",133-259,"('writeMolecule', {'INSTRUCTION': {'covered': 320, 'missed': 78}, 'BRANCH': {'covered': 16, 'missed': 18}, 'LINE': {'covered': 60, 'missed': 15}, 'COMPLEXITY': {'covered': 4, 'missed': 14}, 'METHOD': {'covered': 1, 'missed': 0}})",781.0,11.0,Writes a single frame in XYZ format to the Writer., Insert within the Writer a single frame in XYZ format.  ,A single frame is written in a format called the writer's format.,0.356403466457851,  Writes a single image in XYZ format in the writer.,"public void writeMolecule(IAtomContainer mol) throws IOException{
        writer.write(""@<TRIPOS>MOLECULE"");
        writer.newLine();
        writer.write("" "" + mol.getAtomCount() + "" "" + mol.getBondCount() + "" 0 0 0"");
        writer.newLine();
        writer.write(""SMALL"");
        writer.newLine();
        writer.write(""USER_CHARGES"");
        writer.newLine();
        writer.write(""@<TRIPOS>ATOM"");
        writer.newLine();
        for (IAtom atom : mol.atoms()) {
            writer.write(getAtomLine(atom));
            writer.newLine();
        }
        writer.write(""@<TRIPOS>BOND"");
        writer.newLine();
        for (IBond bond : mol.bonds()) {
            writer.write(getBondLine(bond));
            writer.newLine();
        }
        writer.flush();
    }","public void writeMolecule(IAtomContainer mol) throws IOException{
        writer.write(""@<TRIPOS>MOLECULE"");
        writer.newLine();
        writer.write("" "" + mol.getAtomCount() + "" "" + mol.getBondCount() + "" 0 0 0"");
        writer.newLine();
        writer.write(""SMALL"");
        writer.newLine();
        writer.write(""USER_CHARGES"");
        writer.newLine();
        writer.write(""@<TRIPOS>ATOM"");
        writer.newLine();
        for (IAtom atom : mol.atoms()) {
            writer.write(getAtomLine(atom));
            writer.newLine();
        }
        writer.write(""@<TRIPOS>BOND"");
        writer.newLine();
        for (IBond bond : mol.bonds()) {
            writer.write(getBondLine(bond));
            writer.newLine();
        }
        writer.flush();     
 }","public void writeMolecule(IAtomContainer mol) throws IOException{
        writer.write(""@<TRIPOS>MOLECULE"");
        writer.newLine();
        writer.write(""  "" + mol.getID());
        writer.newLine();
        writer.write(""  "" + mol.getAtomCount());
        writer.newLine();
        writer.write(""  "" + mol.getBondCount());
        writer.newLine();
        writer.write(""  0"");
        writer.newLine();
        writer.write(""SMALL"");
        writer.newLine();
        writer.write(""USER_CHARGES"");
        writer.newLine();
        writer.write(""@<TRIPOS>ATOM"");
        writer.newLine();
        for (IAtom atom : mol.atoms()) {
            writer.write(""  "" + (atom.getIndex() + 1));
            writer.write("" "" + atom.getSymbol());
            writer.write("" "" + atom.getPoint2d().x);
            writer.write("" "" + atom.getPoint2d().y);
            writer.write("" "" + atom.getPoint3d().x);
            writer.write("" "" + atom.getPoint3d().y);
            writer.write("" "" + atom.getPoint3d().z);
            writer.write("" "" + atom.getFormalCharge());
            writer.write("" "" + atom.getImplicitHydrogenCount());
            writer.write("" "" + atom.getMassNumber());
            writer.write("" "" + atom.getAtomTypeName());
            writer.newLine();
        }
        writer.write(""@<TRIPOS>BOND"");
        writer.newLine();
        for (IBond bond : mol.bonds()) {
            writer.write(""  "" + (bond.getIndex() + 1));
            writer.write("" "" + bond.getBegin().getIndex() + 1);
            writer.write("" "" + bond.getEnd().getIndex() + 1);
            writer.write("" "" + bond.getOrder().numeric());
            writer.newLine();
        }
        writer.flush();     
 }","public void writeMolecule(IAtomContainer mol) throws IOException{
        writer.write(""@<TRIPOS>MOLECULE"");
        writer.newLine();
        writer.write(mol.getAtomCount() + "" "" + mol.getBondCount() + "" 0 0 0"");
        writer.newLine();
        writer.write(""SMALL"");
        writer.newLine();
        writer.write(""USER_CHARGES"");
        writer.newLine();
        writer.write(""@<TRIPOS>ATOM"");
        writer.newLine();
        for (IAtom atom : mol.atoms()) {
            writer.write(atom.getAtomNumber() + "" "" + atom.getSymbol() + "" "" + atom.getX3() + "" "" + atom.getY3() + "" "" + atom.getZ3() + "" "" + atom.getCharge());
            writer.newLine();
        }
        writer.write(""@<TRIPOS>BOND"");
        writer.newLine();
        for (IBond bond : mol.bonds()) {
            writer.write(bond.getAtomNumber(0) + "" "" + bond.getAtomNumber(1) + "" "" + bond.getOrder().numeric() + "" "" + bond.getOrder().numeric());
            writer.newLine();
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.1401223461555679,  0.1401223461555679,  0.17776718978347325,  0.27142105381547266,635.0,0.8120204603580563,635.0,0.8120204603580563,586.0,0.7493606138107417,484.0,0.618925831202046,0.0,0.0,80.0,0.33613445378151263,257.0,0.611904761904762,8.0,0.7272727272727273,3.0,0.2727272727272727,8.0,0.6153846153846154
14,cdk,"public boolean allHeavyAtomsPlaced(IAtomContainer ac){
    for (int i = 0; i < ac.getAtomCount(); i++) {
        if (isUnplacedHeavyAtom(ac.getAtom(i))) {
            return false;
        }
    }
    return true;
}",allHeavyAtomsPlaced,org/openscience/cdk/modeling/builder3d/AtomPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomPlacer3D.java,"/**
     *  True is all the atoms in the given AtomContainer have been placed.
     *
     * @param  ac  The AtomContainer to be searched
     * @return     True is all the atoms in the given AtomContainer have been placed
     */",604-617,"('allHeavyAtomsPlaced', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",49.0,13.0,True is all the atoms in the given AtomContainer have been placed., Returns True if all atoms related to the given AtomContainr have been placed.  ,The atoms in the container have been placed.,0.142141057600746,  True is that all the atoms of the given AtomContainer have been placed.,"public boolean allHeavyAtomsPlaced(IAtomContainer ac){
        for (int i = 0; i < ac.getAtomCount(); i++) {
            if (isUnplacedHeavyAtom(ac.getAtom(i))) {
                return false;
            }
        }
        return true;
    }","public boolean allHeavyAtomsPlaced(IAtomContainer ac){
        for (int i = 0; i < ac.getAtomCount(); i++) {
            if (isUnplacedHeavyAtom(ac.getAtom(i))) {
                return false;
            }
        }
        return true;
    }","public boolean allHeavyAtomsPlaced(IAtomContainer ac){
        for (int i = 0; i < ac.getAtomCount(); i++) {
            if (isUnplacedHeavyAtom(ac.getAtom(i))) {
                return false;
            }
        }
        return true;
    }","public boolean allHeavyAtomsPlaced(IAtomContainer ac){
        for (int i = 0; i < ac.getAtomCount(); i++) {
            if (isUnplacedHeavyAtom(ac.getAtom(i))) {
                return false;
            }
        }
        return true;
    }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,6.0,0.42857142857142855,2.0,0.14285714285714285,6.0,0.46153846153846156
15,logstash-logback-encoder,"private boolean enqueue(Event event) throws ShutdownInProgressException, InterruptedException{
    if (this.disruptor.getRingBuffer().tryPublishEvent(this.eventTranslator, event)) {
        return true;
    }
    if (this.appendTimeout.getMilliseconds() == 0) {
        return false;
    }
    long deadline = Long.MAX_VALUE;
    if (this.appendTimeout.getMilliseconds() < 0) {
        lock.lockInterruptibly();
    } else {
        deadline = System.currentTimeMillis() + this.appendTimeout.getMilliseconds();
        if (!lock.tryLock(this.appendTimeout.getMilliseconds(), TimeUnit.MILLISECONDS)) {
            return false;
        }
    }
    long backoff = 1L;
    long backoffLimit = TimeUnit.MILLISECONDS.toNanos(this.appendRetryFrequency.getMilliseconds());
    try {
        do {
            if (!isStarted()) {
                throw new ShutdownInProgressException();
            }
            if (deadline <= System.currentTimeMillis()) {
                return false;
            }
            if (Thread.currentThread().isInterrupted()) {
                throw new InterruptedException();
            }
            LockSupport.parkNanos(backoff);
            backoff = Math.min(backoff * 2, backoffLimit);
        } while (!this.disruptor.getRingBuffer().tryPublishEvent(this.eventTranslator, event));
        return true;
    } finally {
        lock.unlock();
    }
}",enqueue,net/logstash/logback/appender/AsyncDisruptorAppender.java,/src/main/java/net/logstash/logback/appender/AsyncDisruptorAppender.java,"/**
     * Enqueue an event in the ring buffer, retrying if allowed by the configuration.
     * 
     * @param event the event to add to the ring buffer
     * @return {@code true} if the event is successfully enqueued, {@code false} if the event
     *         could not be added to the ring buffer.
     * @throws ShutdownInProgressException thrown when the appender is shutdown while retrying
     *         to enqueue the event
     * @throws InterruptedException thrown when the logging thread is interrupted while retrying
     */",534-600,"('enqueue', {'INSTRUCTION': {'covered': 93, 'missed': 6}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 21, 'missed': 2}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",257.0,15.0,"Enqueue an event in the ring buffer, retrying if allowed by the configuration.","  Enqueue an event in the ring buffer, if allowed by the configuration, retry.  The methon return {@code true} in case the event was successfully added, {@code false}   in case the event was not added to the ring buffer.    ","If allowed by the configuration, you can queue an event in the ring buffer.",0.215699618364069,"  String an event into the ring buffer, try again if the configuration allows it.","private boolean enqueue(Event event) throws ShutdownInProgressException, InterruptedException{
        int retryCount = 0;
        while (true) {
            long sequence = this.disruptor.getRingBuffer().tryNext();
            this.disruptor.getRingBuffer().get(sequence).setEvent(event);
            this.disruptor.getRingBuffer().publish(sequence);
            if (this.disruptor.getRingBuffer().hasAvailableCapacity(this.getRingBufferSize())) {
                return true;
            }
            if (this.getMaxRetries() == 0) {
                return false;
            }
            if (retryCount >= this.getMaxRetries()) {
                return false;
            }
            retryCount++;
            Thread.sleep(this.getRetryInterval().getMilliseconds());
        }
    }","private boolean enqueue(Event event) throws ShutdownInProgressException, InterruptedException{
        boolean enqueued = false;
        int retryCount = 0;
        while (!enqueued && retryCount < MAX_RETRY_COUNT) {
            enqueued = this.disruptor.getRingBuffer().tryPublishEvent(this.sequenceCallback, event.getSequence(), event);
            if (!enqueued) {
                retryCount++;
                LockSupport.parkNanos(SLEEP_TIME_DURING_SHUTDOWN);
            }
        }
        return enqueued;
    }","private boolean enqueue(Event event) throws ShutdownInProgressException, InterruptedException{
        if (this.disruptor.getRingBuffer().hasAvailableCapacity(1)) {
            this.disruptor.getRingBuffer().publishEvent(this.eventTranslator, this.sequenceCallback.get(), event);
            return true;
        } else {
            return false;
        }
    }"," private boolean enqueue(Event event) throws ShutdownInProgressException, InterruptedException{
        boolean enqueued = false;
        while (!enqueued) {
            long sequence = this.disruptor.getRingBuffer().tryNext();
            EventWrapper eventWrapper = (EventWrapper) this.disruptor.getRingBuffer().get(sequence);
            eventWrapper.setEvent(event);
            this.disruptor.getRingBuffer().publish(sequence);
            enqueued = true;
        }
        return enqueued;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3225392010891077,  0.2191698618836756,  0.1897511369543523,  0.18079531501412036,172.0,0.6666666666666666,206.0,0.7984496124031008,199.0,0.7713178294573644,204.0,0.7906976744186046,96.0,0.6713286713286714,81.0,0.5664335664335665,92.0,0.6433566433566433,28.0,0.717948717948718,8.0,0.5333333333333333,13.0,0.8666666666666667
16,matsim-libs,"private static void prepareRNG(final Random rng){
    for (int i = 0; i < 100; i++) {
        rng.nextDouble();
    }
}",prepareRNG,org/matsim/core/gbl/MatsimRandom.java,/matsim/src/main/java/org/matsim/core/gbl/MatsimRandom.java,"/**
         * Draw some random numbers to better initialize the pseudo-random number generator.
         *
         * @param rng the random number generator to initialize.
         */",92-101,"('prepareRNG', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,12.0,Draw some random numbers to better initialize the pseudo-random number generator., In order to better initialize the pseudo-random number generator draw   some random numbers.,Draw some random numbers to make the generator work better.,0.0914113192820884,  Draw random numbers to better initialize the pseudo-random number generator.,"private static void prepareRNG(final Random rng){
		// draw some random numbers to better initialize the pseudo-random number generator
		for (int i = 0; i < 100; i++) {
			rng.nextDouble();
		}
	}","private static void prepareRNG(final Random rng){
		for (int i = 0; i < 10; i++) {
			rng.nextDouble();
		}
	}","private static void prepareRNG(final Random rng){
	 		// draw some random numbers to make the generator work better
 		for (int i = 0; i < 100; i++) {
 			rng.nextDouble();
 		}
 	}","private static void prepareRNG(final Random rng){
	 		// draw random numbers to better initialize the pseudo-random number generator
 		for (int i = 0; i < 100; i++) {
 			rng.nextDouble();
 		}
 	}",PASS,NOT PASS,PASS,PASS,  1.0,  0.9599855215853961,  1.0,  1.0,0.0,0.0,1.0,0.029411764705882353,0.0,0.0,0.0,0.0,1.0,0.029411764705882353,0.0,0.0,0.0,0.0,9.0,0.6428571428571429,1.0,0.08333333333333333,5.0,0.4166666666666667
17,cdk,"private String encode(int[] path){
    StringBuilder sb = new StringBuilder(path.length * 3);
    for (int i = 0, n = path.length - 1; i <= n; i++) {
        IAtom atom = container.getAtom(path[i]);
        sb.append(toAtomPattern(atom));
        if (i < n) {
            IBond bond = container.getBond(container.getAtom(path[i]), container.getAtom(path[i + 1]));
            sb.append(getBondSymbol(bond));
        }
    }
    return sb.toString();
}",encode,org/openscience/cdk/fingerprint/ShortestPathWalker.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/ShortestPathWalker.java,"/**
     * Encode the provided path of atoms to a string.
     *
     * @param path inclusive array of vertex indices
     * @return encoded path
     */",136-154,"('encode', {'INSTRUCTION': {'covered': 63, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",126.0,10.0,Encode the provided path of atoms to a string.,Starting with a string encodes a path of atoms.,The path of atoms can be found in the provided text.,0.861084792626924,  Encode the provided path of atoms to a string.,"private String encode(int[] path){
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < path.length; i++) {
            sb.append(path[i]);
            if (i < path.length - 1) {
                sb.append("","");
            }
        }
        return sb.toString();       
 }",Empty Method,"private String encode(int[] path){
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < path.length; i++) {
            sb.append(container.getAtom(path[i]).getSymbol());
        }
        return sb.toString();       
 }","private String encode(int[] path){
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < path.length; i++) {
            sb.append(container.getAtom(path[i]).getSymbol());
        }
        return sb.toString();       
 }",NOT PASS,Empty Method,NOT PASS,NOT PASS,  0.36416386686369895,None,  0.32224735651509345,  0.32224735651509345,62.0,0.4881889763779528,None,None,67.0,0.5275590551181102,67.0,0.5275590551181102,None,None,18.0,0.24324324324324326,18.0,0.24324324324324326,9.0,0.9,0.0,0.0,10.0,0.8333333333333334
18,tablesaw,"public int mappedRowNumber(int rowNumber){
    if (isSorted()) {
        return sortOrder[rowNumber];
    } else if (hasSelection()) {
        return selection.get(rowNumber);
    }
    return rowNumber;
}",mappedRowNumber,tech/tablesaw/table/TableSlice.java,/core/src/main/java/tech/tablesaw/table/TableSlice.java,"/**
   * Maps the view row number to the row number on the underlying source table.
   *
   * @param rowNumber the row number in the view.
   * @return the matching row number in the underlying table.
   */",255-268,"('mappedRowNumber', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",43.0,15.0,Maps the view row number to the row number on the underlying source table.,"    Starting from the row of the source table, the corresponding row number     of the view is mapped.  ",The view row number is mapped to the underlying source table.,0.0680378417813278,  Maps the row number of the view to the row number of the underlying source table.," public int mappedRowNumber(int rowNumber){
    if (isSorted()) {
      return sortOrder[rowNumber];
    } else if (hasSelection()) {
      return selection.get(rowNumber);
    }
    return rowNumber;
  }"," public int mappedRowNumber(int rowNumber){
    if (isSorted()) {
      return sortOrder[rowNumber];
    } else if (hasSelection()) {
      return selection.get(rowNumber);
    }
    return rowNumber;
  }"," public int mappedRowNumber(int rowNumber){
    if (isSorted()) {
      return sortOrder[rowNumber];
    } else if (hasSelection()) {
      return selection.get(rowNumber);
    }
    return rowNumber;
  }"," public int mappedRowNumber(int rowNumber){
    if (hasSelection()) {
      return selection.get(rowNumber);
    }
    return rowNumber;
  }",PASS,PASS,NOT PASS,PASS,  1.0,  1.0,  0.682995735854476,  1.0,0.0,0.0,0.0,0.0,15.0,0.3409090909090909,0.0,0.0,0.0,0.0,15.0,0.3409090909090909,0.0,0.0,12.0,0.6666666666666666,5.0,0.29411764705882354,7.0,0.4666666666666667
19,matsim-libs,"public static void addService(Carrier carrier, CarrierService carrierService){
    carrier.getServices().put(carrierService.getId(), carrierService);
}",addService,org/matsim/contrib/freight/carrier/CarrierUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/carrier/CarrierUtils.java,"/**
	 * Adds an {@link CarrierService} to the {@link Carrier}.
	 * @param carrier
	 * @param carrierService
	 */",36-43,"('addService', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,15.0,Adds an {@link CarrierService} to the {@link Carrier}.,Appends a {@link CarrierService} to the {@link Carrier}.         ,The @link Carrier is now an @link Carrier Service.,1.21415787076405,  Adds a {carrierservice @link} to the {@link Carrier}.," public static void addService(Carrier carrier, CarrierService carrierService){
	 	carrier.getServices().add(carrierService);		
 }"," public static void addService(Carrier carrier, CarrierService carrierService){
	 	carrier.getServices().add(carrierService);		
 }"," public static void addService(Carrier carrier, CarrierService carrierService){
	 		carrier.getServices().add(carrierService);
 	}"," public static void addService(Carrier carrier, CarrierService carrierService){
	 		carrier.getServices().add(carrierService);
 	}		",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7123063705349664,  0.7123063705349664,  0.7123063705349664,  0.7123063705349664,7.0,0.22580645161290322,7.0,0.22580645161290322,7.0,0.22580645161290322,7.0,0.22580645161290322,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.2222222222222222,3.0,0.3333333333333333,9.0,0.9
20,glowstone,"public boolean readCompoundList(@NonNls String key, Consumer<? super List<CompoundTag>> consumer){
    return readList(key, TagType.COMPOUND, consumer);
}",readCompoundList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to a list subtag if it is present and its contents are compound
     * tags. Processes the list as a single object; to process each tag separately, instead use
     * {@link #iterateCompoundList(String, Consumer)}.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */",558-570,"('readCompoundList', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,19.0,Applies the given function to a list subtag if it is present and its contents are compound  tags.," Given a list subtag if it is present and its content is composed of tags,    the function is applied.  To process each tag separately you can use    {@link #iterateCompoundList(String, Consumer)},    while tag processes the list as a single object   ","If the function is present and the contents are compound tags, apply it to a list subtag.",0.492552590037658,  Applies the given function to a list subtag if it is present and its contents are composed.," public boolean readCompoundList(@NonNls String key, Consumer<? super List<CompoundTag>> consumer){
        return readList(key, TagType.COMPOUND, consumer);
    }"," public boolean readCompoundList(@NonNls String key, Consumer<? super List<CompoundTag>> consumer){
        return readList(key, TagType.COMPOUND, consumer);
    }"," public boolean readCompoundList(@NonNls String key, Consumer<? super List<CompoundTag>> consumer){
        return readList(key, TagType.COMPOUND, consumer);
    }"," public boolean readCompoundList(@NonNls String key, Consumer<? super List<CompoundTag>> consumer){
        return readList(key, TagType.COMPOUND, consumer);
    }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,34.0,0.85,2.0,0.10526315789473684,16.0,0.8421052631578947
21,weblogic-kubernetes-operator,"public Watchable<V1ConfigMap> createConfigMapWatch(String namespace) throws ApiException{
    return FACTORY.createWatch(callParams, V1ConfigMap.class, new ListNamespacedConfigMapCall(namespace));
}",createConfigMapWatch,oracle/kubernetes/operator/builders/WatchBuilder.java,/operator/src/main/java/oracle/kubernetes/operator/builders/WatchBuilder.java,"/**
   * Creates a web hook object to track config map calls.
   *
   * @param namespace the namespace
   * @return the active web hook
   * @throws ApiException if there is an error on the call that sets up the web hook.
   */",118-130,"('createConfigMapWatch', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,11.0,Creates a web hook object to track config map calls., Given the configuration map to keep track of calls a web hook object is created.   The method returns the active web hook otherwise an ApiException if    there is an error in the call set by the web hook   ,A web hook object is created to track map calls.,0.447964995415663,  Creates a Web hook object to track configuration map calls.,"public Watchable<V1ConfigMap> createConfigMapWatch(String namespace) throws ApiException{
    return FACTORY.createWatch(
        callParams, V1ConfigMap.class, new ListConfigMapCall(namespace));
  }","public Watchable<V1ConfigMap> createConfigMapWatch(String namespace) throws ApiException{
    return FACTORY.createWatch(
        callParams, V1ConfigMap.class, new ListConfigMapCall(namespace));
  }","public Watchable<V1ConfigMap> createConfigMapWatch(String namespace) throws ApiException{
    return FACTORY.createWatch(
        callParams, V1ConfigMap.class, new ListConfigMapCall(namespace));
  }","public Watchable<V1ConfigMap> createConfigMapWatch(String namespace) throws ApiException{
    return FACTORY.createWatch(
        callParams, V1ConfigMap.class, new ListConfigMapCall(namespace));
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.9585619808851353,  0.9585619808851353,  0.9585619808851353,  0.9585619808851353,1.0,0.030303030303030304,1.0,0.030303030303030304,1.0,0.030303030303030304,1.0,0.030303030303030304,0.0,0.0,0.0,0.0,0.0,0.0,34.0,0.8717948717948718,2.0,0.18181818181818182,5.0,0.45454545454545453
23,cron-utils,"static Function<CronField, CronField> returnOnZeroExpression(final CronFieldName name){
    return field -> {
        final FieldConstraints constraints = FieldConstraintsBuilder.instance().forField(name).createConstraintsInstance();
        return new CronField(name, new On(new IntegerFieldValue(0)), constraints);
    };
}",returnOnZeroExpression,com/cronutils/mapper/CronMapper.java,/src/main/java/com/cronutils/mapper/CronMapper.java,"/**
     * Creates a Function that returns a On instance with zero value.
     *
     * @param name - Cron field name
     * @return new CronField -> CronField instance, never null
     */",238-250,"('returnOnZeroExpression', {'INSTRUCTION': {'covered': 3, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",59.0,12.0,Creates a Function that returns a On instance with zero value.,Lets you create a function that can return an instance of On with value zero      ,A function returns a On instance with zero value.,0.190230814868357,  Creates a function that returns an On instance with a null value.,"static Function<CronField, CronField> returnOnZeroExpression(final CronFieldName name){
        return field -> new CronField(name, new On(0), field.getConstraints());     
 }","static Function<CronField, CronField> returnOnZeroExpression(final CronFieldName name){
        return field -> {
            if (field.getFieldName() == name) {
                return new On(0);
            }
            return field;
        };      
 }","static Function<CronField, CronField> returnOnZeroExpression(final CronFieldName name){
        return field -> {
            if (field.getFieldName() == name) {
                return new CronField(name, new On(0), field.getConstraints());
            }
            return field;
        };      
 }"," static Function<CronField, CronField> returnOnZeroExpression(final CronFieldName name){
        return field -> new CronField(name, new On(null), field.getConstraints());      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.42041309856039977,  0.41249577936512277,  0.39658841505500975,  0.508231739318008,31.0,0.5166666666666667,26.0,0.43333333333333335,31.0,0.5166666666666667,25.0,0.4166666666666667,18.0,0.4090909090909091,1.0,0.02702702702702703,19.0,0.3392857142857143,11.0,0.6875,4.0,0.3076923076923077,4.0,0.3333333333333333
24,matsim-libs,"public static double calculateWeightFromPoint(final Coordinate emissionSource, final Coordinate cellCentroid, double smoothingRadius){
    if (smoothingRadius <= 0)
        throw new IllegalArgumentException(""smoothing radius must be greater 0"");
    double dist = emissionSource.distance(cellCentroid);
    return Math.exp((-dist * dist) / (smoothingRadius * smoothingRadius));
}",calculateWeightFromPoint,org/matsim/contrib/analysis/spatial/SpatialInterpolation.java,/contribs/analysis/src/main/java/org/matsim/contrib/analysis/spatial/SpatialInterpolation.java,"/**
     * This uses an exponential distance weighting to calculate the impact of point based emissions onto the centroid of
     * a grid cell. The calculation is described in Kickhoefer's PhD thesis https://depositonce.tu-berlin.de/handle/11303/4386
     * in Appendix A.2
     *
     * @param emissionSource Centroid of the link
     * @param cellCentroid   Centroid of the impacted cell
     * @return weight factor by which the emission value should be multiplied to calculate the impact of the cell
     */",41-57,"('calculateWeightFromPoint', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,22.0,This uses an exponential distance weighting to calculate the impact of point based emissions onto the centroid of  a grid cell.,Exponential distance weighting is used to calculate the impact of  point emissions on the centroid of a grid cell.  You can find a description of the calculation in the dissertation by  Kickhoefer's PhD thesis https://depositonce.tu-berlin.de/handle/11303/4386 in Appendix A.2,The impact of point based emissions onto the centroid of a grid cell is calculated using an exponential distance weight.,0.230157454769525,  This uses exponential distance weighting to calculate the impact of point emissions on the centroid of a grid cell.,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,27.0,0.6923076923076923,3.0,0.13636363636363635,17.0,0.7727272727272727
25,cdk,"private int parseMobileHydrogens(List<Integer> mobHydrAttachPositions, String inputInchi){
    int totalMobHydrCount = 0;
    String hydrogens = """";
    String inchi = inputInchi;
    if (inchi.indexOf(""/h"") != -1) {
        hydrogens = inchi.substring(inchi.indexOf(""/h"") + 2);
        if (hydrogens.indexOf('/') != -1) {
            hydrogens = hydrogens.substring(0, hydrogens.indexOf('/'));
        }
        String mobileHydrogens = hydrogens.substring(hydrogens.indexOf('('));
        Pattern mobileHydrPattern = Pattern.compile(""\\((.)*?\\)"");
        Matcher match = mobileHydrPattern.matcher(mobileHydrogens);
        while (match.find()) {
            String mobileHGroup = match.group();
            int mobHCount = 0;
            String head = mobileHGroup.substring(0, mobileHGroup.indexOf(',') + 1);
            if (head.contains(""H,""))
                head = head.replace(""H,"", ""H1,"");
            if (head.contains(""-,""))
                head = head.replace(""-,"", ""-1,"");
            head = head.substring(2);
            Pattern subPattern = Pattern.compile(""[0-9]*"");
            Matcher subMatch = subPattern.matcher(head);
            while (subMatch.find()) {
                if (!subMatch.group().equals("""")) {
                    mobHCount += Integer.valueOf(subMatch.group());
                }
            }
            totalMobHydrCount += mobHCount;
            mobileHGroup = mobileHGroup.substring(mobileHGroup.indexOf(',') + 1).replace("")"", """");
            StringTokenizer tokenizer = new StringTokenizer(mobileHGroup, "","");
            while (tokenizer.hasMoreTokens()) {
                Integer position = Integer.valueOf(tokenizer.nextToken());
                mobHydrAttachPositions.add(position);
            }
        }
    }
    LOGGER.debug(""#total mobile hydrogens: "", totalMobHydrCount);
    return totalMobHydrCount;
}",parseMobileHydrogens,org/openscience/cdk/tautomers/InChITautomerGenerator.java,/tool/tautomer/src/main/java/org/openscience/cdk/tautomers/InChITautomerGenerator.java,"/**
     * Parses mobile H group(s) in an InChI String.
     * <p>
     * Multiple InChI sequences of mobile hydrogens are joined into a single sequence (list),
     * see step 1 of algorithm in paper.
     * <br>
     * Mobile H group has syntax (H[n][-[m]],a1,a2[,a3[,a4...]])
     * Brackets [ ] surround optional terms.
     * <ul>
     *  <li>Term H[n] stands for 1 or, if the number n (n>1) is present, n mobile hydrogen atoms.</li>
     *  <li>Term [-[m]], if present, stands for 1 or, if the number m (m>1) is present, m mobile negative charges.</li>
     *  <li>a1,a2[,a3[,a4...]] are canonical numbers of atoms in the mobile H group.</li>
     *  <li>no two mobile H groups may have an atom (a canonical number) in common.</li>
     * </ul>
     * @param mobHydrAttachPositions list of positions where mobile H can attach
     * @param inputInchi InChI input
     * @return overall count of hydrogens to be dispersed over the positions
     */",344-408,"('parseMobileHydrogens', {'INSTRUCTION': {'covered': 140, 'missed': 12}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 31, 'missed': 1}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",357.0,12.0,Parses mobile H group(s) in an InChI String.,"Allows the analysis of  mobile H group(s) in an InChI String. multiple InChI sequences of mobile hydrogens can be combined into a  single sequence (list),  Step 1 of the algorithm reported in the paper.  Mobile H group has syntax (H[n][-[m]],a1,a2[,a3[,a4...]])  Brackets [ ] encircle optional terms.  Term H[n] stands for 1 or, if the number n (n>1) is present, n mobile hydrogen atoms. Term [-[m]], if present, stands for 1 or, if the number m (m>1) is present, m mobile negative charges. a1,a2[,a3[,a4...]] are canonical numbers of atoms in the mobile H group. no two mobile H groups may have an atom (a canonical number) in common.    The method returns the total count of hydrogens to be dispersed on the positions",Parses mobile H group in an InChI String.,0.433534509985365,  Analyzes the mobile H group(s) in an InChI string.,"private int parseMobileHydrogens(List<Integer> mobHydrAttachPositions, String inputInchi){
        String inchi = inputInchi;
        inchi = inchi.substring(inchi.indexOf('/') + 1);
        inchi = inchi.substring(inchi.indexOf('/') + 1);
        String connections = inchi.substring(1, inchi.indexOf('/'));
        Pattern connectionPattern = Pattern.compile(""(-|\\(|\\)|,|([0-9])*)"");
        Matcher match = connectionPattern.matcher(connections);
        int position = 0;
        while (match.find()) {
            String group = match.group();
            if (!group.isEmpty()) {
                if (group.matches(""[0-9]*"")) {
                    position++;
                    mobHydrAttachPositions.add(position);
                } else if (group.equals(""("")) {
                    position++;
                } else if (group.equals("")"")) {
                    position++;
                } else {
                    throw new CDKException(""Unexpected token "" + group + "" in connection table encountered."");
                }
            }
        }
        return position;
    }","private int parseMobileHydrogens(List<Integer> mobHydrAttachPositions, String inputInchi){
        int mobHydrCount = 0;
        Pattern mobileHydrogenPattern = Pattern.compile(""H[0-9]*"");
        Matcher match = mobileHydrogenPattern.matcher(inputInchi);
        while (match.find()) {
            String group = match.group();
            if (!group.isEmpty()) {
                if (group.matches(""H[0-9]*"")) {
                    mobHydrCount += Integer.valueOf(group.substring(1));
                }
            }
        }
        return mobHydrCount;        
 }","private int parseMobileHydrogens(List<Integer> mobHydrAttachPositions, String inputInchi){
        String inchi = inputInchi;
        inchi = inchi.substring(inchi.indexOf('/') + 1);
        inchi = inchi.substring(inchi.indexOf('/') + 1);
        String mobileHydrogens = inchi.substring(1, inchi.indexOf('/'));
        Pattern mobileHydrogenPattern = Pattern.compile(""(-|\\(|\\)|,|([0-9])*)"");
        Matcher match = mobileHydrogenPattern.matcher(mobileHydrogens);
        int position = 0;
        while (match.find()) {
            String group = match.group();
            if (!group.isEmpty()) {
                if (group.matches(""[0-9]*"")) {
                    mobHydrAttachPositions.add(position);
                } else if (group.equals(""-"")) {
                    position++;
                } else if (group.equals("","")) {
                    position++;
                } else if (group.equals(""("")) {
                    position++;
                } else if (group.equals("")"")) {
                    position++;
                } else {
                    throw new CDKException(""Unexpected token "" + group + "" in connection table encountered."");
                }
            }
        }
        return mobHydrAttachPositions.size();
    }","private int parseMobileHydrogens(List<Integer> mobHydrAttachPositions, String inputInchi){
        String inchi = inputInchi;
        inchi = inchi.substring(inchi.indexOf('/') + 1);
        inchi = inchi.substring(inchi.indexOf('/') + 1);
        String connections = inchi.substring(1, inchi.indexOf('/'));
        Pattern connectionPattern = Pattern.compile(""(-|\\(|\\)|,|([0-9])*)"");
        Matcher match = connectionPattern.matcher(connections);
        int position = 0;
        while (match.find()) {
            String group = match.group();
            if (!group.isEmpty()) {
                if (group.matches(""[0-9]*"")) {
                    position++;
                    if (group.equals(""1"")) {
                        mobHydrAttachPositions.add(position);
                    }
                } else if (group.equals(""-"")) {
                    position++;
                } else if (group.equals("","")) {
                    position++;
                } else if (group.equals(""("")) {
                    position++;
                } else if (group.equals("")"")) {
                    position++;
                } else {
                    throw new CDKException(""Unexpected token "" + group + "" in connection table encountered."");
                }
            }
        }
        return mobHydrAttachPositions.size();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3001830173220154,  0.18050360753447714,  0.32215551203716075,  0.323740796206818,232.0,0.6480446927374302,272.0,0.7597765363128491,216.0,0.6033519553072626,222.0,0.6201117318435754,109.0,0.5647668393782384,46.0,0.19327731092436976,39.0,0.17410714285714285,114.0,0.9344262295081968,3.0,0.3,1.0,0.1111111111111111
26,dcache,"private static void scanFields(Object obj, Map<List<String>, AcCommandExecutor> commands){
    for (Field field : obj.getClass().getFields()) {
        Iterator<String> i = Splitter.on('_').split(field.getName()).iterator();
        FieldType helpMode;
        String helpType = i.next();
        switch(helpType) {
            case ""hh"":
                helpMode = FieldType.HELP_HINT;
                break;
            case ""fh"":
                helpMode = FieldType.FULL_HELP;
                break;
            case ""acl"":
                helpMode = FieldType.ACL;
                break;
            default:
                continue;
        }
        if (!i.hasNext()) {
            continue;
        }
        List<String> name = Lists.newArrayList(i);
        AcCommandExecutor command = getCommandExecutor(obj, commands, name);
        switch(helpMode) {
            case FULL_HELP:
                command.setFullHelpField(field);
                break;
            case HELP_HINT:
                command.setHelpHintField(field);
                break;
            case ACL:
                command.setAclField(field);
                break;
        }
    }
}",scanFields,dmg/util/command/AcCommandScanner.java,/modules/cells/src/main/java/dmg/util/command/AcCommandScanner.java,"/**
     * Scan for help fields: fh_(= full help) or hh_(= help hint).
     */",30-71,"('scanFields', {'INSTRUCTION': {'covered': 74, 'missed': 2}, 'BRANCH': {'covered': 9, 'missed': 3}, 'LINE': {'covered': 21, 'missed': 2}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",199.0,19.0,Scan for help fields: fh_(= full help) or hh_(= help hint).,Allows you to scan for help fields: fh_(= full help) or hh_(= help hint).,Scan for help fields: fh_(full help) or hh_(help hint).,0.643584897892085,  Look for the help fields: fh_(= full help) or hh_(= help index).,"private static void scanFields(Object obj, Map<List<String>, AcCommandExecutor> commands){
        for (Field field : obj.getClass().getDeclaredFields()) {
            if (field.getType() == String.class) {
                String name = field.getName();
                if (name.startsWith(""fh_"")) {
                    String command = name.substring(3);
                    String help = getFieldValue(obj, field);
                    commands.put(Lists.newArrayList(command), new AcCommandExecutor(command, help));
                } else if (name.startsWith(""hh_"")) {
                    String command = name.substring(3);
                    String help = getFieldValue(obj, field);
                    commands.put(Lists.newArrayList(command), new AcCommandExecutor(command, help, true));
                }
            }
        }       
 }","private static void scanFields(Object obj, Map<List<String>, AcCommandExecutor> commands){
        Field[] fields = obj.getClass().getDeclaredFields();
        for (Field field : fields) {
            if (field.getType() == String.class) {
                String name = field.getName();
                if (name.startsWith(""fh_"")) {
                    String command = name.substring(3);
                    String help = getFieldValue(obj, field);
                    commands.put(Lists.newArrayList(command), new AcCommandExecutor(command, help));
                } else if (name.startsWith(""hh_"")) {
                    String command = name.substring(3);
                    String help = getFieldValue(obj, field);
                    commands.put(Lists.newArrayList(command), new AcCommandExecutor(command, help, FieldType.HELP_HINT));
                }
            }
        }       
 }","private static void scanFields(Object obj, Map<List<String>, AcCommandExecutor> commands){
        for (Field field : obj.getClass().getDeclaredFields()) {
            if (field.getName().startsWith(""fh_"") || field.getName().startsWith(""hh_"")) {
                String name = field.getName().substring(3);
                FieldType type = field.getName().startsWith(""fh_"") ? FieldType.FULL_HELP : FieldType.HELP_HINT;
                try {
                    field.setAccessible(true);
                    String help = (String) field.get(obj);
                    if (help != null) {
                        commands.put(Lists.newArrayList(name), new AcCommandExecutor(name, help, type));
                    }
                } catch (IllegalAccessException e) {
                    throw new RuntimeException(""Cannot access field "" + field.getName(), e);
                }
            }
        }       
 }","private static void scanFields(Object obj, Map<List<String>, AcCommandExecutor> commands){
        for (Field field : obj.getClass().getDeclaredFields()) {
            if (field.getName().startsWith(""fh_"")) {
                String name = field.getName().substring(3);
                String help = (String) getField(obj, field);
                commands.put(Lists.newArrayList(name), new AcCommandExecutor(name, help));
            } else if (field.getName().startsWith(""hh_"")) {
                String name = field.getName().substring(3);
                String help = (String) getField(obj, field);
                commands.put(Lists.newArrayList(name), new AcCommandExecutor(name, help));
            }
        }       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.38465018301217657,  0.36638169554131145,  0.34173243582092083,  0.38344804053952686,124.0,0.62,132.0,0.66,121.0,0.605,121.0,0.605,15.0,0.08522727272727272,46.0,0.2754491017964072,92.0,0.5227272727272727,4.0,0.26666666666666666,3.0,0.23076923076923078,4.0,0.3333333333333333
27,egeria,"private Optional<EntityDetail> findSchemaAttributeEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, SCHEMA_ATTRIBUTE_TYPE_NAME);
}",findSchemaAttributeEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineSchemaAttributeHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineSchemaAttributeHandler.java,"/**
     * Find out if the SchemaAttribute object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",66-82,"('findSchemaAttributeEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,13.0,Find out if the SchemaAttribute object is already stored in the repository., It uses the fully qualified name to retrieve the entity. It allows you to find out if the  SchemaAttribute object is already stored in the repository.  ,"If the object is already in the repository, you should find it.",0.154956691436665,  Find out if the SchemaAttribute object is already stored in the repository.," private Optional<EntityDetail> findSchemaAttributeEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        invalidParameterHandler.validateUserId(userId, serverName);
        invalidParameterHandler.validateName(qualifiedName, ""qualifiedName"");
    
        return schemaAttributeHandler.findSchemaAttributeEntity(userId, qualifiedName);     
 }"," private Optional<EntityDetail> findSchemaAttributeEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        EntityDetail entity = null;
        if (qualifiedName != null) {
            entity = repositoryHelper.getEntityForName(userId, qualifiedName, null);
        }
        return Optional.ofNullable(entity);     
 }"," private Optional<EntityDetail> findSchemaAttributeEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        return schemaAttributeHandler.findSchemaAttributeEntity(userId, qualifiedName);     
 }"," private Optional<EntityDetail> findSchemaAttributeEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        return schemaAttributeHandler.findEntityByGUID(userId, qualifiedName);      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7166529591230651,  0.710466521600377,  0.785281802170068,  0.785281802170068,21.0,0.42,26.0,0.4642857142857143,4.0,0.11764705882352941,4.0,0.11764705882352941,23.0,0.4107142857142857,19.0,0.38,18.0,0.36,15.0,0.5555555555555556,0.0,0.0,10.0,0.7692307692307693
28,soul,"public ShenyuAdminResult deletePluginHandles(@RequestBody @NotEmpty final List<@NotBlank String> ids){
    return ShenyuAdminResult.success(ShenyuResultMessage.DELETE_SUCCESS, pluginHandleService.deletePluginHandles(ids));
}",deletePluginHandles,org/apache/shenyu/admin/controller/PluginHandleController.java,/shenyu-admin/src/main/java/org/apache/shenyu/admin/controller/PluginHandleController.java,"/**
     * batch delete some plugin handles by some id list.
     * @param ids plugin handle id list.
     * @return {@linkplain ShenyuAdminResult}
     */",118-126,"('deletePluginHandles', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,10.0,batch delete some plugin handles by some id list.,from a list of ids batch delete some plugin handles.,Some handles by an id list are deleted.,0.455063560781009,  delete in batches some plugin descriptors by a list of identifiers.," public ShenyuAdminResult deletePluginHandles(@RequestBody @NotEmpty final List<@NotBlank String> ids){
        return ShenyuAdminResult.success(ShenyuResultMessage.DELETE_SUCCESS, pluginHandleService.deleteByIds(ids));     
 }"," public ShenyuAdminResult deletePluginHandles(@RequestBody @NotEmpty final List<@NotBlank String> ids){
        return ShenyuAdminResult.success(ShenyuResultMessage.DELETE_SUCCESS, pluginHandleService.deleteByIds(ids));     
 }"," public ShenyuAdminResult deletePluginHandles(@RequestBody @NotEmpty final List<@NotBlank String> ids){
        return ShenyuAdminResult.success(ShenyuResultMessage.DELETE_SUCCESS, pluginHandleService.deleteByIds(ids));     
 }"," public ShenyuAdminResult deletePluginHandles(@RequestBody @NotEmpty final List<@NotBlank String> ids){
        return ShenyuAdminResult.success(ShenyuResultMessage.DELETE_SUCCESS, pluginHandleService.deleteByIds(ids));     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8382880831918131,  0.8382880831918131,  0.8382880831918131,  0.8382880831918131,1.0,0.02702702702702703,1.0,0.02702702702702703,1.0,0.02702702702702703,1.0,0.02702702702702703,0.0,0.0,0.0,0.0,0.0,0.0,9.0,0.8181818181818182,8.0,0.6666666666666666,8.0,0.8
29,openapi-generator,"public static JsonNode readWithInfo(String location, List<AuthorizationValue> auths) throws Exception{
    String data;
    location = location.replaceAll(""\\\\"", ""/"");
    if (location.toLowerCase(Locale.ROOT).startsWith(""http"")) {
        data = RemoteUrl.urlToString(location, auths);
    } else {
        final String fileScheme = ""file:"";
        Path path;
        if (location.toLowerCase(Locale.ROOT).startsWith(fileScheme)) {
            path = Paths.get(URI.create(location));
        } else {
            path = Paths.get(location);
        }
        if (Files.exists(path)) {
            data = FileUtils.readFileToString(path.toFile(), ""UTF-8"");
        } else {
            data = ClasspathHelper.loadFileFromClasspath(location);
        }
    }
    return getRightMapper(data).readTree(data);
}",readWithInfo,org/openapitools/codegen/utils/ModelUtils.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ModelUtils.java,"/**
     * Parse and return a JsonNode representation of the input OAS document.
     *
     * @param location the URL of the OAS document.
     * @param auths the list of authorization values to access the remote URL.
     *
     * @throws java.lang.Exception if an error occurs while retrieving the OpenAPI document.
     *
     * @return A JsonNode representation of the input OAS document.
     */",1608-1638,"('readWithInfo', {'INSTRUCTION': {'covered': 40, 'missed': 13}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 8, 'missed': 3}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",166.0,12.0,Parse and return a JsonNode representation of the input OAS document.,Allows you to parse and return a JsonNode representation of the OAS document given  as input. The method returns a JsonNode representation of the OAS document  given as input. Otherwise if an error occurs during retrieval of the OpenAPI term  document with java.lang.Exception.   ,Return a representation of the OAS document.,0.134081871383596,  Analyze and return a JsonNode representation of the input OAS document.," public static JsonNode readWithInfo(String location, List<AuthorizationValue> auths) throws Exception{
        JsonNode node = null;
        try {
            node = read(location, auths);
        } catch (Exception e) {
            throw new Exception(""Error reading OAS document from "" + location + "": "" + e.getMessage(), e);
        }
        return node;        
 }"," public static JsonNode readWithInfo(String location, List<AuthorizationValue> auths) throws Exception{
        return readWithInfo(location, auths, null);     
 }"," public static JsonNode readWithInfo(String location, List<AuthorizationValue> auths) throws Exception{
        return readWithInfo(location, auths, null);     
 }"," public static JsonNode readWithInfo(String location, List<AuthorizationValue> auths) throws Exception{
        JsonNode node = null;
        try {
            node = read(location, auths);
        } catch (Exception e) {
            throw new Exception(""Error reading OAS document: "" + e.getMessage());
        }
        return node;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.181142859389408,  0.1087098611168663,  0.17134458808552952,  0.1087098611168663,123.0,0.7365269461077845,141.0,0.844311377245509,125.0,0.7485029940119761,141.0,0.844311377245509,39.0,0.6,7.0,0.1076923076923077,39.0,0.6,35.0,0.7954545454545454,1.0,0.08333333333333333,5.0,0.4166666666666667
30,matsim-libs,"public final void addStrategy(final PlanStrategy strategy, final String subpopulation, final double weight){
    delegate.addStrategy(strategy, subpopulation, weight);
}",addStrategy,org/matsim/core/replanning/StrategyManager.java,/matsim/src/main/java/org/matsim/core/replanning/StrategyManager.java,"/**
	 * Adds a strategy to this manager with the specified weight. This weight
	 * compared to the sum of weights of all strategies in this manager defines
	 * the probability this strategy will be used for an agent.
	 *
	 */",109-120,"('addStrategy', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,11.0,Adds a strategy to this manager with the specified weight., Allows a strategy to be added to this manager with the specified weight.  The probability of this strategy being used for an agent is defined   by this weight relative to the sum of the weights of all strategies in this manager.,The manager has a strategy with a specified weight.,0.304590973756266,  Adds a policy to this handler with the specified weight.," public final void addStrategy(final PlanStrategy strategy, final String subpopulation, final double weight){
	 	delegate.addStrategy(strategy, subpopulation, weight);		
 }"," public final void addStrategy(final PlanStrategy strategy, final String subpopulation, final double weight){
	 	delegate.addStrategy(strategy, subpopulation, weight);		
 }"," public final void addStrategy(final PlanStrategy strategy, final String subpopulation, final double weight){
	 		delegate.addStrategy(strategy, subpopulation, weight);
 	}"," public final void addStrategy(final PlanStrategy strategy, final String subpopulation, final double weight){
	 		delegate.addStrategy(strategy, subpopulation, weight);
 	}		",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,32.0,0.7619047619047619,2.0,0.18181818181818182,7.0,0.6363636363636364
32,cdk,"public List<Permutation> transversal(final PermutationGroup subgroup){
    final long m = this.order() / subgroup.order();
    final List<Permutation> results = new ArrayList<Permutation>();
    Backtracker transversalBacktracker = new Backtracker() {

        private boolean finished = false;

        @Override
        public void applyTo(Permutation p) {
            for (Permutation f : results) {
                Permutation h = f.invert().multiply(p);
                if (subgroup.test(h) == size) {
                    return;
                }
            }
            results.add(p);
            if (results.size() >= m) {
                this.finished = true;
            }
        }

        @Override
        public boolean isFinished() {
            return finished;
        }
    };
    this.apply(transversalBacktracker);
    return results;
}",transversal,org/openscience/cdk/group/PermutationGroup.java,/tool/group/src/main/java/org/openscience/cdk/group/PermutationGroup.java,"/**
     * Generate a transversal of a subgroup in this group.
     *
     * @param subgroup the subgroup to use for the transversal
     * @return a list of permutations
     */",241-276,"('transversal', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",156.0,10.0,Generate a transversal of a subgroup in this group.,Allows you to generate a transversal of a subgroup of the following group,A subgroup of this group should be created.,0.266067889731676,  Generate a cross-section of a subgroup in this group.,Not Valid,Not Valid,Not Valid,"public List<Permutation> transversal(final PermutationGroup subgroup){
        List<Permutation> traversal = new ArrayList<Permutation>();
        for (int i = 0; i < size; i++) {
            if (permutations[i] != null) {
                for (int j = 0; j < size; j++) {
                    if (subgroup.permutations[i][j] != null) {
                        traversal.add(permutations[i][j]);
                    }
                }
            }
        }
        return traversal;       
 }",Not Valid,Not Valid,PASS,Not Valid,None,None,  0.23986781506835952,None,None,None,None,None,109.0,0.6942675159235668,None,None,None,None,102.0,0.9902912621359223,None,None,8.0,0.5714285714285714,1.0,0.1,8.0,0.8
33,acs-aem-commons,"public Resource decorate(final Resource resource){
    try {
        if (!this.accepts(resource)) {
            return resource;
        }
    } catch (Exception e) {
        // Logging at debug level b/c if this happens it could represent a ton of logging
        LOG.debug(""Failed binary sync check for remote asset: {}"", resource.getPath());
        return resource;
    }
    boolean syncSuccessful = false;
    if (isAlreadySyncing(resource.getPath())) {
        syncSuccessful = waitForSyncInProgress(resource);
    } else {
        syncSuccessful = syncAssetBinaries(resource);
    }
    if (syncSuccessful) {
        LOG.trace(""Refreshing resource after binary sync of {}"", resource.getPath());
        resource.getResourceResolver().refresh();
        return resource.getResourceResolver().getResource(resource.getPath());
    } else {
        return resource;
    }
}",decorate,com/adobe/acs/commons/remoteassets/impl/RemoteAssetDecorator.java,/bundle/src/main/java/com/adobe/acs/commons/remoteassets/impl/RemoteAssetDecorator.java,"/**
     * When resolving a remote asset, first sync the asset from the remote server.
     * @param resource The resource being resolved.
     * @return The current resource.  If the resource is a ""remote"" asset, it will
     * first be converted to a true local AEM asset by sync'ing in the rendition
     * binaries from the remote server.
     */",76-108,"('decorate', {'INSTRUCTION': {'covered': 49, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",137.0,15.0,"When resolving a remote asset, first sync the asset from the remote server.",In first it is necessary to synchronize the resource from the remote server when  resolving a remote resource,"First, sync the asset from the remote server.",0.104527623499358,"  When resolving a remote resource, first synchronize the resource from the remote server."," public Resource decorate(final Resource resource){
        if (resource == null) {
            return null;
        }
    
        if (resource.getPath().startsWith(config.getRemoteAssetPath())) {
            if (remoteResourcesSyncing.contains(resource.getPath())) {
                LOG.debug(""Skipping sync of remote asset {} because it is already syncing"", resource.getPath());
                return resource;
            }
    
            remoteResourcesSyncing.add(resource.getPath());
            LOG.debug(""Syncing remote asset {}"", resource.getPath());
            try {
                assetSync.syncAsset(resource);
            } catch (Exception e) {
                LOG.error(""Error syncing remote asset {}"", resource.getPath(), e);
            } finally {
                remoteResourcesSyncing.remove(resource.getPath());
            }
        }
    
        return resource;
    }"," public Resource decorate(final Resource resource){
        if (resource == null) {
            return resource;
        }
    
        if (resource.getPath().startsWith(config.getRemoteAssetPath())) {
            if (remoteResourcesSyncing.contains(resource.getPath())) {
                return resource;
            }
    
            remoteResourcesSyncing.add(resource.getPath());
    
            try {
                ResourceResolver resolver = resource.getResourceResolver();
                Session session = resolver.adaptTo(Session.class);
                if (session == null) {
                    return resource;
                }
    
                UserManager userManager = AccessControlUtil.getUserManager(session);
                if (userManager == null) {
                    return resource;
                }
    
                User user = userManager.getAuthorizable(ADMIN_ID);
                if (user == null) {
                    return resource;
                }
    
                ValueMap properties = resource.getValueMap();
                String remotePath = properties.get(DamConstants.PN_REMOTE_PATH, String.class);
                if (remotePath == null) {
                    return resource;
                }
    
                Calendar lastModified = properties.get(DamConstants.PN_REMOTE_LAST_MODIFIED, Calendar.class);
                if (lastModified == null) {
                    return resource;
                }
    
                Calendar lastSynced = properties.get(DamConstants.PN_REMOTE_LAST_SYNCED, Calendar.class);
                if (lastSynced == null) {
                    return resource;
                }
    
                if (lastModified.after(lastSynced)) {
                    LOG.info(""Syncing remote asset {}"", remotePath);
                    assetSync.sync(remotePath, user.getID());
                }
            } catch (RepositoryException e) {
                LOG.error(""Error decorating remote asset {}"", resource.getPath(), e);
            } finally {
                remoteResourcesSyncing.remove(resource.getPath());
            }
        }
    
        return resource;
    }"," public Resource decorate(final Resource resource){
        if (resource == null) {
            return resource;
        }
    
        if (resource.getPath().startsWith(config.getRemoteAssetsPath())) {
            LOG.debug(""Decorating remote asset: {}"", resource.getPath());
            if (remoteResourcesSyncing.contains(resource.getPath())) {
                LOG.debug(""Remote asset is already being synced: {}"", resource.getPath());
                return resource;
            }
    
            remoteResourcesSyncing.add(resource.getPath());
            try {
                syncRemoteAsset(resource);
            } catch (Exception e) {
                LOG.error(""Error syncing remote asset: {}"", resource.getPath(), e);
            } finally {
                remoteResourcesSyncing.remove(resource.getPath());
            }
        }
    
        return resource;        
 }"," public Resource decorate(final Resource resource){
        if (resource == null) {
            return resource;
        }
    
        if (resource.getPath().startsWith(config.getRemoteAssetPath())) {
            if (remoteResourcesSyncing.contains(resource.getPath())) {
                LOG.debug(""Skipping sync of remote asset {} because it is already being synced."", resource.getPath());
                return resource;
            }
    
            remoteResourcesSyncing.add(resource.getPath());
            LOG.debug(""Syncing remote asset {}."", resource.getPath());
            try {
                assetSync.sync(resource);
            } catch (Exception e) {
                LOG.error(""Error syncing remote asset {}."", resource.getPath(), e);
            } finally {
                remoteResourcesSyncing.remove(resource.getPath());
            }
        }
    
        return resource;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5692019048480833,  0.5117279966202735,  0.5876385338765253,  0.6127777482948924,82.0,0.5655172413793104,219.0,0.7087378640776699,82.0,0.5655172413793104,85.0,0.5944055944055944,182.0,0.5889967637540453,5.0,0.034482758620689655,33.0,0.22758620689655173,14.0,0.7368421052631579,3.0,0.21428571428571427,6.0,0.42857142857142855
34,cdk,"public BitSet projectG1(BitSet set){
    BitSet projection = new BitSet(getFirstGraphSize());
    CDKRNode xNode = null;
    for (int x = set.nextSetBit(0); x >= 0; x = set.nextSetBit(x + 1)) {
        xNode = getGraph().get(x);
        projection.set(xNode.getRMap().getId1());
    }
    return projection;
}",projectG1,org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,"/**
     *  Projects a CDKRGraph bitset on the source graph G1.
     * @param  set  CDKRGraph BitSet to project
     * @return      The associate BitSet in G1
     */",530-544,"('projectG1', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",83.0,10.0,Projects a CDKRGraph bitset on the source graph G1.,A set of CDKRGraph bits is projected onto the G1 source graph.  The method at this point returns BitSet associated in G1.,The bitset is on the source graph G1.,0.22479617148768,Projects a CDKRGraph bit set onto the G1 source graphic.,"public BitSet projectG1(BitSet set){
        BitSet result = new BitSet();
        for (int x = set.nextSetBit(0); x >= 0; x = set.nextSetBit(x + 1)) {
            CDKRNode xNode = getGraph().get(x);
            result.set(xNode.getRMap().getId1());
        }
        return result;      
 }","public BitSet projectG1(BitSet set){
        BitSet result = new BitSet();
        for (int x = set.nextSetBit(0); x >= 0; x = set.nextSetBit(x + 1)) {
            CDKRNode xNode = getGraph().get(x);
            result.set(xNode.getRMap().getId1());
        }
        return result;      
 }","public BitSet projectG1(BitSet set){
        BitSet result = new BitSet();
        for (int x = set.nextSetBit(0); x >= 0; x = set.nextSetBit(x + 1)) {
            CDKRNode xNode = getGraph().get(x);
            result.set(xNode.getRMap().getId1());
        }
        return result;      
 }","public BitSet projectG1(BitSet set){
        BitSet result = new BitSet();
        for (int x = set.nextSetBit(0); x >= 0; x = set.nextSetBit(x + 1)) {
            CDKRNode xNode = getGraph().get(x);
            result.set(xNode.getRMap().getId1());
        }
        return result;      
 }",PASS,PASS,PASS,PASS,  0.6833427455788493,  0.6833427455788493,  0.6833427455788493,  0.6833427455788493,12.0,0.14285714285714285,12.0,0.14285714285714285,12.0,0.14285714285714285,12.0,0.14285714285714285,0.0,0.0,0.0,0.0,0.0,0.0,18.0,0.782608695652174,6.0,0.5454545454545454,4.0,0.4
35,cdk,"private IAtomContainer readSmiles(final String line){
    try {
        return sp.parseSmiles(line);
    } catch (CDKException e) {
        logger.error(""Error while reading the SMILES from: "" + line + "", "", e);
        final IAtomContainer empty = builder.newInstance(IAtomContainer.class, 0, 0, 0, 0);
        empty.setProperty(BAD_SMILES_INPUT, line);
        empty.setTitle(suffix(line));
        return empty;
    }
}",readSmiles,org/openscience/cdk/io/iterator/IteratingSMILESReader.java,/storage/smiles/src/main/java/org/openscience/cdk/io/iterator/IteratingSMILESReader.java,"/**
     * Read the SMILES given in the input line - or return an empty container.
     *
     * @param line input line
     * @return the read container (or an empty one)
     */",162-178,"('readSmiles', {'INSTRUCTION': {'covered': 63, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,15.0,Read the SMILES given in the input line - or return an empty container.,The method in question either reads the SMILES indicated in the input line  or returns an empty container.,Return an empty container if you read the SMILES given in the input line.,0.641183155229738,  Read the SMILES given in the input line - or return an empty container.,"private IAtomContainer readSmiles(final String line){
        IAtomContainer molecule = null;
        try {
            String suffix = suffix(line);
            String smiles = line.substring(0, line.length() - suffix.length());
            molecule = sp.parseSmiles(smiles);
            if (molecule == null) {
                molecule = builder.newInstance(IAtomContainer.class);
                molecule.setProperty(BAD_SMILES_INPUT, smiles);
            }
            molecule.setProperty(CDKConstants.TITLE, suffix);
        } catch (Exception exception) {
            logger.error(""Unexpected problem: "", exception.getMessage());
            logger.debug(exception);
            molecule = builder.newInstance(IAtomContainer.class);
            molecule.setProperty(BAD_SMILES_INPUT, line);
        }
        return molecule;
    }","private IAtomContainer readSmiles(final String line){
        IAtomContainer molecule = null;
        try {
            String suffix = suffix(line);
            String smiles = line.substring(0, line.length() - suffix.length());
            molecule = sp.parseSmiles(smiles);
            if (molecule == null) {
                molecule = builder.newInstance(IAtomContainer.class);
                molecule.setProperty(BAD_SMILES_INPUT, smiles);
            }
            molecule.setProperty(CDKConstants.TITLE, suffix);
        } catch (Exception exception) {
            logger.error(""Unexpected problem: "", exception.getMessage());
            logger.debug(exception);
            molecule = builder.newInstance(IAtomContainer.class);
            molecule.setProperty(BAD_SMILES_INPUT, line);
        }
        return molecule;
    }"," private IAtomContainer readSmiles(final String line){
        IAtomContainer molecule = null;
        try {
            molecule = sp.parseSmiles(line);
        } catch (Exception exception) {
            logger.error(""Unexpected problem: "", exception.getMessage());
            logger.debug(exception);
            molecule = sp.parseSmiles("""");
            molecule.setProperty(BAD_SMILES_INPUT, line);
        }
        return molecule;
    }","private IAtomContainer readSmiles(final String line){
        IAtomContainer molecule = null;
        try {
            String suffix = suffix(line);
            String smiles = line.substring(0, line.length() - suffix.length());
            molecule = sp.parseSmiles(smiles);
            molecule.setProperty(CDKConstants.TITLE, suffix);
        } catch (Exception exception) {
            logger.error(""Unexpected problem: "", exception.getMessage());
            logger.debug(exception);
            molecule = builder.newInstance(IAtomContainer.class);
            molecule.setProperty(BAD_SMILES_INPUT, line);
        }
        return molecule;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.45949170666586286,  0.45949170666586286,  0.4616123753253795,  0.3963924884728826,99.0,0.673469387755102,99.0,0.673469387755102,81.0,0.680672268907563,46.0,0.5411764705882353,0.0,0.0,28.0,0.19047619047619047,75.0,0.5102040816326531,9.0,0.47368421052631576,0.0,0.0,14.0,0.9333333333333333
37,jooby,"public static Optional<Cookie> create(@Nonnull String namespace, @Nonnull Config conf){
    if (conf.hasPath(namespace)) {
        Cookie cookie = new Cookie(conf.getString(namespace + "".name""));
        value(conf, namespace + "".value"", Config::getString, cookie::setValue);
        value(conf, namespace + "".path"", Config::getString, cookie::setPath);
        value(conf, namespace + "".domain"", Config::getString, cookie::setDomain);
        value(conf, namespace + "".secure"", Config::getBoolean, cookie::setSecure);
        value(conf, namespace + "".httpOnly"", Config::getBoolean, cookie::setHttpOnly);
        value(conf, namespace + "".maxAge"", (c, path) -> c.getDuration(path, TimeUnit.SECONDS), cookie::setMaxAge);
        value(conf, namespace + "".sameSite"", (c, path) -> SameSite.of(c.getString(path)), cookie::setSameSite);
        return Optional.of(cookie);
    }
    return Optional.empty();
}",create,io/jooby/Cookie.java,/jooby/src/main/java/io/jooby/Cookie.java,"/**
   * Attempt to create/parse a cookie from application configuration object. The namespace given
   * must be present and must defined a <code>name</code> property.
   *
   * The namespace might optionally defined: value, path, domain, secure, httpOnly and maxAge.
   *
   * @param namespace Cookie namespace/prefix.
   * @param conf Configuration object.
   * @return Parsed cookie or empty.
   */",550-575,"('create', {'INSTRUCTION': {'covered': 133, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 12, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",208.0,10.0,Attempt to create/parse a cookie from application configuration object.,"The provided namespace must be present and must define a name property.  Attempt to create/parametrize a cookie from the application configuration item. The namespace can optionally define: value, path, domain, secure, httpOnly and maxAge.",Attempt to create a cookie from an object.,0.362635528775633,  Try creating/parsing a cookie from the application configuration object.,"public static Optional<Cookie> create(@Nonnull String namespace, @Nonnull Config conf){
    String name = conf.getString(namespace + "".name"");
    if (name == null) {
      return Optional.empty();
    }
    String value = conf.getString(namespace + "".value"");
    if (value == null) {
      return Optional.empty();
    }
    String path = conf.getString(namespace + "".path"");
    if (path == null) {
      path = ""/"";
    }
    String domain = conf.getString(namespace + "".domain"");
    if (domain == null) {
      domain = """";
    }
    String sameSite = conf.getString(namespace + "".sameSite"");
    if (sameSite == null) {
      sameSite = ""Strict"";
    }
    boolean secure = conf.getBoolean(namespace + "".secure"", false);
    boolean httpOnly = conf.getBoolean(namespace + "".httpOnly"", false);
    int maxAge = conf.getInt(namespace + "".maxAge"", -1);
    return Optional.of(new Cookie(name, value, path, domain, sameSite, secure, httpOnly, maxAge));
  }"," public static Optional<Cookie> create(@Nonnull String namespace, @Nonnull Config conf){
    String name = conf.getString(namespace + "".name"");
    if(name == null){
      return Optional.empty();
    }
    String value = conf.getString(namespace + "".value"");
    if(value == null){
      return Optional.empty();
    }
    String path = conf.getString(namespace + "".path"");
    String domain = conf.getString(namespace + "".domain"");
    boolean secure = conf.getBoolean(namespace + "".secure"");
    boolean httpOnly = conf.getBoolean(namespace + "".httpOnly"");
    int maxAge = conf.getInt(namespace + "".maxAge"");
    return Optional.of(new Cookie(name, value, path, domain, secure, httpOnly, maxAge));
  }","public static Optional<Cookie> create(@Nonnull String namespace, @Nonnull Config conf){
    String name = conf.getString(""name"");
    if (name == null) {
      return Optional.empty();
    }
    String value = conf.getString(""value"");
    if (value == null) {
      return Optional.empty();
    }
    String path = conf.getString(""path"");
    if (path == null) {
      path = ""/"";
    }
    String domain = conf.getString(""domain"");
    if (domain == null) {
      domain = """";
    }
    boolean secure = conf.getBoolean(""secure"", false);
    boolean httpOnly = conf.getBoolean(""httpOnly"", false);
    int maxAge = conf.getInt(""maxAge"", -1);
    SameSite sameSite = SameSite.fromString(conf.getString(""sameSite""));
    if (sameSite == null) {
      sameSite = SameSite.NONE;
    }
    return Optional.of(new Cookie(namespace, name, value, path, domain, secure, httpOnly, maxAge, sameSite));   
 }","public static Optional<Cookie> create(@Nonnull String namespace, @Nonnull Config conf){
    String name = conf.getString(namespace + "".name"");
    if (name == null) {
      return Optional.empty();
    }
    String value = conf.getString(namespace + "".value"");
    if (value == null) {
      return Optional.empty();
    }
    String path = conf.getString(namespace + "".path"");
    if (path == null) {
      path = ""/"";
    }
    String domain = conf.getString(namespace + "".domain"");
    if (domain == null) {
      domain = """";
    }
    String sameSite = conf.getString(namespace + "".sameSite"");
    if (sameSite == null) {
      sameSite = """";
    }
    boolean secure = conf.getBoolean(namespace + "".secure"", false);
    boolean httpOnly = conf.getBoolean(namespace + "".httpOnly"", false);
    int maxAge = conf.getInt(namespace + "".maxAge"", -1);
    return Optional.of(new Cookie(name, value, path, domain, sameSite, secure, httpOnly, maxAge));    
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3598427932933263,  0.3448767031621756,  0.3598427932933263,  0.2761457848824765,163.0,0.7546296296296297,150.0,0.7177033492822966,163.0,0.7546296296296297,166.0,0.7942583732057417,57.0,0.2638888888888889,1.0,0.004629629629629629,69.0,0.3194444444444444,27.0,0.7714285714285715,4.0,0.4,3.0,0.3
38,tablesaw,"public Iterator<LocalTime> iterator(){
    return new Iterator<LocalTime>() {

        final IntIterator intIterator = intIterator();

        @Override
        public boolean hasNext() {
            return intIterator.hasNext();
        }

        @Override
        public LocalTime next() {
            return PackedLocalTime.asLocalTime(intIterator.nextInt());
        }
    };
}",iterator,tech/tablesaw/api/TimeColumn.java,/core/src/main/java/tech/tablesaw/api/TimeColumn.java,"/**
   * Returns an iterator over elements of type {@code T}.
   *
   * @return an Iterator.
   */",609-631,"('iterator', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,13.0,Returns an iterator over elements of type {@code T}.,Allows an iterator to be returned on items of type {@code T}.,An iterator is returned over elements of type @code T.,0.308572151823239,  Returns an iterator over elements of type {@code T}.,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,6.0,0.46153846153846156,0.0,0.0,6.0,0.5454545454545454
39,cdk,"private boolean lookupRingSystem(IRingSet rs, IAtomContainer molecule, boolean anon){
    if (!useIdentTemplates)
        return false;
    final IChemObjectBuilder bldr = molecule.getBuilder();
    final IAtomContainer ringSystem = bldr.newInstance(IAtomContainer.class);
    for (IAtomContainer container : rs.atomContainers()) ringSystem.add(container);
    final Set<IAtom> ringAtoms = new HashSet<>();
    for (IAtom atom : ringSystem.atoms()) ringAtoms.add(atom);
    final IAtomContainer ringWithStubs = bldr.newInstance(IAtomContainer.class);
    ringWithStubs.add(ringSystem);
    for (IBond bond : molecule.bonds()) {
        IAtom atom1 = bond.getBegin();
        IAtom atom2 = bond.getEnd();
        if (isHydrogen(atom1) || isHydrogen(atom2))
            continue;
        if (ringAtoms.contains(atom1) ^ ringAtoms.contains(atom2)) {
            ringWithStubs.addAtom(atom1);
            ringWithStubs.addAtom(atom2);
            ringWithStubs.addBond(bond);
        }
    }
    final IAtomContainer skeletonStub = clearHydrogenCounts(AtomContainerManipulator.skeleton(ringWithStubs));
    final IAtomContainer skeleton = clearHydrogenCounts(AtomContainerManipulator.skeleton(ringSystem));
    final IAtomContainer anonymous = clearHydrogenCounts(AtomContainerManipulator.anonymise(ringSystem));
    for (IAtomContainer container : Arrays.asList(skeletonStub, skeleton, anonymous)) {
        if (!anon && container == anonymous)
            continue;
        if (identityLibrary.assignLayout(container)) {
            for (int i = 0; i < ringSystem.getAtomCount(); i++) {
                IAtom atom = ringSystem.getAtom(i);
                atom.setPoint2d(container.getAtom(i).getPoint2d());
                atom.setFlag(CDKConstants.ISPLACED, true);
            }
            return true;
        }
    }
    return false;
}",lookupRingSystem,org/openscience/cdk/layout/StructureDiagramGenerator.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/StructureDiagramGenerator.java,"/**
     * Using a fast identity template library, lookup the the ring system and assign coordinates.
     * The method indicates whether a match was found and coordinates were assigned.
     *
     * @param rs       the ring set
     * @param molecule the rest of the compound
     * @param anon     check for anonmised templates
     * @return coordinates were assigned
     */",1583-1649,"('lookupRingSystem', {'INSTRUCTION': {'covered': 175, 'missed': 1}, 'BRANCH': {'covered': 22, 'missed': 2}, 'LINE': {'covered': 32, 'missed': 1}, 'COMPLEXITY': {'covered': 11, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",345.0,16.0,"Using a fast identity template library, lookup the the ring system and assign coordinates.",Search the ring system and assign coordinates using a library of fast identity models.  This method allows the user to indicate whether a match has been found and  whether coordinates have been assigned.,The ring system and coordinates can be assigned using a fast identity template library.,0.180330700980185,"  Using a library of quick identity patterns, search for the ring system and assign coordinates.",Not Valid," private boolean lookupRingSystem(IRingSet rs, IAtomContainer molecule, boolean anon){
        boolean matchFound = false;
        boolean coordinatesAssigned = false;
        for (IRing ring : rs.atomContainerSet().atomContainers()) {
            if (ring.getFlag(CDKConstants.ISRING)) {
                if (ring.getFlag(CDKConstants.ISRING)) {
                    matchFound = true;
                    coordinatesAssigned = true;
                    break;
                }
            }
        }
        if (matchFound) {
            if (anon) {
                for (IAtom atom : molecule.atoms()) {
                    atom.setFlag(CDKConstants.ISINRING, true);
                }
            }
            return coordinatesAssigned;
        }
        return false;       
 }"," private boolean lookupRingSystem(IRingSet rs, IAtomContainer molecule, boolean anon){
        if (anon) {
            if (anonRingSystems.containsKey(rs)) {
                anonRingSystems.get(rs).setCoordinates(molecule);
                return true;
            }
        } else {
            if (ringSystems.containsKey(rs)) {
                ringSystems.get(rs).setCoordinates(molecule);
                return true;
            }
        }
        return false;
    }",Not Valid,Not Valid,NOT PASS,Not Valid,NOT PASS,None,  0.1692344513586688,None,  0.12843193012786622,None,None,263.0,0.7601156069364162,None,None,286.0,0.8265895953757225,120.0,0.9917355371900827,None,None,79.0,0.9875,28.0,0.8235294117647058,7.0,0.4375,14.0,0.9333333333333333
40,cdk,"public double weight(){
    double result = 0;
    Iterator edgeIterator = edgeSet().iterator();
    while (edgeIterator.hasNext()) {
        result += ((Edge) edgeIterator.next()).getWeight();
    }
    return result;
}",weight,org/openscience/cdk/ringsearch/cyclebasis/SimpleCycle.java,/legacy/src/main/java/org/openscience/cdk/ringsearch/cyclebasis/SimpleCycle.java,"/**
     * Returns the sum of the weights of all edges in this cycle.
     *
     * @return the sum of the weights of all edges in this cycle
     */",86-98,"('weight', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,13.0,Returns the sum of the weights of all edges in this cycle.,"In relation to this loop, the sum of the weights of all edges is returned",The sum of the weights of all edges is returned.,0.413491567106878,  Returns the sum of the weights of all the edges in this cycle.,"public double weight(){
        double weight = 0;
        for (Iterator i = getEdges().iterator(); i.hasNext();) {
            Edge edge = (Edge) i.next();
            weight += edge.getWeight();
        }
        return weight;      
 }","public double weight(){
        double weight = 0;
        for (Iterator i = getEdges().iterator(); i.hasNext();) {
            Edge edge = (Edge) i.next();
            weight += edge.getWeight();
        }
        return weight;
    }","public double weight(){
        double weight = 0;
        for (Iterator i = getEdges().iterator(); i.hasNext();) {
            Edge edge = (Edge) i.next();
            weight += edge.getWeight();
        }
        return weight;      
 }","public double weight(){
        double weight = 0;
        for (Iterator i = getEdges().iterator(); i.hasNext();) {
            Edge edge = (Edge) i.next();
            weight += edge.getWeight();
        }
        return weight;      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6403754837701241,  0.6403754837701241,  0.6403754837701241,  0.6019139453085857,18.0,0.3103448275862069,18.0,0.3103448275862069,18.0,0.3103448275862069,18.0,0.3103448275862069,0.0,0.0,0.0,0.0,0.0,0.0,8.0,0.5,1.0,0.07142857142857142,5.0,0.38461538461538464
41,weblogic-kubernetes-operator,"public synchronized boolean containsCluster(String clusterName){
    if (clusterName != null) {
        for (WlsClusterConfig clusterConfig : configuredClusters) {
            if (clusterConfig.getClusterName().equals(clusterName)) {
                return true;
            }
        }
    }
    return false;
}",containsCluster,oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,"/**
   * Whether the WebLogic domain contains a cluster with the given cluster name.
   *
   * @param clusterName cluster name to be checked
   * @return True if the WebLogic domain contains a cluster with the given cluster name
   */",335-351,"('containsCluster', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,13.0,Whether the WebLogic domain contains a cluster with the given cluster name.,If the WebLogic domain includes a cluster with the given cluster name. The method returns True if the WebLogic domain in question contains  a cluster with the given cluster name,The WebLogic domain has a cluster with a name.,0.206896983892128,  If the WebLogic domain contains a cluster with the given cluster name.," public synchronized boolean containsCluster(String clusterName){
    boolean result = false;
    if (clusterName != null) {
      for (WlsClusterConfig clusterConfig : configuredClusters) {
        if (clusterConfig.getClusterName().equals(clusterName)) {
          result = true;
          break;
        }
      }
    }
    return result;
  }"," public synchronized boolean containsCluster(String clusterName){
    boolean result = false;
    if (clusterName != null && configuredClusters != null) {
      for (WlsClusterConfig clusterConfig : configuredClusters) {
        if (clusterConfig.getClusterName().equals(clusterName)) {
          result = true;
          break;
        }
      }
    }
    return result;    
 }"," public synchronized boolean containsCluster(String clusterName){
    return getClusterConfig(clusterName) != null;   
 }"," public synchronized boolean containsCluster(String clusterName){
    return getClusterConfig(clusterName) != null;   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.786937027434261,  0.7606870778714875,  0.22696011733360308,  0.22696011733360308,10.0,0.17543859649122806,14.0,0.22950819672131148,34.0,0.6938775510204082,34.0,0.6938775510204082,4.0,0.06557377049180328,42.0,0.7368421052631579,42.0,0.7368421052631579,20.0,0.6451612903225806,1.0,0.07692307692307693,6.0,0.46153846153846156
43,dataverse,"public static void updateProperties(){
    if (settingsSvc == null) {
        return;
    }
    properties.clear();
    Set<Setting> dbSettings = settingsSvc.listAll();
    dbSettings.forEach(s -> properties.put(PREFIX + ""."" + s.getName().substring(1) + (s.getLang() == null ? """" : ""."" + s.getLang()), s.getContent()));
    lastUpdate = Instant.now();
}",updateProperties,edu/harvard/iq/dataverse/settings/source/DbSettingConfigSource.java,/src/main/java/edu/harvard/iq/dataverse/settings/source/DbSettingConfigSource.java,"/**
     * Retrieve settings from the database via service and update cache.
     */",37-49,"('updateProperties', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",97.0,11.0,Retrieve settings from the database via service and update cache.,Update the cache after ever retrieving the setting from the database through the service.,Update cache and retrieve settings from the database.,0.551407905394742,  Retrieve database settings through the service and update cache.," public static void updateProperties(){
        if (settingsSvc == null) {
            logger.severe(""SettingsServiceBean not injected yet, cannot update properties"");
            return;
        }
        Set<Setting> settings = settingsSvc.findAll();
        for (Setting setting : settings) {
            properties.put(PREFIX + ""."" + setting.getKey(), setting.getValue());
        }
        lastUpdate = Instant.now();     
 }"," public static void updateProperties(){
        if (settingsSvc == null) {
            logger.severe(""SettingsServiceBean not injected yet, cannot update properties"");
            return;
        }
        Set<Setting> settings = settingsSvc.getSettings();
        for (Setting setting : settings) {
            properties.put(PREFIX + ""."" + setting.getKey(), setting.getValue());
        }
        lastUpdate = Instant.now();
    }",Empty Method,Empty Method,NOT PASS,NOT PASS,Empty Method,Empty Method,  0.4347451736151997,  0.4347451736151997,None,None,50.0,0.5102040816326531,50.0,0.5102040816326531,None,None,None,None,1.0,0.013157894736842105,None,None,None,None,13.0,0.8666666666666667,4.0,0.36363636363636365,10.0,0.9090909090909091
44,liquibase,"protected String[] fixupArgs(String[] args){
    List<String> fixedArgs = new ArrayList<>();
    for (int i = 0; i < args.length; i++) {
        String arg = args[i];
        if ((arg.startsWith(""--"") || arg.startsWith(""-D"")) && !arg.contains(""="")) {
            String nextArg = null;
            if ((i + 1) < args.length) {
                nextArg = args[i + 1];
            }
            if ((nextArg != null) && !nextArg.startsWith(""--"") && !isCommand(nextArg)) {
                arg = arg + ""="" + nextArg;
                i++;
            }
        }
        arg = arg.replace(""\\,"", "","");
        fixedArgs.add(arg);
    }
    return fixedArgs.toArray(new String[fixedArgs.size()]);
}",fixupArgs,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,"/**
     * On windows machines, it splits args on '=' signs.  Put it back like it was.
     */",814-839,"('fixupArgs', {'INSTRUCTION': {'covered': 79, 'missed': 0}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",177.0,12.0,"On windows machines, it splits args on '=' signs.","The method in question, to bring everything back to the way it was before,  on Windows computers, divides the arguments on the '=' signs",It splits args on windows machines.,0.487332402409288,"  On Windows machines, it divides the args on the '=' signs.","protected String[] fixupArgs(String[] args){
        if (System.getProperty(""os.name"").toLowerCase().contains(""windows"")) {
            List<String> newArgs = new ArrayList<>();
            for (String arg : args) {
                if (arg.contains(""="")) {
                    String[] split = arg.split(""="");
                    newArgs.add(split[0]);
                    newArgs.add(split[1]);
                } else {
                    newArgs.add(arg);
                }
            }
            return newArgs.toArray(new String[newArgs.size()]);
        }
        return args;
    }","protected String[] fixupArgs(String[] args){
        String[] newArgs = new String[args.length];
        for (int i = 0; i < args.length; i++) {
            String arg = args[i];
            if (arg.contains(""="")) {
                String[] split = arg.split(""="");
                newArgs[i] = split[0];
                newArgs[i+1] = split[1];
                i++;
            } else {
                newArgs[i] = arg;
            }
        }
        return newArgs;
    }",Not Valid,"protected String[] fixupArgs(String[] args){
        if (System.getProperty(""os.name"").toLowerCase().contains(""windows"")) {
            for (int i = 0; i < args.length; i++) {
                if (args[i].contains(""="")) {
                    String[] newArgs = new String[args.length + 1];
                    System.arraycopy(args, 0, newArgs, 0, i);
                    newArgs[i] = args[i].substring(0, args[i].indexOf('='));
                    newArgs[i + 1] = args[i].substring(args[i].indexOf('=') + 1);
                    args = newArgs;
                }
            }
        }
        return args;
    }",NOT PASS,NOT PASS,NOT PASS,Not Valid,  0.3379556147509206,  0.324155726346801,  0.3572117125019628,None,120.0,0.6741573033707865,109.0,0.6123595505617978,126.0,0.7078651685393258,None,None,73.0,0.5703125,84.0,0.5419354838709678,None,None,21.0,0.84,4.0,0.3333333333333333,6.0,0.6
45,acs-aem-commons,"private boolean matches(List<Pattern> patterns, String data){
    for (Pattern pattern : patterns) {
        final Matcher matcher = pattern.matcher(data);
        if (matcher.matches()) {
            return true;
        }
    }
    return false;
}",matches,com/adobe/acs/commons/httpcache/config/impl/HttpCacheConfigImpl.java,/bundle/src/main/java/com/adobe/acs/commons/httpcache/config/impl/HttpCacheConfigImpl.java,"/**
     * Matching the given data with the set of compiled patterns.
     *
     * @param patterns
     * @param data
     * @return
     */",385-401,"('matches', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,11.0,Matching the given data with the set of compiled patterns.,Corresponds to the data provided with the set of completed models.,The data and compiled patterns are matched.,0.234644423224815,  Match the data with all compiled models.," private boolean matches(List<Pattern> patterns, String data){
        for (Pattern pattern : patterns) {
            if (pattern.matcher(data).matches()) {
                return true;
            }
        }
        return false;
    }"," private boolean matches(List<Pattern> patterns, String data){
        for (Pattern pattern : patterns) {
            if (pattern.matcher(data).matches()) {
                return true;
            }
        }
        return false;
    }"," private boolean matches(List<Pattern> patterns, String data){
        for (Pattern pattern : patterns) {
            if (pattern.matcher(data).matches()) {
                return true;
            }
        }
        return false;
    }"," private boolean matches(List<Pattern> patterns, String data){
        for (Pattern pattern : patterns) {
            if (pattern.matcher(data).matches()) {
                return true;
            }
        }
        return false;
    }",PASS,PASS,PASS,PASS,  0.7576099507486102,  0.7576099507486102,  0.7576099507486102,  0.7576099507486102,8.0,0.15384615384615385,8.0,0.15384615384615385,8.0,0.15384615384615385,8.0,0.15384615384615385,0.0,0.0,0.0,0.0,0.0,0.0,6.0,0.5,6.0,0.5454545454545454,9.0,0.8181818181818182
48,glowstone,"public boolean readInt(@NonNls String key, IntConsumer consumer){
    if (isInt(key)) {
        consumer.accept(getInt(key));
        return true;
    }
    return false;
}",readInt,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to an integer subtag if it is present.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */",404-418,"('readInt', {'INSTRUCTION': {'covered': 11, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,13.0,Applies the given function to an integer subtag if it is present.,"In the case where an integer subtag is present, the date function is applied. ","If the function is present, apply it to the subtag.",0.463002178584216,  Applies the given function to an entire subtag if it is present.," public boolean readInt(@NonNls String key, IntConsumer consumer){
        // Avoid boxing by not delegating to readTag
        if (isInt(key)) {
            consumer.accept(getInt(key));
            return true;
        }
        return false;
    }"," public boolean readInt(@NonNls String key, IntConsumer consumer){
        // Avoid boxing by not delegating to readTag
        if (isInt(key)) {
            consumer.accept(getInt(key));
            return true;
        }
        return false;
    }"," public boolean readInt(@NonNls String key, IntConsumer consumer){
        return readTag(key, IntTag.class, consumer);        
 }"," public boolean readInt(@NonNls String key, IntConsumer consumer){
        // Avoid boxing by not delegating to readTag
        if (isInt(key)) {
            consumer.accept(getInt(key));
            return true;
        }
        return false;
    }",PASS,PASS,PASS,NOT PASS,  1.0,  1.0,  1.0,  0.4742209755169855,0.0,0.0,0.0,0.0,0.0,0.0,20.0,0.5,0.0,0.0,0.0,0.0,20.0,0.5,10.0,0.6666666666666666,1.0,0.07692307692307693,10.0,0.7692307692307693
50,matsim-libs,"public double calculate(DrtRequest drtRequest, InsertionWithDetourData<D> insertion){
    // TODO precompute time slacks for each stop to filter out even more infeasible insertions ???????????
    var detourTimeInfo = detourTimeCalculator.calculateDetourTimeInfo(insertion);
    if (!checkTimeConstraintsForScheduledRequests(insertion.getInsertion(), detourTimeInfo.pickupTimeLoss, detourTimeInfo.getTotalTimeLoss())) {
        return INFEASIBLE_SOLUTION_COST;
    }
    double vehicleSlackTime = calcVehicleSlackTime(insertion.getVehicleEntry(), timeOfDay.getAsDouble());
    return costCalculationStrategy.calcCost(drtRequest, insertion.getInsertion(), vehicleSlackTime, detourTimeInfo);
}",calculate,org/matsim/contrib/drt/optimizer/insertion/InsertionCostCalculator.java,/contribs/drt/src/main/java/org/matsim/contrib/drt/optimizer/insertion/InsertionCostCalculator.java,"/**
	 * As the main goal is to minimise bus operation time, this method calculates how much longer the bus will operate
	 * after insertion. By returning INFEASIBLE_SOLUTION_COST, the insertion is considered infeasible
	 * <p>
	 * The insertion is invalid if some maxTravel/Wait constraints for the already scheduled requests are not fulfilled.
	 * This is denoted by returning INFEASIBLE_SOLUTION_COST.
	 * <p>
	 *
	 * @param drtRequest the request
	 * @param insertion  the insertion to be considered here
	 * @return cost of insertion (INFEASIBLE_SOLUTION_COST represents an infeasible insertion)
	 */",87-111,"('calculate', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,24.0,"As the main goal is to minimise bus operation time, this method calculates how much longer the bus will operate  after insertion.","This method calculates the bus travel time after insertion,  with the goal of minimizing the bus travel time.  In case the insertion is considered infeasible, it returns INFEASIBLE_SOLUTION_COST  If certain maxTravel/Wait constraints for already scheduled requests are not met the entry is invalid. This is indicated with the return INFEASIBLE_SOLUTION_COST.""","The main goal is to reduce bus operation time, and this method calculates how long the bus will operate after the introduction.",0.5624203466937,"  As the main goal is to minimize the operating time of the bus, this method calculates how long the bus will still run after insertion."," public double calculate(DrtRequest drtRequest, InsertionWithDetourData<D> insertion){
	 		double departureTime = insertion.getDepartureTime();
 		double arrivalTime = insertion.getArrivalTime();
 		double pickupTimeLoss = insertion.getPickupTimeLoss();
 		double dropoffTimeLoss = insertion.getDropoffTimeLoss();
 		double totalTimeLoss = pickupTimeLoss + dropoffTimeLoss;
 		double detourTime = detourTimeCalculator.calculate(insertion.getDetourData());
 		double cost = costCalculationStrategy.calculate(departureTime, arrivalTime, pickupTimeLoss, dropoffTimeLoss, detourTime);
 		return cost + totalTimeLoss;
 	}"," public double calculate(DrtRequest drtRequest, InsertionWithDetourData<D> insertion){
	 		if (insertion.isInfeasible()) {
 			return INFEASIBLE_SOLUTION_COST;
 		}
 		
 		double departureTime = insertion.getDepartureTime();
 		double arrivalTime = insertion.getArrivalTime();
 		double pickupTimeLoss = insertion.getPickupTimeLoss();
 		double dropoffTimeLoss = insertion.getDropoffTimeLoss();
 		
 		double cost = costCalculationStrategy.calculate(drtRequest, departureTime, arrivalTime, pickupTimeLoss, dropoffTimeLoss);
 		
 		return cost;
 	}","public double calculate(DrtRequest drtRequest, InsertionWithDetourData<D> insertion){
	 		double departureTime = timeOfDay.getAsDouble();
 		double arrivalTime = departureTime + insertion.getDuration();
 		double pickupTimeLoss = 0;
 		double dropoffTimeLoss = 0;
 		double totalTimeLoss = 0;
 		
 		// calculate the time loss of each stop placed after the pickup insertion point
 		for (int i = 0; i < insertion.getPickupInsertionPoint(); i++) {
 			double stopDuration = insertion.getStopDurations().get(i);
 			pickupTimeLoss += stopDuration;
 			departureTime += stopDuration;
 		}
 		
 		// calculate the time loss of each stop placed after the dropoff insertion point
 		for (int i = 0; i < insertion.getDropoffInsertionPoint(); i++) {
 			double stopDuration = insertion.getStopDurations().get(i);
 			dropoffTimeLoss += stopDuration;
 			arrivalTime += stopDuration;
 		}
 		
 		// calculate the total time loss of each stop placed after the dropoff insertion point
 		totalTimeLoss = pickupTimeLoss + dropoffTimeLoss;
 		
 		// calculate the cost of the insertion
 		double cost = costCalculationStrategy.calculate(drtRequest, insertion);
 		
 		// return the cost of the insertion
 		return cost;
 	}"," public double calculate(DrtRequest drtRequest, InsertionWithDetourData<D> insertion){
	 		double departureTime = insertion.getDepartureTime();
 		double arrivalTime = insertion.getArrivalTime();
 		double pickupTimeLoss = insertion.getPickupTimeLoss();
 		double dropoffTimeLoss = insertion.getDropoffTimeLoss();
 		double totalTimeLoss = pickupTimeLoss + dropoffTimeLoss;
 		double timeOfDay = this.timeOfDay.getAsDouble();
 		double timeLoss = timeOfDay - departureTime;
 		double cost = costCalculationStrategy.calculate(timeLoss, totalTimeLoss);
 		return cost;
 	}",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4043170099070885,  0.44347855350279775,  0.39745217803345656,  0.3816001621132499,58.0,0.6041666666666666,53.0,0.5955056179775281,56.0,0.6086956521739131,109.0,0.6987179487179487,34.0,0.3541666666666667,23.0,0.23958333333333334,92.0,0.5897435897435898,46.0,0.9019607843137255,11.0,0.4230769230769231,8.0,0.34782608695652173
51,weblogic-kubernetes-operator,"public List<T> split(Map<String, String> data){
    startSplitResult();
    for (DataEntry dataEntry : getSortedEntrySizes(data)) {
        addToSplitResult(dataEntry);
    }
    recordSplitResult();
    recordTargetInfo(result.get(0), result.size());
    return result;
}",split,oracle/kubernetes/operator/helpers/ConfigMapSplitter.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/ConfigMapSplitter.java,"/**
   * Given a map, splits it so that no map has more total data than the specified limit, and returns a list of
   * target objects built from the resultant maps. This may result in some maps receiving partial value for the largest
   * items. If the target type implements CountRecorder, the 'recordCount' method of the first target will be invoked
   * with the number of targets created.
   *
   * @param data the map to split.
   */",45-62,"('split', {'INSTRUCTION': {'covered': 33, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,32.0,"Given a map, splits it so that no map has more total data than the specified limit, and returns a list of  target objects built from the resultant maps.",The method in question splits the input map with the goal that no map has more total data than the specified limit. It then returns a list of target objects constructed from the resulting maps. In some cases it may happen that some maps get a partial value for larger elements.  The 'recordCount' method of the first target will be invoked with the number of targets  created if the target type implements CountRecorder,"If you give a map, it splits it so that no map has more data than the limit, and returns a list of target objects.",0.35231159253648,"  Given a map, divide it so that no map has more total data than the specified limit and returns a list of target objects built from the resulting maps."," public List<T> split(Map<String, String> data){
    current = new HashMap<>();
    remainingRoom = DATA_LIMIT;
    result.clear();
    split(data);
    return result;
  }"," public List<T> split(Map<String, String> data){
    current = new HashMap<>();
    remainingRoom = DATA_LIMIT;
    for (Map.Entry<String, String> entry : data.entrySet()) {
      String key = entry.getKey();
      String value = entry.getValue();
      if (remainingRoom < value.length()) {
        result.add(factory.apply(current, result.size()));
        current = new HashMap<>();
        remainingRoom = DATA_LIMIT;
      }
      current.put(key, value);
      remainingRoom -= value.length();
    }
    result.add(factory.apply(current, result.size()));
    return result;
  }"," public List<T> split(Map<String, String> data){
    current = new HashMap<>();
    remainingRoom = DATA_LIMIT;
    data.forEach((key, value) -> add(key, value));
    return result;    
 }"," public List<T> split(Map<String, String> data){
    current = new HashMap<>();
    remainingRoom = DATA_LIMIT;
    for (Map.Entry<String, String> entry : data.entrySet()) {
      add(entry.getKey(), entry.getValue());
    }
    result.add(factory.apply(current, remainingRoom));
    return result;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.45538371324037447,  0.4467095457198066,  0.4372356518640589,  0.35209201708493565,30.0,0.4838709677419355,100.0,0.6666666666666666,43.0,0.5180722891566265,33.0,0.532258064516129,108.0,0.72,42.0,0.5060240963855421,12.0,0.23076923076923078,53.0,0.7162162162162162,3.0,0.1,12.0,0.4
52,cdk,"private IChemModel readChemModel(IChemModel chemModel) throws CDKException{
    IReactionSet setOfReactions = chemModel.getReactionSet();
    if (setOfReactions == null) {
        setOfReactions = chemModel.getBuilder().newInstance(IReactionSet.class);
    }
    chemModel.setReactionSet(readReactionSet(setOfReactions));
    return chemModel;
}",readChemModel,org/openscience/cdk/io/MDLRXNReader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLRXNReader.java,"/**
    * Read a IChemModel from a file in MDL RDF format.
    *
    * @param  chemModel The IChemModel
    * @return           The IChemModel that was read from the RDF file
    */",192-205,"('readChemModel', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",56.0,11.0,Read a IChemModel from a file in MDL RDF format.,From a file in MDL format RDF reads an IChemModel,The IChemModel is in MDL RDF format.,0.192112203994705,  Read an IChemModel from a file in MDL RDF format.," private IChemModel readChemModel(IChemModel chemModel) throws CDKException{
        IReactionSet reactionSet = chemModel.getBuilder().newInstance(IReactionSet.class);
        reactionSet.setID(""DefaultReactionSet"");
        chemModel.setReactionSet(reactionSet);
        return chemModel;
    }"," private IChemModel readChemModel(IChemModel chemModel) throws CDKException{
        IChemSequence chemSequence = chemModel.getBuilder().newInstance(IChemSequence.class);
        chemSequence.addChemModel(chemModel);
        return chemModel;       
 }",Not Valid," private IChemModel readChemModel(IChemModel chemModel) throws CDKException{
        logger.info(""Reading MDL RXN file..."");
        IReactionSet reactionSet = chemModel.getBuilder().newInstance(IReactionSet.class);
        reactionSet = readReactionSet(reactionSet);
        chemModel.setReactionSet(reactionSet);
        return chemModel;
    }",NOT PASS,NOT PASS,PASS,Not Valid,  0.5246736240197634,  0.46052870399027523,  0.554531318887354,None,24.0,0.42105263157894735,25.0,0.43859649122807015,25.0,0.43859649122807015,None,None,12.0,0.26666666666666666,10.0,0.19230769230769232,None,None,8.0,0.7272727272727273,1.0,0.09090909090909091,5.0,0.45454545454545453
53,cdk,"public Permutation invert(){
    Permutation inversion = new Permutation(values.length);
    for (int i = 0; i < values.length; i++) {
        inversion.values[this.values[i]] = i;
    }
    return inversion;
}",invert,org/openscience/cdk/group/Permutation.java,/tool/group/src/main/java/org/openscience/cdk/group/Permutation.java,"/**
     * Invert the permutation, so that for all i : inv[p[i]] = i.
     *
     * @return the inverse of this permutation
     */",212-223,"('invert', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,20.0,"Invert the permutation, so that for all i : inv[p[i]] = i.",In order that for all i : inv[p[i]] = i the following method reverses the permutation,"For all, Invert the permutation.",0.433356573948511,"  Reverse the permutation, so that for all i: inv[p[i]] = i.","public Permutation invert(){
        Permutation newPermutation = new Permutation(values.length);
        for (int i = 0; i < values.length; i++) {
            newPermutation.values[values[i]] = i;
        }
        return newPermutation;
    }","public Permutation invert(){
        Permutation newPermutation = new Permutation(values.length);
        for (int i = 0; i < values.length; i++) {
            newPermutation.values[this.values[i]] = i;
        }
        return newPermutation;
    }","public Permutation invert(){
        Permutation newPermutation = new Permutation(values.length);
        for (int i = 0; i < values.length; i++) {
            newPermutation.values[values[i]] = i;
        }
        return newPermutation;
    }","public Permutation invert(){
        Permutation inv = new Permutation(values.length);
        for (int i = 0; i < values.length; i++) {
            inv.values[values[i]] = i;
        }
        return inv;
    }",PASS,PASS,PASS,PASS,  0.8079415012457257,  0.9288274836179495,  0.8079415012457257,  0.8079415012457257,5.0,0.09259259259259259,3.0,0.05555555555555555,5.0,0.09259259259259259,5.0,0.09259259259259259,2.0,0.037037037037037035,3.0,0.057692307692307696,0.0,0.0,11.0,0.6470588235294118,3.0,0.23076923076923078,12.0,0.9230769230769231
55,openapi-generator," void addAuthenticationSwitches(Map<String, Object> bundle){
    Map<String, SecurityScheme> securitySchemeMap = openAPI.getComponents() != null ? openAPI.getComponents().getSecuritySchemes() : null;
    List<CodegenSecurity> authMethods = config.fromSecurity(securitySchemeMap);
    if (authMethods != null && !authMethods.isEmpty()) {
        bundle.put(""authMethods"", authMethods);
        bundle.put(""hasAuthMethods"", true);
        if (ProcessUtils.hasOAuthMethods(authMethods)) {
            bundle.put(""hasOAuthMethods"", true);
            bundle.put(""oauthMethods"", ProcessUtils.getOAuthMethods(authMethods));
        }
        if (ProcessUtils.hasHttpBearerMethods(authMethods)) {
            bundle.put(""hasHttpBearerMethods"", true);
            bundle.put(""httpBearerMethods"", ProcessUtils.getHttpBearerMethods(authMethods));
        }
        if (ProcessUtils.hasHttpSignatureMethods(authMethods)) {
            bundle.put(""hasHttpSignatureMethods"", true);
            bundle.put(""httpSignatureMethods"", ProcessUtils.getHttpSignatureMethods(authMethods));
        }
        if (ProcessUtils.hasHttpBasicMethods(authMethods)) {
            bundle.put(""hasHttpBasicMethods"", true);
            bundle.put(""httpBasicMethods"", ProcessUtils.getHttpBasicMethods(authMethods));
        }
        if (ProcessUtils.hasApiKeyMethods(authMethods)) {
            bundle.put(""hasApiKeyMethods"", true);
            bundle.put(""apiKeyMethods"", ProcessUtils.getApiKeyMethods(authMethods));
        }
    }
}",addAuthenticationSwitches,org/openapitools/codegen/DefaultGenerator.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java,"/**
     * Add authentication methods to the given map
     * This adds a boolean and a collection for each authentication type to the map.
     * <p>
     * Examples:
     * <p> 
     *   boolean hasOAuthMethods
     * <p>
     *   List&lt;CodegenSecurity&gt; oauthMethods
     *
     * @param bundle the map which the booleans and collections will be added
     */",804-844,"('addAuthenticationSwitches', {'INSTRUCTION': {'covered': 83, 'missed': 25}, 'BRANCH': {'covered': 12, 'missed': 4}, 'LINE': {'covered': 17, 'missed': 4}, 'COMPLEXITY': {'covered': 5, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",257.0,22.0,Add authentication methods to the given map  This adds a boolean and a collection for each authentication type to the map.,The method in question from tthe given map allows the addition of authentication methods.  In this case a boolean and a collection for each type of  authentication is added to the map. For examples:  boolean hasOAuthMethods List&lt;CodegenSecurity&gt; oauthMethods,This adds a collection and a boolean for each type ofAuthentication to the map.,0.342279670649763,  Add authentication methods to the given card This adds a Boolean and a collection for each type of authentication to the card.,Not Valid,"void addAuthenticationSwitches(Map<String, Object> bundle){
        boolean hasOAuthMethods = false;
        boolean hasBasicAuthMethods = false;
        boolean hasApiKeyAuthMethods = false;
        boolean hasOAuth2AuthMethods = false;
        boolean hasOAuth2AccessCodeAuthMethods = false;
        boolean hasOAuth2ImplicitAuthMethods = false;
        boolean hasOAuth2PasswordAuthMethods = false;
        boolean hasOAuth2ApplicationAuthMethods = false;
        boolean hasOAuth2AccessTokenAuthMethods = false;
        boolean hasOAuth2TwoLeggedAuthMethods = false;
        boolean hasOAuth2ThreeLeggedAuthMethods = false;
        boolean hasBasicAuthMethods = false;
        boolean hasApiKeyAuthMethods = false;
        boolean hasOAuth2AuthMethods = false;
        boolean hasOAuth2AccessCodeAuthMethods = false;
        boolean hasOAuth2ImplicitAuthMethods = false;
        boolean hasOAuth2PasswordAuthMethods = false;
        boolean hasOAuth2ApplicationAuthMethods = false;
        boolean hasOAuth2AccessTokenAuthMethods = false;
        boolean hasOAuth2TwoLeggedAuthMethods = false;
        boolean hasOAuth2ThreeLeggedAuthMethods = false;
        boolean hasBasicAuthMethods = false;
        boolean hasApiKeyAuthMethods = false;
        boolean hasOAuth2AuthMethods = false;
        boolean hasOAuth2AccessCodeAuthMethods = false;
        boolean hasOAuth2ImplicitAuthMethods = false;
        boolean hasOAuth2PasswordAuthMethods = false;
        boolean hasOAuth2ApplicationAuthMethods = false;
        boolean hasOAuth2AccessTokenAuthMethods = false;
        boolean hasOAuth2TwoLeggedAuthMethods = false;
        boolean hasOAuth2ThreeLeggedAuthMethods = false;
        boolean hasBasicAuthMethods = false;
        boolean hasApiKeyAuthMethods = false;
        boolean hasOAuth2AuthMethods = false;
        boolean hasOAuth2AccessCodeAuthMethods = false;
        boolean hasOAuth2ImplicitAuthMethods = false;
        boolean hasOAuth2PasswordAuthMethods = false;
        boolean hasOAuth2ApplicationAuthMethods = false;
        boolean hasOAuth        
  }","  void addAuthenticationSwitches(Map<String, Object> bundle){
        Map<String, Boolean> authSwitches = new HashMap<>();
        for (String authType : config.getAuthTypes()) {
            authSwitches.put(authType, false);
        }
        bundle.put(""authSwitches"", authSwitches);
    }","  void addAuthenticationSwitches(Map<String, Object> bundle){
        List<CodegenSecurity> authMethods = config.fromSecurity(openAPI.getSecurity());
        if (authMethods != null && !authMethods.isEmpty()) {
            bundle.put(""hasAuthMethods"", true);
            bundle.put(""authMethods"", authMethods);
        }
    }",Not Valid,Syntax Error,NOT PASS,NOT PASS,None,None,  0.20741978580209486,  0.09453821988686047,None,None,None,None,201.0,0.7790697674418605,213.0,0.8255813953488372,None,None,63.0,0.984375,59.0,0.9833333333333333,25.0,0.6410256410256411,6.0,0.2608695652173913,11.0,0.5
56,cdk,"public void dumpSystemProperties(){
    debug(""os.name        : "" + System.getProperty(""os.name""));
    debug(""os.version     : "" + System.getProperty(""os.version""));
    debug(""os.arch        : "" + System.getProperty(""os.arch""));
    debug(""java.version   : "" + System.getProperty(""java.version""));
    debug(""java.vendor    : "" + System.getProperty(""java.vendor""));
}",dumpSystemProperties,org/openscience/cdk/tools/LoggingTool.java,/misc/log4j/src/main/java/org/openscience/cdk/tools/LoggingTool.java,"/**
     * Outputs system properties for the operating system and the java
     * version. More specifically: os.name, os.version, os.arch, java.version
     * and java.vendor.
     */",215-227,"('dumpSystemProperties', {'INSTRUCTION': {'covered': 56, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,12.0,Outputs system properties for the operating system and the java  version.,"The method allows you to get the properties of the java version  and the operating system. Specifically: os.name, os.version, os.arch, java.version and java.vendor.",The system properties are used for the operating system and java version.,0.12071628510258,  Generates the system properties of the operating system and Java version.," public void dumpSystemProperties(){
        logger.info(""Operating System: "" + System.getProperty(""os.name""));
        logger.info(""Java version: "" + System.getProperty(""java.version""));
    }"," public void dumpSystemProperties(){
        System.out.println(""os.name: "" + System.getProperty(""os.name""));
        System.out.println(""os.version: "" + System.getProperty(""os.version""));
        System.out.println(""os.arch: "" + System.getProperty(""os.arch""));
        System.out.println(""java.version: "" + System.getProperty(""java.version""));
        System.out.println(""java.vendor: "" + System.getProperty(""java.vendor""));
    }"," public void dumpSystemProperties(){
        logger.info(""System properties: "");
        Properties props = System.getProperties();
        for (Enumeration<?> e = props.propertyNames(); e.hasMoreElements();) {
            String key = (String) e.nextElement();
            logger.info(key + ""="" + props.getProperty(key));
        }
    }",Not Valid,PASS,PASS,Not Valid,NOT PASS,  0.4056850698178772,  0.714643750573658,None,  0.26089112085513266,39.0,0.5735294117647058,30.0,0.3409090909090909,None,None,49.0,0.6533333333333333,58.0,0.6590909090909091,None,None,46.0,0.6133333333333333,19.0,0.7916666666666666,5.0,0.4166666666666667,4.0,0.3076923076923077
57,mybatis-3,"public List<String> list(String path) throws IOException{
    List<String> names = new ArrayList<>();
    for (URL url : getResources(path)) {
        names.addAll(list(url, path));
    }
    return names;
}",list,org/apache/ibatis/io/VFS.java,/src/main/java/org/apache/ibatis/io/VFS.java,"/**
   * Recursively list the full resource path of all the resources that are children of all the
   * resources found at the specified path.
   *
   * @param path The path of the resource(s) to list.
   * @return A list containing the names of the child resources.
   * @throws IOException If I/O errors occur
   */",212-226,"('list', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,23.0,Recursively list the full resource path of all the resources that are children of all the  resources found at the specified path.,"Starting with all resources that are children of all resources found in the specified path, the method allows the full path to be recursively listed",List the full resource path of all the resources that are children of all the resources found at the path.,0.299864282890757,  Recursively list the full path of all resources that are children of all resources found on the specified path.," public List<String> list(String path) throws IOException{
    List<String> result = new ArrayList<>();
    for (URL url : getResources(path)) {
      result.addAll(list(url, path));
    }
    return result;
  }"," public List<String> list(String path) throws IOException{
    List<String> result = new ArrayList<>();
    for (URL url : getResources(path)) {
      result.addAll(list(url, path));
    }
    return result;    
 }"," public List<String> list(String path) throws IOException{
    List<String> result = new ArrayList<>();
    for (URL url : getResources(path)) {
      result.addAll(list(url, path));
    }
    return result;
  }"," public List<String> list(String path) throws IOException{
    List<String> result = new ArrayList<>();
    for (URL url : getResources(path)) {
      result.addAll(list(url, path));
    }
    return result;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.9300960539568801,  0.9300960539568801,  0.9300960539568801,  0.9300960539568801,3.0,0.05454545454545454,3.0,0.05454545454545454,3.0,0.05454545454545454,3.0,0.05454545454545454,0.0,0.0,0.0,0.0,0.0,0.0,21.0,0.8076923076923077,4.0,0.17391304347826086,3.0,0.13043478260869565
58,json-schema-validator,"public void combineWithCollector(String name, Object data){
    Object object = collectorMap.get(name);
    if (object instanceof Collector<?>) {
        Collector<?> collector = (Collector<?>) object;
        collector.combine(data);
    }
}",combineWithCollector,com/networknt/schema/CollectorContext.java,/src/main/java/com/networknt/schema/CollectorContext.java,"/**
     * Combines data with Collector identified by the given name.
     *
     * @param name String
     * @param data Object
     */",104-116,"('combineWithCollector', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,10.0,Combines data with Collector identified by the given name.,From the specific name given combines the data with the Collector,The data is combined with the collector.,0.222421313951726,  Combines data with collector identified by first name.," public void combineWithCollector(String name, Object data){
        collectorLoadMap.put(name, data);       
 }"," public void combineWithCollector(String name, Object data){
        if(collectorMap.get(name) instanceof Collector<?>){
            collectorLoadMap.put(name, data);
        }
    }"," public void combineWithCollector(String name, Object data){
        collectorLoadMap.put(name, data);
    }"," public void combineWithCollector(String name, Object data){
        if(collectorMap.get(name) instanceof Collector<?>){
            collectorLoadMap.put(name, data);
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2330513061276906,  0.4601993164409869,  0.4601993164409869,  0.2330513061276906,36.0,0.6545454545454545,24.0,0.43636363636363634,24.0,0.43636363636363634,36.0,0.6545454545454545,16.0,0.42105263157894735,16.0,0.42105263157894735,0.0,0.0,10.0,0.8333333333333334,3.0,0.3,7.0,0.7
59,dataverse,"public static void printAttributes(HttpServletRequest request){
    List<String> shibValues = new ArrayList<>();
    if (request == null) {
        logger.fine(""HttpServletRequest was null. No shib values to print."");
        return;
    }
    for (String attr : shibAttrs) {
        Object attrObject = request.getAttribute(attr);
        if (attrObject != null) {
            shibValues.add(attr + "": "" + attrObject.toString());
        }
    }
    logger.fine(""shib values: "" + shibValues);
}",printAttributes,edu/harvard/iq/dataverse/authorization/providers/shib/ShibUtil.java,/src/main/java/edu/harvard/iq/dataverse/authorization/providers/shib/ShibUtil.java,"/**
     * These are the attributes we are getting from the IdP at testshib.org, a
     * dump from https://pdurbin.pagekite.me/Shibboleth.sso/Session
     *
     * Miscellaneous
     *
     * Session Expiration (barring inactivity): 479 minute(s)
     *
     * Client Address: 10.0.2.2
     *
     * SSO Protocol: urn:oasis:names:tc:SAML:2.0:protocol
     *
     * Identity Provider: https://idp.testshib.org/idp/shibboleth
     *
     * Authentication Time: 2014-09-12T17:07:36.137Z
     *
     * Authentication Context Class:
     * urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport
     *
     * Authentication Context Decl: (none)
     *
     *
     *
     * Attributes
     *
     * affiliation: Member@testshib.org;Staff@testshib.org
     *
     * cn: Me Myself And I
     *
     * entitlement: urn:mace:dir:entitlement:common-lib-terms
     *
     * eppn: myself@testshib.org
     *
     * givenName: Me Myself
     *
     * persistent-id:
     * https://idp.testshib.org/idp/shibboleth!https://pdurbin.pagekite.me/shibboleth!zylzL+NruovU5OOGXDOL576jxfo=
     *
     * sn: And I
     *
     * telephoneNumber: 555-5555
     *
     * uid: myself
     *
     * unscoped-affiliation: Member;Staff
     *
     */",297-367,"('printAttributes', {'INSTRUCTION': {'covered': 32, 'missed': 7}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,13.0,These are the attributes we are getting from the IdP at testshib.,"The attributes we get from the IdP of testshib.org, from https://pdurbin.pagekite.me/Shibboleth.sso/Session are as follows:  affiliation, cn, entitlement, eppn, givenName, persistent-id, sn, telephoneNumber, uid, unscoped-affiliation.",The IdP at testshib gives us these attributes.,0.249406190291094,  These are the attributes we get from the IdP to testshib.," public static void printAttributes(HttpServletRequest request){
        for (String attr : shibAttrs) {
            String value = request.getAttribute(attr);
            if (value != null) {
                System.out.println(attr + "": "" + value);
            }
        }
    }"," public static void printAttributes(HttpServletRequest request){
        for (String attr : shibAttrs) {
            String value = request.getAttribute(attr).toString();
            System.out.println(attr + "": "" + value);
        }
    }"," public static void printAttributes(HttpServletRequest request){
        for (String attr : shibAttrs) {
            String value = request.getAttribute(attr).toString();
            System.out.println(attr + "": "" + value);
        }
    }"," public static void printAttributes(HttpServletRequest request){
        for (String attr : shibAttrs) {
            String value = request.getAttribute(attr);
            if (value != null) {
                System.out.println(attr + "": "" + value);
            }
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.33347868261629365,  0.3061906704492621,  0.33347868261629365,  0.3061906704492621,51.0,0.5543478260869565,56.0,0.6086956521739131,51.0,0.5543478260869565,56.0,0.6086956521739131,7.0,0.13725490196078433,0.0,0.0,7.0,0.13725490196078433,22.0,0.88,3.0,0.23076923076923078,12.0,0.9230769230769231
60,cdk,"private static double correctMass(double mass, Integer charge){
    if (charge == null)
        return mass;
    double massE = 0.00054857990927;
    if (charge > 0)
        mass -= massE * charge;
    else if (charge < 0)
        mass += massE * Math.abs(charge);
    return mass;
}",correctMass,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * Correct the mass according the charge of the IMmoleculeFormula.
     * Negative charge will add the mass of one electron to the mass.
     *
     * @param mass      The mass to correct
     * @param charge    The charge
     * @return          The mass with the correction
     */",838-854,"('correctMass', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,10.0,Correct the mass according the charge of the IMmoleculeFormula.,Based on the IMmoleculeFormula it is possible to correct the mass. At this point you will add the mass of an electron to the mass through the negative charge,Correct the mass according to the charge of the molecule.,0.568120328807709,  Correct the mass according to the load of the IMmoleculeFormula.,"private static double correctMass(double mass, Integer charge){
        if (charge == null)
            return mass;
        if (charge == 0)
            return mass;
        if (charge > 0)
            return mass + charge * 1.0 / 6.02 * 1.0 / 1000 * 1.0 / 1000 * 1.0 / 1000;
        else
            return mass - charge * 1.0 / 6.02 * 1.0 / 1000 * 1.0 / 1000 * 1.0 / 1000;
    }","private static double correctMass(double mass, Integer charge){
        if (charge == null)
            return mass;
        if (charge == 0)
            return mass;
        if (charge < 0)
            return mass + charge * ELECTRON_MASS;
        return mass + charge * ELECTRON_MASS;
    }","private static double correctMass(double mass, Integer charge){
        if (charge == null)
            return mass;
        if (charge == 0)
            return mass;
        if (charge > 0)
            return mass + charge * 1.0 / 6.02 * 1.0 / 1000 * 1.0 / 1000 * 1.0 / 1000;
        else
            return mass - charge * 1.0 / 6.02 * 1.0 / 1000 * 1.0 / 1000 * 1.0 / 1000;
    }","private static double correctMass(double mass, Integer charge){
        if (charge == null)
            return mass;
        if (charge == 0)
            return mass;
        if (charge > 0)
            return mass + charge * Constants.ELECTRON_MASS_U;
        return mass - charge * Constants.ELECTRON_MASS_U;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5055644688484383,  0.5594425282361571,  0.5687279773867651,  0.5055644688484383,45.0,0.5555555555555556,24.0,0.39344262295081966,26.0,0.4262295081967213,45.0,0.5555555555555556,33.0,0.4074074074074074,31.0,0.38271604938271603,0.0,0.0,25.0,0.8333333333333334,2.0,0.18181818181818182,2.0,0.18181818181818182
61,cdk,"private static String multipleExtractor(String formula){
    String recentCompoundCount = ""0"";
    String recentCompound = """";
    boolean found = false;
    for (int f = 0; f < formula.length(); f++) {
        char thisChar = formula.charAt(f);
        if (thisChar >= '0' && thisChar <= '9') {
            if (!found)
                recentCompoundCount += thisChar;
            else
                recentCompound += thisChar;
        } else {
            found = true;
            recentCompound += thisChar;
        }
    }
    return muliplier(recentCompound, Integer.valueOf(recentCompoundCount));
}",multipleExtractor,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * The starting with numeric value is used to show a quantity by which a formula is multiplied.
     * For example: 2H2O really means that a H4O2 unit.
     *
     * @param formula Formula to correct
     * @return        Formula with the correction
     */",1443-1469,"('multipleExtractor', {'INSTRUCTION': {'covered': 63, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,18.0,The starting with numeric value is used to show a quantity by which a formula is multiplied.,The initial numeric value is used to specify an amount for which a formula is multiplied.,The formula is calculated by using the starting value and the number of times the formula is repeated.,0.525741784593024,  The starting value by a numeric value is used to display a quantity by which a formula is multiplied.,"private static String multipleExtractor(String formula){
        String multiple = """";
        for (int f = 0; f < formula.length(); f++) {
            char thisChar = formula.charAt(f);
            if (thisChar >= '0' && thisChar <= '9') {
                multiple += thisChar;
            } else {
                break;
            }
        }
        return multiple;
    }","private static String multipleExtractor(String formula){
        String multiple = """";
        for (int f = 0; f < formula.length(); f++) {
            char thisChar = formula.charAt(f);
            if (thisChar >= '0' && thisChar <= '9') {
                multiple += thisChar;
            } else {
                break;
            }
        }
        return multiple;
    }","private static String multipleExtractor(String formula){
        String newFormula = formula;
        String multiple = """";
        for (int f = 0; f < formula.length(); f++) {
            char thisChar = formula.charAt(f);
            if (thisChar >= '0' && thisChar <= '9') {
                multiple += thisChar;
            } else {
                break;
            }
        }
        newFormula = newFormula.substring(multiple.length(), newFormula.length());
        return newFormula;      
 }","private static String multipleExtractor(String formula){
        String multiple = """";
        for (int f = 0; f < formula.length(); f++) {
            char thisChar = formula.charAt(f);
            if (thisChar >= '0' && thisChar <= '9') {
                multiple += thisChar;
            } else {
                break;
            }
        }
        return multiple;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.535681669484804,  0.535681669484804,  0.535681669484804,  0.5203876048749604,40.0,0.37735849056603776,40.0,0.37735849056603776,40.0,0.37735849056603776,38.0,0.3584905660377358,0.0,0.0,0.0,0.0,25.0,0.26595744680851063,6.0,0.3333333333333333,4.0,0.2,15.0,0.7894736842105263
62,cdk,"static long[] parseUSmilesNumbers(String aux, IAtomContainer container){
    int index;
    long[] numbers = new long[container.getAtomCount()];
    int[] first = null;
    int label = 1;
    if ((index = aux.indexOf(""/R:"")) >= 0) {
        int endIndex = aux.indexOf('/', index + 8);
        if (endIndex < 0)
            endIndex = aux.length();
        String[] baseNumbers = aux.substring(index + 8, endIndex).split("";"");
        first = new int[baseNumbers.length];
        Arrays.fill(first, -1);
        for (int i = 0; i < baseNumbers.length; i++) {
            String[] numbering = baseNumbers[i].split("","");
            first[i] = Integer.parseInt(numbering[0]) - 1;
            for (String number : numbering) {
                numbers[Integer.parseInt(number) - 1] = label++;
            }
        }
    } else if ((index = aux.indexOf(""/N:"")) >= 0) {
        String[] baseNumbers = aux.substring(index + 3, aux.indexOf('/', index + 3)).split("";"");
        first = new int[baseNumbers.length];
        Arrays.fill(first, -1);
        if ((index = aux.indexOf(""/F:"")) >= 0) {
            String[] fixedHNumbers = aux.substring(index + 3, aux.indexOf('/', index + 3)).split("";"");
            for (int i = 0; i < fixedHNumbers.length; i++) {
                String component = fixedHNumbers[i];
                if (component.charAt(component.length() - 1) == 'm') {
                    int n = component.length() > 1 ? Integer.parseInt(component.substring(0, component.length() - 1)) : 1;
                    for (int j = 0; j < n; j++) {
                        String[] numbering = baseNumbers[i + j].split("","");
                        first[i + j] = Integer.parseInt(numbering[0]) - 1;
                        for (String number : numbering) numbers[Integer.parseInt(number) - 1] = label++;
                    }
                } else {
                    String[] numbering = component.split("","");
                    for (String number : numbering) numbers[Integer.parseInt(number) - 1] = label++;
                }
            }
        } else {
            for (int i = 0; i < baseNumbers.length; i++) {
                String[] numbering = baseNumbers[i].split("","");
                first[i] = Integer.parseInt(numbering[0]) - 1;
                for (String number : numbering) numbers[Integer.parseInt(number) - 1] = label++;
            }
        }
    } else {
        throw new IllegalArgumentException(""AuxInfo did not contain extractable base numbers (/N: or /R:)."");
    }
    for (int v : first) {
        if (v >= 0) {
            IAtom atom = container.getAtom(v);
            if (atom.getFormalCharge() == null)
                continue;
            if (atom.getAtomicNumber() == 8 && atom.getFormalCharge() == -1) {
                List<IAtom> neighbors = container.getConnectedAtomsList(atom);
                if (neighbors.size() == 1) {
                    IAtom correctedStart = findPiBondedOxygen(container, neighbors.get(0));
                    if (correctedStart != null)
                        exch(numbers, v, container.indexOf(correctedStart));
                }
            }
        }
    }
    for (int i = 0; i < numbers.length; i++) if (numbers[i] == 0)
        numbers[i] = label++;
    return numbers;
}",parseUSmilesNumbers,org/openscience/cdk/graph/invariant/InChINumbersTools.java,/storage/inchi/src/main/java/org/openscience/cdk/graph/invariant/InChINumbersTools.java,"/**
     * Parse the InChI canonical atom numbers (from the AuxInfo) to use in
     * Universal SMILES.
     *
     * The parsing follows: ""Rule A: The correspondence between the input atom
     * order and the InChI canonical labels should be obtained from the
     * reconnected metal layer (/R:) in preference to the initial layer, and
     * then from the fixed hydrogen labels (/F:) in preference to the standard
     * labels (/N:)."" 
     *
     * The labels are also adjust for ""Rule E: If the start atom is a negatively
     * charged oxygen atom, start instead at any carbonyl oxygen attached to the
     * same neighbour."" 
     *
     * All unlabelled atoms (e.g. hydrogens) are assigned the same label which
     * is different but larger then all other labels. The hydrogen
     * labelling then needs to be adjusted externally as universal SMILES
     * suggests hydrogens should be visited first.
     *
     * @param aux       inchi AuxInfo
     * @param container the structure to obtain the numbering of
     * @return the numbers string to use
     */",86-191,"('parseUSmilesNumbers', {'INSTRUCTION': {'covered': 384, 'missed': 6}, 'BRANCH': {'covered': 41, 'missed': 5}, 'LINE': {'covered': 54, 'missed': 1}, 'COMPLEXITY': {'covered': 19, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",749.0,17.0,Parse the InChI canonical atom numbers (from the AuxInfo) to use in  Universal SMILES.,"To use inUniversal SMILES analyze the canonical atom numbers of InChI (from AuxInfo).  The analysis follows: ""Rule A: From the reconnected metal layer (/ R :) it should be possible to obtain the correspondence between the order of the incoming atoms and the canonical InChI labels, rather than from the initial layer, and therefore from the fixed labels of hydrogen (/ F :) in preference to standard labels (/ N :). ""  It is also possible to adjust the labels for Rule E: in the case of the start atom is a negatively charged oxygen atom, start instead at any carbonyl oxygen attached to the same neighbour.""   The same label is assigned to all unlabeled atoms (eg Hydrogens) which is different but larger than all other labels. Universal SMILES suggests that hydrogens should be visited first therefore hydrogen labeling must therefore be externally regulated.",Universal SMILES uses the InChI canonical atom numbers.,0.61558432534238,  Analyze the numbers of canonical atoms InChI (from the AuxInfo) for use in Universal SMILES.," static long[] parseUSmilesNumbers(String aux, IAtomContainer container){
        long[] numbers = new long[container.getAtomCount()];
        parseAuxInfo(aux, numbers);
        return numbers;
    }","static long[] parseUSmilesNumbers(String aux, IAtomContainer container){
        long[] numbers = new long[container.getAtomCount()];
        aux = aux.substring(aux.indexOf(""/N:"") + 3);
        String numberStringAux = aux.substring(0, aux.indexOf('/'));
        int i = 1;
        for (String numberString : numberStringAux.split(""[,;]""))
            numbers[Integer.valueOf(numberString) - 1] = i++;
        return numbers;
    }","static long[] parseUSmilesNumbers(String aux, IAtomContainer container){
        long[] numbers = new long[container.getAtomCount()];
        aux = aux.substring(aux.indexOf(""/N:"") + 3);
        String numberStringAux = aux.substring(0, aux.indexOf('/'));
        int i = 1;
        for (String numberString : numberStringAux.split(""[,;]""))
            numbers[Integer.valueOf(numberString) - 1] = i++;
        return numbers;
    }","static long[] parseUSmilesNumbers(String aux, IAtomContainer container){
        long[] numbers = new long[container.getAtomCount()];
        aux = aux.substring(aux.indexOf(""/N:"") + 3);
        String numberStringAux = aux.substring(0, aux.indexOf('/'));
        int i = 1;
        for (String numberString : numberStringAux.split(""[,;]""))
            numbers[Integer.valueOf(numberString) - 1] = i++;
        return numbers;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.06318145467895947,  0.13483780949383845,  0.1359016392810725,  0.13483780949383845,711.0,0.948,659.0,0.8786666666666667,659.0,0.8786666666666667,659.0,0.8786666666666667,59.0,0.6020408163265306,59.0,0.6020408163265306,59.0,0.6020408163265306,136.0,0.9379310344827586,6.0,0.375,12.0,0.8
63,jackson-databind,"public ObjectReader readerForUpdating(Object valueToUpdate){
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}",readerForUpdating,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Factory method for constructing {@link ObjectReader} that will
     * update given Object (usually Bean, but can be a Collection or Map
     * as well, but NOT an array) with JSON data. Deserialization occurs
     * normally except that the root-level value in JSON is not used for
     * instantiating a new object; instead give updateable object is used
     * as root.
     * Runtime type of value object is used for locating deserializer,
     * unless overridden by other factory methods of {@link ObjectReader}
     */",4096-4110,"('readerForUpdating', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,37.0,"Factory method for constructing {@link ObjectReader} that will  update given Object (usually Bean, but can be a Collection or Map  as well, but NOT an array) with JSON data.","It will be possible to update a certain object (usually Bean, but it can also be a collection or a map, but NOT an array) with JSON data through the factory method {@link ObjectReader}.  De-serialization normally happens, except that the value of the root layer in JSON is not used to instantiate a new object. The runtime type of the value object is used to locate the deserializer, unless it is overwritten by other factory methods of {@link ObjectReader}",The method for constructing @link ObjectReader that will update given object is a factory method.,1.14555495215555,"  A factory method for constructing {@link ObjectReader} that will update a given object (usually Bean, but can also be a collection or map, but NOT an array) with JSON data."," public ObjectReader readerForUpdating(Object valueToUpdate){
        return _newReader(getDeserializationConfig()).with(_injectableValues).forUpdating(valueToUpdate);
    }"," public ObjectReader readerForUpdating(Object valueToUpdate){
        return _newReader(getDeserializationConfig()).with(_injectableValues).forUpdating(valueToUpdate);
    }"," public ObjectReader readerForUpdating(Object valueToUpdate){
        return _newReader(getDeserializationConfig()).with(_injectableValues).forUpdating(valueToUpdate);
    }"," public ObjectReader readerForUpdating(Object valueToUpdate){
        return _newReader(getDeserializationConfig()).with(_injectableValues).forUpdating(valueToUpdate);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3673202117872424,  0.3673202117872424,  0.3673202117872424,  0.3673202117872424,21.0,0.525,21.0,0.525,21.0,0.525,21.0,0.525,0.0,0.0,0.0,0.0,0.0,0.0,69.0,0.8625,9.0,0.2903225806451613,21.0,0.7
64,jackson-databind,"public static boolean isProxyType(Class<?> type){
    String name = type.getName();
    if (name.startsWith(""net.sf.cglib.proxy."") || name.startsWith(""org.hibernate.proxy."")) {
        return true;
    }
    return false;
}",isProxyType,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * Helper method used to weed out dynamic Proxy types; types that do
     * not expose concrete method API that we could use to figure out
     * automatic Bean (property) based serialization.
     */",233-255,"('isProxyType', {'INSTRUCTION': {'covered': 13, 'missed': 2}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,33.0,Helper method used to weed out dynamic Proxy types; types that do  not expose concrete method API that we could use to figure out  automatic Bean (property) based serialization.,To understand Bean-based automatic serialization (property) it is possible to use types that do not expose the API of the concrete method. This is a helper method for eliminating dynamic proxy types,The method used to weed out dynamic Proxy types is called a helpers method.,0.855630472713994,  Assistive method used to eliminate dynamic proxy types; types that do not expose the concrete method API that we could use to understand Bean-based automatic serialization (property).," public static boolean isProxyType(Class<?> type){
        if (type == null) {
            return false;
        }
        if (type.isInterface()) {
            return false;
        }
        if (type.isArray()) {
            return false;
        }
        if (type.isAnnotation()) {
            return false;
        }
        if (type.isEnum()) {
            return false;
        }
        if (type.isPrimitive()) {
            return false;
        }
        if (type.isMemberClass()) {
            return false;
        }
        if (type.isLocalClass()) {
            return false;
        }
        if (type.isAnonymousClass()) {
            return false;
        }
        if (type.isSynthetic()) {
            return false;
        }
        if (type.isMemberClass()) {
            return false;
        }
        if (type.isLocalClass()) {
            return false;
        }
        if (type.isAnonymousClass()) {
            return false;
        }
        if (type.isSynthetic()) {
            return false;
        }
        if (type.isMemberClass()) {
            return false;
        }
        if (type.isLocalClass()) {
            return false;
        }
        if (type.isAnonymousClass()) {
            return false;
        }
        if (type.isSynthetic()) {
            return false;
        }
        if (type.isMemberClass()) {
            return false;
        }
        if (type.isLocalClass()) {
            return false;
        }
        if (type.isAnonymousClass()) {
            return false;
        }
        if (type.isSynthetic()) {
            return false;
        }
        if (type.isMemberClass()) {
            return false;
        }
        if (type.isLocalClass()) {
            return false;
        }
        if (type.isAnonymousClass()) {
            return false;
        }
        if (type.isSynthetic()) {
            return false;
        }
        if (type        
 }"," public static boolean isProxyType(Class<?> type){
        return type.getName().contains(""$$EnhancerByCGLIB"");
    }"," public static boolean isProxyType(Class<?> type){
        return Proxy.isProxyClass(type);
    }"," public static boolean isProxyType(Class<?> type){
        return Proxy.isProxyClass(type);
    }",Syntax Error,PASS,NOT PASS,NOT PASS,None,  0.3573092993547129,  0.277334480966548,  0.277334480966548,None,None,24.0,0.5106382978723404,29.0,0.6170212765957447,29.0,0.6170212765957447,330.0,0.9348441926345609,333.0,0.943342776203966,333.0,0.943342776203966,27.0,0.8181818181818182,11.0,0.36666666666666664,21.0,0.7
65,logstash-logback-encoder,"public static List<InetSocketAddress> parse(String destinations, int defaultPort){
    /*
         * Multiple destinations can be specified on one single line, separated by comma
         */
    String[] destinationStrings = (destinations == null ? """" : destinations.trim()).split(""\\s*,\\s*"");
    List<InetSocketAddress> destinationList = new ArrayList<>(destinationStrings.length);
    for (String entry : destinationStrings) {
        /*
             * For #134, check to ensure properties are defined when destinations
             * are set using properties.
             */
        if (entry.contains(CoreConstants.UNDEFINED_PROPERTY_SUFFIX)) {
            throw new IllegalArgumentException(""Invalid destination '"" + entry + ""': unparseable value (expected format 'host[:port]')."");
        }
        Matcher matcher = DESTINATION_PATTERN.matcher(entry);
        if (!matcher.matches()) {
            throw new IllegalArgumentException(""Invalid destination '"" + entry + ""': unparseable value (expected format 'host[:port]')."");
        }
        String host = matcher.group(HOSTNAME_GROUP);
        String portString = matcher.group(PORT_GROUP);
        int port;
        try {
            port = (portString != null) ? Integer.parseInt(portString) : defaultPort;
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException(""Invalid destination '"" + entry + ""': unparseable port (was '"" + portString + ""')."");
        }
        destinationList.add(InetSocketAddress.createUnresolved(host, port));
    }
    return destinationList;
}",parse,net/logstash/logback/appender/destination/DestinationParser.java,/src/main/java/net/logstash/logback/appender/destination/DestinationParser.java,"/**
     * Constructs {@link InetSocketAddress}es by parsing the given {@link String} value.
     * <p>
     * The string is a comma separated list of destinations in the form of hostName[:portNumber].
     * <p>
     *
     * For example, ""host1.domain.com,host2.domain.com:5560""
     * <p>
     *
     * If portNumber is not provided, then the given defaultPort will be used.
     * 
     * @param destinations comma-separated list of destinations in the form of {@code hostName[:portNumber]}
     * @param defaultPort the port number to use when a destination does not specify one explicitly
     * @return ordered list of {@link InetSocketAddress} instances
     */",39-94,"('parse', {'INSTRUCTION': {'covered': 111, 'missed': 2}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",203.0,18.0,Constructs {@link InetSocketAddress}es by parsing the given {@link String} value.,"By analyzing the specified {@link String} value, it builds {@link InetSocketAddress} The string is a comma-separated list of targets in the form of hostName [: portNumber]",The given @link String value is used to construct @link InetSocketAddresses.,0.65011910575187,  Constructs {@link InetSocketAddress}es by parsing the given {@link String} value.,"public static List<InetSocketAddress> parse(String destinations, int defaultPort){
        List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();
        if (destinations == null) {
            return addresses;
        }
        String[] destinationArray = destinations.split(CoreConstants.COMMA_REGEX);
        for (String destination : destinationArray) {
            Matcher matcher = DESTINATION_PATTERN.matcher(destination);
            if (matcher.matches()) {
                String hostname = matcher.group(HOSTNAME_GROUP);
                int port = defaultPort;
                if (matcher.groupCount() > 1) {
                    String portString = matcher.group(PORT_GROUP);
                    if (portString != null) {
                        port = Integer.parseInt(portString);
                    }
                }
                addresses.add(new InetSocketAddress(hostname, port));
            } else {
                throw new IllegalArgumentException(""Invalid destination: "" + destination);
            }
        }
        return addresses;
    }"," public static List<InetSocketAddress> parse(String destinations, int defaultPort){
        List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();
        if(destinations == null) {
            return addresses;
        }
        String[] destinationArray = destinations.split("","");
        for(String destination : destinationArray) {
            Matcher matcher = DESTINATION_PATTERN.matcher(destination);
            if(matcher.matches()) {
                String hostname = matcher.group(HOSTNAME_GROUP);
                String portString = matcher.group(PORT_GROUP);
                int port = defaultPort;
                if(portString != null) {
                    port = Integer.parseInt(portString);
                }
                addresses.add(new InetSocketAddress(hostname, port));
            } else {
                throw new IllegalArgumentException(""Invalid destination: "" + destination);
            }
        }
        return addresses;       
 }"," public static List<InetSocketAddress> parse(String destinations, int defaultPort){
        List<InetSocketAddress> result = new ArrayList<InetSocketAddress>();
        if (destinations == null) {
            return result;
        }
        String[] destinationArray = destinations.split(CoreConstants.COMMA_CHAR);
        for (String destination : destinationArray) {
            Matcher matcher = DESTINATION_PATTERN.matcher(destination);
            if (matcher.matches()) {
                String hostname = matcher.group(HOSTNAME_GROUP);
                String portString = matcher.group(PORT_GROUP);
                int port = defaultPort;
                if (portString != null) {
                    port = Integer.parseInt(portString);
                }
                result.add(new InetSocketAddress(hostname, port));
            } else {
                throw new IllegalArgumentException(""Invalid destination: "" + destination);
            }
        }
        return result;
    }       "," public static List<InetSocketAddress> parse(String destinations, int defaultPort){
        List<InetSocketAddress> result = new ArrayList<InetSocketAddress>();
        if (destinations == null) {
            return result;
        }
        String[] destinationArray = destinations.split(CoreConstants.COMMA_CHAR);
        for (String destination : destinationArray) {
            Matcher matcher = DESTINATION_PATTERN.matcher(destination);
            if (matcher.matches()) {
                String hostname = matcher.group(HOSTNAME_GROUP);
                String portString = matcher.group(PORT_GROUP);
                int port = defaultPort;
                if (portString != null) {
                    port = Integer.parseInt(portString);
                }
                result.add(new InetSocketAddress(hostname, port));
            } else {
                throw new IllegalArgumentException(""Invalid destination: "" + destination);
            }
        }
        return result;
    }       ",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.44143448148994546,  0.41102847758697025,  0.4192767141823752,  0.42871067644652616,123.0,0.6029411764705882,113.0,0.553921568627451,113.0,0.553921568627451,113.0,0.553921568627451,23.0,0.1377245508982036,25.0,0.1497005988023952,25.0,0.1497005988023952,24.0,0.8888888888888888,0.0,0.0,11.0,0.9166666666666666
66,cdk,"public static boolean contains(IMolecularFormulaSet formulaSet, IMolecularFormula formula){
    for (IMolecularFormula fm : formulaSet.molecularFormulas()) {
        if (MolecularFormulaManipulator.compare(fm, formula)) {
            return true;
        }
    }
    return false;
}",contains,org/openscience/cdk/tools/manipulator/MolecularFormulaSetManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaSetManipulator.java,"/**
     *  True, if the IMolecularFormulaSet contains the given IMolecularFormula but not
     *  as object. It compare according contains the same number and type of Isotopes.
     *  It is not based on compare objects.
     *
     * @param formulaSet   The IMolecularFormulaSet
     * @param  formula     The IMolecularFormula this IMolecularFormulaSet is searched for
     * @return             True, if the IMolecularFormulaSet contains the given formula
     *
     * @see                IMolecularFormulaSet#contains(IMolecularFormula)
     */",166-184,"('contains', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,14.0,"True, if the IMolecularFormulaSet contains the given IMolecularFormula but not  as object.","The method in question returns True, if the specified MolecularFormula object is contained in IMolecularFormulaSet but not as an object. Compares objects that contain the same number and type of isotopes.  It does not rely on comparing objects.","If the IMolecularFormulaSet contains the given IMolecularFormula but not as object, it is true.",0.392988217973468,"  True, if IMolecularFormulaSet contains the given IMolecularFormula but not as an object."," public static boolean contains(IMolecularFormulaSet formulaSet, IMolecularFormula formula){
        for (IMolecularFormula mf : formulaSet.molecularFormulas()) {
            if (mf.equals(formula)) return true;
        }
        return false;       
 }"," public static boolean contains(IMolecularFormulaSet formulaSet, IMolecularFormula formula){
        for (IMolecularFormula mf : formulaSet.molecularFormulas()) {
            if (MolecularFormulaManipulator.isIsomorphic(mf, formula)) return true;
        }
        return false;
    }"," public static boolean contains(IMolecularFormulaSet formulaSet, IMolecularFormula formula){
        for(IMolecularFormula mf : formulaSet.molecularFormulas()){
            if(mf.equals(formula)) return true;
        }
        return false;       
 }"," public static boolean contains(IMolecularFormulaSet formulaSet, IMolecularFormula formula){
        for (IMolecularFormula mf : formulaSet.molecularFormulas()) {
            if (mf.equals(formula)) return true;
        }
        return false;       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6976349649984342,  0.7953381262975437,  0.6976349649984342,  0.6976349649984342,7.0,0.15217391304347827,5.0,0.10869565217391304,7.0,0.15217391304347827,7.0,0.15217391304347827,4.0,0.09090909090909091,0.0,0.0,0.0,0.0,31.0,0.7948717948717948,2.0,0.15384615384615385,6.0,0.4
67,jackson-databind,"public static String apostrophed(String text){
    if (text == null) {
        return ""[null]"";
    }
    return new StringBuilder(text.length() + 2).append('\'').append(text).append('\'').toString();
}",apostrophed,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * Returns either {@code 'text'} (single-quoted) or {@code [null]}.
     *
     * @since 2.9
     */",805-815,"('apostrophed', {'INSTRUCTION': {'covered': 17, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,20.0,Returns either {@code 'text'} (single-quoted) or {@code [null]}.,The following method allows you to return either {@code 'text'} (single-quoted) or {@code [null]}.,Either @code 'text' or @code 'null' will be returned.,0.759913550007265,  Returns {@code 'text'} (single quotation mark) or {@code [null]}.,"public static String apostrophed(String text){
        if (text == null) {
            return ""[null]"";
        }
        return new StringBuilder(text.length()+2).append('\'').append(text).append('\'').toString();
    }","public static String apostrophed(String text){
        if (text == null) {
            return ""[null]"";
        }
        return new StringBuilder(text.length()+2).append('\'').append(text).append('\'').toString();
    }","public static String apostrophed(String text){
        if (text == null) {
            return ""[null]"";
        }
        return new StringBuilder(text.length()+2).append('\'').append(text).append('\'').toString();
    }","public static String apostrophed(String text){
        if (text == null) {
            return ""[null]"";
        }
        return new StringBuilder(text.length()+2).append('\'').append(text).append('\'').toString();
    }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,7.0,0.4666666666666667,4.0,0.4,9.0,0.9
68,cdk,"void store(OutputStream out) throws IOException{
    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(out));
    for (Entry<String, List<Point2d[]>> e : templateMap.entrySet()) {
        for (Point2d[] val : e.getValue()) {
            bw.write(encodeEntry(new AbstractMap.SimpleImmutableEntry<>(e.getKey(), val)));
            bw.write('\n');
        }
    }
    bw.close();
}",store,org/openscience/cdk/layout/IdentityTemplateLibrary.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/IdentityTemplateLibrary.java,"/**
     * Store a template library to the provided output stream.
     *
     * @param out output stream
     * @throws IOException low level IO error
     */",484-502,"('store', {'INSTRUCTION': {'covered': 50, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",98.0,10.0,Store a template library to the provided output stream.,In the provided output stream this method allows you to store a template library.,The template library should be stored in the provided output stream.,0.421867323576133,  Store a library of templates in the provided output stream.,"void store(OutputStream out) throws IOException{
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(out));
        for (Map.Entry<String,List<Point2d[]>> e : templateMap.entrySet()) {
            for (Point2d[] coords : e.getValue()) {
                bw.write(encodeEntry(e.getKey(), coords));
                bw.newLine();
            }
        }
        bw.close();
    }","void store(OutputStream out) throws IOException{
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(out));
        for (Map.Entry<String,List<Point2d[]>> e : templateMap.entrySet()) {
            for (Point2d[] coords : e.getValue()) {
                bw.write(encodeEntry(e.getKey(), coords));
                bw.newLine();
            }
        }
        bw.close();
    }","void store(OutputStream out) throws IOException{
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(out));
        for (Map.Entry<String,List<Point2d[]>> e : templateMap.entrySet()) {
            for (Point2d[] coords : e.getValue()) {
                bw.write(encodeEntry(e.getKey(), coords));
                bw.newLine();
            }
        }
        bw.close();
    }","void store(OutputStream out) throws IOException{
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(out));
        for (Map.Entry<String,List<Point2d[]>> e : templateMap.entrySet()) {
            for (Point2d[] coords : e.getValue()) {
                bw.write(encodeEntry(e.getKey(), coords));
                bw.newLine();
            }
        }
        bw.close();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7896724141025897,  0.7896724141025897,  0.7896724141025897,  0.7896724141025897,14.0,0.1414141414141414,14.0,0.1414141414141414,14.0,0.1414141414141414,14.0,0.1414141414141414,0.0,0.0,0.0,0.0,0.0,0.0,13.0,0.8666666666666667,4.0,0.36363636363636365,6.0,0.5
69,cdk,"private static int readUInt(final String line, int index, int digits){
    int result = 0;
    while (digits-- > 0) result = (result * 10) + toInt(line.charAt(index++));
    return result;
}",readUInt,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Read an unsigned int value from the given index with the expected number
     * of digits.
     *
     * @param line   input line
     * @param index  start index
     * @param digits number of digits (max)
     * @return an unsigned int
     */",1671-1685,"('readUInt', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,16.0,Read an unsigned int value from the given index with the expected number  of digits.,The method in question from the given index with the expected number of digits reads an int value without a sign,The expected number of digits is what you'll get when you read an unsigned int value from the index.,0.243987253483922,  Read an unsigned int value from the given index with the expected number of digits.,"private static int readUInt(final String line, int index, int digits){
        int value = 0;
        for (int i = 0; i < digits; i++) {
            value = value * 10 + toInt(line.charAt(index + i));
        }
        return value;
    }","private static int readUInt(final String line, int index, int digits){
        int result = 0;
        for(int i = 0; i < digits; i++){
            result = result * 10 + toInt(line.charAt(index + i));
        }
        return result;      
 }","private static int readUInt(final String line, int index, int digits){
        int value = 0;
        for (int i = 0; i < digits; i++) {
            value = value * 10 + toInt(line.charAt(index + i));
        }
        return value;       
 }","private static int readUInt(final String line, int index, int digits){
        int value = 0;
        for (int i = 0; i < digits; i++) {
            value = value * 10 + toInt(line.charAt(index + i));
        }
        return value;
    }",PASS,PASS,PASS,PASS,  0.5097918619991415,  0.581199390902839,  0.5306251953324749,  0.5306251953324749,21.0,0.35,17.0,0.2833333333333333,21.0,0.35,21.0,0.35,4.0,0.06666666666666667,0.0,0.0,0.0,0.0,13.0,0.5909090909090909,0.0,0.0,19.0,0.95
70,dataverse,"public static String generateNewFileName(final String fileName){
    String newName;
    String baseName;
    String extension = null;
    int extensionIndex = fileName.lastIndexOf(""."");
    if (extensionIndex != -1) {
        extension = fileName.substring(extensionIndex + 1);
        baseName = fileName.substring(0, extensionIndex);
    } else {
        baseName = fileName;
    }
    if (baseName.matches("".*-[0-9][0-9]*$"")) {
        int dashIndex = baseName.lastIndexOf(""-"");
        String numSuffix = baseName.substring(dashIndex + 1);
        String basePrefix = baseName.substring(0, dashIndex);
        int numSuffixValue = Integer.parseInt(numSuffix);
        numSuffixValue++;
        baseName = basePrefix + ""-"" + numSuffixValue;
    } else {
        baseName = baseName + ""-1"";
    }
    newName = baseName;
    if (extension != null) {
        newName = newName + ""."" + extension;
    }
    return newName;
}",generateNewFileName,edu/harvard/iq/dataverse/ingest/IngestUtil.java,/src/main/java/edu/harvard/iq/dataverse/ingest/IngestUtil.java,"/**
     * Generates a new unique filename by adding -[number] to the base name.
     *
     * @param fileName original filename
     * @return a new unique filename
     */",208-244,"('generateNewFileName', {'INSTRUCTION': {'covered': 62, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 18, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",168.0,16.0,Generates a new unique filename by adding -[number] to the base name.,Adding -[number] to the base name generates a new filename,Adding -[number] to the base name creates a new unique filename.,1.01501677171445,  Generates a new unique file name by appending -[number] to the base name.,"public static String generateNewFileName(final String fileName){
        String newFileName = fileName;
        int i = 1;
        while (true) {
            if (newFileName.endsWith(""-"" + i)) {
                i++;
            } else {
                newFileName = fileName + ""-"" + i;
                break;
            }
        }
        return newFileName;
    }","public static String generateNewFileName(final String fileName){
        String newFileName = fileName;
        int i = 1;
        while (true) {
            if (newFileName.endsWith(""-"" + i)) {
                i++;
            } else {
                newFileName = newFileName + ""-"" + i;
                break;
            }
        }
        return newFileName;
    }","public static String generateNewFileName(final String fileName){
        String newFileName = fileName;
        int i = 1;
        while (true) {
            if (newFileName.endsWith(""."")) {
                newFileName = newFileName.substring(0, newFileName.length() - 1);
            }
            if (!newFileName.endsWith(""-"" + i)) {
                newFileName = newFileName + ""-"" + i;
                break;
            }
            i++;
        }
        return newFileName;
    }","public static String generateNewFileName(final String fileName){
        String newFileName = fileName;
        int i = 1;
        while (true) {
            newFileName = fileName + ""-"" + i;
            if (!new File(newFileName).exists()) {
                break;
            }
            i++;
        }
        return newFileName;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.1636280702690763,  0.16749802703997585,  0.16317491969128428,  0.24018000248014426,128.0,0.757396449704142,128.0,0.757396449704142,129.0,0.7633136094674556,118.0,0.6982248520710059,1.0,0.016666666666666666,24.0,0.4,35.0,0.4069767441860465,12.0,0.9230769230769231,3.0,0.21428571428571427,12.0,0.9230769230769231
71,jeromq,"public Timer add(long interval, Handler handler, Object... args){
    if (handler == null) {
        return null;
    }
    Utils.checkArgument(interval > 0, ""Delay of a timer has to be strictly greater than 0"");
    final Timer timer = new Timer(this, interval, handler, args);
    final boolean rc = insert(timer);
    assert (rc);
    return timer;
}",add,zmq/util/Timers.java,/src/main/java/zmq/util/Timers.java,"/**
     * Add timer to the set, timer repeats forever, or until cancel is called.
     * @param interval the interval of repetition in milliseconds.
     * @param handler the callback called at the expiration of the timer.
     * @param args the optional arguments for the handler.
     * @return an opaque handle for further cancel.
     */",113-130,"('add', {'INSTRUCTION': {'covered': 32, 'missed': 4}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",71.0,16.0,"Add timer to the set, timer repeats forever, or until cancel is called.",In the following method a timer is added to the collection the handler parameter the callback is called when the timer expires. Until cancel is called the timer repeats forever,Add a timer to the set and it will repeat forever.,0.380046231451206,"  Add the timer to the set, the timer repeats forever or until the cancellation is called.","public Timer add(long interval, Handler handler, Object... args){
        return add(interval, 0, handler, args);     
 }"," public Timer add(long interval, Handler handler, Object... args){
        Timer timer = new Timer(this, interval, handler, args);
        return timer;
    }","public Timer add(long interval, Handler handler, Object... args){
        return add(interval, 0, handler, args);     
 }","public Timer add(long interval, Handler handler, Object... args){
        return add(interval, 0, handler, args);     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.29725882133128256,  0.42389122638669374,  0.29725882133128256,  0.29725882133128256,45.0,0.625,37.0,0.5138888888888888,45.0,0.625,45.0,0.625,10.0,0.2857142857142857,0.0,0.0,0.0,0.0,25.0,0.8064516129032258,5.0,0.29411764705882354,10.0,0.7142857142857143
72,openapi-generator,"public String toModelName(final String name){
    if (schemaKeyToModelNameCache.containsKey(name)) {
        return schemaKeyToModelNameCache.get(name);
    }
    String camelizedName = camelize(modelNamePrefix + ""_"" + name + ""_"" + modelNameSuffix);
    schemaKeyToModelNameCache.put(name, camelizedName);
    return camelizedName;
}",toModelName,org/openapitools/codegen/DefaultCodegen.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java,"/**
     * Converts the OpenAPI schema name to a model name suitable for the current code generator.
     * May be overridden for each programming language.
     * In case the name belongs to the TypeSystem it won't be renamed.
     *
     * @param name the name of the model
     * @return capitalized model name
     */",2380-2397,"('toModelName', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",57.0,16.0,Converts the OpenAPI schema name to a model name suitable for the current code generator.,The OpenAPI schema name is converted to a template name suitable for the current code generator. For any programming language it can be overridden. It will not be renamed if the name belongs to TypeSystem.,The OpenAPI name is converted to a model name for the current code generator.,0.799427466674471,  Converts the OpenAPI schema name to a template name that is appropriate for the current code generator.," public String toModelName(final String name){
        return camelize(name);
    }"," public String toModelName(final String name){
        return camelize(name);
    }"," public String toModelName(final String name){
        return camelize(name);
    }"," public String toModelName(final String name){
        return camelize(name);
    }",PASS,PASS,PASS,PASS,  0.181590654644612,  0.181590654644612,  0.181590654644612,  0.181590654644612,41.0,0.7068965517241379,41.0,0.7068965517241379,41.0,0.7068965517241379,41.0,0.7068965517241379,0.0,0.0,0.0,0.0,0.0,0.0,24.0,0.6666666666666666,4.0,0.2222222222222222,6.0,0.375
74,javaparser,"public static String castValue(String value, Type requiredType, String valueType){
    String requiredTypeName = requiredType.asString();
    if (requiredTypeName.equals(valueType))
        return value;
    else
        return String.format(""(%s) %s"", requiredTypeName, value);
}",castValue,com/github/javaparser/generator/core/utils/CodeUtils.java,/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/utils/CodeUtils.java,"/**
	 * Cast the value if the current type doesn't match the required type.
	 * <br>
	 * Given the following example:
	 * <code>
	 *     int withoutCast = 1;
	 *     double withCast = (double) 1;
	 * </code>
	 * The variable withoutCast doesn't need to be casted, since we have int as required type and int as value type.
	 * While in the variable withCast we have double as required type and int as value type.
	 *
	 * @param value           The value to be returned.
	 * @param requiredType    The expected type to be casted if needed.
	 * @param valueType       The type of the value to be returned.
	 *
	 * @return The value casted if needed.
	 */",32-56,"('castValue', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",50.0,14.0,Cast the value if the current type doesn't match the required type.,In case the current type does not match the required type it casts the value. In the variable conCast we have double as the required type and int as the value type. Whereas in the case where we have int as the required type and int as the value type the variable withoutCast does not need to be cast.,"If the current type doesn't match the required type, cast the value.",0.187302707008753,  Convert the value if the current type does not match the required type.," public static String castValue(String value, Type requiredType, String valueType){
   	if(requiredType.toString().equals(valueType)){
 		return value;
 	}
 	return ""("" + requiredType.toString() + "")"" + value;   
 }"," public static String castValue(String value, Type requiredType, String valueType){
   	String conCast = ""("" + requiredType.asStringWithoutComments() + "") "" + value;
 	String withoutCast = value;
 	if(!valueType.equals(requiredType.asStringWithoutComments())){
 		withoutCast = conCast;
 	}
 	return withoutCast;   
 }"," public static String castValue(String value, Type requiredType, String valueType){
   	if (requiredType.isPrimitive() && !requiredType.asString().equals(valueType)) {
 		return ""("" + requiredType.asString() + "")"" + value;
 	}
 	return value;   
 }"," public static String castValue(String value, Type requiredType, String valueType){
   	if (requiredType.isPrimitive() && !requiredType.asString().equals(valueType)) {
 		return ""("" + requiredType.asString() + "")"" + value;
 	}
 	return value;   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.545277873466624,  0.5026565946835078,  0.5607968429048853,  0.5607968429048853,19.0,0.37254901960784315,33.0,0.55,25.0,0.45454545454545453,25.0,0.45454545454545453,32.0,0.5333333333333333,17.0,0.3090909090909091,17.0,0.3090909090909091,53.0,0.8833333333333333,3.0,0.21428571428571427,8.0,0.6153846153846154
75,cdk,"public static ILigand defineLigand(IAtomContainer container, VisitedAtoms visitedAtoms, int chiralAtom, int ligandAtom){
    if (ligandAtom == HYDROGEN) {
        return new ImplicitHydrogenLigand(container, visitedAtoms, container.getAtom(chiralAtom));
    } else {
        return new Ligand(container, visitedAtoms, container.getAtom(chiralAtom), container.getAtom(ligandAtom));
    }
}",defineLigand,org/openscience/cdk/geometry/cip/CIPTool.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/CIPTool.java,"/**
     * Creates a ligand attached to a single chiral atom, where the involved
     * atoms are identified by there index in the {@link IAtomContainer}. For ligand
     * atom, {@link #HYDROGEN} can be passed as index, which will indicate the presence of
     * an implicit hydrogen, not explicitly present in the chemical graph of the
     * given <code>container</code>.
     *
     * @param container  {@link IAtomContainer} for which the returned {@link ILigand}s are defined
     * @param visitedAtoms a list of atoms already visited in the analysis
     * @param chiralAtom an integer pointing to the {@link IAtom} index of the chiral atom
     * @param ligandAtom an integer pointing to the {@link IAtom} index of the {@link ILigand}
     * @return           the created {@link ILigand}
     */",307-327,"('defineLigand', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,27.0,"Creates a ligand attached to a single chiral atom, where the involved  atoms are identified by there index in the {@link IAtomContainer}.","From the atoms involved that are identified by the index in the {@link IAtomContainer} creates a ligand linked to a single chiral atom. {@link #HYDROGEN} for the ligand atom, can be passed as an index, this will allow to indicate the presence of an implicit hydrogen, thus not explicitly occurring in the chemical graph of the given <code>container</code>",The involved atoms are identified by the index in the @link IAtomContainer.,0.729108886222505,"  Creates a ligand attached to a single chiral atom, where the atoms involved are identified by the index {@link IAtomContainer}."," public static ILigand defineLigand(IAtomContainer container, VisitedAtoms visitedAtoms, int chiralAtom, int ligandAtom){
        if (ligandAtom == HYDROGEN) {
            return new Ligand(container, visitedAtoms, chiralAtom, null);
        } else {
            return new Ligand(container, visitedAtoms, chiralAtom, container.getAtom(ligandAtom));
        }
    }"," public static ILigand defineLigand(IAtomContainer container, VisitedAtoms visitedAtoms, int chiralAtom, int ligandAtom){
        if (ligandAtom == HYDROGEN) {
            return new Ligand(container, visitedAtoms, container.getAtom(chiralAtom), null);
        } else {
            return new Ligand(container, visitedAtoms, container.getAtom(chiralAtom), container.getAtom(ligandAtom));
        }       
 }"," public static ILigand defineLigand(IAtomContainer container, VisitedAtoms visitedAtoms, int chiralAtom, int ligandAtom){
        if (ligandAtom == HYDROGEN) {
            return new Ligand(container, visitedAtoms, chiralAtom, null);
        } else {
            return new Ligand(container, visitedAtoms, chiralAtom, container.getAtom(ligandAtom));
        }
    }"," public static ILigand defineLigand(IAtomContainer container, VisitedAtoms visitedAtoms, int chiralAtom, int ligandAtom){
        if (ligandAtom == HYDROGEN) {
            return new Ligand(container, visitedAtoms, chiralAtom, null);
        } else {
            return new Ligand(container, visitedAtoms, chiralAtom, container.getAtom(ligandAtom));
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7239298493312674,  0.9049993720381949,  0.7239298493312674,  0.7239298493312674,12.0,0.17142857142857143,3.0,0.041666666666666664,12.0,0.17142857142857143,12.0,0.17142857142857143,10.0,0.1388888888888889,0.0,0.0,0.0,0.0,48.0,0.8135593220338984,5.0,0.21739130434782608,14.0,0.6086956521739131
76,matsim-libs,"public void checkConsistency(Config config){
    super.checkConsistency(config);
    boolean hasOpeningAndClosingTime = false;
    boolean hasOpeningTimeAndLatePenalty = false;
    for (ActivityParams actType : this.getActivityParams()) {
        if (actType.isScoringThisActivityAtAll()) {
            if (actType.getOpeningTime().isDefined() && actType.getClosingTime().isDefined()) {
                hasOpeningAndClosingTime = true;
                if (actType.getOpeningTime().seconds() == 0. && actType.getClosingTime().seconds() > 24. * 3600 - 1) {
                    log.error(""it looks like you have an activity type with opening time set to 0:00 and closing "" + ""time set to 24:00. This is most probably not the same as not setting them at all.  "" + ""In particular, activities which extend past midnight may not accumulate scores."");
                }
            }
            if (actType.getOpeningTime().isDefined() && (getLateArrival_utils_hr() < -0.001)) {
                hasOpeningTimeAndLatePenalty = true;
            }
        }
    }
    if (!hasOpeningAndClosingTime && !hasOpeningTimeAndLatePenalty) {
        log.info(""NO OPENING OR CLOSING TIMES DEFINED!\n\n"" + ""There is no activity type that has an opening *and* closing time (or opening time and late penalty) defined.\n"" + ""This usually means that the activity chains can be shifted by an arbitrary\n"" + ""number of hours without having an effect on the score of the plans, and thus\n"" + ""resulting in wrong results / traffic patterns.\n"" + ""If you are using MATSim without time adaptation, you can ignore this warning.\n\n"");
    }
    if (this.getMarginalUtlOfWaiting_utils_hr() != 0.0) {
        log.warn(""marginal utl of wait set to: "" + this.getMarginalUtlOfWaiting_utils_hr() + "". Setting this different from zero is "" + ""discouraged since there is already the marginal utility of time as a resource. The parameter was also used "" + ""in the past for pt routing; if you did that, consider setting the new "" + ""parameter waitingPt instead."");
    }
}",checkConsistency,org/matsim/core/config/groups/PlanCalcScoreConfigGroup.java,/matsim/src/main/java/org/matsim/core/config/groups/PlanCalcScoreConfigGroup.java,"/**
		 * Checks whether all the settings make sense or if there are some
		 * problems with the parameters currently set. Currently, this checks
		 * that for at least one activity type opening AND closing times are
		 * defined.
		 */",1510-1561,"('checkConsistency', {'INSTRUCTION': {'covered': 90, 'missed': 12}, 'BRANCH': {'covered': 18, 'missed': 2}, 'LINE': {'covered': 17, 'missed': 2}, 'COMPLEXITY': {'covered': 9, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",207.0,19.0,Checks whether all the settings make sense or if there are some  problems with the parameters currently set.,"The following method checks whether there are problems with the currently set parameters or whether all settings make sense. For at least one type of activity, check that opening and closing times are defined.",Checks if the settings make sense or if there are problems with the parameters currently set.,0.547390837594194,  Checks if all the parameters make sense or if there are any problems with the currently defined parameters.," public void checkConsistency(Config config){
		for (ActivityParams params : getActivityParams()) {
			params.checkConsistency(config);
		}
		for (ModeParams params : getModes().values()) {
			params.checkConsistency(config);
		}
	}"," public void checkConsistency(Config config){
		for (String actType : getActivityTypes()) {
			ActivityParams params = getActivityParams(actType);
			if (params.getOpeningTime() == null || params.getClosingTime() == null) {
				throw new RuntimeException(""opening and closing time for activity type "" + actType + "" are not defined."");
			}
		}
	}"," public void checkConsistency(Config config){
		for (ActivityParams params : getActivityParams()) {
			params.checkConsistency(config);
		}
		for (ModeParams params : getModes().values()) {
			params.checkConsistency(config);
		}
	}"," public void checkConsistency(Config config){
		for (ActivityParams params : getActivityParams()) {
			params.checkConsistency(config);
		}
		for (ModeParams params : getModes().values()) {
			params.checkConsistency(config);
		}
	}",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.14963829554215657,  0.14260408110909895,  0.14963829554215657,  0.14963829554215657,171.0,0.8221153846153846,165.0,0.7932692307692307,171.0,0.8221153846153846,171.0,0.8221153846153846,28.0,0.4666666666666667,0.0,0.0,0.0,0.0,30.0,0.8571428571428571,6.0,0.3157894736842105,3.0,0.15789473684210525
77,cdk,"public DescriptorValue calculate(IAtom atom, IAtomContainer container){
    double value;
    String originalAtomtypeName = atom.getAtomTypeName();
    Integer originalNeighborCount = atom.getFormalNeighbourCount();
    Integer originalValency = atom.getValency();
    Double originalBondOrderSum = atom.getBondOrderSum();
    Order originalMaxBondOrder = atom.getMaxBondOrder();
    IAtomType.Hybridization originalHybridization = atom.getHybridization();
    if (!isCachedAtomContainer(container)) {
        try {
            AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(container);
            LonePairElectronChecker lpcheck = new LonePairElectronChecker();
            lpcheck.saturate(container);
        } catch (CDKException e) {
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(Double.NaN), NAMES, e);
        }
    }
    value = db.extractIP(container, atom);
    atom.setAtomTypeName(originalAtomtypeName);
    atom.setFormalNeighbourCount(originalNeighborCount);
    atom.setValency(originalValency);
    atom.setHybridization(originalHybridization);
    atom.setMaxBondOrder(originalMaxBondOrder);
    atom.setBondOrderSum(originalBondOrderSum);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(value), NAMES);
}",calculate,org/openscience/cdk/qsar/descriptors/atomic/IPAtomicHOSEDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/IPAtomicHOSEDescriptor.java,"/**
     *  This method calculates the ionization potential of an atom.
     *
     *@param  atom          The IAtom to ionize.
     *@param  container         Parameter is the IAtomContainer.
     *@return                   The ionization potential. Not possible the ionization.
     */",119-160,"('calculate', {'INSTRUCTION': {'covered': 71, 'missed': 17}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 19, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",220.0,10.0,This method calculates the ionization potential of an atom.,This method makes it possible to calculate the ionization potential of an atom,The method calculates the potential of an atom.,0.770640448549817,  This method calculates the ionization potential of an atom.,Not Valid,"public DescriptorValue calculate(IAtom atom, IAtomContainer container){
        if (atom.getSymbol().equals(""H"")) {
            return new DescriptorValue(getSpecification(), getParameterNames(),
                    getParameters(), new DoubleResult(0.0),
                    atom.getSymbol() + "" is not a valid atom for this descriptor"");
        }
    
        // get the HOSE code
        String hoseCode = getHoseCode(atom, container);
    
        // get the ionization potential
        double ip = getIonizationPotential(hoseCode);
    
        return new DescriptorValue(getSpecification(), getParameterNames(),
                getParameters(), new DoubleResult(ip),
                atom.getSymbol() + "" "" + hoseCode + "" "" + ip);
    }"," public DescriptorValue calculate(IAtom atom, IAtomContainer container){
        if (atom.getSymbol().equals(""H"")) return null;
        if (atom.getSymbol().equals(""C"")) return null;
        if (atom.getSymbol().equals(""N"")) return null;
        if (atom.getSymbol().equals(""O"")) return null;
        if (atom.getSymbol().equals(""S"")) return null;
        if (atom.getSymbol().equals(""P"")) return null;
        if (atom.getSymbol().equals(""F"")) return null;
        if (atom.getSymbol().equals(""Cl"")) return null;
        if (atom.getSymbol().equals(""Br"")) return null;
        if (atom.getSymbol().equals(""I"")) return null;
        if (atom.getSymbol().equals(""B"")) return null;
        if (atom.getSymbol().equals(""Si"")) return null;
        if (atom.getSymbol().equals(""Ge"")) return null;
        if (atom.getSymbol().equals(""As"")) return null;
        if (atom.getSymbol().equals(""Se"")) return null;
        if (atom.getSymbol().equals(""Te"")) return null;
        if (atom.getSymbol().equals(""Po"")) return null;
        if (atom.getSymbol().equals(""At"")) return null;
        if (atom.getSymbol().equals(""Rn"")) return null;
        if (atom.getSymbol().equals(""He"")) return null;
        if (atom.getSymbol().equals(""Ne"")) return null;
        if (atom.getSymbol().equals(""Ar"")) return null;
        if (atom.getSymbol().equals(""Kr"")) return null;
        if (atom.getSymbol().equals(""Xe"")) return null;
        if (atom.getSymbol().equals(""Pb"")) return null;
        if (atom.getSymbol().equals(""Bi"")) return null;
        if (atom.getSymbol().equals(""Po"")) return null;
        if (atom.getSymbol().       
 }",Not Valid,Not Valid,NOT PASS,Not Valid,Syntax Error,None,  0.3115907451262886,None,None,None,None,154.0,0.6968325791855203,None,None,336.0,0.7417218543046358,113.0,0.9912280701754386,None,None,452.0,0.9977924944812362,6.0,0.42857142857142855,0.0,0.0,2.0,0.2
78,openapi-generator,"public static boolean isObjectSchema(Schema schema){
    if (schema instanceof ObjectSchema) {
        return true;
    }
    if (SchemaTypeUtil.OBJECT_TYPE.equals(schema.getType()) && !(schema instanceof MapSchema)) {
        return true;
    }
    if (schema.getType() == null && schema.getProperties() != null && !schema.getProperties().isEmpty()) {
        return true;
    }
    return false;
}",isObjectSchema,org/openapitools/codegen/utils/ModelUtils.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ModelUtils.java,"/**
     * Return true if the specified schema is an object with a fixed number of properties.
     *
     * A ObjectSchema differs from an MapSchema in the following way:
     * - An ObjectSchema is not extensible, i.e. it has a fixed number of properties.
     * - A MapSchema is an object that can be extended with an arbitrary set of properties.
     *   The payload may include dynamic properties.
     *
     * For example, an OpenAPI schema is considered an ObjectSchema in the following scenarios:
     *
     *   type: object
     *   additionalProperties: false
     *   properties:
     *     name:
     *       type: string
     *     address:
     *       type: string
     *
     * @param schema the OAS schema
     * @return true if the specified schema is an Object schema.
     */",425-461,"('isObjectSchema', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",85.0,16.0,Return true if the specified schema is an object with a fixed number of properties.,If the specified pattern is an object with a fixed number of properties returns true,"If the specified object is an object with a fixed number of properties, return true.",0.851904796427581,  Return true if the specified schema is an object with a fixed number of properties.," public static boolean isObjectSchema(Schema schema){
        if (schema instanceof ObjectSchema) {
            return true;
        }
        return false;       
 }","public static boolean isObjectSchema(Schema schema){
        if (schema.getType() == SchemaType.OBJECT) {
            if (schema.getProperties() != null) {
                if (schema.getProperties().size() > 0) {
                    return true;
                }
            }
        }
        return false;
    }"," public static boolean isObjectSchema(Schema schema){
        if (schema instanceof ObjectSchema) {
            return true;
        }
        return false;
    }"," public static boolean isObjectSchema(Schema schema){
        if (schema instanceof ObjectSchema) {
            return true;
        }
        return false;       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.24040342828412642,  0.5006524180340804,  0.24040342828412642,  0.24040342828412642,61.0,0.7093023255813954,45.0,0.5232558139534884,61.0,0.7093023255813954,61.0,0.7093023255813954,36.0,0.6101694915254238,0.0,0.0,0.0,0.0,7.0,0.4375,0.0,0.0,7.0,0.4375
79,matsim-libs,"public static void insertLegAct(Plan plan, int pos, Leg leg, Activity act){
    if (pos < plan.getPlanElements().size()) {
        Object o = plan.getPlanElements().get(pos);
        if (!(o instanceof Leg)) {
            throw new IllegalArgumentException(""Position to insert leg and act is not valid (act instead of leg at position)."");
        }
    } else if (pos > plan.getPlanElements().size()) {
        throw new IllegalArgumentException(""Position to insert leg and act is not valid."");
    }
    plan.getPlanElements().add(pos, act);
    plan.getPlanElements().add(pos, leg);
}",insertLegAct,org/matsim/core/population/PopulationUtils.java,/matsim/src/main/java/org/matsim/core/population/PopulationUtils.java,"/**
         * Inserts a leg and a following act at position <code>pos</code> into the plan.
         * @param pos the position where to insert the leg-act-combo. acts and legs are both counted from the beginning starting at 0.
         * @param leg the leg to insert
         * @param act the act to insert, following the leg
         *
         * @throws IllegalArgumentException If the leg and act cannot be inserted at the specified position without retaining the correct order of legs and acts.
         */",1057-1076,"('insertLegAct', {'INSTRUCTION': {'covered': 40, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",117.0,20.0,Inserts a leg and a following act at position <code>pos</code> into the plan.,Inserts a leg and a subsequent act at position <code>pos</code> into the plan.,A leg and a following act are inserted into the plan.,0.536312162644162,  Inserts one leg and one subsequent act to the <code>pos</code> position in the plane.,"public static void insertLegAct(Plan plan, int pos, Leg leg, Activity act){
	 	if (pos < 0 || pos > plan.getPlanElements().size()) {
 		throw new IllegalArgumentException(""pos must be between 0 and "" + plan.getPlanElements().size());
 	}
 	plan.getPlanElements().add(pos, leg);
 	plan.getPlanElements().add(pos+1, act);
 }","public static void insertLegAct(Plan plan, int pos, Leg leg, Activity act){
	 if (pos < 0) {
		 throw new IllegalArgumentException(""pos must be >= 0"");
	 }
	 if (pos > plan.getPlanElements().size()) {
		 throw new IllegalArgumentException(""pos must be < plan.size()"");
	 }
	 plan.getPlanElements().add(pos, leg);
	 plan.getPlanElements().add(pos+1, act);
 }","public static void insertLegAct(Plan plan, int pos, Leg leg, Activity act){
	 	if (pos < 0 || pos > plan.getPlanElements().size()) {
 		throw new IllegalArgumentException(""insertLegAct: index out of bounds"");
 	}
 	if (pos % 2 != 0) {
 		throw new IllegalArgumentException(""insertLegAct: index must be even"");
 	}
 	plan.getPlanElements().add(pos, act);
 	plan.getPlanElements().add(pos, leg);
 }","public static void insertLegAct(Plan plan, int pos, Leg leg, Activity act){
	 	if (pos < 0 || pos > plan.getPlanElements().size()) {
 		throw new IllegalArgumentException(""insertLegAct: pos="" + pos + "" is not in [0,"" + plan.getPlanElements().size() + ""]"");
 	}
 	if (pos % 2 != 0) {
 		throw new IllegalArgumentException(""insertLegAct: pos="" + pos + "" is not even"");
 	}
 	if (pos == 0) {
 		// insert first leg and act
 		plan.getPlanElements().add(pos, act);
 		plan.getPlanElements().add(pos, leg);
 	}
 	else if (pos == plan.getPlanElements().size()) {
 		// insert last leg and act
 		plan.getPlanElements().add(pos, leg);
 		plan.getPlanElements().add(pos, act);
 	}
 	else {
 		// insert in between
 		plan.getPlanElements().add(pos, leg);
 		plan.getPlanElements().add(pos, act);
 	}
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5791894236508413,  0.6025282907107208,  0.6457874182931417,  0.6071078577189168,46.0,0.3898305084745763,41.0,0.3474576271186441,92.0,0.4842105263157895,39.0,0.3305084745762712,23.0,0.26744186046511625,108.0,0.5684210526315789,19.0,0.2111111111111111,1.0,0.07142857142857142,8.0,0.5333333333333333,5.0,0.35714285714285715
80,weblogic-kubernetes-operator,"public Map<String, Object> generate(Class<?> someClass){
    Map<String, Object> result = new HashMap<>();
    if (includeSchemaReference) {
        result.put(""$schema"", JSON_SCHEMA_REFERENCE);
    }
    generateObjectTypeIn(result, someClass);
    if (!definedObjects.isEmpty()) {
        Map<String, Object> definitions = new TreeMap<>();
        result.put(""definitions"", definitions);
        for (Class<?> type : definedObjects.keySet()) {
            if (!definedObjects.get(type).equals(EXTERNAL_CLASS)) {
                definitions.put(getDefinitionKey(type), definedObjects.get(type));
            }
        }
    }
    return result;
}",generate,oracle/kubernetes/json/SchemaGenerator.java,/json-schema-generator/src/main/java/oracle/kubernetes/json/SchemaGenerator.java,"/**
   * Generates an object representing a JSON schema for the specified class.
   *
   * @param someClass the class for which the schema should be generated
   * @return a map of maps, representing the computed JSON
   */",167-191,"('generate', {'INSTRUCTION': {'covered': 61, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",142.0,12.0,Generates an object representing a JSON schema for the specified class.,An object representing the relevant JSON schema is constructed for the specified class,An object is generated for a class.,0.486318278394064,  Generates an object representing a JSON schema for the specified class.," public Map<String, Object> generate(Class<?> someClass){
    return generate(someClass, null);   
 }"," public Map<String, Object> generate(Class<?> someClass){
    return generate(someClass, null);   
 }"," public Map<String, Object> generate(Class<?> someClass){
    return generate(someClass, null);   
 }"," public Map<String, Object> generate(Class<?> someClass){
    return generate(someClass, null);   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.12207118777885104,  0.12207118777885104,  0.12207118777885104,  0.12207118777885104,120.0,0.8391608391608392,120.0,0.8391608391608392,120.0,0.8391608391608392,120.0,0.8391608391608392,0.0,0.0,0.0,0.0,0.0,0.0,7.0,0.5,0.0,0.0,8.0,0.6666666666666666
81,tablesaw,"private void validateColumn(FunctionMetaData function, Column<?> sourceColumn){
    if (!function.isCompatibleColumn(sourceColumn.type())) {
        throw new IllegalArgumentException(""Function: "" + function.functionName() + "" Is not compatible with column type: "" + sourceColumn.type());
    }
}",validateColumn,tech/tablesaw/analytic/AnalyticQueryEngine.java,/core/src/main/java/tech/tablesaw/analytic/AnalyticQueryEngine.java,"/**
   * Checks to make sure the given aggregate function is compatible with the type of the source
   * column.
   */",114-126,"('validateColumn', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",52.0,18.0,Checks to make sure the given aggregate function is compatible with the type of the source  column.,Checks whether the source column type is compatible with the given aggregate function,Checks to make sure the aggregate function is compatible with the source column.,0.377006557828616,  Verifies that the given aggregation function is compatible with the type of the source column.," private void validateColumn(FunctionMetaData function, Column<?> sourceColumn){
    if(!function.isCompatibleWith(sourceColumn.type())){
      throw new IllegalArgumentException(
          ""Aggregate function "" + function.getName() + "" is not compatible with column "" + sourceColumn.name());
    }
  }"," private void validateColumn(FunctionMetaData function, Column<?> sourceColumn){
    if (!function.getSourceColumnType().isAssignableFrom(sourceColumn.type())) {
      throw new IllegalArgumentException(
          ""Source column type "" + sourceColumn.type() + "" is not compatible with "" + function);
    }
  }"," private void validateColumn(FunctionMetaData function, Column<?> sourceColumn){
    if(!function.isCompatibleWith(sourceColumn)){
      throw new IllegalArgumentException(
          ""Aggregate function "" + function.getName() + "" is not compatible with column "" +
              sourceColumn.name());
    }
  }"," private void validateColumn(FunctionMetaData function, Column<?> sourceColumn){
    if (!function.isCompatibleWith(sourceColumn.type())) {
      throw new IllegalArgumentException(
          ""Cannot use "" + function.getName() + "" on column "" + sourceColumn.name());
    }
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8044862677920124,  0.7697007127877541,  0.7868329843115712,  0.6995660651811455,5.0,0.09433962264150944,14.0,0.2641509433962264,5.0,0.09433962264150944,9.0,0.16981132075471697,14.0,0.2641509433962264,2.0,0.03773584905660377,4.0,0.07547169811320754,11.0,0.6111111111111112,5.0,0.2777777777777778,4.0,0.2222222222222222
82,acs-aem-commons,"protected void bindScriptProvider(OnDeployScriptProvider scriptProvider){
    logger.info(""Executing on-deploy scripts from scriptProvider: {}"", scriptProvider.getClass().getName());
    scriptProviders.add(scriptProvider);
    List<OnDeployScript> scripts = scriptProvider.getScripts();
    if (scripts.size() == 0) {
        logger.debug(""No on-deploy scripts found."");
        return;
    }
    try (ResourceResolver resourceResolver = logIn()) {
        runScripts(resourceResolver, scripts);
    }
}",bindScriptProvider,com/adobe/acs/commons/ondeploy/impl/OnDeployExecutorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/ondeploy/impl/OnDeployExecutorImpl.java,"/**
     * Executes all on-deploy scripts on bind of a script provider.
     */",138-154,"('bindScriptProvider', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,11.0,Executes all on-deploy scripts on bind of a script provider.,Allows all scripts to run on-deploy on bind of a script provider.,All on-deploy scripts are executed on the bind of a script provider.,0.285104866675482,  Runs all scripts that are being deployed when binding a script provider.," protected void bindScriptProvider(OnDeployScriptProvider scriptProvider){
        if(scriptProvider != null){
            scriptProviders.add(scriptProvider);
            executeScripts(scriptProvider);
        }       
 }"," protected void bindScriptProvider(OnDeployScriptProvider scriptProvider){
        scriptProviders.add(scriptProvider);        
 }"," protected void bindScriptProvider(OnDeployScriptProvider scriptProvider){
        scriptProviders.add(scriptProvider);        
 }"," protected void bindScriptProvider(OnDeployScriptProvider scriptProvider){
        for (OnDeployScript script : scriptProvider.getScripts()) {
            runScript(script);
        }       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.1973517154871282,  0.1321582455486591,  0.22361896741733955,  0.1321582455486591,61.0,0.7176470588235294,68.0,0.8,62.0,0.7294117647058823,68.0,0.8,13.0,0.43333333333333335,12.0,0.4,13.0,0.43333333333333335,5.0,0.38461538461538464,8.0,0.6153846153846154,5.0,0.38461538461538464
83,cdk,"public static boolean isAromatic(IRing ring, IAtomContainer atomContainer){
    java.util.Iterator<IAtom> ringAtoms = ring.atoms().iterator();
    int eCount = 0;
    java.util.List<IBond> conectedBonds;
    int numDoubleBond = 0;
    boolean allConnectedBondsSingle;
    while (ringAtoms.hasNext()) {
        IAtom atom = ringAtoms.next();
        numDoubleBond = 0;
        allConnectedBondsSingle = true;
        conectedBonds = atomContainer.getConnectedBondsList(atom);
        for (IBond conectedBond : conectedBonds) {
            if (conectedBond.getOrder() == IBond.Order.DOUBLE && ring.contains(conectedBond)) {
                numDoubleBond++;
            } else // Count the Electron if bond order = 1.5
            if (conectedBond.getFlag(CDKConstants.ISAROMATIC) && ring.contains(conectedBond)) {
                numDoubleBond = 1;
            }
            if (conectedBond.getOrder() != IBond.Order.SINGLE) {
                allConnectedBondsSingle = false;
            }
        }
        if (numDoubleBond == 1) {
            // C or heteroatoms both contibute 1 electron in sp2 hybridized form
            eCount++;
        } else if (!atom.getSymbol().equals(""C"")) {
            // Heteroatom probably in sp3 hybrid therefore 2 electrons contributed.
            eCount = eCount + 2;
        } else if (atom.getFlag(CDKConstants.ISAROMATIC)) {
            eCount++;
        } else if (allConnectedBondsSingle && atom.getSymbol().equals(""C"") && atom.getFormalCharge() == 1.0) {
            // This is for tropylium and kinds.
            // Dependence on hybridisation would be better:
            // empty p-orbital is needed
            continue;
        } else {
            return false;
        }
    }
    return eCount - 2 != 0 && (eCount - 2) % 4 == 0;
}",isAromatic,org/openscience/cdk/aromaticity/AromaticityCalculator.java,/legacy/src/main/java/org/openscience/cdk/aromaticity/AromaticityCalculator.java,"/**
     *  Tests the <code>ring</code> in the <code>molecule</code> for aromaticity. Uses the
     *  H&uuml;ckel rule (4n + 2) pie electrons. sp<sup>2</sup> hybridized C contibute 1 electron non
     *  sp<sup>2</sup> hybridized heteroatoms contribute 2 electrons (N and O should never be sp in
     *  or anything else in a ring and d electron elements get to complicated)
     *  sp<sup>2</sup> hybridized heteroatoms contribute 1 electron hybridization is worked out by
     *  counting the number of bonds with order 2. Therefore sp<sup>2</sup> hybridization is assumed
     *  if there is one bond of order 2. Otherwise sp<sup>3</sup> hybridization is assumed.
     *
     * @param  ring      the ring to test
     * @param  atomContainer  the AtomContainer the ring is in
     * @return           true if the ring is aromatic false otherwise.
     */",45-103,"('isAromatic', {'INSTRUCTION': {'covered': 90, 'missed': 23}, 'BRANCH': {'covered': 17, 'missed': 13}, 'LINE': {'covered': 23, 'missed': 4}, 'COMPLEXITY': {'covered': 6, 'missed': 10}, 'METHOD': {'covered': 1, 'missed': 0}})",274.0,21.0,Tests the <code>ring</code> in the <code>molecule</code> for aromaticity.,For aromaticity tests the <code>ring</code> in the <code>molecule</code>. The method returns true if the ring is aromatic false otherwise,The aromaticity is tested in the code>ring/code>.,0.583058183991712,  Tests <code>the aromaticity of the ring</code> in the <code>molecule</code>.," public static boolean isAromatic(IRing ring, IAtomContainer atomContainer){
   	Aromaticity aromaticity = new Aromaticity(atomContainer);
 	aromaticity.setRing(ring);
 	return aromaticity.isAromatic();    
 }"," public static boolean isAromatic(IRing ring, IAtomContainer atomContainer){
   	Aromaticity aromaticity = new Aromaticity(atomContainer);
 	aromaticity.setRing(ring);
 	return aromaticity.isAromatic();    
 }",Empty Method,Empty Method,NOT PASS,NOT PASS,Empty Method,Empty Method,  0.10355963808327412,  0.10355963808327412,None,None,247.0,0.8981818181818182,247.0,0.8981818181818182,None,None,None,None,0.0,0.0,None,None,None,None,15.0,0.75,7.0,0.7,7.0,0.7777777777777778
84,cdk,"public static IAtomContainer scaffold(final IAtomContainer mol){
    if (!mol.isEmpty() && mol.getAtom(0).getContainer() == null)
        return null;
    Deque<IAtom> queue = new ArrayDeque<>();
    int[] bcount = new int[mol.getAtomCount()];
    for (IAtom atom : mol.atoms()) {
        int numBonds = atom.getBondCount();
        bcount[atom.getIndex()] = numBonds;
        if (numBonds == 1)
            queue.add(atom);
    }
    while (!queue.isEmpty()) {
        IAtom atom = queue.poll();
        if (atom == null)
            continue;
        bcount[atom.getIndex()] = 0;
        for (IBond bond : atom.bonds()) {
            IAtom nbr = bond.getOther(atom);
            bcount[nbr.getIndex()]--;
            if (bcount[nbr.getIndex()] == 1)
                queue.add(nbr);
        }
    }
    IAtomContainer scaffold = mol.getBuilder().newAtomContainer();
    for (int i = 0; i < mol.getAtomCount(); i++) {
        IAtom atom = mol.getAtom(i);
        if (bcount[i] > 0)
            scaffold.addAtom(atom);
    }
    for (int i = 0; i < mol.getBondCount(); i++) {
        IBond bond = mol.getBond(i);
        if (bcount[bond.getBegin().getIndex()] > 0 && bcount[bond.getEnd().getIndex()] > 0)
            scaffold.addBond(bond);
    }
    return scaffold;
}",scaffold,org/openscience/cdk/fragment/MurckoFragmenter.java,/tool/fragment/src/main/java/org/openscience/cdk/fragment/MurckoFragmenter.java,"/**
     * Computes the Murcko Scaffold for the provided molecule in linear time.
     * Note the return value contains the same atoms/bonds as in the input
     * and an additional clone and valence adjustments may be required.
     *
     * @param mol the molecule
     * @return the atoms and bonds in the scaffold
     */",156-211,"('scaffold', {'INSTRUCTION': {'covered': 144, 'missed': 3}, 'BRANCH': {'covered': 23, 'missed': 3}, 'LINE': {'covered': 31, 'missed': 2}, 'COMPLEXITY': {'covered': 11, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",333.0,12.0,Computes the Murcko Scaffold for the provided molecule in linear time.,"For the molecule supplied in linear time, Murck's Scaffold is calculated. The returned value contains the same atoms/bonds as the input. In addition, it may require further cloning and valence adjustments.",The Murcko Scaffold is computed for a molecule in a linear time.,0.496948186185992,  Calculates the Murcko scaffolding for the molecule supplied in linear time.,Not Valid,Not Valid,Not Valid," public static IAtomContainer scaffold(final IAtomContainer mol){
        IAtomContainer scaffold = new org.openscience.cdk.AtomContainer(mol);
        scaffold.setID(mol.getID() + ""_scaffold"");
        scaffold.setProperties(mol.getProperties());
        scaffold.setAtomContainer(mol);
        scaffold.setProperty(IS_SIDECHAIN_ATOM, true);
        scaffold.setProperty(IS_LINKER_ATOM, true);
        scaffold.setProperty(IS_CONNECTED_TO_RING, true);
        return scaffold;
    }",Not Valid,Not Valid,NOT PASS,Not Valid,None,None,  0.14877829401303438,None,None,None,None,None,279.0,0.8353293413173652,None,None,None,None,87.0,0.9886363636363636,None,None,28.0,0.875,4.0,0.3333333333333333,7.0,0.5384615384615384
85,jackson-databind,"public ObjectMapper registerModule(Module module){
    _assertNotNull(""module"", module);
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    for (Module dep : module.getDependencies()) {
        registerModule(dep);
    }
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    module.setupModule(new Module.SetupContext() {

        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            return (C) ObjectMapper.this;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public MutableConfigOverride configOverride(Class<?> type) {
            return ObjectMapper.this.configOverride(type);
        }

        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = _deserializationContext._factory.withAdditionalDeserializers(d);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = _deserializationContext._factory.withAdditionalKeyDeserializers(d);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = _deserializationContext._factory.withDeserializerModifier(modifier);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void addSerializers(Serializers s) {
            _serializerFactory = _serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            _serializerFactory = _serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            _serializerFactory = _serializerFactory.withSerializerModifier(modifier);
        }

        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = _deserializationContext._factory.withAbstractTypeResolver(resolver);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = _typeFactory;
            f = f.withModifier(modifier);
            setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = _deserializationContext._factory.withValueInstantiators(instantiators);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            _deserializationConfig = _deserializationConfig.with(ci);
            _serializationConfig = _serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            _deserializationConfig = _deserializationConfig.withInsertedAnnotationIntrospector(ai);
            _serializationConfig = _serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            _deserializationConfig = _deserializationConfig.withAppendedAnnotationIntrospector(ai);
            _serializationConfig = _serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            ObjectMapper.this.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            ObjectMapper.this.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(Collection<Class<?>> subtypes) {
            ObjectMapper.this.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            setPropertyNamingStrategy(naming);
        }
    });
    return this;
}",registerModule,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Method for registering a module that can extend functionality
     * provided by this mapper; for example, by adding providers for
     * custom serializers and deserializers.
     * 
     * @param module Module to register
     */",809-1019,"('registerModule', {'INSTRUCTION': {'covered': 62, 'missed': 10}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 17, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",836.0,26.0,"Method for registering a module that can extend functionality  provided by this mapper; for example, by adding providers for  custom serializers and deserializers.","Registration of a module that can extend the functionality provided by this mapper. For example, adding providers for custom serialisers and deserialisers.",Adding providers for custom serializers and deserializers is a method for registration a module that can extend the function of this mapper.,0.435470582653588,"  Method of registering a module capable of extending the functionality provided by this mapper; for example, by adding suppliers for custom serializers and deserializers."," public ObjectMapper registerModule(Module module){
        _configOverrides.addModule(module);
        return this;        
 }"," public ObjectMapper registerModule(Module module){
        _configOverrides.addModule(module);
        return this;        
 }"," public ObjectMapper registerModule(Module module){
        _configOverrides.addModule(module);
        return this;
    }"," public ObjectMapper registerModule(Module module){
        _configOverrides.addModule(module);
        return this;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.06274702961979894,  0.06274702961979894,  0.06274702961979894,  0.06274702961979894,819.0,0.978494623655914,819.0,0.978494623655914,819.0,0.978494623655914,819.0,0.978494623655914,0.0,0.0,0.0,0.0,0.0,0.0,9.0,0.375,6.0,0.24,23.0,0.9583333333333334
86,cucumber-reporting,"void updateElements(Feature feature, Element[] elements){
    for (int i = 0; i < elements.length; i++) {
        Element current = elements[i];
        if (current.isScenario()) {
            checkArgument(current.getStartTime() != null, ERROR);
            int indexOfPreviousResult = find(feature.getElements(), current);
            boolean hasBackground = isBackground(i - 1, elements);
            if (indexOfPreviousResult < 0) {
                feature.addElements(hasBackground ? new Element[] { elements[i - 1], current } : new Element[] { current });
            } else {
                if (replaceIfExists(feature.getElements()[indexOfPreviousResult], current)) {
                    feature.getElements()[indexOfPreviousResult] = current;
                    if (hasBackground && isBackground(indexOfPreviousResult - 1, feature.getElements())) {
                        feature.getElements()[indexOfPreviousResult - 1] = elements[i - 1];
                    }
                }
            }
        }
    }
}",updateElements,net/masterthought/cucumber/reducers/ReportFeatureWithRetestMerger.java,/src/main/java/net/masterthought/cucumber/reducers/ReportFeatureWithRetestMerger.java,"/**
     * Updates feature's elements with items from the @elements list if an Id of the item coincides
     * with an Id of any element from the @feature object. If there is no element in the @feature object
     * then the item is appended to the end of the elements' list of the @feature.
     *
     * @param feature  - target object of Feature class.
     * @param elements - list of elements which need to be inserted to the @feature with replacing
     *                   or adding to the end.
     */",40-74,"('updateElements', {'INSTRUCTION': {'covered': 74, 'missed': 25}, 'BRANCH': {'covered': 11, 'missed': 5}, 'LINE': {'covered': 14, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",195.0,30.0,Updates feature's elements with items from the @elements list if an Id of the item coincides  with an Id of any element from the @feature object.,"If the element's id matches the id of any element in the @feature object, it updates the elements in the feature with the elements in the @elements list. The element is added to the end of the @feature element list if there is no element in the @feature object.","If an Id of an item coincides with an Id of an element from the feature object, the feature's elements will be updated.",0.207878053587579,  Updates feature items with items in the @elements list if an item ID coincides with an item ID in the @feature object.," void updateElements(Feature feature, Element[] elements){
        for (Element element : elements) {
            if (feature.getElements().stream().anyMatch(e -> ELEMENT_COMPARATOR.compare(e, element))) {
                feature.getElements().stream()
                        .filter(e -> ELEMENT_COMPARATOR.compare(e, element))
                        .findFirst()
                        .ifPresent(e -> e.setStartTimestamp(element.getStartTimestamp()));
            } else {
                feature.getElements().add(element);
            }
        }
    }"," void updateElements(Feature feature, Element[] elements){
        for (Element element : elements) {
            if (feature.getElements().stream().anyMatch(e -> ELEMENT_COMPARATOR.compare(e, element))) {
                feature.getElements().stream()
                        .filter(e -> ELEMENT_COMPARATOR.compare(e, element))
                        .findFirst()
                        .ifPresent(e -> e.setStartTimestamp(element.getStartTimestamp()));
            } else {
                feature.getElements().add(element);
            }
        }
    }","void updateElements(Feature feature, Element[] elements){
        checkArgument(feature.getStart_timestamp() != null, ERROR);
        for (Element element : elements) {
            if (element.getStart_timestamp() != null) {
                if (ELEMENT_COMPARATOR.compare(feature.getStart_timestamp(), element.getStart_timestamp()) < 0) {
                    feature.setStart_timestamp(element.getStart_timestamp());
                }
            }
            if (element.getEnd_timestamp() != null) {
                if (ELEMENT_COMPARATOR.compare(feature.getEnd_timestamp(), element.getEnd_timestamp()) > 0) {
                    feature.setEnd_timestamp(element.getEnd_timestamp());
                }
            }
            if (element.getId() != null) {
                if (feature.getElements().stream().noneMatch(e -> e.getId().equals(element.getId()))) {
                    feature.getElements().add(element);
                }
            }
        }
    }"," void updateElements(Feature feature, Element[] elements){
        checkArgument(feature.getStart_timestamp() != null, ERROR);
        for (Element element : elements) {
            if (feature.getStart_timestamp().equals(element.getStart_timestamp())) {
                feature.getElements().add(element);
            }
        }
        feature.getElements().sort(ELEMENT_COMPARATOR);
    }       ",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.25240080148085303,  0.25240080148085303,  0.21650747703751955,  0.34171711445550634,137.0,0.6989795918367347,137.0,0.6989795918367347,141.0,0.7193877551020408,138.0,0.7040816326530612,0.0,0.0,59.0,0.5412844036697247,104.0,0.5621621621621622,39.0,0.78,12.0,0.4444444444444444,20.0,0.7407407407407407
87,dcache,"public static Optional<Integer> optionalPortWithDefault(URI uri){
    int port = portWithDefault(uri, null, -1);
    return port > -1 ? Optional.of(port) : Optional.<Integer>empty();
}",optionalPortWithDefault,org/dcache/util/URIs.java,/modules/common/src/main/java/org/dcache/util/URIs.java,"/**
     * Obtain an optional port number based on supplied URI.  Use the defined port number, if the
     * URI defines one; otherwise use the default port number for URI's schema, if one is known.
     * Otherwise return an empty Optional.
     */",56-64,"('optionalPortWithDefault', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,10.0,Obtain an optional port number based on supplied URI.,"An optional port number is obtained from the URI provided. Use the defined port number if the URI defines one. Otherwise, if known, it uses the default port number for the URI's scheme.",The port number can be obtained based on the supplied URI.,0.574130637711767,  Get an optional port number based on the provided URI.," public static Optional<Integer> optionalPortWithDefault(URI uri){
        return Optional.ofNullable(portWithDefault(uri));
    }"," public static Optional<Integer> optionalPortWithDefault(URI uri){
        return Optional.ofNullable(portWithDefault(uri));
    }"," public static Optional<Integer> optionalPortWithDefault(URI uri){
        return Optional.ofNullable(portWithDefault(uri));
    }"," public static Optional<Integer> optionalPortWithDefault(URI uri){
        return Optional.ofNullable(portWithDefault(uri));
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2862693648008659,  0.2862693648008659,  0.2862693648008659,  0.2862693648008659,29.0,0.5918367346938775,29.0,0.5918367346938775,29.0,0.5918367346938775,29.0,0.5918367346938775,0.0,0.0,0.0,0.0,0.0,0.0,31.0,0.9117647058823529,3.0,0.2727272727272727,7.0,0.5833333333333334
88,matsim-libs,"public static void reduceToBiggestCluster(Network network, Map<Id<Node>, Node> biggestCluster){
    List<Node> allNodes2 = new ArrayList<>(network.getNodes().values());
    for (Node node : allNodes2) {
        if (!biggestCluster.containsKey(node.getId())) {
            network.removeNode(node.getId());
        }
    }
    log.info(""  resulting network contains "" + network.getNodes().size() + "" nodes and "" + network.getLinks().size() + "" links."");
    log.info(""done."");
}",reduceToBiggestCluster,org/matsim/core/network/algorithms/NetworkCleaner.java,/matsim/src/main/java/org/matsim/core/network/algorithms/NetworkCleaner.java,"/** 
	 * Reducing the network so it only contains nodes included in the biggest Cluster.
	 * Loop over all nodes and check if they are in the cluster, if not, remove them from the network
	 */",144-158,"('reduceToBiggestCluster', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",117.0,14.0,Reducing the network so it only contains nodes included in the biggest Cluster.,"The method to contain are the nodes included in the largest cluster reduces the network. Check if all nodes are part of the cluster; if not, remove them from the network.",The network should only have the smallest cluster of the biggest.,0.551194766881731,   Shrinking the network so that it contains only nodes included in the largest cluster.," public static void reduceToBiggestCluster(Network network, Map<Id<Node>, Node> biggestCluster){
		log.info(""reducing network to biggest cluster..."");
		Set<Id<Node>> nodesToRemove = new HashSet<>();
		for (Node node : network.getNodes().values()) {
			if (!biggestCluster.containsKey(node.getId())) {
				nodesToRemove.add(node.getId());
			}
		}
		for (Id<Node> nodeId : nodesToRemove) {
			network.removeNode(nodeId);
		}
		log.info(""  done."");
	}"," public static void reduceToBiggestCluster(Network network, Map<Id<Node>, Node> biggestCluster){
		for (Node node : network.getNodes().values()) {
			if (!biggestCluster.containsKey(node.getId())) {
				network.removeNode(node.getId());
			}
		}
	}"," public static void reduceToBiggestCluster(Network network, Map<Id<Node>, Node> biggestCluster){
		log.info(""reducing network to biggest cluster..."");
		// remove all nodes that are not part of the biggest cluster
		for (Node node : network.getNodes().values()) {
			if (!biggestCluster.containsKey(node.getId())) {
				network.removeNode(node.getId());
			}
		}
		// remove all links that are not part of the biggest cluster
		for (Link link : network.getLinks().values()) {
			if (!biggestCluster.containsKey(link.getFromNode().getId()) ||
					!biggestCluster.containsKey(link.getToNode().getId())) {
				network.removeLink(link.getId());
			}
		}
		log.info(""done."");
	}"," public static void reduceToBiggestCluster(Network network, Map<Id<Node>, Node> biggestCluster){
	 		log.info(""reducing network to the biggest cluster..."");
 		// remove all nodes that are not part of the biggest cluster
 		for (Node node : network.getNodes().values()) {
 			if (!biggestCluster.containsKey(node.getId())) {
 				network.removeNode(node.getId());
 			}
 		}
 		// remove all links that are not part of the biggest cluster
 		for (Link link : network.getLinks().values()) {
 			if (!biggestCluster.containsKey(link.getFromNode().getId()) ||
 					!biggestCluster.containsKey(link.getToNode().getId())) {
 				network.removeLink(link.getId());
 			}
 		}
 		log.info(""done."");
 	}",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6596439905642841,  0.4781745585880245,  0.6785733557694986,  0.6795178902236859,56.0,0.4745762711864407,56.0,0.4745762711864407,68.0,0.4722222222222222,68.0,0.4722222222222222,51.0,0.4434782608695652,74.0,0.5138888888888888,73.0,0.5069444444444444,28.0,0.875,6.0,0.4,11.0,0.7857142857142857
89,cdk,"public static Partition unit(int size){
    Partition unit = new Partition();
    unit.cells.add(new TreeSet<Integer>());
    for (int i = 0; i < size; i++) {
        unit.cells.get(0).add(i);
    }
    return unit;
}",unit,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,"/**
     * Create a unit partition - in other words, the coarsest possible partition
     * where all the elements are in one cell.
     *
     * @param size the number of elements
     * @return a new Partition with one cell containing all the elements
     */",80-94,"('unit', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,22.0,"Create a unit partition - in other words, the coarsest possible partition  where all the elements are in one cell.",Create the coarsest possible partition in which all elements are in one cell.,The coarsest partition where all the elements are in one cell is the unit partition.,0.719816071057307,"  Create a unit partition - in other words, the coarsest possible partition where all the elements are in a cell.","public static Partition unit(int size){
        Partition partition = new Partition();
        partition.addCell(new int[]{1,2,3,4});
        return partition;
    }","public static Partition unit(int size){
        Partition partition = new Partition();
        partition.addCell(new TreeSet<Integer>());
        for (int i = 1; i <= size; i++) {
            partition.getCell(0).add(i);
        }
        return partition;
    }","public static Partition unit(int size){
        Partition partition = new Partition();
        partition.addCell(new int[]{1,2,3,4});
        return partition;
    }","public static Partition unit(int size){
        Partition partition = new Partition();
        for (int i = 1; i <= size; i++) {
            partition.addCell(i);
        }
        return partition;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2309321652374473,  0.6452023491132339,  0.4639203167303194,  0.2309321652374473,40.0,0.5970149253731343,12.0,0.1791044776119403,28.0,0.417910447761194,40.0,0.5970149253731343,32.0,0.5079365079365079,21.0,0.4666666666666667,0.0,0.0,10.0,0.47619047619047616,1.0,0.047619047619047616,15.0,0.7142857142857143
90,matsim-libs,"public Collection<T> values(){
    if (this.values == null) {
        this.values = new AbstractCollection<T>() {

            @Override
            public Iterator<T> iterator() {
                Iterator<T> iterator = new Iterator<T>() {

                    private final int expectedModCount = QuadTree.this.modCount;

                    private Leaf<T> currentLeaf = firstLeaf();

                    private int nextIndex = 0;

                    private T next = first();

                    private T first() {
                        if (this.currentLeaf == null) {
                            return null;
                        }
                        this.nextIndex = 0;
                        loadNext();
                        return this.next;
                    }

                    @Override
                    public boolean hasNext() {
                        return this.next != null;
                    }

                    @Override
                    public T next() {
                        if (this.next == null) {
                            return null;
                        }
                        if (QuadTree.this.modCount != this.expectedModCount) {
                            throw new ConcurrentModificationException();
                        }
                        T current = this.next;
                        loadNext();
                        return current;
                    }

                    private void loadNext() {
                        boolean searching = true;
                        while (searching) {
                            int size = this.currentLeaf.value != null ? 1 : this.currentLeaf.values.size();
                            if (this.nextIndex < size) {
                                this.nextIndex++;
                                this.next = this.currentLeaf.value != null ? this.currentLeaf.value : this.currentLeaf.values.get(this.nextIndex - 1);
                                searching = false;
                            } else {
                                this.currentLeaf = nextLeaf(this.currentLeaf);
                                if (this.currentLeaf == null) {
                                    this.next = null;
                                    searching = false;
                                } else {
                                    this.nextIndex = 0;
                                }
                            }
                        }
                    }

                    @Override
                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
                return iterator;
            }

            @Override
            public int size() {
                return QuadTree.this.size;
            }
        };
    }
    return this.values;
}",values,org/matsim/core/utils/collections/QuadTree.java,/matsim/src/main/java/org/matsim/core/utils/collections/QuadTree.java,"/**
	 * Returns a collection view of the values contained in this map.  The
	 * collection's iterator will return the values in the order that their
	 * corresponding keys appear in the tree.  The collection is backed by
	 * this <tt>QuadMap</tt> instance, so changes to this map are reflected in
	 * the collection.
	 *
	 * @return a collection view of the values contained in this map.
	 */",276-359,"('values', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",380.0,12.0,Returns a collection view of the values contained in this map.,The method returns a collection view of the values contained in the following map.The values are returned in the order in which the corresponding keys appear in the tree.,A collection view of the values is returned.,0.610701618551137,  Returns a collection view of the values contained in this map.," public Collection<T> values(){
	 	return this.top.values();
 }"," public Collection<T> values(){
	 	return this.top.values();		
 }"," public Collection<T> values(){
	 	return this.top.values();
 }"," public Collection<T> values(){
	 	return this.top.values();
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.09250746463400261,  0.09250746463400261,  0.09250746463400261,  0.09250746463400261,362.0,0.9501312335958005,362.0,0.9501312335958005,362.0,0.9501312335958005,362.0,0.9501312335958005,0.0,0.0,0.0,0.0,0.0,0.0,21.0,0.7,0.0,0.0,6.0,0.5
91,jackson-databind,"public EnumMap<?, SerializableString> internalMap(){
    EnumMap<?, SerializableString> result = _asMap;
    if (result == null) {
        Map<Enum<?>, SerializableString> map = new LinkedHashMap<Enum<?>, SerializableString>();
        for (Enum<?> en : _values) {
            map.put(en, _textual[en.ordinal()]);
        }
        result = new EnumMap(map);
    }
    return result;
}",internalMap,com/fasterxml/jackson/databind/util/EnumValues.java,/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java,"/**
     * Method used for serialization and introspection by core Jackson code.
     */",116-131,"('internalMap', {'INSTRUCTION': {'covered': 42, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",93.0,11.0,Method used for serialization and introspection by core Jackson code.,This method is used for serialisation and introspection from Jackson's main code.,Core Jackson code is used for the method.,0.555929129887707,  A method used for serialization and introspection by basic Jackson code.,"public EnumMap<?, SerializableString> internalMap(){
        if (_asMap == null) {
            _asMap = new EnumMap<>(_enumClass);
            for (int i = 0, len = _values.length; i < len; ++i) {
                _asMap.put(_values[i], _textual[i]);
            }
        }
        return _asMap;
    }","public EnumMap<?, SerializableString> internalMap(){
        if (_asMap == null) {
            _asMap = new EnumMap<>(_enumClass);
            for (int i = 0, len = _values.length; i < len; ++i) {
                _asMap.put(_values[i], _textual[i]);
            }
        }
        return _asMap;
    }","public EnumMap<?, SerializableString> internalMap(){
        if (_asMap == null) {
            _asMap = new EnumMap<>(getEnumClass());
            for (int i = 0, len = _values.length; i < len; ++i) {
                _asMap.put(_values[i], _textual[i]);
            }
        }
        return _asMap;
    }","public EnumMap<?, SerializableString> internalMap(){
        if (_asMap == null) {
            _asMap = new EnumMap<>(getEnumClass());
            for (int i = 0, len = _values.length; i < len; ++i) {
                _asMap.put(_values[i], _textual[i]);
            }
        }
        return _asMap;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3007962900937452,  0.3007962900937452,  0.30849031773427404,  0.30849031773427404,60.0,0.6382978723404256,60.0,0.6382978723404256,60.0,0.6382978723404256,60.0,0.6382978723404256,0.0,0.0,3.0,0.0410958904109589,3.0,0.0410958904109589,7.0,0.5384615384615384,3.0,0.25,10.0,0.9090909090909091
92,matsim-libs,"public void calculateLaneCapacities(Network network, Lanes lanes){
    for (LanesToLinkAssignment l2l : lanes.getLanesToLinkAssignments().values()) {
        Link link = network.getLinks().get(l2l.getLinkId());
        for (Lane lane : l2l.getLanes().values()) {
            calculateAndSetCapacity(lane, lane.getToLaneIds() == null || lane.getToLaneIds().isEmpty(), link, network);
        }
    }
}",calculateLaneCapacities,org/matsim/contrib/sumo/SumoNetworkConverter.java,/contribs/sumo/src/main/java/org/matsim/contrib/sumo/SumoNetworkConverter.java,"/**
     * Calculates lane capacities, according to {@link LanesUtils}.
     */",144-155,"('calculateLaneCapacities', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,12.0,"Calculates lane capacities, according to {@link LanesUtils}.",Based on {@link LanesUtils} calculate the capacity of lanes,"According to @link LanesUtils, it calculates lane capacities.",0.798648776152227,"  Calculates track capacities, based on {@link LanesUtils}.","public void calculateLaneCapacities(Network network, Lanes lanes){
        network.getLinks().values().forEach(link -> {
            LanesToLinkAssignment l2l = lanes.getLanesToLinkAssignments().get(link.getId());
            if (l2l != null)
                calculateAndSetCapacity(link, l2l);
        });
    }","public void calculateLaneCapacities(Network network, Lanes lanes){
        network.getLinks().values().forEach(link -> {
            LanesToLinkAssignment l2l = lanes.getLanesToLinkAssignments().get(link.getId());
            if (l2l != null)
                calculateAndSetCapacity(link, l2l);
        });
    }","public void calculateLaneCapacities(Network network, Lanes lanes){
        network.getLinks().values().forEach(link -> {
            LanesToLinkAssignment l2l = lanes.getLanesToLinkAssignments().get(link.getId());
            if (l2l != null)
                calculateAndSetCapacity(link, l2l);
        });
    }","public void calculateLaneCapacities(Network network, Lanes lanes){
        network.getLinks().values().forEach(link -> {
            LanesToLinkAssignment l2l = lanes.getLanesToLinkAssignments().get(link.getId());
            if (l2l != null)
                calculateAndSetCapacity(link, l2l);
        });
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4195990520182709,  0.4195990520182709,  0.4095990520182709,  0.4195990520182709,52.0,0.5652173913043478,52.0,0.5652173913043478,52.0,0.5652173913043478,52.0,0.5652173913043478,0.0,0.0,0.0,0.0,0.0,0.0,9.0,0.9,3.0,0.375,8.0,0.8888888888888888
93,cdk,"static List<Point2D> grahamScan(final List<Point2D> points){
    if (points.size() <= 3)
        return new ArrayList<Point2D>(points);
    Collections.sort(points, new CompareYThenX());
    Collections.sort(points, new PolarComparator(points.get(0)));
    Deque<Point2D> hull = new ArrayDeque<Point2D>();
    hull.push(points.get(0));
    hull.push(points.get(1));
    hull.push(points.get(2));
    for (int i = 3; i < points.size(); i++) {
        Point2D top = hull.pop();
        while (!hull.isEmpty() && !isLeftTurn(hull.peek(), top, points.get(i))) {
            top = hull.pop();
        }
        hull.push(top);
        hull.push(points.get(i));
    }
    return new ArrayList<Point2D>(hull);
}",grahamScan,org/openscience/cdk/renderer/generators/standard/ConvexHull.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/ConvexHull.java,"/**
     * The Graham Scan algorithm determines the points belonging to the convex hull in O(n lg n).
     *
     * @param points set of points
     * @return points in the convex hull
     * @see <a href=""http://en.wikipedia.org/wiki/Graham_scan"">Graham scan, Wikipedia</a>
     */",163-193,"('grahamScan', {'INSTRUCTION': {'covered': 89, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",212.0,20.0,The Graham Scan algorithm determines the points belonging to the convex hull in O(n lg n).,The points belonging to the convex hull in O(n lg n) are determined by the Graham Scan algorithm,The points belonging to the hull are determined by the Graham Scan.,0.362463947582369,  The Graham Scan algorithm determines the points belonging to the convex shell in O(n lg n).,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,13.0,0.6842105263157895,1.0,0.058823529411764705,12.0,0.7058823529411765
94,dataverse,"public Boolean verifyPassword(String userIdInProvider, String password){
    BuiltinUser biUser = bean.findByUserName(userIdInProvider);
    if (biUser == null)
        return null;
    return PasswordEncryption.getVersion(biUser.getPasswordEncryptionVersion()).check(password, biUser.getEncryptedPassword());
}",verifyPassword,edu/harvard/iq/dataverse/authorization/providers/builtin/BuiltinAuthenticationProvider.java,/src/main/java/edu/harvard/iq/dataverse/authorization/providers/builtin/BuiltinAuthenticationProvider.java,"/**
     * Validates that the passed password is indeed the password of the user.
     * @param userIdInProvider
     * @param password
     * @return {@code true} if the password matches the user's password; {@code false} otherwise.
     */",85-97,"('verifyPassword', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,13.0,Validates that the passed password is indeed the password of the user.,Based on the user's password validate the passed password,The password is confirmed as the password of the user.,0.320928093927256,  Validates that the password passed is the user's password.," public Boolean verifyPassword(String userIdInProvider, String password){
        BuiltinUser biUser = bean.findByUserName( userIdInProvider  );
        return PasswordEncryption.get().verify(password, biUser.getEncryptedPassword(), biUser.getPasswordEncryptionVersion());
    }"," public Boolean verifyPassword(String userIdInProvider, String password){
        BuiltinUser biUser = bean.findByUserName( userIdInProvider  );
        return PasswordEncryption.get().verify(password, biUser.getEncryptedPassword(), biUser.getPasswordEncryptionVersion());
    }"," public Boolean verifyPassword(String userIdInProvider, String password){
        BuiltinUser biUser = bean.findByUserName( userIdInProvider  );
        return PasswordEncryption.get().verify(password, biUser.getEncryptedPassword(), biUser.getPasswordEncryptionVersion());
    }"," public Boolean verifyPassword(String userIdInProvider, String password){
        BuiltinUser biUser = bean.findByUserName( userIdInProvider  );
        return PasswordEncryption.get().verify(password, biUser.getEncryptedPassword(), biUser.getPasswordEncryptionVersion());
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7009642737131819,  0.7009642737131819,  0.7009642737131819,  0.7009642737131819,18.0,0.32727272727272727,18.0,0.32727272727272727,18.0,0.32727272727272727,18.0,0.32727272727272727,0.0,0.0,0.0,0.0,0.0,0.0,9.0,0.6923076923076923,7.0,0.5384615384615384,6.0,0.46153846153846156
95,cdk,"private static void makeElevationMap(IAtom atom, List<IBond> bonds, Map<IAtom, Integer> map){
    map.clear();
    for (IBond bond : bonds) {
        int elevation = 0;
        switch(bond.getStereo()) {
            case UP:
            case DOWN_INVERTED:
                elevation = +1;
                break;
            case DOWN:
            case UP_INVERTED:
                elevation = -1;
                break;
        }
        if (bond.getBegin().equals(atom)) {
            map.put(bond.getEnd(), elevation);
        } else {
            map.put(bond.getBegin(), -1 * elevation);
        }
    }
}",makeElevationMap,org/openscience/cdk/hash/stereo/GeometricTetrahedralEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricTetrahedralEncoderFactory.java,"/**
     * Maps the input bonds to a map of Atom->Elevation where the elevation is
     * whether the bond is off the plane with respect to the central atom.
     *
     * @param atom  central atom
     * @param bonds bonds connected to the central atom
     * @param map   map to load with elevation values (can be reused)
     */",250-282,"('makeElevationMap', {'INSTRUCTION': {'covered': 49, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",127.0,29.0,Maps the input bonds to a map of Atom->Elevation where the elevation is  whether the bond is off the plane with respect to the central atom.,Maps the input bonds to a map of Atom->Elevation Elevation is used to check whether the bond is out of the plane with respect to the central atom.,The map shows the bonds on the plane and the elevation of the central atom.,0.824822047641372,  Maps the input bonds to an Atom->Elevation map where the elevation is if the bond is out of the plane relative to the central atom.,"private static void makeElevationMap(IAtom atom, List<IBond> bonds, Map<IAtom, Integer> map){
        for (IBond bond : bonds) {
            IAtom other = bond.getConnectedAtom(atom);
            if (other.getPoint2d() != null) {
                Point2d p1 = atom.getPoint2d();
                Point2d p2 = other.getPoint2d();
                int elevation = (p1.y - p2.y) * (p1.x - p2.x) > 0 ? 1 : -1;
                map.put(other, elevation);
            }
        }
    }","private static void makeElevationMap(IAtom atom, List<IBond> bonds, Map<IAtom, Integer> map){
        int elevation = 0;
        for (IBond bond : bonds) {
            if (bond.getBegin().equals(atom)) {
                elevation += bond.getBegin().getPoint2d().y > bond.getEnd().getPoint2d().y ? 1 : -1;
            } else {
                elevation += bond.getBegin().getPoint2d().y > bond.getEnd().getPoint2d().y ? -1 : 1;
            }
        }
        map.put(atom, elevation);
    }","private static void makeElevationMap(IAtom atom, List<IBond> bonds, Map<IAtom, Integer> map){
        int elevation = 0;
        for (IBond bond : bonds) {
            IBond.Stereo stereo = bond.getStereo();
            switch (stereo) {
                case E_OR_Z:
                case UP_OR_DOWN:
                case UP_OR_DOWN_INVERTED:
                    return;
                case UP:
                case DOWN:
                case UP_INVERTED:
                case DOWN_INVERTED:
                    elevation++;
                    break;
            }
        }
        map.put(atom, elevation);
    }","private static void makeElevationMap(IAtom atom, List<IBond> bonds, Map<IAtom, Integer> map){
        for (IBond bond : bonds) {
            IAtom other = bond.getConnectedAtom(atom);
            int elevation = 0;
            if (bond.getBegin().equals(atom)) {
                elevation = bond.getBegin().getPoint2d().y - other.getPoint2d().y;
            } else {
                elevation = bond.getEnd().getPoint2d().y - other.getPoint2d().y;
            }
            map.put(other, elevation);
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4238585286516191,  0.49232490365406,  0.5230060260264529,  0.48100975458704853,76.0,0.59375,75.0,0.5859375,72.0,0.5625,69.0,0.5390625,66.0,0.515625,50.0,0.4166666666666667,69.0,0.6106194690265486,7.0,0.2413793103448276,9.0,0.3333333333333333,19.0,0.7037037037037037
96,egeria,"public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (!(objectToCompare instanceof DigitalService)) {
        return false;
    }
    DigitalService asset = (DigitalService) objectToCompare;
    return Objects.equals(getVersion(), asset.getVersion()) && Objects.equals(getDisplayName(), asset.getDisplayName()) && Objects.equals(getDescription(), asset.getDescription());
}",equals,org/odpi/openmetadata/accessservices/digitalservice/properties/DigitalService.java,/open-metadata-implementation/access-services/digital-service/digital-service-api/src/main/java/org/odpi/openmetadata/accessservices/digitalservice/properties/DigitalService.java,"/**
     * {@inheritDoc}
     *
     * Return comparison result based on the content of the properties.
     */",141-161,"('equals', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,15.0,{@inheritDoc}   Return comparison result based on the content of the properties.,"Based on the content of the properties, the result of the comparison is returned ",The return result is based on the content of the properties.,0.135107291740365,  {@inheritDoc}   Return the result of the comparison based on the content of the properties.," public boolean equals(Object objectToCompare){
        if (objectToCompare == null)
        {
            return false;
        }
    
        DigitalService digitalService = (DigitalService) objectToCompare;
    
        return digitalService.getDisplayName().equals(this.getDisplayName());       
 }"," public boolean equals(Object objectToCompare){
        if (objectToCompare == null)
        {
            return false;
        }
    
        if (objectToCompare instanceof DigitalService)
        {
            DigitalService digitalService = (DigitalService) objectToCompare;
    
            if (!DigitalService.super.equals(digitalService))
            {
                return false;
            }
    
            if (this.displayName != null ? !this.displayName.equals(digitalService.displayName) : digitalService.displayName != null)
            {
                return false;
            }
    
            if (this.description != null ? !this.description.equals(digitalService.description) : digitalService.description != null)
            {
                return false;
            }
    
            if (this.version != null ? !this.version.equals(digitalService.version) : digitalService.version != null)
            {
                return false;
            }
    
            return true;
        }
    
        return false;       
 }"," public boolean equals(Object objectToCompare){
    
         if (this == objectToCompare)
         {
             return true;
         }
         if (objectToCompare == null || getClass() != objectToCompare.getClass())
         {
             return false;
         }
         DigitalService that = (DigitalService) objectToCompare;
         return Objects.equals(getDisplayName(), that.getDisplayName()) &&
                 Objects.equals(getDescription(), that.getDescription()) &&
                 Objects.equals(getVersion(), that.getVersion());           
 }"," public boolean equals(Object objectToCompare){
     
      boolean isEqual = false;
     
      if( objectToCompare instanceof DigitalService ) {
            DigitalService  that = (DigitalService) objectToCompare;
            isEqual = this.getGUID().equals(that.getGUID());
            }
     
      return isEqual;           
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.37285091188973124,  0.46642752748952554,  0.3555202064415555,  0.7943714272536828,50.0,0.5617977528089888,104.0,0.6797385620915033,53.0,0.5955056179775281,20.0,0.20833333333333334,111.0,0.7254901960784313,22.0,0.43137254901960786,55.0,0.5729166666666666,11.0,0.7333333333333333,4.0,0.26666666666666666,4.0,0.3333333333333333
97,liquibase,"private static boolean isNoArgCommand(String arg){
    return COMMANDS.MIGRATE.equals(arg) || COMMANDS.MIGRATE_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE.equalsIgnoreCase(arg) || COMMANDS.UPDATE_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE_TESTING_ROLLBACK.equalsIgnoreCase(arg) || COMMANDS.LIST_LOCKS.equalsIgnoreCase(arg) || COMMANDS.RELEASE_LOCKS.equalsIgnoreCase(arg) || COMMANDS.VALIDATE.equalsIgnoreCase(arg) || COMMANDS.HELP.equalsIgnoreCase(arg) || COMMANDS.CLEAR_CHECKSUMS.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(arg);
}",isNoArgCommand,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,"/**
     * Returns true if the given main command arg needs no special parameters.
     *
     * @param arg the main command to test
     * @return true if arg is a valid main command and needs no special parameters, false in all other cases
     */",680-699,"('isNoArgCommand', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'BRANCH': {'covered': 24, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 13, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",119.0,13.0,Returns true if the given main command arg needs no special parameters.,"In the case where the given main command arg does not need any special parameters, the method returns true.","If the main command needs no special parameters, this is true.",1.15804692373566,  Returns true if the given arg master command does not need special parameters.," private static boolean isNoArgCommand(String arg){
        return COMMANDS.HELP.equalsIgnoreCase(arg)
                || COMMANDS.DB_DOC.equalsIgnoreCase(arg)
                || COMMANDS.LIST_LOCKS.equalsIgnoreCase(arg)
                || COMMANDS.RELEASE_LOCKS.equalsIgnoreCase(arg)
                || COMMANDS.STATUS.equalsIgnoreCase(arg)
                || COMMANDS.UNEXPECTED_CHANGESETS.equalsIgnoreCase(arg)
                || COMMANDS.VALIDATE.equalsIgnoreCase(arg)
                || COMMANDS.DIFF.equalsIgnoreCase(arg)
                || COMMANDS.DIFF_CHANGELOG.equalsIgnoreCase(arg)
                || COMMANDS.GENERATE_CHANGELOG.equalsIgnoreCase(arg)
                || COMMANDS.SNAPSHOT.equalsIgnoreCase(arg)
                || COMMANDS.SNAPSHOT_REFERENCE.equalsIgnoreCase(arg)
                || COMMANDS.SYNC_HUB.equalsIgnoreCase(arg)
                || COMMANDS.EXECUTE_SQL.equalsIgnoreCase(arg)
                || COMMANDS.CALCULATE_CHECKSUM.equalsIgnoreCase(arg)
                || COMMANDS.CLEAR_CHECKSUMS.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_TO_TAG.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_TO_TAG_SQL.equalsIgnoreCase(arg)
                || COMMANDS.MARK_NEXT_CHANGESET_RAN.equalsIgnoreCase(arg)
                || COMMANDS.MARK_NEXT_CHANGESET_RAN_SQL.equalsIgnoreCase        
 }"," private static boolean isNoArgCommand(String arg){
        return COMMANDS.HELP.equalsIgnoreCase(arg)
                || COMMANDS.DB_DOC.equalsIgnoreCase(arg)
                || COMMANDS.LIST_LOCKS.equalsIgnoreCase(arg)
                || COMMANDS.RELEASE_LOCKS.equalsIgnoreCase(arg)
                || COMMANDS.STATUS.equalsIgnoreCase(arg)
                || COMMANDS.UNEXPECTED_CHANGESETS.equalsIgnoreCase(arg)
                || COMMANDS.VALIDATE.equalsIgnoreCase(arg)
                || COMMANDS.DIFF.equalsIgnoreCase(arg)
                || COMMANDS.DIFF_CHANGELOG.equalsIgnoreCase(arg)
                || COMMANDS.GENERATE_CHANGELOG.equalsIgnoreCase(arg)
                || COMMANDS.SNAPSHOT.equalsIgnoreCase(arg)
                || COMMANDS.SNAPSHOT_REFERENCE.equalsIgnoreCase(arg)
                || COMMANDS.SYNC_HUB.equalsIgnoreCase(arg)
                || COMMANDS.EXECUTE_SQL.equalsIgnoreCase(arg)
                || COMMANDS.CALCULATE_CHECKSUM.equalsIgnoreCase(arg)
                || COMMANDS.CLEAR_CHECKSUMS.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_TO_TAG.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_TO_TAG_SQL.equalsIgnoreCase(arg)
                || COMMANDS.MARK_NEXT_CHANGESET_RAN.equalsIgnoreCase(arg)
                || COMMANDS.MARK_NEXT_CHANGESET_RAN_SQL.equalsIgnoreCase        
 }"," private static boolean isNoArgCommand(String arg){
        return COMMANDS.HELP.equalsIgnoreCase(arg)
                || COMMANDS.LIST_LOCKS.equalsIgnoreCase(arg)
                || COMMANDS.STATUS.equalsIgnoreCase(arg)
                || COMMANDS.UNEXPECTED_CHANGESETS.equalsIgnoreCase(arg)
                || COMMANDS.VALIDATE.equalsIgnoreCase(arg)
                || COMMANDS.DIFF.equalsIgnoreCase(arg)
                || COMMANDS.DIFF_CHANGELOG.equalsIgnoreCase(arg)
                || COMMANDS.GENERATE_CHANGELOG.equalsIgnoreCase(arg)
                || COMMANDS.SNAPSHOT.equalsIgnoreCase(arg)
                || COMMANDS.SNAPSHOT_REFERENCE.equalsIgnoreCase(arg)
                || COMMANDS.SYNC_HUB.equalsIgnoreCase(arg)
                || COMMANDS.EXECUTE_SQL.equalsIgnoreCase(arg)
                || COMMANDS.CALCULATE_CHECKSUM.equalsIgnoreCase(arg)
                || COMMANDS.CLEAR_CHECKSUMS.equalsIgnoreCase(arg)
                || COMMANDS.DB_DOC.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_TO_TAG.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_TO_TAG_SQL.equalsIgnoreCase(arg)
                || COMMANDS.MARK_NEXT_CHANGESET_RAN.equalsIgnoreCase(arg)
                || COMMANDS.MARK_NEXT_CHANGESET_RAN_SQL.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_ONE_CHANGE_SET.        
 }"," private static boolean isNoArgCommand(String arg){
        return COMMANDS.HELP.equalsIgnoreCase(arg)
                || COMMANDS.LIST_LOCKS.equalsIgnoreCase(arg)
                || COMMANDS.STATUS.equalsIgnoreCase(arg)
                || COMMANDS.UNEXPECTED_CHANGESETS.equalsIgnoreCase(arg)
                || COMMANDS.VALIDATE.equalsIgnoreCase(arg)
                || COMMANDS.DIFF.equalsIgnoreCase(arg)
                || COMMANDS.DIFF_CHANGELOG.equalsIgnoreCase(arg)
                || COMMANDS.GENERATE_CHANGELOG.equalsIgnoreCase(arg)
                || COMMANDS.SNAPSHOT.equalsIgnoreCase(arg)
                || COMMANDS.SNAPSHOT_REFERENCE.equalsIgnoreCase(arg)
                || COMMANDS.SYNC_HUB.equalsIgnoreCase(arg)
                || COMMANDS.EXECUTE_SQL.equalsIgnoreCase(arg)
                || COMMANDS.CALCULATE_CHECKSUM.equalsIgnoreCase(arg)
                || COMMANDS.CLEAR_CHECKSUMS.equalsIgnoreCase(arg)
                || COMMANDS.DB_DOC.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_TO_TAG.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_TO_TAG_SQL.equalsIgnoreCase(arg)
                || COMMANDS.MARK_NEXT_CHANGESET_RAN.equalsIgnoreCase(arg)
                || COMMANDS.MARK_NEXT_CHANGESET_RAN_SQL.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_ONE_CHANGE_SET.        
 }",Syntax Error,Syntax Error,Syntax Error,Syntax Error,None,None,None,None,None,None,None,None,96.0,0.4682926829268293,96.0,0.4682926829268293,None,None,22.0,0.10679611650485436,22.0,0.10679611650485436,13.0,0.65,5.0,0.35714285714285715,9.0,0.6923076923076923
98,anserini,"public static float computeQueryDocumentScoreWithSimilarity(IndexReader reader, String docid, String q, Similarity similarity) throws IOException{
    return computeQueryDocumentScoreWithSimilarityAndAnalyzer(reader, docid, q, similarity, IndexCollection.DEFAULT_ANALYZER);
}",computeQueryDocumentScoreWithSimilarity,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,"/**
   * Computes the score of a document with respect to a query given a scoring function. Assumes Anserini's default
   * analyzer.
   *
   * @param reader index reader
   * @param docid docid of the document to score
   * @param q query
   * @param similarity scoring function
   * @return the score of the document with respect to the query
   * @throws IOException if error encountered during query
   */",673-689,"('computeQueryDocumentScoreWithSimilarity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,16.0,Computes the score of a document with respect to a query given a scoring function.,Given a scoring function computes the score of a document with respect to a query,The score of a document is computed with respect to a query.,0.173858807520445,  Calculates the score of a document against a query with a scoring function.,"public static float computeQueryDocumentScoreWithSimilarity(IndexReader reader, String docid, String q, Similarity similarity) throws IOException{
    IndexSearcher searcher = new IndexSearcher(reader);
    searcher.setSimilarity(similarity);
    Query query = new QueryParser(IndexArgs.CONTENTS, IndexCollection.DEFAULT_ANALYZER).parse(q);
    TopDocs rs = searcher.search(query, 1);
    return rs.scoreDocs.length == 0 ? 0 : rs.scoreDocs[0].score;    
 }","public static float computeQueryDocumentScoreWithSimilarity(IndexReader reader, String docid, String q, Similarity similarity) throws IOException{
    IndexSearcher searcher = new IndexSearcher(reader);
    searcher.setSimilarity(similarity);
    Query query = new QueryParser(IndexArgs.CONTENTS, IndexCollection.DEFAULT_ANALYZER).parse(q);
    TopDocs rs = searcher.search(query, 1);
    return rs.scoreDocs.length == 0 ? 0 : rs.scoreDocs[0].score;    
 }","public static float computeQueryDocumentScoreWithSimilarity(IndexReader reader, String docid, String q, Similarity similarity) throws IOException{
    IndexSearcher searcher = new IndexSearcher(reader);
    searcher.setSimilarity(similarity);
    Query query = new QueryParser(IndexArgs.CONTENTS, new StandardAnalyzer()).parse(q);
    TopDocs rs = searcher.search(query, 1);
    return rs.scoreDocs.length == 0 ? 0 : rs.scoreDocs[0].score;    
 }","public static float computeQueryDocumentScoreWithSimilarity(IndexReader reader, String docid, String q, Similarity similarity) throws IOException{
    IndexSearcher searcher = new IndexSearcher(reader);
    searcher.setSimilarity(similarity);
    QueryParser parser = new QueryParser(IndexArgs.CONTENTS, new StandardAnalyzer());
    Query query = null;
    try {
      query = parser.parse(q);
    } catch (ParseException e) {
      throw new IOException(e);
    }
    TopDocs rs = searcher.search(query, 1);
    return rs.scoreDocs.length == 0 ? 0 : rs.scoreDocs[0].score;    
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6319540299574318,  0.6319540299574318,  0.6243494500010511,  0.6040937630026126,59.0,0.6555555555555556,59.0,0.6555555555555556,88.0,0.7521367521367521,62.0,0.6813186813186813,0.0,0.0,32.0,0.27350427350427353,4.0,0.04395604395604396,9.0,0.5625,5.0,0.3125,9.0,0.5625
99,openapi-generator,"private static String generateNextName(String name){
    Pattern pattern = Pattern.compile(""\\d+\\z"");
    Matcher matcher = pattern.matcher(name);
    if (matcher.find()) {
        String numStr = matcher.group();
        int num = Integer.parseInt(numStr) + 1;
        return name.substring(0, name.length() - numStr.length()) + num;
    } else {
        return name + ""2"";
    }
}",generateNextName,org/openapitools/codegen/DefaultCodegen.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java,"/**
     * Generate the next name for the given name, i.e. append ""2"" to the base name if not ending with a number,
     * otherwise increase the number by 1. For example:
     * status    => status2
     * status2   => status3
     * myName100 => myName101
     *
     * @param name The base name
     * @return The next name for the base name
     */",5112-5132,"('generateNextName', {'INSTRUCTION': {'covered': 43, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,11.0,"Generate the next name for the given name, i.", Taking a base name as input generates the next name for the given name.,The next name should be generated.,0.394310108099911,"  Generate the following name for the first name, i.","private static String generateNextName(String name){
        StringBuilder sb = new StringBuilder(name);
        int i = 1;
        while (true) {
            String nextName = sb.append(""_"" + i).toString();
            if (!usedNames.contains(nextName)) {
                usedNames.add(nextName);
                return nextName;
            }
            i++;
        }
    }","private static String generateNextName(String name){
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < name.length(); i++) {
            char c = name.charAt(i);
            if (Character.isUpperCase(c)) {
                sb.append('_');
                sb.append(Character.toLowerCase(c));
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }"," private static String generateNextName(String name){
        return name + ""_"" + nextNameCounter.getAndIncrement();
    }","private static String generateNextName(String name){
        if (name.length() == 1) {
            return name.toUpperCase(Locale.ROOT);
        }
        return name.substring(0, 1).toUpperCase(Locale.ROOT) + name.substring(1);       
 }",NOT PASS,NOT PASS - TIMEOUT,NOT PASS - TIMEOUT,NOT PASS,  0.2773670126799242,  0.3424021521419377,  0.289917225370806,  0.14669556976808293,56.0,0.6086956521739131,65.0,0.6770833333333334,59.0,0.6413043478260869,75.0,0.8152173913043478,53.0,0.5520833333333334,47.0,0.6527777777777778,54.0,0.75,9.0,0.6,2.0,0.2,7.0,0.7
100,cdk,"private void combineHydrogenPositions(List<Integer> taken, List<List<Integer>> combinations, IAtomContainer skeleton, int totalMobHydrCount, List<Integer> mobHydrAttachPositions){
    if (taken.size() != totalMobHydrCount) {
        for (int i = 0; i < mobHydrAttachPositions.size(); i++) {
            int pos = mobHydrAttachPositions.get(i);
            IAtom atom = findAtomByPosition(skeleton, pos);
            int conn = getConnectivity(atom, skeleton);
            int hCnt = 0;
            for (int t : taken) if (t == pos)
                hCnt++;
            if (atom.getValency() - atom.getFormalCharge() > (hCnt + conn)) {
                taken.add(pos);
                combineHydrogenPositions(taken, combinations, skeleton, totalMobHydrCount, mobHydrAttachPositions);
                taken.remove(taken.size() - 1);
            }
        }
    } else {
        List<Integer> addList = new ArrayList<Integer>(taken.size());
        addList.addAll(taken);
        Collections.sort(addList);
        if (!combinations.contains(addList)) {
            combinations.add(addList);
        }
    }
}",combineHydrogenPositions,org/openscience/cdk/tautomers/InChITautomerGenerator.java,/tool/tautomer/src/main/java/org/openscience/cdk/tautomers/InChITautomerGenerator.java,"/**
     * Makes combinations recursively of all possible mobile Hydrogen positions.
     * @param taken positions taken by hydrogen
     * @param combinations combinations made so far
     * @param skeleton container to work on
     * @param totalMobHydrCount
     * @param mobHydrAttachPositions
     */",590-622,"('combineHydrogenPositions', {'INSTRUCTION': {'covered': 98, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",226.0,10.0,Makes combinations recursively of all possible mobile Hydrogen positions.,"From all possible mobile hydrogen positions, it performs recursive combinations.",Makes combinations that are all possible.,0.47708428596362,  Makes recursive combinations of all possible mobile positions of hydrogen.,"private void combineHydrogenPositions(List<Integer> taken, List<List<Integer>> combinations, IAtomContainer skeleton, int totalMobHydrCount, List<Integer> mobHydrAttachPositions){
        if (taken.size() == totalMobHydrCount) {
            combinations.add(taken);
            return;
        }
        for (int i = 0; i < mobHydrAttachPositions.size(); i++) {
            if (!taken.contains(mobHydrAttachPositions.get(i))) {
                List<Integer> newTaken = new ArrayList<Integer>(taken);
                newTaken.add(mobHydrAttachPositions.get(i));
                combineHydrogenPositions(newTaken, combinations, skeleton, totalMobHydrCount, mobHydrAttachPositions);
            }
        }       
 }","private void combineHydrogenPositions(List<Integer> taken, List<List<Integer>> combinations, IAtomContainer skeleton, int totalMobHydrCount, List<Integer> mobHydrAttachPositions){
        if (taken.size() == totalMobHydrCount) {
            combinations.add(taken);
            return;
        }
        for (int i = 0; i < mobHydrAttachPositions.size(); i++) {
            if (!taken.contains(mobHydrAttachPositions.get(i))) {
                List<Integer> newTaken = new ArrayList<Integer>(taken);
                newTaken.add(mobHydrAttachPositions.get(i));
                combineHydrogenPositions(newTaken, combinations, skeleton, totalMobHydrCount, mobHydrAttachPositions);
            }
        }       
 }","private void combineHydrogenPositions(List<Integer> taken, List<List<Integer>> combinations, IAtomContainer skeleton, int totalMobHydrCount, List<Integer> mobHydrAttachPositions){
        if (taken.size() == totalMobHydrCount) {
            combinations.add(taken);
            return;
        }
        for (int i = 0; i < mobHydrAttachPositions.size(); i++) {
            if (!taken.contains(mobHydrAttachPositions.get(i))) {
                taken.add(mobHydrAttachPositions.get(i));
                combineHydrogenPositions(taken, combinations, skeleton, totalMobHydrCount, mobHydrAttachPositions);
                taken.remove(mobHydrAttachPositions.get(i));
            }
        }       
 }","private void combineHydrogenPositions(List<Integer> taken, List<List<Integer>> combinations, IAtomContainer skeleton, int totalMobHydrCount, List<Integer> mobHydrAttachPositions){
        if (taken.size() == totalMobHydrCount) {
            combinations.add(taken);
            return;
        }
        for (int i = 0; i < mobHydrAttachPositions.size(); i++) {
            if (!taken.contains(mobHydrAttachPositions.get(i))) {
                taken.add(mobHydrAttachPositions.get(i));
                combineHydrogenPositions(taken, combinations, skeleton, totalMobHydrCount, mobHydrAttachPositions);
                taken.remove(mobHydrAttachPositions.get(i));
            }
        }       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4578523154486738,  0.4578523154486738,  0.4640531001251375,  0.4640531001251375,135.0,0.5947136563876652,135.0,0.5947136563876652,137.0,0.6035242290748899,137.0,0.6035242290748899,0.0,0.0,28.0,0.21212121212121213,28.0,0.21212121212121213,10.0,0.9090909090909091,5.0,0.45454545454545453,6.0,0.6
101,dcache,"public void buildRemovalTransition(StatePath ourPath, StateTransition transition, boolean forced){
    LOGGER.trace(""entering buildRemovalTransition: path={}"", ourPath);
    Date now = new Date();
    for (Map.Entry<String, StateComponent> entry : _children.entrySet()) {
        StateComponent childValue = entry.getValue();
        String childName = entry.getKey();
        boolean shouldRemoveThisChild = forced;
        boolean shouldItr = forced;
        if (childValue.hasExpired()) {
            LOGGER.trace(""registering {} (in path {}) for removal."", childName, ourPath);
            shouldRemoveThisChild = shouldItr = true;
        }
        Date childExp = childValue.getEarliestChildExpiryDate();
        if (childExp != null && !now.before(childExp)) {
            shouldItr = true;
        }
        if (shouldItr || shouldRemoveThisChild) {
            StateChangeSet changeSet = transition.getOrCreateChangeSet(ourPath);
            if (shouldRemoveThisChild) {
                changeSet.recordRemovedChild(childName);
            }
            if (shouldItr) {
                changeSet.recordChildItr(childName);
                childValue.buildRemovalTransition(buildChildPath(ourPath, childName), transition, shouldRemoveThisChild);
            }
        }
    }
}",buildRemovalTransition,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,"/**
     * Ostensibly, we iterate over all children to find Mortal children that should be removed.  In
     * practise, cached knowledge of Mortal child expiry Dates means this iterates over only those
     * StateComponents that contain children that have actually expired.
     *
     * @param ourPath
     * @param transition
     * @param forced
     */",687-736,"('buildRemovalTransition', {'INSTRUCTION': {'covered': 83, 'missed': 0}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 22, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",196.0,16.0,"Ostensibly, we iterate over all children to find Mortal children that should be removed.",To find the dead children that are to be removed it iterates over all children.  This causes it to iterate only over those StateComponents that contain actually expired children.,We look over all children to find children that should be removed.,0.156702810440307,"  Apparently, we iterate on all children to find mortal children who should be abducted."," public void buildRemovalTransition(StatePath ourPath, StateTransition transition, boolean forced){
        LOGGER.trace(""buildRemovalTransition path={}, forced={}"", ourPath, forced);
        StateChangeSet changeSet = transition.getStateChangeSet(ourPath);
    
        if (changeSet == null) {
            return;
        }
    
        // Scan through the list of new children first.
        Collection<String> newChildren = changeSet.getNewChildren();
    
        if (newChildren != null) {
            for (String newChildName : newChildren) {
                if (!_children.containsKey(newChildName)) {
                    // ignore unrelated children.
                    continue;
                }
    
                // Ask this child whether it should be removed.
                StateComponent child = changeSet.getNewChildValue(newChildName);
                if (child.shouldBeRemoved(buildChildPath(ourPath, newChildName), transition, forced)) {
                    changeSet.recordRemovedChild(newChildName);
                }
            }
        }
    
        // Scan through our existing children
        for (String childName : _children.keySet()) {
            StateComponent child = _children.get(childName);
    
            // If we've done nothing, it can't have changed.
            if (!changeSet.hasChildChanged(childName)) {
                continue;
            }
    
            // ignore unrelated children
            if (!_children.containsKey(childName)) {
                continue;
            }
    
            // Ask this child whether it should be removed.
            if (child.shouldBeRemoved(buildChildPath(ourPath, childName), transition, forced)) {
                changeSet.recordRemovedChild(childName);
            }
        }
    }"," public void buildRemovalTransition(StatePath ourPath, StateTransition transition, boolean forced){
        StateChangeSet changeSet = transition.getStateChangeSet(ourPath);
    
        if (changeSet == null) {
            return;
        }
    
        // Scan through the list of new children first.
        Collection<String> newChildren = changeSet.getNewChildren();
    
        if (newChildren != null) {
            for (String newChildName : newChildren) {
                if (!_children.containsKey(newChildName)) {
                    // ignore unrelated children.
                    continue;
                }
    
                // Ask this child whether the predicate is triggered.  If the child says ""yes"", we
                // concur.
                StateComponent child = changeSet.getNewChildValue(newChildName);
                if (child.isEphemeral() || forced) {
                    transition.recordRemoval(buildChildPath(ourPath, newChildName));
                }
            }
        }
    
        // Scan through our existing children
        for (String childName : _children.keySet()) {
            StateComponent child = _children.get(childName);
    
            // If we've done nothing, it can't have changed.
            if (!changeSet.hasChildChanged(childName)) {
                continue;
            }
    
            // ignore unrelated children
            if (!_children.containsKey(childName)) {
                continue;
            }
    
            // Ask this child whether the predicate is triggered.  If the child says ""yes"", we
            // concur.
            if (child.isEphemeral() || forced) {
                transition.recordRemoval(buildChildPath(ourPath, childName));
            }
        }
    }",Not Valid," public void buildRemovalTransition(StatePath ourPath, StateTransition transition, boolean forced){
        LOGGER.trace(""buildRemovalTransition path={}, forced={}"", ourPath, forced);
        StateChangeSet changeSet = transition.getStateChangeSet(ourPath);
    
        if (changeSet == null) {
            return;
        }
    
        // Scan through the list of new children first.
        Collection<String> newChildren = changeSet.getNewChildren();
    
        if (newChildren != null) {
            for (String newChildName : newChildren) {
                StateComponent child = changeSet.getNewChildValue(newChildName);
    
                if (child.isMortal()) {
                    if (forced) {
                        child.buildRemovalTransition(buildChildPath(ourPath, newChildName), transition, true);
                    }
                }
            }
        }
    
        // Scan through our existing children
        for (String childName : _children.keySet()) {
            StateComponent child = _children.get(childName);
    
            // If we've done nothing, it can't have changed.
            if (!changeSet.hasChildChanged(childName)) {
                continue;
            }
    
            // ignore unrelated children
            if (!changeSet.childIsRemoved(childName)) {
                continue;
            }
    
            /**
            * If predicate's last element is one of our children...
            */
            if (child.isMortal()) {
                // Check various options:
    
                // Removed children always triggers a predicate.
                if (forced) {
                    child.buildRemovalTransition(buildChildPath(ourPath, childName), transition, true);
                }
            }
        }       
 }",NOT PASS,NOT PASS,NOT PASS,Not Valid,  0.4319018778751732,  0.37626371137593756,  0.44507244846265,None,138.0,0.6731707317073171,135.0,0.6852791878172588,127.0,0.6318407960199005,None,None,45.0,0.21951219512195122,53.0,0.25853658536585367,None,None,25.0,0.8333333333333334,5.0,0.3333333333333333,4.0,0.26666666666666666
102,cdk,"private static StereoEncoder axial3DEncoder(IAtomContainer container, IAtom start, List<IBond> startBonds, IAtom end, List<IBond> endBonds){
    Point3d[] coordinates = new Point3d[4];
    PermutationParity perm = new CombinedPermutationParity(fill3DCoordinates(container, start, startBonds, coordinates, 0), fill3DCoordinates(container, end, endBonds, coordinates, 2));
    GeometricParity geom = new Tetrahedral3DParity(coordinates);
    int u = container.indexOf(start);
    int v = container.indexOf(end);
    return new GeometryEncoder(new int[] { u, v }, perm, geom);
}",axial3DEncoder,org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,"/**
     * Create an encoder for axial 3D stereochemistry for the given start and
     * end atoms.
     *
     * @param container  the molecule
     * @param start      start of the cumulated system
     * @param startBonds bonds connected to the start
     * @param end        end of the cumulated system
     * @param endBonds   bonds connected to the end
     * @return an encoder
     */",188-213,"('axial3DEncoder', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",120.0,15.0,Create an encoder for axial 3D stereochemistry for the given start and  end atoms.,"For the indicated start and target atoms, create an encoder for axial 3D stereochemistry",An Encoder is needed for the given start and end atoms.,0.44505799266735,Create an encoder for axial 3D stereochemistry for the given start and end atoms.,"private static StereoEncoder axial3DEncoder(IAtomContainer container, IAtom start, List<IBond> startBonds, IAtom end, List<IBond> endBonds){
     
      Point3d[] ps = new Point3d[4];
      int[] es = new int[4];
     
      PermutationParity perm = new CombinedPermutationParity(fill3DCoordinates(container, start, startBonds, ps, es,
                 0), fill3DCoordinates(container, end, endBonds, ps, es, 2));
     
      GeometricParity geom = new Tetrahedral3DParity(ps, es);
     
      int u = container.indexOf(start);
      int v = container.indexOf(end);
     
      return new GeometryEncoder(new int[]{u, v}, perm, geom);
     }","private static StereoEncoder axial3DEncoder(IAtomContainer container, IAtom start, List<IBond> startBonds, IAtom end, List<IBond> endBonds){
     
      Point3d[] ps = new Point3d[4];
      int[] es = new int[4];
     
      PermutationParity perm = new CombinedPermutationParity(fill3DCoordinates(container, start, startBonds, ps, es,
                 0), fill3DCoordinates(container, end, endBonds, ps, es, 2));
     
      GeometricParity geom = new Tetrahedral3DParity(ps, es);
     
      int u = container.indexOf(start);
      int v = container.indexOf(end);
     
      return new GeometryEncoder(new int[]{u, v}, perm, geom);
     }","private static StereoEncoder axial3DEncoder(IAtomContainer container, IAtom start, List<IBond> startBonds, IAtom end, List<IBond> endBonds){
     
      Point3d[] ps = new Point3d[4];
      int[] es = new int[4];
     
      PermutationParity perm = new CombinedPermutationParity(fill3DCoordinates(container, start, startBonds, ps, es,
                 0), fill3DCoordinates(container, end, endBonds, ps, es, 2));
     
      GeometricParity geom = new Tetrahedral3DParity(ps, es);
     
      int u = container.indexOf(start);
      int v = container.indexOf(end);
     
      return new GeometryEncoder(new int[]{u, v}, perm, geom);
     }","private static StereoEncoder axial3DEncoder(IAtomContainer container, IAtom start, List<IBond> startBonds, IAtom end, List<IBond> endBonds){
     
      Point3d[] ps = new Point3d[4];
      int[] es = new int[4];
     
      PermutationParity perm = new CombinedPermutationParity(fill3DCoordinates(container, start, startBonds, ps, es,
                 0), fill3DCoordinates(container, end, endBonds, ps, es, 2));
     
      GeometricParity geom = new Tetrahedral3DParity(ps, es);
     
      int u = container.indexOf(start);
      int v = container.indexOf(end);
     
      return new GeometryEncoder(new int[]{u, v}, perm, geom);
     }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8045246727067863,  0.8045246727067863,  0.8045246727067863,  0.8045246727067863,21.0,0.15217391304347827,21.0,0.15217391304347827,21.0,0.15217391304347827,21.0,0.15217391304347827,0.0,0.0,0.0,0.0,0.0,0.0,14.0,0.9333333333333333,0.0,0.0,7.0,0.4666666666666667
105,liquibase,"public Change create(String name){
    Change plugin = getPlugin(name);
    if (plugin == null) {
        return null;
    }
    try {
        return plugin.getClass().getConstructor().newInstance();
    } catch (Exception e) {
        throw new UnexpectedLiquibaseException(e);
    }
}",create,liquibase/change/ChangeFactory.java,/liquibase-core/src/main/java/liquibase/change/ChangeFactory.java,"/**
     * Create a new Change implementation for the given change name. The class of the constructed object will be the Change implementation with the highest priority.
     * Each call to create will return a new instance of the Change.
     */",81-95,"('create', {'INSTRUCTION': {'covered': 24, 'missed': 6}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,11.0,Create a new Change implementation for the given change name.,"For the given change name, create a new implementation of Change. A new instance of Change will be returned for each call to create.",A new implementation for the given change name is needed.,0.260805723088709,  Create a new change implementation for the given change name.," public Change create(String name){
        Change change = create(name, new Object[]{});
        if (change == null) {
            throw new UnexpectedLiquibaseException(""No change found for name "" + name);
        }
        return change;      
 }"," public Change create(String name){
        return create(name, new Scope());       
 }"," public Change create(String name){
        Change change = create(name, new Object[]{});
        if (change == null) {
            throw new UnexpectedLiquibaseException(""No change found for name "" + name);
        }
        return change;      
 }"," public Change create(String name){
        Change change = create(name, new Object[]{});
        if (change == null) {
            throw new UnexpectedLiquibaseException(""No change found for name "" + name);
        }
        return change;      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3501495132260434,  0.22106767610638547,  0.3501495132260434,  0.3501495132260434,39.0,0.639344262295082,45.0,0.7377049180327869,39.0,0.639344262295082,39.0,0.639344262295082,26.0,0.5777777777777777,0.0,0.0,0.0,0.0,20.0,0.8,1.0,0.09090909090909091,6.0,0.5454545454545454
106,acs-aem-commons,"private boolean isAllowedUser(Resource resource) throws RepositoryException{
    ResourceResolver resourceResolver = resource.getResourceResolver();
    String userId = resourceResolver.getUserID();
    if (!userId.equals(ADMIN_ID)) {
        if (this.config.getWhitelistedServiceUsers().contains(userId)) {
            return true;
        }
        Session session = resourceResolver.adaptTo(Session.class);
        User currentUser = (User) getUserManager(session).getAuthorizable(userId);
        if (currentUser != null && !currentUser.isSystemUser()) {
            return true;
        } else {
            LOG.trace(""Avoiding binary sync b/c this is a non-whitelisted service user: {}"", session.getUserID());
        }
    } else {
        LOG.trace(""Avoiding binary sync for admin user"");
    }
    return false;
}",isAllowedUser,com/adobe/acs/commons/remoteassets/impl/RemoteAssetDecorator.java,/bundle/src/main/java/com/adobe/acs/commons/remoteassets/impl/RemoteAssetDecorator.java,"/**
     * Check if the user is allowed to sync binaries.
     *
     * Service users, as well as the admin user, are prevented from sync'ing
     * binaries to ensure that some back end procress traversing the DAM doesn't
     * trigger a sync of the entire DAM, thus subverting the benefits of
     * remote assets.
     *
     * Service users can be whitelisted via remote aseets configuration if it
     * is desired for a particular service user to be able to sync binaries.
     *
     * @param resource The asset content Resource to sync binaries for.
     * @return True if user is allowed to sync binaries, else false.
     * @throws RepositoryException
     */",154-188,"('isAllowedUser', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",136.0,10.0,Check if the user is allowed to sync binaries.,This method makes it possible to check whether the user is authorised to synchronise binaries. Both service users and the administrator user are prevented from synchronising binaries. The configuration of remote assets allows users to be added to a list.,"If the user is allowed to sync, check it.",0.275394665925662,  Check if the user has permission to synchronize the binaries.," private boolean isAllowedUser(Resource resource) throws RepositoryException{
        ResourceResolver resolver = resource.getResourceResolver();
        Session session = resolver.adaptTo(Session.class);
        UserManager userManager = AccessControlUtil.getUserManager(session);
        User user = userManager.getAuthorizable(session.getUserID());
        if (user == null) {
            return false;
        }
        Set<String> allowedUsers = this.config.getAllowedUsers();
        if (allowedUsers.isEmpty()) {
            return true;
        }
        for (String allowedUser : allowedUsers) {
            if (user.getID().equals(allowedUser)) {
                return true;
            }
        }
        return false;
    }","private boolean isAllowedUser(Resource resource) throws RepositoryException{
        ResourceResolver resolver = resource.getResourceResolver();
        Session session = resolver.adaptTo(Session.class);
        UserManager userManager = AccessControlUtil.getUserManager(session);
        User user = userManager.getAuthorizable(session.getUserID());
        String userId = user.getID();
        if (ADMIN_ID.equals(userId)) {
            return false;
        }
        ValueMap props = resource.getValueMap();
        String[] allowedUsers = props.get(RemoteAssets.ALLOWED_USERS, new String[0]);
        for (String allowedUser : allowedUsers) {
            if (allowedUser.equals(userId)) {
                return true;
            }
        }
        return false;
    }"," private boolean isAllowedUser(Resource resource) throws RepositoryException{
        ResourceResolver resolver = resource.getResourceResolver();
        Session session = resolver.adaptTo(Session.class);
        UserManager userManager = AccessControlUtil.getUserManager(session);
        User user = userManager.getAuthorizable(ADMIN_ID);
        return user.isGroupMember(this.config.getAllowedGroup());
    }"," private boolean isAllowedUser(Resource resource) throws RepositoryException{
        ResourceResolver resolver = resource.getResourceResolver();
        Session session = resolver.adaptTo(Session.class);
        UserManager userManager = AccessControlUtil.getUserManager(session);
        User user = userManager.getAuthorizable(ADMIN_ID);
        return user.isAdmin();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4805083858716689,  0.45261655344089097,  0.31060538152888656,  0.33686165812888097,84.0,0.6131386861313869,92.0,0.6715328467153284,92.0,0.6715328467153284,89.0,0.6496350364963503,47.0,0.34814814814814815,67.0,0.536,64.0,0.512,35.0,0.8536585365853658,4.0,0.36363636363636365,5.0,0.5
107,jackson-databind,"public T valueToTree(Object fromValue) throws IllegalArgumentException{
    if (fromValue == null) {
        return (T) getNodeFactory().nullNode();
    }
    final SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);
    final DefaultSerializerProvider context = _serializerProvider(config);
    TokenBuffer buf = context.bufferForValueConversion(this);
    if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
        buf = buf.forceUseOfBigDecimal(true);
    }
    try {
        context.serializeValue(buf, fromValue);
        try (JsonParser p = buf.asParser()) {
            return readTree(p);
        }
    } catch (IOException e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    }
}",valueToTree,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Method that is reverse of {@link #treeToValue}: it
     * will convert given Java value (usually bean) into its
     * equivalent Tree mode {@link JsonNode} representation.
     * Functionally similar to serializing value into token stream and parsing that
     * stream back as tree model node,
     * but more efficient as {@link TokenBuffer} is used to contain the intermediate
     * representation instead of fully serialized contents.
     *<p>
     * NOTE: while results are usually identical to that of serialization followed
     * by deserialization, this is not always the case. In some cases serialization
     * into intermediate representation will retain encapsulation of things like
     * raw value ({@link com.fasterxml.jackson.databind.util.RawValue}) or basic
     * node identity ({@link JsonNode}). If so, result is a valid tree, but values
     * are not re-constructed through actual format representation. So if transformation
     * requires actual materialization of encoded content,
     * it will be necessary to do actual serialization.
     * 
     * @param <T> Actual node type; usually either basic {@link JsonNode} or
     *  {@link com.fasterxml.jackson.databind.node.ObjectNode}
     * @param fromValue Java value to convert
     *
     * @return (non-null) Root node of the resulting content tree: in case of
     *   {@code null} value node for which {@link JsonNode#isNull()} returns {@code true}.
     */",3344-3396,"('valueToTree', {'INSTRUCTION': {'covered': 41, 'missed': 8}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 2}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",136.0,34.0,Method that is reverse of {@link #treeToValue}: it  will convert given Java value (usually bean) into its  equivalent Tree mode {@link JsonNode} representation.,Reverse method to {@link #treeToValue}: the provided Java value (usually a bean) is converted into its equivalent representation in Tree mode {@link JsonNode}. It is used to hold the intermediate representation instead of the fully serialised content.,"The method is reverse of @link #treeToValue, it will convert given Java value into its equivalent Tree mode.",0.744966993140192,  Reverse method of {@link #treeToValue}: it will convert the given Java value (usually bean) to its equivalent in Tree view {@link JsonNode representation}.,Not Valid,"public T valueToTree(Object fromValue) throws IllegalArgumentException{
        if (fromValue == null) {
            return null;
        }
        if (fromValue instanceof JsonNode) {
            return (T) fromValue;
        }
        if (fromValue instanceof String) {
            return (T) new TextNode((String) fromValue);
        }
        if (fromValue instanceof Number) {
            return (T) new NumberNode((Number) fromValue);
        }
        if (fromValue instanceof Boolean) {
            return (T) BooleanNode.valueOf((Boolean) fromValue);
        }
        if (fromValue instanceof Collection) {
            Collection<?> coll = (Collection<?>) fromValue;
            ArrayNode an = createArrayNode();
            for (Object o : coll) {
                an.add(valueToTree(o));
            }
            return (T) an;
        }
        if (fromValue instanceof Map) {
            Map<?,?> map = (Map<?,?>) fromValue;
            ObjectNode on = createObjectNode();
            for (Map.Entry<?,?> entry : map.entrySet()) {
                on.set(String.valueOf(entry.getKey()), valueToTree(entry.getValue()));
            }
            return (T) on;
        }
        if (fromValue instanceof Enum) {
            return (T) new TextNode(((Enum<?>) fromValue).name());
        }
        if (fromValue instanceof Calendar) {
            return (T) new TextNode(ISO8601Utils.format((Calendar) fromValue));
        }
        if (fromValue instanceof Date) {
            return (T) new TextNode(ISO8601Utils.format((Date) fromValue));
        }
        if (fromValue instanceof TemporalAccessor) {
            return (T) new TextNode(ISO8601Utils.format((TemporalAccessor) fromValue));
        }
        if (fromValue instanceof Temporal) {
            return (T) new TextNode(ISO8601Utils.format((Temporal) fromValue));
        }
        if (from        
 }"," public T valueToTree(Object fromValue) throws IllegalArgumentException{
        if (fromValue == null) {
            return null;
        }
        if (fromValue instanceof TreeNode) {
            return (T) fromValue;
        }
        if (fromValue instanceof JsonNode) {
            return (T) fromValue;
        }
        if (fromValue instanceof byte[]) {
            return (T) binaryNode((byte[]) fromValue);
        }
        if (fromValue instanceof Number) {
            return (T) numberNode(((Number) fromValue).doubleValue());
        }
        if (fromValue instanceof Boolean) {
            return (T) booleanNode((Boolean) fromValue);
        }
        if (fromValue instanceof String) {
            return (T) textNode((String) fromValue);
        }
        if (fromValue instanceof Character) {
            return (T) textNode(String.valueOf(fromValue));
        }
        if (fromValue instanceof Map) {
            return (T) objectNode((Map<?,?>) fromValue);
        }
        if (fromValue instanceof Iterable) {
            return (T) arrayNode((Iterable<?>) fromValue);
        }
        if (fromValue.getClass().isArray()) {
            return (T) arrayNode(fromValue);
        }
        throw new IllegalArgumentException(""Unsupported value type: ""+fromValue.getClass().getName());
    }"," public T valueToTree(Object fromValue) throws IllegalArgumentException{
        if (fromValue == null) {
            return null;
        }
        if (fromValue instanceof JsonNode) {
            return (T) fromValue;
        }
        if (fromValue instanceof byte[]) {
            return (T) binaryNode((byte[]) fromValue);
        }
        if (fromValue instanceof Number) {
            return (T) numberNode((Number) fromValue);
        }
        if (fromValue instanceof Boolean) {
            return (T) booleanNode((Boolean) fromValue);
        }
        if (fromValue instanceof Character) {
            return (T) textNode(String.valueOf(fromValue));
        }
        if (fromValue instanceof String) {
            return (T) textNode((String) fromValue);
        }
        if (fromValue instanceof Map) {
            return (T) objectNode((Map<?,?>) fromValue);
        }
        if (fromValue instanceof Iterable) {
            return (T) arrayNode((Iterable<?>) fromValue);
        }
        if (fromValue.getClass().isArray()) {
            return (T) arrayNode(fromValue);
        }
        return (T) pojoNode(fromValue);
    }",Not Valid,Syntax Error,NOT PASS,NOT PASS,None,None,  0.25400658610528143,  0.2693758275371808,None,None,None,None,156.0,0.6995515695067265,175.0,0.6972111553784861,None,None,222.0,0.9955156950672646,250.0,0.9960159362549801,29.0,0.7631578947368421,10.0,0.4166666666666667,10.0,0.4166666666666667
108,cdk,"private static PermutationParity fill2DCoordinates(IAtomContainer container, IAtom a, List<IBond> connected, Point2d[] coordinates, int[] elevations, int offset){
    int i = 0;
    coordinates[offset + 1] = a.getPoint2d();
    elevations[offset + 1] = 0;
    int[] indices = new int[2];
    for (IBond bond : connected) {
        if (!isDoubleBond(bond)) {
            IAtom other = bond.getOther(a);
            coordinates[i + offset] = other.getPoint2d();
            elevations[i + offset] = elevation(bond, a);
            indices[i] = container.indexOf(other);
            i++;
        }
    }
    if (i == 1) {
        return PermutationParity.IDENTITY;
    } else {
        return new BasicPermutationParity(indices);
    }
}",fill2DCoordinates,org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,"/**
     * Fill the {@literal coordinates} and {@literal elevation} from the given
     * offset index. If there is only one connection then the second entry (from
     * the offset) will use the coordinates of <i>a</i>. The permutation parity
     * is also built and returned.
     *
     * @param container   atom container
     * @param a           the central atom
     * @param connected   bonds connected to the central atom
     * @param coordinates the coordinates array to fill
     * @param elevations  the elevations of the connected atoms
     * @param offset      current location in the offset array
     * @return the permutation parity
     */",215-253,"('fill2DCoordinates', {'INSTRUCTION': {'covered': 68, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",164.0,19.0,Fill the {@literal coordinates} and {@literal elevation} from the given  offset index.,"Starting from the given offset index, it fills the {@ literal coordinates} and {@ literal heights}. The second entry (from the offset) will use the coordinates of <i> a </i> in case there is only one connection.",The coordinates and elevation are from the offset index.,0.356782922290219,  Fill in the {coordinates @literal} and {@literal elevation} from the given offset index.,"private static PermutationParity fill2DCoordinates(IAtomContainer container, IAtom a, List<IBond> connected, Point2d[] coordinates, int[] elevations, int offset){
        int i = 0;
        for (IBond bond : connected) {
            IAtom b = bond.getOther(a);
            if (b.getPoint2d() != null) {
                coordinates[i + offset] = b.getPoint2d();
                elevations[i + offset] = container.indexOf(b);
                i++;
            }
        }
        return new PermutationParity(i);        
 }","private static PermutationParity fill2DCoordinates(IAtomContainer container, IAtom a, List<IBond> connected, Point2d[] coordinates, int[] elevations, int offset){
        int i = offset;
        for (IBond bond : connected) {
            IAtom b = bond.getOther(a);
            if (b.getPoint2d() != null) {
                coordinates[i] = b.getPoint2d();
                elevations[i] = bond.getOrder().numeric();
                i++;
            }
        }
        return new PermutationParity(i - offset, elevations);       
 }","private static PermutationParity fill2DCoordinates(IAtomContainer container, IAtom a, List<IBond> connected, Point2d[] coordinates, int[] elevations, int offset){
        for (IBond bond : connected) {
            IAtom b = bond.getOther(a);
            coordinates[offset] = container.getAtomPoint2d(b);
            elevations[offset] = container.getAtomNumber(b);
            offset++;
        }
        return new PermutationParity(elevations);       
 }","private static PermutationParity fill2DCoordinates(IAtomContainer container, IAtom a, List<IBond> connected, Point2d[] coordinates, int[] elevations, int offset){
        for (int i = 0; i < connected.size(); i++) {
            IBond bond = connected.get(i);
            IAtom b = bond.getOther(a);
            coordinates[offset + i] = container.getAtomPoint2d(b);
            elevations[offset + i] = container.getAtomNumber(b);
        }
        return new PermutationParity(elevations);       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.45309692535433255,  0.40646216159757437,  0.3996175495885121,  0.3229031569135021,83.0,0.503030303030303,90.0,0.5454545454545454,86.0,0.5212121212121212,89.0,0.5393939393939394,15.0,0.13761467889908258,38.0,0.35185185185185186,27.0,0.25471698113207547,33.0,0.868421052631579,3.0,0.21428571428571427,7.0,0.5384615384615384
109,matsim-libs,"protected Path constructPath(Node fromNode, Node toNode, double startTime, double arrivalTime){
    List<Node> nodes = new ArrayList<>();
    List<Link> links = new ArrayList<>();
    nodes.add(0, toNode);
    Link tmpLink = getData(toNode).getPrevLink();
    if (tmpLink != null) {
        while (tmpLink.getFromNode() != fromNode) {
            links.add(0, tmpLink);
            nodes.add(0, tmpLink.getFromNode());
            tmpLink = getData(tmpLink.getFromNode()).getPrevLink();
        }
        links.add(0, tmpLink);
        nodes.add(0, tmpLink.getFromNode());
    }
    DijkstraNodeData toNodeData = getData(toNode);
    Path path = new Path(nodes, links, arrivalTime - startTime, toNodeData.getCost());
    return path;
}",constructPath,org/matsim/core/router/Dijkstra.java,/matsim/src/main/java/org/matsim/core/router/Dijkstra.java,"/**
         * Constructs the path after the algorithm has been run.
         *
         * @param fromNode
         *            The node where the path starts.
         * @param toNode
         *            The node where the path ends.
         * @param startTime
         *            The time when the trip starts.
         */",321-351,"('constructPath', {'INSTRUCTION': {'covered': 65, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",176.0,10.0,Constructs the path after the algorithm has been run.,"After execution of the algorithm, the path is constructed",The path is constructed after the algorithm has been run.,0.228797063057459,  Constructs the path after the algorithm is run.,Empty Method,Empty Method,"protected Path constructPath(Node fromNode, Node toNode, double startTime, double arrivalTime){
	 		
 		Path path = new Path(this.network);
 		path.setStartTime(startTime);
 		path.setEndTime(arrivalTime);
 		path.setTravelTime(arrivalTime - startTime);
 		path.setDistance(getData(toNode).getDistance());
 		path.setCost(getData(toNode).getCost());
 		path.setMode(this.mode);
 		path.setRouteDescription(this.routeDescription);
 		
 		Node currentNode = toNode;
 		while (currentNode != fromNode) {
 			Node nextNode = getData(currentNode).getFromNode();
 			path.addNode(nextNode);
 			path.addTravelTime(getData(currentNode).getTime() - getData(nextNode).getTime());
 			path.addCost(getData(currentNode).getCost() - getData(nextNode).getCost());
 			path.addDistance(getData(currentNode).getDistance() - getData(nextNode).getDistance());
 			currentNode = nextNode;
 		}
 		path.addNode(fromNode);
 		path.addTravelTime(0.);
 		path.addCost(0.);
 		path.addDistance(0.);
 		
 		return path;
 	}"," protected Path constructPath(Node fromNode, Node toNode, double startTime, double arrivalTime){
	 		
 		// construct the path
 		Path path = new Path(this.network);
 		path.setStartTime(startTime);
 		path.setEndTime(arrivalTime);
 		path.setTravelTime(arrivalTime - startTime);
 		path.setDistance(getData(toNode).getDistance());
 		path.setCost(getData(toNode).getCost());
 		path.setMode(this.mode);
 		path.setFromNode(fromNode);
 		path.setToNode(toNode);
 		
 		// add all nodes to the path
 		Node currentNode = toNode;
 		while (currentNode != fromNode) {
 			path.addNode(currentNode);
 			currentNode = getData(currentNode).getPredecessor();
 		}
 		path.addNode(fromNode);
 		
 		// add all links to the path
 		Node previousNode = fromNode;
 		for (Node node : path.getNodes()) {
 			Link link = this.network.getLinks().get(previousNode.getId(), node.getId());
 			path.addLink(link);
 			previousNode = node;
 		}
 		
 		return path;
 	}",Empty Method,Empty Method,NOT PASS,NOT PASS,None,None,  0.36492343433230107,  0.3878558105413877,None,None,None,None,127.0,0.635,150.0,0.6382978723404256,None,None,199.0,0.995,234.0,0.9957446808510638,9.0,0.9,2.0,0.2,4.0,0.36363636363636365
110,matsim-libs,"public static void copyTo(Attributes from, Attributes to){
    for (var entry : from.getAsMap().entrySet()) {
        to.putAttribute(entry.getKey(), entry.getValue());
    }
}",copyTo,org/matsim/utils/objectattributes/attributable/AttributesUtils.java,/matsim/src/main/java/org/matsim/utils/objectattributes/attributable/AttributesUtils.java,"/**
         * Adds the mappings from ""from"" to ""to"". Nothing is done to copy the Object themselves,
         * which should be fine for 99.9% of the usecases of Attributes (value objects)
         */",31-39,"('copyTo', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,12.0,"Adds the mappings from ""from"" to ""to"".","The method in question allows mappings to be added from 'from' to 'to'. While for copying the objects themselves, nothing is done, which should be fine for 99.9% of Attribute (value object) use cases.","The mappings are changed from ""from"" to ""to"".",0.384669713515458,"  Adds mappings from ""from"" to ""to""."," public static void copyTo(Attributes from, Attributes to){
     	for (String key : from.getAttributeKeys()) {
     		to.putAttribute(key, from.getAttribute(key));
     	}       
 }"," public static void copyTo(Attributes from, Attributes to){
     	to.getAttributes().putAll(from.getAttributes());        
 }"," public static void copyTo(Attributes from, Attributes to){
     	to.putAll(from);        
 }"," public static void copyTo(Attributes from, Attributes to){
     	for (String key : from.getAttributeKeys()) {
     		to.putAttribute(key, from.getAttribute(key));
     	}       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5935519943212173,  0.4467516536404747,  0.5935519943212173,  0.2916650900959123,15.0,0.3125,24.0,0.5,15.0,0.3125,29.0,0.6041666666666666,16.0,0.3902439024390244,0.0,0.0,21.0,0.5121951219512195,31.0,0.8857142857142857,1.0,0.125,4.0,0.4444444444444444
111,jackson-databind,"public JsonNode replace(String propertyName, JsonNode value){
    if (value == null) {
        value = nullNode();
    }
    return _children.put(propertyName, value);
}",replace,com/fasterxml/jackson/databind/node/ObjectNode.java,/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java,"/**
     * Method for replacing value of specific property with passed
     * value, and returning value (or null if none).
     *
     * @param propertyName Property of which value to replace
     * @param value Value to set property to, replacing old value if any
     * 
     * @return Old value of the property; null if there was no such property
     *   with value
     * 
     * @since 2.1
     */",439-457,"('replace', {'INSTRUCTION': {'covered': 9, 'missed': 3}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,21.0,"Method for replacing value of specific property with passed  value, and returning value (or null if none).",The value of a specific property is replaced with the passed value and returns the value (or null if there is none).,The method for replacing the value of the property with another is called a substitution.,0.771889237090254,  How to replace the value of a specific property with a passed value and return the value (or null if none).," public JsonNode replace(String propertyName, JsonNode value){
        if (value == null) {
            value = nullNode();
        }
        _children.put(propertyName, value);
        return value;
    }"," public JsonNode replace(String propertyName, JsonNode value){
        if (value == null) {
            value = nullNode();
        }
        _children.put(propertyName, value);
        return value;
    }"," public JsonNode replace(String propertyName, JsonNode value){
        if (value == null) {
            value = nullNode();
        }
        _children.put(propertyName, value);
        return this;
    }"," public JsonNode replace(String propertyName, JsonNode value){
        if (value == null) {
            value = nullNode();
        }
        return _children.put(propertyName, value);
    }",NOT PASS,NOT PASS,PASS,NOT PASS,  0.9082350069894055,  0.9082350069894055,  1.0,  0.9082350069894055,4.0,0.10256410256410256,4.0,0.10256410256410256,0.0,0.0,4.0,0.10256410256410256,0.0,0.0,4.0,0.10256410256410256,1.0,0.02564102564102564,12.0,0.5217391304347826,9.0,0.4090909090909091,13.0,0.7222222222222222
112,cdk,"protected static String formatMDLFloat(float fl){
    String s = """", fs = """";
    int l;
    NumberFormat nf = NumberFormat.getNumberInstance(Locale.ENGLISH);
    nf.setMinimumIntegerDigits(1);
    nf.setMaximumIntegerDigits(4);
    nf.setMinimumFractionDigits(4);
    nf.setMaximumFractionDigits(4);
    nf.setGroupingUsed(false);
    if (Double.isNaN(fl) || Double.isInfinite(fl))
        s = ""0.0000"";
    else
        s = nf.format(fl);
    l = 10 - s.length();
    for (int f = 0; f < l; f++) fs += "" "";
    fs += s;
    return fs;
}",formatMDLFloat,org/openscience/cdk/io/MDLV2000Writer.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Writer.java,"/**
     * Formats a float to fit into the connectiontable and changes it
     * to a String.
     *
     * @param fl The float to be formated
     * @return The String to be written into the connectiontable
     */",1347-1372,"('formatMDLFloat', {'INSTRUCTION': {'covered': 67, 'missed': 3}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 14, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",134.0,15.0,Formats a float to fit into the connectiontable and changes it  to a String.,This method formats a float to insert it into the connection table and changes it to a string.,A float is formatted to fit into the connectiontable and changed to a String.,0.806747037444189,  Formats a float to fit the connection table and replaces it with a string.," protected static String formatMDLFloat(float fl){
        return formatMDLFloat(fl, WIDTH);       
 }","protected static String formatMDLFloat(float fl){
        String s = Float.toString(fl);
        if (s.indexOf('.') == -1)
            s += "".0"";
        return s;
    }"," protected static String formatMDLFloat(float fl){
        return formatMDLFloat(fl, WIDTH);       
 }","protected static String formatMDLFloat(float fl){
        String s = Float.toString(fl);
        if (s.length() > 10)
            s = s.substring(0, 10);
        return s;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.0701575634903577,  0.15301181541157566,  0.17090429464892934,  0.0701575634903577,120.0,0.8888888888888888,105.0,0.7777777777777778,101.0,0.7481481481481481,120.0,0.8888888888888888,25.0,0.625,29.0,0.6444444444444445,0.0,0.0,8.0,0.42105263157894735,6.0,0.4,6.0,0.4
113,matsim-libs,"public static Carriers createShipmentVRPCarrierFromServiceVRPSolution(Carriers carriers){
    Carriers carriersWithShipments = new Carriers();
    for (Carrier carrier : carriers.getCarriers().values()) {
        Carrier carrierWS = CarrierUtils.createCarrier(carrier.getId());
        if (carrier.getShipments().size() > 0) {
            copyShipments(carrierWS, carrier);
        }
        if (carrier.getServices().size() > 0) {
            createShipmentsFromServices(carrierWS, carrier);
        }
        carrierWS.setCarrierCapabilities(carrier.getCarrierCapabilities());
        carriersWithShipments.addCarrier(carrierWS);
    }
    return carriersWithShipments;
}",createShipmentVRPCarrierFromServiceVRPSolution,org/matsim/contrib/freight/utils/FreightUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/utils/FreightUtils.java,"/**
         * Creates a new {@link Carriers} container only with {@link CarrierShipment}s
         * for creating a new VRP. As consequence of the transformation of
         * {@link CarrierService}s to {@link CarrierShipment}s the solution of the VRP
         * can have tours with vehicles returning to the depot and load for another tour
         * instead of creating another vehicle with additional (fix) costs. <br/>
         * The method is meant for multi-depot problems. Here, the original ""services""
         * input does not have an assignment of services to depots. The solution to the
         * problem, however, does. So the assignment is taken from that solution, and
         * each returned {@link Carrier} has that depot as pickup location in each
         * shipment.
         *
         * @param carriers carriers with a Solution (result of solving the VRP).
         * @return Carriers carriersWithShipments
         */",143-174,"('createShipmentVRPCarrierFromServiceVRPSolution', {'INSTRUCTION': {'covered': 44, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",116.0,23.0,Creates a new {@link Carriers} container only with {@link CarrierShipment}s  for creating a new VRP.,"To create a new VRP create a new container {@link Carriers} only with {@link CarrierShipment}.  The VRP solution can have tours with vehicles that return to the depot and load for another tour instead of creating another vehicle with additional (fixed) costs As a consequence of transforming {@link CarrierService}s to {@link CarrierShipment}s   The method makes it possible to handle problems with multiple repositories. The original 'services' input does not provide for assigning services to depots.  Therefore, the assignment is taken from that solution and each {@link Carrier} returned has that depot as pick-up location in each dispatch.",A new container is created with the help of the CarrierShipment.,0.618711687071035,  Creates a container {@link Carriers} only with {@link CarrierShipment} to create a new VRP.," public static Carriers createShipmentVRPCarrierFromServiceVRPSolution(Carriers carriers){
	 Carriers newCarriers = new Carriers();
	 for (Carrier carrier : carriers.getCarriers().values()) {
		 Carrier newCarrier = new Carrier();
		 newCarrier.setId(carrier.getId());
		 newCarrier.setName(carrier.getName());
		 newCarrier.setCarrierCapacity(carrier.getCarrierCapacity());
		 newCarrier.setCarrierPlan(carrier.getSelectedPlan());
		 newCarrier.setCarrierVehicleTypes(carrier.getCarrierVehicleTypes());
		 newCarrier.setCarrierServices(carrier.getServices());
		 newCarrier.setCarrierShipments(carrier.getShipments());
		 newCarriers.addCarrier(newCarrier);
	 }
	 return newCarriers;			
 }"," public static Carriers createShipmentVRPCarrierFromServiceVRPSolution(Carriers carriers){
	 Carriers newCarriers = new Carriers();
	 for (Carrier carrier : carriers.getCarriers().values()) {
		 Carrier newCarrier = new Carrier(carrier.getId());
		 newCarrier.setCarrierCapacity(carrier.getCarrierCapacity());
		 newCarrier.setCarrierVehicleTypes(carrier.getCarrierVehicleTypes());
		 newCarrier.setCarrierServices(carrier.getCarrierServices());
		 newCarrier.setCarrierShipments(carrier.getCarrierShipments());
		 newCarrier.setSelectedPlan(carrier.getSelectedPlan());
		 newCarriers.addCarrier(newCarrier);
	 }
	 return newCarriers;			
 }"," public static Carriers createShipmentVRPCarrierFromServiceVRPSolution(Carriers carriers){
	 Carriers newCarriers = new Carriers();
	 for (Carrier carrier : carriers.getCarriers().values()) {
		 Carrier newCarrier = new Carrier();
		 newCarrier.setId(carrier.getId());
		 newCarrier.setName(carrier.getName());
		 newCarrier.setCarrierCapacity(carrier.getCarrierCapacity());
		 newCarrier.setCarrierVehicleTypes(carrier.getCarrierVehicleTypes());
		 newCarrier.setCarrierServices(carrier.getCarrierServices());
		 newCarrier.setCarrierShipments(carrier.getCarrierShipments());
		 newCarrier.setCarrierPlan(carrier.getSelectedPlan());
		 newCarriers.addCarrier(newCarrier);
	 }
	 return newCarriers;
 }"," public static Carriers createShipmentVRPCarrierFromServiceVRPSolution(Carriers carriers){
	 Carriers newCarriers = new Carriers();
	 for (Carrier carrier : carriers.getCarriers().values()) {
		 Carrier newCarrier = new Carrier();
		 newCarrier.setId(carrier.getId());
		 newCarrier.setName(carrier.getName());
		 newCarrier.setCarrierCapacity(carrier.getCarrierCapacity());
		 newCarrier.setCarrierVehicleTypes(carrier.getCarrierVehicleTypes());
		 newCarrier.setCarrierServices(carrier.getCarrierServices());
		 newCarrier.setCarrierShipments(carrier.getCarrierShipments());
		 newCarrier.setSelectedPlan(carrier.getSelectedPlan());
		 newCarriers.addCarrier(newCarrier);
	 }
	 return newCarriers;			
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5989280061931795,  0.5899214625486291,  0.5775047660842662,  0.5775047660842662,54.0,0.4122137404580153,44.0,0.37606837606837606,54.0,0.4122137404580153,54.0,0.4122137404580153,25.0,0.19083969465648856,8.0,0.061068702290076333,8.0,0.061068702290076333,88.0,0.8979591836734694,5.0,0.3125,13.0,0.8125
114,weblogic-kubernetes-operator,"public static boolean isFirstNewer(V1ObjectMeta first, V1ObjectMeta second){
    if (second == null) {
        return true;
    }
    if (first == null) {
        return false;
    }
    OffsetDateTime time1 = first.getCreationTimestamp();
    OffsetDateTime time2 = second.getCreationTimestamp();
    if (time1.equals(time2)) {
        return getResourceVersion(first).compareTo(getResourceVersion(second)) > 0;
    } else {
        return time1.isAfter(time2);
    }
}",isFirstNewer,oracle/kubernetes/operator/helpers/KubernetesUtils.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/KubernetesUtils.java,"/**
   * Returns true if the first metadata indicates a newer resource than does the second. 'Newer'
   * indicates that the creation time is later. If two items have the same creation time, a higher
   * resource version indicates the newer resource.
   *
   * @param first  the first item to compare
   * @param second the second item to compare
   * @return true if the first object is newer than the second object
   */",122-147,"('isFirstNewer', {'INSTRUCTION': {'covered': 30, 'missed': 2}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,15.0,Returns true if the first metadata indicates a newer resource than does the second.,"If the first metadata indicates a more recent resource than the second returns True. Whereas, in the case where two elements have the same creation time, a resource version plus resource version indicates the more recent resource.","If the first and second gis show a newer resource, then it's true.",0.47128674647248,  Returns true if the first metadata indicates a newer resource than the second.,"public static boolean isFirstNewer(V1ObjectMeta first, V1ObjectMeta second){
    if (first == null || second == null) {
      return false;
    }
    if (first.getResourceVersion() == null || second.getResourceVersion() == null) {
      return false;
    }
    return new BigInteger(first.getResourceVersion()).compareTo(new BigInteger(second.getResourceVersion())) > 0;
  }","public static boolean isFirstNewer(V1ObjectMeta first, V1ObjectMeta second){
    if(first == null || second == null) {
      return false;
    }
    OffsetDateTime firstCreationTime = first.getCreationTimestamp();
    OffsetDateTime secondCreationTime = second.getCreationTimestamp();
    if(firstCreationTime == null || secondCreationTime == null) {
      return false;
    }
    if(firstCreationTime.isAfter(secondCreationTime)) {
      return true;
    }
    if(firstCreationTime.isEqual(secondCreationTime)) {
      String firstResourceVersion = first.getResourceVersion();
      String secondResourceVersion = second.getResourceVersion();
      if(firstResourceVersion == null || secondResourceVersion == null) {
        return false;
      }
      if(firstResourceVersion.compareTo(secondResourceVersion) > 0) {
        return true;
      }
    }
    return false;
  }","public static boolean isFirstNewer(V1ObjectMeta first, V1ObjectMeta second){
    if(first == null || second == null) {
      return false;
    }
    OffsetDateTime firstCreated = first.getCreationTimestamp();
    OffsetDateTime secondCreated = second.getCreationTimestamp();
    if(firstCreated == null || secondCreated == null) {
      return false;
    }
    return firstCreated.isAfter(secondCreated);
  }","public static boolean isFirstNewer(V1ObjectMeta first, V1ObjectMeta second){
    if (first == null || second == null) {
      return false;
    }
    OffsetDateTime firstCreated = first.getCreationTimestamp();
    OffsetDateTime secondCreated = second.getCreationTimestamp();
    if (firstCreated == null || secondCreated == null) {
      return false;
    }
    return firstCreated.isAfter(secondCreated);
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.44917419585315826,  0.6724542061414737,  0.5835324237500814,  0.5835324237500814,50.0,0.5434782608695652,83.0,0.5971223021582733,38.0,0.41304347826086957,38.0,0.41304347826086957,76.0,0.5467625899280576,37.0,0.47435897435897434,37.0,0.47435897435897434,31.0,0.8157894736842105,1.0,0.06666666666666667,12.0,0.8
115,cdk,"public static Pattern findSubstructure(IAtomContainer query){
    boolean isQuery = query instanceof IQueryAtomContainer;
    return new Ullmann(query, isQuery ? AtomMatcher.forQuery() : AtomMatcher.forElement(), isQuery ? BondMatcher.forQuery() : BondMatcher.forOrder());
}",findSubstructure,org/openscience/cdk/isomorphism/Ullmann.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/Ullmann.java,"/**
     * Create a pattern which can be used to find molecules which contain the
     * {@code query} structure.
     *
     * @param query the substructure to find
     * @return a pattern for finding the {@code query}
     */",122-133,"('findSubstructure', {'INSTRUCTION': {'covered': 14, 'missed': 4}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",52.0,20.0,Create a pattern which can be used to find molecules which contain the  {@code query} structure.,The method allows the creation of a model that can be used to find molecules that contain the structure {@query code}.,A pattern can be created to find the @code query structure.,0.687299894559208,  Create a template that can be used to find molecules that contain the {@code query} structure.," public static Pattern findSubstructure(IAtomContainer query){
        return new Ullmann(query, new AtomMatcher(), new BondMatcher());        
 }"," public static Pattern findSubstructure(IAtomContainer query){
        return new Ullmann(query, new UniversalAtomMatcher(), new UniversalBondMatcher());      
 }"," public static Pattern findSubstructure(IAtomContainer query){
        return new Ullmann(query, new UniversalAtomMatcher(), new UniversalBondMatcher());      
 }"," public static Pattern findSubstructure(IAtomContainer query){
        return new Ullmann(query, new UniversalAtomMatcher(), new UniversalBondMatcher());      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2929490640711786,  0.29054764676409894,  0.29054764676409894,  0.29054764676409894,27.0,0.5094339622641509,29.0,0.5471698113207547,29.0,0.5471698113207547,29.0,0.5471698113207547,2.0,0.07142857142857142,2.0,0.07142857142857142,2.0,0.07142857142857142,12.0,0.5454545454545454,3.0,0.17647058823529413,9.0,0.5294117647058824
116,cron-utils,"public CronDefinition instance(){
    final Set<CronConstraint> validations = new HashSet<>();
    validations.addAll(cronConstraints);
    final List<FieldDefinition> values = new ArrayList<>(fields.values());
    values.sort(FieldDefinition.createFieldDefinitionComparator());
    return new CronDefinition(values, validations, matchDayOfWeekAndDayOfMonth);
}",instance,com/cronutils/model/definition/CronDefinitionBuilder.java,/src/main/java/com/cronutils/model/definition/CronDefinitionBuilder.java,"/**
     * Creates a new CronDefinition instance with provided field definitions.
     *
     * @return returns CronDefinition instance, never null
     */",156-167,"('instance', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,10.0,Creates a new CronDefinition instance with provided field definitions.,"From the provided field definitions, create a new instance of CronDefinition",A new CronDefinition instance is created with field definitions.,0.371087579804145,  Creates a CronDefinition instance with the provided field definitions.," public CronDefinition instance(){
        return new CronDefinition(fields, cronConstraints, matchDayOfWeekAndDayOfMonth);
    }"," public CronDefinition instance(){
        return new CronDefinition(fields, cronConstraints, matchDayOfWeekAndDayOfMonth);
    }",Not Valid,Not Valid,NOT PASS,NOT PASS,Not Valid,Not Valid,  0.11624038926677799,  0.11624038926677799,None,None,53.0,0.7571428571428571,53.0,0.7571428571428571,None,None,None,None,0.0,0.0,None,None,None,None,11.0,0.9166666666666666,2.0,0.2,5.0,0.5
117,weblogic-kubernetes-operator,"public V1TokenReviewStatus check(String principal, String token, String namespace){
    // Don't expose the token since it's a credential
    LOGGER.entering(principal);
    V1TokenReview result = null;
    try {
        boolean allowed = authorizationProxy.check(principal, AuthorizationProxy.Operation.create, AuthorizationProxy.Resource.TOKENREVIEWS, null, namespace == null ? AuthorizationProxy.Scope.cluster : AuthorizationProxy.Scope.namespace, namespace);
        if (allowed) {
            result = new CallBuilder().createTokenReview(prepareTokenReview(token));
        } else {
            LOGGER.warning(MessageKeys.CANNOT_CREATE_TOKEN_REVIEW);
        }
    } catch (ApiException e) {
        LOGGER.severe(MessageKeys.APIEXCEPTION_FROM_TOKEN_REVIEW, e);
        LOGGER.exiting(null);
        return null;
    }
    LOGGER.fine(""Returned TokenReview"", result);
    V1TokenReviewStatus status = result != null ? result.getStatus() : null;
    LOGGER.exiting(status);
    return status;
}",check,oracle/kubernetes/operator/helpers/AuthenticationProxy.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/AuthenticationProxy.java,"/**
   * Check if the specified access token can be authenticated.
   *
   * @param principal The user, group or service account.
   * @param token The access token that identifies the user.
   * @param namespace Namespace
   * @return V1TokenReviewStatus containing either info about the authenticated user or an error
   *     explaining why the user couldn't be authenticated
   */",20-57,"('check', {'INSTRUCTION': {'covered': 55, 'missed': 14}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 12, 'missed': 5}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",167.0,10.0,Check if the specified access token can be authenticated.,The method verifies whether the specified access token can be authenticated. The method verifies whether the specified access token can be authenticated. Return V1TokenReviewStatus containing either info about the authenticated user or an error.,"If the access token can be verified, check it.",0.135052338432147,  Check if the specified access token can be authenticated.,"public V1TokenReviewStatus check(String principal, String token, String namespace){
    V1TokenReview tokenReview = new V1TokenReview();
    V1TokenReviewSpec tokenReviewSpec = new V1TokenReviewSpec();
    tokenReviewSpec.setToken(token);
    tokenReviewSpec.setAudience(principal);
    tokenReview.setSpec(tokenReviewSpec);
    V1TokenReviewStatus tokenReviewStatus = null;
    try {
      tokenReviewStatus = authorizationProxy.check(tokenReview, namespace);
    } catch (ApiException e) {
      LOGGER.severe(MessageKeys.OPERATOR_AUTHENTICATION_FAILED, e.getCode(), e.getResponseBody(), e.getMessage());
    }
    return tokenReviewStatus;
  }","public V1TokenReviewStatus check(String principal, String token, String namespace){
    V1TokenReview tokenReview = new V1TokenReview();
    V1TokenReviewSpec tokenReviewSpec = new V1TokenReviewSpec();
    tokenReviewSpec.setToken(token);
    tokenReviewSpec.setAudience(namespace);
    tokenReviewSpec.setUsername(principal);
    tokenReview.setSpec(tokenReviewSpec);
    V1TokenReviewStatus tokenReviewStatus = null;
    try {
      tokenReviewStatus = authorizationProxy.check(tokenReview);
    } catch (ApiException e) {
      LOGGER.severe(MessageKeys.OPERATOR_AUTHENTICATION_FAILED, e.getCode(), e.getResponseBody(), e.getMessage());
    }
    return tokenReviewStatus;
  }","public V1TokenReviewStatus check(String principal, String token, String namespace){
    V1TokenReview tokenReview = new V1TokenReview();
    V1TokenReviewSpec tokenReviewSpec = new V1TokenReviewSpec();
    tokenReviewSpec.setToken(token);
    tokenReview.setSpec(tokenReviewSpec);
    V1TokenReviewStatus tokenReviewStatus = null;
    try {
      tokenReviewStatus = authorizationProxy.check(tokenReview, namespace);
    } catch (ApiException e) {
      LOGGER.warning(MessageKeys.AUTH_CHECK_FAILED, e.getCode(), e.getResponseBody(), e);
    }
    return tokenReviewStatus;
  }","public V1TokenReviewStatus check(String principal, String token, String namespace){
    V1TokenReview tokenReview = new V1TokenReview();
    V1TokenReviewSpec tokenReviewSpec = new V1TokenReviewSpec();
    tokenReviewSpec.setToken(token);
    tokenReviewSpec.setAudiences(new String[] { ""system:serviceaccounts"" });
    tokenReviewSpec.setGroups(new String[] { ""system:serviceaccounts"" });
    tokenReviewSpec.setUsername(principal);
    tokenReview.setSpec(tokenReviewSpec);
    V1TokenReviewStatus tokenReviewStatus = null;
    try {
      tokenReviewStatus = authorizationProxy.check(tokenReview, namespace);
    } catch (ApiException e) {
      LOGGER.severe(MessageKeys.AUTHENTICATION_FAILED, e.getCode(), e.getResponseBody(), e);
    }
    return tokenReviewStatus;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2991773165440143,  0.29957602362572155,  0.30434146255052896,  0.3069521491866549,111.0,0.6607142857142857,109.0,0.6488095238095238,114.0,0.6785714285714286,115.0,0.6845238095238095,9.0,0.07894736842105263,32.0,0.24427480916030533,13.0,0.11926605504587157,27.0,0.7714285714285715,0.0,0.0,6.0,0.6
118,jooby,"public static String unsign(@Nonnull final String value, @Nonnull final String secret){
    int sep = value.indexOf(""|"");
    if (sep <= 0) {
        return null;
    }
    String str = value.substring(sep + 1);
    return sign(str, secret).equals(value) ? str : null;
}",unsign,io/jooby/Cookie.java,/jooby/src/main/java/io/jooby/Cookie.java,"/**
   * Un-sign a value, previously signed with {@link #sign(String, String)}.
   * Produces a nonnull value or <code>null</code> for invalid.
   *
   * @param value A signed value.
   * @param secret A secret key.
   * @return A new signed value or null.
   */",464-479,"('unsign', {'INSTRUCTION': {'covered': 21, 'missed': 3}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,19.0,"Un-sign a value, previously signed with {@link #sign(String, String)}.","In this method an Un-sign a value, previously signed with {@link #sign(String, String)}, produces a nonnull value or <code>null</code> for invalid.","Un-sign a value that was previously signed with the @link #sign(String, String)",0.798209843641386,"  Unsign a value previously signed with {@link #sign(String, String)}.","public static String unsign(@Nonnull final String value, @Nonnull final String secret){
    try {
      String[] parts = value.split(""\\|"");
      if (parts.length != 2) {
        throw new IllegalArgumentException(""Invalid signed value: "" + value);
      }
      Mac mac = Mac.getInstance(HMAC_SHA256);
      mac.init(new SecretKeySpec(secret.getBytes(), HMAC_SHA256));
      byte[] bytes = mac.doFinal(parts[1].getBytes());
      String signature = Base64.getEncoder().withoutPadding().encodeToString(bytes);
      if (!signature.equals(parts[0])) {
        throw new IllegalArgumentException(""Invalid signature: "" + value);
      }
      return parts[1];
    } catch (Exception x) {
      throw SneakyThrows.propagate(x);
    }
  }","public static String unsign(@Nonnull final String value, @Nonnull final String secret){
    try {
      String[] parts = value.split(""\\|"");
      if (parts.length != 2) {
        return null;
      }
      Mac mac = Mac.getInstance(HMAC_SHA256);
      mac.init(new SecretKeySpec(secret.getBytes(), HMAC_SHA256));
      byte[] bytes = mac.doFinal(parts[1].getBytes());
      String signature = Base64.getEncoder().withoutPadding().encodeToString(bytes);
      if (!signature.equals(parts[0])) {
        return null;
      }
      return parts[1];
    } catch (Exception x) {
      throw SneakyThrows.propagate(x);
    }
  }","public static String unsign(@Nonnull final String value, @Nonnull final String secret){
    try {
      String[] parts = value.split(""\\|"");
      if (parts.length != 2) {
        throw new IllegalArgumentException(""Invalid signed value: "" + value);
      }
      Mac mac = Mac.getInstance(HMAC_SHA256);
      mac.init(new SecretKeySpec(secret.getBytes(), HMAC_SHA256));
      byte[] bytes = mac.doFinal(parts[1].getBytes());
      String expected = Base64.getEncoder().withoutPadding().encodeToString(bytes);
      if (!expected.equals(parts[0])) {
        throw new IllegalArgumentException(""Signature doesn't match: "" + value);
      }
      return parts[1];
    } catch (Exception x) {
      throw SneakyThrows.propagate(x);
    }
  }","public static String unsign(@Nonnull final String value, @Nonnull final String secret){
    try {
      String[] parts = value.split(""\\|"");
      if (parts.length != 2) {
        throw new IllegalArgumentException(""Invalid signed value: "" + value);
      }
      Mac mac = Mac.getInstance(HMAC_SHA256);
      mac.init(new SecretKeySpec(secret.getBytes(), HMAC_SHA256));
      byte[] bytes = mac.doFinal(parts[1].getBytes());
      String expected = Base64.getEncoder().withoutPadding().encodeToString(bytes);
      if (!expected.equals(parts[0])) {
        throw new IllegalArgumentException(""Invalid signature: "" + value);
      }
      return parts[1];
    } catch (Exception x) {
      throw SneakyThrows.propagate(x);
    }
  }",NOT PASS,PASS,NOT PASS,NOT PASS,  0.4784460532206297,  0.4622997521073705,  0.4645571643317409,  0.46431599283998026,117.0,0.7177914110429447,103.0,0.6821192052980133,117.0,0.7177914110429447,117.0,0.7177914110429447,16.0,0.09815950920245399,2.0,0.012269938650306749,3.0,0.018404907975460124,13.0,0.5909090909090909,2.0,0.2,6.0,0.46153846153846156
119,cdk,"public IAtomContainer kekuliseAromaticRings(IAtomContainer molecule) throws CDKException{
    IAtomContainer mNew = null;
    try {
        mNew = (IAtomContainer) molecule.clone();
    } catch (Exception e) {
        throw new CDKException(""Failed to clone source molecule"");
    }
    IRingSet ringSet;
    try {
        ringSet = removeExtraRings(mNew);
    } catch (CDKException x) {
        throw x;
    } catch (Exception x) {
        throw new CDKException(""failure in SSSRFinder.findAllRings"", x);
    }
    if (ringSet == null) {
        throw new CDKException(""failure in SSSRFinder.findAllRings"");
    }
    // We need to establish which rings share bonds and set up sets of such interdependant rings
    List<Integer[]> rBondsArray = null;
    List<List<Integer>> ringGroups = null;
    // Start by getting a list (same dimensions and ordering as ringset) of all the ring bond numbers in the reduced ring set
    rBondsArray = getRingSystem(mNew, ringSet);
    // Now find out which share a bond and assign them accordingly to groups
    ringGroups = assignRingGroups(rBondsArray);
    // Loop through each group of rings checking all choices of double bond combis and seeing if you can get a
    // proper molecule.
    for (int i = 0; i < ringGroups.size(); i++) {
        // Set all ring bonds with single order to allow Matrix solving to work
        setAllRingBondsSingleOrder(ringGroups.get(i), ringSet);
        // Set up  lists of atoms, bonds and atom pairs for this ringGroup
        List<Integer> atomNos = null;
        atomNos = getAtomNosForRingGroup(mNew, ringGroups.get(i), ringSet);
        List<Integer> bondNos = null;
        bondNos = getBondNosForRingGroup(mNew, ringGroups.get(i), ringSet);
        // Array of same dimensions as bondNos (cols in Matrix)
        List<Integer[]> atomNoPairs = null;
        atomNoPairs = getAtomNoPairsForRingGroup(mNew, bondNos);
        // Set up ajacency Matrix
        Matrix M = new Matrix(atomNos.size(), bondNos.size());
        for (int x = 0; x < M.getRows(); x++) {
            for (int y = 0; y < M.getCols(); y++) {
                if (Objects.equals(atomNos.get(x), atomNoPairs.get(y)[0])) {
                    M.set(x, y, 1);
                } else {
                    if (Objects.equals(atomNos.get(x), atomNoPairs.get(y)[1])) {
                        M.set(x, y, 1);
                    } else {
                        M.set(x, y, 0);
                    }
                }
            }
        }
        // Array of same dimensions as atomNos (rows in Matrix)
        List<Integer> freeValencies = null;
        freeValencies = getFreeValenciesForRingGroup(mNew, atomNos, M, ringSet);
        // Array of ""answers""
        List<Integer> bondOrders = new ArrayList<Integer>();
        for (int j = 0; j < bondNos.size(); j++) {
            bondOrders.add(0);
        }
        if (solveMatrix(M, atomNos, bondNos, freeValencies, atomNoPairs, bondOrders)) {
            for (int j = 0; j < bondOrders.size(); j++) {
                mNew.getBond(bondNos.get(j)).setOrder(bondOrders.get(j) == 1 ? IBond.Order.SINGLE : IBond.Order.DOUBLE);
            }
        } else {
            // TODO Put any failure code here
        }
    }
    return mNew;
}",kekuliseAromaticRings,org/openscience/cdk/smiles/FixBondOrdersTool.java,/legacy/src/main/java/org/openscience/cdk/smiles/FixBondOrdersTool.java,"/**
     * kekuliseAromaticRings - function to add double/single bond order information for molecules having rings containing all atoms marked SP2 or Planar3 hybridisation.
     * @param molecule The {@link IAtomContainer} to kekulise
     * @return The {@link IAtomContainer} with kekule structure
     * @throws CDKException
     */",140-231,"('kekuliseAromaticRings', {'INSTRUCTION': {'covered': 211, 'missed': 21}, 'BRANCH': {'covered': 18, 'missed': 2}, 'LINE': {'covered': 36, 'missed': 7}, 'COMPLEXITY': {'covered': 9, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",527.0,22.0,kekuliseAromaticRings - function to add double/single bond order information for molecules having rings containing all atoms marked SP2 or Planar3 hybridisation.,kekuliseAromaticRings-function to add double/single bond order information for molecules that have rings that contain all atoms marked with SP2 or Planar3 hybridisation,The kekuliseAromaticRings function adds double/ single bond order information for the molecule with all the atoms marked Planar3 hybridisation.,1.03522879103686,kekuliseAromaticRings - function to add double/single bond order information for molecules with rings containing all atoms labeled SP2 or Hybridation Planar3.,"public IAtomContainer kekuliseAromaticRings(IAtomContainer molecule) throws CDKException{
     
      //Check if molecule has any rings
      if (molecule.getAtomContainerCount() == 0) {
            return molecule;
      }
     
      //Check if molecule has any rings
      IRingSet ringSet = molecule.getRingSet();
      if (ringSet == null) {
            return molecule;
      }
     
      //Check if molecule has any rings
      if (ringSet.getAtomContainerCount() == 0) {
            return molecule;
      }
     
      //Check if molecule has any rings
      if (ringSet.getAtomContainerCount() == 0) {
            return molecule;
      }
     
      //Check if molecule has any rings
      if (ringSet.getAtomContainerCount() == 0) {
            return molecule;
      }
     
      //Check if molecule has any rings
      if (ringSet.getAtomContainerCount() == 0) {
            return molecule;
      }
     
      //Check if molecule has any rings
      if (ringSet.getAtomContainerCount() == 0) {
            return molecule;
      }
     
      //Check if molecule has any rings
      if (ringSet.getAtomContainerCount() == 0) {
            return molecule;
      }
     
      //Check if molecule has any rings
      if (ringSet.getAtomContainerCount() == 0) {
            return molecule;
      }
     
      //Check if molecule has any rings
      if (ringSet.getAtomContainerCount() == 0) {
            return molecule;
      }
     
      //Check if molecule has any rings
      if (ringSet.getAtomContainerCount() == 0) {
            return molecule;
      }
     
      //Check if molecule has any rings
      if (ringSet.getAtomContainerCount() == 0) {
            return molecule;
      }
     
      //Check if molecule has any rings
      if (ringSet.getAtomContainerCount() == 0) {
            return molecule;
      }
     
      //Check if molecule has any rings
      if (ringSet.getAtomContainerCount()           
 }",Not Valid,Not Valid,Not Valid,Syntax Error,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,9.0,0.391304347826087,4.0,0.18181818181818182,12.0,0.5454545454545454
120,weblogic-kubernetes-operator,"public static Step updateExporterSidecars(){
    return new Step() {

        @Override
        public NextAction apply(Packet packet) {
            return doNext(updateExportersWithConfiguration(packet), packet);
        }

        private Step updateExportersWithConfiguration(Packet packet) {
            final Collection<String> serverNames = getExporterEnabledServerNames(packet);
            if (serverNames.isEmpty()) {
                return getNext();
            } else {
                return Step.chain(SecretHelper.createAuthorizationSourceStep(), RunInParallel.perServer(serverNames, ConfigurationVerificationStartStep::new));
            }
        }

        private Collection<String> getExporterEnabledServerNames(Packet packet) {
            return getAllServerNames(packet).stream().filter(name -> hasExporterConfiguration(packet, name)).filter(name -> hasExporterSidecar(packet, name)).collect(Collectors.toList());
        }

        private Collection<String> getAllServerNames(Packet packet) {
            return DomainPresenceInfo.fromPacket(packet).map(DomainPresenceInfo::getServerNames).orElse(Collections.emptyList());
        }

        // Change this to handle per-cluster configuration
        @SuppressWarnings(""unused"")
        private boolean hasExporterConfiguration(Packet packet, String serverName) {
            return DomainPresenceInfo.fromPacket(packet).map(DomainPresenceInfo::getDomain).map(Domain::getMonitoringExporterConfiguration).isPresent();
        }

        private boolean hasExporterSidecar(Packet packet, String serverName) {
            return DomainPresenceInfo.fromPacket(packet).map(dpi -> dpi.getServerPod(serverName)).map(this::hasExporterSidecar).orElse(false);
        }

        private boolean hasExporterSidecar(V1Pod pod) {
            return Optional.ofNullable(pod).map(V1Pod::getSpec).map(V1PodSpec::getContainers).orElse(Collections.emptyList()).stream().anyMatch(c -> c.getName().equals(KubernetesConstants.EXPORTER_CONTAINER_NAME));
        }
    };
}",updateExporterSidecars,oracle/kubernetes/operator/steps/MonitoringExporterSteps.java,/operator/src/main/java/oracle/kubernetes/operator/steps/MonitoringExporterSteps.java,"/**
   * Creates a step to initiate processing for all servers in the domain for which a configuration is defined,
   * checking the configuration of each exporter sidecar and updating it if necessary.
   *
   * Expects packet to contain DomainPresenceInfo and:
   *     DOMAIN_TOPOLOGY              the domain configuration
   *     AUTHORIZATION_HEADER_FACTORY a factory to create an http authentication header
   */",44-107,"('updateExporterSidecars', {'INSTRUCTION': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",340.0,32.0,"Creates a step to initiate processing for all servers in the domain for which a configuration is defined,  checking the configuration of each exporter sidecar and updating it if necessary.","It allows the creation of a pass to start processing all servers in the domain, checking, if defined, the configuration of each export sidecar and updating it if necessary.","If necessary, it creates a step to initiate exporter processing for all the server in the domain that has a configuration defined.",0.332139534007904,"  Creates a step to start processing all servers in the domain for which a configuration is defined, checking the configuration of each exporting sidecar and updating it as needed.",Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,16.0,0.5161290322580645,5.0,0.16129032258064516,23.0,0.7419354838709677
121,cdk,"private static boolean addIsotopeDist(IMolecularFormula mf, IIsotope[] isotopes, int idx, int count){
    if (count == 0)
        return true;
    double frac = 100d;
    for (int i = 0; i < idx; i++) frac -= isotopes[i].getNaturalAbundance();
    double p = isotopes[idx].getNaturalAbundance() / frac;
    if (p >= 1.0) {
        mf.addIsotope(isotopes[idx], count);
        return true;
    }
    double kMin = (count + 1) * (1 - p) - 1;
    double kMax = (count + 1) * (1 - p);
    if ((int) Math.ceil(kMin) == (int) Math.floor(kMax)) {
        int k = (int) kMax;
        mf.addIsotope(isotopes[idx], count - k);
        return addIsotopeDist(mf, isotopes, idx + 1, k);
    }
    return false;
}",addIsotopeDist,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * Helper method for adding isotope distributions to a MF. The method adds
     * a distribution of isotopes by splitting the set of isotopes in two,
     * the one under consideration (specified by 'idx') and the remaining to be
     * considered ('&gt;idx'). The inflection point is calculate as 'k'
     * &le 'count' isotopes added. If there are remaining isotopes the method
     * calls it's self with 'idx+1' and 'count := k'.
     *
     * @param mf       the molecular formula to update
     * @param isotopes the isotopes, sorted most abundance to least
     * @param idx      which isotope we're currently considering
     * @param count    the number of isotopes remaining to select from
     * @return the distribution is unique (or not)
     */",1581-1619,"('addIsotopeDist', {'INSTRUCTION': {'covered': 89, 'missed': 2}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 15, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",192.0,10.0,Helper method for adding isotope distributions to a MF.,Method for adding isotope distributions to an MF. The method adds an isotope distribution by dividing the set of isotopes into two parts.,Adding isotope to distributions is a method of adding.,0.470706541913815,  A helper method for adding isotopic distributions to an MF.,"private static boolean addIsotopeDist(IMolecularFormula mf, IIsotope[] isotopes, int idx, int count){
        if (idx >= isotopes.length) return false;
        IIsotope iso = isotopes[idx];
        if (count > 0) {
            mf.addIsotope(iso, count);
            return true;
        }
        return false;
    }","private static boolean addIsotopeDist(IMolecularFormula mf, IIsotope[] isotopes, int idx, int count){
        if (idx >= isotopes.length) return false;
        if (count <= 0) return false;
        if (count == 1) {
            mf.addIsotope(isotopes[idx], 1);
            return true;
        }
        int half = count / 2;
        mf.addIsotope(isotopes[idx], half);
        return addIsotopeDist(mf, isotopes, idx + 1, count - half);     
 }","private static boolean addIsotopeDist(IMolecularFormula mf, IIsotope[] isotopes, int idx, int count){
        if (idx >= isotopes.length) return false;
        if (count <= 0) return false;
        if (mf.contains(isotopes[idx])) return false;
        mf.addIsotope(isotopes[idx], count);
        return true;        
 }","private static boolean addIsotopeDist(IMolecularFormula mf, IIsotope[] isotopes, int idx, int count){
        if (idx >= isotopes.length) return false;
        if (count <= 0) return true;
        mf.addIsotope(isotopes[idx], count);
        return true;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2199198758097274,  0.35325799465142926,  0.22306098913155348,  0.24904952171782102,141.0,0.7305699481865285,118.0,0.6113989637305699,144.0,0.7461139896373057,137.0,0.7098445595854922,48.0,0.48,20.0,0.3125,28.0,0.3888888888888889,18.0,0.75,4.0,0.36363636363636365,9.0,0.9
122,cdk,"public Point3d[] calculate3DCoordinates2(Point3d aPoint, Point3d bPoint, Point3d cPoint, int nwanted, double length, double angle){
    Point3d[] newPoints = new Point3d[0];
    double ang2 = angle / 2.0;
    Vector3d ba = new Vector3d(aPoint);
    ba.sub(bPoint);
    Vector3d ca = new Vector3d(aPoint);
    ca.sub(cPoint);
    Vector3d baxca = new Vector3d();
    baxca.cross(ba, ca);
    if (baxca.length() < 0.00000001) {
        ;
    } else if (nwanted == 1) {
        newPoints = new Point3d[1];
        Vector3d ax = new Vector3d(ba);
        ax.add(ca);
        ax.normalize();
        ax.scale(length);
        newPoints[0] = new Point3d(aPoint);
        newPoints[0].add(ax);
    } else if (nwanted >= 2) {
        newPoints = new Point3d[2];
        Vector3d ax = new Vector3d(ba);
        ax.add(ca);
        ax.normalize();
        baxca.normalize();
        baxca.scale(Math.sin(ang2) * length);
        ax.scale(Math.cos(ang2) * length);
        newPoints[0] = new Point3d(aPoint);
        newPoints[0].add(ax);
        newPoints[0].add(baxca);
        newPoints[1] = new Point3d(aPoint);
        newPoints[1].add(ax);
        newPoints[1].sub(baxca);
    }
    baxca = null;
    ba = null;
    ca = null;
    return newPoints;
}",calculate3DCoordinates2,org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,"/**
     *  Calculate new point(s) X in a B-A-C system, it forms a B-A(-C)-X
     *  system. (2) 2 ligands(B, C) of refAtom A (i) 1 points required; vector in
     *  ABC plane bisecting AB, AC. If ABC is linear, no points (ii) 2 points: 2
     *  points X1, X2, X1-A-X2 = angle about 2i vector
     *
     *@param  aPoint   to which substituents are added
     *@param  bPoint   first ligand of A
     *@param  cPoint   second ligand of A
     *@param  nwanted  number of points to calculate (1-2)
     *@param  length   A-X length
     *@param  angle    B-A-X angle
     *@return          Point3d[] nwanted points (or zero if failed)
     */",438-494,"('calculate3DCoordinates2', {'INSTRUCTION': {'covered': 111, 'missed': 30}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 28, 'missed': 7}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",323.0,22.0,"Calculate new point(s) X in a B-A-C system, it forms a B-A(-C)-X  system.",This method calculates new points X by taking three points in a B-A-C system as input and forms a system B-A(-C)-X,A B-A-C system is formed by calculating new point(s) X.,0.443697550121469,"  Calculate new X points in a B-A-C system, it forms a B-A(-C)-X system.",Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,14.0,0.6363636363636364,2.0,0.14285714285714285,13.0,0.9285714285714286
123,dcache,"private void updateEarliestChildExpiryDate(Date newDate){
    if (newDate == null) {
        return;
    }
    if (_earliestChildExpiry == null || newDate.before(_earliestChildExpiry)) {
        _earliestChildExpiry = newDate;
    }
}",updateEarliestChildExpiryDate,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,"/**
     * Possibly update our belief of the earliest time that a Mortal child StateComponent will
     * expire.  It is safe to call this method with all child Dates: it will update the
     * _earliestChildExpiry Date correctly.
     *
     * @param newDate the expiry Date of a Mortal child StateComponent
     */",109-124,"('updateEarliestChildExpiryDate', {'INSTRUCTION': {'covered': 14, 'missed': 1}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,16.0,Possibly update our belief of the earliest time that a Mortal child StateComponent will  expire., It will eventually update the belief about the earliest time a StateComponent child of Mortal will expire,We believe that a child will expire at the earliest time.,0.372941056204372,  Perhaps update our belief the first time that a deadly child StateComponent will expire.," private void updateEarliestChildExpiryDate(Date newDate){
        if (newDate == null) {
            _earliestChildExpiry = null;
        } else if (_earliestChildExpiry == null || newDate.before(_earliestChildExpiry)) {
            _earliestChildExpiry = newDate;
        }
    }"," private void updateEarliestChildExpiryDate(Date newDate){
        if (_earliestChildExpiry == null || newDate.before(_earliestChildExpiry)) {
            _earliestChildExpiry = newDate;
        }
    }"," private void updateEarliestChildExpiryDate(Date newDate){
        if (_earliestChildExpiry == null || newDate.before(_earliestChildExpiry)) {
            _earliestChildExpiry = newDate;
        }
    }"," private void updateEarliestChildExpiryDate(Date newDate){
        if (_earliestChildExpiry == null || newDate.before(_earliestChildExpiry)) {
            _earliestChildExpiry = newDate;
        }       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7981800761573616,  0.7458871911143913,  0.7458871911143913,  0.7458871911143913,4.0,0.09523809523809523,10.0,0.2564102564102564,10.0,0.2564102564102564,10.0,0.2564102564102564,13.0,0.30952380952380953,13.0,0.30952380952380953,13.0,0.30952380952380953,10.0,0.5555555555555556,4.0,0.25,15.0,0.9375
124,openapi-generator,"private Set<Map<String, String>> toImportsObjects(Map<String, String> mappedImports){
    Set<Map<String, String>> result = new TreeSet<Map<String, String>>((Comparator<Map<String, String>>) (o1, o2) -> {
        String s1 = o1.get(""classname"");
        String s2 = o2.get(""classname"");
        return s1.compareTo(s2);
    });
    mappedImports.entrySet().forEach(mapping -> {
        Map<String, String> im = new LinkedHashMap<>();
        im.put(""import"", mapping.getKey());
        im.put(""classname"", mapping.getValue());
        result.add(im);
    });
    return result;
}",toImportsObjects,org/openapitools/codegen/DefaultGenerator.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java,"/**
     * Using an import map created via {@link #getAllImportsMappings(Set)} to build a list import objects.
     * The import objects have two keys: import and classname which hold the key and value of the initial map entry.
     *
     * @param mappedImports Map of fully qualified import and import
     * @return The set of unique imports
     */",1234-1257,"('toImportsObjects', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",158.0,22.0,Using an import map created via {@link #getAllImportsMappings(Set)} to build a list import objects.,The map created via {@link#getAllImportsMappings(Set)} is used to construct a list of import objects. Import objects have two keys: they contain the key and the value of the initial map entry.,"To build a list import objects, you need an import map created via @link #getAllImportsMappings(Set).",0.746702768106061,  Using an import card created through {@link #getAllImportsMappings(Set)} to create a list of import objects.," private Set<Map<String, String>> toImportsObjects(Map<String, String> mappedImports){
        Set<Map<String, String>> result = new HashSet<>();
        mappedImports.forEach((key,value)->{
            Map<String,String> importMap = new HashMap<>();
            importMap.put(""import"",value);
            importMap.put(""importPath"",key);
            result.add(importMap);
        });
        return result;
    }"," private Set<Map<String, String>> toImportsObjects(Map<String, String> mappedImports){
        Set<Map<String, String>> result = new HashSet<>();
        mappedImports.forEach((key,value)->{
            Map<String,String> importObject = new HashMap<>();
            importObject.put(""import"",value);
            importObject.put(""key"",key);
            result.add(importObject);
        });
        return result;
    }"," private Set<Map<String, String>> toImportsObjects(Map<String, String> mappedImports){
        Set<Map<String, String>> result = new HashSet<>();
        mappedImports.forEach((key,value)->{
            Map<String,String> next = new HashMap<>();
            next.put(""import"",value);
            next.put(""importPath"",key);
            result.add(next);
        });
        return result;
    }"," private Set<Map<String, String>> toImportsObjects(Map<String, String> mappedImports){
        Set<Map<String, String>> result = new HashSet<>();
        mappedImports.forEach((key,value)->{
            Map<String, String> next = new HashMap<>();
            next.put(""import"",value);
            next.put(""importPath"",key);
            result.add(next);
        });
        return result;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3978316100758821,  0.4044105574443031,  0.3978316100758821,  0.391252662707461,75.0,0.4716981132075472,75.0,0.4716981132075472,75.0,0.4716981132075472,75.0,0.4716981132075472,5.0,0.05102040816326531,4.0,0.04081632653061224,4.0,0.04081632653061224,25.0,0.78125,4.0,0.25,15.0,0.9375
125,egeria,"public Optional<EntityDetail> findCollectionEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, COLLECTION_TYPE_NAME);
}",findCollectionEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCollectionHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCollectionHandler.java,"/**
     * Find out if the Transformation Project object is already stored in the repository as a Collection. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",92-108,"('findCollectionEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,17.0,Find out if the Transformation Project object is already stored in the repository as a Collection.,Allows you to check whether the transformation project object is stored in the repository as a Collection. It uses the fully qualified name to retrieve the entity.,"If the Transformation Project object is already in the repository, you can find out if it is a collection.",0.258108744478671,  Find out if the Transformation Project object is already stored in the repository as a collection.," public Optional<EntityDetail> findCollectionEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        String methodName = ""findCollectionEntity"";
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateName(qualifiedName, QUALIFIED_NAME_PROPERTY_NAME, methodName);
    
        return collectionOpenMetadataAPIGenericHandler.findEntity(userId, qualifiedName, QUALIFIED_NAME_PROPERTY_NAME, methodName);     
 }"," public Optional<EntityDetail> findCollectionEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        String methodName = ""findCollectionEntity"";
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateName(qualifiedName, QUALIFIED_NAME_PROPERTY_NAME, methodName);
    
        return collectionOpenMetadataAPIGenericHandler.findEntity(userId, qualifiedName, methodName);       
 }"," public Optional<EntityDetail> findCollectionEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        String methodName = ""findCollectionEntity"";
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateName(qualifiedName, QUALIFIED_NAME_PROPERTY_NAME, methodName);
    
        return collectionOpenMetadataAPIGenericHandler.findEntity(userId, qualifiedName, methodName);       
 }"," public Optional<EntityDetail> findCollectionEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        String methodName = ""findCollectionEntity"";
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateName(qualifiedName, QUALIFIED_NAME_PROPERTY_NAME, methodName);
    
        return collectionOpenMetadataAPIGenericHandler.findEntity(userId, qualifiedName, COLLECTION_TYPE_NAME, methodName);     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7586162701650451,  0.7803308714220554,  0.7705259512717734,  0.7803308714220554,29.0,0.47540983606557374,27.0,0.4576271186440678,28.0,0.45901639344262296,27.0,0.4576271186440678,2.0,0.03278688524590164,1.0,0.01639344262295082,2.0,0.03278688524590164,18.0,0.6428571428571429,1.0,0.058823529411764705,13.0,0.65
126,cdk,"boolean feasible(int n, int m){
    // verify atom semantic feasibility
    if (!atomMatcher.matches(container1.getAtom(n), container2.getAtom(m)))
        return false;
    // unmapped terminal vertices n and m are adjacent to
    int nTerminal1 = 0, nTerminal2 = 0;
    // unmapped non-terminal (remaining) vertices n and m are adjacent to
    int nRemain1 = 0, nRemain2 = 0;
    // 0-look-ahead: check each adjacent edge for being mapped, and count
    // terminal or remaining
    for (int n_prime : g1[n]) {
        int m_prime = m1[n_prime];
        // v is already mapped, there should be an edge {m, w} in g2.
        if (m_prime != UNMAPPED) {
            IBond bond2 = bonds2.get(m, m_prime);
            // the bond is not present in the target
            if (bond2 == null)
                return false;
            // verify bond semantic feasibility
            if (!bondMatcher.matches(bonds1.get(n, n_prime), bond2))
                return false;
        } else {
            if (t1[n_prime] > 0)
                nTerminal1++;
            else
                nRemain1++;
        }
    }
    // 0-look-ahead: check each adjacent edge for being mapped, and count
    // terminal or remaining
    for (int m_prime : g2[m]) {
        int n_prime = m2[m_prime];
        if (n_prime != UNMAPPED) {
            IBond bond1 = bonds1.get(n, n_prime);
            // the bond is not present in the query
            if (bond1 == null)
                return false;
            // verify bond semantic feasibility
            if (!bondMatcher.matches(bond1, bonds2.get(m, m_prime)))
                return false;
        } else {
            if (t2[m_prime] > 0)
                nTerminal2++;
            else
                nRemain2++;
        }
    }
    // 1-look-ahead : the mapping {n, m} is feasible iff the number of
    // terminal vertices (t1) adjacent to n is equal to the
    // number of terminal vertices (t2) adjacent to m.
    // 
    // 2-look-ahead: the mapping {n, m} is feasible iff the number of
    // vertices adjacent to n that are neither in m1 or t1 is equal to
    // the number of the number of vertices adjacent to m that are neither
    // in m2 or t2.
    return nTerminal1 == nTerminal2 && nRemain1 == nRemain2;
}",feasible,org/openscience/cdk/isomorphism/VFState.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/VFState.java,"/**
     * Check the feasibility of the candidate pair {n, m}. A candidate pair is
     * syntactically feasible iff all k-look-ahead rules hold. These look ahead
     * rules check adjacency relation of the mapping. If an edge is mapped in g1
     * it should also be mapped in g2 and vise-versa (0-look-ahead). If an edge
     * in g1 is unmapped but the edge is adjacent to an another mapped vertex
     * (terminal) then the number of such edges should be equal in g1 compared
     * to g2 (1-look-ahead). If the edge is unmapped and non-terminal then the
     * number of such edges should be equal in g1 compared to g2 (2-look-ahead).
     * 
     *
     * @param n a candidate vertex from g1
     * @param m a candidate vertex from g2
     * @return the mapping is feasible
     */",86-160,"('feasible', {'INSTRUCTION': {'covered': 144, 'missed': 4}, 'BRANCH': {'covered': 24, 'missed': 2}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 12, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",243.0,13.0,"Check the feasibility of the candidate pair {n, m}.","Checks the feasibility of the candidate pair {n, m}. If all k-look-ahead rules are valid a candidate pair is syntactically feasible. The adjacency relation of the mapping is checked by the look-ahead rules.",The feasibility of the candidate pair is checked.,0.102795181592992,"  Check the feasibility of the candidate pair {n, m}.","boolean feasible(int n, int m){
        IBond bond1 = bonds1.get(n);
        IBond bond2 = bonds2.get(m);
        return bondMatcher.matches(bond1, bond2) && atomMatcher.matches(container1.getAtom(n), container2.getAtom(m));      
 }","boolean feasible(int n, int m){
        if(!atomMatcher.feasible(n, m))
            return false;
        if(!bondMatcher.feasible(n, m))
            return false;
        if(!feasible(n, m, container1, container2, bonds1, bonds2))
            return false;
        return true;        
 }","boolean feasible(int n, int m){
        return atomMatcher.feasible(container1.getAtom(n), container2.getAtom(m));      
 }","boolean feasible(int n, int m){
        IBond bond1 = bonds1.get(n);
        IBond bond2 = bonds2.get(m);
        return bondMatcher.compatible(bond1, bond2);        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.16568679996728816,  0.15483194042257928,  0.1207812923650094,  0.1009808995936618,197.0,0.8073770491803278,191.0,0.7827868852459017,208.0,0.8524590163934426,214.0,0.8770491803278688,41.0,0.6212121212121212,20.0,0.32786885245901637,30.0,0.4918032786885246,25.0,0.7352941176470589,0.0,0.0,4.0,0.4
127,tablesaw,"public Table sampleX(double proportion){
    Preconditions.checkArgument(proportion <= 1 && proportion >= 0, ""The sample proportion must be between 0 and 1"");
    int tableSize = (int) Math.round(rowCount() * proportion);
    return where(selectNRowsAtRandom(tableSize, rowCount()));
}",sampleX,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,"/**
   * Returns a table consisting of randomly selected records from this table. The sample size is
   * based on the given proportion
   *
   * @param proportion The proportion to go in the sample
   */",553-565,"('sampleX', {'INSTRUCTION': {'covered': 27, 'missed': 1}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,12.0,Returns a table consisting of randomly selected records from this table.,"Returns a table from randomly selected records. Based on the given proportion, the sample size is defined.",A table consisting of randomly selected records is returned.,0.390648568971858,  Returns a table consisting of randomly selected records from that table.,"public Table sampleX(double proportion){
    int sampleSize = (int) Math.round(rowCount() * proportion);
    Selection sampleSelection = new BitmapBackedSelection();
    for (int i = 0; i < rowCount(); i++) {
      sampleSelection.add(i);
    }
    Selection sampleRecords = selectNRowsAtRandom(sampleSize, rowCount());
    for (int sampleRecord : sampleRecords) {
      sampleSelection.add(sampleRecord);
    }
    return where(sampleSelection);
  }","public Table sampleX(double proportion){
    int sampleSize = (int) Math.round(rowCount() * proportion);
    Selection sampleSelection = new BitmapBackedSelection();
    for (int i = 0; i < rowCount(); i++) {
      sampleSelection.add(i);
    }
    Selection sampleRecords = selectNRowsAtRandom(sampleSize, rowCount());
    for (int sampleRecord : sampleRecords) {
      sampleSelection.add(sampleRecord);
    }
    return where(sampleSelection);
  }","public Table sampleX(double proportion){
    int sampleSize = (int) Math.round(rowCount() * proportion);
    Selection sampleSelection = new BitmapBackedSelection();
    for (int i = 0; i < rowCount(); i++) {
      sampleSelection.add(i);
    }
    Selection sampleRecords = selectNRowsAtRandom(sampleSize, rowCount());
    for (int sampleRecord : sampleRecords) {
      sampleSelection.add(sampleRecord);
    }
    return where(sampleSelection);
  }","public Table sampleX(double proportion){
    int sampleSize = (int) Math.round(rowCount() * proportion);
    Selection sampleSelection = new BitmapBackedSelection();
    for (int i = 0; i < rowCount(); i++) {
      sampleSelection.add(i);
    }
    Selection sampleRecords = selectNRowsAtRandom(sampleSize, rowCount());
    for (int sampleRecord : sampleRecords) {
      sampleSelection.add(sampleRecord);
    }
    return where(sampleSelection);
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5598170557356963,  0.5598170557356963,  0.5598170557356963,  0.5598170557356963,64.0,0.6808510638297872,64.0,0.6808510638297872,64.0,0.6808510638297872,64.0,0.6808510638297872,0.0,0.0,0.0,0.0,0.0,0.0,13.0,0.7222222222222222,1.0,0.08333333333333333,5.0,0.4166666666666667
128,acs-aem-commons,"protected final void sendEmail(final List<HealthCheckExecutionResult> success, final List<HealthCheckExecutionResult> failure, final long timeTaken){
    final ProductInfo[] productInfos = productInfoService.getInfos();
    final String hostname = getHostname();
    final Map<String, String> emailParams = new HashMap<>();
    emailParams.put(""subject"", String.format(""%s [ %d Failures ] [ %d Success ] [ %s ]"", emailSubject, failure.size(), success.size(), hostname));
    emailParams.put(""failure"", resultToPlainText(""Failing Health Checks"", failure));
    emailParams.put(""success"", resultToPlainText(""Successful Health Checks"", success));
    emailParams.put(""executedAt"", Calendar.getInstance().getTime().toString());
    emailParams.put(""runModes"", StringUtils.join(slingSettingsService.getRunModes(), "", ""));
    emailParams.put(""mode"", ModeUtil.isAuthor() ? ""Author"" : ""Publish"");
    emailParams.put(""hostname"", hostname);
    emailParams.put(""timeTaken"", String.valueOf(timeTaken));
    if (productInfos.length == 1) {
        emailParams.put(""productName"", productInfos[0].getShortName());
        emailParams.put(""productVersion"", productInfos[0].getShortVersion());
    }
    emailParams.put(""successCount"", String.valueOf(success.size()));
    emailParams.put(""failureCount"", String.valueOf(failure.size()));
    emailParams.put(""totalCount"", String.valueOf(failure.size() + success.size()));
    if (ArrayUtils.isNotEmpty(recipientEmailAddresses)) {
        final List<String> failureList = emailService.sendEmail(emailTemplatePath, emailParams, recipientEmailAddresses);
        if (failureList.size() > 0) {
            log.warn(""Could not send health status check e-mails to recipients [ {} ]"", StringUtils.join(failureList, "", ""));
        } else {
            log.info(""Successfully sent Health Check email to [ {} ] recipients"", recipientEmailAddresses.length - failureList.size());
        }
    } else {
        log.warn(""No e-mail addresses provided to e-mail results of health checks. Either add the appropriate e-mail recipients or remove the health check status e-mail configuration entirely."");
    }
}",sendEmail,com/adobe/acs/commons/hc/impl/HealthCheckStatusEmailer.java,/bundle/src/main/java/com/adobe/acs/commons/hc/impl/HealthCheckStatusEmailer.java,"/**
     * Creates the e-mail template parameter map and invokes the OSGi E-Mail Service.
     *
     * @param success the list of successful Health Check Execution Results
     * @param failure the list of unsuccessful Health Check Execution Results
     * @param timeTaken the time taken to execute all Health Checks
     */",218-260,"('sendEmail', {'INSTRUCTION': {'covered': 162, 'missed': 12}, 'BRANCH': {'covered': 4, 'missed': 4}, 'LINE': {'covered': 23, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",389.0,13.0,Creates the e-mail template parameter map and invokes the OSGi E-Mail Service.,Call up the OSGi e-mail service and enable the creation of the e-mail template parameter map.,The OSGi E-Mail Service is invoked after the creation of the e-mail template.,0.460517130364482,  Creates the e-mail template parameter mapping and calls the OSGi e-mail service.,Empty Method," protected final void sendEmail(final List<HealthCheckExecutionResult> success, final List<HealthCheckExecutionResult> failure, final long timeTaken){
        final Map<String, Object> templateParams = new HashMap<>();
        templateParams.put(""success"", success);
        templateParams.put(""failure"", failure);
        templateParams.put(""timeTaken"", timeTaken);
        templateParams.put(""productInfo"", productInfoService.getProductInfo());
        templateParams.put(""slingSettings"", slingSettingsService.getSlingSettings());
        templateParams.put(""healthCheckTags"", healthCheckTags);
        templateParams.put(""healthCheckTagsOptionsOr"", healthCheckTagsOptionsOr);
        templateParams.put(""healthCheckTimeoutOverride"", healthCheckTimeoutOverride);
        templateParams.put(""fallbackHostname"", fallbackHostname);
        templateParams.put(""throttleInMins"", throttleInMins);
        templateParams.put(""nextEmailTime"", nextEmailTime);
        templateParams.put(""healthCheckTags"", healthCheckTags);
        templateParams.put(""healthCheckTagsOptionsOr"", healthCheckTagsOptionsOr);
        templateParams.put(""healthCheckTimeoutOverride"", healthCheckTimeoutOverride);
        templateParams.put(""fallbackHostname"", fallbackHostname);
        templateParams.put(""throttleInMins"", throttleInMins);
        templateParams.put(""nextEmailTime"", nextEmailTime);
        templateParams.put(""healthCheckTags"", healthCheckTags);
        templateParams.put(""healthCheckTagsOptionsOr"", healthCheckTagsOptionsOr);
        templateParams.put(""healthCheckTimeoutOverride"", healthCheckTimeoutOverride);
        templateParams.put(""fallbackHostname"", fallbackHostname);
        templateParams.put(""throttleInMins"", throttleInMins);
        templateParams.put(""nextEmailTime"", nextEmailTime);
        templateParams.put(""healthCheckTags"", healthCheckTags);
        templateParams.put(""healthCheckTagsOptionsOr"", healthCheckTagsOptionsOr);
        templateParams.put(""healthCheckTimeoutOverride"", healthCheckTimeoutOverride);
        templateParams.put(""fallbackHostname"", fallbackHostname);
        templateParams.put      
 }","protected final void sendEmail(final List<HealthCheckExecutionResult> success, final List<HealthCheckExecutionResult> failure, final long timeTaken){
        final StringBuilder body = new StringBuilder();
        final StringBuilder subject = new StringBuilder();
    
        body.append(""<html><body>"");
        body.append(""<h1>Health Check Results</h1>"");
        body.append(""<p>This e-mail is sent as a result of the scheduled ACS Commons Health Check E-mailer service.</p>"");
        body.append(""<p>The following Health Checks were executed:</p>"");
        body.append(""<ul>"");
        for (HealthCheckExecutionResult result : success) {
            body.append(""<li>"");
            body.append(result.getHealthCheck().getName());
            body.append(""</li>"");
        }
        body.append(""</ul>"");
        body.append(""<p>The following Health Checks failed:</p>"");
        body.append(""<ul>"");
        for (HealthCheckExecutionResult result : failure) {
            body.append(""<li>"");
            body.append(result.getHealthCheck().getName());
            body.append(""</li>"");
        }
        body.append(""</ul>"");
        body.append(""<p>The following Health Checks were skipped:</p>"");
        body.append(""<ul>"");
        for (HealthCheckExecutionResult result : success) {
            if (result.getHealthCheckResult().isSkipped()) {
                body.append(""<li>"");
                body.append(result.getHealthCheck().getName());
                body.append(""</li>"");
            }
        }
        body.append(""</ul>"");
        body.append(""<p>The following Health Checks were not executed:</p>"");
        body.append(""<ul>"");
        for (HealthCheckExecutionResult result : failure) {
            if (result.getHealthCheckResult().isNotExecuted()) {
                body.append(""<li>"");
                body.append(result.getHealthCheck().getName());
                body.append(""</li>"");
            }
        }
        body.append(""</ul>"");
        body.append     
 }"," protected final void sendEmail(final List<HealthCheckExecutionResult> success, final List<HealthCheckExecutionResult> failure, final long timeTaken){
        final Map<String, Object> parameters = new HashMap<>();
        parameters.put(""success"", success);
        parameters.put(""failure"", failure);
        parameters.put(""timeTaken"", timeTaken);
        parameters.put(""productInfo"", productInfoService.getProductInfo());
        parameters.put(""slingSettings"", slingSettingsService.getSlingSettings());
    
        final String subject = String.format(""Health Check Status for [ %s ]"", slingSettingsService.getSlingSettings().get(SlingSettingsService.PROP_SERVER_NAME, DEFAULT_FALLBACK_HOSTNAME));
        emailService.sendEmail(recipientsEmailAddresses, subject, parameters, ""health-check-status-email.html"");
    }",Empty Method,Syntax Error,NOT PASS,Syntax Error,None,None,  0.21420795291992423,None,None,None,None,None,287.0,0.735897435897436,252.0,0.6461538461538462,None,None,133.0,0.9925373134328358,331.0,0.9969879518072289,13.0,0.7647058823529411,4.0,0.3076923076923077,13.0,0.9285714285714286
130,cdk,"private double hydrogenXDodge(int hydrogens, int mass, TextOutline elementLabel, TextOutline hydrogenLabel, TextOutline hydrogenCount, TextOutline massLabel){
    if (mass < 0 && hydrogens > 1) {
        return (elementLabel.getBounds().getMinX() - padding) - hydrogenCount.getBounds().getMaxX();
    } else if (mass >= 0) {
        if (hydrogens > 1) {
            return (massLabel.getBounds().getMinX() + padding) - hydrogenCount.getBounds().getMaxX();
        } else if (hydrogens > 0) {
            return (massLabel.getBounds().getMinX() - padding) - hydrogenLabel.getBounds().getMaxX();
        }
    }
    return 0;
}",hydrogenXDodge,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,"/**
     * If the hydrogens are position in from of the element we may need to move the hydrogen and
     * hydrogen count labels. This code assesses the positions of the mass, hydrogen, and hydrogen
     * count labels and determines the x-axis adjustment needed for the hydrogen label to dodge a
     * collision.
     *
     * @param hydrogens     number of hydrogens
     * @param mass          atomic mass
     * @param elementLabel  element label outline
     * @param hydrogenLabel hydrogen label outline
     * @param hydrogenCount hydrogen count label outline
     * @param massLabel     the mass label outline
     * @return required adjustment to x-axis
     */",543-569,"('hydrogenXDodge', {'INSTRUCTION': {'covered': 47, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",140.0,22.0,If the hydrogens are position in from of the element we may need to move the hydrogen and  hydrogen count labels.,"This method evaluates the positions of the mass, hydrogen and hydrogen count labels to determine the x-axis adjustment required for the hydrogen label to avoid a collision. ",We may need to change the hydrogen and hydrogen count labels if the hydrogens are in the element.,0.530275911447373,"  If the hydrogens are positioned from the element, we may need to move the hydrogen and hydrogen counting labels.","private double hydrogenXDodge(int hydrogens, int mass, TextOutline elementLabel, TextOutline hydrogenLabel, TextOutline hydrogenCount, TextOutline massLabel){
        final Rectangle2D elementBounds = elementLabel.getBounds();
        final Rectangle2D hydrogenBounds = hydrogenLabel.getBounds();
        final Rectangle2D hydrogenCountBounds = hydrogenCount.getBounds();
        final Rectangle2D massBounds = massLabel.getBounds();
        double xDodge = 0;
        if (hydrogens > 0 && (hydrogenBounds.getMinX() < elementBounds.getMinX())){
            xDodge = elementBounds.getMinX() - hydrogenBounds.getMinX();
        }
        if (mass > 0 && (massBounds.getMinX() < elementBounds.getMinX())){
            xDodge = elementBounds.getMinX() - massBounds.getMinX();
        }
        return xDodge;
    }","private double hydrogenXDodge(int hydrogens, int mass, TextOutline elementLabel, TextOutline hydrogenLabel, TextOutline hydrogenCount, TextOutline massLabel){
        double xDodge = 0;
        if (hydrogens > 0){
            Rectangle2D hydrogenBounds = hydrogenLabel.getBounds();
            Rectangle2D hydrogenCountBounds = hydrogenCount.getBounds();
            Rectangle2D elementBounds = elementLabel.getBounds();
            if (hydrogenBounds.getMinX() < elementBounds.getMinX()){
                xDodge = hydrogenBounds.getMaxX() - hydrogenCountBounds.getMinX();
            }
        }
        if (mass > 0){
            Rectangle2D massBounds = massLabel.getBounds();
            Rectangle2D elementBounds = elementLabel.getBounds();
            if (massBounds.getMinX() < elementBounds.getMinX()){
                xDodge = massBounds.getMaxX() - elementBounds.getMinX();
            }
        }
        return xDodge;
    }","private double hydrogenXDodge(int hydrogens, int mass, TextOutline elementLabel, TextOutline hydrogenLabel, TextOutline hydrogenCount, TextOutline massLabel){
        double xDodge = 0;
        if (hydrogens > 0){
            Rectangle2D hydrogenBounds = hydrogenLabel.getBounds();
            Rectangle2D elementBounds = elementLabel.getBounds();
            if (hydrogenBounds.getMaxX() > elementBounds.getMaxX()){
                xDodge = hydrogenBounds.getMaxX() - elementBounds.getMaxX();
            }
        }
        if (mass > 0){
            Rectangle2D massBounds = massLabel.getBounds();
            Rectangle2D elementBounds = elementLabel.getBounds();
            if (massBounds.getMaxX() > elementBounds.getMaxX()){
                xDodge = massBounds.getMaxX() - elementBounds.getMaxX();
            }
        }
        return xDodge;
    }","private double hydrogenXDodge(int hydrogens, int mass, TextOutline elementLabel, TextOutline hydrogenLabel, TextOutline hydrogenCount, TextOutline massLabel){
        double xDodge = 0;
        if (hydrogens > 0) {
            Rectangle2D hydrogenBounds = hydrogenLabel.getBounds();
            Rectangle2D elementBounds = elementLabel.getBounds();
            Rectangle2D hydrogenCountBounds = hydrogenCount.getBounds();
            Rectangle2D massBounds = massLabel.getBounds();
            if (hydrogens > 1) {
                if (hydrogenBounds.getMaxX() > elementBounds.getMaxX()) {
                    xDodge = hydrogenBounds.getMaxX() - elementBounds.getMaxX();
                }
            }
            if (mass > 0) {
                if (massBounds.getMinX() < elementBounds.getMinX()) {
                    xDodge = massBounds.getMinX() - elementBounds.getMinX();
                }
            }
        }
        return xDodge;      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.516547784224867,  0.5212563678194678,  0.558455644976112,  0.4994301427606951,77.0,0.5310344827586206,81.0,0.525974025974026,66.0,0.43137254901960786,79.0,0.5448275862068965,56.0,0.36363636363636365,45.0,0.29411764705882354,68.0,0.4689655172413793,24.0,0.8571428571428571,5.0,0.22727272727272727,19.0,0.8636363636363636
131,acs-aem-commons,"protected final Optional<Resource> merge(final Resource resource, final String destination, final Collection<String> sources, final Class<T> typeHint, final boolean allowDuplicates) throws PersistenceException{
    ResourceResolver rr = resource.getResourceResolver();
    @SuppressWarnings(""unchecked"")
    final T[] emptyArray = (T[]) Array.newInstance(typeHint, 0);
    Collection<T> collectedValues;
    if (allowDuplicates) {
        collectedValues = new ArrayList<>();
    } else {
        collectedValues = new LinkedHashSet<>();
    }
    for (final String source : sources) {
        Resource sourceProperties = resource;
        String sourceParam = source;
        if (source.contains(""/"")) {
            sourceParam = StringUtils.substringAfterLast(source, ""/"");
            sourceProperties = rr.getResource(resource, StringUtils.substringBeforeLast(source, ""/""));
        }
        T[] tmp = sourceProperties.adaptTo(ModifiableValueMap.class).get(sourceParam, emptyArray);
        collectedValues.addAll(Arrays.asList(tmp));
    }
    Resource targetResource = resource;
    String targetProperty = destination;
    if (destination.contains(""/"")) {
        targetProperty = StringUtils.substringAfterLast(destination, ""/"");
        targetResource = rr.getResource(resource, StringUtils.substringBeforeLast(destination, ""/""));
    }
    ModifiableValueMap targetProperties = targetResource.adaptTo(ModifiableValueMap.class);
    final T[] currentValues = targetProperties.get(targetProperty, emptyArray);
    if (!collectedValues.equals(Arrays.asList(currentValues))) {
        targetProperties.put(targetProperty, collectedValues.toArray(emptyArray));
        return Optional.of(targetResource);
    } else {
        return Optional.empty();
    }
}",merge,com/adobe/acs/commons/wcm/impl/PropertyMergePostProcessor.java,/bundle/src/main/java/com/adobe/acs/commons/wcm/impl/PropertyMergePostProcessor.java,"/**
     * Merges the values found in the the source properties into the destination
     * property as a multi-value. The values of the source properties and
     * destination properties must all be the same property type.
     *
     * The unique set of properties will be stored in
     *
     * @param resource the resource to look for the source and destination
     * properties on
     * @param destination the property to store the collected properties.
     * @param sources the properties to collect values from for merging
     * @param typeHint the data type that should be used when reading and
     * storing the data
     * @param allowDuplicates true to allow duplicates values in the destination
     * property; false to make values unique
     * @return Optional resource updated, if any
     */",214-277,"('merge', {'INSTRUCTION': {'covered': 108, 'missed': 2}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 24, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",324.0,17.0,Merges the values found in the the source properties into the destination  property as a multi-value.,The values found in the source property in the target property as multi-value are merged.,The source properties are combined into the destination property as multi-value.,0.175622139220299,  Merges the values found in the source properties into the destination property as a multiple value.," protected final Optional<Resource> merge(final Resource resource, final String destination, final Collection<String> sources, final Class<T> typeHint, final boolean allowDuplicates) throws PersistenceException{
        final ResourceResolver resolver = resource.getResourceResolver();
        final Resource destinationResource = resolver.getResource(destination);
        final Resource destinationParent = destinationResource.getParent();
        final String destinationName = destinationResource.getName();
        final String destinationPath = destinationResource.getPath();
        final String destinationType = destinationResource.getResourceType();
    
        if (destinationParent == null) {
            log.error(""Cannot merge properties into [ {} ] because it has no parent"", destinationPath);
            return Optional.empty();
        }
    
        if (destinationType.equals(JcrConstants.NT_UNSTRUCTURED)) {
            log.error(""Cannot merge properties into [ {} ] because it is an unstructured node"", destinationPath);
            return Optional.empty();
        }
    
        if (destinationType.equals(JcrConstants.NT_FOLDER)) {
            log.error(""Cannot merge properties into [ {} ] because it is a folder"", destinationPath);
            return Optional.empty();
        }
    
        if (destinationType.equals(JcrConstants.NT_FILE)) {
            log.error(""Cannot merge properties into [ {} ] because it is a file"", destinationPath);
            return Optional.empty();
        }
    
        if (destinationType.equals(JcrConstants.NT_RESOURCE)) {
            log.error(""Cannot merge properties into [ {} ] because it is a resource"", destinationPath);
            return Optional.empty();
        }
    
        if (destinationType.equals(JcrConstants.NT_MIX_REFERENCEABLE)) {
            log.error(""Cannot merge properties into [ {} ] because it is a referenceable node"", destinationPath);
            return Optional.empty();
        }
    
        if (destinationType.equals(JcrConstants.NT_MIX_REFERENCEABLE)) {
            log.error(""Cannot merge properties into [ {} ] because it is a referenceable node"", destinationPath);
            return Optional.empty();
        }
    
        if (destination     
 }"," protected final Optional<Resource> merge(final Resource resource, final String destination, final Collection<String> sources, final Class<T> typeHint, final boolean allowDuplicates) throws PersistenceException{
        final ResourceResolver resolver = resource.getResourceResolver();
        final Resource destinationResource = resolver.getResource(destination);
        final Resource sourceResource = resolver.getResource(sources.iterator().next());
        final ResourceType sourceType = sourceResource.getResourceType();
        final ResourceType destinationType = destinationResource.getResourceType();
        final String sourcePath = sourceResource.getPath();
        final String destinationPath = destinationResource.getPath();
        final String sourceName = sourceResource.getName();
        final String destinationName = destinationResource.getName();
        final String sourceParentPath = sourceResource.getParent().getPath();
        final String destinationParentPath = destinationResource.getParent().getPath();
        final String sourceParentName = sourceResource.getParent().getName();
        final String destinationParentName = destinationResource.getParent().getName();
        final String sourceParentParentPath = sourceResource.getParent().getParent().getPath();
        final String destinationParentParentPath = destinationResource.getParent().getParent().getPath();
        final String sourceParentParentName = sourceResource.getParent().getParent().getName();
        final String destinationParentParentName = destinationResource.getParent().getParent().getName();
        final String sourceParentParentParentPath = sourceResource.getParent().getParent().getParent().getPath();
        final String destinationParentParentParentPath = destinationResource.getParent().getParent().getParent().getPath();
        final String sourceParentParentParentName = sourceResource.getParent().getParent().getParent().getName();
        final String destinationParentParentParentName = destinationResource.getParent().getParent().getParent().getName();
        final String sourceParentParentParentParentPath = sourceResource.getParent().getParent().getParent().getParent().getPath();
        final String destinationParentParentParentParentPath = destinationResource.getParent().getParent().getParent().getParent().getPath();
        final String sourceParentParentParentParentName = sourceResource.getParent().getParent().getParent().getParent().getName();
        final String destinationParentParentParentParentName = destinationResource.getParent().getParent().getParent().getParent().get      
 }",Not Valid,Not Valid,Syntax Error,Syntax Error,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,9.0,0.5294117647058824,3.0,0.17647058823529413,10.0,0.5882352941176471
132,dcache,"public CellMessage clone(){
    try {
        CellMessage copy = (CellMessage) super.clone();
        copy._destination = _destination.clone();
        if (_source != null) {
            copy._source = _source.clone();
        }
        copy._messageStream = _messageStream;
        return copy;
    } catch (CloneNotSupportedException e) {
        throw new RuntimeException(e);
    }
}",clone,dmg/cells/nucleus/CellMessage.java,/modules/cells/src/main/java/dmg/cells/nucleus/CellMessage.java,"/**
     * The method does not copy the message object - only the encoded message stream (if any).
     */",217-233,"('clone', {'INSTRUCTION': {'covered': 23, 'missed': 6}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",73.0,19.0,The method does not copy the message object - only the encoded message stream (if any).,"The method only copies the encoded message stream, if any, and does not copy the message object.",The method only uses the message stream as a reference.,0.326491299031426,  The method does not copy the message object - only the encoded message flow (if any).," public CellMessage clone(){
        CellMessage msg = new CellMessage();
        msg._source = _source.clone();
        msg._destination = _destination.clone();
        msg._creationTime = _creationTime;
        msg._ttl = _ttl;
        msg._mode = _mode;
        msg._umid = _umid;
        msg._lastUmid = _lastUmid;
        msg._messageStream = _messageStream;
        msg._isPersistent = _isPersistent;
        msg._session = _session;
        msg._receivedAt = _receivedAt;
        return msg;
    }"," public CellMessage clone(){
        CellMessage clone = new CellMessage();
        clone._source = _source.clone();
        clone._destination = _destination.clone();
        clone._creationTime = _creationTime;
        clone._ttl = _ttl;
        clone._mode = _mode;
        clone._umid = _umid;
        clone._lastUmid = _lastUmid;
        clone._messageStream = _messageStream;
        clone._isPersistent = _isPersistent;
        clone._session = _session;
        clone._receivedAt = _receivedAt;
        return clone;
    }"," public CellMessage clone(){
        CellMessage msg = new CellMessage();
        msg._source = _source.clone();
        msg._destination = _destination.clone();
        msg._message = _message;
        msg._creationTime = _creationTime;
        msg._ttl = _ttl;
        msg._mode = _mode;
        msg._umid = _umid;
        msg._lastUmid = _lastUmid;
        msg._messageStream = _messageStream;
        msg._isPersistent = _isPersistent;
        msg._session = _session;
        msg._receivedAt = _receivedAt;
        return msg;
    }"," public CellMessage clone(){
        CellMessage msg = new CellMessage();
        msg._source = _source.clone();
        msg._destination = _destination.clone();
        msg._creationTime = _creationTime;
        msg._ttl = _ttl;
        msg._mode = _mode;
        msg._umid = _umid;
        msg._lastUmid = _lastUmid;
        msg._messageStream = _messageStream;
        msg._isPersistent = _isPersistent;
        msg._session = _session;
        msg._receivedAt = _receivedAt;
        return msg;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.43356220759813474,  0.3686228228212355,  0.43356220759813474,  0.4290881360133344,59.0,0.6344086021505376,59.0,0.6344086021505376,59.0,0.6344086021505376,65.0,0.6565656565656566,13.0,0.13978494623655913,0.0,0.0,6.0,0.06060606060606061,14.0,0.7777777777777778,1.0,0.058823529411764705,12.0,0.7058823529411765
133,cdk,"public static BitSet decode(String enc){
    byte[] fp = base64Decode(enc);
    if (fp.length < 4) {
        throw new IllegalArgumentException(""Input is not a proper PubChem base64 encoded fingerprint"");
    }
    int len = (fp[0] << 24) | (fp[1] << 16) | (fp[2] << 8) | (fp[3] & 0xff);
    if (len != FP_SIZE) {
        throw new IllegalArgumentException(""Input is not a proper PubChem base64 encoded fingerprint"");
    }
    PubchemFingerprinter pc = new PubchemFingerprinter(null);
    for (int i = 0; i < pc.m_bits.length; ++i) {
        pc.m_bits[i] = fp[i + 4];
    }
    BitSet ret = new BitSet(FP_SIZE);
    for (int i = 0; i < FP_SIZE; i++) {
        if (pc.isBitOn(i))
            ret.set(i);
    }
    return ret;
}",decode,org/openscience/cdk/fingerprint/PubchemFingerprinter.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/PubchemFingerprinter.java,"/**
     * Returns a fingerprint from a Base64 encoded Pubchem fingerprint.
     *
     * @param enc The Base64 encoded fingerprint
     * @return A BitSet corresponding to the input fingerprint
     */",346-375,"('decode', {'INSTRUCTION': {'covered': 83, 'missed': 5}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 12, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",178.0,10.0,Returns a fingerprint from a Base64 encoded Pubchem fingerprint.,From a Base64-encoded fingerprint Pubchem returns a fingerprint,A Base64 encoded Pubchem fingerprints is returned.,0.698329562209862,Returns a fingerprint from a Base64-encoded Pubchem fingerprint.,"public static BitSet decode(String enc){
        byte[] bytes = Base64.decode(enc);
        BitSet bits = new BitSet();
        for (int i = 0; i < bytes.length; i++) {
            bits.set(i, (bytes[i] & 0x80) != 0);
        }
        return bits;
    }","public static BitSet decode(String enc){
        byte[] bytes = Base64.decode(enc);
        BitSet bits = new BitSet();
        for (int i = 0; i < bytes.length; i++) {
            bits.set(i, (bytes[i] & 0x80) != 0);
        }
        return bits;
    }","public static BitSet decode(String enc){
        byte[] bytes = Base64.decode(enc);
        BitSet bits = new BitSet();
        for (int i = 0; i < bytes.length; i++) {
            bits.set(i, (bytes[i] & 0x80) != 0);
        }
        return bits;
    }","public static BitSet decode(String enc){
        byte[] bytes = Base64.decode(enc);
        BitSet bits = new BitSet();
        for (int i = 0; i < bytes.length; i++) {
            bits.set(i, (bytes[i] & 0x80) != 0);
        }
        return bits;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.18150400998431504,  0.18150400998431504,  0.18150400998431504,  0.18150400998431504,129.0,0.7206703910614525,129.0,0.7206703910614525,129.0,0.7206703910614525,129.0,0.7206703910614525,0.0,0.0,0.0,0.0,0.0,0.0,8.0,0.8,2.0,0.2,8.0,0.8
134,dataverse,"public static boolean isPubliclyDownloadable(FileMetadata fileMetadata){
    if (fileMetadata == null) {
        return false;
    }
    if (fileMetadata.isRestricted()) {
        String msg = ""Not publicly downloadable because the file is restricted."";
        logger.fine(msg);
        return false;
    }
    if (isActivelyEmbargoed(fileMetadata)) {
        return false;
    }
    boolean popupReasons = isDownloadPopupRequired(fileMetadata.getDatasetVersion());
    if (popupReasons == true) {
        return false;
    }
    return true;
}",isPubliclyDownloadable,edu/harvard/iq/dataverse/util/FileUtil.java,/src/main/java/edu/harvard/iq/dataverse/util/FileUtil.java,"/**
     * Provide download URL if no Terms of Use, no guestbook, and not
     * restricted.
     */",1542-1585,"('isPubliclyDownloadable', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,16.0,"Provide download URL if no Terms of Use, no guestbook, and not  restricted.","If there Terms of Use, no guestbook, and not restricted, please provide the URL for downloading.","If there are no Terms of Use, no guestbook, and no download URL, then provide one.",0.405122984056609,"  Provide the download URL if there are no terms of use, no guestbook and no restrictions.","public static boolean isPubliclyDownloadable(FileMetadata fileMetadata){
        if (fileMetadata == null) {
            logger.fine(""Download popup required because fileMetadata is null."");
            return false;
        }
        if (fileMetadata.getTermsOfUseAndAccess() != null) {
            if (!TermsOfUseAndAccess.License.CC0.equals(fileMetadata.getTermsOfUseAndAccess().getLicense())
                    && !(fileMetadata.getTermsOfUseAndAccess().getTermsOfUse() == null
                    || fileMetadata.getTermsOfUseAndAccess().getTermsOfUse().equals(""""))) {
                logger.fine(""Download popup required because of license or terms of use."");
                return false;
            }
    
            // 2. Terms of Access:
            if (!(fileMetadata.getTermsOfUseAndAccess().getTermsOfAccess() == null) && !fileMetadata.getTermsOfUseAndAccess().getTermsOfAccess().equals("""")) {
                logger.fine(""Download popup required because of terms of access."");
                return false;
            }
        }
    
        // 3. Guest Book:
        if (fileMetadata.getDataset() != null && fileMetadata.getDataset().getGuestbook() != null && fileMetadata.getDataset().getGuestbook().isEnabled() && fileMetadata.getDataset().getGuestbook().getDataverse() != null) {
            logger.fine(""Download popup required because of guestbook."");
            return false;
        }
    
        logger.fine(""Download popup is not required."");
        return true;
    }","public static boolean isPubliclyDownloadable(FileMetadata fileMetadata){
        if (fileMetadata == null) {
            logger.fine(""Download popup required because fileMetadata is null."");
            return false;
        }
        if (fileMetadata.getTermsOfUseAndAccess() != null) {
            if (!TermsOfUseAndAccess.License.CC0.equals(fileMetadata.getTermsOfUseAndAccess().getLicense())
                    && !(fileMetadata.getTermsOfUseAndAccess().getTermsOfUse() == null
                    || fileMetadata.getTermsOfUseAndAccess().getTermsOfUse().equals(""""))) {
                logger.fine(""Download popup required because of license or terms of use."");
                return true;
            }
        }
        return false;
    }","public static boolean isPubliclyDownloadable(FileMetadata fileMetadata){
        if (fileMetadata == null) {
            return false;
        }
        if (fileMetadata.getTermsOfUseAndAccess() != null) {
            if (TermsOfUseAndAccess.License.CC0.equals(fileMetadata.getTermsOfUseAndAccess().getLicense())) {
                return true;
            }
            if (fileMetadata.getTermsOfUseAndAccess().getTermsOfUse() == null || fileMetadata.getTermsOfUseAndAccess().getTermsOfUse().equals("""")) {
                return true;
            }
        }
        if (fileMetadata.getDataset() != null && fileMetadata.getDataset().getGuestbook() != null && fileMetadata.getDataset().getGuestbook().isEnabled() && fileMetadata.getDataset().getGuestbook().getDataverse() != null) {
            return true;
        }
        if (fileMetadata.getDownloadUrl() != null && !fileMetadata.getDownloadUrl().equals("""")) {
            return true;
        }
        return false;       
 }","public static boolean isPubliclyDownloadable(FileMetadata fileMetadata){
        if (fileMetadata == null) {
            return false;
        }
        if (fileMetadata.getTermsOfUseAndAccess() != null) {
            if (!TermsOfUseAndAccess.License.CC0.equals(fileMetadata.getTermsOfUseAndAccess().getLicense())
                    && !(fileMetadata.getTermsOfUseAndAccess().getTermsOfUse() == null
                    || fileMetadata.getTermsOfUseAndAccess().getTermsOfUse().equals(""""))) {
                return false;
            }
        }
        if (fileMetadata.getGuestbook() != null && fileMetadata.getGuestbook().isEnabled() && fileMetadata.getGuestbook().getDataverse() != null) {
            return false;
        }
        return true;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4804670975147175,  0.4935166181411814,  0.5228764646955677,  0.5067198831567591,157.0,0.7008928571428571,61.0,0.5648148148148148,72.0,0.549618320610687,119.0,0.6574585635359116,117.0,0.5223214285714286,93.0,0.41517857142857145,87.0,0.38839285714285715,12.0,0.7058823529411765,8.0,0.47058823529411764,10.0,0.5882352941176471
135,egeria,"public int hashCode(){
    return Objects.hash(getType(), getInstanceProvenanceType(), getMetadataCollectionId(), getMetadataCollectionName(), getInstanceLicense(), getCreatedBy(), getUpdatedBy(), getCreateTime(), getMaintainedBy(), getUpdateTime(), getVersion(), getStatus(), getStatusOnDelete(), getMappingProperties());
}",hashCode,org/odpi/openmetadata/repositoryservices/connectors/stores/metadatacollectionstore/properties/instances/InstanceAuditHeader.java,/open-metadata-implementation/repository-services/repository-services-apis/src/main/java/org/odpi/openmetadata/repositoryservices/connectors/stores/metadatacollectionstore/properties/instances/InstanceAuditHeader.java,"/**
     * Return a hash code based on the values of this object.
     *
     * @return in hash code
     */",590-602,"('hashCode', {'INSTRUCTION': {'covered': 75, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,12.0,Return a hash code based on the values of this object.,Returns a hash code based on the values of this object,Return a code based on the values of the object.,0.310345741624581,  Return a hash code based on the values of this object.,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,2.0,0.16666666666666666,0.0,0.0,2.0,0.16666666666666666
136,weblogic-kubernetes-operator,"boolean verifyMachinesConfigured(String machineNamePrefix, int numMachinesNeeded){
    if (wlsDomainConfig != null && machineNamePrefix != null) {
        for (int suffix = 1; suffix <= numMachinesNeeded; suffix++) {
            if (wlsDomainConfig.getMachineConfig(machineNamePrefix + suffix) == null) {
                return false;
            }
        }
    }
    return true;
}",verifyMachinesConfigured,oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,"/**
   * Verify whether the WebLogic domain already has all the machines configured for use by the
   * dynamic cluster. For example, if machineNamePrefix is ""domain1-cluster1-machine"" and
   * numMachinesNeeded is 2, this method return true if machines named ""domain1-cluster1-machine1""
   * and ""domain1-cluster1-machine2"" are configured in the WebLogic domain.
   *
   * @param machineNamePrefix Prefix of the names of the machines
   * @param numMachinesNeeded Number of machines needed for this dynamic cluster
   * @return True if the WebLogic domain already has all the machines configured, or if there is no
   *     WlsDomainConfig object associated with this cluster, in which case we cannot perform the
   *     verification, or if machineNamePrefix is null, false otherwise
   */",290-311,"('verifyMachinesConfigured', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,18.0,Verify whether the WebLogic domain already has all the machines configured for use by the  dynamic cluster.,Checks whether all machines configured to use the dynamic cluster have the WebLogic domain,"If the WebLogic domain already has all the machines configured for use, you should check it.",0.591292943260742,  Check if the WebLogic domain already has all the machines configured for use by the dynamic cluster.," boolean verifyMachinesConfigured(String machineNamePrefix, int numMachinesNeeded){
    boolean result = false;
    if (dynamicServersConfig != null) {
      result = dynamicServersConfig.verifyMachinesConfigured(machineNamePrefix, numMachinesNeeded);
    }
    return result;
  }","boolean verifyMachinesConfigured(String machineNamePrefix, int numMachinesNeeded){
    int numMachinesConfigured = 0;
    for (WlsServerConfig serverConfig : getServerConfigs()) {
      if (serverConfig.getMachineName().startsWith(machineNamePrefix)) {
        numMachinesConfigured++;
      }
    }
    return numMachinesConfigured == numMachinesNeeded;
  }"," boolean verifyMachinesConfigured(String machineNamePrefix, int numMachinesNeeded){
    boolean result = true;
    if (hasDynamicServers()) {
      result = dynamicServersConfig.verifyMachinesConfigured(machineNamePrefix, numMachinesNeeded);
    }
    return result;
  }"," boolean verifyMachinesConfigured(String machineNamePrefix, int numMachinesNeeded){
    boolean result = false;
    if (hasDynamicServers()) {
      int numMachines = getDynamicServersConfig().getNumMachines();
      if (numMachines >= numMachinesNeeded) {
        result = true;
      }
    }
    return result;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.35067990046390085,  0.3786661323461691,  0.3068646425442549,  0.3215551890163413,37.0,0.6065573770491803,36.0,0.5901639344262295,37.0,0.6065573770491803,37.0,0.6065573770491803,27.0,0.5294117647058824,20.0,0.39215686274509803,4.0,0.10256410256410256,14.0,0.7777777777777778,2.0,0.1111111111111111,7.0,0.3888888888888889
138,jeromq," boolean checkForChanges(){
    final Map<File, byte[]> presents = new HashMap<>(fingerprints);
    boolean modified = traverseDirectory(location, new IFileVisitor() {

        @Override
        public boolean visitFile(File file) {
            return modified(presents.remove(file), file);
        }

        @Override
        public boolean visitDir(File dir) {
            return modified(presents.remove(dir), dir);
        }
    });
    return modified || !presents.isEmpty();
}",checkForChanges,org/zeromq/ZCertStore.java,/src/main/java/org/zeromq/ZCertStore.java,"/**
     * Check if files in the certificate folders have been added or removed.
     */",270-293,"('checkForChanges', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",98.0,13.0,Check if files in the certificate folders have been added or removed.,The following method allows you to check whether files in the certificate folders have been added or removed.,"If there are files in the certificate folders that have been added or removed, you should check them.",0.128931130721899,  Check if any files in the certificate folders have been added or removed.,"  boolean checkForChanges(){
        boolean changed = false;
        for (File file : location.listFiles()) {
            if (file.isFile()) {
                byte[] fingerprint = finger.print(file);
                if (!fingerprints.containsKey(file)) {
                    fingerprints.put(file, fingerprint);
                    changed = true;
                }
                else if (!Arrays.equals(fingerprints.get(file), fingerprint)) {
                    fingerprints.put(file, fingerprint);
                    changed = true;
                }
            }
            else if (file.isDirectory()) {
                byte[] fingerprint = finger.print(file);
                if (!fingerprints.containsKey(file)) {
                    fingerprints.put(file, fingerprint);
                    changed = true;
                }
                else if (!Arrays.equals(fingerprints.get(file), fingerprint)) {
                    fingerprints.put(file, fingerprint);
                    changed = true;
                }
            }
            else {
                System.out.printf(
                                    ""WARNING: %s is neither file nor directory? This shouldn't happen....SKIPPING%n"",
                                    file.getAbsolutePath());
            }
        }
        return changed;
    }","  boolean checkForChanges(){
        boolean changed = false;
        for (File file : location.listFiles()) {
            if (file.isFile()) {
                byte[] fingerprint = finger.print(file);
                if (!fingerprints.containsKey(file)) {
                    fingerprints.put(file, fingerprint);
                    changed = true;
                }
                else if (!Arrays.equals(fingerprints.get(file), fingerprint)) {
                    fingerprints.put(file, fingerprint);
                    changed = true;
                }
            }
            else if (file.isDirectory()) {
                byte[] fingerprint = finger.print(file);
                if (!fingerprints.containsKey(file)) {
                    fingerprints.put(file, fingerprint);
                    changed = true;
                }
                else if (!Arrays.equals(fingerprints.get(file), fingerprint)) {
                    fingerprints.put(file, fingerprint);
                    changed = true;
                }
            }
            else {
                System.out.printf(
                                    ""WARNING: %s is neither file nor directory? This shouldn't happen....SKIPPING%n"",
                                    file.getAbsolutePath());
            }
        }
        return changed;
    }","  boolean checkForChanges(){
        boolean changed = false;
        for (File file : location.listFiles()) {
            if (file.isFile()) {
                if (!fingerprints.containsKey(file)) {
                    changed = true;
                    break;
                }
            }
            else if (file.isDirectory()) {
                if (!fingerprints.containsKey(file)) {
                    changed = true;
                    break;
                }
                for (File subfile : file.listFiles()) {
                    if (!fingerprints.containsKey(subfile)) {
                        changed = true;
                        break;
                    }
                }
            }
        }
        return changed;
    }","  boolean checkForChanges(){
        boolean changed = false;
        for (File file : location.listFiles()) {
            if (file.isFile()) {
                if (!fingerprints.containsKey(file)) {
                    changed = true;
                    break;
                }
            }
            else if (file.isDirectory()) {
                if (!fingerprints.containsKey(file)) {
                    changed = true;
                    break;
                }
                for (File subfile : file.listFiles()) {
                    if (!fingerprints.containsKey(subfile)) {
                        changed = true;
                        break;
                    }
                }
            }
        }
        return changed;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.23578742336494854,  0.23578742336494854,  0.14076118703101415,  0.14076118703101415,164.0,0.7922705314009661,164.0,0.7922705314009661,90.0,0.7758620689655172,90.0,0.7758620689655172,0.0,0.0,115.0,0.5555555555555556,115.0,0.5555555555555556,8.0,0.42105263157894735,1.0,0.07142857142857142,9.0,0.47368421052631576
139,cdk,"public StereoEncoder create(IAtomContainer container, int[][] graph){
    // XXX: this code isn't pretty, the current IAtomContainer
    // implementations are  slow for the queries (i.e. looking at connected
    // atoms/bonds) we need to ask to decide if something is a potential
    // tetrahedral centre. We can help out a little with the adjacency list
    // (int[][]) but this doesn't help with the bonds.
    int n = container.getAtomCount();
    List<StereoEncoder> encoders = new ArrayList<StereoEncoder>();
    Map<IAtom, Integer> elevation = new HashMap<IAtom, Integer>(10);
    ATOMS: for (int i = 0; i < n; i++) {
        int degree = graph[i].length;
        // ignore those which don't have 3 or 4 neighbors
        if (degree < 3 || degree > 4)
            continue;
        IAtom atom = container.getAtom(i);
        // only create encoders for SP3 hybridized atom. atom typing is
        // currently wrong for some atoms, in sulfoxide for example the atom
        // type sets SP2... but there we don't to fuss about with that here
        if (!sp3(atom))
            continue;
        // avoid nitrogen-inversion
        if (Integer.valueOf(7).equals(atom.getAtomicNumber()) && degree == 3)
            continue;
        // TODO: we could be more strict with our selection, InChI uses C,
        // Si, Ge, P, As, B, Sn, N, P, S, Se but has preconditions for
        // certain cases. An atom or ion N, P, As, S or Se is not stereogenic
        // if it has a terminal H or two terminal neighbors -XHm, -XHn (n+m>0)
        // where X is O, S, Se, Te, or N
        // XXX: likely bottle neck
        List<IBond> bonds = container.getConnectedBondsList(atom);
        // try to create geometric parity
        GeometricParity geometric = geometric(elevation, bonds, i, graph[i], container);
        if (geometric != null) {
            // add a new encoder if a geometric parity
            encoders.add(new GeometryEncoder(i, new BasicPermutationParity(graph[i]), geometric));
        }
    }
    // no encoders, replace with the empty encoder
    return encoders.isEmpty() ? StereoEncoder.EMPTY : new MultiStereoEncoder(encoders);
}",create,org/openscience/cdk/hash/stereo/GeometricTetrahedralEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricTetrahedralEncoderFactory.java,"/**
     * Create a stereo encoder for all potential 2D and 3D tetrahedral
     * elements.
     *
     * @param container an atom container
     * @param graph     adjacency list representation of the container
     * @return a new encoder for tetrahedral elements
     */",54-113,"('create', {'INSTRUCTION': {'covered': 83, 'missed': 5}, 'BRANCH': {'covered': 12, 'missed': 4}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",221.0,13.0,Create a stereo encoder for all potential 2D and 3D tetrahedral  elements.,For all potential 2D and 3D tetrahedral elements create a stereo encoder,A stereo Encoder is needed for all potential 2D and 3D elements.,0.251114903825953,Create a stereo encoder for all potential 2D and 3D tetrahedral elements.,Not Valid,Not Valid,"public StereoEncoder create(IAtomContainer container, int[][] graph){
     
      // check for 3D coordinates
      boolean threeD = true;
      for (int i = 0; i < container.getAtomCount(); i++) {
            if (container.getAtom(i).getPoint3d() == null) {
                 threeD = false;
                 break;
            }
      }
     
      // check for 2D coordinates
      boolean twoD = true;
      for (int i = 0; i < container.getAtomCount(); i++) {
            if (container.getAtom(i).getPoint2d() == null) {
                 twoD = false;
                 break;
            }
      }
     
      // check for query bonds
      boolean query = false;
      for (int i = 0; i < container.getBondCount(); i++) {
            if (container.getBond(i).getFlag(CDKConstants.ISQUERY)) {
                 query = true;
                 break;
            }
      }
     
      // check for stereo bonds
      boolean stereo = false;
      for (int i = 0; i < container.getBondCount(); i++) {
            if (container.getBond(i).getFlag(CDKConstants.ISSTEREO)) {
                 stereo = true;
                 break;
            }
      }
     
      // check for 3D coordinates
      boolean threeDCoordinates = true;
      for (int i = 0; i < container.getAtomCount(); i++) {
            if (container.getAtom(i).getPoint3d() == null) {
                 threeDCoordinates = false;
                 break;
            }
      }
     
      // check for 2D coordinates
      boolean twoDCoordinates = true;
      for (int i = 0; i < container.getAtomCount(); i++) {
            if (container.getAtom(i).getPoint2d() == null) {
                 twoDCoordinates = false;
                 break;
            }
      }
     
      // check for query bonds
      boolean queryBonds = false;
      for (int i            
 }","public StereoEncoder create(IAtomContainer container, int[][] graph){
     
      // check for 3D coordinates
      boolean threeD = true;
      for (IAtom atom : container.atoms()) {
            if (atom.getPoint3d() == null) {
                 threeD = false;
                 break;
            }
      }
     
      // check for 3D coordinates
      if (threeD) {
            return new Tetrahedral3DEncoder(container, graph);
      }
     
      // check for 2D coordinates
      boolean twoD = true;
      for (IAtom atom : container.atoms()) {
            if (atom.getPoint2d() == null) {
                 twoD = false;
                 break;
            }
      }
     
      // check for 2D coordinates
      if (twoD) {
            return new Tetrahedral2DEncoder(container, graph);
      }
     
      // no coordinates
      return null;          
 }",Not Valid,Not Valid,NOT PASS,Syntax Error,None,None,  0.15481491363134647,None,None,None,None,None,164.0,0.7387387387387387,233.0,0.7373417721518988,None,None,121.0,0.9918032786885246,315.0,0.9968354430379747,10.0,0.7692307692307693,0.0,0.0,6.0,0.46153846153846156
140,jackson-databind,"public byte[] binaryValue() throws IOException{
    if (_value instanceof byte[]) {
        return (byte[]) _value;
    }
    return super.binaryValue();
}",binaryValue,com/fasterxml/jackson/databind/node/POJONode.java,/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java,"/**
     * As it is possible that some implementations embed byte[] as POJONode
     * (despite optimal being {@link BinaryNode}), let's add support for exposing
     * binary data here too.
     */",36-48,"('binaryValue', {'INSTRUCTION': {'covered': 8, 'missed': 3}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,35.0,"As it is possible that some implementations embed byte[] as POJONode  (despite optimal being {@link BinaryNode}), let's add support for exposing  binary data here too.","We add support for exposing binary data as it is possible for some implementations to incorporate byte[] as POJONode ( despite the fact that {@link BinaryNode} is optimal),",It is possible that some implementations will add support for exposing data in the form of POJONode.,1.11090718020103,"  As it is possible that some implementations integrate byte[] as POJONode (although the optimal is {@link BinaryNode}), let's add here also support for binary data exposure."," public byte[] binaryValue() throws IOException{
        if(_value instanceof byte[]){
            return (byte[])_value;
        }
        if(_value instanceof JsonSerializable){
            return ((JsonSerializable)_value).serialize();
        }
        throw new IOException(""Cannot serialize POJO of type ""+_value.getClass().getName());        
 }"," public byte[] binaryValue() throws IOException{
        if(_value instanceof BinaryNode){
            return ((BinaryNode)_value).binaryValue();
        }
        return null;        
 }"," public byte[] binaryValue() throws IOException{
        throw new UnsupportedOperationException(""POJO node does not support binary value access"");      
 }"," public byte[] binaryValue() throws IOException{
        if (_value instanceof JsonSerializable) {
            return ((JsonSerializable)_value).serialize();
        }
        return null;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7786452070134962,  0.7072992925578007,  0.5556407686175684,  0.28199258679612427,32.0,0.47761194029850745,14.0,0.3783783783783784,15.0,0.40540540540540543,22.0,0.5945945945945946,37.0,0.5522388059701493,34.0,0.5074626865671642,50.0,0.746268656716418,25.0,0.8620689655172413,9.0,0.3333333333333333,18.0,0.6923076923076923
141,cdk,"private boolean isAmide(IAtom atom0, IAtom atom1, IAtomContainer ac){
    if (atom0.getAtomicNumber() == IElement.C && atom1.getAtomicNumber() == IElement.N) {
        for (IAtom neighbor : ac.getConnectedAtomsList(atom0)) {
            if (neighbor.getAtomicNumber() == IElement.O && ac.getBond(atom0, neighbor).getOrder() == Order.DOUBLE) {
                return true;
            }
        }
    }
    return false;
}",isAmide,org/openscience/cdk/qsar/descriptors/molecular/RotatableBondsCountDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/RotatableBondsCountDescriptor.java,"/**
     * Checks whether both atoms are involved in an amide C-N bond: *N(*)C(*)=O.
     *
     * Only the most common constitution is considered. Tautomeric, O\C(*)=N\*,
     * and charged forms, [O-]\C(*)=N\*, are ignored.
     *
     * @param atom0 the first bonding partner
     * @param atom1 the second bonding partner
     * @param ac the parent container
     *
     * @return if both partners are involved in an amide C-N bond
     */",192-215,"('isAmide', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",90.0,20.0,Checks whether both atoms are involved in an amide C-N bond: N()C()=O.,It allows one to check whether both atoms are involved in a C-N amide bond: *N(*)C(*)=O.,"The N is for ""N is involved in an amide C-N bond.""",0.63936359819647,  Checks whether the two atoms are involved in an amide bond C-N: N()C()=O.,"private boolean isAmide(IAtom atom0, IAtom atom1, IAtomContainer ac){
        if (atom0.getAtomicNumber() != IElement.N || atom1.getAtomicNumber() != IElement.C) return false;
        if (atom0.getFormalCharge() != null && atom0.getFormalCharge() != 0) return false;
        if (atom1.getFormalCharge() != null && atom1.getFormalCharge() != 0) return false;
        if (ac.getConnectedBondsCount(atom0) != 1) return false;
        if (ac.getConnectedBondsCount(atom1) != 1) return false;
        IBond bond = ac.getConnectedBonds(atom0).iterator().next();
        if (bond.getOrder() != IBond.Order.SINGLE) return false;
        if (bond.getBegin() != atom0) return false;
        if (bond.getEnd() != atom1) return false;
        bond = ac.getConnectedBonds(atom1).iterator().next();
        if (bond.getOrder() != IBond.Order.SINGLE) return false;
        if (bond.getBegin() != atom1) return false;
        if (bond.getEnd() != atom0) return false;
        IAtom atom = bond.getBegin();
        if (atom.getAtomicNumber() != IElement.O) return false;
        if (atom.getFormalCharge() != null && atom.getFormalCharge() != 0) return false;
        return true;        
 }",Not Valid,"private boolean isAmide(IAtom atom0, IAtom atom1, IAtomContainer ac){
        if (atom0.getAtomicNumber() == IElement.N && atom1.getAtomicNumber() == IElement.C) {
            IAtom nitrogen = atom0;
            IAtom carbon = atom1;
            if (ac.getConnectedBondsCount(nitrogen) == 1) {
                if (ac.getConnectedBondsCount(carbon) == 2) {
                    IBond bond = ac.getConnectedBond(carbon, nitrogen);
                    if (bond.getOrder() == IBond.Order.DOUBLE) {
                        return true;
                    }
                }
            }
        }
        if (atom1.getAtomicNumber() == IElement.N && atom0.getAtomicNumber() == IElement.C) {
            IAtom nitrogen = atom1;
            IAtom carbon = atom0;
            if (ac.getConnectedBondsCount(nitrogen) == 1) {
                if (ac.getConnectedBondsCount(carbon) == 2) {
                    IBond bond = ac.getConnectedBond(carbon, nitrogen);
                    if (bond.getOrder() == IBond.Order.DOUBLE) {
                        return true;
                    }
                }
            }
        }
        return false;
    }","private boolean isAmide(IAtom atom0, IAtom atom1, IAtomContainer ac){
        if (atom0.getAtomicNumber() != IElement.N || atom1.getAtomicNumber() != IElement.C) return false;
        IBond[] bonds = ac.getConnectedBonds(atom0);
        for (IBond bond : bonds) {
            if (bond.getOrder() == Order.DOUBLE) {
                if (bond.getBegin().equals(atom0) && bond.getEnd().equals(atom1)) return true;
                if (bond.getBegin().equals(atom1) && bond.getEnd().equals(atom0)) return true;
            }
        }
        return false;       
 }",NOT PASS,Not Valid,NOT PASS,NOT PASS,  0.5485107192096506,None,  0.5911372653717459,  0.6601690495712231,218.0,0.7785714285714286,None,None,70.0,0.5263157894736842,123.0,0.6119402985074627,None,None,177.0,0.6321428571428571,169.0,0.6035714285714285,9.0,0.5294117647058824,4.0,0.2857142857142857,8.0,0.6153846153846154
142,weblogic-kubernetes-operator,"private static ParsedJson parseJson(String jsonString){
    ObjectMapper mapper = new ObjectMapper();
    try {
        ParsedJson parsedJson = new ParsedJson();
        Map result = mapper.readValue(jsonString, Map.class);
        parsedJson.domainName = (String) result.get(""name"");
        parsedJson.adminServerName = (String) result.get(""adminServerName"");
        Map servers = (Map<String, Object>) result.get(""servers"");
        if (servers != null) {
            parsedJson.servers = (List<Map<String, Object>>) servers.get(""items"");
        }
        Map serverTemplates = (Map<String, Object>) result.get(""serverTemplates"");
        if (serverTemplates != null) {
            parsedJson.serverTemplates = (List<Map<String, Object>>) serverTemplates.get(""items"");
        }
        Map clusters = (Map<String, Object>) result.get(""clusters"");
        if (clusters != null) {
            parsedJson.clusters = (List<Map<String, Object>>) clusters.get(""items"");
        }
        Map machines = (Map<String, Object>) result.get(""machines"");
        if (machines != null) {
            parsedJson.machines = (List<Map<String, Object>>) machines.get(""items"");
        }
        return parsedJson;
    } catch (Exception e) {
        LOGGER.warning(MessageKeys.JSON_PARSING_FAILED, jsonString, e.getMessage());
    }
    return null;
}",parseJson,oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,"/**
   * Parse the json string containing WLS configuration and return a list containing a map of
   * (server attribute name, attribute value).
   *
   * @param jsonString JSON string containing WLS configuration to be parsed
   * @return a ParsedJson object containing WebLogic domain configuration by parsing the given JSON
   *     string
   */",165-202,"('parseJson', {'INSTRUCTION': {'covered': 80, 'missed': 17}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 3}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",293.0,24.0,"Parse the json string containing WLS configuration and return a list containing a map of  (server attribute name, attribute value).","Returns a list containing a map of (server attribute name, attribute value) after parsing the json string containing the WLS configuration",Parse the json string and return a list with a map.,0.508266634349763,"  Parse the json string containing the WLS configuration and return a list containing a map of (server attribute name, attribute value).",Not Valid,Not Valid," private static ParsedJson parseJson(String jsonString){
    ParsedJson parsedResult = new ParsedJson();
    try {
      JsonParser parser = new JsonParser();
      JsonObject jsonObject = parser.parse(jsonString).getAsJsonObject();
      parsedResult.domainName = jsonObject.get(""name"").getAsString();
      parsedResult.adminServerName = jsonObject.get(""adminServerName"").getAsString();
      JsonArray clusters = jsonObject.getAsJsonArray(""clusters"");
      if (clusters != null) {
        parsedResult.clusters = new ArrayList<>();
        for (JsonElement cluster : clusters) {
          parsedResult.clusters.add(cluster.getAsJsonObject());
        }
      }
      JsonArray servers = jsonObject.getAsJsonArray(""servers"");
      if (servers != null) {
        parsedResult.servers = new ArrayList<>();
        for (JsonElement server : servers) {
          parsedResult.servers.add(server.getAsJsonObject());
        }
      }
      JsonArray serverTemplates = jsonObject.getAsJsonArray(""serverTemplates"");
      if (serverTemplates != null) {
        parsedResult.serverTemplates = new ArrayList<>();
        for (JsonElement serverTemplate : serverTemplates) {
          parsedResult.serverTemplates.add(serverTemplate.getAsJsonObject());
        }
      }
      JsonArray machines = jsonObject.getAsJsonArray(""machines"");
      if (machines != null) {
        parsedResult.machines = new ArrayList<>();
        for (JsonElement machine : machines) {
          parsedResult.machines.add(machine.getAsJsonObject());
        }
      }
    } catch (Exception e) {
      // ignore exception and return empty parsedResult
      return new ParsedJson();
    }
    return parsedResult;    
 }"," private static ParsedJson parseJson(String jsonString){
    ParsedJson parsedResult = new ParsedJson();
    try {
      JsonParser parser = new JsonParser();
      JsonObject jsonObject = parser.parse(jsonString).getAsJsonObject();
      parsedResult.domainName = jsonObject.get(""name"").getAsString();
      parsedResult.adminServerName = jsonObject.get(""adminServerName"").getAsString();
      JsonArray clusters = jsonObject.getAsJsonArray(""clusters"");
      if (clusters != null) {
        parsedResult.clusters = new ArrayList<>();
        for (JsonElement cluster : clusters) {
          parsedResult.clusters.add(cluster.getAsJsonObject());
        }
      }
      JsonArray servers = jsonObject.getAsJsonArray(""servers"");
      if (servers != null) {
        parsedResult.servers = new ArrayList<>();
        for (JsonElement server : servers) {
          parsedResult.servers.add(server.getAsJsonObject());
        }
      }
      JsonArray serverTemplates = jsonObject.getAsJsonArray(""serverTemplates"");
      if (serverTemplates != null) {
        parsedResult.serverTemplates = new ArrayList<>();
        for (JsonElement serverTemplate : serverTemplates) {
          parsedResult.serverTemplates.add(serverTemplate.getAsJsonObject());
        }
      }
      JsonArray machines = jsonObject.getAsJsonArray(""machines"");
      if (machines != null) {
        parsedResult.machines = new ArrayList<>();
        for (JsonElement machine : machines) {
          parsedResult.machines.add(machine.getAsJsonObject());
        }
      }
    } catch (Exception e) {
      // ignore exception and return empty parsedResult
      LOGGER.log(Level.WARNING, ""Error parsing JSON response from WLS admin server"", e);
    }
    return parsedResult;    
 }",Not Valid,Not Valid,NOT PASS,NOT PASS,None,None,  0.32157168836170397,  0.32902996127006984,None,None,None,None,185.0,0.6146179401993356,191.0,0.6496598639455783,None,None,300.0,0.9966777408637874,293.0,0.9965986394557823,19.0,0.8636363636363636,1.0,0.045454545454545456,11.0,0.5238095238095238
143,logstash-logback-encoder,"protected PatternLayoutAdapter<Event> buildLayout(String format){
    PatternLayoutAdapter<Event> adapter = new PatternLayoutAdapter<>(createLayout());
    adapter.setPattern(format);
    adapter.setContext(context);
    adapter.start();
    return adapter;
}",buildLayout,net/logstash/logback/pattern/AbstractJsonPatternParser.java,/src/main/java/net/logstash/logback/pattern/AbstractJsonPatternParser.java,"/**
     * Initialize a PatternLayout with the supplied format and throw an {@link IllegalArgumentException}
     * if the format is invalid.
     * 
     * @param format the pattern layout format
     * @return a configured and started {@link PatternLayoutAdapter} instance around the supplied format
     * @throws IllegalArgumentException if the supplied format is not a valid PatternLayout
     */",212-227,"('buildLayout', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,21.0,Initialize a PatternLayout with the supplied format and throw an {@link IllegalArgumentException}  if the format is invalid.,"From the provided format, it initialises a PatternLayout and throws a {@link IllegalArgumentException} if the format is invalid.","If the format is invalid, throw an IllegalArgumentException if the pattern is created.",2.42343002799508,  Initialize a PatternLayout with the format provided and run a {@link IllegalArgumentException} if the format is invalid.," protected PatternLayoutAdapter<Event> buildLayout(String format){
        PatternLayoutAdapter<Event> layout = new PatternLayoutAdapter<>(format, context);
        if (!layout.isValid()) {
            throw new IllegalArgumentException(""Invalid pattern: "" + format);
        }
        return layout;
    }"," protected PatternLayoutAdapter<Event> buildLayout(String format){
        PatternLayoutAdapter<Event> layout = new PatternLayoutAdapter<>(format, context);
        if (!layout.isValid()) {
            throw new IllegalArgumentException(""Invalid format: "" + format);
        }
        return layout;
    }"," protected PatternLayoutAdapter<Event> buildLayout(String format){
        PatternLayoutAdapter<Event> layout = new PatternLayoutAdapter<>(format, context);
        layout.setThrowExceptionOnMissing(true);
        layout.start();
        return layout;
    }"," protected PatternLayoutAdapter<Event> buildLayout(String format){
        PatternLayoutAdapter<Event> layout = new PatternLayoutAdapter<>(format, context);
        layout.start();
        return layout;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5324879703015922,  0.5324879703015922,  0.5543867938710494,  0.5954933235616844,22.0,0.4230769230769231,22.0,0.4230769230769231,18.0,0.34615384615384615,16.0,0.3076923076923077,1.0,0.019230769230769232,15.0,0.28846153846153844,13.0,0.25,10.0,0.5263157894736842,4.0,0.2222222222222222,11.0,0.6111111111111112
144,anserini,"public static String convertLuceneDocidToDocid(IndexReader reader, int docid){
    if (docid >= reader.maxDoc())
        return null;
    try {
        return reader.document(docid).get(IndexArgs.ID);
    } catch (IOException e) {
        return null;
    }
}",convertLuceneDocidToDocid,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,"/**
   * Converts a Lucene internal docid to a collection docid.
   *
   * @param reader index reader
   * @param docid Lucene internal docid
   * @return corresponding collection docid, or <code>null</code> if not found.
   */",757-774,"('convertLuceneDocidToDocid', {'INSTRUCTION': {'covered': 12, 'missed': 3}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,10.0,Converts a Lucene internal docid to a collection docid.,A collection docid is converted into an internal Lucene docid,A collection docid is converted to a Lucene internal docid.,0.808480929669891,  Converts an internal Lucene docid to a collection docid.,"public static String convertLuceneDocidToDocid(IndexReader reader, int docid){
    try {
      return reader.document(docid).get(IndexArgs.ID);
    } catch (IOException e) {
      // Silently eat the error and return -1
      return null;
    }
  }","public static String convertLuceneDocidToDocid(IndexReader reader, int docid){
    try {
      return reader.document(docid).get(IndexArgs.ID);
    } catch (IOException e) {
      // Silently eat the error and return -1
      return null;
    }
  }","public static String convertLuceneDocidToDocid(IndexReader reader, int docid){
    try {
      return reader.document(docid).get(IndexArgs.ID);
    } catch (IOException e) {
      // Silently eat the error and return -1
      return null;
    }
  }"," public static String convertLuceneDocidToDocid(IndexReader reader, int docid){
    try {
      return reader.document(docid).get(IndexArgs.ID);
    } catch (IOException e) {
      // Silently eat the error and return null
      return null;
    }
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7123619693286222,  0.7123619693286222,  0.7123619693286222,  0.7123619693286222,13.0,0.23636363636363636,13.0,0.23636363636363636,13.0,0.23636363636363636,13.0,0.23636363636363636,0.0,0.0,0.0,0.0,0.0,0.0,10.0,0.9090909090909091,3.0,0.3,7.0,0.6363636363636364
145,cdk,"public IRenderingElement generateCompactElement(IAtom atom, RendererModel model){
    Point2d point = atom.getPoint2d();
    double radius = (Double) model.get(AtomRadius.class) / model.getParameter(Scale.class).getValue();
    double distance = 2 * radius;
    if (model.get(CompactShape.class) == Shape.SQUARE) {
        return new RectangleElement(point.x - radius, point.y - radius, distance, distance, true, getAtomColor(atom, model));
    } else {
        return new OvalElement(point.x, point.y, radius, true, getAtomColor(atom, model));
    }
}",generateCompactElement,org/openscience/cdk/renderer/generators/BasicAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/BasicAtomGenerator.java,"/**
     * Generate a compact element for an atom, such as a circle or a square,
     * rather than text element.
     *
     * @param atom the atom to generate the compact element for
     * @param model the renderer model
     * @return a compact rendering element
     */",333-351,"('generateCompactElement', {'INSTRUCTION': {'covered': 59, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",130.0,21.0,"Generate a compact element for an atom, such as a circle or a square,  rather than text element.","Instead of a text element for an atom, a compact element such as a circle or square is generated",A circle or square is a better fit for an atom than a text element.,0.700671400207211,"  Generate a compact element for an atom, such as a circle or square, rather than a text element."," public IRenderingElement generateCompactElement(IAtom atom, RendererModel model){
        Shape shape = (Shape) model.get(CompactShape.class);
        if (shape == Shape.CIRCLE) {
            return generateCircle(atom, model);
        } else {
            return generateSquare(atom, model);
        }
    }","public IRenderingElement generateCompactElement(IAtom atom, RendererModel model){
        Shape shape = (Shape) model.get(CompactShape.class);
        if (shape == Shape.CIRCLE) {
            return new Circle(atom.getPoint2d(), model.get(AtomRadius.class));
        } else {
            return new Rectangle(atom.getPoint2d(), model.get(AtomRadius.class));
        }
    }"," public IRenderingElement generateCompactElement(IAtom atom, RendererModel model){
        Shape shape = (Shape) model.get(CompactShape.class);
        if (shape == Shape.SQUARE) {
            return generateSquareElement(atom, model);
        } else {
            return generateCircleElement(atom, model);
        }
    }"," public IRenderingElement generateCompactElement(IAtom atom, RendererModel model){
        Shape shape = (Shape) model.get(CompactShape.class);
        if (shape == null) {
            shape = Shape.SQUARE;
        }
        ElementGroup elementGroup = new ElementGroup();
        elementGroup.add(MarkedElement.markupAtom(new Circle(shape.getRadius()), atom));
        return elementGroup;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.300131512758802,  0.35645549584082625,  0.27441405799878715,  0.3093984341634497,82.0,0.6259541984732825,77.0,0.5877862595419847,93.0,0.7099236641221374,81.0,0.6183206106870229,26.0,0.32098765432098764,35.0,0.4666666666666667,3.0,0.05263157894736842,12.0,0.6,2.0,0.10526315789473684,15.0,0.7894736842105263
147,matsim-libs,"public E poll(){
    E minValue;
    if (isEmpty())
        return null;
    else {
        this.modCount++;
        minValue = data[0];
        if (classicalRemove) {
            data[0] = data[heapSize - 1];
            costs[0] = costs[heapSize - 1];
            indices[this.getIndex(data[0])] = 0;
            indices[this.getIndex(minValue)] = -1;
            heapSize--;
            if (heapSize > 0)
                siftDown(0);
        } else {
            siftDownUp(0);
            indices[this.getIndex(minValue)] = -1;
        }
        return minValue;
    }
}",poll,org/matsim/core/router/priorityqueue/BinaryMinHeap.java,/matsim/src/main/java/org/matsim/core/router/priorityqueue/BinaryMinHeap.java,"/**
         * Retrieves and removes the head of this queue, or <tt>null</tt> if this
         * queue is empty.
         * 
         * @return the head of this queue, or <tt>null</tt> if this queue is empty.
         */",151-179,"('poll', {'INSTRUCTION': {'covered': 83, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",130.0,23.0,"Retrieves and removes the head of this queue, or <tt>null</tt> if this  queue is empty.","The head of this queue is retrieved and removed, otherwise returns <tt>null</tt> if this queue is empty.","If the queue is empty, you can retrieve and remove the head of it.",0.412031528381004,"  Retrieves and deletes the header from this queue, or <tt>null</tt> if this queue is empty.","public E poll(){
	 if (isEmpty()) return null;
	 else return poll(0);			
 }","public E poll(){
	 	if (isEmpty()) return null;
 	else return poll(0);		
 }","public E poll(){
	 if (isEmpty()) return null;
	 else return poll(0);			
 }","public E poll(){
	 if (isEmpty()) return null;
	 else return poll(0);			
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.09020613293206697,  0.09020613293206697,  0.09020613293206697,  0.09020613293206697,109.0,0.8320610687022901,109.0,0.8320610687022901,109.0,0.8320610687022901,109.0,0.8320610687022901,0.0,0.0,0.0,0.0,0.0,0.0,11.0,0.6111111111111112,3.0,0.1875,15.0,0.9375
148,egeria,"private Optional<EntityDetail> findDatabaseSchemaEntity(String userId, String qualifiedName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, DEPLOYED_DATABASE_SCHEMA_TYPE_NAME);
}",findDatabaseSchemaEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineRelationalDataHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineRelationalDataHandler.java,"/**
     * Find out if the DatabaseSchema object is already stored in the repository.
     * It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the database schema to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",166-182,"('findDatabaseSchemaEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,13.0,Find out if the DatabaseSchema object is already stored in the repository.,"Discovers whether the DatabaseSchema object is already stored in the repository.  To retrieve the entity, use the full name","If the database object is already in the repository, you should find it.",0.155385203559939,  Verify that the DatabaseSchema object is already stored in the repository.," private Optional<EntityDetail> findDatabaseSchemaEntity(String userId, String qualifiedName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
        return dataEngineCommonHandler.findEntity(userId, qualifiedName, DATABASE_SCHEMA_TYPE_NAME);        
 }"," private Optional<EntityDetail> findDatabaseSchemaEntity(String userId, String qualifiedName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
        return dataEngineCommonHandler.findEntity(userId, qualifiedName, DATABASE_SCHEMA_TYPE_NAME);        
 }"," private Optional<EntityDetail> findDatabaseSchemaEntity(String userId, String qualifiedName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
        return dataEngineCommonHandler.findEntity(userId, qualifiedName, DATABASE_SCHEMA_TYPE_NAME);        
 }"," private Optional<EntityDetail> findDatabaseSchemaEntity(String userId, String qualifiedName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
        return dataEngineCommonHandler.findEntity(userId, qualifiedName, DATABASE_SCHEMA_TYPE_NAME);        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.9597107821926839,  0.9597107821926839,  0.9597107821926839,  0.9597107821926839,1.0,0.029411764705882353,1.0,0.029411764705882353,1.0,0.029411764705882353,1.0,0.029411764705882353,0.0,0.0,0.0,0.0,0.0,0.0,11.0,0.55,3.0,0.23076923076923078,10.0,0.7142857142857143
149,liquibase,"protected boolean supportsSortingObjects(Database database){
    return (database instanceof AbstractDb2Database) || (database instanceof MSSQLDatabase) || (database instanceof OracleDatabase) || database instanceof PostgresDatabase;
}",supportsSortingObjects,liquibase/diff/output/changelog/DiffToChangeLog.java,/liquibase-core/src/main/java/liquibase/diff/output/changelog/DiffToChangeLog.java,"/**
     * Used by {@link #sortMissingObjects(Collection, Database)} to determine whether to go into the sorting logic.
     */",487-493,"('supportsSortingObjects', {'INSTRUCTION': {'covered': 14, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 4}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,23.0,"Used by {@link #sortMissingObjects(Collection, Database)} to determine whether to go into the sorting logic.","To determine whether to go into the sorting logic used by {@link #sortMissingObjects(Collection, Database)}",The use of the #sortMissingObjects to determine whether to go into the sorting logic was used by @link.,1.05887834297401,"  Used by {@link #sortMissingObjects(Collection, Database)} to determine whether to enter the sort logic."," protected boolean supportsSortingObjects(Database database){
        return true;
    }"," protected boolean supportsSortingObjects(Database database){
        return true;
    }"," protected boolean supportsSortingObjects(Database database){
        return true;
    }"," protected boolean supportsSortingObjects(Database database){
        return true;
    }",PASS,PASS,PASS,PASS,  0.18295041760395148,  0.18295041760395148,  0.18295041760395148,  0.18295041760395148,21.0,0.6363636363636364,21.0,0.6363636363636364,21.0,0.6363636363636364,21.0,0.6363636363636364,0.0,0.0,0.0,0.0,0.0,0.0,12.0,0.8,3.0,0.2,10.0,0.5263157894736842
151,tablesaw," static Selection withoutRange(int totalRangeStart, int totalRangeEnd, int excludedRangeStart, int excludedRangeEnd){
    return BitmapBackedSelection.withoutRange(totalRangeStart, totalRangeEnd, excludedRangeStart, excludedRangeEnd);
}",withoutRange,tech/tablesaw/selection/Selection.java,/core/src/main/java/tech/tablesaw/selection/Selection.java,"/**
   * Returns a Selection containing all values from totalRangeStart to totalRangeEnd, except for
   * those in the range from excludedRangeStart to excludedRangeEnd. Start values are inclusive, end
   * values exclusive.
   */",108-117,"('withoutRange', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,22.0,"Returns a Selection containing all values from totalRangeStart to totalRangeEnd, except for  those in the range from excludedRangeStart to excludedRangeEnd.","All values from totalRangeStart to totalRangeEnd except those in the range excludedRangeStart to excludedRangeEnd are returned in a selection. Start values are included, end values excluded.","The selection contains values from totalRangeStart to totalRangeEnd, except for those in the range from excludedRangeStart to excludedRangeEnd.",0.961275903059573,"  Returns a selection containing all values from totalRangeStart to totalRangeEnd, except those between excludedRangeStart and excludedRangeEnd.","  static Selection withoutRange(int totalRangeStart, int totalRangeEnd, int excludedRangeStart, int excludedRangeEnd){
    return BitmapBackedSelection.withoutRange(totalRangeStart, totalRangeEnd, excludedRangeStart, excludedRangeEnd);
  }","  static Selection withoutRange(int totalRangeStart, int totalRangeEnd, int excludedRangeStart, int excludedRangeEnd){
    return BitmapBackedSelection.withoutRange(totalRangeStart, totalRangeEnd, excludedRangeStart, excludedRangeEnd);
  }","  static Selection withoutRange(int totalRangeStart, int totalRangeEnd, int excludedRangeStart, int excludedRangeEnd){
    return BitmapBackedSelection.withoutRange(totalRangeStart, totalRangeEnd, excludedRangeStart, excludedRangeEnd);
  }","  static Selection withoutRange(int totalRangeStart, int totalRangeEnd, int excludedRangeStart, int excludedRangeEnd){
    return BitmapBackedSelection.withoutRange(totalRangeStart, totalRangeEnd, excludedRangeStart, excludedRangeEnd);
  }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,21.0,0.7777777777777778,7.0,0.3333333333333333,5.0,0.23809523809523808
152,weblogic-kubernetes-operator,"public synchronized boolean containsServer(String serverName){
    if (!isNullOrEmpty(serverName)) {
        return getServers().stream().anyMatch(s -> serverName.equals(s.getName())) || getConfiguredClusters().stream().anyMatch(c -> c.containsServer(serverName));
    }
    return false;
}",containsServer,oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,"/**
   * Whether the WebLogic domain contains a server with the given server name,
   * including standalone servers, and servers that belong to a configured or dynamic cluster.
   *
   * @param serverName server name to be checked
   * @return True if the WebLogic domain contains a server with the given server name
   */",353-366,"('containsServer', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",68.0,28.0,"Whether the WebLogic domain contains a server with the given server name,  including standalone servers, and servers that belong to a configured or dynamic cluster.","The following method returns True if the WebLogic domain contains a server with the given server name, including independent servers and those belonging to a configured or dynamic cluster.",The server name of the server in the WebLogic domain can include the server that is a part of a configured or dynamic cluster.,0.764851472234447,"  If the WebLogic domain contains a server with the given server name, including stand-alone servers and servers belonging to a configured or dynamic cluster."," public synchronized boolean containsServer(String serverName){
    if (serverName != null) {
      for (WlsServerConfig serverConfig : servers) {
        if (serverConfig.getName().equals(serverName)) {
          return true;
        }
      }
    }
    return false;
  }"," public synchronized boolean containsServer(String serverName){
    if (serverName != null) {
      for (WlsServerConfig serverConfig : servers) {
        if (serverConfig.getName().equals(serverName)) {
          return true;
        }
      }
    }
    return false;
  }"," public synchronized boolean containsServer(String serverName){
    if (serverName != null && servers != null) {
      for (WlsServerConfig serverConfig : servers) {
        if (serverConfig.getName().equals(serverName)) {
          return true;
        }
      }
    }
    return false;
  }"," public synchronized boolean containsServer(String serverName){
    if (serverName != null && servers != null) {
      for (WlsServerConfig serverConfig : servers) {
        if (serverConfig.getName().equals(serverName)) {
          return true;
        }
      }
    }
    return false;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.37803385947124757,  0.37803385947124757,  0.3980272979128598,  0.3980272979128598,41.0,0.5942028985507246,41.0,0.5942028985507246,42.0,0.6086956521739131,42.0,0.6086956521739131,0.0,0.0,4.0,0.07547169811320754,4.0,0.07547169811320754,11.0,0.36666666666666664,5.0,0.19230769230769232,18.0,0.6923076923076923
153,cdk,"public LigancyFourChirality project(ILigand[] newOrder){
    ITetrahedralChirality.Stereo newStereo = this.stereo;
    ILigand[] newAtoms = new ILigand[4];
    System.arraycopy(this.ligands, 0, newAtoms, 0, 4);
    for (int i = 0; i < 3; i++) {
        if (!newAtoms[i].getLigandAtom().equals(newOrder[i].getLigandAtom())) {
            for (int j = i; j < 4; j++) {
                if (newAtoms[j].getLigandAtom().equals(newOrder[i].getLigandAtom())) {
                    swap(newAtoms, i, j);
                    if (newStereo == Stereo.CLOCKWISE) {
                        newStereo = Stereo.ANTI_CLOCKWISE;
                    } else {
                        newStereo = Stereo.CLOCKWISE;
                    }
                }
            }
        }
    }
    return new LigancyFourChirality(chiralAtom, newAtoms, newStereo);
}",project,org/openscience/cdk/geometry/cip/LigancyFourChirality.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/LigancyFourChirality.java,"/**
     * Recalculates the {@link LigancyFourChirality} based on the new, given atom ordering.
     *
     * @param newOrder new order of atoms
     * @return the chirality following the new atom order
     */",117-149,"('project', {'INSTRUCTION': {'covered': 68, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",176.0,16.0,"Recalculates the {@link LigancyFourChirality} based on the new, given atom ordering.",Based on the new ordering of atoms Recalculates the {@link LigancyFourChirality},The @link Ligancy FourChirality is calculated based on the new atom ordering.,1.75341208847306,  Recalculates the {@link LigancyFourChirality} according to the new order of atoms given.,"public LigancyFourChirality project(ILigand[] newOrder){
        if (newOrder.length != 4) {
            throw new IllegalArgumentException(""Expected four ligands, got "" + newOrder.length);
        }
        ILigand[] newLigands = new ILigand[4];
        for (int i = 0; i < 4; i++) {
            newLigands[i] = newOrder[i];
        }
        return new LigancyFourChirality(chiralAtom, newLigands, stereo);
    }","public LigancyFourChirality project(ILigand[] newOrder){
        if (newOrder.length != 4) {
            throw new IllegalArgumentException(""Expected four ligands, got "" + newOrder.length);
        }
        ILigand[] newLigands = new ILigand[4];
        for (int i = 0; i < 4; i++) {
            newLigands[i] = ligands[newOrder[i].getIndex()];
        }
        return new LigancyFourChirality(chiralAtom, newLigands, stereo);
    }","public LigancyFourChirality project(ILigand[] newOrder){
        if (newOrder.length != 4) {
            throw new IllegalArgumentException(""The new order must have exactly four elements."");
        }
        if (newOrder[0].equals(ligands[0]) && newOrder[1].equals(ligands[1]) && newOrder[2].equals(ligands[2]) && newOrder[3].equals(ligands[3])) {
            return this;
        }
        LigancyFourChirality newLigancy = new LigancyFourChirality(chiralAtom, newOrder, stereo);
        return newLigancy;
    }","public LigancyFourChirality project(ILigand[] newOrder){
        if (newOrder.length != 4) {
            throw new IllegalArgumentException(""The new order must have exactly four elements."");
        }
        if (newOrder[0].equals(ligands[0]) && newOrder[1].equals(ligands[1]) && newOrder[2].equals(ligands[2]) && newOrder[3].equals(ligands[3])) {
            return this;
        }
        LigancyFourChirality newLigancy = new LigancyFourChirality(chiralAtom, newOrder, stereo);
        return newLigancy;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.23946883132385666,  0.2846336763397866,  0.1682520642240451,  0.1682520642240451,127.0,0.7175141242937854,123.0,0.6949152542372882,129.0,0.7288135593220338,129.0,0.7288135593220338,7.0,0.07954545454545454,58.0,0.5576923076923077,58.0,0.5576923076923077,11.0,0.9166666666666666,7.0,0.5384615384615384,8.0,0.6153846153846154
154,logstash-logback-encoder,"private void appendRootCauseFirst(StringBuilder builder, String prefix, int indent, IThrowableProxy throwableProxy, Deque<String> stackHashes){
    if (throwableProxy == null || builder.length() > maxLength) {
        return;
    }
    if (throwableProxy.getCause() != null) {
        appendRootCauseFirst(builder, prefix, indent, throwableProxy.getCause(), stackHashes);
        prefix = CoreConstants.WRAPPED_BY;
    }
    String hash = stackHashes == null || stackHashes.isEmpty() ? null : stackHashes.removeLast();
    appendFirstLine(builder, prefix, indent, throwableProxy, hash);
    appendStackTraceElements(builder, indent, throwableProxy);
    IThrowableProxy[] suppressedThrowableProxies = throwableProxy.getSuppressed();
    if (suppressedThrowableProxies != null) {
        for (IThrowableProxy suppressedThrowableProxy : suppressedThrowableProxies) {
            appendRootCauseFirst(builder, CoreConstants.SUPPRESSED, indent + ThrowableProxyUtil.SUPPRESSED_EXCEPTION_INDENT, suppressedThrowableProxy, null);
        }
    }
}",appendRootCauseFirst,net/logstash/logback/stacktrace/ShortenedThrowableConverter.java,/src/main/java/net/logstash/logback/stacktrace/ShortenedThrowableConverter.java,"/**
     * Appends a throwable and recursively appends its causedby/suppressed throwables
     * in ""reverse"" order (Root cause first).
     */",349-380,"('appendRootCauseFirst', {'INSTRUCTION': {'covered': 59, 'missed': 16}, 'BRANCH': {'covered': 9, 'missed': 5}, 'LINE': {'covered': 11, 'missed': 2}, 'COMPLEXITY': {'covered': 3, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",167.0,20.0,"Appends a throwable and recursively appends its causedby/suppressed throwables  in ""reverse"" order (Root cause first).","It applies a throwable and recursively its caused/deleted throwables in ""reverse"" sequence (root cause first).",Appends a throwable and then reverses it in order.,1.96092468411286,"  Adds a disposable and recursively adds its caused/deleted disposables in ""reverse"" order (first cause first)."," private void appendRootCauseFirst(StringBuilder builder, String prefix, int indent, IThrowableProxy throwableProxy, Deque<String> stackHashes){
        if (throwableProxy == null || builder.length() > maxLength) {
            return;
        }
    
        String hash = stackHashes == null || stackHashes.isEmpty() ? null : stackHashes.removeFirst();
        appendFirstLine(builder, prefix, indent, throwableProxy, hash);
        appendStackTraceElements(builder, indent, throwableProxy);
    
        IThrowableProxy[] suppressedThrowableProxies = throwableProxy.getSuppressed();
        if (suppressedThrowableProxies != null) {
            for (IThrowableProxy suppressedThrowableProxy : suppressedThrowableProxies) {
                // stack hashes are not computed/inlined on suppressed errors
                appendRootCauseFirst(builder, CoreConstants.SUPPRESSED, indent + ThrowableProxyUtil.SUPPRESSED_EXCEPTION_INDENT, suppressedThrowableProxy, null);
            }
        }
        appendRootCauseFirst(builder, CoreConstants.CAUSED_BY, indent, throwableProxy.getCause(), stackHashes);
    }"," private void appendRootCauseFirst(StringBuilder builder, String prefix, int indent, IThrowableProxy throwableProxy, Deque<String> stackHashes){
        if (throwableProxy == null || builder.length() > maxLength) {
            return;
        }
    
        String hash = stackHashes == null || stackHashes.isEmpty() ? null : stackHashes.removeFirst();
        appendFirstLine(builder, prefix, indent, throwableProxy, hash);
        appendStackTraceElements(builder, indent, throwableProxy);
    
        IThrowableProxy[] suppressedThrowableProxies = throwableProxy.getSuppressed();
        if (suppressedThrowableProxies != null) {
            for (IThrowableProxy suppressedThrowableProxy : suppressedThrowableProxies) {
                // stack hashes are not computed/inlined on suppressed errors
                appendRootCauseFirst(builder, CoreConstants.SUPPRESSED, indent + ThrowableProxyUtil.SUPPRESSED_EXCEPTION_INDENT, suppressedThrowableProxy, null);
            }
        }
        appendRootCauseFirst(builder, CoreConstants.CAUSED_BY, indent, throwableProxy.getCause(), stackHashes);
    }"," private void appendRootCauseFirst(StringBuilder builder, String prefix, int indent, IThrowableProxy throwableProxy, Deque<String> stackHashes){
        if (throwableProxy == null || builder.length() > maxLength) {
            return;
        }
    
        String hash = stackHashes == null || stackHashes.isEmpty() ? null : stackHashes.removeFirst();
        appendFirstLine(builder, prefix, indent, throwableProxy, hash);
        appendStackTraceElements(builder, indent, throwableProxy);
    
        IThrowableProxy[] suppressedThrowableProxies = throwableProxy.getSuppressed();
        if (suppressedThrowableProxies != null) {
            for (IThrowableProxy suppressedThrowableProxy : suppressedThrowableProxies) {
                // stack hashes are not computed/inlined on suppressed errors
                appendRootCauseFirst(builder, CoreConstants.SUPPRESSED, indent + ThrowableProxyUtil.SUPPRESSED_EXCEPTION_INDENT, suppressedThrowableProxy, null);
            }
        }
        appendRootCauseFirst(builder, CoreConstants.CAUSED_BY, indent, throwableProxy.getCause(), stackHashes);
    }"," private void appendRootCauseFirst(StringBuilder builder, String prefix, int indent, IThrowableProxy throwableProxy, Deque<String> stackHashes){
        if (throwableProxy == null || builder.length() > maxLength) {
            return;
        }
    
        String hash = stackHashes == null || stackHashes.isEmpty() ? null : stackHashes.removeFirst();
        appendFirstLine(builder, prefix, indent, throwableProxy, hash);
        appendStackTraceElements(builder, indent, throwableProxy);
    
        IThrowableProxy[] suppressedThrowableProxies = throwableProxy.getSuppressed();
        if (suppressedThrowableProxies != null) {
            for (IThrowableProxy suppressedThrowableProxy : suppressedThrowableProxies) {
                // stack hashes are not computed/inlined on suppressed errors
                appendRootCauseFirst(builder, CoreConstants.SUPPRESSED, indent + ThrowableProxyUtil.SUPPRESSED_EXCEPTION_INDENT, suppressedThrowableProxy, null);
            }
        }
        appendRootCauseFirst(builder, CoreConstants.CAUSED_BY, indent, throwableProxy.getCause(), stackHashes);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8107936067746522,  0.8107936067746522,  0.8107936067746522,  0.8107936067746522,55.0,0.3273809523809524,55.0,0.3273809523809524,55.0,0.3273809523809524,55.0,0.3273809523809524,0.0,0.0,0.0,0.0,0.0,0.0,6.0,0.375,6.0,0.375,10.0,0.625
155,egeria,"protected Optional<Relationship> findRelationship(String userId, String firstGUID, String secondGUID, String firstEntityTypeName, String relationshipTypeName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    final String methodName = ""findRelationship"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateName(firstGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    invalidParameterHandler.validateName(secondGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    TypeDef relationshipTypeDef = repositoryHelper.getTypeDefByName(userId, relationshipTypeName);
    Relationship relationshipBetweenEntities = repositoryHandler.getRelationshipBetweenEntities(userId, firstGUID, firstEntityTypeName, secondGUID, relationshipTypeDef.getGUID(), relationshipTypeDef.getName(), methodName);
    if (relationshipBetweenEntities == null) {
        return Optional.empty();
    }
    if (firstGUID.equalsIgnoreCase(relationshipBetweenEntities.getEntityOneProxy().getGUID()) && secondGUID.equalsIgnoreCase(relationshipBetweenEntities.getEntityTwoProxy().getGUID())) {
        return Optional.of(relationshipBetweenEntities);
    }
    return Optional.empty();
}",findRelationship,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCommonHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCommonHandler.java,"/**
     * Find out if the relationship is already stored in the repository.
     * It will search for relationships that have the source firstGUID and target secondGUID
     *
     * @param userId               the name of the calling user
     * @param firstGUID            the unique identifier of the entity at first end
     * @param secondGUID           the unique identifier of the entity at second end
     * @param relationshipTypeName type name for the relationship to create
     * @param firstEntityTypeName  type name for the entity at first end
     *
     * @return The found relationship or an empty Optional
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",269-309,"('findRelationship', {'INSTRUCTION': {'covered': 57, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 12, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",177.0,12.0,Find out if the relationship is already stored in the repository.,Finds out whether the relation is already stored in the repository. It searches for relationships where the source is the firstGUID and the destination is the secondGUID.,"If the relationship is already in the repository, you should find out.",0.210287073468003,  Check if the relationship is already stored in the repository.," protected Optional<Relationship> findRelationship(String userId, String firstGUID, String secondGUID, String firstEntityTypeName, String relationshipTypeName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        final String methodName = ""findRelationship"";
    
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateGUID(firstGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateGUID(secondGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    
        TypeDef relationshipTypeDef = repositoryHelper.getTypeDefByName(userId, relationshipTypeName);
    
        InstanceProperties properties = repositoryHelper.addStringPropertyToInstance(serviceName, null, CommonMapper.GUID_PROPERTY_NAME,
                firstGUID, methodName);
    
        Optional<Relationship> retrievedRelationship = Optional.ofNullable(repositoryHandler.getUniqueRelationshipByProperty(userId,
                properties, relationshipTypeDef.getGUID(), relationshipTypeDef.getName(), methodName));
    
        if (retrievedRelationship.isPresent()) {
            Relationship relationship = retrievedRelationship.get();
            if (relationship.getSecondEntityGUID().equals(secondGUID)) {
                return retrievedRelationship;
            }
        }
    
        return Optional.empty();        
 }"," protected Optional<Relationship> findRelationship(String userId, String firstGUID, String secondGUID, String firstEntityTypeName, String relationshipTypeName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        final String methodName = ""findRelationship"";
    
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateGUID(firstGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateGUID(secondGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    
        TypeDef firstEntityTypeDef = repositoryHelper.getTypeDefByName(userId, firstEntityTypeName);
        TypeDef relationshipTypeDef = repositoryHelper.getTypeDefByName(userId, relationshipTypeName);
    
        InstanceProperties properties = repositoryHelper.addStringPropertyToInstance(serviceName, null, CommonMapper.GUID_PROPERTY_NAME,
                firstGUID, methodName);
    
        Optional<Relationship> relationship = Optional.ofNullable(repositoryHandler.getRelationshipBySourceAndDestination(userId,
                firstEntityTypeDef.getGUID(), firstGUID, CommonMapper.GUID_PROPERTY_NAME, relationshipTypeDef.getGUID(),
                relationshipTypeName, properties, methodName));
    
        if (relationship.isPresent()) {
            return relationship;
        }
    
        properties = repositoryHelper.addStringPropertyToInstance(serviceName, null, CommonMapper.GUID_PROPERTY_NAME,
                secondGUID, methodName);
    
        relationship = Optional.ofNullable(repositoryHandler.getRelationshipBySourceAndDestination(userId,
                secondEntityTypeDef.getGUID(), secondGUID, CommonMapper.GUID_PROPERTY_NAME, relationshipTypeDef.getGUID(),
                relationshipTypeName, properties, methodName));
    
        return relationship;        
 }"," protected Optional<Relationship> findRelationship(String userId, String firstGUID, String secondGUID, String firstEntityTypeName, String relationshipTypeName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        final String methodName = ""findRelationship"";
    
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateGUID(firstGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateGUID(secondGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    
        String firstEntityTypeGUID = repositoryHelper.getTypeDefByName(userId, firstEntityTypeName).getGUID();
        String relationshipTypeGUID = repositoryHelper.getTypeDefByName(userId, relationshipTypeName).getGUID();
    
        return Optional.ofNullable(repositoryHandler.getRelationshipByGUIDs(userId, firstGUID, secondGUID, firstEntityTypeGUID, relationshipTypeGUID, methodName));     
 }"," protected Optional<Relationship> findRelationship(String userId, String firstGUID, String secondGUID, String firstEntityTypeName, String relationshipTypeName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        final String methodName = ""findRelationship"";
    
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateGUID(firstGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateGUID(secondGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    
        String firstEntityTypeGUID = repositoryHelper.getTypeDefByName(userId, firstEntityTypeName).getGUID();
        String relationshipTypeGUID = repositoryHelper.getTypeDefByName(userId, relationshipTypeName).getGUID();
    
        return Optional.ofNullable(repositoryHandler.getRelationshipByGUIDs(userId, firstGUID, secondGUID, firstEntityTypeGUID, relationshipTypeGUID, methodName));     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6334631450337356,  0.6401319080206523,  0.5313241850815695,  0.5313241850815695,70.0,0.38461538461538464,110.0,0.47619047619047616,81.0,0.4550561797752809,81.0,0.4550561797752809,78.0,0.33766233766233766,81.0,0.44505494505494503,81.0,0.44505494505494503,19.0,0.6785714285714286,2.0,0.16666666666666666,9.0,0.6923076923076923
156,mybatis-3,"protected static T invoke(Method method, Object object, Object... parameters) throws IOException, RuntimeException{
    try {
        return (T) method.invoke(object, parameters);
    } catch (IllegalArgumentException | IllegalAccessException e) {
        throw new RuntimeException(e);
    } catch (InvocationTargetException e) {
        if (e.getTargetException() instanceof IOException) {
            throw (IOException) e.getTargetException();
        } else {
            throw new RuntimeException(e);
        }
    }
}",invoke,org/apache/ibatis/io/VFS.java,/src/main/java/org/apache/ibatis/io/VFS.java,"/**
   * Invoke a method on an object and return whatever it returns.
   *
   * @param <T>
   *          the generic type
   * @param method
   *          The method to invoke.
   * @param object
   *          The instance or class (for static methods) on which to invoke the method.
   * @param parameters
   *          The parameters to pass to the method.
   * @return Whatever the method returns.
   * @throws IOException
   *           If I/O errors occur
   * @throws RuntimeException
   *           If anything else goes wrong
   */",148-179,"('invoke', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,12.0,Invoke a method on an object and return whatever it returns.,Allows a method to be invoked on an object and return what it returns.,Return whatever it returns by using a method on an object.,0.612226970540833,  Call a method on an object and return what it returns.," protected static T invoke(Method method, Object object, Object... parameters) throws IOException, RuntimeException{
    try {
      return (T) method.invoke(object, parameters);
    } catch (IllegalAccessException e) {
      throw new IOException(""Illegal access invoking method "" + method.getName() + "" on object "" + object, e);
    } catch (InvocationTargetException e) {
      throw new IOException(""Exception invoking method "" + method.getName() + "" on object "" + object, e.getTargetException());
    }   
 }"," protected static T invoke(Method method, Object object, Object... parameters) throws IOException, RuntimeException{
    try {
      return (T) method.invoke(object, parameters);
    } catch (IllegalAccessException e) {
      throw new IOException(""IllegalAccessException invoking "" + method.getName() + "" on "" + object, e);
    } catch (InvocationTargetException e) {
      throw new IOException(""InvocationTargetException invoking "" + method.getName() + "" on "" + object, e);
    }   
 }"," protected static T invoke(Method method, Object object, Object... parameters) throws IOException, RuntimeException{
    try {
      return (T) method.invoke(object, parameters);
    } catch (IllegalAccessException e) {
      throw new IOException(""IllegalAccessException invoking "" + method, e);
    } catch (InvocationTargetException e) {
      throw new IOException(""InvocationTargetException invoking "" + method, e);
    }   
 }"," protected static T invoke(Method method, Object object, Object... parameters) throws IOException, RuntimeException{
    try {
      return (T) method.invoke(object, parameters);
    } catch (IllegalAccessException e) {
      throw new IOException(""Illegal access exception invoking method "" + method.getName() + "" on object "" + object, e);
    } catch (InvocationTargetException e) {
      throw new IOException(""Invocation target exception invoking method "" + method.getName() + "" on object "" + object, e);
    }   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6023195653581508,  0.6059002357205334,  0.59439779857578,  0.5573865251823988,37.0,0.39361702127659576,36.0,0.3870967741935484,36.0,0.3870967741935484,33.0,0.3548387096774194,8.0,0.0851063829787234,6.0,0.06382978723404255,22.0,0.23404255319148937,5.0,0.3333333333333333,2.0,0.16666666666666666,11.0,0.9166666666666666
157,dcache,"private static List<AuthorisationSupplier> parseScope(String claim) throws InvalidScopeException{
    return Splitter.on(' ').trimResults().splitToList(claim).stream().map(SciTokenPlugin::resolveScope).filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());
}",parseScope,org/dcache/gplazma/scitoken/SciTokenPlugin.java,/modules/gplazma2-scitoken/src/main/java/org/dcache/gplazma/scitoken/SciTokenPlugin.java,"/**
     * Parse the ""scope"" claim and extract all SciToken or WLCG Profile scopes.
     */",184-194,"('parseScope', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,15.0,"Parse the ""scope"" claim and extract all SciToken or WLCG Profile scopes.",Following the analysis of the request 'scope' and extract all SciToken scopes or WLCG Profiles.,"Parse the ""scope"" claim and extract the scope.",0.680151029985872,  Analyze the scope claim and extract all SciToken or WLCG Profile scopes.,"private static List<AuthorisationSupplier> parseScope(String claim) throws InvalidScopeException{
        List<AuthorisationSupplier> scopes = new ArrayList<>();
        for (String scope : Splitter.on(' ').trimResults().split(claim)) {
            if (scope.startsWith(""scitoken:"")) {
                scopes.add(new SciTokenScope(scope.substring(9)));
            } else if (scope.startsWith(""wlcg:"")) {
                scopes.add(new WlcgScope(scope.substring(5)));
            } else {
                throw new InvalidScopeException(scope);
            }
        }
        return scopes;
    }"," private static List<AuthorisationSupplier> parseScope(String claim) throws InvalidScopeException{
        List<AuthorisationSupplier> scopes = new ArrayList<>();
        for (String scope : claim.split("" "")) {
            if (scope.startsWith(""wlcg."")) {
                scopes.add(new WlcgProfile(scope));
            } else if (scope.startsWith(""scitoken."")) {
                scopes.add(new SciTokenScope(scope));
            } else {
                throw new InvalidScopeException(scope);
            }
        }
        return scopes;
    }"," private static List<AuthorisationSupplier> parseScope(String claim) throws InvalidScopeException{
        List<AuthorisationSupplier> scopes = new ArrayList<>();
        for (String scope : Splitter.on(' ').trimResults().split(claim)) {
            if (scope.startsWith(""wlcg:"")) {
                scopes.add(new WlcgScope(scope));
            } else {
                throw new InvalidScopeException(scope);
            }
        }
        return scopes;
    }"," private static List<AuthorisationSupplier> parseScope(String claim) throws InvalidScopeException{
        List<AuthorisationSupplier> scopes = new ArrayList<>();
        for (String scope : claim.split("" "")) {
            if (scope.startsWith(""wlcg."")) {
                scopes.add(new WlcgScope(scope));
            } else if (scope.startsWith(""scitoken."")) {
                scopes.add(new SciTokenScope(scope));
            } else {
                throw new InvalidScopeException(scope);
            }
        }
        return scopes;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5155069637052601,  0.425980408312195,  0.425980408312195,  0.5361794677500471,73.0,0.6083333333333333,66.0,0.6534653465346535,66.0,0.6534653465346535,50.0,0.5747126436781609,25.0,0.20833333333333334,25.0,0.20833333333333334,33.0,0.275,9.0,0.5625,2.0,0.15384615384615385,6.0,0.46153846153846156
158,openapi-generator,"private void flattenComposedChildren(OpenAPI openAPI, String key, List<Schema> children){
    if (children == null || children.isEmpty()) {
        return;
    }
    ListIterator<Schema> listIterator = children.listIterator();
    while (listIterator.hasNext()) {
        Schema component = listIterator.next();
        if ((component != null) && (component.get$ref() == null) && ((component.getProperties() != null && !component.getProperties().isEmpty()) || (component.getEnum() != null && !component.getEnum().isEmpty()))) {
            String innerModelName = resolveModelName(component.getTitle(), key);
            Schema innerModel = modelFromProperty(openAPI, component, innerModelName);
            String existing = matchGenerated(innerModel);
            if (existing == null) {
                openAPI.getComponents().addSchemas(innerModelName, innerModel);
                addGenerated(innerModelName, innerModel);
                Schema schema = new Schema().$ref(innerModelName);
                schema.setRequired(component.getRequired());
                listIterator.set(schema);
            } else {
                Schema schema = new Schema().$ref(existing);
                schema.setRequired(component.getRequired());
                listIterator.set(schema);
            }
        }
    }
}",flattenComposedChildren,org/openapitools/codegen/InlineModelResolver.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/InlineModelResolver.java,"/**
     * Flattens properties of inline object schemas that belong to a composed schema into a
     * single flat list of properties. This is useful to generate a single or multiple
     * inheritance model.
     *
     * In the example below, codegen may generate a 'Dog' class that extends from the
     * generated 'Animal' class. 'Dog' has additional properties 'name', 'age' and 'breed' that
     * are flattened as a single list of properties.
     *
     * Dog:
     *   allOf:
     *     - $ref: '#/components/schemas/Animal'
     *     - type: object
     *       properties:
     *         name:
     *           type: string
     *         age:
     *           type: string
     *     - type: object
     *       properties:
     *         breed:
     *           type: string
     *
     * @param openAPI the OpenAPI document
     * @param key a unique name ofr the composed schema.
     * @param children the list of nested schemas within a composed schema (allOf, anyOf, oneOf).
     */",348-412,"('flattenComposedChildren', {'INSTRUCTION': {'covered': 88, 'missed': 4}, 'BRANCH': {'covered': 14, 'missed': 6}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",256.0,20.0,Flattens properties of inline object schemas that belong to a composed schema into a  single flat list of properties.,The properties of inline object schemas that belong to a compound schema in a single flat list of properties are flattened. This allows the generation of an inheritance pattern,Flatten the properties of inline object schemas into a single list.,0.264267354911332,  Flattens the properties of inline object schemas that belong to a schema composed into a single flat list of properties.,"private void flattenComposedChildren(OpenAPI openAPI, String key, List<Schema> children){
        for (Schema child : children) {
            if (child instanceof ObjectSchema) {
                ObjectSchema op = (ObjectSchema) child;
                if (op.getProperties() != null && op.getProperties().size() > 0) {
                    flattenProperties(openAPI, op.getProperties(), key);
                }
            }
        }
    }","private void flattenComposedChildren(OpenAPI openAPI, String key, List<Schema> children){
        for (Schema child : children) {
            if (child instanceof ObjectSchema) {
                ObjectSchema op = (ObjectSchema) child;
                if (op.getProperties() != null && op.getProperties().size() > 0) {
                    flattenProperties(openAPI, op.getProperties(), key);
                }
            } else if (child instanceof ArraySchema) {
                ArraySchema ap = (ArraySchema) child;
                Schema inner = ap.getItems();
                if (inner instanceof ObjectSchema) {
                    ObjectSchema op = (ObjectSchema) inner;
                    if (op.getProperties() != null && op.getProperties().size() > 0) {
                        flattenProperties(openAPI, op.getProperties(), key);
                    }
                }
            } else if (child instanceof MapSchema) {
                MapSchema mp = (MapSchema) child;
                Schema innerProperty = ModelUtils.getAdditionalProperties(openAPI, mp);
                if (innerProperty instanceof ObjectSchema) {
                    ObjectSchema op = (ObjectSchema) innerProperty;
                    if (op.getProperties() != null && op.getProperties().size() > 0) {
                        flattenProperties(openAPI, op.getProperties(), key);
                    }
                }
            }
        }
    }","private void flattenComposedChildren(OpenAPI openAPI, String key, List<Schema> children){
        for (Schema child : children) {
            if (child instanceof ObjectSchema) {
                ObjectSchema op = (ObjectSchema) child;
                if (op.getProperties() != null && op.getProperties().size() > 0) {
                    flattenProperties(openAPI, op.getProperties(), key);
                }
            } else if (child instanceof ArraySchema) {
                ArraySchema ap = (ArraySchema) child;
                Schema inner = ap.getItems();
                if (inner instanceof ObjectSchema) {
                    ObjectSchema op = (ObjectSchema) inner;
                    if (op.getProperties() != null && op.getProperties().size() > 0) {
                        flattenProperties(openAPI, op.getProperties(), key);
                    }
                }
            } else if (child instanceof MapSchema) {
                MapSchema mp = (MapSchema) child;
                Schema innerProperty = ModelUtils.getAdditionalProperties(openAPI, mp);
                if (innerProperty instanceof ObjectSchema) {
                    ObjectSchema op = (ObjectSchema) innerProperty;
                    if (op.getProperties() != null && op.getProperties().size() > 0) {
                        flattenProperties(openAPI, op.getProperties(), key);
                    }
                }
            }
        }
    }","private void flattenComposedChildren(OpenAPI openAPI, String key, List<Schema> children){
        for (Schema child : children) {
            if (child instanceof ObjectSchema) {
                ObjectSchema op = (ObjectSchema) child;
                if (op.getProperties() != null && op.getProperties().size() > 0) {
                    flattenProperties(openAPI, op.getProperties(), key);
                }
            } else if (child instanceof ArraySchema) {
                ArraySchema ap = (ArraySchema) child;
                Schema inner = ap.getItems();
                if (inner instanceof ObjectSchema) {
                    ObjectSchema op = (ObjectSchema) inner;
                    if (op.getProperties() != null && op.getProperties().size() > 0) {
                        flattenProperties(openAPI, op.getProperties(), key);
                    }
                }
            } else if (child instanceof MapSchema) {
                MapSchema mp = (MapSchema) child;
                Schema innerProperty = ModelUtils.getAdditionalProperties(openAPI, mp);
                if (innerProperty instanceof ObjectSchema) {
                    ObjectSchema op = (ObjectSchema) innerProperty;
                    if (op.getProperties() != null && op.getProperties().size() > 0) {
                        flattenProperties(openAPI, op.getProperties(), key);
                    }
                }
            }
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.18646997295934725,  0.3095915903581362,  0.3095915903581362,  0.3095915903581362,199.0,0.77431906614786,178.0,0.6926070038910506,178.0,0.6926070038910506,178.0,0.6926070038910506,161.0,0.6652892561983471,161.0,0.6652892561983471,161.0,0.6652892561983471,14.0,0.4666666666666667,3.0,0.14285714285714285,12.0,0.6
159,cdk,"public static Order resource2Order(Resource rdfOrder){
    if (rdfOrder.equals(CDK.SINGLEBOND)) {
        return Order.SINGLE;
    } else if (rdfOrder.equals(CDK.DOUBLEBOND)) {
        return Order.DOUBLE;
    } else if (rdfOrder.equals(CDK.TRIPLEBOND)) {
        return Order.TRIPLE;
    } else if (rdfOrder.equals(CDK.QUADRUPLEBOND)) {
        return Order.QUADRUPLE;
    }
    return null;
}",resource2Order,org/openscience/cdk/libio/jena/Convertor.java,/storage/iordf/src/main/java/org/openscience/cdk/libio/jena/Convertor.java,"/**
     * Converts a {@link Resource} object into the matching {@link Order}.
     *
     * @param rdfOrder Resource for which the matching {@link Order} should be given.
     * @return the matching {@link Order}.
     */",253-270,"('resource2Order', {'INSTRUCTION': {'covered': 24, 'missed': 2}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,17.0,Converts a {@link Resource} object into the matching {@link Order}.,{@link Order} refers to the conversion of the corresponding {@link Resource} object.,The @link Resource object is converted into the matching @link Order.,0.808927411981844,  Converts an object to {@link Resource} to the corresponding {@link Order}.,"public static Order resource2Order(Resource rdfOrder){
        if (rdfOrder.equals(CDK.ORDER_ONE)) return Order.ONE;
        if (rdfOrder.equals(CDK.ORDER_TWO)) return Order.TWO;
        if (rdfOrder.equals(CDK.ORDER_THREE)) return Order.THREE;
        if (rdfOrder.equals(CDK.ORDER_FOUR)) return Order.FOUR;
        if (rdfOrder.equals(CDK.ORDER_FIVE)) return Order.FIVE;
        if (rdfOrder.equals(CDK.ORDER_SIX)) return Order.SIX;
        if (rdfOrder.equals(CDK.ORDER_SEVEN)) return Order.SEVEN;
        if (rdfOrder.equals(CDK.ORDER_EIGHT)) return Order.EIGHT;
        if (rdfOrder.equals(CDK.ORDER_NINE)) return Order.NINE;
        if (rdfOrder.equals(CDK.ORDER_TEN)) return Order.TEN;
        if (rdfOrder.equals(CDK.ORDER_ELEVEN)) return Order.ELEVEN;
        if (rdfOrder.equals(CDK.ORDER_TWELVE)) return Order.TWELVE;
        if (rdfOrder.equals(CDK.ORDER_THIRTEEN)) return Order.THIRTEEN;
        if (rdfOrder.equals(CDK.ORDER_FOURTEEN)) return Order.FOURTEEN;
        if (rdfOrder.equals(CDK.ORDER_FIFTEEN)) return Order.FIFTEEN;
        if (rdfOrder.equals(CDK.ORDER_SIXTEEN)) return Order.SIXTEEN;
        if (rdfOrder.equals(CDK.ORDER_SEVENTEEN)) return Order.SEVENTEEN;
        if (rdfOrder.equals(CDK.ORDER_EIGHTEEN)) return Order.EIGHTEEN;
        if (        
 }","public static Order resource2Order(Resource rdfOrder){
        if (rdfOrder.equals(CDK.ORDER_ONE)) return Order.ONE;
        if (rdfOrder.equals(CDK.ORDER_TWO)) return Order.TWO;
        if (rdfOrder.equals(CDK.ORDER_THREE)) return Order.THREE;
        if (rdfOrder.equals(CDK.ORDER_FOUR)) return Order.FOUR;
        if (rdfOrder.equals(CDK.ORDER_FIVE)) return Order.FIVE;
        if (rdfOrder.equals(CDK.ORDER_SIX)) return Order.SIX;
        if (rdfOrder.equals(CDK.ORDER_SEVEN)) return Order.SEVEN;
        if (rdfOrder.equals(CDK.ORDER_EIGHT)) return Order.EIGHT;
        if (rdfOrder.equals(CDK.ORDER_NINE)) return Order.NINE;
        if (rdfOrder.equals(CDK.ORDER_TEN)) return Order.TEN;
        if (rdfOrder.equals(CDK.ORDER_ELEVEN)) return Order.ELEVEN;
        if (rdfOrder.equals(CDK.ORDER_TWELVE)) return Order.TWELVE;
        if (rdfOrder.equals(CDK.ORDER_THIRTEEN)) return Order.THIRTEEN;
        if (rdfOrder.equals(CDK.ORDER_FOURTEEN)) return Order.FOURTEEN;
        if (rdfOrder.equals(CDK.ORDER_FIFTEEN)) return Order.FIFTEEN;
        if (rdfOrder.equals(CDK.ORDER_SIXTEEN)) return Order.SIXTEEN;
        if (rdfOrder.equals(CDK.ORDER_SEVENTEEN)) return Order.SEVENTEEN;
        if (rdfOrder.equals(CDK.ORDER_EIGHTEEN)) return Order.EIGHTEEN;
        if (        
 }","public static Order resource2Order(Resource rdfOrder){
        if (rdfOrder.equals(CDK.ORDER_ONE)) return Order.ONE;
        if (rdfOrder.equals(CDK.ORDER_TWO)) return Order.TWO;
        if (rdfOrder.equals(CDK.ORDER_THREE)) return Order.THREE;
        if (rdfOrder.equals(CDK.ORDER_FOUR)) return Order.FOUR;
        if (rdfOrder.equals(CDK.ORDER_FIVE)) return Order.FIVE;
        if (rdfOrder.equals(CDK.ORDER_SIX)) return Order.SIX;
        if (rdfOrder.equals(CDK.ORDER_SEVEN)) return Order.SEVEN;
        if (rdfOrder.equals(CDK.ORDER_EIGHT)) return Order.EIGHT;
        if (rdfOrder.equals(CDK.ORDER_NINE)) return Order.NINE;
        if (rdfOrder.equals(CDK.ORDER_TEN)) return Order.TEN;
        if (rdfOrder.equals(CDK.ORDER_ELEVEN)) return Order.ELEVEN;
        if (rdfOrder.equals(CDK.ORDER_TWELVE)) return Order.TWELVE;
        if (rdfOrder.equals(CDK.ORDER_THIRTEEN)) return Order.THIRTEEN;
        if (rdfOrder.equals(CDK.ORDER_FOURTEEN)) return Order.FOURTEEN;
        if (rdfOrder.equals(CDK.ORDER_FIFTEEN)) return Order.FIFTEEN;
        if (rdfOrder.equals(CDK.ORDER_SIXTEEN)) return Order.SIXTEEN;
        if (rdfOrder.equals(CDK.ORDER_SEVENTEEN)) return Order.SEVENTEEN;
        if (rdfOrder.equals(CDK.ORDER_EIGHTEEN)) return Order.EIGHTEEN;
        if (        
 }","public static Order resource2Order(Resource rdfOrder){
        if (rdfOrder.equals(CDK.ORDER_ONE)) return Order.ONE;
        if (rdfOrder.equals(CDK.ORDER_TWO)) return Order.TWO;
        if (rdfOrder.equals(CDK.ORDER_THREE)) return Order.THREE;
        if (rdfOrder.equals(CDK.ORDER_FOUR)) return Order.FOUR;
        if (rdfOrder.equals(CDK.ORDER_FIVE)) return Order.FIVE;
        if (rdfOrder.equals(CDK.ORDER_SIX)) return Order.SIX;
        if (rdfOrder.equals(CDK.ORDER_SEVEN)) return Order.SEVEN;
        if (rdfOrder.equals(CDK.ORDER_EIGHT)) return Order.EIGHT;
        if (rdfOrder.equals(CDK.ORDER_NINE)) return Order.NINE;
        if (rdfOrder.equals(CDK.ORDER_TEN)) return Order.TEN;
        if (rdfOrder.equals(CDK.ORDER_ELEVEN)) return Order.ELEVEN;
        if (rdfOrder.equals(CDK.ORDER_TWELVE)) return Order.TWELVE;
        if (rdfOrder.equals(CDK.ORDER_THIRTEEN)) return Order.THIRTEEN;
        if (rdfOrder.equals(CDK.ORDER_FOURTEEN)) return Order.FOURTEEN;
        if (rdfOrder.equals(CDK.ORDER_FIFTEEN)) return Order.FIFTEEN;
        if (rdfOrder.equals(CDK.ORDER_SIXTEEN)) return Order.SIXTEEN;
        if (rdfOrder.equals(CDK.ORDER_SEVENTEEN)) return Order.SEVENTEEN;
        if (rdfOrder.equals(CDK.ORDER_EIGHTEEN)) return Order.EIGHTEEN;
        if (        
 }",Syntax Error,Syntax Error,Syntax Error,Syntax Error,None,None,None,None,None,None,None,None,232.0,0.770764119601329,232.0,0.770764119601329,None,None,0.0,0.0,0.0,0.0,10.0,0.7692307692307693,6.0,0.5,8.0,0.6666666666666666
160,dcache,"private static Set<String> toAttributes(String format){
    Set<String> attributes = new HashSet<>();
    Matcher matcher = ATTRIBUTE_PATTERN.matcher(format);
    while (matcher.find()) {
        String expression = matcher.group(1);
        if (!isIf(expression) && !isElse(expression) && !isEndIf(expression)) {
            int pos = expression.indexOf(';');
            attributes.add(pos > -1 ? expression.substring(0, pos) : expression);
        }
    }
    return attributes;
}",toAttributes,org/dcache/services/billing/text/BillingParserBuilder.java,/modules/dcache/src/main/java/org/dcache/services/billing/text/BillingParserBuilder.java,"/**
     * Returns names of all attributes in the provided billing format.
     */",263-277,"('toAttributes', {'INSTRUCTION': {'covered': 38, 'missed': 5}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",112.0,11.0,Returns names of all attributes in the provided billing format.,The names of all attributes are returned in the provided billing format,The names of all attributes are returned.,0.168007070870768,  Returns the names of all attributes in the billing format provided.,"private static Set<String> toAttributes(String format){
        Set<String> attributes = new HashSet<>();
        Matcher matcher = ATTRIBUTE_PATTERN.matcher(format);
        while (matcher.find()) {
            attributes.add(matcher.group(1));
        }
        return attributes;
    }","private static Set<String> toAttributes(String format){
        Set<String> attributes = new HashSet<>();
        Matcher matcher = ATTRIBUTE_PATTERN.matcher(format);
        while (matcher.find()) {
            attributes.add(matcher.group(1));
        }
        return attributes;
    }","private static Set<String> toAttributes(String format){
        Set<String> attributes = new HashSet<>();
        Matcher matcher = ATTRIBUTE_PATTERN.matcher(format);
        while (matcher.find()) {
            attributes.add(matcher.group(1));
        }
        return attributes;
    }","private static Set<String> toAttributes(String format){
        Set<String> attributes = new HashSet<>();
        Matcher matcher = ATTRIBUTE_PATTERN.matcher(format);
        while (matcher.find()) {
            attributes.add(matcher.group(1));
        }
        return attributes;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4510472256201891,  0.4510472256201891,  0.4510472256201891,  0.4510472256201891,54.0,0.4778761061946903,54.0,0.4778761061946903,54.0,0.4778761061946903,54.0,0.4778761061946903,0.0,0.0,0.0,0.0,0.0,0.0,4.0,0.3076923076923077,4.0,0.3333333333333333,6.0,0.5454545454545454
161,egeria,"protected void upsertExternalRelationship(String userId, String firstGUID, String secondGUID, String relationshipTypeName, String firstEntityTypeName, String externalSourceName, InstanceProperties relationshipProperties) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    final String methodName = ""upsertExternalRelationship"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateGUID(firstGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    invalidParameterHandler.validateGUID(secondGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    String externalSourceGUID = dataEngineRegistrationHandler.getExternalDataEngine(userId, externalSourceName);
    Optional<Relationship> relationship = findRelationship(userId, firstGUID, secondGUID, firstEntityTypeName, relationshipTypeName);
    if (relationship.isEmpty()) {
        TypeDef relationshipTypeDef = repositoryHelper.getTypeDefByName(userId, relationshipTypeName);
        repositoryHandler.createExternalRelationship(userId, relationshipTypeDef.getGUID(), externalSourceGUID, externalSourceName, firstGUID, secondGUID, relationshipProperties, methodName);
    } else {
        Relationship originalRelationship = relationship.get();
        RelationshipDifferences relationshipDifferences = repositoryHelper.getRelationshipDifferences(originalRelationship, buildRelationship(originalRelationship.getGUID(), relationshipProperties), true);
        if (relationshipDifferences.hasInstancePropertiesDifferences()) {
            repositoryHandler.updateRelationshipProperties(userId, externalSourceGUID, externalSourceName, originalRelationship.getGUID(), relationshipProperties, methodName);
        }
    }
}",upsertExternalRelationship,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCommonHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCommonHandler.java,"/**
     * Create or updates an external relationship between two entities. Verifies that the relationship is not present before creating it. If the
     * relationship is present, verifies the instanceProperties for the relationship to be updated.
     *
     * @param userId                 the name of the calling user
     * @param firstGUID              the unique identifier of the entity at first end
     * @param secondGUID             the unique identifier of the entity at second end
     * @param relationshipTypeName   type name for the relationship to create
     * @param firstEntityTypeName    type name for the entity at first end
     * @param externalSourceName     the unique name of the external source
     * @param relationshipProperties the properties for the relationship
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",221-267,"('upsertExternalRelationship', {'INSTRUCTION': {'covered': 84, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",218.0,10.0,Create or updates an external relationship between two entities.,"Updates or creates an external relation between two entities. Check before creating the relationship that it is not present. If the relationship is present, the instanceProperties of the relationship to be updated must be checked.",An external relationship between two entities can be created or updated.,0.257820566478949,  Create or update an external relationship between two entities.," protected void upsertExternalRelationship(String userId, String firstGUID, String secondGUID, String relationshipTypeName, String firstEntityTypeName, String externalSourceName, InstanceProperties relationshipProperties) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        final String methodName = ""upsertExternalRelationship"";
    
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateGUID(firstGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateGUID(secondGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateName(relationshipTypeName, CommonMapper.TYPE_NAME_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateName(firstEntityTypeName, CommonMapper.TYPE_NAME_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateName(externalSourceName, CommonMapper.EXTERNAL_SOURCE_NAME_PROPERTY_NAME, methodName);
    
        String externalSourceGUID = dataEngineRegistrationHandler.getExternalDataEngine(userId, externalSourceName);
    
        repositoryHandler.upsertExternalRelationship(userId, externalSourceGUID, externalSourceName, firstGUID, firstEntityTypeName, secondGUID,
                relationshipTypeName, relationshipProperties, methodName);      
 }"," protected void upsertExternalRelationship(String userId, String firstGUID, String secondGUID, String relationshipTypeName, String firstEntityTypeName, String externalSourceName, InstanceProperties relationshipProperties) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        final String methodName = ""upsertExternalRelationship"";
    
        TypeDef relationshipTypeDef = repositoryHelper.getTypeDefByName(userId, relationshipTypeName);
    
        String externalSourceGUID = dataEngineRegistrationHandler.getExternalDataEngine(userId, externalSourceName);
    
        repositoryHandler.upsertExternalRelationship(userId, externalSourceGUID, externalSourceName, firstGUID, firstEntityTypeName, secondGUID, relationshipTypeDef.getGUID(), relationshipTypeName, relationshipProperties, methodName);      
 }"," protected void upsertExternalRelationship(String userId, String firstGUID, String secondGUID, String relationshipTypeName, String firstEntityTypeName, String externalSourceName, InstanceProperties relationshipProperties) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        final String methodName = ""upsertExternalRelationship"";
    
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateGUID(firstGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateGUID(secondGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateName(relationshipTypeName, CommonMapper.TYPE_NAME_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateName(firstEntityTypeName, CommonMapper.TYPE_NAME_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateName(externalSourceName, CommonMapper.EXTERNAL_SOURCE_NAME_PROPERTY_NAME, methodName);
    
        String externalSourceGUID = dataEngineRegistrationHandler.getExternalDataEngine(userId, externalSourceName);
    
        repositoryHandler.upsertExternalRelationship(userId, externalSourceGUID, externalSourceName, firstGUID, firstEntityTypeName, secondGUID,
                relationshipTypeName, relationshipProperties, methodName);      
 }"," protected void upsertExternalRelationship(String userId, String firstGUID, String secondGUID, String relationshipTypeName, String firstEntityTypeName, String externalSourceName, InstanceProperties relationshipProperties) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        final String methodName = ""upsertExternalRelationship"";
    
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateGUID(firstGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateGUID(secondGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateName(relationshipTypeName, CommonMapper.TYPE_NAME_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateName(firstEntityTypeName, CommonMapper.TYPE_NAME_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateName(externalSourceName, CommonMapper.EXTERNAL_SOURCE_NAME_PROPERTY_NAME, methodName);
    
        String externalSourceGUID = dataEngineRegistrationHandler.getExternalDataEngine(userId, externalSourceName);
    
        repositoryHandler.upsertExternalRelationship(userId, firstGUID, secondGUID, relationshipTypeName, firstEntityTypeName, externalSourceGUID, externalSourceName, relationshipProperties, methodName);     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.47721756642925695,  0.36594333959045866,  0.47721756642925695,  0.47721756642925695,105.0,0.4794520547945205,138.0,0.6301369863013698,106.0,0.4840182648401826,105.0,0.4794520547945205,74.0,0.4966442953020134,5.0,0.03355704697986577,0.0,0.0,29.0,0.8055555555555556,1.0,0.1,10.0,0.8333333333333334
162,cdk,"private int[] priority(int focus, IAtom[] atoms, int n){
    int[] rank = new int[n];
    for (int i = 0; i < n; i++) rank[i] = i;
    for (int j = 1; j < n; j++) {
        int v = rank[j];
        int i = j - 1;
        while ((i >= 0) && hasPriority(focus, atomToIndex.get(atoms[v]), atomToIndex.get(atoms[rank[i]]))) {
            rank[i + 1] = rank[i--];
        }
        rank[i + 1] = v;
    }
    return rank;
}",priority,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,"/**
     * Obtain a prioritised array where the indices 0 to n which correspond to
     * the provided {@code atoms}.
     *
     * @param focus focus of the tetrahedral atom
     * @param atoms the atom
     * @param n     number of atoms
     * @return prioritised indices
     */",1009-1031,"('priority', {'INSTRUCTION': {'covered': 71, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",145.0,21.0,Obtain a prioritised array where the indices 0 to n which correspond to  the provided {@code atoms}.,Get a priority array in which the indices from 0 to n corresponding to the {@code} atoms provided,The provided code atoms correspond to the indices 0 to n.,0.34847583143654,Obtain a hierarchical array where the indices 0 to n that correspond to the {@code atoms} provided.,"private int[] priority(int focus, IAtom[] atoms, int n){
        int[] priority = new int[n];
        for (int i = 0; i < n; i++) {
            priority[i] = i;
        }
        return priority;
    }","private int[] priority(int focus, IAtom[] atoms, int n){
        int[] priority = new int[n];
        for (int i = 0; i < n; i++) {
            priority[i] = i;
        }
        return priority;
    }","private int[] priority(int focus, IAtom[] atoms, int n){
        int[] priority = new int[n];
        for (int i = 0; i < n; i++) {
            priority[i] = i;
        }
        // sort clockwise
        int[] rank = new int[n];
        for (int i = 0; i < n; i++) {
            rank[i] = i;
        }
        sortClockwise(rank, focus, atoms, n);
        // sort by number of adjacent centres
        for (int i = 0; i < n; i++) {
            int v = rank[i];
            int nadjacent = nAdjacentCentres(v);
            for (int j = i + 1; j < n; j++) {
                int w = rank[j];
                if (nAdjacentCentres(w) > nadjacent) {
                    nadjacent = nAdjacentCentres(w);
                    v = w;
                }
            }
            priority[i] = v;
        }
        return priority;
    }","private int[] priority(int focus, IAtom[] atoms, int n){
        int[] priority = new int[n];
        for (int i = 0; i < n; i++) {
            priority[i] = i;
        }
        return priority;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.308885924532958,  0.308885924532958,  0.308885924532958,  0.5958998830250031,92.0,0.6301369863013698,92.0,0.6301369863013698,92.0,0.6301369863013698,105.0,0.5555555555555556,0.0,0.0,0.0,0.0,132.0,0.6984126984126984,10.0,0.5263157894736842,5.0,0.2777777777777778,14.0,0.7777777777777778
163,cdk,"private IsotopePattern calculateAbundanceAndMass(IsotopePattern current, List<IsotopeContainer> additional){
    if (additional == null || additional.size() == 0)
        return current;
    List<IsotopeContainer> containers = new ArrayList<>();
    if (current == null) {
        current = new IsotopePattern();
        for (IsotopeContainer container : additional) current.addIsotope(container);
    } else {
        for (IsotopeContainer container : current.getIsotopes()) {
            for (IsotopeContainer other : additional) {
                double abundance = container.getIntensity() * other.getIntensity() * 0.01;
                double mass = container.getMass() + other.getMass();
                IsotopeContainer existing = findExisting(containers, mass, resolution);
                if (existing != null) {
                    double newIntensity = existing.getIntensity() + abundance;
                    existing.setMass((existing.getMass() * existing.getIntensity() + mass * abundance) / newIntensity);
                    existing.setIntensity(newIntensity);
                    if (storeFormula) {
                        for (IMolecularFormula mf : container.getFormulas()) addDistinctFormula(existing, union(mf, other.getFormula()));
                    }
                    continue;
                }
                if (abundance > minAbundance) {
                    IsotopeContainer newcontainer = new IsotopeContainer(mass, abundance);
                    if (storeFormula) {
                        for (IMolecularFormula mf : container.getFormulas()) newcontainer.addFormula(union(mf, other.getFormula()));
                    }
                    containers.add(newcontainer);
                }
            }
        }
        current = new IsotopePattern();
        for (IsotopeContainer container : containers) {
            current.addIsotope(container);
        }
    }
    return current;
}",calculateAbundanceAndMass,org/openscience/cdk/formula/IsotopePatternGenerator.java,/tool/formula/src/main/java/org/openscience/cdk/formula/IsotopePatternGenerator.java,"/**
     * Calculates the mass and abundance of all isotopes generated by adding one
     * atom. Receives the periodic table element and calculate the isotopes, if
     * there exist a previous calculation, add these new isotopes. In the
     * process of adding the new isotopes, remove those that has an abundance
     * less than setup parameter minIntensity, and remove duplicated masses.
     *
     * @param additional additional isotopes to 'multiple' the current pattern by
     * @return the calculation was successful
     */",190-252,"('calculateAbundanceAndMass', {'INSTRUCTION': {'covered': 177, 'missed': 2}, 'BRANCH': {'covered': 24, 'missed': 2}, 'LINE': {'covered': 31, 'missed': 0}, 'COMPLEXITY': {'covered': 12, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",314.0,14.0,Calculates the mass and abundance of all isotopes generated by adding one  atom.,"Calculate the mass and abundance of all isotopes obtained by adding an atom. It receives the element from the periodic table and calculates the isotopes; if a previous calculation exists, the new isotopes are added. In the process of adding new isotopes, those with an abundance below the minIntensity parameter are removed. It also removes duplicate masses.",Add one atom to the generated isotopes and calculate their mass and abundance.,0.375819125797711,  Calculates the mass and abundance of all isotopes generated by the addition of an atom.," private IsotopePattern calculateAbundanceAndMass(IsotopePattern current, List<IsotopeContainer> additional){
     
      IsotopePattern abundance_Mass = new IsotopePattern();
     
      for (IsotopeContainer container : current) {
            for (IsotopeContainer add : additional) {
                 IsotopeContainer newContainer = new IsotopeContainer(container.getMass() + add.getMass(), container.getAbundance() * add.getAbundance());
                 if (storeFormula)
                  addDistinctFormula(newContainer, union(container.getFormula(), add.getFormula()));
                 abundance_Mass.add(newContainer);
            }
      }
     
      return abundance_Mass;
     }"," private IsotopePattern calculateAbundanceAndMass(IsotopePattern current, List<IsotopeContainer> additional){
            IsotopePattern abundance_Mass = new IsotopePattern();
            if (current == null)
                return abundance_Mass;
    
            for (IsotopeContainer container : current) {
                for (IsotopeContainer add : additional) {
                    double mass = container.getMass() + add.getMass();
                    double abundance = container.getAbundance() * add.getAbundance();
                    if (abundance < minAbundance)
                        continue;
                    IsotopeContainer newContainer = new IsotopeContainer(mass, abundance);
                    if (storeFormula)
                        addDistinctFormula(newContainer, union(container.getFormula(), add.getFormula()));
                    abundance_Mass.add(newContainer);
                }
            }
            return abundance_Mass;
        }"," private IsotopePattern calculateAbundanceAndMass(IsotopePattern current, List<IsotopeContainer> additional){
     
      IsotopePattern abundance_Mass = new IsotopePattern();
     
      if (current == null) {
            for (IsotopeContainer container : additional) {
                 abundance_Mass.add(container);
            }
            return abundance_Mass;
      }
     
      for (IsotopeContainer container : current) {
            for (IsotopeContainer add : additional) {
                 IsotopeContainer newContainer = new IsotopeContainer(container.getMass() + add.getMass(),
                                                                    container.getAbundance() * add.getAbundance());
                 if (storeFormula)
                  addDistinctFormula(newContainer, union(container.getFormula(), add.getFormula()));
                 abundance_Mass.add(newContainer);
            }
      }
     
      return abundance_Mass;            
 }"," private IsotopePattern calculateAbundanceAndMass(IsotopePattern current, List<IsotopeContainer> additional){
     
      IsotopePattern abundance_Mass = new IsotopePattern();
     
      if (current == null) {
            for (IsotopeContainer container : additional) {
                 abundance_Mass.add(container);
            }
            return abundance_Mass;
      }
     
      for (IsotopeContainer container : additional) {
            for (IsotopeContainer currentContainer : current) {
                 double mass = container.getMass() + currentContainer.getMass();
                 double abundance = container.getAbundance() * currentContainer.getAbundance();
                 if (abundance < minAbundance)
                  continue;
                 IsotopeContainer existing = findExisting(abundance_Mass, mass, resolution);
                 if (existing == null) {
                  abundance_Mass.add(new IsotopeContainer(mass, abundance));
                 } else {
                  existing.addAbundance(abundance);
                 }
            }
      }
      return abundance_Mass;            
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.23813615123800974,  0.32892278187949436,  0.3483545382337657,  0.2960427070721684,226.0,0.7174603174603175,208.0,0.6603174603174603,211.0,0.6698412698412698,210.0,0.6666666666666666,36.0,0.26865671641791045,73.0,0.477124183006536,27.0,0.20149253731343283,47.0,0.8103448275862069,4.0,0.25,13.0,0.9285714285714286
164,cdk,"public static void percieveAtomTypesAndConfigureAtoms(IAtomContainer container) throws CDKException{
    CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.getInstance(container.getBuilder());
    for (IAtom atom : container.atoms()) {
        if (!(atom instanceof IPseudoAtom)) {
            IAtomType matched = matcher.findMatchingAtomType(container, atom);
            if (matched != null) {
                AtomTypeManipulator.configure(atom, matched);
            }
        }
    }
}",percieveAtomTypesAndConfigureAtoms,org/openscience/cdk/normalize/SMSDNormalizer.java,/legacy/src/main/java/org/openscience/cdk/normalize/SMSDNormalizer.java,"/**
     * Convenience method to perceive atom types for all <code>IAtom</code>s in the
     * <code>IAtomContainer</code>, using the <code>CDKAtomTypeMatcher</code>. If the
     * matcher finds atom matching atom type, the <code>IAtom</code> will be configured
     * to have the same properties as the <code>IAtomType</code>. If no matching atom
     * type is found, no configuration is performed.
     * @param container
     * @throws CDKException
     */",302-323,"('percieveAtomTypesAndConfigureAtoms', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",79.0,36.0,"Convenience method to perceive atom types for all <code>IAtom</code>s in the  <code>IAtomContainer</code>, using the <code>CDKAtomTypeMatcher</code>.","Metodo che consente la percezione dei tipi di atomo per tutti gli <code>IAtom</code>s in the <code>IAtomContainer</code> attraverso l'utilizzo di <code>CDKAtomTypeMatcher</code>. Nel caso in cui il matcher rileva un tipo di atomo corrispondente, le stesse proprieta' del tipo di atomo <code>IAtom</code> saranno configurate su <code>IAtomType</code>. Mentre non viene eseguita alcuna configurazione, nel caso in cui non viene trovato un tipo di atomo corrispondete ",The convenience method to perceive atom types is used.,1.14204701836919,"  A practical method for perceiving atom types for all <code>IAtom</code>s in <code>the IAtomContainer</code>, using the <code>CDKAtomTypeMatcher</code>."," public static void percieveAtomTypesAndConfigureAtoms(IAtomContainer container) throws CDKException{
        CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.getInstance(container.getBuilder());
        for (IAtom atom : container.atoms()) {
            matcher.findAndConfigureAtom(atom);
        }
    }"," public static void percieveAtomTypesAndConfigureAtoms(IAtomContainer container) throws CDKException{
        CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.getInstance(container.getBuilder());
        for (IAtom atom : container.atoms()) {
            IAtomType type = matcher.findMatchingAtomType(container, atom);
            if (type != null) {
                atom.setAtomTypeName(type.getAtomTypeName());
                atom.setHybridization(type.getHybridization());
                atom.setFormalCharge(type.getFormalCharge());
                atom.setMassNumber(type.getMassNumber());
                atom.setValency(type.getValency());
                atom.setRadical(type.getRadical());
                atom.setBondOrderSum(type.getBondOrderSum());
                atom.setMaximumBondOrder(type.getMaximumBondOrder());
                atom.setProperty(CDKConstants.ATOM_ATOM_TYPE, type);
            }
        }
    }"," public static void percieveAtomTypesAndConfigureAtoms(IAtomContainer container) throws CDKException{
        AtomTypePerception perception = new AtomTypePerception(container);
        perception.setup();
        perception.perceive();
    }"," public static void percieveAtomTypesAndConfigureAtoms(IAtomContainer container) throws CDKException{
        CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.getInstance(container.getBuilder());
        for (IAtom atom : container.atoms()) {
            if (atom.getAtomTypeName() == null) {
                IAtomType type = matcher.findMatchingAtomType(container, atom);
                if (type == null) {
                    throw new CDKException(""No matching atom type found for "" + atom);
                }
                atom.setAtomTypeName(type.getAtomTypeName());
            }
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4885524733260189,  0.6706086658349559,  0.6603901810540129,  0.18121728835030235,34.0,0.425,100.0,0.6289308176100629,27.0,0.29347826086956524,54.0,0.675,113.0,0.710691823899371,46.0,0.5,22.0,0.46808510638297873,58.0,0.9206349206349206,6.0,0.35294117647058826,11.0,0.6875
165,cdk,"private static double deltavPhosphorous(IAtom atom, IAtomContainer atomContainer){
    if (atom.getAtomicNumber() != IElement.P)
        return -1;
    List<IAtom> connected = atomContainer.getConnectedAtomsList(atom);
    int conditions = 0;
    if (connected.size() == 4)
        conditions++;
    for (IAtom connectedAtom : connected) {
        if (connectedAtom.getAtomicNumber() == IElement.O && atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.DOUBLE)
            conditions++;
        if (atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.SINGLE)
            conditions++;
    }
    if (conditions == 5)
        return 2.22;
    return -1;
}",deltavPhosphorous,org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,"/**
     * Checks whether the P atom is in a PO environment.
     * 
     * This environment is noted in Kier & Hall (1986), page 20
     *
     * @param atom          The P atom in question
     * @param atomContainer The molecule containing the P atom
     * @return The empirical delta V if present in the above environment,
     *         -1 otherwise
     */",219-244,"('deltavPhosphorous', {'INSTRUCTION': {'covered': 53, 'missed': 4}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 10, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",140.0,11.0,Checks whether the P atom is in a PO environment.,See if the P atom is present in a PO environment.,The P atom is checked to see if it is in a PO environment.,0.260771379956401,  Checks whether the P atom is in a PO environment.,"private static double deltavPhosphorous(IAtom atom, IAtomContainer atomContainer){
        if (atom.getAtomicNumber() != IElement.P) return -1;
    
        int count = 0;
        for (IAtom connectedAtom : atomContainer.getConnectedAtomsList(atom)) {
            if (connectedAtom.getAtomicNumber() == IElement.O
                    && atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.DOUBLE) count++;
        }
        if (count == 1) return 1.33;
        else if (count == 2) return 2.67;
    
        return -1;
    }","private static double deltavPhosphorous(IAtom atom, IAtomContainer atomContainer){
        if (atom.getAtomicNumber() != IElement.P) return -1;
    
        int count = 0;
        for (IAtom connectedAtom : atomContainer.getConnectedAtomsList(atom)) {
            if (connectedAtom.getAtomicNumber() == IElement.O
                    && atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.DOUBLE) count++;
        }
        if (count == 1) return 1.33;
        else if (count == 2) return 2.67;
    
        return -1;
    }","private static double deltavPhosphorous(IAtom atom, IAtomContainer atomContainer){
        if (atom.getAtomicNumber() != IElement.P) return -1;
    
        int count = 0;
        for (IAtom connectedAtom : atomContainer.getConnectedAtomsList(atom)) {
            if (connectedAtom.getAtomicNumber() == IElement.O
                    && atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.DOUBLE) count++;
        }
        if (count == 1) return 1.33;
        else if (count == 2) return 2.67;
    
        return -1;
    }","private static double deltavPhosphorous(IAtom atom, IAtomContainer atomContainer){
        if (atom.getAtomicNumber() != IElement.P) return -1;
    
        int count = 0;
        for (IAtom connectedAtom : atomContainer.getConnectedAtomsList(atom)) {
            if (connectedAtom.getAtomicNumber() == IElement.O
                    && atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.DOUBLE) count++;
        }
        if (count == 1) return 1.33;
        else if (count == 2) return 2.67;
    
        return -1;
    }",PASS,PASS,PASS,PASS,  0.6219977908604151,  0.6219977908604151,  0.6219977908604151,  0.6219977908604151,56.0,0.3971631205673759,56.0,0.3971631205673759,56.0,0.3971631205673759,56.0,0.3971631205673759,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.25,0.0,0.0,9.0,0.6
166,cdk,"public void fireChange(){
    if (getNotification() && listeners != null) {
        EventObject event = new EventObject(this);
        for (int i = 0; i < listeners.size(); i++) {
            listeners.get(i).stateChanged(event);
        }
    }
}",fireChange,org/openscience/cdk/renderer/RendererModel.java,/display/render/src/main/java/org/openscience/cdk/renderer/RendererModel.java,"/**
     * Notifies registered listeners of certain changes that have occurred in
     * this model.
     */",404-415,"('fireChange', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,13.0,Notifies registered listeners of certain changes that have occurred in  this model.,Notifying registered listeners of changes in this model,Changes that have occurred in this model have been notified to registered listeners.,0.221199632925599,  Notifies the saved listeners of certain changes that have occurred in this model.," public void fireChange(){
        if (listeners != null) {
            for (ICDKChangeListener listener : listeners) {
                listener.stateChanged(new ChangeEvent(this));
            }
        }
    }"," public void fireChange(){
        if (listeners != null) {
            for (ICDKChangeListener listener : listeners) {
                listener.stateChanged(new ChangeEvent(this));
            }
        }
    }"," public void fireChange(){
        if (listeners != null) {
            for (ICDKChangeListener listener : listeners) {
                listener.stateChanged(new ChangeEvent(this));
            }
        }
    }"," public void fireChange(){
        if (listeners != null) {
            for (ICDKChangeListener listener : listeners) {
                listener.stateChanged(new ChangeEvent(this));
            }
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.25294093549963614,  0.25294093549963614,  0.25294093549963614,  0.25294093549963614,35.0,0.5737704918032787,35.0,0.5737704918032787,35.0,0.5737704918032787,35.0,0.5737704918032787,0.0,0.0,0.0,0.0,0.0,0.0,6.0,0.46153846153846156,2.0,0.14285714285714285,12.0,0.8571428571428571
168,tablesaw,"private Iterable<TableSlice> partition(){
    if (query.getPartitionColumns().isEmpty()) {
        return ImmutableList.of(new TableSlice(query.getTable()));
    }
    return query.getTable().splitOn(query.getPartitionColumns().toArray(new String[0]));
}",partition,tech/tablesaw/analytic/AnalyticQueryEngine.java,/core/src/main/java/tech/tablesaw/analytic/AnalyticQueryEngine.java,"/**
   * Partition the source table into a series of table slices. Does not modify the underlying table.
   */",140-148,"('partition', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,11.0,Partition the source table into a series of table slices.,The source table is split into a series of table slices. The underlying table is not modified.,The source table should be partitioned into slices.,0.367211584507255,  Partition the source table into a series of table slices.," private Iterable<TableSlice> partition(){
    return new TableSlicePartitioner(query.getTable(), query.getWindowFrame());   
 }"," private Iterable<TableSlice> partition(){
    return new TableSlice.Partitioner(query.getTable(), query.getWindowFrame());    
 }"," private Iterable<TableSlice> partition(){
    return query.getTable().partition(query.getWindowFrame());    
 }"," private Iterable<TableSlice> partition(){
    return new Partitioner(query.getTable(), query.getWindowFrame());   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.28414165925734225,  0.2909745178883088,  0.28414165925734225,  0.3584707068747867,41.0,0.6212121212121212,39.0,0.5909090909090909,41.0,0.6212121212121212,41.0,0.6212121212121212,3.0,0.1,1.0,0.03571428571428571,6.0,0.21428571428571427,10.0,0.5555555555555556,0.0,0.0,7.0,0.6363636363636364
169,cdk,"public List<Permutation> all(){
    final List<Permutation> permutations = new ArrayList<Permutation>();
    Backtracker counter = new Backtracker() {

        @Override
        public void applyTo(Permutation p) {
            permutations.add(p);
        }

        @Override
        public boolean isFinished() {
            return false;
        }
    };
    this.apply(counter);
    return permutations;
}",all,org/openscience/cdk/group/PermutationGroup.java,/tool/group/src/main/java/org/openscience/cdk/group/PermutationGroup.java,"/**
     * Generate the whole group from the compact list of permutations.
     *
     * @return a list of permutations
     */",303-324,"('all', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,11.0,Generate the whole group from the compact list of permutations.,From the compact list of permutations generate the entire group,The whole group can be generated from the compact list of permutations.,0.468012925408487,  Generate the entire group from the compact list of swaps.,Not Valid,"public List<Permutation> all(){
        List<Permutation> all = new ArrayList<Permutation>();
        for(int i = 0; i < size; i++){
            for(int j = 0; j < size; j++){
                if(this.permutations[i][j] != null){
                    all.add(this.permutations[i][j]);
                }
            }
        }
        return all;
    }","public List<Permutation> all(){
        List<Permutation> all = new ArrayList<Permutation>();
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                if (permutations[i][j] != null) {
                    all.add(permutations[i][j]);
                }
            }
        }
        return all;
    }",Not Valid,Not Valid,NOT PASS,Not Valid,NOT PASS,None,  0.3668419967406813,None,  0.35231523940284176,None,None,58.0,0.6373626373626373,None,None,55.0,0.632183908045977,90.0,0.989010989010989,None,None,86.0,0.9885057471264368,9.0,0.8181818181818182,2.0,0.18181818181818182,5.0,0.38461538461538464
170,cdk,"public static IAtomContainer model2Molecule(Model model, IChemObjectBuilder builder){
    ResIterator mols = model.listSubjectsWithProperty(RDF.type, CDK.MOLECULE);
    IAtomContainer mol = null;
    if (mols.hasNext()) {
        Resource rdfMol = mols.next();
        mol = builder.newInstance(IAtomContainer.class);
        Map<Resource, IAtom> rdfToCDKAtomMap = new HashMap<Resource, IAtom>();
        StmtIterator atoms = rdfMol.listProperties(CDK.HASATOM);
        while (atoms.hasNext()) {
            Resource rdfAtom = atoms.nextStatement().getResource();
            IAtom atom;
            if (rdfAtom.hasProperty(RDF.type, CDK.PSEUDOATOM)) {
                atom = builder.newInstance(IPseudoAtom.class);
                atom.setStereoParity(0);
                Statement label = rdfAtom.getProperty(CDK.HASLABEL);
                if (label != null)
                    ((IPseudoAtom) atom).setLabel(label.getString());
            } else {
                atom = builder.newInstance(IAtom.class);
            }
            Statement symbol = rdfAtom.getProperty(CDK.SYMBOL);
            if (symbol != null)
                atom.setSymbol(symbol.getString());
            rdfToCDKAtomMap.put(rdfAtom, atom);
            deserializeAtomTypeFields(rdfAtom, atom);
            mol.addAtom(atom);
        }
        StmtIterator bonds = rdfMol.listProperties(CDK.HASBOND);
        while (bonds.hasNext()) {
            Resource rdfBond = bonds.nextStatement().getResource();
            IBond bond = builder.newInstance(IBond.class);
            StmtIterator bondAtoms = rdfBond.listProperties(CDK.BINDSATOM);
            int atomCounter = 0;
            while (bondAtoms.hasNext()) {
                Statement rdfAtom = bondAtoms.nextStatement();
                IAtom atom = rdfToCDKAtomMap.get(rdfAtom.getResource());
                bond.setAtom(atom, atomCounter);
                atomCounter++;
            }
            Resource order = rdfBond.getProperty(CDK.HASORDER).getResource();
            bond.setOrder(resource2Order(order));
            mol.addBond(bond);
            deserializeElectronContainerFields(rdfBond, bond);
        }
    }
    return mol;
}",model2Molecule,org/openscience/cdk/libio/jena/Convertor.java,/storage/iordf/src/main/java/org/openscience/cdk/libio/jena/Convertor.java,"/**
     * Converts a {@link Model} into an {@link IAtomContainer} using the given {@link IChemObjectBuilder}.
     *
     * @param model RDF graph to deserialize into an {@link IAtomContainer}.
     * @param builder {@link IChemObjectBuilder} used to create new {@link IChemObject}s.
     * @return a {@link IAtomContainer} deserialized from the RDF graph.
     */",306-357,"('model2Molecule', {'INSTRUCTION': {'covered': 153, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 40, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",407.0,23.0,Converts a {@link Model} into an {@link IAtomContainer} using the given {@link IChemObjectBuilder}.,Using the {@link IChemObjectBuilder} given converts a {@link Model} to a {@link IAtomContainer},The model is converted into an IAtomContainer using the given IChemObjectBuilder.,0.346444615143087,  Converts a {@link Model} to {@link IAtomContainer} using the given {@link IChemObjectBuilder}.,"public static IAtomContainer model2Molecule(Model model, IChemObjectBuilder builder){
        IAtomContainer molecule = builder.newInstance(IAtomContainer.class);
        for (Resource rdfObject : model.listResourcesWithProperty(RDF.type, CDK.ATOM)) {
            IAtom atom = builder.newInstance(IAtom.class);
            deserializeAtomFields(rdfObject, atom);
            molecule.addAtom(atom);
        }
        for (Resource rdfObject : model.listResourcesWithProperty(RDF.type, CDK.BOND)) {
            IBond bond = builder.newInstance(IBond.class);
            deserializeBondFields(rdfObject, bond);
            molecule.addBond(bond);
        }
        return molecule;
    }","public static IAtomContainer model2Molecule(Model model, IChemObjectBuilder builder){
        IAtomContainer molecule = builder.newInstance(IAtomContainer.class);
        for (Resource rdfObject : model.listResources()) {
            if (rdfObject.hasProperty(CDK.HASATOM)) {
                IAtom atom = builder.newInstance(IAtom.class);
                deserializeAtomFields(rdfObject, atom);
                molecule.addAtom(atom);
            } else if (rdfObject.hasProperty(CDK.HASBOND)) {
                IBond bond = builder.newInstance(IBond.class);
                deserializeBondFields(rdfObject, bond);
                molecule.addBond(bond);
            }
        }
        return molecule;
    }","public static IAtomContainer model2Molecule(Model model, IChemObjectBuilder builder){
        IAtomContainer molecule = builder.newInstance(IAtomContainer.class);
        for (Resource rdfObject : model.listResourcesWithProperty(RDF.type, CDK.ATOM)) {
            IAtom atom = builder.newInstance(IAtom.class);
            deserializeAtomFields(rdfObject, atom);
            molecule.addAtom(atom);
        }
        for (Resource rdfObject : model.listResourcesWithProperty(RDF.type, CDK.BOND)) {
            IBond bond = builder.newInstance(IBond.class);
            deserializeBondFields(rdfObject, bond);
            molecule.addBond(bond);
        }
        return molecule;
    }","public static IAtomContainer model2Molecule(Model model, IChemObjectBuilder builder){
        IAtomContainer molecule = builder.newInstance(IAtomContainer.class);
        for (Resource rdfObject : model.listResourcesWithProperty(RDF.type, CDK.ATOM)) {
            IAtom atom = builder.newInstance(IAtom.class);
            deserializeAtomFields(rdfObject, atom);
            molecule.addAtom(atom);
        }
        for (Resource rdfObject : model.listResourcesWithProperty(RDF.type, CDK.BOND)) {
            IBond bond = builder.newInstance(IBond.class);
            deserializeBondFields(rdfObject, bond);
            molecule.addBond(bond);
        }
        return molecule;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.20644901237055902,  0.23245773523893185,  0.2047129012594479,  0.2029767901483368,315.0,0.7720588235294118,309.0,0.7573529411764706,315.0,0.7720588235294118,315.0,0.7720588235294118,22.0,0.18181818181818182,0.0,0.0,0.0,0.0,11.0,0.7857142857142857,2.0,0.14285714285714285,8.0,0.5714285714285714
171,acs-aem-commons,"private boolean doesRequestMatch(SlingHttpServletRequest request){
    WCMMode wcmMode = WCMMode.fromRequest(request);
    if (wcmMode != null && wcmMode != WCMMode.DISABLED) {
        log.trace(""Request in author mode: {}, no redirection."", wcmMode);
        return false;
    }
    String method = request.getMethod();
    if (!getMethods().contains(method)) {
        log.trace(""Request method [{}] does not match any of {}."", method, methods);
        return false;
    }
    String ext = request.getRequestPathInfo().getExtension();
    if (ext != null && !getExtensions().isEmpty() && !getExtensions().contains(ext)) {
        log.trace(""Request extension [{}] does not match any of {}."", ext, exts);
        return false;
    }
    String resourcePath = request.getRequestPathInfo().getResourcePath();
    boolean matches = getPaths().isEmpty() || getPaths().stream().anyMatch(p -> resourcePath.startsWith(p + ""/""));
    if (!matches) {
        log.trace(""Request path [{}] not within any of {}."", resourcePath, paths);
        return false;
    }
    return true;
}",doesRequestMatch,com/adobe/acs/commons/redirects/filter/RedirectFilter.java,/bundle/src/main/java/com/adobe/acs/commons/redirects/filter/RedirectFilter.java,"/**
     * Check whether redirection for the given request is allowed.
     * <ol>
     * <li>On author redirects are disabled in EDIT, PREVIEW and DESIGN WCM Modes.
     * To test on author you need to disable WCM mode and append &wcmmode=disabled
     * to the query string</li>
     * <li>Redirects are supported only for GET and HEAD methods</li>
     * This can be changed in the OSGi configuration</li>
     * <li>If configured, redirects are allowed only for the specified extensions,
     * e.g. only *.html requests will be redirected. Same path with .json extension
     * will <i>not</i> be redirected. This feature is disabled by default.</li>
     * </ol>
     *
     * @param request the request to check
     * @return whether redirection for the given is allowed
     */",486-528,"('doesRequestMatch', {'INSTRUCTION': {'covered': 84, 'missed': 0}, 'BRANCH': {'covered': 15, 'missed': 3}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",206.0,10.0,Check whether redirection for the given request is allowed.,"Check whether redirection is permitted for the given request. In WCM EDIT, PREVIEW and DESIGN modes, redirects to author are disabled. In order to test on author, it is necessary to disable the WCM mode and add &wcmmode=disabled to the query string. In addition, redirects are only supported for GET and HEAD methods. If configured, redirects are only allowed for the specified extensions. By default, this function is disabled.",Check if the given request is allowed to be diverted.,0.332636186599137,  Check if redirection for the given request is allowed.," private boolean doesRequestMatch(SlingHttpServletRequest request){
        RequestPathInfo pathInfo = request.getRequestPathInfo();
        String resourcePath = pathInfo.getResourcePath();
        String ext = pathInfo.getExtension();
        if (ext != null && !ext.isEmpty()) {
            if (!extensions.contains(ext)) {
                return false;
            }
        }
        if (paths.isEmpty()) {
            return true;
        }
        for (String path : paths) {
            if (StringUtils.startsWith(resourcePath, path)) {
                return true;
            }
        }
        return false;
    }",Not Valid," private boolean doesRequestMatch(SlingHttpServletRequest request){
        RequestPathInfo pathInfo = request.getRequestPathInfo();
        String resourcePath = pathInfo.getResourcePath();
        String ext = pathInfo.getExtension();
        if (ext != null && !ext.isEmpty()) {
            if (!exts.contains(ext)) {
                return false;
            }
        }
        String method = request.getMethod();
        if (method != null && !method.isEmpty()) {
            if (!methods.contains(method)) {
                return false;
            }
        }
        String path = pathInfo.getSuffix();
        if (path != null && !path.isEmpty()) {
            if (!paths.contains(path)) {
                return false;
            }
        }
        return true;
    }"," private boolean doesRequestMatch(SlingHttpServletRequest request){
        RequestPathInfo pathInfo = request.getRequestPathInfo();
        String resourcePath = pathInfo.getResourcePath();
        String ext = pathInfo.getExtension();
        if (ext != null && !ext.isEmpty()) {
            if (!exts.contains(ext)) {
                return false;
            }
        }
        String method = request.getMethod();
        if (method != null && !method.isEmpty()) {
            if (!methods.contains(method)) {
                return false;
            }
        }
        String path = pathInfo.getSuffix();
        if (path != null && !path.isEmpty()) {
            if (!paths.contains(path)) {
                return false;
            }
        }
        return true;
    }",NOT PASS,Not Valid,NOT PASS,NOT PASS,  0.23633947702383662,None,  0.3062022962532625,  0.3062022962532625,137.0,0.6618357487922706,None,None,124.0,0.5990338164251208,124.0,0.5990338164251208,None,None,55.0,0.3716216216216216,55.0,0.3716216216216216,62.0,0.8857142857142857,1.0,0.1,7.0,0.6363636363636364
172,cdk,"public Iterable<IMapping> mappings(){
    return new Iterable<IMapping>() {

        @Override
        public Iterator<IMapping> iterator() {
            return new MappingIterator();
        }
    };
}",mappings,org/openscience/cdk/Reaction.java,/base/data/src/main/java/org/openscience/cdk/Reaction.java,"/**
     * Returns the mappings between the reactant and the product side.
     *
     * @return An Iterator to the Mappings.
     * @see    #addMapping
     */",168-183,"('mappings', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,11.0,Returns the mappings between the reactant and the product side.,"Between the reagent side and the product side, mappings are returned",The mappings between the reactant and the product side are returned.,0.418501292167985,  Returns the mappings between the reagent and the product side.,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,9.0,0.75,1.0,0.09090909090909091,5.0,0.4166666666666667
173,liquibase,"public SqlStatement[] generateStatements(Database database){
    List<SqlStatement> returnStatements = new ArrayList<>();
    String sql = StringUtil.trimToNull(getSql());
    if (sql == null) {
        return new SqlStatement[0];
    }
    String processedSQL = normalizeLineEndings(sql);
    if (this instanceof RawSQLChange && ((RawSQLChange) this).isRerunnable()) {
        returnStatements.add(new RawSqlStatement(processedSQL, getEndDelimiter()));
        return returnStatements.toArray(new SqlStatement[returnStatements.size()]);
    }
    for (String statement : StringUtil.processMultiLineSQL(processedSQL, isStripComments(), isSplitStatements(), getEndDelimiter())) {
        if (database instanceof MSSQLDatabase) {
            statement = statement.replaceAll(""\\n"", ""\r\n"");
        }
        String escapedStatement = statement;
        try {
            if (database.getConnection() != null) {
                escapedStatement = database.getConnection().nativeSQL(statement);
            }
        } catch (DatabaseException e) {
            escapedStatement = statement;
        }
        returnStatements.add(new RawSqlStatement(escapedStatement, getEndDelimiter()));
    }
    return returnStatements.toArray(new SqlStatement[returnStatements.size()]);
}",generateStatements,liquibase/change/AbstractSQLChange.java,/liquibase-core/src/main/java/liquibase/change/AbstractSQLChange.java,"/**
     * Generates one or more SqlStatements depending on how the SQL should be parsed.
     * If split statements is set to true then the SQL is split and each command is made into a separate SqlStatement.
     * <p></p>
     * If stripping comments is true then any comments are removed before the splitting is executed.
     * The set SQL is passed through the {@link java.sql.Connection#nativeSQL} method if a connection is available.
     */",216-256,"('generateStatements', {'INSTRUCTION': {'covered': 84, 'missed': 19}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 15, 'missed': 4}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",229.0,14.0,Generates one or more SqlStatements depending on how the SQL should be parsed.,"Depending on how the SQL is to be analysed, it generates one or more SqlStatements. SQL is split and each command is turned into a separate SqlStatement if split statements is set to true.  Comments are removed before the split statement is executed if the stripping of comments is true. If a connection is available the SQL set is passed through the method {@link java.sql.Connection#nativeSQL}","Depending on how the SQL should be read, one or more SqlStatements can be generated.",0.229453054082421,  Generates one or more SqlStatements based on how sql should be parsed.," public SqlStatement[] generateStatements(Database database){
        InputStream stream = null;
        try {
            stream = openSqlStream();
    
            String sql = this.sql;
            if ((stream == null) && (sql == null)) {
                sql = """";
            }
    
            if (sql != null) {
                stream = new ByteArrayInputStream(sql.getBytes(GlobalConfiguration.OUTPUT_FILE_ENCODING.getCurrentValue())
                );
            }
    
            return SqlStatement.generateStatements(new NormalizingStream(this.getEndDelimiter(), this.isSplitStatements(), this.isStripComments(), stream), database);
        } catch (IOException e) {
            throw new UnexpectedLiquibaseException(e);
        } finally {
            if (stream != null) {
                try {
                    stream.close();
                } catch (IOException e) {
                    Scope.getCurrentScope().getLog(getClass()).fine(""Error closing stream"", e);
                }
            }
        }
    }","public SqlStatement[] generateStatements(Database database){
        if (sql == null) {
            return new SqlStatement[0];
        }
    
        String[] statements = sql.split(endDelimiter);
        if (statements.length == 1) {
            return new SqlStatement[] { new RawSqlStatement(sql) };
        }
    
        List<SqlStatement> statementList = new ArrayList<SqlStatement>();
        for (String statement : statements) {
            if (statement.trim().length() == 0) {
                continue;
            }
    
            if (isStripComments()) {
                statement = StripComments.stripComments(statement);
            }
    
            if (isSplitStatements()) {
                statementList.addAll(Arrays.asList(SplitStatements.splitStatements(statement, database)));
            } else {
                statementList.add(new RawSqlStatement(statement));
            }
        }
    
        return statementList.toArray(new SqlStatement[statementList.size()]);
    }"," public SqlStatement[] generateStatements(Database database){
        InputStream stream = null;
        try {
            stream = openSqlStream();
    
            String sql = this.sql;
            if ((stream == null) && (sql == null)) {
                sql = """";
            }
    
            if (sql != null) {
                stream = new ByteArrayInputStream(sql.getBytes(GlobalConfiguration.OUTPUT_FILE_ENCODING.getCurrentValue())
                );
            }
    
            return SqlStatement.generateStatements(new NormalizingStream(this.getEndDelimiter(), this.isSplitStatements(), this.isStripComments(), stream), database);
        } catch (IOException e) {
            throw new UnexpectedLiquibaseException(e);
        } finally {
            if (stream != null) {
                try {
                    stream.close();
                } catch (IOException e) {
                    Scope.getCurrentScope().getLog(getClass()).fine(""Error closing stream"", e);
                }
            }
        }
    }"," public SqlStatement[] generateStatements(Database database){
        InputStream stream = null;
        try {
            stream = openSqlStream();
    
            String sql = this.sql;
            if ((stream == null) && (sql == null)) {
                sql = """";
            }
    
            if (sql != null) {
                stream = new ByteArrayInputStream(sql.getBytes(GlobalConfiguration.OUTPUT_FILE_ENCODING.getCurrentValue())
                );
            }
    
            return SqlStatement.generateStatements(new NormalizingStream(this.getEndDelimiter(), this.isSplitStatements(), this.isStripComments(), stream), database);
        } catch (IOException e) {
            throw new UnexpectedLiquibaseException(e);
        } finally {
            if (stream != null) {
                try {
                    stream.close();
                } catch (IOException e) {
                    Scope.getCurrentScope().getLog(getClass()).fine(""Error closing stream"", e);
                }
            }
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.25367898587108223,  0.3785618521565779,  0.2488712935633899,  0.25367898587108223,148.0,0.6434782608695652,137.0,0.5956521739130435,148.0,0.6434782608695652,148.0,0.6434782608695652,134.0,0.7570621468926554,0.0,0.0,0.0,0.0,60.0,0.9090909090909091,3.0,0.21428571428571427,14.0,0.875
174,cdk,"public String toCanonicalSignatureString(int height){
    String canonicalSignature = null;
    for (int i = 0; i < getVertexCount(); i++) {
        String signatureForI = signatureStringForVertex(i, height);
        if (canonicalSignature == null || canonicalSignature.compareTo(signatureForI) < 0) {
            canonicalSignature = signatureForI;
        }
    }
    return canonicalSignature;
}",toCanonicalSignatureString,org/openscience/cdk/signature/MoleculeSignature.java,/descriptor/signature/src/main/java/org/openscience/cdk/signature/MoleculeSignature.java,"/**
     * Make a canonical signature string of a given height.
     *
     * @param height the maximum height to make signatures
     * @return the canonical signature string
     */",186-201,"('toCanonicalSignatureString', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,10.0,Make a canonical signature string of a given height.,"From a given height, it creates a canonical signature string",A signature string of a height.,0.181131475591323,  Create a canonical signature string of a given height.," public String toCanonicalSignatureString(int height){
        return super.toCanonicalSignatureString(height);        
 }","public String toCanonicalSignatureString(int height){
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < this.getVertexCount(); i++) {
            sb.append(this.signatureStringForVertex(i, height));
            sb.append(""."");
        }
        return sb.toString();
    }"," public String toCanonicalSignatureString(int height){
        return this.toCanonicalString(height);
    }"," public String toCanonicalSignatureString(int height){
        return this.toCanonicalString(height);      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.14683780087148846,  0.5143592446936547,  0.13367990613464636,  0.13367990613464636,53.0,0.7910447761194029,36.0,0.5373134328358209,53.0,0.7910447761194029,53.0,0.7910447761194029,51.0,0.7727272727272727,2.0,0.1111111111111111,2.0,0.1111111111111111,8.0,0.7272727272727273,1.0,0.1,4.0,0.4
175,cdk,"private static GeometryEncoder encoder(ITetrahedralChirality tc, Map<IAtom, Integer> atomToIndex){
    IAtom[] ligands = tc.getLigands();
    int centre = atomToIndex.get(tc.getChiralAtom());
    int[] indices = new int[4];
    int offset = -1;
    for (int i = 0; i < ligands.length; i++) {
        indices[i] = atomToIndex.get(ligands[i]);
        if (indices[i] == centre)
            offset = i;
    }
    int parity = tc.getStereo() == CLOCKWISE ? -1 : 1;
    if (offset >= 0) {
        for (int i = offset; i < indices.length - 1; i++) {
            indices[i] = indices[i + 1];
        }
        if (Integer.lowestOneBit(3 - offset) == 0x1)
            parity *= -1;
        indices = Arrays.copyOf(indices, indices.length - 1);
    }
    return new GeometryEncoder(centre, new BasicPermutationParity(indices), GeometricParity.valueOf(parity));
}",encoder,org/openscience/cdk/hash/stereo/TetrahedralElementEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/TetrahedralElementEncoderFactory.java,"/**
     * Create an encoder for the {@link ITetrahedralChirality} element.
     *
     * @param tc          stereo element from an atom container
     * @param atomToIndex map of atoms to indices
     * @return a new geometry encoder
     */",73-118,"('encoder', {'INSTRUCTION': {'covered': 96, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",215.0,12.0,Create an encoder for the {@link ITetrahedralChirality} element.,For the {@link ITetrahedralChirality} element create an encoder,The @link ITetrahedralChirality element has an Encoder.,1.17261735531017,  Create an encoder for the {@link ITetrahedralChirality} element.,Empty Method,Empty Method,Empty Method,"private static GeometryEncoder encoder(ITetrahedralChirality tc, Map<IAtom, Integer> atomToIndex){
        int[] indices = new int[4];
        for (int i = 0; i < 4; i++) {
            indices[i] = atomToIndex.get(tc.getAtoms()[i]);
        }
        return new GeometryEncoder(indices, tc.getStereo() == CLOCKWISE ? 1 : 0);       
 }",Empty Method,Empty Method,NOT PASS,Empty Method,None,None,  0.25325648020916924,None,None,None,None,None,145.0,0.6712962962962963,None,None,None,None,83.0,0.9880952380952381,None,None,8.0,0.8888888888888888,0.0,0.0,8.0,0.8888888888888888
176,cdk,"public static boolean containsElement(IMolecularFormula formula, IElement element){
    for (IIsotope isotope : formula.isotopes()) {
        if (element.getSymbol().equals(isotope.getSymbol()))
            return true;
    }
    return false;
}",containsElement,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * True, if the MolecularFormula contains the given element as IIsotope object.
     *
     * @param  formula   IMolecularFormula molecularFormula
     * @param  element   The element this MolecularFormula is searched for
     * @return           True, if the MolecularFormula contains the given element object
     */",190-204,"('containsElement', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",49.0,13.0,"True, if the MolecularFormula contains the given element as IIsotope object.","If the MolecularFormula contains the element given as the IIsotope object, the method returns true.","If the element is an IIsotope object, it's true.",0.293965138251268,"  True, if molecularFormula contains the given element as an IIsotope object."," public static boolean containsElement(IMolecularFormula formula, IElement element){
        for (IIsotope isotope : formula.isotopes()) {
            if (isotope.getSymbol().equals(element.getSymbol())) return true;
        }
        return false;
    }"," public static boolean containsElement(IMolecularFormula formula, IElement element){
        for (IIsotope isotope : formula.isotopes()) {
            if (isotope.getSymbol().equals(element.getSymbol())) return true;
        }
        return false;       
 }"," public static boolean containsElement(IMolecularFormula formula, IElement element){
        for (IIsotope isotope : formula.isotopes()) {
            if (isotope.getSymbol().equals(element.getSymbol())) return true;
        }
        return false;
    }"," public static boolean containsElement(IMolecularFormula formula, IElement element){
        for (IIsotope isotope : formula.isotopes()) {
            if (isotope.getSymbol().equals(element.getSymbol())) return true;
        }
        return false;
    }",PASS,PASS,PASS,PASS,  0.9834722290374383,  0.9834722290374383,  0.9834722290374383,  0.9834722290374383,2.0,0.04,2.0,0.04,2.0,0.04,2.0,0.04,0.0,0.0,0.0,0.0,0.0,0.0,10.0,0.625,3.0,0.25,10.0,0.8333333333333334
177,cdk,"public static IsotopePattern sortByMass(IsotopePattern isotopeP){
    try {
        IsotopePattern isoSort = (IsotopePattern) isotopeP.clone();
        if (isoSort.getNumberOfIsotopes() == 0)
            return isoSort;
        List<IsotopeContainer> listISO = isoSort.getIsotopes();
        Collections.sort(listISO, new Comparator<IsotopeContainer>() {

            @Override
            public int compare(IsotopeContainer o1, IsotopeContainer o2) {
                return Double.compare(o1.getMass(), o2.getMass());
            }
        });
        isoSort.setMonoIsotope(listISO.get(0));
        return isoSort;
    } catch (CloneNotSupportedException e) {
        e.printStackTrace();
    }
    return null;
}",sortByMass,org/openscience/cdk/formula/IsotopePatternManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/formula/IsotopePatternManipulator.java,"/**
     * Return the isotope pattern sorted by mass
     * to the highest abundance.
     *
     * @param isotopeP  The IsotopePattern object to sort
     * @return          The IsotopePattern sorted
     */",106-140,"('sortByMass', {'INSTRUCTION': {'covered': 23, 'missed': 7}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 4}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",130.0,12.0,Return the isotope pattern sorted by mass  to the highest abundance.,The isotope pattern sorted by mass at maximum abundance is returned.,The pattern of the isotope is sorted by mass.,0.784389204413977,  Restore the highest abundance of the mass-sorted isotopic pattern.,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,7.0,0.5833333333333334,10.0,0.8333333333333334,9.0,0.75
178,matsim-libs,"private double calculateRouteDistanceWithAssociatedPickup(JobInsertionContext context){
    double routeDistance = 0;
    int positionOfRelatedPickup = context.getRelatedActivityContext().getInsertionIndex();
    int nextRouteActivity = 0;
    // checks if the associated pickup is on first position
    if (positionOfRelatedPickup == 0 && context.getRoute().getActivities().isEmpty()) {
        context.getRoute().getStart().setLocation(context.getNewVehicle().getStartLocation());
        // This value is never used. it gets overwritten before usage. -- commenting it out. KMT, Jun'20
        // routeDistance = getDistance(context.getRoute().getStart(), context.getAssociatedActivities().get(0),
        // context.getNewVehicle(), context.getNewDepTime());
        context.getRoute().getEnd().setLocation(context.getNewVehicle().getEndLocation());
        routeDistance = getDistance(context.getAssociatedActivities().get(0), context.getRoute().getEnd(), context.getNewVehicle(), context.getNewDepTime());
        return routeDistance;
    } else if (positionOfRelatedPickup == 0 && !context.getRoute().getActivities().isEmpty()) {
        // This value is never used. it gets overwritten before usage. -- commenting it out. KMT, Jun'20
        // routeDistance = getDistance(context.getRoute().getStart(), context.getAssociatedActivities().get(0),
        // context.getNewVehicle(), context.getNewDepTime());
        routeDistance = getDistance(context.getAssociatedActivities().get(0), context.getRoute().getActivities().get(0), context.getNewVehicle(), context.getNewDepTime());
    } else {
        routeDistance = getDistance(context.getRoute().getStart(), context.getRoute().getActivities().get(0), context.getNewVehicle(), context.getNewDepTime());
    }
    // adds distances between every tour activity and adds the associated pickup on
    // the correct position of the tour
    while (context.getRoute().getTourActivities().getActivities().size() > (nextRouteActivity + 1)) {
        if (positionOfRelatedPickup == (nextRouteActivity + 1) && positionOfRelatedPickup != 0) {
            routeDistance = routeDistance + getDistance(context.getRoute().getActivities().get(nextRouteActivity), context.getAssociatedActivities().get(0), context.getNewVehicle());
            routeDistance = routeDistance + getDistance(context.getAssociatedActivities().get(0), context.getRoute().getActivities().get(nextRouteActivity), context.getNewVehicle());
        } else {
            routeDistance = routeDistance + getDistance(context.getRoute().getActivities().get(nextRouteActivity), context.getRoute().getActivities().get(nextRouteActivity + 1), context.getNewVehicle());
        }
        nextRouteActivity++;
    }
    if (positionOfRelatedPickup == context.getRoute().getActivities().size()) {
        routeDistance = routeDistance + getDistance(context.getRoute().getActivities().get(nextRouteActivity), context.getAssociatedActivities().get(0), context.getNewVehicle());
        routeDistance = routeDistance + getDistance(context.getAssociatedActivities().get(0), context.getRoute().getEnd(), context.getNewVehicle());
    } else
        routeDistance = routeDistance + getDistance(context.getRoute().getActivities().get(nextRouteActivity), context.getRoute().getEnd(), context.getNewVehicle());
    return routeDistance;
}",calculateRouteDistanceWithAssociatedPickup,org/matsim/contrib/freight/jsprit/DistanceConstraint.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/jsprit/DistanceConstraint.java,"/**
         * Calculates the distance based on the route-based distances between every tour
         * activities. The method also integrates the associated pickup in the tour.
         */",130-183,"('calculateRouteDistanceWithAssociatedPickup', {'INSTRUCTION': {'covered': 222, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 31, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",561.0,13.0,Calculates the distance based on the route-based distances between every tour  activities.,"Based on the route between the activities of each tour, it calculates the distance .  The pick-up associated with the tour is integrated into the",The distance is calculated based on the route-based distances between the activities.,0.243047624685901,  Calculates the distance based on the distances based on the route between each tourist activity.,"private double calculateRouteDistanceWithAssociatedPickup(JobInsertionContext context){
		double routeDistance = 0;
		for (TourActivity act : context.getJob().getActivities()) {
			if (act instanceof PickupShipment) {
				routeDistance += getDistance(act, act.getNext(), context.getNewVehicle());
			} else if (act instanceof DeliverShipment) {
				routeDistance += getDistance(act, act.getNext(), context.getNewVehicle());
			} else {
				routeDistance += getDistance(act, act.getNext(), context.getNewVehicle());
			}
		}
		return routeDistance;
	}","private double calculateRouteDistanceWithAssociatedPickup(JobInsertionContext context){
		double routeDistance = 0;
		TourActivity prevAct = context.getCurrentRoute().getStart();
		TourActivity newAct = context.getCurrentRoute().getEnd();
		TourActivity nextAct = context.getCurrentRoute().getEnd().getNext();
		Vehicle newVehicle = context.getNewVehicle();
		while(nextAct != null){
			routeDistance += getDistance(prevAct, nextAct, newVehicle);
			prevAct = nextAct;
			nextAct = nextAct.getNext();
		}
		return routeDistance;
	}","private double calculateRouteDistanceWithAssociatedPickup(JobInsertionContext context){
		double routeDistance = 0;
		Vehicle newVehicle = context.getNewVehicle();
		TourActivity prevAct = context.getPrevAct();
		TourActivity newAct = context.getNewAct();
		TourActivity nextAct = context.getNextAct();
		
		if(prevAct instanceof PickupShipment){
			routeDistance = netBasedCosts.getLinkTravelTime(prevAct.getLocation(), newAct.getLocation(), departureTime, newVehicle)
					+ netBasedCosts.getLinkTravelTime(newAct.getLocation(), nextAct.getLocation(), departureTime, newVehicle);
		}
		else{
			routeDistance = netBasedCosts.getLinkTravelTime(prevAct.getLocation(), newAct.getLocation(), departureTime, newVehicle)
					+ netBasedCosts.getLinkTravelTime(newAct.getLocation(), nextAct.getLocation(), departureTime, newVehicle);
		}
		return routeDistance;
	}","private double calculateRouteDistanceWithAssociatedPickup(JobInsertionContext context){
		double routeDistance = 0;
		TourActivity prevAct = context.getPrevAct();
		TourActivity newAct = context.getNewAct();
		TourActivity nextAct = context.getNextAct();
		Vehicle newVehicle = context.getNewVehicle();
		
		if(prevAct instanceof PickupShipment){
			routeDistance += getDistance(prevAct, newAct, newVehicle);
		}
		if(nextAct instanceof DeliverShipment){
			routeDistance += getDistance(newAct, nextAct, newVehicle);
		}
		return routeDistance;
	}",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.19714883345690165,  0.18573410670439258,  0.15587086919389043,  0.1862571516596023,473.0,0.8416370106761566,485.0,0.8629893238434164,495.0,0.8807829181494662,458.0,0.8149466192170819,68.0,0.6071428571428571,59.0,0.5267857142857143,90.0,0.5882352941176471,22.0,0.8461538461538461,8.0,0.5,6.0,0.46153846153846156
179,weblogic-kubernetes-operator,"public CallBuilder withAuthentication(String accessToken){
    if (!isNullOrEmpty(accessToken)) {
        this.helper = new ClientPool().withApiClient(createApiClient(accessToken));
    }
    return this;
}",withAuthentication,oracle/kubernetes/operator/helpers/CallBuilder.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/CallBuilder.java,"/**
   * Create AccessTokenAuthentication component for authenticating user represented by
   * the given token.
   * @param accessToken - User's Bearer token
   * @return - this CallBuilder instance
   */",2151-2162,"('withAuthentication', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,12.0,Create AccessTokenAuthentication component for authenticating user represented by  the given token.,"To authenticate the user represented by the given token, create the AccessTokenAuthentication component",AccessTokenAuthentication component is created to allow for the authenticating of user represented by a token.,0.273095666658776,  Create the AccessTokenAuthentication component to authenticate the user represented by the given token.," public CallBuilder withAuthentication(String accessToken){
    return new CallBuilder(this).withAuthentication(accessToken);           
 }"," public CallBuilder withAuthentication(String accessToken){
    return new CallBuilder(this).withAuthentication(accessToken);           
 }"," public CallBuilder withAuthentication(String accessToken){
    this.accessToken = accessToken;
    return this;            
 }"," public CallBuilder withAuthentication(String accessToken){
    return new CallBuilder(this).withAuthentication(accessToken);           
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.31108556758706385,  0.31108556758706385,  0.31108556758706385,  0.2841107020342184,22.0,0.55,22.0,0.55,22.0,0.55,22.0,0.55,0.0,0.0,0.0,0.0,10.0,0.45454545454545453,10.0,0.7142857142857143,4.0,0.2857142857142857,9.0,0.5625
180,cdk,"public static void aromatizeMolecule(IAtomContainer mol){
    IRingSet ringSet = null;
    try {
        AllRingsFinder arf = new AllRingsFinder();
        ringSet = arf.findAllRings(mol);
    } catch (Exception e) {
        e.printStackTrace();
    }
    try {
        SMSDNormalizer.percieveAtomTypesAndConfigureAtoms(mol);
        Aromaticity.cdkLegacy().apply(mol);
        RingSetManipulator.markAromaticRings(ringSet);
    } catch (Exception e) {
        e.printStackTrace();
    }
    for (int i = 0; i <= mol.getAtomCount() - 1; i++) {
        mol.getAtom(i).setFlag(CDKConstants.ISAROMATIC, false);
        jloop: for (int j = 0; j <= ringSet.getAtomContainerCount() - 1; j++) {
            IRing ring = (IRing) ringSet.getAtomContainer(j);
            if (!ring.getFlag(CDKConstants.ISAROMATIC)) {
                continue jloop;
            }
            boolean haveatom = ring.contains(mol.getAtom(i));
            if (haveatom && ring.getAtomCount() == 6) {
                mol.getAtom(i).setFlag(CDKConstants.ISAROMATIC, true);
            }
        }
    }
}",aromatizeMolecule,org/openscience/cdk/normalize/SMSDNormalizer.java,/legacy/src/main/java/org/openscience/cdk/normalize/SMSDNormalizer.java,"/**
     * This function finds rings and uses aromaticity detection code to
     * aromatize the molecule.
     * @param mol input molecule
     */",118-178,"('aromatizeMolecule', {'INSTRUCTION': {'covered': 74, 'missed': 7}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 5}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",226.0,14.0,This function finds rings and uses aromaticity detection code to  aromatize the molecule.,This function to aromatise the molecule finds the rings and uses the aromaticity detection code,The function uses aromaticity detection code to find rings.,0.146076276589445,  This function finds rings and uses the aromaticity detection code to flavor the molecule.,Empty Method," public static void aromatizeMolecule(IAtomContainer mol){
        IRingSet ringSet = AllRingsFinder.findAllRings(mol);
        Aromaticity.cdkAromaticity(mol, ringSet);
    }"," public static void aromatizeMolecule(IAtomContainer mol){
        Aromaticity aromaticity = new Aromaticity(ElectronDonation.daylight(), Cycles.all());
        aromaticity.apply(mol);     
 }","public static void aromatizeMolecule(IAtomContainer mol){
        IRingSet ringSet = AllRingsFinder.findAllRings(mol);
        if (ringSet.getAtomContainerCount() > 0) {
            for (int i = 0; i < ringSet.getAtomContainerCount(); i++) {
                IRing ring = ringSet.getAtomContainer(i);
                if (ring.getAtomCount() > 5) {
                    Aromaticity.cdkLegacy().apply(ring);
                }
            }
        }
    }",Empty Method,NOT PASS,NOT PASS,NOT PASS,None,  0.08896372948739176,  0.2537913759065084,  0.12880899536695153,None,None,198.0,0.8722466960352423,154.0,0.6784140969162996,198.0,0.8722466960352423,29.0,0.9666666666666667,85.0,0.9883720930232558,36.0,0.972972972972973,10.0,0.625,2.0,0.13333333333333333,7.0,0.5
181,dataverse,"public FileMetadata createCopy(){
    FileMetadata fmd = new FileMetadata();
    fmd.setCategories(new LinkedList<>(getCategories()));
    fmd.setDataFile(getDataFile());
    fmd.setDatasetVersion(getDatasetVersion());
    fmd.setDescription(getDescription());
    fmd.setLabel(getLabel());
    fmd.setRestricted(isRestricted());
    fmd.setDirectoryLabel(getDirectoryLabel());
    return fmd;
}",createCopy,edu/harvard/iq/dataverse/FileMetadata.java,/src/main/java/edu/harvard/iq/dataverse/FileMetadata.java,"/**
     * Creates a copy of {@code this}, with identical business logic fields.
     * E.g., {@link #label} would be duplicated; {@link #version} will not.
     * 
     * @return A copy of {@code this}, except for the DB-related data.
     */",115-132,"('createCopy', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,16.0,"Creates a copy of {@code this}, with identical business logic fields.","Creates a copy of {@code this}, where the business logic fields are identical",A copy of @code this is created.,0.742771807655122,"  Creates a copy of {@code this}, with identical business logic fields."," public FileMetadata createCopy(){
        FileMetadata copy = new FileMetadata();
        copy.setLabel(this.getLabel());
        copy.setDescription(this.getDescription());
        copy.setRestricted(this.isRestricted());
        copy.setDatasetVersion(this.getDatasetVersion());
        copy.setDataFile(this.getDataFile());
        copy.setProvFreeForm(this.getProvFreeForm());
        copy.setVariableMetadatas(this.getVariableMetadatas());
        return copy;
    }"," public FileMetadata createCopy(){
        FileMetadata copy = new FileMetadata();
        copy.setLabel(this.getLabel());
        copy.setDescription(this.getDescription());
        copy.setRestricted(this.isRestricted());
        copy.setDatasetVersion(this.getDatasetVersion());
        copy.setDataFile(this.getDataFile());
        copy.setProvFreeForm(this.getProvFreeForm());
        copy.setVariableMetadatas(this.getVariableMetadatas());
        return copy;
    }"," public FileMetadata createCopy(){
        FileMetadata copy = new FileMetadata();
        copy.setLabel(this.getLabel());
        copy.setDescription(this.getDescription());
        copy.setRestricted(this.isRestricted());
        copy.setDatasetVersion(this.getDatasetVersion());
        copy.setDataFile(this.getDataFile());
        copy.setProvFreeForm(this.getProvFreeForm());
        copy.setVariableMetadatas(this.getVariableMetadatas());
        return copy;
    }"," public FileMetadata createCopy(){
        FileMetadata copy = new FileMetadata();
        copy.setLabel(this.getLabel());
        copy.setDescription(this.getDescription());
        copy.setRestricted(this.isRestricted());
        copy.setDatasetVersion(this.getDatasetVersion());
        copy.setDataFile(this.getDataFile());
        copy.setProvFreeForm(this.getProvFreeForm());
        copy.setVariableMetadatas(this.getVariableMetadatas());
        return copy;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5475862050332742,  0.5475862050332742,  0.5475862050332742,  0.5475862050332742,41.0,0.4270833333333333,41.0,0.4270833333333333,41.0,0.4270833333333333,41.0,0.4270833333333333,0.0,0.0,0.0,0.0,0.0,0.0,5.0,0.35714285714285715,0.0,0.0,9.0,0.75
182,acs-aem-commons,"private boolean accepts(final ReplicationAction replicationAction, final ReplicationOptions replicationOptions){
    if (replicationAction == null || replicationOptions == null) {
        log.debug(""Replication Action or Options are null. Skipping this replication."");
        return false;
    }
    final String path = replicationAction.getPath();
    if (replicationOptions.getFilter() instanceof DispatcherFlushRulesFilter) {
        log.debug(""Ignore applying dispatcher flush rules for [ {} ], as it originated from this "" + ""Service."", path);
        return false;
    } else if ((this.hierarchicalFlushRules == null || this.hierarchicalFlushRules.size() < 1) && (this.resourceOnlyFlushRules == null || this.resourceOnlyFlushRules.size() < 1)) {
        log.warn(""Ignored due no configured flush rules."");
        return false;
    } else if (StringUtils.isBlank(path)) {
        log.debug(""Replication Action path is blank. Skipping this replication."");
        return false;
    } else if (!ReplicationActionType.ACTIVATE.equals(replicationAction.getType()) && !ReplicationActionType.DEACTIVATE.equals(replicationAction.getType()) && !ReplicationActionType.DELETE.equals(replicationAction.getType())) {
        return false;
    }
    return true;
}",accepts,com/adobe/acs/commons/replication/dispatcher/impl/DispatcherFlushRulesImpl.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/impl/DispatcherFlushRulesImpl.java,"/**
     * Checks if this service should react to or ignore this replication action.
     *
     * @param replicationAction The replication action that is initiating this flush request
     * @param replicationOptions The replication options that is initiating this flush request
     * @return true is this service should attempt to flush associated resources for this replication request
     */",208-243,"('accepts', {'INSTRUCTION': {'covered': 64, 'missed': 6}, 'BRANCH': {'covered': 17, 'missed': 5}, 'LINE': {'covered': 17, 'missed': 2}, 'COMPLEXITY': {'covered': 7, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",198.0,13.0,Checks if this service should react to or ignore this replication action.,Controls whether the service should ignore the response action or react,This service is checked to see if it should respond to this action.,0.542121213749766,  Checks whether this service should react or ignore this replication action.," private boolean accepts(final ReplicationAction replicationAction, final ReplicationOptions replicationOptions){
        if (replicationAction.getType() == ReplicationActionType.DELETE) {
            return false;
        }
    
        if (replicationOptions.getReplicationActionType() == ReplicationActionType.DELETE) {
            return false;
        }
    
        return true;
    }"," private boolean accepts(final ReplicationAction replicationAction, final ReplicationOptions replicationOptions){
        return replicationAction.getType() == ReplicationActionType.CREATE ||
                replicationAction.getType() == ReplicationActionType.UPDATE ||
                replicationAction.getType() == ReplicationActionType.DELETE;
    }"," private boolean accepts(final ReplicationAction replicationAction, final ReplicationOptions replicationOptions){
        return replicationAction.getType() == ReplicationActionType.CREATE
                || replicationAction.getType() == ReplicationActionType.UPDATE
                || replicationAction.getType() == ReplicationActionType.DELETE;
    }"," private boolean accepts(final ReplicationAction replicationAction, final ReplicationOptions replicationOptions){
        if (replicationAction.getType() == ReplicationActionType.DELETE) {
            return false;
        }
    
        if (replicationOptions.getReplicationActionType() == ReplicationActionType.DELETE) {
            return false;
        }
    
        return true;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.18577130463554664,  0.16762863747863993,  0.18577130463554664,  0.16762863747863993,153.0,0.7688442211055276,160.0,0.8040201005025126,153.0,0.7688442211055276,160.0,0.8040201005025126,24.0,0.46153846153846156,0.0,0.0,24.0,0.46153846153846156,10.0,0.7692307692307693,2.0,0.15384615384615385,12.0,0.8571428571428571
183,cdk,"public boolean contains(IIsotope isotope){
    for (Iterator<IIsotope> it = isotopes().iterator(); it.hasNext(); ) {
        IIsotope thisIsotope = it.next();
        if (isTheSame(thisIsotope, isotope)) {
            return true;
        }
    }
    return false;
}",contains,org/openscience/cdk/formula/AdductFormula.java,/base/data/src/main/java/org/openscience/cdk/formula/AdductFormula.java,"/**
     *  True, if the AdductFormula contains the given IIsotope object and not
     *  the instance. The method looks for other isotopes which has the same
     *  symbol, natural abundance and exact mass.
     *
     * @param  isotope  The IIsotope this AdductFormula is searched for
     * @return          True, if the AdductFormula contains the given isotope object
     */",111-128,"('contains', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,15.0,"True, if the AdductFormula contains the given IIsotope object and not  the instance.","In the case where the AdductFormula contains the given IIsotope object and not the instance returns True. Whereas, the method searches for other isotopes with the same natural abundance, the same symbol and the same exact mass.","If the AdductFormula contains the IIsotope object, it's true.",0.30247503443561,"  True, if AdductFormula contains the given IIsotope object, not the instance."," public boolean contains(IIsotope isotope){
        for (IMolecularFormula mf : components) {
            if (mf.contains(isotope)) return true;
        }
        return false;
    }"," public boolean contains(IIsotope isotope){
        for (IMolecularFormula mf : components) {
            if (mf.contains(isotope)) {
                return true;
            }
        }
        return false;
    }"," public boolean contains(IIsotope isotope){
        for (IMolecularFormula mf : components) {
            if (mf.contains(isotope)) return true;
        }
        return false;
    }"," public boolean contains(IIsotope isotope){
        for (IMolecularFormula mf : components) {
            if (mf.contains(isotope)) return true;
        }
        return false;
    }",PASS,PASS,PASS,PASS,  0.2823388655533638,  0.33309677105089514,  0.2823388655533638,  0.2823388655533638,35.0,0.5737704918032787,33.0,0.5409836065573771,35.0,0.5737704918032787,35.0,0.5737704918032787,2.0,0.05555555555555555,0.0,0.0,0.0,0.0,27.0,0.7105263157894737,3.0,0.21428571428571427,8.0,0.5714285714285714
184,cdk,"public DescriptorValue calculate(IAtomContainer container){
    if (!GeometryUtil.has3DCoordinates(container))
        return getDummyDescriptorValue(new CDKException(""Molecule must have 3D coordinates""));
    double sum = 0.0;
    IAtomContainer ac;
    try {
        ac = (IAtomContainer) container.clone();
    } catch (CloneNotSupportedException e) {
        return getDummyDescriptorValue(e);
    }
    double[][] cmat = new double[ac.getAtomCount()][3];
    for (int i = 0; i < ac.getAtomCount(); i++) {
        Point3d coords = ac.getAtom(i).getPoint3d();
        cmat[i][0] = coords.x;
        cmat[i][1] = coords.y;
        cmat[i][2] = coords.z;
    }
    Map<String, Double> hash = null;
    double[] wt = new double[ac.getAtomCount()];
    if (this.type.equals(""unity"")) {
        for (int i = 0; i < ac.getAtomCount(); i++) wt[i] = 1.0;
    } else {
        if (this.type.equals(""mass"")) {
            hash = this.hashatwt;
        } else if (this.type.equals(""volume"")) {
            hash = this.hashvdw;
        } else if (this.type.equals(""eneg"")) {
            hash = this.hasheneg;
        } else if (this.type.equals(""polar"")) {
            hash = this.hashpol;
        }
        for (int i = 0; i < ac.getAtomCount(); i++) {
            String sym = ac.getAtom(i).getSymbol();
            wt[i] = (Double) hash.get(sym);
        }
    }
    PCA pcaobject = null;
    try {
        pcaobject = new PCA(cmat, wt);
    } catch (CDKException cdke) {
        logger.debug(cdke);
    }
    double[] lambda = pcaobject.getEigenvalues();
    double[] gamma = new double[3];
    double[] nu = new double[3];
    double[] eta = new double[3];
    for (int i = 0; i < 3; i++) sum += lambda[i];
    for (int i = 0; i < 3; i++) nu[i] = lambda[i] / sum;
    double[][] scores = pcaobject.getScores();
    for (int i = 0; i < 3; i++) {
        sum = 0.0;
        for (int j = 0; j < ac.getAtomCount(); j++) sum += scores[j][i] * scores[j][i] * scores[j][i] * scores[j][i];
        sum = sum / (lambda[i] * lambda[i] * ac.getAtomCount());
        eta[i] = 1.0 / sum;
    }
    for (int i = 0; i < 3; i++) {
        double ns = 0.0;
        double na = 0.0;
        for (int j = 0; j < ac.getAtomCount(); j++) {
            boolean foundmatch = false;
            for (int k = 0; k < ac.getAtomCount(); k++) {
                if (k == j)
                    continue;
                if (scores[j][i] == -1 * scores[k][i]) {
                    ns++;
                    foundmatch = true;
                    break;
                }
            }
            if (!foundmatch)
                na++;
        }
        double n = (double) ac.getAtomCount();
        gamma[i] = -1.0 * ((ns / n) * Math.log(ns / n) / Math.log(2.0) + (na / n) * Math.log(1.0 / n) / Math.log(2.0));
        gamma[i] = 1.0 / (1.0 + gamma[i]);
    }
    double t = lambda[0] + lambda[1] + lambda[2];
    double a = lambda[0] * lambda[1] + lambda[0] * lambda[2] + lambda[1] * lambda[2];
    double v = t + a + lambda[0] * lambda[1] * lambda[2];
    double k = 0.0;
    sum = 0.0;
    for (int i = 0; i < 3; i++) sum += lambda[i];
    for (int i = 0; i < 3; i++) k = (lambda[i] / sum) - (1.0 / 3.0);
    k = k / (4.0 / 3.0);
    double g = Math.pow(gamma[0] * gamma[1] * gamma[2], 1.0 / 3.0);
    double d = eta[0] + eta[1] + eta[2];
    DoubleArrayResult retval = new DoubleArrayResult(11 + 6);
    retval.add(lambda[0]);
    retval.add(lambda[1]);
    retval.add(lambda[2]);
    retval.add(nu[0]);
    retval.add(nu[1]);
    retval.add(gamma[0]);
    retval.add(gamma[1]);
    retval.add(gamma[2]);
    retval.add(eta[0]);
    retval.add(eta[1]);
    retval.add(eta[2]);
    retval.add(t);
    retval.add(a);
    retval.add(v);
    retval.add(k);
    retval.add(g);
    retval.add(d);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), retval, getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/WHIMDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/WHIMDescriptor.java,"/**
     * Calculates 11 directional and 6 non-directional WHIM descriptors for.
     * the specified weighting scheme
     *
     * @param container Parameter is the atom container.
     * @return An ArrayList containing the descriptors in the order described above.
     */",301-450,"('calculate', {'INSTRUCTION': {'covered': 502, 'missed': 65}, 'BRANCH': {'covered': 31, 'missed': 11}, 'LINE': {'covered': 82, 'missed': 15}, 'COMPLEXITY': {'covered': 16, 'missed': 6}, 'METHOD': {'covered': 1, 'missed': 0}})",1163.0,10.0,Calculates 11 directional and 6 non-directional WHIM descriptors for.,"For the specified weighting scheme, calculate 11 directional and 6 non-directional WHIM descriptors",11 and 6 WHIM descriptors were calculated.,0.578668099220741,Calculates 11 directional WHIM descriptors and 6 non-directional WHIM descriptors for.," public DescriptorValue calculate(IAtomContainer container){
        try {
            return calculate(container, type);
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }",Not Valid,Not Valid," public DescriptorValue calculate(IAtomContainer container){
        try {
            return calculate(container, type);
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }",NOT PASS,Not Valid,NOT PASS,Not Valid,  0.021197123610448284,None,  0.021197123610448284,None,1135.0,0.9750859106529209,None,None,1135.0,0.9750859106529209,None,None,None,None,0.0,0.0,None,None,7.0,0.5,2.0,0.16666666666666666,5.0,0.5
185,cdk,"public boolean test(final int[] mapping){
    // n.b. not true for unspecified queries e.g. [C@?H](*)(*)*
    if (queryStereoIndices.length > targetStereoIndices.length)
        return false;
    // reset augment group config if it was initialised
    if (groupConfigAdjust != null)
        Arrays.fill(groupConfigAdjust, 0);
    for (final int u : queryStereoIndices) {
        switch(queryTypes[u]) {
            case Tetrahedral:
                if (!checkTetrahedral(u, mapping))
                    return false;
                break;
            case Geometric:
                if (!checkGeometric(u, otherIndex(u), mapping))
                    return false;
                break;
        }
    }
    return true;
}",test,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,"/**
     * Is the {@code mapping} of the stereochemistry in the query preserved in
     * the target.
     *
     * @param mapping permutation of the query vertices
     * @return the stereo chemistry is value
     */",104-132,"('test', {'INSTRUCTION': {'covered': 56, 'missed': 4}, 'BRANCH': {'covered': 11, 'missed': 2}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 6, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",103.0,18.0,Is the {@code mapping} of the stereochemistry in the query preserved in  the target.,The {@code} mapping of the stereochemistry in the query is stored in the destination,Is the query preserved in the target?,0.223971332803513,  Is the {mapping @code} of the stereochemistry in the query preserved in the target?," public boolean test(final int[] mapping){
        // check if the mapping is valid
        if (mapping == null || mapping.length != query.getAtomCount())
            return false;
    
        // check if the mapping is a valid stereo mapping
        if (!isStereoMapping(mapping))
            return false;
    
        // check if the stereo elements are valid
        if (!isStereoElementsValid(mapping))
            return false;
    
        // check if the stereo elements are consistent
        if (!isStereoElementsConsistent(mapping))
            return false;
    
        // check if the stereo elements are consistent
        if (!isStereoElementsConsistent(mapping))
            return false;
    
        // check if the stereo elements are consistent
        if (!isStereoElementsConsistent(mapping))
            return false;
    
        // check if the stereo elements are consistent
        if (!isStereoElementsConsistent(mapping))
            return false;
    
        // check if the stereo elements are consistent
        if (!isStereoElementsConsistent(mapping))
            return false;
    
        // check if the stereo elements are consistent
        if (!isStereoElementsConsistent(mapping))
            return false;
    
        // check if the stereo elements are consistent
        if (!isStereoElementsConsistent(mapping))
            return false;
    
        // check if the stereo elements are consistent
        if (!isStereoElementsConsistent(mapping))
            return false;
    
        // check if the stereo elements are consistent
        if (!isStereoElementsConsistent(mapping))
            return false;
    
        // check if the stereo elements are consistent
        if (!isStereoElementsConsistent(mapping))
            return false;
    
        // check if the stereo elements are consistent
        if (!isStereoElementsConsistent(mapping))
            return false;
    
        // check if the stereo elements are consistent
        if (!isStereoElementsConsistent(mapping))
            return false;
    
        // check if the stereo elements are consistent
        if (!isStereo       
 }","public boolean test(final int[] mapping){
        // check if the mapping is valid
        if (mapping == null) return false;
        if (mapping.length != query.getAtomCount()) return false;
        if (mapping.length != target.getAtomCount()) return false;
    
        // check if the mapping is valid
        for (int i = 0; i < mapping.length; i++) {
            if (mapping[i] < 0 || mapping[i] >= target.getAtomCount()) return false;
        }
    
        // check if the mapping is valid
        for (int i = 0; i < mapping.length; i++) {
            if (mapping[i] < 0 || mapping[i] >= query.getAtomCount()) return false;
        }
    
        // check if the mapping is valid
        for (int i = 0; i < mapping.length; i++) {
            if (mapping[i] < 0 || mapping[i] >= target.getAtomCount()) return false;
        }
    
        // check if the mapping is valid
        for (int i = 0; i < mapping.length; i++) {
            if (mapping[i] < 0 || mapping[i] >= query.getAtomCount()) return false;
        }
    
        // check if the mapping is valid
        for (int i = 0; i < mapping.length; i++) {
            if (mapping[i] < 0 || mapping[i] >= target.getAtomCount()) return false;
        }
    
        // check if the mapping is valid
        for (int i = 0; i < mapping.length; i++) {
            if (mapping[i] < 0 || mapping[i] >= query.getAtomCount()) return false;
        }
    
        // check if the mapping is valid
        for (int i = 0; i < mapping.length; i++) {
            if (mapping[i] < 0 || mapping[i] >= target.getAtomCount()) return false;
        }
    
        // check if the mapping is valid
        for (int i = 0; i < mapping.length; i++)        
 }",Not Valid,Not Valid,Syntax Error,Syntax Error,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,7.0,0.4666666666666667,3.0,0.2,8.0,0.5333333333333333
186,cdk,"private void parseMolCXSMILES(String title, IAtomContainer mol) throws InvalidSmilesException{
    CxSmilesState cxstate;
    int pos;
    if (title != null && title.startsWith(""|"")) {
        if ((pos = CxSmilesParser.processCx(title, cxstate = new CxSmilesState())) >= 0) {
            mol.setTitle(title.substring(pos));
            final Map<IAtom, IAtomContainer> atomToMol = new HashMap<>(2 * mol.getAtomCount());
            final List<IAtom> atoms = new ArrayList<>(mol.getAtomCount());
            for (IAtom atom : mol.atoms()) {
                atoms.add(atom);
                atomToMol.put(atom, mol);
            }
            assignCxSmilesInfo(mol.getBuilder(), mol, atoms, atomToMol, cxstate);
        }
    }
}",parseMolCXSMILES,org/openscience/cdk/smiles/SmilesParser.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/SmilesParser.java,"/**
     * Parses CXSMILES layer and set attributes for atoms and bonds on the provided molecule.
     *
     * @param title SMILES title field
     * @param mol   molecule
     */",301-327,"('parseMolCXSMILES', {'INSTRUCTION': {'covered': 65, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",159.0,15.0,Parses CXSMILES layer and set attributes for atoms and bonds on the provided molecule.,"Allows the CXSMILES level to be analysed. In addition, the molecule bonds provided and the attributes for the atoms.",Parses the layer and sets the attributes for the atoms and bonds.,0.342214737536253,  Analyzes the CXSMILES layer and defines the attributes of atoms and bonds on the supplied molecule.,Not Valid,"private void parseMolCXSMILES(String title, IAtomContainer mol) throws InvalidSmilesException{
        if (title != null) {
            mol.setProperty(CDKConstants.TITLE, title);
        }
    
        // CXSMILES layer
        if (mol.getAtomCount() > 0) {
            String cxsmiles = mol.getProperty(CDKConstants.CXSMILES).toString();
            if (cxsmiles != null) {
                String[] cxsmilesParts = cxsmiles.split(""\\s+"");
                if (cxsmilesParts.length == mol.getAtomCount()) {
                    for (int i = 0; i < cxsmilesParts.length; i++) {
                        String cxsmilesPart = cxsmilesParts[i];
                        if (cxsmilesPart.length() > 0) {
                            IAtom atom = mol.getAtom(i);
                            atom.setProperty(CDKConstants.CXSMILES, cxsmilesPart);
                            String[] cxsmilesPartParts = cxsmilesPart.split(""\\."");
                            if (cxsmilesPartParts.length == 2) {
                                atom.setProperty(CDKConstants.CXSMILES_ATOM_ID, cxsmilesPartParts[0]);
                                atom.setProperty(CDKConstants.CXSMILES_ATOM_ATTRIBUTE, cxsmilesPartParts[1]);
                            }
                        }
                    }
                }
            }
        }
    }",Not Valid,"private void parseMolCXSMILES(String title, IAtomContainer mol) throws InvalidSmilesException{
        if (title != null) {
            String[] parts = title.split(""\\s+"");
            if (parts.length > 0) {
                String[] attrs = parts[0].split("":"");
                if (attrs.length > 1) {
                    String[] attr = attrs[1].split("","");
                    if (attr.length > 1) {
                        mol.setProperty(CDKConstants.TITLE, attrs[0]);
                        mol.setProperty(CDKConstants.SMILES, parts[0]);
                        mol.setProperty(CDKConstants.SMILES_ATOM_ATTRIBUTE, attr[0]);
                        mol.setProperty(CDKConstants.SMILES_BOND_ATTRIBUTE, attr[1]);
                    }
                }
            }
        }       
 }",Not Valid,NOT PASS,NOT PASS,Not Valid,None,  0.35935176489985077,  0.2749512996911163,None,None,None,147.0,0.7170731707317073,114.0,0.7125,None,None,204.0,0.9951219512195122,150.0,0.9933774834437086,None,None,16.0,0.8,6.0,0.35294117647058826,9.0,0.6
187,matsim-libs,"public static double calcEndOfPlanElement(final double now, final PlanElement pe, Config config){
    Preconditions.checkArgument(Double.isFinite(now));
    if (pe instanceof Activity) {
        Activity act = (Activity) pe;
        return PopulationUtils.decideOnActivityEndTime(act, now, config).seconds();
    } else {
        double ttime = PopulationUtils.decideOnTravelTimeForLeg((Leg) pe).orElse(0);
        return now + ttime;
    }
}",calcEndOfPlanElement,org/matsim/core/router/TripRouter.java,/matsim/src/main/java/org/matsim/core/router/TripRouter.java,"/**
         * Helper method, that can be used to compute start time of legs.
         * (it is also used internally).
         * It is provided here, because such an operation is mainly useful for routing,
         * but it may be externalized in a ""util"" class...
         * @param config TODO
         */",202-224,"('calcEndOfPlanElement', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,14.0,"Helper method, that can be used to compute start time of legs.",Allows the calculation of the start time of routes (is also used internally).,The method can be used to calculate the start time of legs.,0.617405881626939,"  Assistance method, which can be used to calculate the start time of the legs."," public static double calcEndOfPlanElement(final double now, final PlanElement pe, Config config){
	 if (pe instanceof Leg) {
		 return now + ((Leg) pe).getTravelTime();
	 } else if (pe instanceof Activity) {
		 return now + ((Activity) pe).getEndTime();
	 } else {
		 throw new RuntimeException(""unknown plan element: "" + pe);
	 }
 }"," public static double calcEndOfPlanElement(final double now, final PlanElement pe, Config config){
	 if (pe instanceof Leg) {
		 return now + ((Leg) pe).getTravelTime();
	 } else if (pe instanceof Activity) {
		 return now + ((Activity) pe).getEndTime();
	 } else {
		 throw new RuntimeException(""unknown plan element: "" + pe);
	 }
 }"," public static double calcEndOfPlanElement(final double now, final PlanElement pe, Config config){
		if (pe instanceof Leg) {
			Leg leg = (Leg) pe;
			return now + leg.getTravelTime().seconds() + config.plansCalcRoute().getTeleportationTransitWalkFactor() * leg.getTravelTime().seconds();
		} else if (pe instanceof Activity) {
			Activity act = (Activity) pe;
			return now + act.getEndTime();
		} else if (pe instanceof Transit		
 }"," public static double calcEndOfPlanElement(final double now, final PlanElement pe, Config config){
		if (pe instanceof Leg) {
			Leg leg = (Leg) pe;
			return now + leg.getTravelTime().seconds() + config.plansCalcRoute().getTeleportationTransitWalkFactor() * leg.getTravelTime().seconds();
		} else if (pe instanceof Activity) {
			Activity act = (Activity) pe;
			return now + act.getEndTime();
		} else {
			throw new RuntimeException(""unknown plan element: "" + pe);
		}
	}",NOT PASS,NOT PASS,NOT PASS,Syntax Error,  0.4195331959403704,  0.4195331959403704,  0.5589535456655834,None,53.0,0.5955056179775281,53.0,0.5955056179775281,64.0,0.6037735849056604,61.0,0.61,0.0,0.0,38.0,0.3584905660377358,47.0,0.47,13.0,0.9285714285714286,5.0,0.3333333333333333,5.0,0.38461538461538464
188,cdk,"private static String breakExtractor(String formula){
    boolean finalBreak = false;
    int innerMostBracket = formula.lastIndexOf(""("");
    if (innerMostBracket < 0)
        return formula;
    String finalformula = formula.substring(0, innerMostBracket);
    String multipliedformula = """";
    String formulaEnd = """";
    String multiple = """";
    for (int f = innerMostBracket + 1; f < formula.length(); f++) {
        char thisChar = formula.charAt(f);
        if (finalBreak) {
            if (isDigit(thisChar)) {
                multiple += thisChar;
            } else {
                formulaEnd = formula.substring(f, formula.length());
                break;
            }
        } else {
            if (thisChar == ')') {
                finalBreak = true;
            } else
                multipliedformula += thisChar;
        }
    }
    finalformula += muliplier(multipliedformula, multiple.isEmpty() ? 1 : Integer.valueOf(multiple)) + formulaEnd;
    if (finalformula.contains(""(""))
        return breakExtractor(finalformula);
    else
        return finalformula;
}",breakExtractor,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * The parenthesis convention is used to show a quantity by which a formula is multiplied.
     * For example: (C12H20O11)2 really means that a C24H40O22 unit.
     *
     * @param formula Formula to correct
     * @return        Formula with the correction
     */",1398-1441,"('breakExtractor', {'INSTRUCTION': {'covered': 99, 'missed': 2}, 'BRANCH': {'covered': 13, 'missed': 1}, 'LINE': {'covered': 21, 'missed': 1}, 'COMPLEXITY': {'covered': 7, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",195.0,16.0,The parenthesis convention is used to show a quantity by which a formula is multiplied.,"To indicate a quantity by which a formula is multiplied, the convention of brackets is used ",The quantity is shown by using the parenthesis convention.,0.0849403989108162,  The parenthesis convention is used to show a quantity by which a formula is multiplied.,"private static String breakExtractor(String formula){
        String newFormula = formula;
        if (formula.contains(""("")) {
            int pos = formula.indexOf('(');
            newFormula = formula.substring(0, pos);
        }
        return newFormula;      
 }","private static String breakExtractor(String formula){
        String newFormula = formula;
        if (formula.contains(""("")) {
            int pos = formula.indexOf('(');
            newFormula = formula.substring(0, pos);
        }
        return newFormula;      
 }","private static String breakExtractor(String formula){
        String newFormula = formula;
        if (formula.contains(""("")) {
            int pos = newFormula.indexOf('(');
            String thisFormula = newFormula.substring(0, pos);
            if (thisFormula.charAt(0) >= '0' && thisFormula.charAt(0) <= '9')
                thisFormula = multipleExtractor(thisFormula);
    
            if (thisFormula.contains(""("")) thisFormula = breakExtractor(thisFormula);
    
            newFormula = thisFormula + newFormula.substring(pos, newFormula.length());
        }
        return newFormula;      
 }","private static String breakExtractor(String formula){
        String newFormula = formula;
        String thisFormula = """";
        String thisElement = """";
        String thisElementCount = """";
        String thisElementCountString = """";
        String thisElementSymbol = """";
        String thisElementSymbolString = """";
        String thisElementSymbolString2 = """";
        String thisElementSymbolString3 = """";
        String thisElementSymbolString4 = """";
        String thisElementSymbolString5 = """";
        String thisElementSymbolString6 = """";
        String thisElementSymbolString7 = """";
        String thisElementSymbolString8 = """";
        String thisElementSymbolString9 = """";
        String thisElementSymbolString10 = """";
        String thisElementSymbolString11 = """";
        String thisElementSymbolString12 = """";
        String thisElementSymbolString13 = """";
        String thisElementSymbolString14 = """";
        String thisElementSymbolString15 = """";
        String thisElementSymbolString16 = """";
        String thisElementSymbolString17 = """";
        String thisElementSymbolString18 = """";
        String thisElementSymbolString19 = """";
        String thisElementSymbolString20 = """";
        String thisElementSymbolString21 = """";
        String thisElementSymbolString22 = """";
        String thisElementSymbolString23 = """";
        String thisElementSymbolString24 = """";
        String thisElementSymbolString25 = """";
        String thisElementSymbolString26 = """";
        String thisElementSymbolString27 = """";
        String thisElementSymbolString28 = """";
        String thisElementSymbolString29 = """";
        String thisElementSymbolString30 = """";
        String thisElementSymbolString31 = """";
        String thisElementSymbolString32 = """";
        String thisElementSymbolString33 = """";
        String thisElementSymbolString34 = """";
        String thisElementSymbolString35 = """";
        String thisElementSymbolString36 = """";
        String thisElementSymbolString37 = """";      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.12308616466254274,  0.12308616466254274,  0.08852463045011894,  0.23253760972168452,157.0,0.8010204081632653,157.0,0.8010204081632653,181.0,0.8008849557522124,141.0,0.7193877551020408,0.0,0.0,205.0,0.9070796460176991,64.0,0.5714285714285714,14.0,0.8235294117647058,0.0,0.0,12.0,0.75
189,anserini,"public static String documentContents(IndexReader reader, String docid){
    try {
        return reader.document(convertDocidToLuceneDocid(reader, docid)).get(IndexArgs.CONTENTS);
    } catch (Exception e) {
        return null;
    }
}",documentContents,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,"/**
   * Returns the ""contents"" field of a document based on a collection docid. The method is named to be consistent with
   * Lucene's {@link IndexReader#document(int)}, contra Java's standard method naming conventions.
   *
   * @param reader index reader
   * @param docid collection docid
   * @return the ""contents"" field the document
   */",555-570,"('documentContents', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,15.0,"Returns the ""contents"" field of a document based on a collection docid.","  Based on a docid collection, the 'content' field of a document is returned. The method name is consistent with Lucene {@link IndexReader#document(int)}, whereas it is at odds with the naming conventions of Java's standard methods.",The field of the document is based on the collection docid.,0.361831735177235,"  Returns the ""contents"" field of a document based on a collection docid."," public static String documentContents(IndexReader reader, String docid){
    try {
      return reader.document(convertDocidToLuceneDocid(reader, docid)).get(IndexArgs.CONTENTS);
    } catch (Exception e) {
      // Eat any exceptions and just return null.
      return null;
    }
  }"," public static String documentContents(IndexReader reader, String docid){
    try {
      return reader.document(convertDocidToLuceneDocid(reader, docid)).get(IndexArgs.CONTENTS);
    } catch (Exception e) {
      // Eat any exceptions and just return null.
      return null;
    }
  }"," public static String documentContents(IndexReader reader, String docid){
    try {
      return reader.document(convertDocidToLuceneDocid(reader, docid)).get(IndexArgs.CONTENTS);
    } catch (Exception e) {
      // Eat any exceptions and just return null.
      return null;
    }
  }"," public static String documentContents(IndexReader reader, String docid){
    try {
      return reader.document(convertDocidToLuceneDocid(reader, docid)).get(IndexArgs.CONTENTS);
    } catch (Exception e) {
      // Eat any exceptions and just return null.
      return null;
    }
  }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,30.0,0.8333333333333334,0.0,0.0,6.0,0.46153846153846156
190,cdk,"public DescriptorValue calculate(IAtomContainer mol){
    this.mol = mol;
    excavateMolecule();
    int nSmallRings = smallRings.length;
    int nAromRings = 0;
    int nRingBlocks = 0;
    int nAromBlocks = countAromaticComponents();
    int nRings3 = 0, nRings4 = 0, nRings5 = 0, nRings6 = 0, nRings7 = 0, nRings8 = 0, nRings9 = 0;
    for (int[] r : smallRings) {
        final int sz = r.length;
        if (sz == 3)
            nRings3++;
        else if (sz == 4)
            nRings4++;
        else if (sz == 5)
            nRings5++;
        else if (sz == 6)
            nRings6++;
        else if (sz == 7)
            nRings7++;
        else if (sz == 8)
            nRings8++;
        else if (sz == 9)
            nRings9++;
        boolean aromatic = true;
        for (int n = 0; n < r.length; n++) if (!bondArom[findBond(r[n], r[n < sz - 1 ? n + 1 : 0])]) {
            aromatic = false;
            break;
        }
        if (aromatic)
            nAromRings++;
    }
    for (int n = ringBlock.length - 1; n >= 0; n--) nRingBlocks = Math.max(nRingBlocks, ringBlock[n]);
    IntegerArrayResult result = new IntegerArrayResult();
    result.add(nSmallRings);
    result.add(nAromRings);
    result.add(nRingBlocks);
    result.add(nAromBlocks);
    result.add(nRings3);
    result.add(nRings4);
    result.add(nRings5);
    result.add(nRings6);
    result.add(nRings7);
    result.add(nRings8);
    result.add(nRings9);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), result, NAMES);
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/SmallRingDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/SmallRingDescriptor.java,"/**
     * Performs the calculation: the graph will be analyzed and ring information will be determined and wrapped
     * up into descriptors.
     *
     * @param mol the atoms and bonds that make up the molecular object
     * @return the various ring-based descriptors generated
     */",136-197,"('calculate', {'INSTRUCTION': {'covered': 169, 'missed': 18}, 'BRANCH': {'covered': 17, 'missed': 9}, 'LINE': {'covered': 36, 'missed': 7}, 'COMPLEXITY': {'covered': 8, 'missed': 6}, 'METHOD': {'covered': 1, 'missed': 0}})",363.0,21.0,Performs the calculation: the graph will be analyzed and ring information will be determined and wrapped  up into descriptors.,"The method allows the actual atom polarisability of a given atom to be calculated. From the tools.HydrogenAdder class, the method addExplicitHydrogensToSatisfyValency",The graph will be analyzed and ring information wrapped up into descriptors.,1.00134881130705,  Perform the calculation: the graph will be analyzed and the information in the ring will be determined and wrapped in descriptors.,"public DescriptorValue calculate(IAtomContainer mol){
        this.mol = mol;
        int nAtoms = mol.getAtomCount();
        int nBonds = mol.getBondCount();
        int nRings = 0;
        int nAromRings = 0;
        int nRingBlocks = 0;
        int nAromBlocks = 0;
        int nRings3 = 0;
        int nRings4 = 0;
        int nRings5 = 0;
        int nRings6 = 0;
        int nRings7 = 0;
        int nRings8 = 0;
        int nRings9 = 0;
    
        // precalculate aromaticity
        bondArom = new boolean[nBonds];
        for (IBond bond : mol.bonds()) {
            if (bond.getFlag(CDKConstants.ISAROMATIC)) {
                bondArom[bond.getAtom(0).getIndex()] = true;
                bondArom[bond.getAtom(1).getIndex()] = true;
            }
        }
    
        // precalculate bond order
        bondOrder = new int[nBonds];
        for (IBond bond : mol.bonds()) {
            bondOrder[bond.getIndex()] = bond.getOrder().numeric();
        }
    
        // precalculate pi-atoms
        piAtom = new boolean[nAtoms];
        for (IBond bond : mol.bonds()) {
            if (bond.getOrder().numeric() == 2) {
                piAtom[bond.getAtom(0).getIndex()] = true;
                piAtom[bond.getAtom(1).getIndex()] = true;
            }
        }
    
        // precalculate implicit hydrogens
        implicitH = new int[nAtoms];
        for (IAtom atom : mol.atoms()) {
            implicitH[atom.getIndex()] = atom.getImplicitHydrogenCount();
        }
    
        // precalculate adjacency information       
 }","public DescriptorValue calculate(IAtomContainer mol){
        this.mol = mol;
        IChemObjectBuilder builder = mol.getBuilder();
        int nAtoms = mol.getAtomCount();
        int nBonds = mol.getBondCount();
        int nRings = 0;
        int nAromRings = 0;
        int nRingBlocks = 0;
        int nAromBlocks = 0;
        int nRings3 = 0;
        int nRings4 = 0;
        int nRings5 = 0;
        int nRings6 = 0;
        int nRings7 = 0;
        int nRings8 = 0;
        int nRings9 = 0;
        int nRings10 = 0;
        int nRings11 = 0;
        int nRings12 = 0;
        int nRings13 = 0;
        int nRings14 = 0;
        int nRings15 = 0;
        int nRings16 = 0;
        int nRings17 = 0;
        int nRings18 = 0;
        int nRings19 = 0;
        int nRings20 = 0;
        int nRings21 = 0;
        int nRings22 = 0;
        int nRings23 = 0;
        int nRings24 = 0;
        int nRings25 = 0;
        int nRings26 = 0;
        int nRings27 = 0;
        int nRings28 = 0;
        int nRings29 = 0;
        int nRings30 = 0;
        int nRings31 = 0;
        int nRings32 = 0;
        int nRings33 = 0;
        int nRings34 = 0;
        int nRings35 = 0;
        int nRings36 = 0;
        int nRings37 = 0;
        int nRings38 = 0;
        int nRings39 = 0;
        int nRings40 = 0;
        int nRings41 = 0;
        int nRings42 = 0;
        int nRings43 = 0;       
 }",Not Valid,"public DescriptorValue calculate(IAtomContainer mol){
        this.mol = mol;
        int nAtoms = mol.getAtomCount();
        int nBonds = mol.getBondCount();
        int nRings = 0;
        int nAromRings = 0;
        int nRingBlocks = 0;
        int nAromBlocks = 0;
        int nRings3 = 0;
        int nRings4 = 0;
        int nRings5 = 0;
        int nRings6 = 0;
        int nRings7 = 0;
        int nRings8 = 0;
        int nRings9 = 0;
        int nSmallRings = 0;
        int nAromatic = 0;
        int nNonAromatic = 0;
        int nAromaticBlocks = 0;
        int nNonAromaticBlocks = 0;
        int nAromaticRings = 0;
        int nNonAromaticRings = 0;
        int nAromaticRingBlocks = 0;
        int nNonAromaticRingBlocks = 0;
        int nAromaticRingBlocks3 = 0;
        int nNonAromaticRingBlocks3 = 0;
        int nAromaticRingBlocks4 = 0;
        int nNonAromaticRingBlocks4 = 0;
        int nAromaticRingBlocks5 = 0;
        int nNonAromaticRingBlocks5 = 0;
        int nAromaticRingBlocks6 = 0;
        int nNonAromaticRingBlocks6 = 0;
        int nAromaticRingBlocks7 = 0;
        int nNonAromaticRingBlocks7 = 0;
        int nAromaticRingBlocks8 = 0;
        int nNonAromaticRingBlocks8 = 0;
        int nAromaticRingBlocks9 = 0;
        int nNonAromaticRingBlocks9 = 0;
        int nAromaticRingBlocks10 = 0;
        int nNonAromaticRingBlocks10 = 0;
        int nAromaticRingBlocks11 = 0;
        int nNonAromaticRingBlocks11 = 0;
        int nAromaticRing       
 }",NOT PASS,NOT PASS,Syntax Error,Not Valid,  0.1721312574501273,  0.13715636226541986,None,None,266.0,0.7307692307692307,289.0,0.7939560439560439,283.0,0.7774725274725275,None,None,199.0,0.6633333333333333,191.0,0.6366666666666667,None,None,19.0,0.8636363636363636,7.0,0.3181818181818182,8.0,0.4
191,cdk,"private void layoutCyclicParts() throws CDKException{
    logger.debug(""Start of layoutNextRingSystem()"");
    resetUnplacedRings();
    IAtomContainer placedAtoms = AtomPlacer.getPlacedAtoms(molecule);
    logger.debug(""Finding attachment bond to already placed part..."");
    IBond nextRingAttachmentBond = getNextBondWithUnplacedRingAtom();
    if (nextRingAttachmentBond != null) {
        logger.debug(""...bond found."");
        IAtom ringAttachmentAtom = getRingAtom(nextRingAttachmentBond);
        IAtom chainAttachmentAtom = getOtherBondAtom(ringAttachmentAtom, nextRingAttachmentBond);
        IRingSet nextRingSystem = getRingSystemOfAtom(ringSystems, ringAttachmentAtom);
        IAtomContainer ringSystem = RingSetManipulator.getAllInOneContainer(nextRingSystem);
        Point2d oldRingAttachmentAtomPoint = ringAttachmentAtom.getPoint2d();
        Point2d oldChainAttachmentAtomPoint = chainAttachmentAtom.getPoint2d();
        layoutRingSet(firstBondVector, nextRingSystem);
        AtomPlacer.markNotPlaced(placedAtoms);
        IAtomContainer placedRingSubstituents = ringPlacer.placeRingSubstituents(nextRingSystem, bondLength);
        ringSystem.add(placedRingSubstituents);
        AtomPlacer.markPlaced(placedAtoms);
        logger.debug(""Computing translation/rotation of new ringset to fit old attachment bond orientation..."");
        Point2d oldPoint2 = oldRingAttachmentAtomPoint;
        Point2d oldPoint1 = oldChainAttachmentAtomPoint;
        Point2d newPoint2 = ringAttachmentAtom.getPoint2d();
        Point2d newPoint1 = chainAttachmentAtom.getPoint2d();
        logger.debug(""oldPoint1: "" + oldPoint1);
        logger.debug(""oldPoint2: "" + oldPoint2);
        logger.debug(""newPoint1: "" + newPoint1);
        logger.debug(""newPoint2: "" + newPoint2);
        double oldAngle = GeometryUtil.getAngle(oldPoint2.x - oldPoint1.x, oldPoint2.y - oldPoint1.y);
        double newAngle = GeometryUtil.getAngle(newPoint2.x - newPoint1.x, newPoint2.y - newPoint1.y);
        double angleDiff = oldAngle - newAngle;
        logger.debug(""oldAngle: "" + oldAngle + "", newAngle: "" + newAngle + ""; diff = "" + angleDiff);
        Vector2d translationVector = new Vector2d(oldPoint1);
        translationVector.sub(new Vector2d(newPoint1));
        GeometryUtil.translate2D(ringSystem, translationVector);
        GeometryUtil.rotate(ringSystem, oldPoint1, angleDiff);
        logger.debug(""...done translating/rotating new ringset to fit old attachment bond orientation."");
    } else {
        logger.debug(""...no bond found"");
        if (ringSystems != null) {
            for (IRingSet ringset : ringSystems) {
                for (IAtomContainer ring : ringset.atomContainers()) ringPlacer.completePartiallyPlacedRing(ringset, (IRing) ring, bondLength);
                if (allPlaced(ringset))
                    ringPlacer.placeRingSubstituents(ringset, bondLength);
            }
        }
    }
    logger.debug(""End of layoutNextRingSystem()"");
}",layoutCyclicParts,org/openscience/cdk/layout/StructureDiagramGenerator.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/StructureDiagramGenerator.java,"/**
     * Does the layout for the next RingSystem that is connected to those parts of
     * the molecule that have already been laid out. Finds the next ring with an
     * unplaced ring atom and lays out this ring. Then lays out the ring substituents
     * of this ring. Then moves and rotates the laid out ring to match the position
     * of its attachment bond to the rest of the molecule.
     *
     * @throws CDKException if an error occurs
     */",1902-2009,"('layoutCyclicParts', {'INSTRUCTION': {'covered': 236, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 47, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",420.0,23.0,Does the layout for the next RingSystem that is connected to those parts of  the molecule that have already been laid out.,"Arrange the next RingSystem connected to the parts of the molecule already arranged. After finding the next ring with an atom from the unplaced ring, arranges it. At this point he draws the ring substituents of this ring. Finally, move and rotate the drawn ring so that the position of its attachment bond matches the rest of the molecule.",Does the layout for the next RingSystem connect to the parts of the molecule that have already been laid out?,0.513928689027366,  Makes the arrangement for the next RingSystem that is connected to the parts of the molecule that have already been arranged.,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,53.0,0.8833333333333333,5.0,0.21739130434782608,5.0,0.21739130434782608
192,openapi-generator," static ValidationRule empty(){
    return new ValidationRule(Severity.ERROR, ""empty"", ""failure message"", (i) -> Fail.empty());
}",empty,org/openapitools/codegen/validation/ValidationRule.java,/modules/openapi-generator-core/src/main/java/org/openapitools/codegen/validation/ValidationRule.java,"/**
     * Constructs an empty rule (useful for testing).
     *
     * @return An ""empty"" rule.
     */",87-94,"('empty', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,10.0,Constructs an empty rule (useful for testing).,An empty line useful for testing is constructed,"Useful for testing, this rule is empty.",0.589437476510427,  Constructs an empty rule (useful for testing).,"  static ValidationRule empty(){
    return new ValidationRule(Severity.WARNING, """", """", o -> Result.success());         
  }","  static ValidationRule empty(){
    return new ValidationRule(Severity.WARNING, """", """", (o) -> Result.success());           
  }","  static ValidationRule empty(){
    return new ValidationRule(Severity.WARNING, """", """", o -> Result.success());
  }","  static ValidationRule empty(){
    return new ValidationRule(Severity.WARNING, """", """", o -> Result.success());         
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3867819874216908,  0.5163711397052634,  0.3867819874216908,  0.3867819874216908,8.0,0.25806451612903225,6.0,0.1935483870967742,8.0,0.25806451612903225,8.0,0.25806451612903225,2.0,0.06451612903225806,0.0,0.0,0.0,0.0,7.0,0.7777777777777778,0.0,0.0,7.0,0.875
193,dataverse,"public TabularDataIngest read(BufferedInputStream stream, File dataFile) throws IOException{
    init();
    if (stream == null) {
        throw new IOException(BundleUtil.getStringFromBundle(""ingest.csv.nullStream""));
    }
    TabularDataIngest ingesteddata = new TabularDataIngest();
    DataTable dataTable = new DataTable();
    BufferedReader localBufferedReader = new BufferedReader(new InputStreamReader(stream));
    File tabFileDestination = File.createTempFile(""data-"", "".tab"");
    PrintWriter tabFileWriter = new PrintWriter(tabFileDestination.getAbsolutePath());
    int lineCount = readFile(localBufferedReader, dataTable, tabFileWriter);
    logger.fine(""Tab file produced: "" + tabFileDestination.getAbsolutePath());
    dataTable.setUnf(""UNF:6:NOTCALCULATED"");
    ingesteddata.setTabDelimitedFile(tabFileDestination);
    ingesteddata.setDataTable(dataTable);
    return ingesteddata;
}",read,edu/harvard/iq/dataverse/ingest/tabulardata/impl/plugins/csv/CSVFileReader.java,/src/main/java/edu/harvard/iq/dataverse/ingest/tabulardata/impl/plugins/csv/CSVFileReader.java,"/**
     * Reads a CSV file, converts it into a dataverse DataTable.
     *
     * @param stream a <code>BufferedInputStream</code>.
     * @return an <code>TabularDataIngest</code> object
     * @throws java.io.IOException if a reading error occurs.
     */",105-137,"('read', {'INSTRUCTION': {'covered': 58, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",141.0,12.0,"Reads a CSV file, converts it into a dataverse DataTable.",Converts a CSV file into a table of data.,A dataverse DataTable is created when acsv file is read and converted.,0.798439070162964,"  Reads a CSV file, converts it to DataTable dataverse.",Empty Method,Empty Method,Not Valid,Empty Method,Empty Method,Empty Method,Empty Method,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,7.0,0.6363636363636364,4.0,0.36363636363636365,12.0,0.9230769230769231
194,twilio-java,"private static String replace(String string, boolean replaceSlash){
    if (string == null || string.isEmpty()) {
        return string;
    }
    StringBuffer buffer = new StringBuffer(string.length());
    Matcher matcher = TOKEN_REPLACE_PATTERN.matcher(string);
    while (matcher.find()) {
        String replacement = matcher.group(0);
        if (""+"".equals(replacement)) {
            replacement = ""%20"";
        } else if (""*"".equals(replacement)) {
            replacement = ""%2A"";
        } else if (""%7E"".equals(replacement)) {
            replacement = ""~"";
        } else if (replaceSlash && ""%2F"".equals(replacement)) {
            replacement = ""/"";
        }
        matcher.appendReplacement(buffer, replacement);
    }
    matcher.appendTail(buffer);
    return buffer.toString();
}",replace,com/twilio/jwt/validation/RequestCanonicalizer.java,/src/main/java/com/twilio/jwt/validation/RequestCanonicalizer.java,"/**
     * Replaces the special characters in the URLEncoded string with the replacement values defined by the spec.
     *
     * Partially copied from https://github.com/aws/aws-sdk-java: com.amazonaws.util.SdkHttpUtils (2017-05-19)
     *
     * @param string       the string to replace characters in
     * @param replaceSlash whether the encoded '/' should be replaced
     * @return the string after replacements
     */",168-201,"('replace', {'INSTRUCTION': {'covered': 66, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",161.0,17.0,Replaces the special characters in the URLEncoded string with the replacement values defined by the spec.,"In the URLEncoded string, special characters are replaced on the basis of the replacement values defined by the specification.",The special characters in the URLEncoded string are replaced with the replacement values defined by the spec.,0.333147191174338,  Replaces the special characters in the URLEncoded string with the replacement values defined by the specification.,"private static String replace(String string, boolean replaceSlash){
        String replacedString = string.replace(""+"", ""%20"");
        replacedString = replacedString.replace(""*"", ""%2A"");
        replacedString = replacedString.replace(""%7E"", ""~"");
        replacedString = replacedString.replace(""%2F"", ""/"");
        if(replaceSlash){
            replacedString = replacedString.replace(""%2F"", ""/"");
        }
        return replacedString;
    }","private static String replace(String string, boolean replaceSlash){
        String replacedString = string.replace(""+"", ""%20"");
        replacedString = replacedString.replace(""*"", ""%2A"");
        replacedString = replacedString.replace(""%7E"", ""~"");
        replacedString = replacedString.replace(""%2F"", ""/"");
        if(replaceSlash){
            replacedString = replacedString.replace(""%2F"", ""/"");
        }
        return replacedString;
    }","private static String replace(String string, boolean replaceSlash){
        String replacedString = string.replace(""+"", ""%20"");
        replacedString = replacedString.replace(""*"", ""%2A"");
        replacedString = replacedString.replace(""%7E"", ""~"");
        replacedString = replacedString.replace(""%2F"", ""/"");
        if(replaceSlash){
            replacedString = replacedString.replace(""%2F"", ""/"");
        }
        return replacedString;
    }","private static String replace(String string, boolean replaceSlash){
        String replacedString = string.replace(""+"", ""%20"");
        replacedString = replacedString.replace(""*"", ""%2A"");
        replacedString = replacedString.replace(""%7E"", ""~"");
        replacedString = replacedString.replace(""%2F"", ""/"");
        if(replaceSlash){
            replacedString = replacedString.replace(""%2F"", ""/"");
        }
        return replacedString;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.15573343137927131,  0.15573343137927131,  0.17898924533275967,  0.17898924533275967,116.0,0.7160493827160493,116.0,0.7160493827160493,116.0,0.7160493827160493,116.0,0.7160493827160493,0.0,0.0,0.0,0.0,0.0,0.0,10.0,0.5,1.0,0.058823529411764705,4.0,0.2222222222222222
195,dcache,"public static boolean isExemptFromNamespaceChecks(Subject subject){
    return subject.getPrincipals().stream().anyMatch(p -> p instanceof UidPrincipal && ((UidPrincipal) p).getUid() == 0 || p instanceof ExemptFromNamespaceChecks);
}",isExemptFromNamespaceChecks,org/dcache/auth/Subjects.java,/modules/common/src/main/java/org/dcache/auth/Subjects.java,"/**
     * Return true if the subject is root or has the special ExemptFromNamespaceChecks principal.
     *
     * @param subject The identity of the user.
     * @return if the user is except from namespace checks.
     * @see #isRoot(javax.security.auth.Subject)
     */",70-82,"('isExemptFromNamespaceChecks', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,14.0,Return true if the subject is root or has the special ExemptFromNamespaceChecks principal.,In the case where the object is root or has the special principle ExemptFromNamespaceChecks returns true ,"If the subject is root, return true.",0.197727867705204,  Return true if the object is root or has the special Principal ExemptFromNamespaceChecks.," public static boolean isExemptFromNamespaceChecks(Subject subject){
        return isRoot(subject) || subject.getPrincipals().contains(ExemptFromNamespaceChecks.INSTANCE);
    }"," public static boolean isExemptFromNamespaceChecks(Subject subject){
        return isRoot(subject) || hasPrincipal(subject, ExemptFromNamespaceChecks.class);
    }"," public static boolean isExemptFromNamespaceChecks(Subject subject){
        return isRoot(subject);
    }"," public static boolean isExemptFromNamespaceChecks(Subject subject){
        return isRoot(subject) || subject.getPrincipals().contains(ExemptFromNamespaceChecks.INSTANCE);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.34191180635162227,  0.25357122602151744,  0.34191180635162227,  0.22850829901621922,28.0,0.5833333333333334,30.0,0.625,28.0,0.5833333333333334,33.0,0.6875,8.0,0.26666666666666666,0.0,0.0,13.0,0.43333333333333335,8.0,0.47058823529411764,3.0,0.21428571428571427,10.0,0.7142857142857143
196,jackson-databind,"protected void _removeUnwantedProperties(Map<String, POJOPropertyBuilder> props){
    Iterator<POJOPropertyBuilder> it = props.values().iterator();
    while (it.hasNext()) {
        POJOPropertyBuilder prop = it.next();
        if (!prop.anyVisible()) {
            it.remove();
            continue;
        }
        if (prop.anyIgnorals()) {
            if (!prop.isExplicitlyIncluded()) {
                it.remove();
                _collectIgnorals(prop.getName());
                continue;
            }
            prop.removeIgnored();
            if (!prop.couldDeserialize()) {
                _collectIgnorals(prop.getName());
            }
        }
    }
}",_removeUnwantedProperties,com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java,/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java,"/**
     * Method called to get rid of candidate properties that are marked
     * as ignored.
     */",884-914,"('_removeUnwantedProperties', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",132.0,14.0,Method called to get rid of candidate properties that are marked  as ignored.,Allows the deletion of candidate properties flagged as ignored.,Candidate properties marked as ignored are thrown out.,0.564805981882159,  Method called to get rid of candidate properties marked as ignored.," protected void _removeUnwantedProperties(Map<String, POJOPropertyBuilder> props){
        if (_ignoredPropertyNames != null) {
            for (Iterator<Map.Entry<String, POJOPropertyBuilder>> it = props.entrySet().iterator(); it.hasNext();) {
                Map.Entry<String, POJOPropertyBuilder> entry = it.next();
                if (_ignoredPropertyNames.contains(entry.getKey())) {
                    it.remove();
                }
            }
        }
    }"," protected void _removeUnwantedProperties(Map<String, POJOPropertyBuilder> props){
        if (_ignoredPropertyNames != null) {
            for (String name : _ignoredPropertyNames) {
                props.remove(name);
            }
        }
    }"," protected void _removeUnwantedProperties(Map<String, POJOPropertyBuilder> props){
        if (_ignorableProps != null) {
            for (Iterator<String> it = _ignorableProps.iterator(); it.hasNext();) {
                String key = it.next();
                POJOPropertyBuilder prop = props.remove(key);
                if (prop != null) {
                    prop.removeIgnored();
                }
            }
        }
    }"," protected void _removeUnwantedProperties(Map<String, POJOPropertyBuilder> props){
        if (_ignorableProps != null) {
            for (String key : _ignorableProps) {
                props.remove(key);
            }
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.41765069683507605,  0.11135569185026725,  0.11135569185026725,  0.4128299053689969,81.0,0.6090225563909775,104.0,0.7819548872180451,104.0,0.7819548872180451,81.0,0.6090225563909775,60.0,0.6382978723404256,62.0,0.6595744680851063,35.0,0.3723404255319149,8.0,0.5714285714285714,2.0,0.14285714285714285,12.0,0.8571428571428571
197,tablesaw,"public static Function<Table, Selection> neither(Function<Table, Selection> sel1, Function<Table, Selection> sel2){
    return new Not(either(sel1, sel2));
}",neither,tech/tablesaw/api/QuerySupport.java,/core/src/main/java/tech/tablesaw/api/QuerySupport.java,"/**
   * Returns a selection for all records that match neither of the given functions. In other words,
   * if either (or both) of sel1 or sel2 is {@code true}, the record as a whole is {@code false}.
   */",26-33,"('neither', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,14.0,Returns a selection for all records that match neither of the given functions.,This method returns all records that do not match any of the specified functions. ,A selection is returned for records that do not match the functions.,0.402104749852766,  Returns a selection for all records that do not match any of the given functions.,"public static Function<Table, Selection> neither(Function<Table, Selection> sel1, Function<Table, Selection> sel2){
    return new Or(sel1, sel2);    
 }","public static Function<Table, Selection> neither(Function<Table, Selection> sel1, Function<Table, Selection> sel2){
    return new Or(sel1, sel2);    
 }","public static Function<Table, Selection> neither(Function<Table, Selection> sel1, Function<Table, Selection> sel2){
    return new Not(new Or(sel1, sel2));   
 }","public static Function<Table, Selection> neither(Function<Table, Selection> sel1, Function<Table, Selection> sel2){
    return new Not(new Or(sel1, sel2));   
 }",NOT PASS,NOT PASS,PASS,PASS,  0.8437872331853737,  0.8437872331853737,  0.8863378752013158,  0.8863378752013158,4.0,0.0975609756097561,4.0,0.0975609756097561,2.0,0.047619047619047616,2.0,0.047619047619047616,0.0,0.0,4.0,0.09523809523809523,4.0,0.09523809523809523,8.0,0.5333333333333333,3.0,0.1875,9.0,0.6428571428571429
198,matsim-libs,"private static List<String> convertSkillsAttributeToList(Attributes attributes){
    if (attributes.getAttribute(ATTR_SKILLS) == null) {
        return new ArrayList<>();
    } else {
        return Arrays.asList(Objects.requireNonNull(attributes.getAttribute(ATTR_SKILLS)).toString().split("",""));
    }
}",convertSkillsAttributeToList,org/matsim/contrib/freight/utils/FreightUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/utils/FreightUtils.java,"/**
         * Converts the 'skills' attribute to a list of strings.
         *
         * @param attributes the {@link Attributes} container that is checked for the
         *                   skill(s) to be converted.
         * @return the {@link List} of skills, possibly empty, as parsed from the
         *         attribute.
         */",487-501,"('convertSkillsAttributeToList', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",64.0,11.0,Converts the 'skills' attribute to a list of strings.,Obtains a list of strings from the conversion of the 'skills' attribute,The skills attribute is converted to a list of strings.,0.623037492050315,  Converts the 'skills' attribute into a list of strings.," private static List<String> convertSkillsAttributeToList(Attributes attributes){
	 		String skillsString = attributes.getAttribute(ATTR_SKILLS);
 		if (skillsString == null) {
 			return Collections.emptyList();
 		}
 		String[] skills = skillsString.split("","");
 		List<String> skillsList = new ArrayList<String>(skills.length);
 		for (String skill : skills) {
 			skillsList.add(skill);
 		}
 		return Collections.unmodifiableList(skillsList);
 	}"," private static List<String> convertSkillsAttributeToList(Attributes attributes){
	 String skills = attributes.getAttribute(ATTR_SKILLS);
	 if(skills == null){
		 return Collections.emptyList();
	 }
	 String[] skillsArray = skills.split("","");
	 List<String> skillsList = new ArrayList<String>();
	 for(String skill : skillsArray){
		 skillsList.add(skill);
	 }
	 return skillsList;			
 }"," private static List<String> convertSkillsAttributeToList(Attributes attributes){
	 		String skillsString = attributes.getAttribute(ATTR_SKILLS);
 		if (skillsString == null) {
 			return Collections.emptyList();
 		}
 		String[] skills = skillsString.split("","");
 		List<String> skillList = new ArrayList<String>(skills.length);
 		for (String skill : skills) {
 			skillList.add(skill);
 		}
 		return skillList;
 	}"," private static List<String> convertSkillsAttributeToList(Attributes attributes){
	 		String skillsString = attributes.getAttribute(ATTR_SKILLS);
 		if (skillsString == null) {
 			return Collections.emptyList();
 		}
 		String[] skills = skillsString.split("","");
 		List<String> skillList = new ArrayList<String>(skills.length);
 		for (String skill : skills) {
 			skillList.add(skill);
 		}
 		return skillList;
 	}",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.479585476853713,  0.4910627095759096,  0.48209648703992847,  0.48209648703992847,53.0,0.5760869565217391,47.0,0.5595238095238095,49.0,0.5632183908045977,49.0,0.5632183908045977,13.0,0.14130434782608695,8.0,0.08695652173913043,8.0,0.08695652173913043,11.0,0.8461538461538461,1.0,0.1,5.0,0.45454545454545453
199,glowstone,"public void sendMessages(GlowSession session){
    if (!needsUpdate) {
        return;
    }
    int id = entity.entityId;
    if (entity instanceof GlowPlayer) {
        GlowPlayer player = (GlowPlayer) entity;
        if (player.getUniqueId().equals(session.getPlayer().getUniqueId())) {
            id = 0;
        }
    }
    session.send(new EntityPropertyMessage(id, properties));
    needsUpdate = false;
}",sendMessages,net/glowstone/entity/AttributeManager.java,/src/main/java/net/glowstone/entity/AttributeManager.java,"/**
     * Sends the managed entity's properties to the client, if the client's snapshot is stale.
     *
     * @param session the client's session
     */",56-74,"('sendMessages', {'INSTRUCTION': {'covered': 36, 'missed': 1}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 9, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",85.0,18.0,"Sends the managed entity's properties to the client, if the client's snapshot is stale.","If the client snapshot is obsolete, it allows the managed entity's properties to be sent to the client","If the client's snapshot is not fresh, the managed entity's properties are sent to them.",0.368012526730976,"  Sends the properties of the managed entity to the client, if the client snapshot is outdated."," public void sendMessages(GlowSession session){
        if (!needsUpdate) {
            return;
        }
        session.send(new EntityPropertyMessage(entity.entityId, properties));
        needsUpdate = false;
    }"," public void sendMessages(GlowSession session){
        if (!needsUpdate) {
            return;
        }
        session.send(new EntityPropertyMessage(entity.entityId, properties));
        needsUpdate = false;
    }"," public void sendMessages(GlowSession session){
        if (!needsUpdate) {
            return;
        }
        session.send(new EntityPropertyMessage(entity.entityId, properties));
        needsUpdate = false;
    }"," public void sendMessages(GlowSession session){
        if (!needsUpdate) {
            return;
        }
        session.send(new EntityPropertyMessage(entity.entityId, properties));
        needsUpdate = false;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2686536328254554,  0.2686536328254554,  0.2686536328254554,  0.2686536328254554,53.0,0.6162790697674418,53.0,0.6162790697674418,53.0,0.6162790697674418,53.0,0.6162790697674418,0.0,0.0,0.0,0.0,0.0,0.0,15.0,0.7894736842105263,7.0,0.4117647058823529,13.0,0.8125
200,cdk,"static Entry<String, Point2d[]> decodeEntry(String str){
    final int i = str.indexOf(' ');
    if (i < 0)
        throw new IllegalArgumentException();
    return new SimpleEntry<String, Point2d[]>(str.substring(0, i), decodeCoordinates(str.substring(i + 1)));
}",decodeEntry,org/openscience/cdk/layout/IdentityTemplateLibrary.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/IdentityTemplateLibrary.java,"/**
     * Create a library entry from a SMILES string with the coordinates suffixed in binary. The
     * entry should be created with {@link #encodeEntry(java.util.Map.Entry)} and not created
     * manually. Note, the entry is not added to the library.
     *
     * @param str input string
     * @return library entry
     */",231-243,"('decodeEntry', {'INSTRUCTION': {'covered': 20, 'missed': 4}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",72.0,15.0,Create a library entry from a SMILES string with the coordinates suffixed in binary.,"From a SMILES string with binary suffix coordinates creates a library entry. The entry must not be created manually but must be created with {@link #encodeEntry(java.util.Map.Entry)}. Furthermore, the entry is not added to the library.",The coordinates are added to the SMILES string in a way that makes it appear as if it is a library entry.,0.916836520408373,  Create a library entry from a SMILES string with the coordinates suffixed in binary.,"static Entry<String, Point2d[]> decodeEntry(String str){
        String[] parts = str.split(""\\s+"");
        String smiles = parts[0];
        Point2d[] points = new Point2d[parts.length - 1];
        for (int i = 1; i < parts.length; i++) {
            String[] coords = parts[i].split("","");
            points[i - 1] = new Point2d(Double.parseDouble(coords[0]), Double.parseDouble(coords[1]));
        }
        return new SimpleEntry<String, Point2d[]>(smiles, points);
    }","static Entry<String, Point2d[]> decodeEntry(String str){
        String[] parts = str.split(""\\s+"");
        String smiles = parts[0];
        Point2d[] points = new Point2d[parts.length-1];
        for (int i = 1; i < parts.length; i++) {
            String[] xy = parts[i].split("","");
            points[i-1] = new Point2d(Double.parseDouble(xy[0]), Double.parseDouble(xy[1]));
        }
        return new SimpleEntry<String, Point2d[]>(smiles, points);
    }","static Entry<String, Point2d[]> decodeEntry(String str){
        String[] parts = str.split(""\\s+"");
        String smiles = parts[0];
        Point2d[] points = new Point2d[parts.length-1];
        for (int i = 1; i < parts.length; i++) {
            String[] xy = parts[i].split("","");
            points[i-1] = new Point2d(Double.parseDouble(xy[0]), Double.parseDouble(xy[1]));
        }
        return new SimpleEntry<String, Point2d[]>(smiles, points);
    }","static Entry<String, Point2d[]> decodeEntry(String str){
        int idx = str.indexOf(' ');
        String smiles = str.substring(0, idx);
        String coords = str.substring(idx+1);
        byte[] bytes = Base64.getDecoder().decode(coords);
        ByteBuffer buf = ByteBuffer.wrap(bytes);
        int n = buf.getInt();
        Point2d[] points = new Point2d[n];
        for (int i = 0; i < n; i++) {
            double x = buf.getDouble();
            double y = buf.getDouble();
            points[i] = new Point2d(x, y);
        }
        return new SimpleEntry<String, Point2d[]>(smiles, points);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.48137668386170324,  0.48137668386170324,  0.6008080971823554,  0.48137668386170324,92.0,0.696969696969697,92.0,0.696969696969697,116.0,0.725,92.0,0.696969696969697,3.0,0.022727272727272728,97.0,0.60625,3.0,0.022727272727272728,30.0,0.8333333333333334,0.0,0.0,20.0,0.8695652173913043
201,cdk,"public Point3d calculate3DCoordinates3(Point3d aPoint, Point3d bPoint, Point3d cPoint, Point3d dPoint, double length){
    Vector3d bc = new Vector3d(bPoint);
    bc.sub(cPoint);
    Vector3d dc = new Vector3d(dPoint);
    dc.sub(cPoint);
    Vector3d ca = new Vector3d(cPoint);
    ca.sub(aPoint);
    Vector3d n1 = new Vector3d();
    Vector3d n2 = new Vector3d();
    n1.cross(bc, dc);
    n1.normalize();
    n1.scale(length);
    Vector3d ax = new Vector3d(aPoint);
    ax.add(n1);
    ax.sub(aPoint);
    Vector3d ax2 = new Vector3d(aPoint);
    ax2.add(n2);
    ax2.sub(aPoint);
    Point3d point = new Point3d(aPoint);
    double dotProduct = ca.dot(ax);
    double angle = Math.acos((dotProduct) / (ax.length() * ca.length()));
    if (angle < 1.5) {
        n2.cross(dc, bc);
        n2.normalize();
        n2.scale(length);
        point.add(n2);
    } else {
        point.add(n1);
    }
    bc = null;
    dc = null;
    ca = null;
    n1 = null;
    n2 = null;
    return point;
}",calculate3DCoordinates3,org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,"/**
     *  Calculate new point X in a B-A(-D)-C system. It forms a B-A(-D)(-C)-X
     *  system. (3) 3 ligands(B, C, D) of refAtom A (i) 1 points required; if A, B,
     *  C, D coplanar, no points. else vector is resultant of BA, CA, DA
     *
     *@param  aPoint  to which substituents are added
     *@param  bPoint  first ligand of A
     *@param  cPoint  second ligand of A
     *@param  dPoint  third ligand of A
     *@param  length  A-X length
     *@return         Point3d nwanted points (or null if failed (coplanar))
     */",496-552,"('calculate3DCoordinates3', {'INSTRUCTION': {'covered': 100, 'missed': 13}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 28, 'missed': 4}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",268.0,13.0,Calculate new point X in a B-A(-D)-C system.,From a system B-A(-D)-C calculate the new point X. Create a system B-A(-D)(-C)-X,"In a B-A(-D)-C system, calculate the new point X.",0.512710085220485,  Calculate the new X point in a B-A(-D)-C system.,"public Point3d calculate3DCoordinates3(Point3d aPoint, Point3d bPoint, Point3d cPoint, Point3d dPoint, double length){
        Point3d newPoint = new Point3d();
        Vector3d ba = new Vector3d(aPoint);
        ba.sub(bPoint);
        Vector3d ca = new Vector3d(aPoint);
        ca.sub(cPoint);
        Vector3d da = new Vector3d(aPoint);
        da.sub(dPoint);
        Vector3d baxca = new Vector3d();
        baxca.cross(ba, ca);
        Vector3d baxda = new Vector3d();
        baxda.cross(ba, da);
        baxca.normalize();
        baxda.normalize();
        baxca.scale(length);
        baxda.scale(length);
        newPoint.add(baxca);
        newPoint.add(baxda);
        return newPoint;        
 }","public Point3d calculate3DCoordinates3(Point3d aPoint, Point3d bPoint, Point3d cPoint, Point3d dPoint, double length){
        Point3d newPoint = new Point3d();
        Vector3d ba = new Vector3d(aPoint);
        ba.sub(bPoint);
        Vector3d ca = new Vector3d(aPoint);
        ca.sub(cPoint);
        Vector3d da = new Vector3d(aPoint);
        da.sub(dPoint);
        Vector3d baxca = new Vector3d();
        baxca.cross(ba, ca);
        Vector3d baxda = new Vector3d();
        baxda.cross(ba, da);
        baxca.normalize();
        baxda.normalize();
        baxca.scale(length);
        baxda.scale(length);
        newPoint.add(baxca);
        newPoint.add(baxda);
        return newPoint;        
 }","public Point3d calculate3DCoordinates3(Point3d aPoint, Point3d bPoint, Point3d cPoint, Point3d dPoint, double length){
        Point3d newPoint = new Point3d(aPoint);
        Vector3d ba = new Vector3d(aPoint);
        ba.sub(bPoint);
        Vector3d dc = new Vector3d(aPoint);
        dc.sub(dPoint);
        Vector3d baxdc = new Vector3d();
        baxdc.cross(ba, dc);
        baxdc.normalize();
        baxdc.scale(length);
        newPoint.add(baxdc);
        return newPoint;        
 }","public Point3d calculate3DCoordinates3(Point3d aPoint, Point3d bPoint, Point3d cPoint, Point3d dPoint, double length){
        Point3d newPoint = new Point3d();
        Vector3d ba = new Vector3d(aPoint);
        ba.sub(bPoint);
        Vector3d ca = new Vector3d(aPoint);
        ca.sub(cPoint);
        Vector3d da = new Vector3d(aPoint);
        da.sub(dPoint);
        Vector3d baxca = new Vector3d();
        baxca.cross(ba, ca);
        Vector3d baxda = new Vector3d();
        baxda.cross(ba, da);
        Vector3d caxda = new Vector3d();
        caxda.cross(ca, da);
        Vector3d ax = new Vector3d();
        ax.cross(baxca, caxda);
        ax.normalize();
        ax.scale(length);
        newPoint.add(aPoint);
        newPoint.add(ax);
        return newPoint;        
 }",PASS,PASS,PASS,PASS,  0.443410330315034,  0.443410330315034,  0.4797419327709117,  0.3458273844057654,153.0,0.5687732342007435,153.0,0.5687732342007435,142.0,0.5278810408921933,185.0,0.6877323420074349,0.0,0.0,32.0,0.18181818181818182,62.0,0.4,10.0,0.7142857142857143,3.0,0.3,9.0,0.9
202,acs-aem-commons," boolean needsUpdate(@Nonnull Resource ensureDefinition, @Nonnull Resource oakIndex) throws IOException, RepositoryException{
    final Session session = ensureDefinition.getResourceResolver().adaptTo(Session.class);
    final ChecksumGenerator checksumGenerator = this.ensureOakIndex.getChecksumGenerator();
    final CustomChecksumGeneratorOptions ensureDefinitionOptions = new CustomChecksumGeneratorOptions();
    ensureDefinitionOptions.addIncludedNodeTypes(new String[] { NT_OAK_UNSTRUCTURED });
    ensureDefinitionOptions.addExcludedProperties(this.ignoreProperties);
    ensureDefinitionOptions.addExcludedSubTrees(this.excludeSubTrees);
    ensureDefinitionOptions.addExcludedNodeNames(this.excludeNodeNames);
    final Map<String, String> srcChecksum = checksumGenerator.generateChecksums(session, ensureDefinition.getPath(), ensureDefinitionOptions);
    final CustomChecksumGeneratorOptions oakIndexOptions = new CustomChecksumGeneratorOptions();
    oakIndexOptions.addIncludedNodeTypes(new String[] { NT_OAK_QUERY_INDEX_DEFINITION });
    oakIndexOptions.addExcludedProperties(this.ignoreProperties);
    oakIndexOptions.addExcludedSubTrees(this.excludeSubTrees);
    oakIndexOptions.addExcludedNodeNames(this.excludeNodeNames);
    final Map<String, String> destChecksum = checksumGenerator.generateChecksums(session, oakIndex.getPath(), oakIndexOptions);
    return !StringUtils.equals(srcChecksum.get(ensureDefinition.getPath()), destChecksum.get(oakIndex.getPath()));
}",needsUpdate,com/adobe/acs/commons/oak/impl/EnsureOakIndexJobHandler.java,/bundle/src/main/java/com/adobe/acs/commons/oak/impl/EnsureOakIndexJobHandler.java,"/**
     * Determines if the ensure definition is the same as the the same-named oak:index definition.
     *
     * @param ensureDefinition the ensure index definition
     * @param oakIndex         the oak index definition
     * @return true if the ensure definition and the oak index definition are different
     * @throws IOException
     * @throws RepositoryException
     */",487-522,"('needsUpdate', {'INSTRUCTION': {'covered': 88, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",223.0,17.0,Determines if the ensure definition is the same as the the same-named oak:index definition.,Determines whether the definition of ensure is equal to the definition oak:index with the same name.,"If the ensure definition is the same as the oak: index definition, then it's a problem.",0.465933633308375,  Determines whether the warranty definition is the same as the oak:index definition of the same name.,"  boolean needsUpdate(@Nonnull Resource ensureDefinition, @Nonnull Resource oakIndex) throws IOException, RepositoryException{
        final ValueMap ensureDefinitionProperties = ensureDefinition.getValueMap();
        final ValueMap oakIndexProperties = oakIndex.getValueMap();
     
        // Check if the ensure definition is the same as the oak:index definition
        if (ensureDefinitionProperties.equals(oakIndexProperties)) {
            return false;
        }
     
        // Check if the ensure definition is the same as the oak:index definition, except for the type
        final ValueMap ensureDefinitionPropertiesCopy = new ValueMap(ensureDefinitionProperties);
        ensureDefinitionPropertiesCopy.remove(PN_TYPE);
        if (ensureDefinitionPropertiesCopy.equals(oakIndexProperties)) {
            return false;
        }
     
        return true;
     }      ","  boolean needsUpdate(@Nonnull Resource ensureDefinition, @Nonnull Resource oakIndex) throws IOException, RepositoryException{
        final ValueMap ensureDefinitionProperties = ensureDefinition.getValueMap();
        final ValueMap oakIndexProperties = oakIndex.getValueMap();
     
        if (ensureDefinitionProperties.get(PN_TYPE, """").equals(oakIndexProperties.get(PN_TYPE, """"))) {
            if (ensureDefinitionProperties.get(PN_TYPE, """").equals(DISABLED)) {
                return false;
            }
     
            if (ensureDefinitionProperties.get(PN_TYPE, """").equals(INDEX)) {
                return !ensureDefinitionProperties.get(PN_INDEX_NAME, """").equals(oakIndexProperties.get(PN_INDEX_NAME, """"));
            }
     
            if (ensureDefinitionProperties.get(PN_TYPE, """").equals(QUERY)) {
                return !ensureDefinitionProperties.get(PN_QUERY_NAME, """").equals(oakIndexProperties.get(PN_QUERY_NAME, """"));
            }
        }
     
        return true;
     }",Not Valid,"  boolean needsUpdate(@Nonnull Resource ensureDefinition, @Nonnull Resource oakIndex) throws IOException, RepositoryException{
        final ValueMap ensureDefinitionProperties = ensureDefinition.getValueMap();
        final ValueMap oakIndexProperties = oakIndex.getValueMap();
     
        if (!ensureDefinitionProperties.get(PN_TYPE, """").equals(oakIndexProperties.get(PN_TYPE, """"))) {
            log.info(""Skipping update... Oak Index at [ {} ] is of type [ {} ] and Ensure Definition is of type [ {} ]"",
                    oakIndex.getPath(), oakIndexProperties.get(PN_TYPE, """"), ensureDefinitionProperties.get(PN_TYPE, """"));
            return false;
        }
     
        if (!ensureDefinitionProperties.get(PN_NAME, """").equals(oakIndexProperties.get(PN_NAME, """"))) {
            log.info(""Skipping update... Oak Index at [ {} ] is named [ {} ] and Ensure Definition is named [ {} ]"",
                    oakIndex.getPath(), oakIndexProperties.get(PN_NAME, """"), ensureDefinitionProperties.get(PN_NAME, """"));
            return false;
        }
     
        if (!ensureDefinitionProperties.get(PN_DESCRIPTION, """").equals(oakIndexProperties.get(PN_DESCRIPTION, """"))) {
            log.info(""Skipping update... Oak Index at [ {} ] has description [ {} ] and Ensure Definition has description [ {} ]"",
                    oakIndex.getPath(), oakIndexProperties.get(PN_DESCRIPTION, """"), ensureDefinitionProperties.get(PN_DESCRIPTION, """"));
            return false;
        }
     
        if (!ensureDefinitionProperties.get(PN_QUERY, """").equals(oakIndexProperties.get(PN_QUERY, """"))) {
            log.info(""Skipping update... Oak Index at [ {} ] has query [ {} ] and Ensure Definition has query [ {} ]"",
                    oakIndex.getPath(), oakIndexProperties.get(PN_QUERY, """"), ensureDefinitionProperties.get(PN_QUERY, """"));
            return false;
        }
     
        if (!ensureDefinitionProperties.        
  }",NOT PASS,NOT PASS,Syntax Error,Not Valid,  0.15619780417078247,  0.20673705525246808,None,None,168.0,0.75,151.0,0.6741071428571429,196.0,0.6877192982456141,None,None,96.0,0.5614035087719298,210.0,0.7368421052631579,None,None,12.0,0.7058823529411765,8.0,0.47058823529411764,9.0,0.5294117647058824
203,cdk,"public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
    if (!isCachedAtomContainer(ac)) {
        Double[] org = new Double[ac.getAtomCount()];
        for (int i = 0; i < org.length; i++) org[i] = ac.getAtom(i).getCharge();
        IAtomContainer mol = atom.getBuilder().newInstance(IAtomContainer.class, ac);
        if (maxIterations != 0)
            peoe.setMaxGasteigerIters(maxIterations);
        try {
            peoe.assignGasteigerMarsiliSigmaPartialCharges(mol, true);
            for (int i = 0; i < ac.getAtomCount(); i++) {
                cacheDescriptorValue(ac.getAtom(i), ac, new DoubleResult(mol.getAtom(i).getCharge()));
            }
        } catch (Exception e) {
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(Double.NaN), NAMES, e);
        }
        for (int i = 0; i < org.length; i++) mol.getAtom(i).setCharge(org[i]);
    }
    return getCachedDescriptorValue(atom) != null ? new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), getCachedDescriptorValue(atom), NAMES) : null;
}",calculate,org/openscience/cdk/qsar/descriptors/atomic/PartialSigmaChargeDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/PartialSigmaChargeDescriptor.java,"/**
     *  The method returns apha partial charges assigned to an heavy atom through Gasteiger Marsili
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *  For this method will be only possible if the heavy atom has single bond.
     *
     *@param  atom              The IAtom for which the DescriptorValue is requested
     *@param  ac                AtomContainer
     *@return                   Value of the alpha partial charge
     */",120-152,"('calculate', {'INSTRUCTION': {'covered': 107, 'missed': 18}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 14, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",259.0,27.0,The method returns apha partial charges assigned to an heavy atom through Gasteiger Marsili  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.,"The partial apha charges assigned to a heavy atom via Gasteiger Marsili are returned by this method. From the class tools.HydrogenAdder it is necessary to call the method addExplicitHydrogensToSatisfyValency. If the heavy atom has a single bond, this method can be applied.",The method returns partial charges assigned to an heavy atom through Gasteiger Marsili.,0.535168093178731,  The method returns partial charges apha assigned to a heavy atom via Gasteiger Marsili It is necessary to call the method addExplicitHydrogensToSatisfyValency from the class tools.," public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
        try {
            peoe.setMaxIterations(maxIterations);
            peoe.calculate(ac);
            DoubleResult result = new DoubleResult(peoe.getPartialCharge(atom));
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), result,
                    atom.getSymbol());
        } catch (Exception e) {
            e.printStackTrace();
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(),
                    new DoubleResult(Double.NaN), atom.getSymbol());
        }
    }"," public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
        DescriptorValue result = new DescriptorValue();
        result.setNames(NAMES);
        result.setValue(calculatePartialSigmaCharge(atom, ac));
        return result;
    }","public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
        try {
            peoe.setMaxIterations(maxIterations);
            peoe.setAtomContainer(ac);
            peoe.calculate();
            double partialCharge = peoe.getPartialCharge(atom);
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(),
                    NAMES[0], new DoubleResult(partialCharge));
        } catch (Exception e) {
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(),
                    NAMES[0], new DoubleResult(Double.NaN));
        }
    }"," public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
        try {
            peoe.setMaxIterations(maxIterations);
            peoe.setAtomContainer(ac);
            peoe.addExplicitHydrogensToSatisfyValency(atom);
            double partialCharge = peoe.getPartialCharge(atom);
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(),
                    atom.getSymbol(), partialCharge);
        } catch (Exception e) {
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(),
                    atom.getSymbol(), Double.NaN);
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2718956893348462,  0.10565263792863688,  0.2458349524218068,  0.2540360127449375,186.0,0.7153846153846154,228.0,0.8769230769230769,187.0,0.7192307692307692,187.0,0.7192307692307692,82.0,0.7256637168141593,32.0,0.2831858407079646,36.0,0.3185840707964602,30.0,0.6976744186046512,7.0,0.25925925925925924,14.0,0.5185185185185185
204,cron-utils,"protected void isInRange(final FieldValue<?> fieldValue){
    if (fieldValue instanceof IntegerFieldValue) {
        final int value = ((IntegerFieldValue) fieldValue).getValue();
        if (!constraints.isInRange(value)) {
            throw new IllegalArgumentException(String.format(OORANGE, value, constraints.getStartRange(), constraints.getEndRange()));
        }
    }
}",isInRange,com/cronutils/model/field/expression/visitor/ValidationFieldExpressionVisitor.java,/src/main/java/com/cronutils/model/field/expression/visitor/ValidationFieldExpressionVisitor.java,"/**
     * Check if given number is greater or equal to start range and minor or equal to end range.
     *
     * @param fieldValue - to be validated
     * @throws IllegalArgumentException - if not in range
     */",117-131,"('isInRange', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,19.0,Check if given number is greater or equal to start range and minor or equal to end range.,Verifies whether the given number is less than or equal to the final range or greater than or equal to the initial range.,"If the number is greater or equal to the start range, you should check it.",0.308417110171343,  Check if the given number is greater than or equal to the beginning range and minor or equal to the end range.," protected void isInRange(final FieldValue<?> fieldValue){
        if (fieldValue instanceof IntegerFieldValue) {
            final int value = ((IntegerFieldValue) fieldValue).getValue();
            if (value < constraints.getStartRange() || value > constraints.getEndRange()) {
                throw new IllegalArgumentException(String.format(OORANGE, value, constraints.getStartRange(), constraints.getEndRange()));
            }
        }
    }"," protected void isInRange(final FieldValue<?> fieldValue){
        if (fieldValue instanceof IntegerFieldValue) {
            final int value = ((IntegerFieldValue) fieldValue).getValue();
            if (value < constraints.getMinValue() || value > constraints.getMaxValue()) {
                throw new IllegalArgumentException(String.format(OORANGE, value, constraints.getMinValue(), constraints.getMaxValue()));
            }
        }
    }"," protected void isInRange(final FieldValue<?> fieldValue){
        if (fieldValue instanceof IntegerFieldValue) {
            final int value = ((IntegerFieldValue) fieldValue).getValue();
            if (value < constraints.getStartRange() || value > constraints.getEndRange()) {
                throw new IllegalArgumentException(String.format(OORANGE, value, constraints.getStartRange(), constraints.getEndRange()));
            }
        }
    }"," protected void isInRange(final FieldValue<?> fieldValue){
        if (fieldValue instanceof IntegerFieldValue) {
            final int value = ((IntegerFieldValue) fieldValue).getValue();
            if (value < constraints.getRange().getFrom() || value > constraints.getRange().getTo()) {
                throw new IllegalArgumentException(String.format(OORANGE, value, constraints.getRange().getFrom(), constraints.getRange().getTo()));
            }
        }       
 }",PASS,NOT PASS,NOT PASS,PASS,  0.7818685870301492,  0.7483657367914208,  0.6976126794955606,  0.7818685870301492,10.0,0.12048192771084337,12.0,0.14457831325301204,28.0,0.2828282828282828,10.0,0.12048192771084337,4.0,0.04819277108433735,20.0,0.20202020202020202,0.0,0.0,12.0,0.5,5.0,0.21739130434782608,12.0,0.631578947368421
205,cdk,"private boolean verify(int n, int m){
    for (int n_prime : g1[n]) {
        boolean found = false;
        for (int m_prime : g2[m]) {
            if (matrix.get(n_prime, m_prime) && bondMatcher.matches(bond1.get(n, n_prime), bonds2.get(m, m_prime))) {
                found = true;
                break;
            }
        }
        if (!found)
            return false;
    }
    return true;
}",verify,org/openscience/cdk/isomorphism/UllmannState.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/UllmannState.java,"/**
     * Verify that for every vertex adjacent to n, there should be at least one
     * feasible candidate adjacent which can be mapped. If no such candidate
     * exists the mapping of n -> m is not longer valid.
     *
     * @param n query vertex
     * @param m target vertex
     * @return mapping is still valid
     */",196-217,"('verify', {'INSTRUCTION': {'covered': 69, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",94.0,23.0,"Verify that for every vertex adjacent to n, there should be at least one  feasible candidate adjacent which can be mapped.","For each vertex adjacent to n, it must be verified that there is at least one feasible adjacent candidate that can be mapped. The mapping of n -> m is no longer valid if there is no such candidate.",There should be at least one feasible candidate adjacent which can be mapped for every single vertex.,0.768304567711752,"  Verify that for each vertex adjacent to n, there must be at least one feasible adjacent candidate that can be mapped.","private boolean verify(int n, int m){
        for (int i = 0; i < g1[n].length; i++) {
            int n1 = g1[n][i];
            for (int j = 0; j < g2[m].length; j++) {
                int m1 = g2[m][j];
                if (matrix.get(n1, m1)) return true;
            }
        }
        return false;
    }","private boolean verify(int n, int m){
        for (int i = 0; i < g1[n].length; i++) {
            int n1 = g1[n][i];
            if (m1[n1] == UNMAPPED) {
                for (int j = 0; j < g2[m].length; j++) {
                    int m2 = g2[m][j];
                    if (m2 != UNMAPPED && bondMatcher.matches(bond1.getBond(n1), bonds2.getBond(m2))) {
                        return true;
                    }
                }
            }
        }
        return false;
    }","private boolean verify(int n, int m){
        for (int i = 0; i < g1[n].length; i++) {
            int m1 = g1[n][i];
            if (m1 == UNMAPPED) continue;
            for (int j = 0; j < g2[m].length; j++) {
                int m2 = g2[m][j];
                if (m2 == UNMAPPED) continue;
                if (matrix.get(m1, m2)) return true;
            }
        }
        return false;
    }","private boolean verify(int n, int m){
        for (int i : g1[n]) {
            if (m2[m] == UNMAPPED) {
                for (int j : g2[m]) {
                    if (matrix.get(i, j)) return true;
                }
            } else {
                if (matrix.get(i, m2[m])) return true;
            }
        }
        return false;       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5020935741479178,  0.4701423429640984,  0.5186300299348688,  0.5053634982282087,68.0,0.7157894736842105,78.0,0.6446280991735537,48.0,0.5052631578947369,76.0,0.6909090909090909,31.0,0.256198347107438,49.0,0.5212765957446809,20.0,0.18181818181818182,29.0,0.725,5.0,0.22727272727272727,14.0,0.6363636363636364
206,cdk,"static String dataHeader(final String line){
    if (line.length() > 2 && line.charAt(0) != '>' && line.charAt(1) != ' ')
        return null;
    int i = line.indexOf('<', 2);
    if (i < 0)
        return null;
    int j = line.indexOf('>', i);
    if (j < 0)
        return null;
    return line.substring(i + 1, j);
}",dataHeader,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Obtain the field name from a potential SD data header. If the header
     * does not contain a field name, then null is returned. The method does
     * not currently return field numbers (e.g. DT&lt;n&gt;).
     *
     * @param line an input line
     * @return the field name
     */",2292-2307,"('dataHeader', {'INSTRUCTION': {'covered': 39, 'missed': 2}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",95.0,11.0,Obtain the field name from a potential SD data header.,"From a potential SD data header, obtain the field name. Null is returned if the header does not contain a field name. The method currently does not return field numbers (e.g. DT&lt;n&gt;).",Obtain the field name from the data.,0.264300389980479,  Get the field name from a potential SD data header.,"static String dataHeader(final String line){
        if (line.startsWith("">"")) {
            return line.substring(1, line.indexOf('<')).trim();
        }
        return null;
    }","static String dataHeader(final String line){
        if (line.length() < 3) return null;
        if (line.charAt(0) != '>') return null;
        if (line.charAt(1) != ' ') return null;
        if (line.charAt(2) != '<') return null;
        return line.substring(3, line.indexOf('>', 3));
    }","static String dataHeader(final String line){
        if (line.startsWith(""> "")) {
            return line.substring(2).trim();
        }
        return null;
    }","static String dataHeader(final String line){
        if (line.startsWith("">"")) {
            return line.substring(1).trim();
        }
        return null;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.21005093941538514,  0.5009182924166774,  0.1990386854741698,  0.19812207436499601,61.0,0.6354166666666666,49.0,0.5104166666666666,66.0,0.6875,65.0,0.6770833333333334,52.0,0.6265060240963856,7.0,0.1590909090909091,9.0,0.20454545454545456,29.0,0.8787878787878788,1.0,0.09090909090909091,5.0,0.45454545454545453
207,cdk,"private static int[][] findAromaticRings(int[][] cycles, int[] contribution, int[] dbs){
    boolean found;
    boolean[] checked = new boolean[cycles.length];
    final boolean[] aromaticAtoms = new boolean[contribution.length];
    final List<int[]> ringsOfSize6 = new ArrayList<int[]>();
    final List<int[]> ringsOfSize5 = new ArrayList<int[]>();
    do {
        found = false;
        for (int i = 0; i < cycles.length; i++) {
            int[] cycle = cycles[i];
            int len = cycle.length - 1;
            if (checked[i])
                continue;
            if (isAromaticRing(cycle, contribution, dbs, aromaticAtoms)) {
                checked[i] = true;
                found |= true;
                for (int j = 0; j < len; j++) {
                    aromaticAtoms[cycle[j]] = true;
                }
                if (len == 6)
                    ringsOfSize6.add(cycle);
                else if (len == 5)
                    ringsOfSize5.add(cycle);
            }
        }
    } while (found);
    List<int[]> rings = new ArrayList<int[]>();
    rings.addAll(ringsOfSize6);
    rings.addAll(ringsOfSize5);
    return rings.toArray(new int[rings.size()][]);
}",findAromaticRings,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,"/**
     * From a provided set of cycles find the 5/6 member cycles that fit the MMFF aromaticity
     * definition - {@link #isAromaticRing(int[], int[], int[], boolean[])}. The cycles of size 6
     * are listed first.
     *
     * @param cycles       initial set of cycles from
     * @param contribution vector of p electron contributions from each vertex
     * @param dbs          vector of double-bond pairs, index stored double-bonded index
     * @return the cycles that are aromatic
     */",113-168,"('findAromaticRings', {'INSTRUCTION': {'covered': 103, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 22, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",283.0,42.0,"From a provided set of cycles find the 5/6 member cycles that fit the MMFF aromaticity  definition - {@link #isAromaticRing(int[], int[], int[], boolean[])}.","From a given set of cycles, it is necessary to find the 5/6 member cycles that satisfy the MMFF definition of aromaticity - {@link #isAromaticRing(int[], int[], boolean[])}. Cycles of size 6 are listed first.",The MMFF aromaticity definition states that the 6 member cycles fit the definition.,0.941336864741545,"From a set of cycles provided, find the 5/6 member cycles that correspond to the definition of aromaticity of MMFF - {@link #isAromaticRing(int[], int[], int[], boolean[])}."," private static int[][] findAromaticRings(int[][] cycles, int[] contribution, int[] dbs){
        List<int[]> rings = new ArrayList<int[]>();
        for (int[] cycle : cycles) {
            if (isAromaticRing(cycle, contribution, dbs, false)) {
                rings.add(cycle);
            }
        }
        return rings.toArray(new int[rings.size()][]);
    }"," private static int[][] findAromaticRings(int[][] cycles, int[] contribution, int[] dbs){
        List<int[]> rings = new ArrayList<int[]>();
        for (int[] cycle : cycles) {
            if (isAromaticRing(cycle, contribution, dbs)) {
                rings.add(cycle);
            }
        }
        return rings.toArray(new int[rings.size()][]);
    }","private static int[][] findAromaticRings(int[][] cycles, int[] contribution, int[] dbs){
        int[][] rings = new int[cycles.length][];
        for (int i = 0; i < cycles.length; i++) {
            int[] cycle = cycles[i];
            int len = cycle.length - 1;
            if (len == 6) {
                rings[i] = cycle;
            }
        }
        return rings;       
 }"," private static int[][] findAromaticRings(int[][] cycles, int[] contribution, int[] dbs){
        List<int[]> rings = new ArrayList<int[]>();
        for (int[] cycle : cycles) {
            if (isAromaticRing(cycle, contribution, dbs, false)) {
                rings.add(cycle);
            }
        }
        return rings.toArray(new int[rings.size()][]);      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3013162849532576,  0.29868286378115183,  0.28860442054647795,  0.2797338785139365,191.0,0.6725352112676056,192.0,0.676056338028169,191.0,0.6725352112676056,191.0,0.6725352112676056,2.0,0.02040816326530612,0.0,0.0,59.0,0.5841584158415841,18.0,0.5142857142857142,8.0,0.2962962962962963,18.0,0.75
208,cdk,"public void addMapping(IMapping mapping){
    if (mappingCount + 1 >= map.length)
        growMappingArray();
    map[mappingCount] = mapping;
    mappingCount++;
    notifyChanged();
}",addMapping,org/openscience/cdk/Reaction.java,/base/data/src/main/java/org/openscience/cdk/Reaction.java,"/**
     * Adds a mapping between the reactant and product side to this
     * Reaction.
     *
     * @param mapping Mapping to add.
     * @see   #mappings
     */",411-424,"('addMapping', {'INSTRUCTION': {'covered': 23, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,13.0,Adds a mapping between the reactant and product side to this  Reaction.,A mapping is added between the reactant side and the product side of this Reaction.,A mapping between the reactant and product side is added.,0.863825027459556,  Adds a mapping between the reactive side and the product side to this reaction.," public void addMapping(IMapping mapping){
        mappings.add(mapping);
        notifyChanged();        
 }"," public void addMapping(IMapping mapping){
        mappings.add(mapping);
        notifyChanged();        
 }"," public void addMapping(IMapping mapping){
        mappings.add(mapping);
        notifyChanged();        
 }"," public void addMapping(IMapping mapping){
        mappings.add(mapping);
        notifyChanged();        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3769075260021675,  0.3769075260021675,  0.3769075260021675,  0.3769075260021675,20.0,0.5263157894736842,20.0,0.5263157894736842,20.0,0.5263157894736842,20.0,0.5263157894736842,0.0,0.0,0.0,0.0,0.0,0.0,7.0,0.4375,4.0,0.26666666666666666,5.0,0.38461538461538464
209,cdk,"public boolean add(IAtomContainer atomContainer){
    if (this.atomContainer == null) {
        this.atomContainer = atomContainer;
        title = (String) atomContainer.getTitle();
    }
    if (title == null) {
        throw new IllegalArgumentException(""At least one of the input molecules does not have a title"");
    }
    if (!title.equals(atomContainer.getTitle()))
        throw new IllegalArgumentException(""The input molecules does not have the same title ('"" + title + ""') as the other conformers ('"" + atomContainer.getTitle() + ""')"");
    if (atomContainer.getAtomCount() != this.atomContainer.getAtomCount())
        throw new IllegalArgumentException(""Doesn't have the same number of atoms as the rest of the conformers"");
    coordinates.add(getCoordinateList(atomContainer));
    return true;
}",add,org/openscience/cdk/ConformerContainer.java,/base/data/src/main/java/org/openscience/cdk/ConformerContainer.java,"/**
     * Add a conformer to the end of the list.
     * 
     * This method allows you to add a IAtomContainer object as another conformer.
     * Before adding it ensures that the title of specific object matches the
     * stored title for these conformers. It will also check that the number of
     * atoms in the specified molecule match the number of atoms in the current set
     * of conformers.
     * 
     * This method will not check for duplicate conformers.
     *
     * @param atomContainer The new conformer to add.
     * @return true
     */",220-252,"('add', {'INSTRUCTION': {'covered': 54, 'missed': 10}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 10, 'missed': 2}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",120.0,10.0,Add a conformer to the end of the list.,A conformer is added to the end of the list. The addition of an AtomContainer object as another conformer is permitted by the following method. Once it has been ensured that the title of the specific object matches the title stored for these conformers it is added.,The end of the list should have a conformer added to it.,0.376752516774774,  Add a conformer to the end of the list.," public boolean add(IAtomContainer atomContainer){
        if (title != null && !atomContainer.getTitle().equals(title))
            throw new IllegalArgumentException(""Titles of all molecules must match"");
        coordinates.add(getCoordinateList(atomContainer));
        return true;        
 }"," public boolean add(IAtomContainer atomContainer){
        if (atomContainer.getTitle() == null) throw new IllegalArgumentException(""Molecule must have a title"");
        if (!atomContainer.getTitle().equals(title)) throw new IllegalArgumentException(""Title of molecule must match stored title"");
        coordinates.add(getCoordinateList(atomContainer));
        return true;
    }","public boolean add(IAtomContainer atomContainer){
        if (atomContainer.getAtomCount() != this.atomContainer.getAtomCount())
            throw new IllegalArgumentException(""Molecule must have the same number of atoms"");
        if (atomContainer.getBondCount() != this.atomContainer.getBondCount())
            throw new IllegalArgumentException(""Molecule must have the same number of bonds"");
        if (atomContainer.getTitle() == null)
            throw new IllegalArgumentException(""Molecule must have a title"");
        if (!atomContainer.getTitle().equals(title))
            throw new IllegalArgumentException(""Molecule title must match"");
    
        Point3d[] tmp = getCoordinateList(atomContainer);
        coordinates.add(tmp);
        return true;        
 }"," public boolean add(IAtomContainer atomContainer){
        if (title != null && !title.equals(atomContainer.getTitle()))
            throw new IllegalArgumentException(""Titles of all molecules must match"");
        coordinates.add(getCoordinateList(atomContainer));
        return true;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2719198806330517,  0.33040961726833395,  0.2958775445202031,  0.5297800534496963,78.0,0.6446280991735537,64.0,0.5289256198347108,76.0,0.628099173553719,68.0,0.5619834710743802,17.0,0.2786885245901639,5.0,0.10416666666666667,73.0,0.6403508771929824,41.0,0.8541666666666666,0.0,0.0,12.0,0.9230769230769231
210,dcache,"public synchronized void remove(LoggerName logger, String appender){
    if (_rules.remove(logger, appender) != null) {
        clearCache();
    }
}",remove,dmg/util/logback/FilterThresholdSet.java,/modules/cells/src/main/java/dmg/util/logback/FilterThresholdSet.java,"/**
     * Removes the threshold of the given logger and appender combination in this threshold set. The
     * new effective threshold will be derived from the regular inheritance rules.
     */",151-159,"('remove', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,15.0,Removes the threshold of the given logger and appender combination in this threshold set.,"From the threshold set, it removes the threshold of the indicated logger and appender combination. From the regular inheritance rules the new threshold will be derived",The threshold of the given combination is removed.,0.386535814203195,  Removes the threshold from the given recorder and appendix combination in this threshold set.," public synchronized void remove(LoggerName logger, String appender){
        _rules.remove(logger, appender);
        clearCache();
    }"," public synchronized void remove(LoggerName logger, String appender){
        _rules.remove(logger, appender);
        clearCache();
    }"," public synchronized void remove(LoggerName logger, String appender){
        _rules.remove(logger, appender);
        clearCache();
    }"," public synchronized void remove(LoggerName logger, String appender){
        _rules.remove(logger, appender);
        clearCache();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7459596852508608,  0.7459596852508608,  0.7459596852508608,  0.7459596852508608,7.0,0.21212121212121213,7.0,0.21212121212121213,7.0,0.21212121212121213,7.0,0.21212121212121213,0.0,0.0,0.0,0.0,0.0,0.0,18.0,0.6666666666666666,3.0,0.2,9.0,0.6
211,cdk,"public void sortAtomContainers(final Comparator<IAtomContainer> comparator){
    Integer[] indexes = new Integer[atomContainerCount];
    for (int i = 0; i < indexes.length; i++) indexes[i] = i;
    Arrays.sort(indexes, new Comparator<Integer>() {

        @Override
        public int compare(Integer o1, Integer o2) {
            return comparator.compare(atomContainers[o1], atomContainers[o2]);
        }
    });
    IAtomContainer[] containersTmp = Arrays.copyOf(atomContainers, indexes.length);
    Double[] multipliersTmp = Arrays.copyOf(multipliers, indexes.length);
    for (int i = 0; i < indexes.length; i++) {
        atomContainers[i] = containersTmp[indexes[i]];
        multipliers[i] = multipliersTmp[indexes[i]];
    }
}",sortAtomContainers,org/openscience/cdk/AtomContainerSet.java,/base/data/src/main/java/org/openscience/cdk/AtomContainerSet.java,"/**
     * Sort the AtomContainers and multipliers using a provided Comparator.
     * @param comparator defines the sorting method
     */",408-439,"('sortAtomContainers', {'INSTRUCTION': {'covered': 67, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",170.0,10.0,Sort the AtomContainers and multipliers using a provided Comparator.,"Using a provided comparator, order the AtomContainers and multipliers",Sort the containers using a Comparator.,0.393783047494438,  Sort AtomContainers and multipliers using a provided comparator.,Not Valid,Not Valid," public void sortAtomContainers(final Comparator<IAtomContainer> comparator){
        Arrays.sort(atomContainers, comparator);
    }",Not Valid,Not Valid,Not Valid,Not Valid,NOT PASS,None,None,None,  0.06806921434239202,None,None,None,None,None,None,149.0,0.8713450292397661,None,None,None,None,22.0,0.9565217391304348,9.0,0.9,2.0,0.2,4.0,0.4
212,cdk,"static HydrogenPosition usingAngularExtent(final List<Vector2d> vectors){
    double[] extents = VecmathUtil.extents(vectors);
    Arrays.sort(extents);
    Map<HydrogenPosition, OffsetExtent> extentMap = new HashMap<HydrogenPosition, OffsetExtent>();
    for (int i = 0; i < extents.length; i++) {
        final double before = extents[i];
        final double after = extents[(i + 1) % extents.length];
        for (final HydrogenPosition position : values()) {
            final double bias = TAU - position.direction;
            double afterBias = after + bias;
            double beforeBias = before + bias;
            if (beforeBias >= TAU)
                beforeBias -= TAU;
            if (afterBias >= TAU)
                afterBias -= TAU;
            final double afterExtent = afterBias;
            final double beforeExtent = TAU - beforeBias;
            final double totalExtent = afterExtent + beforeExtent;
            final double offset = Math.abs(totalExtent / 2 - beforeExtent);
            OffsetExtent offsetExtent = extentMap.get(position);
            if (offsetExtent == null || totalExtent < offsetExtent.extent) {
                extentMap.put(position, new OffsetExtent(totalExtent, offset));
            }
        }
    }
    Set<Map.Entry<HydrogenPosition, OffsetExtent>> extentEntries = extentMap.entrySet();
    Map.Entry<HydrogenPosition, OffsetExtent> best = null;
    for (Map.Entry<HydrogenPosition, OffsetExtent> e : extentEntries) {
        if (best == null || ExtentPriority.INSTANCE.compare(e, best) < 0)
            best = e;
    }
    assert best != null;
    return best.getKey();
}",usingAngularExtent,org/openscience/cdk/renderer/generators/standard/HydrogenPosition.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/HydrogenPosition.java,"/**
     * Using the angular extents of vectors, determine the best position for a hydrogen label. The
     * position with the most space is selected first. If multiple positions have the same amount of
     * space, the one where the hydrogen position is most centred is selected. If all position are
     * okay, the priority is Right > Left > Above > Below.
     *
     * @param vectors directional vectors for each bond from an atom
     * @return best hydrogen position
     */",124-184,"('usingAngularExtent', {'INSTRUCTION': {'covered': 147, 'missed': 4}, 'BRANCH': {'covered': 20, 'missed': 2}, 'LINE': {'covered': 26, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",308.0,16.0,"Using the angular extents of vectors, determine the best position for a hydrogen label.","Determine the best position for a hydrogen label using the angular extremes of the vectors. We first select the position with the most space. The one where the hydrogen position is most centred is selected if several positions have the same amount of space. If all position are okay, the priority is Right > Left > Above > Below.",The best position for a hydrogen label is determined using the angular extents of the vectors.,0.387869030510431,"  Using the angular ranges of the vectors, determine the best position for a hydrogen label.","static HydrogenPosition usingAngularExtent(final List<Vector2d> vectors){
        final double[] angles = new double[vectors.size()];
        for (int i = 0; i < vectors.size(); i++) {
            angles[i] = Math.atan2(vectors.get(i).y, vectors.get(i).x);
        }
        Arrays.sort(angles);
        final double min = angles[0];
        final double max = angles[angles.length - 1];
        final double angle = (min + max) / 2;
        return usingCardinalDirection(new Vector2d(Math.cos(angle), Math.sin(angle)));      
 }",Not Valid,"static HydrogenPosition usingAngularExtent(final List<Vector2d> vectors){
        final double[] angles = new double[vectors.size()];
        for (int i = 0; i < vectors.size(); i++) {
            angles[i] = Math.atan2(vectors.get(i).y, vectors.get(i).x);
        }
        final double min = min(angles);
        final double max = max(angles);
        final double extent = max - min;
    
        if (extent > TAU / 2) {
            return Right;
        } else if (extent < -TAU / 2) {
            return Left;
        } else {
            return Above;
        }       
 }","static HydrogenPosition usingAngularExtent(final List<Vector2d> vectors){
        final double[] angles = new double[vectors.size()];
        for (int i = 0; i < vectors.size(); i++) {
            angles[i] = Math.atan2(vectors.get(i).y, vectors.get(i).x);
        }
    
        final double min = min(angles);
        final double max = max(angles);
    
        if (min < -TAU / 4 && max > TAU / 4) {
            return Above;
        } else if (min < -TAU / 4 && max < TAU / 4) {
            return Below;
        } else if (min > -TAU / 4 && max > TAU / 4) {
            return Right;
        } else if (min > -TAU / 4 && max < TAU / 4) {
            return Left;
        } else {
            return Right;
        }       
 }",NOT PASS,Not Valid,NOT PASS,NOT PASS,  0.219716117377549,None,  0.18812020701313,  0.19487918455446715,237.0,0.7669902912621359,None,None,237.0,0.7669902912621359,237.0,0.7669902912621359,None,None,89.0,0.4810810810810811,49.0,0.3475177304964539,54.0,0.9,2.0,0.125,16.0,0.9411764705882353
214,anserini,"public static Document document(IndexReader reader, String docid){
    try {
        return reader.document(IndexReaderUtils.convertDocidToLuceneDocid(reader, docid));
    } catch (Exception e) {
        return null;
    }
}",document,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,"/**
   * Returns the Lucene {@link Document} based on a collection docid. The method is named to be consistent with Lucene's
   * {@link IndexReader#document(int)}, contra Java's standard method naming conventions.
   *
   * @param reader index reader
   * @param docid collection docid
   * @return corresponding Lucene {@link Document}
   */",492-507,"('document', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,14.0,Returns the Lucene {@link Document} based on a collection docid.,"Based on the docid collection, it returns Lucene's {@link Document}. The method is called in order to be consistent with Lucene's {@link IndexReader#document(int)} as opposed to Java's standard method naming conventions.",The document is based on a collection docid.,0.319175158351138,  Returns the Lucene document {@link Document} based on a collection docid.,"public static Document document(IndexReader reader, String docid){
    int ldocid = convertDocidToLuceneDocid(reader, docid);
    if (ldocid == -1) {
      return null;
    }
    return reader.document(ldocid);   
 }","public static Document document(IndexReader reader, String docid){
    int ldocid = convertDocidToLuceneDocid(reader, docid);
    if (ldocid == -1) {
      return null;
    }
    return reader.document(ldocid);
  }","public static Document document(IndexReader reader, String docid){
    int ldocid = convertDocidToLuceneDocid(reader, docid);
    if (ldocid == -1) {
      return null;
    }
    return reader.document(ldocid);   
 }","public static Document document(IndexReader reader, String docid){
    int ldocid = convertDocidToLuceneDocid(reader, docid);
    if (ldocid == -1) {
      return null;
    }
    return reader.document(ldocid);   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6634925062767074,  0.6634925062767074,  0.6634925062767074,  0.6634925062767074,24.0,0.5454545454545454,24.0,0.5454545454545454,24.0,0.5454545454545454,24.0,0.5454545454545454,0.0,0.0,0.0,0.0,0.0,0.0,29.0,0.90625,1.0,0.08333333333333333,5.0,0.45454545454545453
215,glowstone,"public boolean readBoolean(@NonNls String key, Consumer<? super Boolean> consumer){
    return readTag(key, ByteTag.class, byteVal -> consumer.accept(byteVal != 0));
}",readBoolean,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to a byte subtag if it is present, converting it to boolean first.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */",498-509,"('readBoolean', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,19.0,"Applies the given function to a byte subtag if it is present, converting it to boolean first.","If it is present, it applies the given function to a byte subtag, converting it first to a Boolean ","If the function is present, apply it to a subtag and convert it to a string.",0.404176881911894,"  Applies the given function to a byte subtag if it is present, first converting it to Boolean.","public boolean readBoolean(@NonNls String key, Consumer<? super Boolean> consumer){
        return readTag(key, ByteTag.class, tag -> consumer.accept(tag.getValue() != 0));
    }","public boolean readBoolean(@NonNls String key, Consumer<? super Boolean> consumer){
        return readTag(key, ByteTag.class, tag -> consumer.accept(tag.getValue() != 0));
    }"," public boolean readBoolean(@NonNls String key, Consumer<? super Boolean> consumer){
        return readTag(key, BooleanTag.class, consumer);        
 }","public boolean readBoolean(@NonNls String key, Consumer<? super Boolean> consumer){
        return readTag(key, ByteTag.class, tag -> consumer.accept(tag.getValue() != 0));
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8113312587994382,  0.8113312587994382,  0.8113312587994382,  0.6328889792603816,6.0,0.13333333333333333,6.0,0.13333333333333333,6.0,0.13333333333333333,10.0,0.24390243902439024,0.0,0.0,0.0,0.0,14.0,0.3111111111111111,14.0,0.7,3.0,0.16666666666666666,13.0,0.7222222222222222
217,tablesaw,"public static boolean isAlphanumeric(final String cs){
    if (Strings.isNullOrEmpty(cs)) {
        return false;
    }
    final int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (!Character.isLetterOrDigit(cs.charAt(i))) {
            return false;
        }
    }
    return true;
}",isAlphanumeric,tech/tablesaw/util/StringUtils.java,/core/src/main/java/tech/tablesaw/util/StringUtils.java,"/**
   * Checks if the CharSequence contains only Unicode letters or digits.
   *
   * <p>{@code null} will return {@code false}. An empty CharSequence (length()=0) will return
   * {@code false}.
   *
   * <pre>
   * StringUtils.isAlphanumeric(null)   = false
   * StringUtils.isAlphanumeric("""")     = false
   * StringUtils.isAlphanumeric(""  "")   = false
   * StringUtils.isAlphanumeric(""abc"")  = true
   * StringUtils.isAlphanumeric(""ab c"") = false
   * StringUtils.isAlphanumeric(""ab2c"") = true
   * StringUtils.isAlphanumeric(""ab-c"") = false
   * </pre>
   *
   * @param cs the CharSequence to check, may be null
   * @return {@code true} if only contains letters or digits, and is non-null
   * @since 3.0 Changed signature from isAlphanumeric(String) to isAlphanumeric(CharSequence)
   * @since 3.0 Changed """" to return false and not true
   */",378-410,"('isAlphanumeric', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,11.0,Checks if the CharSequence contains only Unicode letters or digits.,Allows you to verify whether the character sequence contains only Unicode letters or digits.,The CharSequence contains only letters and digits.,0.676220004551006,  Checks whether charSequence contains only Unicode letters or numbers.,"public static boolean isAlphanumeric(final String cs){
    if (Strings.isNullOrEmpty(cs)) {
      return false;
    }
    final int sz = cs.length();
    for (int i = 0; i < sz; i++) {
      if (!Character.isLetterOrDigit(cs.charAt(i))) {
        return false;
      }
    }
    return true;    
 }","public static boolean isAlphanumeric(final String cs){
    if (Strings.isNullOrEmpty(cs)) {
      return false;
    }
    final int sz = cs.length();
    for (int i = 0; i < sz; i++) {
      if (!Character.isLetterOrDigit(cs.charAt(i))) {
        return false;
      }
    }
    return true;
  }","public static boolean isAlphanumeric(final String cs){
    if (Strings.isNullOrEmpty(cs)) {
      return false;
    }
    final int sz = cs.length();
    for (int i = 0; i < sz; i++) {
      if (!Character.isLetterOrDigit(cs.charAt(i))) {
        return false;
      }
    }
    return true;    
 }","public static boolean isAlphanumeric(final String cs){
    if (Strings.isNullOrEmpty(cs)) {
      return false;
    }
    final int sz = cs.length();
    for (int i = 0; i < sz; i++) {
      if (!Character.isLetterOrDigit(cs.charAt(i))) {
        return false;
      }
    }
    return true;    
 }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,7.0,0.4666666666666667,4.0,0.36363636363636365,5.0,0.45454545454545453
218,matsim-libs,"public void removeNodesWithoutLinks(){
    List<Node> toBeRemoved = new ArrayList<>();
    for (Node node : this.network.getNodes().values()) {
        if ((node.getInLinks().size() == 0) && (node.getOutLinks().size() == 0)) {
            toBeRemoved.add(node);
        }
    }
    for (Node node : toBeRemoved) {
        this.network.removeNode(node.getId());
    }
}",removeNodesWithoutLinks,org/matsim/core/network/algorithms/MultimodalNetworkCleaner.java,/matsim/src/main/java/org/matsim/core/network/algorithms/MultimodalNetworkCleaner.java,"/**
         * Removes nodes from the network that have no incoming or outgoing links attached to them.
         */",61-74,"('removeNodesWithoutLinks', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",100.0,16.0,Removes nodes from the network that have no incoming or outgoing links attached to them.,Nodes that have no incoming or outgoing connections are removed from the network.,The network has no incoming or outgoing links for the nodes that are removed.,0.532156791935069,  Removes nodes from the network to which no inbound or outbound links are attached.," public void removeNodesWithoutLinks(){
	 		Set<Id<Node>> nodesToRemove = new HashSet<>();
 		for (Node node : network.getNodes().values()) {
 			if (node.getInLinks().isEmpty() && node.getOutLinks().isEmpty()) {
 				nodesToRemove.add(node.getId());
 			}
 		}
 		for (Id<Node> nodeId : nodesToRemove) {
 			network.removeNode(nodeId);
 		}
 	}		"," public void removeNodesWithoutLinks(){
	 		Set<Id<Node>> nodesToRemove = new HashSet<>();
 		for (Node node : network.getNodes().values()) {
 			if (node.getInLinks().isEmpty() && node.getOutLinks().isEmpty()) {
 				nodesToRemove.add(node.getId());
 			}
 		}
 		for (Id<Node> nodeId : nodesToRemove) {
 			network.removeNode(nodeId);
 		}
 	}		"," public void removeNodesWithoutLinks(){
	 	for (Node node : network.getNodes().values()) {
 		if (node.getInLinks().isEmpty() && node.getOutLinks().isEmpty()) {
 			network.removeNode(node.getId());
 		}
 	}
 }"," public void removeNodesWithoutLinks(){
	 		Set<Id<Node>> nodesToRemove = new HashSet<>();
 		for (Node node : network.getNodes().values()) {
 			if (node.getInLinks().isEmpty() && node.getOutLinks().isEmpty()) {
 				nodesToRemove.add(node.getId());
 			}
 		}
 		for (Id<Node> nodeId : nodesToRemove) {
 			network.removeNode(nodeId);
 		}
 	}",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6591359360793578,  0.6591359360793578,  0.6591359360793578,  0.407739747998017,35.0,0.3465346534653465,35.0,0.3465346534653465,35.0,0.3465346534653465,45.0,0.44554455445544555,0.0,0.0,0.0,0.0,37.0,0.3894736842105263,11.0,0.6875,7.0,0.4375,12.0,0.75
219,tablesaw,"private void processAggregateFunctions(TableSlice slice){
    for (String toColumn : query.getArgumentList().getAggregateFunctions().keySet()) {
        FunctionCall<AggregateFunctions> functionCall = query.getArgumentList().getAggregateFunctions().get(toColumn);
        AggregateFunctions aggregateFunction = functionCall.getFunction();
        Column<?> sourceColumn = query.getTable().column(functionCall.getSourceColumnName());
        validateColumn(aggregateFunction, sourceColumn);
        Column<?> destinationColumn = destination.column(functionCall.getDestinationColumnName());
        new WindowSlider(query.getWindowFrame(), aggregateFunction, slice, sourceColumn, destinationColumn).execute();
    }
}",processAggregateFunctions,tech/tablesaw/analytic/AnalyticQueryEngine.java,/core/src/main/java/tech/tablesaw/analytic/AnalyticQueryEngine.java,"/**
   * Execute all aggregate functions for the given slice setting values in the appropriate
   * destination column.
   */",54-72,"('processAggregateFunctions', {'INSTRUCTION': {'covered': 56, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",127.0,16.0,Execute all aggregate functions for the given slice setting values in the appropriate  destination column.,From the given slice perform all aggregate functions by setting values in the appropriate destination column in the destination column,Aggregate functions for the slice setting values are executed.,0.667489598714237,  Perform all aggregation functions for the slice parameter values given in the appropriate destination column.,"private void processAggregateFunctions(TableSlice slice){
    for (AggregateFunction function : query.getAggregateFunctions()) {
      Column column = function.getColumn();
      Column destinationColumn = destination.column(column.name());
      switch (function.getType()) {
        case COUNT:
          destinationColumn.fill(slice.count());
          break;
        case SUM:
          destinationColumn.fill(slice.sum(column));
          break;
        case MIN:
          destinationColumn.fill(slice.min(column));
          break;
        case MAX:
          destinationColumn.fill(slice.max(column));
          break;
        case AVG:
          destinationColumn.fill(slice.avg(column));
          break;
        case STD:
          destinationColumn.fill(slice.std(column));
          break;
        case VAR:
          destinationColumn.fill(slice.var(column));
          break;
        case MEDIAN:
          destinationColumn.fill(slice.median(column));
          break;
        case Q1:
          destinationColumn.fill(slice.q1(column));
          break;
        case Q3:
          destinationColumn.fill(slice.q3(column));
          break;
        case PERCENTILE:
          destinationColumn.fill(slice.percentile(column, function.getPercentile()));
          break;
        case CUSTOM:
          destinationColumn.fill(function.getCustomFunction().apply(slice));
          break;
        default:
          throw new IllegalArgumentException(""Unsupported aggregate function: "" + function.getType());
      }
    }   
 }"," private void processAggregateFunctions(TableSlice slice){
    for (AggregateFunction function : query.getAggregateFunctions()) {
      Column column = function.getColumn();
      Column destinationColumn = destination.column(column.name());
      for (Row row : slice) {
        destinationColumn.set(row.index(), function.apply(row));
      }
    }   
 }"," private void processAggregateFunctions(TableSlice slice){
    for (AggregateFunction function : query.getAggregateFunctions()) {
      Column column = slice.getColumn(function.getColumnName());
      Column result = function.apply(column);
      destination.addColumn(result);
    }   
 }","private void processAggregateFunctions(TableSlice slice){
    for (AggregateFunction function : query.getAggregateFunctions()) {
      Column column = function.getColumn();
      Column destinationColumn = destination.column(column.name());
      for (int i = 0; i < slice.size(); i++) {
        Row row = slice.row(i);
        Object value = row.get(column);
        destinationColumn.set(i, function.apply(value, destinationColumn.get(i)));
      }
    }   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.38776073399792393,  0.34565235977582875,  0.39531384086503324,  0.2811011657751801,210.0,0.7394366197183099,81.0,0.6328125,83.0,0.6484375,87.0,0.6796875,219.0,0.7711267605633803,205.0,0.721830985915493,239.0,0.8415492957746479,14.0,0.6666666666666666,5.0,0.3125,9.0,0.5625
220,cdk,"public DescriptorValue calculate(IAtomContainer container){
    try {
        IAtomContainer clone = (IAtomContainer) container.clone();
        AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(clone);
        int nsp2 = 0;
        int nsp3 = 0;
        for (IAtom atom : clone.atoms()) {
            if (atom.getAtomicNumber() != IElement.C)
                continue;
            if (atom.getHybridization() == Hybridization.SP2)
                nsp2++;
            else if (atom.getHybridization() == Hybridization.SP3)
                nsp3++;
        }
        double ratio = nsp3 / (double) (nsp2 + nsp3);
        return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(ratio), getDescriptorNames());
    } catch (CloneNotSupportedException e) {
        return getDummyDescriptorValue(e);
    } catch (CDKException e) {
        return getDummyDescriptorValue(e);
    }
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/HybridizationRatioDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/HybridizationRatioDescriptor.java,"/**
     * Calculate sp3/sp2 hybridization ratio in the supplied {@link IAtomContainer}.
     *
     * @param container The AtomContainer for which this descriptor is to be calculated.
     * @return The ratio of sp3 to sp2 carbons
     */",112-139,"('calculate', {'INSTRUCTION': {'covered': 62, 'missed': 10}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 4}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",166.0,13.0,Calculate sp3/sp2 hybridization ratio in the supplied {@link IAtomContainer}.,The sp3/sp2 hybridisation ratio is calculated in the {@link IAtomContainer} provided.,The supplied IAtomContainer has a sp3/sp2 hybridization ratio.,1.13656483935282,Calculate the sp3/sp2 hybridization ratio in the provided {@link IAtomContainer}.,"public DescriptorValue calculate(IAtomContainer container){
        try {
            double sp3 = 0;
            double sp2 = 0;
            for (IAtom atom : container.atoms()) {
                if (atom.getHybridization() == Hybridization.SP3) {
                    sp3++;
                } else if (atom.getHybridization() == Hybridization.SP2) {
                    sp2++;
                }
            }
            double ratio = sp3 / (sp3 + sp2);
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(ratio),
                    getDescriptorNames());
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }","public DescriptorValue calculate(IAtomContainer container){
        try {
            double sp3 = 0;
            double sp2 = 0;
            for (IAtom atom : container.atoms()) {
                if (atom.getHybridization() == Hybridization.SP3) {
                    sp3++;
                } else if (atom.getHybridization() == Hybridization.SP2) {
                    sp2++;
                }
            }
            double ratio = sp3 / (sp3 + sp2);
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(ratio),
                    getDescriptorNames());
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }","public DescriptorValue calculate(IAtomContainer container){
        try {
            double sp3 = 0;
            double sp2 = 0;
            for (IAtom atom : container.atoms()) {
                if (atom.getHybridization() == Hybridization.SP3) {
                    sp3++;
                } else if (atom.getHybridization() == Hybridization.SP2) {
                    sp2++;
                }
            }
            double ratio = sp3 / (sp3 + sp2);
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(ratio),
                    getDescriptorNames());
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }","public DescriptorValue calculate(IAtomContainer container){
        try {
            double sp3 = 0;
            double sp2 = 0;
            for (IAtom atom : container.atoms()) {
                if (atom.getHybridization() == Hybridization.SP3) {
                    sp3++;
                } else if (atom.getHybridization() == Hybridization.SP2) {
                    sp2++;
                }
            }
            double ratio = sp3 / (sp3 + sp2);
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(ratio),
                    getDescriptorNames());
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5510796648035857,  0.5510796648035857,  0.5510796648035857,  0.5510796648035857,66.0,0.39520958083832336,66.0,0.39520958083832336,66.0,0.39520958083832336,66.0,0.39520958083832336,0.0,0.0,0.0,0.0,0.0,0.0,7.0,0.5833333333333334,2.0,0.18181818181818182,9.0,0.9
221,cdk,"private int chooseRingNumber(){
    for (int i = 1; i < rnums.length; i++) {
        if (rnums[i] == 0) {
            rnums[i] = 1;
            return i;
        }
    }
    throw new IllegalStateException(""No more ring numbers available!"");
}",chooseRingNumber,org/openscience/cdk/smarts/SmartsFragmentExtractor.java,/tool/smarts/src/main/java/org/openscience/cdk/smarts/SmartsFragmentExtractor.java,"/**
     * Select the lowest ring number for use in SMARTS.
     *
     * @return ring number
     * @throws IllegalStateException all ring numbers are used
     */",321-335,"('chooseRingNumber', {'INSTRUCTION': {'covered': 21, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,10.0,Select the lowest ring number for use in SMARTS.,Select the lowest ring number to be used in SMARTS.,The lowest ring number is used in SMARTS.,0.376267068793337,  Select the lowest ring number to use in SMARTS.,"private int chooseRingNumber(){
        if (ringNum == null)
            ringNum = new int[10];
        for (int i = 0; i < ringNum.length; i++)
            if (ringNum[i] == 0)
                return i;
        throw new IllegalStateException(""Too many rings!"");     
 }"," private int chooseRingNumber(){
        return ringNum++;       
 }"," private int chooseRingNumber(){
        return ringNum++;       
 }","private int chooseRingNumber(){
        if (ringNum == null)
            ringNum = new int[10];
        for (int i = 0; i < ringNum.length; i++)
            if (ringNum[i] == 0)
                return i;
        throw new IllegalStateException(""Too many rings!"");     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5049431132873738,  0.09895186447997126,  0.5049431132873738,  0.09895186447997126,29.0,0.5087719298245614,44.0,0.8148148148148148,29.0,0.5087719298245614,44.0,0.8148148148148148,46.0,0.8070175438596491,0.0,0.0,46.0,0.8070175438596491,3.0,0.2727272727272727,1.0,0.1,4.0,0.4
222,shardingsphere-elasticjob,"public void checkMaxTimeDiffSecondsTolerable() throws JobExecutionEnvironmentException{
    int maxTimeDiffSeconds = load(true).getMaxTimeDiffSeconds();
    if (0 > maxTimeDiffSeconds) {
        return;
    }
    long timeDiff = Math.abs(timeService.getCurrentMillis() - jobNodeStorage.getRegistryCenterTime());
    if (timeDiff > maxTimeDiffSeconds * 1000L) {
        throw new JobExecutionEnvironmentException(""Time different between job server and register center exceed '%s' seconds, max time different is '%s' seconds."", timeDiff / 1000, maxTimeDiffSeconds);
    }
}",checkMaxTimeDiffSecondsTolerable,org/apache/shardingsphere/elasticjob/lite/internal/config/ConfigurationService.java,/elasticjob-lite/elasticjob-lite-core/src/main/java/org/apache/shardingsphere/elasticjob/lite/internal/config/ConfigurationService.java,"/**
     * Check max time different seconds tolerable between job server and registry center.
     * 
     * @throws JobExecutionEnvironmentException throe JobExecutionEnvironmentException if exceed max time different seconds
     */",90-105,"('checkMaxTimeDiffSecondsTolerable', {'INSTRUCTION': {'covered': 45, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,13.0,Check max time different seconds tolerable between job server and registry center.,"Between the job server and the registration centre, the maximum time of several seconds can be controlled","Between job server and registry center, check max time.",0.266389157581326,  Check the maximum tolerable time of different seconds between the task server and the registry center.,"public void checkMaxTimeDiffSecondsTolerable() throws JobExecutionEnvironmentException{
        long maxTimeDiffSecondsTolerable = timeService.getMaxTimeDiffSecondsTolerable();
        if (maxTimeDiffSecondsTolerable > 0) {
            long timeDiffSeconds = timeService.getTimeDiffSeconds();
            if (timeDiffSeconds > maxTimeDiffSecondsTolerable) {
                throw new JobExecutionEnvironmentException(
                        ""Time difference between job server and registry center is too large. The time difference is %s seconds, but the max time difference is %s seconds."", timeDiffSeconds, maxTimeDiffSecondsTolerable);
            }
        }
    }","public void checkMaxTimeDiffSecondsTolerable() throws JobExecutionEnvironmentException{
        long maxTimeDiffSecondsTolerable = timeService.getMaxTimeDiffSecondsTolerable();
        if (maxTimeDiffSecondsTolerable > 0) {
            long timeDiffSeconds = timeService.getTimeDiffSeconds();
            if (timeDiffSeconds > maxTimeDiffSecondsTolerable) {
                throw new JobExecutionEnvironmentException(""The time difference between the job server and the registration centre is too large, the time difference is %s seconds, the maximum time difference is %s seconds"", timeDiffSeconds, maxTimeDiffSecondsTolerable);
            }
        }
    }","public void checkMaxTimeDiffSecondsTolerable() throws JobExecutionEnvironmentException{
        long maxTimeDiffSeconds = timeService.getMaxTimeDiffSeconds();
        if (maxTimeDiffSeconds > 0) {
            throw new JobExecutionEnvironmentException(""The time difference between job server and registry center is too large, the max time difference is "" + maxTimeDiffSeconds + "" seconds."");
        }
    }","public void checkMaxTimeDiffSecondsTolerable() throws JobExecutionEnvironmentException{
        long maxTimeDiffSecondsTolerable = timeService.getMaxTimeDiffSecondsTolerable();
        if (maxTimeDiffSecondsTolerable > 0) {
            throw new JobExecutionEnvironmentException(""The time difference between the task server and the registry center is too large, the maximum tolerable time is "" + maxTimeDiffSecondsTolerable + "" seconds."");
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.377012726250779,  0.3610532452755034,  0.3024735812464212,  0.325681284139539,35.0,0.4666666666666667,35.0,0.4666666666666667,46.0,0.6133333333333333,45.0,0.6,1.0,0.01818181818181818,22.0,0.4,25.0,0.45454545454545453,17.0,0.9444444444444444,8.0,0.47058823529411764,11.0,0.8461538461538461
224,matsim-libs,"public static final int findSecondTerminusStop(ArrayList<TransitStopFacility> stops){
    double totalDistance = 0;
    Map<Integer, Double> distFromStart2StopIndex = new HashMap<>();
    TransitStopFacility previousStop = stops.get(0);
    for (int i = 0; i < stops.size(); i++) {
        TransitStopFacility currentStop = stops.get(i);
        totalDistance = totalDistance + CoordUtils.calcEuclideanDistance(previousStop.getCoord(), currentStop.getCoord());
        distFromStart2StopIndex.put(i, totalDistance);
        previousStop = currentStop;
    }
    // add leg from last to first stop
    totalDistance = totalDistance + CoordUtils.calcEuclideanDistance(previousStop.getCoord(), stops.get(0).getCoord());
    // first terminus is first stop in stops, other terminus is stop half way on the
    // circular route beginning at the first stop
    for (int i = 1; i < stops.size(); i++) {
        if (distFromStart2StopIndex.get(i) >= totalDistance / 2) {
            if (Math.abs(totalDistance / 2 - distFromStart2StopIndex.get(i - 1)) > Math.abs(totalDistance / 2 - distFromStart2StopIndex.get(i))) {
                // -> if both Math.abs() are equal the previous stop (i-1) is returned
                return i;
            } else {
                return i - 1;
            }
        }
    }
    return 0;
}",findSecondTerminusStop,org/matsim/contrib/minibus/genericUtils/TerminusStopFinder.java,/contribs/minibus/src/main/java/org/matsim/contrib/minibus/genericUtils/TerminusStopFinder.java,"/**
         * Find the 2nd terminus stop (1st terminus is at index 0 per definition).
         * 
         * Returns stop index instead of the stop, in order to cater for stops which are
         * served multiple times
         * 
         * @param stops
         * @return index of the stop which is half way on the route from start stop over
         *         all stops back to the start stop
         *         
         * @author gleich
         * 
         */",31-75,"('findSecondTerminusStop', {'INSTRUCTION': {'covered': 103, 'missed': 2}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",221.0,16.0,Find the 2nd terminus stop (1st terminus is at index 0 per definition).,"Find the 2nd terminus (based on the definition, the 1st terminus is at index 0). To take into account stops that are served several times returns the stop index instead of the stop.",The 2nd stop is at index 0 per definition.,0.523233117007238,Find the 2nd terminus stop (the 1st terminus is at index 0 by definition).,Empty Method,"public static final int findSecondTerminusStop(ArrayList<TransitStopFacility> stops){
    int secondTerminusStop = 0;
    int secondTerminusStopIndex = 0;
    int secondTerminusStopIndex2 = 0;
    int secondTerminusStopIndex3 = 0;
    int secondTerminusStopIndex4 = 0;
    int secondTerminusStopIndex5 = 0;
    int secondTerminusStopIndex6 = 0;
    int secondTerminusStopIndex7 = 0;
    int secondTerminusStopIndex8 = 0;
    int secondTerminusStopIndex9 = 0;
    int secondTerminusStopIndex10 = 0;
    int secondTerminusStopIndex11 = 0;
    int secondTerminusStopIndex12 = 0;
    int secondTerminusStopIndex13 = 0;
    int secondTerminusStopIndex14 = 0;
    int secondTerminusStopIndex15 = 0;
    int secondTerminusStopIndex16 = 0;
    int secondTerminusStopIndex17 = 0;
    int secondTerminusStopIndex18 = 0;
    int secondTerminusStopIndex19 = 0;
    int secondTerminusStopIndex20 = 0;
    int secondTerminusStopIndex21 = 0;
    int secondTerminusStopIndex22 = 0;
    int secondTerminusStopIndex23 = 0;
    int secondTerminusStopIndex24 = 0;
    int secondTerminusStopIndex25 = 0;
    int secondTerminusStopIndex26 = 0;
    int secondTerminusStopIndex27 = 0;
    int secondTerminusStopIndex28 = 0;
    int secondTerminusStopIndex29 = 0;
    int secondTerminusStopIndex30 = 0;
    int secondTerminusStopIndex31 = 0;
    int secondTerminusStopIndex32 = 0;
    int secondTerminusStopIndex33 = 0;
    int secondTerminusStopIndex34 = 0;
    int secondTerminusStopIndex35 = 0;
    int secondTerminusStopIndex36 = 0;
    int secondTerminusStopIndex37 = 0;
    int secondTerminusStopIndex38 = 0;
    int secondTerminusStopIndex39 = 0;
    int secondTerminusStopIndex40 = 0;
    int secondTerminusStopIndex41 = 0   
 }",Empty Method,Empty Method,Empty Method,Syntax Error,Empty Method,Empty Method,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,25.0,0.7352941176470589,3.0,0.2,6.0,0.42857142857142855
225,cdk,"public static double evalSimpleIndex(IAtomContainer atomContainer, List<List<Integer>> fragLists){
    double sum = 0;
    for (List<Integer> fragList : fragLists) {
        double prod = 1.0;
        for (Integer atomSerial : fragList) {
            IAtom atom = atomContainer.getAtom(atomSerial);
            int nconnected = atomContainer.getConnectedBondsCount(atom);
            prod = prod * nconnected;
        }
        if (prod != 0)
            sum += 1.0 / Math.sqrt(prod);
    }
    return sum;
}",evalSimpleIndex,org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,"/**
     * Evaluates the simple chi index for a set of fragments.
     *
     * @param atomContainer The target <code>AtomContainer</code>
     * @param fragLists      A list of fragments
     * @return The simple chi index
     */",101-120,"('evalSimpleIndex', {'INSTRUCTION': {'covered': 53, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",96.0,11.0,Evaluates the simple chi index for a set of fragments.,For a set of fragments evaluate the simple chi index ,Evaluates the chi index for a set of fragments.,0.103356143361033,  Evaluates the simple chi index for a set of fragments.,"public static double evalSimpleIndex(IAtomContainer atomContainer, List<List<Integer>> fragLists){
        double index = 0.0;
        for (List<Integer> frag : fragLists) {
            index += evalSimpleIndex(atomContainer, frag);
        }
        return index;       
 }","public static double evalSimpleIndex(IAtomContainer atomContainer, List<List<Integer>> fragLists){
        double sum = 0.0;
        for (List<Integer> frag : fragLists) {
            double chi = evalSimpleIndex(atomContainer, frag);
            sum += chi;
        }
        return sum;     
 }","public static double evalSimpleIndex(IAtomContainer atomContainer, List<List<Integer>> fragLists){
        double sum = 0;
        for (List<Integer> frag : fragLists) {
            sum += evalSimpleIndex(atomContainer, frag);
        }
        return sum;     
 }","public static double evalSimpleIndex(IAtomContainer atomContainer, List<List<Integer>> fragLists){
        double sum = 0;
        for (List<Integer> frag : fragLists) {
            double val = evalSimpleIndex(atomContainer, frag);
            sum += val;
        }
        return sum;     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2912008365266486,  0.3324434614323563,  0.34560376588475356,  0.3252346003298362,57.0,0.5876288659793815,50.0,0.5154639175257731,49.0,0.5051546391752577,54.0,0.5567010309278351,9.0,0.16666666666666666,10.0,0.18518518518518517,4.0,0.08163265306122448,10.0,0.9090909090909091,0.0,0.0,1.0,0.09090909090909091
226,dcache,"public synchronized boolean hasAppender(String appender){
    return _appenders.contains(appender) || (_parent != null && _parent.hasAppender(appender));
}",hasAppender,dmg/util/logback/FilterThresholdSet.java,/modules/cells/src/main/java/dmg/util/logback/FilterThresholdSet.java,"/**
     * Returns whether the appender is valid is valid for use in a threshold definition.
     */",104-110,"('hasAppender', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,15.0,Returns whether the appender is valid is valid for use in a threshold definition.,"For use in a threshold definition, it returns whether the appender is valid or not.","If the appender is valid, it is valid for use in a threshold definition.",0.512660324188762,  Indicates whether the appendix is valid and valid for use in a threshold definition.," public synchronized boolean hasAppender(String appender){
        return _appenders.contains(appender);
    }"," public synchronized boolean hasAppender(String appender){
        return _appenders.contains(appender);
    }"," public synchronized boolean hasAppender(String appender){
        return _appenders.contains(appender);
    }"," public synchronized boolean hasAppender(String appender){
        return _appenders.contains(appender);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.47379842637710523,  0.47379842637710523,  0.47379842637710523,  0.47379842637710523,13.0,0.40625,13.0,0.40625,13.0,0.40625,13.0,0.40625,0.0,0.0,0.0,0.0,0.0,0.0,15.0,0.9375,3.0,0.2,4.0,0.26666666666666666
227,cdk,"public IBond clone() throws CloneNotSupportedException{
    Bond clone = (Bond) super.clone();
    if (atoms != null) {
        clone.atoms = new IAtom[atoms.length];
        for (int f = 0; f < atoms.length; f++) {
            if (atoms[f] != null) {
                clone.atoms[f] = (IAtom) ((IAtom) atoms[f]).clone();
            }
        }
    }
    return clone;
}",clone,org/openscience/cdk/Bond.java,/base/data/src/main/java/org/openscience/cdk/Bond.java,"/**
     * Clones this bond object, including clones of the atoms between which the
     * bond is defined.
     *
     * @return The cloned object
     */",553-572,"('clone', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",97.0,17.0,"Clones this bond object, including clones of the atoms between which the  bond is defined.","Clone the following bond object, including clones of the atoms between which the bond is defined","Clones the bond object, including the atoms between it.",0.369602656230942,"  Clones this binding object, including clones of the atoms between which the bond is defined."," public IBond clone() throws CloneNotSupportedException{
        IBond clone = (IBond) super.clone();
        clone.atoms = new ArrayList<IAtom>();
        for (IAtom atom : atoms) {
            clone.atoms.add(atom.clone());
        }
        return clone;
    }"," public IBond clone() throws CloneNotSupportedException{
        IBond clone = (IBond) super.clone();
        clone.atoms = new ArrayList<IAtom>();
        for (IAtom atom : atoms) {
            clone.atoms.add(atom.clone());
        }
        return clone;
    }"," public IBond clone() throws CloneNotSupportedException{
        IBond clone = (IBond) super.clone();
        clone.atoms = new ArrayList<IAtom>();
        for (IAtom atom : atoms) {
            clone.atoms.add((IAtom) atom.clone());
        }
        return clone;
    }"," public IBond clone() throws CloneNotSupportedException{
        IBond clone = (IBond) super.clone();
        clone.atoms = new ArrayList<IAtom>();
        for (IAtom atom : atoms) {
            clone.atoms.add(atom.clone());
        }
        return clone;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3279724372656695,  0.31871317800641025,  0.31871317800641025,  0.34002750563006434,55.0,0.5612244897959183,55.0,0.5612244897959183,55.0,0.5612244897959183,52.0,0.5306122448979592,0.0,0.0,0.0,0.0,3.0,0.04838709677419355,4.0,0.23529411764705882,1.0,0.0625,8.0,0.5
228,jackson-databind,"public SimpleModule addValueInstantiator(Class<?> beanType, ValueInstantiator inst){
    _checkNotNull(beanType, ""class to register value instantiator for"");
    _checkNotNull(inst, ""value instantiator"");
    if (_valueInstantiators == null) {
        _valueInstantiators = new SimpleValueInstantiators();
    }
    _valueInstantiators = _valueInstantiators.addValueInstantiator(beanType, inst);
    return this;
}",addValueInstantiator,com/fasterxml/jackson/databind/module/SimpleModule.java,/src/main/java/com/fasterxml/jackson/databind/module/SimpleModule.java,"/**
     * Method for registering {@link ValueInstantiator} to use when deserializing
     * instances of type <code>beanType</code>.
     *<p>
     * Instantiator is
     * registered when module is registered for <code>ObjectMapper</code>.
     */",470-486,"('addValueInstantiator', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",58.0,23.0,Method for registering {@link ValueInstantiator} to use when deserializing  instances of type <code>beanType</code>.,The method to register {@link ValueInstantiator} is used when deserialising instances of type <code>beanType</code>. When the module is registered for <code>ObjectMapper</code> the instantiator is registered.,The method for registration @link ValueInstantiator is used when deserializing instances of type code>beanType/code>.,0.70196409527169,  The method for registering {@link ValueInstantiator} to use when deserializing instances of type <code>beanType</code>.," public SimpleModule addValueInstantiator(Class<?> beanType, ValueInstantiator inst){
        _checkNotNull(beanType, ""bean type to register value instantiator for"");
        _checkNotNull(inst, ""value instantiator"");
        if (_valueInstantiators == null) {
            _valueInstantiators = new SimpleValueInstantiators();
        }
        _valueInstantiators.addValueInstantiator(beanType, inst);
        return this;
    }"," public SimpleModule addValueInstantiator(Class<?> beanType, ValueInstantiator inst){
        _checkNotNull(beanType, ""bean type to register instantiator for"");
        _checkNotNull(inst, ""instantiator"");
        if (_valueInstantiators == null) {
            _valueInstantiators = new SimpleValueInstantiators();
        }
        _valueInstantiators.addInstantiator(beanType, inst);
        return this;
    }"," public SimpleModule addValueInstantiator(Class<?> beanType, ValueInstantiator inst){
        _checkNotNull(beanType, ""bean type to register value instantiator for"");
        _checkNotNull(inst, ""value instantiator"");
        if (_valueInstantiators == null) {
            _valueInstantiators = new SimpleValueInstantiators();
        }
        _valueInstantiators.addValueInstantiator(beanType, inst);
        return this;
    }"," public SimpleModule addValueInstantiator(Class<?> beanType, ValueInstantiator inst){
        _checkNotNull(beanType, ""bean type to register value instantiator for"");
        _checkNotNull(inst, ""value instantiator"");
        if (_valueInstantiators == null) {
            _valueInstantiators = new SimpleValueInstantiators();
        }
        _valueInstantiators.addValueInstantiator(beanType, inst);
        return this;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.9080373360290073,  0.7534284362278569,  0.9080373360290073,  0.9080373360290073,3.0,0.05084745762711865,5.0,0.0847457627118644,3.0,0.05084745762711865,3.0,0.05084745762711865,3.0,0.05263157894736842,0.0,0.0,0.0,0.0,18.0,0.6923076923076923,2.0,0.13333333333333333,8.0,0.5333333333333333
229,cdk,"public DescriptorValue calculate(IBond bond, IAtomContainer ac){
    Double originalCharge1 = bond.getBegin().getCharge();
    String originalAtomtypeName1 = bond.getBegin().getAtomTypeName();
    Integer originalNeighborCount1 = bond.getBegin().getFormalNeighbourCount();
    IAtomType.Hybridization originalHybridization1 = bond.getBegin().getHybridization();
    Integer originalValency1 = bond.getBegin().getValency();
    Double originalCharge2 = bond.getEnd().getCharge();
    String originalAtomtypeName2 = bond.getEnd().getAtomTypeName();
    Integer originalNeighborCount2 = bond.getEnd().getFormalNeighbourCount();
    IAtomType.Hybridization originalHybridization2 = bond.getEnd().getHybridization();
    Integer originalValency2 = bond.getEnd().getValency();
    Double originalBondOrderSum1 = bond.getBegin().getBondOrderSum();
    Order originalMaxBondOrder1 = bond.getBegin().getMaxBondOrder();
    Double originalBondOrderSum2 = bond.getEnd().getBondOrderSum();
    Order originalMaxBondOrder2 = bond.getEnd().getMaxBondOrder();
    if (!isCachedAtomContainer(ac)) {
        try {
            AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(ac);
            if (lpeChecker) {
                LonePairElectronChecker lpcheck = new LonePairElectronChecker();
                lpcheck.saturate(ac);
            }
        } catch (CDKException e) {
            return getDummyDescriptorValue(e);
        }
        if (maxIterations != -1)
            peoe.setMaxGasteigerIters(maxIterations);
        if (maxIterations != -1)
            pepe.setMaxGasteigerIters(maxIterations);
        if (maxResonStruc != -1)
            pepe.setMaxResoStruc(maxResonStruc);
        try {
            peoe.assignGasteigerMarsiliSigmaPartialCharges(ac, true);
            List<Double> peoeBond = new ArrayList<Double>();
            for (Iterator<IBond> it = ac.bonds().iterator(); it.hasNext(); ) {
                IBond bondi = it.next();
                double result = Math.abs(bondi.getBegin().getCharge() - bondi.getEnd().getCharge());
                peoeBond.add(result);
            }
            for (Iterator<IAtom> it = ac.atoms().iterator(); it.hasNext(); ) it.next().setCharge(0.0);
            pepe.assignGasteigerPiPartialCharges(ac, true);
            for (int i = 0; i < ac.getBondCount(); i++) {
                IBond bondi = ac.getBond(i);
                double result = Math.abs(bondi.getBegin().getCharge() - bondi.getEnd().getCharge());
                cacheDescriptorValue(bondi, ac, new DoubleResult(peoeBond.get(i) + result));
            }
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }
    bond.getBegin().setCharge(originalCharge1);
    bond.getBegin().setAtomTypeName(originalAtomtypeName1);
    bond.getBegin().setHybridization(originalHybridization1);
    bond.getBegin().setValency(originalValency1);
    bond.getBegin().setFormalNeighbourCount(originalNeighborCount1);
    bond.getEnd().setCharge(originalCharge2);
    bond.getEnd().setAtomTypeName(originalAtomtypeName2);
    bond.getEnd().setHybridization(originalHybridization2);
    bond.getEnd().setValency(originalValency2);
    bond.getEnd().setFormalNeighbourCount(originalNeighborCount2);
    bond.getBegin().setMaxBondOrder(originalMaxBondOrder1);
    bond.getBegin().setBondOrderSum(originalBondOrderSum1);
    bond.getEnd().setMaxBondOrder(originalMaxBondOrder2);
    bond.getEnd().setBondOrderSum(originalBondOrderSum2);
    return getCachedDescriptorValue(bond) != null ? new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), getCachedDescriptorValue(bond), NAMES) : null;
}",calculate,org/openscience/cdk/qsar/descriptors/bond/BondPartialTChargeDescriptor.java,/descriptor/qsarbond/src/main/java/org/openscience/cdk/qsar/descriptors/bond/BondPartialTChargeDescriptor.java,"/**
     *  The method calculates the bond total Partial charge of a given bond
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *
     *@param  ac                AtomContainer
     *@return return the sigma electronegativity
     */",152-230,"('calculate', {'INSTRUCTION': {'covered': 256, 'missed': 27}, 'BRANCH': {'covered': 13, 'missed': 5}, 'LINE': {'covered': 54, 'missed': 4}, 'COMPLEXITY': {'covered': 5, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",714.0,25.0,The method calculates the bond total Partial charge of a given bond  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.,The total partial charge of a given bond is calculated. The method addExplicitHydrogensToSatisfyValency must be called from the tools.HydrogenAdder class. ,The method calculates the bond total partial charge of a given bond,0.428708045296393,  The method calculates the total partial load of the binding of a given link It is necessary to call the addExplicitHydrogensToSatisfyValency method from the class tools.,"public DescriptorValue calculate(IBond bond, IAtomContainer ac){
        try {
            if (bond.getOrder() == Order.SINGLE) {
                return getDummyDescriptorValue(new CDKException(""The bond order is SINGLE""));
            }
    
            IAtom atomA = bond.getAtom(0);
            IAtom atomB = bond.getAtom(1);
    
            double pA = 0.0;
            double pB = 0.0;
    
            if (atomA.getFlag(CDKConstants.ISAROMATIC)) {
                pA = getPartialCharge(atomA, ac);
            } else {
                pA = getPartialCharge(atomA, ac);
            }
    
            if (atomB.getFlag(CDKConstants.ISAROMATIC)) {
                pB = getPartialCharge(atomB, ac);
            } else {
                pB = getPartialCharge(atomB, ac);
            }
    
            double pT = pA - pB;
    
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(pT),
                    NAMES);
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }",Not Valid,"public DescriptorValue calculate(IBond bond, IAtomContainer ac){
        try {
            if (bond.getOrder() == Order.SINGLE) {
                return getDummyDescriptorValue(new CDKException(""The bond order is SINGLE""));
            }
    
            IAtom atomA = bond.getAtom(0);
            IAtom atomB = bond.getAtom(1);
    
            double pA = 0.0;
            double pB = 0.0;
    
            if (atomA.getFormalCharge() != null) {
                pA = atomA.getFormalCharge().doubleValue();
            }
    
            if (atomB.getFormalCharge() != null) {
                pB = atomB.getFormalCharge().doubleValue();
            }
    
            if (lpeChecker) {
                LonePairElectronChecker lpe = new LonePairElectronChecker();
                if (lpe.isLonePairElectron(atomA)) {
                    pA += 1.0;
                }
                if (lpe.isLonePairElectron(atomB)) {
                    pB += 1.0;
                }
            }
    
            double pT = pA - pB;
    
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(pT),
                    NAMES);
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }","public DescriptorValue calculate(IBond bond, IAtomContainer ac){
        try {
            if (bond.getOrder() != Order.SINGLE)
                return getDummyDescriptorValue(new CDKException(""The bond must be single""));
    
            IAtom atomA = bond.getBegin();
            IAtom atomB = bond.getEnd();
    
            double pA = 0.0;
            double pB = 0.0;
    
            if (atomA.getSymbol().equals(""H"")) {
                pA = 0.0;
            } else {
                pA = peoe.calculatePartialCharge(atomA, ac);
            }
    
            if (atomB.getSymbol().equals(""H"")) {
                pB = 0.0;
            } else {
                pB = peoe.calculatePartialCharge(atomB, ac);
            }
    
            double pT = pA - pB;
    
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(pT),
                    NAMES);
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }",NOT PASS,Not Valid,NOT PASS,NOT PASS,  0.1807056318038449,None,  0.18279366289056037,  0.21107217748852258,606.0,0.8475524475524475,None,None,605.0,0.8461538461538461,591.0,0.8265734265734266,None,None,36.0,0.19672131147540983,63.0,0.30434782608695654,15.0,0.6,8.0,0.2962962962962963,13.0,0.52
230,dcache,"public static Checksum parseChecksum(String digest){
    requireNonNull(digest, ""value may not be null"");
    int del = digest.indexOf(DELIMITER);
    if (del < 1) {
        throw new IllegalArgumentException(""Not a dCache checksum: "" + digest);
    }
    String type = digest.substring(0, del);
    String checksum = digest.substring(del + 1);
    return new Checksum(ChecksumType.getChecksumType(type), checksum);
}",parseChecksum,org/dcache/util/Checksum.java,/modules/common/src/main/java/org/dcache/util/Checksum.java,"/**
     * Create a new checksum instance for an already computed digest of a particular type.
     *
     * @param digest the input must have the following format:
     *               <type>:<hexadecimal digest>
     * @throws IllegalArgumentException if argument has wrong form
     * @throws NullPointerException     if argument is null
     */",130-150,"('parseChecksum', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",82.0,15.0,Create a new checksum instance for an already computed digest of a particular type.,"For an already calculated digest of a particular type, create a new checksum instance",A new instance of a particular type is needed.,0.543560005567141,  Create a new checksum instance for an already calculated summary of a particular type.,"public static Checksum parseChecksum(String digest){
        String[] parts = digest.split("":"");
        if (parts.length != 2) {
            throw new IllegalArgumentException(""Invalid checksum format: "" + digest);
        }
        ChecksumType type = ChecksumType.getChecksumType(parts[0]);
        if (type == null) {
            throw new IllegalArgumentException(""Invalid checksum type: "" + parts[0]);
        }
        return new Checksum(type, parts[1]);
    }","public static Checksum parseChecksum(String digest){
        String[] parts = digest.split("":"");
        return new Checksum(ChecksumType.getChecksumType(parts[0]), parts[1]);
    }","public static Checksum parseChecksum(String digest){
        String[] parts = digest.split("":"");
        return new Checksum(ChecksumType.getChecksumType(parts[0]), parts[1]);
    }","public static Checksum parseChecksum(String digest){
        String[] parts = digest.split("":"");
        return new Checksum(ChecksumType.getChecksumType(parts[0]), parts[1]);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.37336728069155506,  0.21052008735978806,  0.21052008735978806,  0.21052008735978806,48.0,0.5517241379310345,59.0,0.7108433734939759,59.0,0.7108433734939759,59.0,0.7108433734939759,46.0,0.5287356321839081,46.0,0.5287356321839081,46.0,0.5287356321839081,13.0,0.8666666666666667,2.0,0.13333333333333333,11.0,0.7333333333333333
231,weblogic-kubernetes-operator," boolean isIstioEnabled(){
    return Optional.ofNullable(configuration).map(Configuration::getIstio).map(Istio::getEnabled).orElse(false);
}",isIstioEnabled,oracle/kubernetes/weblogic/domain/model/DomainSpec.java,/operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainSpec.java,"/**
   * Test if the domain is deployed under Istio environment.
   *
   * @return istioEnabled
   */",835-845,"('isIstioEnabled', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,10.0,Test if the domain is deployed under Istio environment.,Allows you to check whether the domain is distributed in the Istio environment,"If the domain is deployed under Istio, you should test it.",0.110559920782763,  Test whether the domain is deployed under the Istio environment.,"  boolean isIstioEnabled(){
    return Optional.ofNullable(configuration)
        .map(Configuration::getModel)
        .map(Model::getIstio)
        .map(Istio::getEnabled)
        .orElse(false);     
  }","  boolean isIstioEnabled(){
    return Optional.ofNullable(configuration)
        .map(Configuration::getModel)
        .map(Model::getIstio)
        .map(Istio::getEnabled)
        .orElse(false);     
  }","  boolean isIstioEnabled(){
    return Optional.ofNullable(configuration)
        .map(Configuration::getModel)
        .map(Model::getIstio)
        .map(Istio::getEnabled)
        .orElse(false);
  }","  boolean isIstioEnabled(){
    return Optional.ofNullable(configuration)
        .map(Configuration::getModel)
        .map(Model::getIstio)
        .map(Istio::getEnabled)
        .orElse(false);
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8842600358396339,  0.8842600358396339,  0.8842600358396339,  0.8842600358396339,7.0,0.17073170731707318,7.0,0.17073170731707318,7.0,0.17073170731707318,7.0,0.17073170731707318,0.0,0.0,0.0,0.0,0.0,0.0,9.0,0.6428571428571429,2.0,0.18181818181818182,7.0,0.5833333333333334
232,weblogic-kubernetes-operator,"public boolean hasNamedServer(String serverName){
    return getServerConfigs().stream().anyMatch(c -> serverName.equals(c.getName()));
}",hasNamedServer,oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,"/**
   * Returns true if one of the servers in the cluster has the specified name.
   *
   * @param serverName the name to look for
   * @return true or false
   */",135-143,"('hasNamedServer', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,15.0,Returns true if one of the servers in the cluster has the specified name.,"In the event that one of the servers in the cluster bears the specified name, true is returned.","If one of the server in the cluster has the specified name, this is true.",1.3710665481329,  Returns true if one of the servers in the cluster has the specified name.," public boolean hasNamedServer(String serverName){
    return servers.stream().anyMatch(server -> server.getName().equals(serverName));
  }"," public boolean hasNamedServer(String serverName){
    boolean result = false;
    for (WlsServerConfig server : servers) {
      if (server.getName().equals(serverName)) {
        result = true;
        break;
      }
    }
    return result;
  }"," public boolean hasNamedServer(String serverName){
    return servers.stream().anyMatch(server -> server.getName().equals(serverName));
  }"," public boolean hasNamedServer(String serverName){
    for (WlsServerConfig server : servers) {
      if (server.getName().equals(serverName)) {
        return true;
      }
    }
    return false;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6767310197054481,  0.4748786756038178,  0.4963051497093047,  0.6767310197054481,9.0,0.2571428571428571,30.0,0.625,23.0,0.575,9.0,0.2571428571428571,25.0,0.5208333333333334,18.0,0.45,0.0,0.0,9.0,0.47368421052631576,0.0,0.0,8.0,0.5
234,acs-aem-commons,"private boolean isDispatcherTransportURI(final Agent agent){
    final String transportURI = agent.getConfiguration().getTransportURI();
    return (StringUtils.startsWith(transportURI, HTTP) || StringUtils.startsWith(transportURI, HTTPS));
}",isDispatcherTransportURI,com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,"/**
     * Checks if the agent has a valid transport URI set.
     *
     * @param agent Agent to check
     * @return true if the Agent's transport URI is in the proper form
     */",142-153,"('isDispatcherTransportURI', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,11.0,Checks if the agent has a valid transport URI set.,Verify whether the agent reports a valid transport URI,The agent is checked if they have a valid transport set.,0.787137996858752,  Checks whether the agent has a valid transport URI.," private boolean isDispatcherTransportURI(final Agent agent){
        final AgentConfig config = agent.getConfiguration();
        final String transportUri = config.getTransportURI();
        return StringUtils.startsWith(transportUri, HTTP) || StringUtils.startsWith(transportUri, HTTPS);       
 }"," private boolean isDispatcherTransportURI(final Agent agent){
        final AgentConfig config = agent.getConfiguration();
        final String transportUri = config.getTransportUri();
        return transportUri != null && (transportUri.startsWith(HTTP) || transportUri.startsWith(HTTPS));       
 }"," private boolean isDispatcherTransportURI(final Agent agent){
        final AgentConfig config = agent.getConfiguration();
        final String transport = config.getTransport();
        return String       
 }"," private boolean isDispatcherTransportURI(final Agent agent){
        final AgentConfig config = agent.getConfiguration();
        final String transportURI = config.getTransportURI();
        return StringUtils.startsWith(transportURI, HTTP) || StringUtils.startsWith(transportURI, HTTPS);       
 }",PASS,NOT PASS,PASS,Syntax Error,  0.6271540206024848,  0.5041142755860509,  0.7049868817001838,None,12.0,0.24,19.0,0.36538461538461536,10.0,0.2,25.0,0.5434782608695652,12.0,0.23076923076923078,3.0,0.06,20.0,0.4,4.0,0.36363636363636365,3.0,0.2727272727272727,8.0,0.6666666666666666
235,anserini,"public final Iterator<FileSegment<T>> iterator(){
    List<Path> paths = discover(this.path);
    Iterator<Path> pathsIterator = paths.iterator();
    return new Iterator<>() {

        Path segmentPath;

        FileSegment<T> segment;

        @Override
        public boolean hasNext() {
            if (segment != null) {
                return true;
            }
            if (!pathsIterator.hasNext()) {
                return false;
            } else {
                try {
                    segmentPath = pathsIterator.next();
                    segment = createFileSegment(segmentPath);
                } catch (IOException e) {
                    return false;
                }
            }
            return true;
        }

        @Override
        public FileSegment<T> next() throws NoSuchElementException {
            if (!hasNext()) {
                throw new NoSuchElementException(""No more file segments to read."");
            } else {
                FileSegment<T> seg = segment;
                segment = null;
                return seg;
            }
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    };
}",iterator,io/anserini/collection/DocumentCollection.java,/src/main/java/io/anserini/collection/DocumentCollection.java,"/**
   * An iterator over {@code FileSegment} for the {@code DocumentCollection} iterable.
   * A collection is comprised of one or more file segments.
   */",98-145,"('iterator', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",189.0,17.0,An iterator over {@code FileSegment} for the {@code DocumentCollection} iterable.,An iterator on {@code FileSegment} for the iterable {@code DocumentCollection}. A collection may consist of one or more file segments,The iterator is over @code DocumentCollection.,0.687896165886014,  An iterator on {@code FileSegment} for the iterable {@code DocumentCollection}.,Not Valid," public final Iterator<FileSegment<T>> iterator(){
    return new FileSegmentIterator();   
 }",Not Valid," public final Iterator<FileSegment<T>> iterator(){
    return new FileSegmentIterator();
  }",Not Valid,NOT PASS,NOT PASS,Not Valid,None,  0.09550541341711916,  0.09550541341711916,None,None,None,170.0,0.8947368421052632,170.0,0.8947368421052632,None,None,20.0,0.9523809523809523,20.0,0.9523809523809523,None,None,13.0,0.6190476190476191,4.0,0.36363636363636365,9.0,0.8181818181818182
236,jackson-databind,"protected MappingIterator<T> _newIterator(JsonParser p, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean parserManaged){
    return new MappingIterator<T>(_valueType, p, ctxt, deser, parserManaged, _valueToUpdate);
}",_newIterator,com/fasterxml/jackson/databind/ObjectReader.java,/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java,"/**
     * Factory method used to create {@link MappingIterator} instances;
     * either default, or custom subtype.
     * 
     * @since 2.5
     */",326-337,"('_newIterator', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,19.0,"Factory method used to create {@link MappingIterator} instances;  either default, or custom subtype.",Method for creating instances of {@link MappingIterator} custom subtype or either default,The factory method creates @link MappingIterator instances.,0.872265713559452,  A factory method used to create {@link MappingIterator} instances;  either by default or custom subtype.," protected MappingIterator<T> _newIterator(JsonParser p, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean parserManaged){
        return new MappingIterator<T>(p, ctxt, deser, parserManaged);
    }"," protected MappingIterator<T> _newIterator(JsonParser p, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean parserManaged){
        return new MappingIterator<T>(p, ctxt, deser, parserManaged);
    }"," protected MappingIterator<T> _newIterator(JsonParser p, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean parserManaged){
        return new MappingIterator<T>(p, ctxt, deser, parserManaged);
    }"," protected MappingIterator<T> _newIterator(JsonParser p, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean parserManaged){
        return new MappingIterator<T>(p, ctxt, deser, parserManaged);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8575421101972409,  0.8575421101972409,  0.8575421101972409,  0.8575421101972409,4.0,0.08888888888888889,4.0,0.08888888888888889,4.0,0.08888888888888889,4.0,0.08888888888888889,0.0,0.0,0.0,0.0,0.0,0.0,10.0,0.7142857142857143,4.0,0.25,13.0,0.9285714285714286
237,cdk,"private static void addExtendedTetrahedralConfiguration(ExtendedTetrahedral et, GraphBuilder gb, Map<IAtom, Integer> indices){
    IAtom[] ligands = et.peripherals();
    int u = indices.get(et.focus());
    int[] vs = new int[] { indices.get(ligands[0]), indices.get(ligands[1]), indices.get(ligands[2]), indices.get(ligands[3]) };
    gb.extendedTetrahedral(u).lookingFrom(vs[0]).neighbors(vs[1], vs[2], vs[3]).winding(et.winding() == CLOCKWISE ? Configuration.CLOCKWISE : Configuration.ANTI_CLOCKWISE).build();
}",addExtendedTetrahedralConfiguration,org/openscience/cdk/smiles/CDKToBeam.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/CDKToBeam.java,"/**
     * Add extended tetrahedral stereo configuration to the Beam GraphBuilder.
     *
     * @param et      stereo element specifying tetrahedral configuration
     * @param gb      the current graph builder
     * @param indices atom indices
     */",348-366,"('addExtendedTetrahedralConfiguration', {'INSTRUCTION': {'covered': 81, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",153.0,10.0,Add extended tetrahedral stereo configuration to the Beam GraphBuilder.,Extended tetrahedral stereo configuration added to Beam GraphBuilder,The Beam GraphBuilder can be used to add extended stereo configuration.,0.29998816493298,  Add an extended tetrahedral stereo configuration to the Beam GraphBuilder.,"private static void addExtendedTetrahedralConfiguration(ExtendedTetrahedral et, GraphBuilder gb, Map<IAtom, Integer> indices){
        IAtom[] ligands = et.getLigands();
        int u = indices.get(et.getChiralAtom());
        int vs[] = new int[]{indices.get(ligands[0]), indices.get(ligands[1]), indices.get(ligands[2]),
                indices.get(ligands[3])};
        gb.tetrahedral(u).lookingFrom(vs[0]).neighbors(vs[1], vs[2], vs[3])
                .winding(et.getStereo() == CLOCKWISE ? Configuration.CLOCKWISE : Configuration.ANTI_CLOCKWISE).build();
    }","private static void addExtendedTetrahedralConfiguration(ExtendedTetrahedral et, GraphBuilder gb, Map<IAtom, Integer> indices){
     
      IAtom[] ligands = et.getLigands();
     
      int u = indices.get(et.getChiralAtom());
      int vs[] = new int[]{indices.get(ligands[0]), indices.get(ligands[1]), indices.get(ligands[2]),
                 indices.get(ligands[3])};
     
      gb.tetrahedral(u).lookingFrom(vs[0]).neighbors(vs[1], vs[2], vs[3])
                 .winding(et.getStereo() == CLOCKWISE ? Configuration.CLOCKWISE : Configuration.ANTI_CLOCKWISE).build();
     }","private static void addExtendedTetrahedralConfiguration(ExtendedTetrahedral et, GraphBuilder gb, Map<IAtom, Integer> indices){
        int u = indices.get(et.getChiralAtom());
        int vs[] = new int[]{indices.get(et.getLigands()[0]), indices.get(et.getLigands()[1]), indices.get(et.getLigands()[2]),
                indices.get(et.getLigands()[3])};
        gb.tetrahedral(u).lookingFrom(vs[0]).neighbors(vs[1], vs[2], vs[3])
                .winding(et.getStereo() == CLOCKWISE ? Configuration.CLOCKWISE : Configuration.ANTI_CLOCKWISE).build();
    }","private static void addExtendedTetrahedralConfiguration(ExtendedTetrahedral et, GraphBuilder gb, Map<IAtom, Integer> indices){
        IAtom[] ligands = et.getLigands();
    
        int u = indices.get(et.getChiralAtom());
        int vs[] = new int[]{indices.get(ligands[0]), indices.get(ligands[1]), indices.get(ligands[2]),
                indices.get(ligands[3])};
    
        gb.tetrahedral(u).lookingFrom(vs[0]).neighbors(vs[1], vs[2], vs[3])
                .winding(et.getStereo() == CLOCKWISE ? Configuration.CLOCKWISE : Configuration.ANTI_CLOCKWISE).build();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8814263453428424,  0.8936214672940619,  0.9119141502208912,  0.7303492986006389,6.0,0.03896103896103896,6.0,0.03896103896103896,6.0,0.03896103896103896,36.0,0.22641509433962265,0.0,0.0,0.0,0.0,31.0,0.1949685534591195,5.0,0.5,1.0,0.09090909090909091,10.0,0.8333333333333334
238,matsim-libs,"protected void relaxNode(final Node outNode, final Node toNode, final RouterPriorityQueue<Node> pendingNodes){
    DijkstraNodeData outData = getData(outNode);
    double currTime = outData.getTime();
    double currCost = outData.getCost();
    if (this.pruneDeadEnds) {
        PreProcessDijkstra.DeadEndData ddOutData = getPreProcessData(outNode);
        for (Link l : outNode.getOutLinks().values()) {
            relaxNodeLogic(l, pendingNodes, currTime, currCost, toNode, ddOutData);
        }
    } else {
        for (Link l : outNode.getOutLinks().values()) {
            relaxNodeLogic(l, pendingNodes, currTime, currCost, toNode, null);
        }
    }
}",relaxNode,org/matsim/core/router/Dijkstra.java,/matsim/src/main/java/org/matsim/core/router/Dijkstra.java,"/**
         * Expands the given Node in the routing algorithm; may be overridden in
         * sub-classes.
         *
         * @param outNode
         *            The Node to be expanded.
         * @param toNode
         *            The target Node of the route.
         * @param pendingNodes
         *            The set of pending nodes so far.
         */",371-398,"('relaxNode', {'INSTRUCTION': {'covered': 61, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",132.0,15.0,Expands the given Node in the routing algorithm; may be overridden in  sub-classes.,This method allows the expansion of the given node in the routing algorithm; it can also be overridden in the subclasses,The given Node may be expanded in the routing algorithm.,0.632716567611816,  Expands the given node in the routing algorithm; can be replaced in subclasses.," protected void relaxNode(final Node outNode, final Node toNode, final RouterPriorityQueue<Node> pendingNodes){
	 		DijkstraNodeData data = getData(outNode);
 		visitNode(outNode, data, pendingNodes, data.getStartTime(), data.getCost(), toNode);
 	}"," protected void relaxNode(final Node outNode, final Node toNode, final RouterPriorityQueue<Node> pendingNodes){
	 DijkstraNodeData data = getData(outNode);
	 visitNode(outNode, data, pendingNodes, data.getStartTime(), data.getCost(), toNode);
 }"," protected void relaxNode(final Node outNode, final Node toNode, final RouterPriorityQueue<Node> pendingNodes){
	 		DijkstraNodeData data = getData(outNode);
 		double cost = data.getCost();
 		double newCost = cost + getCost(outNode, toNode);
 		if (newCost < getData(toNode).getCost()) {
 			visitNode(outNode, data, pendingNodes, data.getStartTime(), newCost, toNode);
 		}
 	}		"," protected void relaxNode(final Node outNode, final Node toNode, final RouterPriorityQueue<Node> pendingNodes){
	 		DijkstraNodeData outNodeData = getData(outNode);
 		double outNodeCost = outNodeData.getCost();
 		double outNodeTime = outNodeData.getTime();
 		double outNodeDistance = outNodeData.getDistance();
 		double outNodeWeight = outNodeData.getWeight();
 		double outNodeSpeed = outNodeData.getSpeed();
 		double outNodeWalkTime = outNodeData.getWalkTime();
 		double outNodeWalkDistance = outNodeData.getWalkDistance();
 		double outNodeWalkWeight = outNodeData.getWalkWeight();
 		double outNodeWalkSpeed = outNodeData.getWalkSpeed();
 		double outNodeWalkCost = outNodeData.getWalkCost();
 		double outNodeWalkTime = outNodeData.getWalkTime();
 		double outNodeWalkDistance = outNodeData.getWalkDistance();
 		double outNodeWalkWeight = outNodeData.getWalkWeight();
 		double outNodeWalkSpeed = outNodeData.getWalkSpeed();
 		double outNodeWalkCost = outNodeData.getWalkCost();
 		double outNodeWalkTime = outNodeData.getWalkTime();
 		double outNodeWalkDistance = outNodeData.getWalkDistance();
 		double outNodeWalkWeight = outNodeData.getWalkWeight();
 		double outNodeWalkSpeed = outNodeData.getWalkSpeed();
 		double outNodeWalkCost = outNodeData.getWalkCost();
 		double outNodeWalkTime = outNodeData.getWalkTime();
 		double outNodeWalkDistance = outNodeData.getWalkDistance();
 		double outNodeWalkWeight = outNodeData.getWalkWeight();
 		double outNodeWalkSpeed = outNodeData.getWalkSpeed();
 		double outNodeWalkCost = outNodeData.getWalkCost();
 		double outNodeWalkTime = outNodeData.getWalkTime();
 		double outNodeWalkDistance = outNodeData.getWalkDistance();
 		double		
 }",NOT PASS,NOT PASS,Syntax Error,NOT PASS,  0.3018921128571719,  0.3018921128571719,None,  0.41571637278965917,91.0,0.6842105263157895,91.0,0.6842105263157895,202.0,0.7372262773722628,72.0,0.5413533834586466,0.0,0.0,236.0,0.8613138686131386,40.0,0.47058823529411764,12.0,0.5454545454545454,4.0,0.2857142857142857,10.0,0.7142857142857143
239,tablesaw,"private List<Index> buildIndexesForJoinColumns(List<Integer> joinColumnIndexes, Table table){
    return joinColumnIndexes.stream().map(c -> indexFor(table, c)).collect(Collectors.toList());
}",buildIndexesForJoinColumns,tech/tablesaw/joining/DataFrameJoiner.java,/core/src/main/java/tech/tablesaw/joining/DataFrameJoiner.java,/** Build a reverse index for every join column in the table. */,336-339,"('buildIndexesForJoinColumns', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,12.0,Build a reverse index for every join column in the table.," For each join column in the table, create an inverse index",Every join column in the table should be built with a reverse index.,0.77643292894935, Create an inverse index for each join column in the table.," private List<Index> buildIndexesForJoinColumns(List<Integer> joinColumnIndexes, Table table){
    List<Index> indexes = new ArrayList<>();
    for (int i : joinColumnIndexes) {
      indexes.add(table.getIndex(i));
    }
    return indexes;
  }"," private List<Index> buildIndexesForJoinColumns(List<Integer> joinColumnIndexes, Table table){
    List<Index> indexes = new ArrayList<Index>();
    for (int i : joinColumnIndexes) {
      indexes.add(table.getIndex(i));
    }
    return indexes;
  }"," private List<Index> buildIndexesForJoinColumns(List<Integer> joinColumnIndexes, Table table){
    List<Index> indexes = new ArrayList<>();
    for (int i : joinColumnIndexes) {
      indexes.add(table.getColumn(i).buildReverseIndex());
    }
    return indexes;
  }"," private List<Index> buildIndexesForJoinColumns(List<Integer> joinColumnIndexes, Table table){
    List<Index> indexes = new ArrayList<>();
    for (int i : joinColumnIndexes) {
      indexes.add(table.index(i));
    }
    return indexes;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5495768471896338,  0.5478312400055366,  0.5495768471896338,  0.5584814908457684,27.0,0.48214285714285715,28.0,0.49122807017543857,27.0,0.48214285714285715,31.0,0.5166666666666667,1.0,0.017543859649122806,1.0,0.017857142857142856,5.0,0.08333333333333333,11.0,0.9166666666666666,4.0,0.3333333333333333,13.0,0.9285714285714286
240,cdk,"public IAtomContainer generate(IAtomContainerSet atomContainers) throws CDKException{
    int iteration = 0;
    boolean structureFound = false;
    do {
        iteration++;
        boolean bondFormed;
        do {
            bondFormed = false;
            for (IAtomContainer ac : atomContainers.atomContainers()) {
                for (IAtom atom : AtomContainerManipulator.getAtomArray(ac)) {
                    if (!satCheck.isSaturated(atom, ac)) {
                        IAtom partner = getAnotherUnsaturatedNode(atom, ac, atomContainers);
                        if (partner != null) {
                            IAtomContainer toadd = AtomContainerSetManipulator.getRelevantAtomContainer(atomContainers, partner);
                            double cmax1 = satCheck.getCurrentMaxBondOrder(atom, ac);
                            double cmax2 = satCheck.getCurrentMaxBondOrder(partner, toadd);
                            double max = Math.min(cmax1, cmax2);
                            // (double)Math.round(Math.random() * max)
                            double order = Math.min(Math.max(1.0, max), 3.0);
                            logger.debug(""cmax1, cmax2, max, order: "" + cmax1 + "", "" + cmax2 + "", "" + max + "", "" + order);
                            if (toadd != ac) {
                                atomContainers.removeAtomContainer(toadd);
                                ac.add(toadd);
                            }
                            ac.addBond(ac.getBuilder().newInstance(IBond.class, atom, partner, BondManipulator.createBondOrder(order)));
                            bondFormed = true;
                        }
                    }
                }
            }
        } while (bondFormed);
        if (atomContainers.getAtomContainerCount() == 1 && satCheck.allSaturated(atomContainers.getAtomContainer(0))) {
            structureFound = true;
        }
    } while (!structureFound && iteration < 5);
    if (atomContainers.getAtomContainerCount() == 1 && satCheck.allSaturated(atomContainers.getAtomContainer(0))) {
        structureFound = true;
    }
    if (!structureFound)
        throw new CDKException(""Could not combine the fragments to combine a valid, satured structure"");
    return atomContainers.getAtomContainer(0);
}",generate,org/openscience/cdk/structgen/stochastic/PartialFilledStructureMerger.java,/tool/structgen/src/main/java/org/openscience/cdk/structgen/stochastic/PartialFilledStructureMerger.java,"/**
     * Randomly generates a single, connected, correctly bonded structure from
     * a number of fragments.  IMPORTANT: The AtomContainers in the set must be
     * connected. If an AtomContainer is disconnected, no valid result will
     * be formed
     * @param atomContainers The fragments to generate for.
     * @return The newly formed structure.
     * @throws CDKException No valid result could be formed.
     */",62-115,"('generate', {'INSTRUCTION': {'covered': 168, 'missed': 8}, 'BRANCH': {'covered': 17, 'missed': 9}, 'LINE': {'covered': 31, 'missed': 1}, 'COMPLEXITY': {'covered': 6, 'missed': 8}, 'METHOD': {'covered': 1, 'missed': 0}})",332.0,16.0,"Randomly generates a single, connected, correctly bonded structure from  a number of fragments.","A single, connected and correctly bound structure from a set of fragments is generated randomly. IMPORTANT: The AtomContainers of the collection must be connected. No valid result will be formed if an AtomContainer is disconnected.","Randomly generated a single, connected, correctly bonded structure from a number of fragments.",0.984073489481379,"  Randomly generates a single, connected, and properly linked structure from a number of fragments.","public IAtomContainer generate(IAtomContainerSet atomContainers) throws CDKException{
        IAtomContainer molecule = atomContainers.getAtomContainer(0);
        IAtomContainerSet fragments = atomContainers.getConnectedComponents();
        int fragmentCount = fragments.getAtomContainerCount();
        int[] fragmentSizes = new int[fragmentCount];
        for (int i = 0; i < fragmentCount; i++) {
            fragmentSizes[i] = fragments.getAtomContainer(i).getAtomCount();
        }
        int[] fragmentHydrogens = new int[fragmentCount];
        for (int i = 0; i < fragmentCount; i++) {
            fragmentHydrogens[i] = 0;
        }
        int[] fragmentBonds = new int[fragmentCount];
        for (int i = 0; i < fragmentCount; i++) {
            fragmentBonds[i] = 0;
        }
        int[] fragmentAtoms = new int[fragmentCount];
        for (int i = 0; i < fragmentCount; i++) {
            fragmentAtoms[i] = 0;
        }
        int[] fragmentHydrogens2 = new int[fragmentCount];
        for (int i = 0; i < fragmentCount; i++) {
            fragmentHydrogens2[i] = 0;
        }
        int[] fragmentBonds2 = new int[fragmentCount];
        for (int i = 0; i < fragmentCount; i++) {
            fragmentBonds2[i] = 0;
        }
        int[] fragmentAtoms2 = new int[fragmentCount];
        for (int i = 0; i < fragmentCount; i++) {
            fragmentAtoms2[i] = 0;
        }
        int[] fragmentHydrogens3 = new int[fragmentCount];
        for (int i = 0; i < fragmentCount; i++) {
            fragmentHydrogens3[i] = 0;
        }
        int[] fragmentBonds3 = new int[fragmentCount];
        for (int i = 0; i < fragmentCount; i++) {
            fragmentBonds3[i] = 0;
        }
        int     
 }","public IAtomContainer generate(IAtomContainerSet atomContainers) throws CDKException{
        IAtomContainer molecule = null;
        IAtomContainerSet fragments = atomContainers;
        int numFragments = fragments.getAtomContainerCount();
        if (numFragments == 0) {
            throw new CDKException(""No fragments to merge"");
        }
        if (numFragments == 1) {
            molecule = fragments.getAtomContainer(0);
            return molecule;
        }
        IAtomContainerSet fragmentSet = new AtomContainerSet();
        for (int i = 0; i < numFragments; i++) {
            fragmentSet.addAtomContainer(fragments.getAtomContainer(i));
        }
        molecule = fragmentSet.getAtomContainer(0);
        for (int i = 1; i < numFragments; i++) {
            IAtomContainer fragment = fragmentSet.getAtomContainer(i);
            IAtomContainer mergedFragment = mergeFragment(molecule, fragment);
            molecule = mergedFragment;
        }
        return molecule;
    }",Not Valid,Not Valid,Syntax Error,NOT PASS,Not Valid,Not Valid,None,  0.18619866745737906,None,None,None,None,262.0,0.7867867867867868,None,None,None,None,260.0,0.7303370786516854,None,None,None,None,31.0,0.8611111111111112,3.0,0.2,1.0,0.07142857142857142
241,cdk,"protected void generateAtomContainerFromInchi(IChemObjectBuilder builder) throws CDKException{
    InchiInput input = output.getInchiInput();
    molecule = builder.newInstance(IAtomContainer.class);
    Map<InchiAtom, IAtom> inchiCdkAtomMap = new HashMap<InchiAtom, IAtom>();
    List<InchiAtom> atoms = input.getAtoms();
    for (int i = 0; i < atoms.size(); i++) {
        InchiAtom iAt = atoms.get(i);
        IAtom cAt = builder.newInstance(IAtom.class);
        inchiCdkAtomMap.put(iAt, cAt);
        cAt.setID(""a"" + i);
        cAt.setAtomicNumber(Elements.ofString(iAt.getElName()).number());
        cAt.setFormalCharge(iAt.getCharge());
        cAt.setImplicitHydrogenCount(iAt.getImplicitHydrogen());
        int isotopicMass = iAt.getIsotopicMass();
        if (isotopicMass != 0) {
            if (isotopicMass > ISOTOPIC_SHIFT_THRESHOLD) {
                try {
                    int massNumber = Isotopes.getInstance().getMajorIsotope(cAt.getAtomicNumber()).getMassNumber();
                    cAt.setMassNumber(massNumber + (isotopicMass - ISOTOPIC_SHIFT_FLAG));
                } catch (IOException e) {
                    throw new CDKException(""Could not load Isotopes data"", e);
                }
            } else {
                cAt.setMassNumber(isotopicMass);
            }
        }
        molecule.addAtom(cAt);
        cAt = molecule.getAtom(molecule.getAtomCount() - 1);
        addHydrogenIsotopes(builder, cAt, 2, iAt.getImplicitDeuterium());
        addHydrogenIsotopes(builder, cAt, 3, iAt.getImplicitTritium());
    }
    List<InchiBond> bonds = input.getBonds();
    for (int i = 0; i < bonds.size(); i++) {
        InchiBond iBo = bonds.get(i);
        IBond cBo = builder.newInstance(IBond.class);
        IAtom atO = inchiCdkAtomMap.get(iBo.getStart());
        IAtom atT = inchiCdkAtomMap.get(iBo.getEnd());
        cBo.setAtoms(new IAtom[] { atO, atT });
        InchiBondType type = iBo.getType();
        switch(type) {
            case SINGLE:
                cBo.setOrder(IBond.Order.SINGLE);
                break;
            case DOUBLE:
                cBo.setOrder(IBond.Order.DOUBLE);
                break;
            case TRIPLE:
                cBo.setOrder(IBond.Order.TRIPLE);
                break;
            case ALTERN:
                cBo.setIsInRing(true);
                break;
            default:
                throw new CDKException(""Unknown bond type: "" + type);
        }
        InchiBondStereo stereo = iBo.getStereo();
        switch(stereo) {
            case NONE:
                cBo.setStereo(IBond.Stereo.NONE);
                break;
            case SINGLE_1DOWN:
                cBo.setStereo(IBond.Stereo.DOWN);
                break;
            case SINGLE_1UP:
                cBo.setStereo(IBond.Stereo.UP);
                break;
            case SINGLE_2DOWN:
                cBo.setStereo(IBond.Stereo.DOWN_INVERTED);
                break;
            case SINGLE_2UP:
                cBo.setStereo(IBond.Stereo.UP_INVERTED);
                break;
            case SINGLE_1EITHER:
                cBo.setStereo(IBond.Stereo.UP_OR_DOWN);
                break;
            case SINGLE_2EITHER:
                cBo.setStereo(IBond.Stereo.UP_OR_DOWN_INVERTED);
                break;
        }
        molecule.addBond(cBo);
    }
    List<InchiStereo> stereos = input.getStereos();
    for (int i = 0; i < stereos.size(); i++) {
        InchiStereo stereo0d = stereos.get(i);
        if (stereo0d.getType() == InchiStereoType.Tetrahedral || stereo0d.getType() == InchiStereoType.Allene) {
            InchiAtom central = stereo0d.getCentralAtom();
            InchiAtom[] neighbours = stereo0d.getAtoms();
            IAtom focus = inchiCdkAtomMap.get(central);
            IAtom[] neighbors = new IAtom[] { inchiCdkAtomMap.get(neighbours[0]), inchiCdkAtomMap.get(neighbours[1]), inchiCdkAtomMap.get(neighbours[2]), inchiCdkAtomMap.get(neighbours[3]) };
            ITetrahedralChirality.Stereo stereo;
            if (stereo0d.getParity() == InchiStereoParity.ODD) {
                stereo = ITetrahedralChirality.Stereo.ANTI_CLOCKWISE;
            } else if (stereo0d.getParity() == InchiStereoParity.EVEN) {
                stereo = ITetrahedralChirality.Stereo.CLOCKWISE;
            } else {
                continue;
            }
            IStereoElement stereoElement = null;
            if (stereo0d.getType() == InchiStereoType.Tetrahedral) {
                stereoElement = builder.newInstance(ITetrahedralChirality.class, focus, neighbors, stereo);
            } else if (stereo0d.getType() == InchiStereoType.Allene) {
                IAtom[] peripherals = neighbors;
                IAtom[] terminals = ExtendedTetrahedral.findTerminalAtoms(molecule, focus);
                for (IAtom terminal : terminals) {
                    if (peripherals[1].equals(terminal)) {
                        peripherals[1] = findOtherSinglyBonded(molecule, terminal, peripherals[0]);
                    } else if (peripherals[2].equals(terminal)) {
                        peripherals[2] = findOtherSinglyBonded(molecule, terminal, peripherals[3]);
                    } else if (peripherals[0].equals(terminal)) {
                        peripherals[0] = findOtherSinglyBonded(molecule, terminal, peripherals[1]);
                    } else if (peripherals[3].equals(terminal)) {
                        peripherals[3] = findOtherSinglyBonded(molecule, terminal, peripherals[2]);
                    }
                }
                stereoElement = new ExtendedTetrahedral(focus, peripherals, stereo);
            }
            assert stereoElement != null;
            molecule.addStereoElement(stereoElement);
        } else if (stereo0d.getType() == InchiStereoType.DoubleBond) {
            boolean extended = false;
            InchiAtom[] neighbors = stereo0d.getAtoms();
            IAtom x = inchiCdkAtomMap.get(neighbors[0]);
            IAtom a = inchiCdkAtomMap.get(neighbors[1]);
            IAtom b = inchiCdkAtomMap.get(neighbors[2]);
            IAtom y = inchiCdkAtomMap.get(neighbors[3]);
            IBond stereoBond = molecule.getBond(a, b);
            if (stereoBond == null) {
                extended = true;
                IBond tmp = null;
                stereoBond = ExtendedCisTrans.findCentralBond(molecule, a);
                if (stereoBond == null)
                    continue;
                IAtom[] ends = ExtendedCisTrans.findTerminalAtoms(molecule, stereoBond);
                assert ends != null;
                if (ends[0] != a)
                    flip(stereoBond);
            } else {
                if (!stereoBond.getBegin().equals(a))
                    flip(stereoBond);
            }
            int config = IStereoElement.TOGETHER;
            if (stereo0d.getParity() == InchiStereoParity.EVEN)
                config = IStereoElement.OPPOSITE;
            if (extended) {
                molecule.addStereoElement(new ExtendedCisTrans(stereoBond, new IBond[] { molecule.getBond(x, a), molecule.getBond(b, y) }, config));
            } else {
                molecule.addStereoElement(new DoubleBondStereochemistry(stereoBond, new IBond[] { molecule.getBond(x, a), molecule.getBond(b, y) }, config));
            }
        }
    }
}",generateAtomContainerFromInchi,org/openscience/cdk/inchi/InChIToStructure.java,/storage/inchi/src/main/java/org/openscience/cdk/inchi/InChIToStructure.java,"/**
     * Gets structure from InChI, and converts InChI library data structure
     * into an IAtomContainer.
     *
     * @throws CDKException
     */",158-384,"('generateAtomContainerFromInchi', {'INSTRUCTION': {'covered': 515, 'missed': 119}, 'BRANCH': {'covered': 39, 'missed': 28}, 'LINE': {'covered': 97, 'missed': 26}, 'COMPLEXITY': {'covered': 13, 'missed': 26}, 'METHOD': {'covered': 1, 'missed': 0}})",1349.0,15.0,"Gets structure from InChI, and converts InChI library data structure  into an IAtomContainer.","Once the structure has been obtained from InChI, it converts the data structure of the InChI library into an IAtomContainer.",Gets structure from InChI and converts it into an IAtomContainer.,0.32404378516653,  Gets the structure of InChI and converts the data structure of the InChI library to IAtomContainer.," protected void generateAtomContainerFromInchi(IChemObjectBuilder builder) throws CDKException{
        molecule = builder.newInstance(IAtomContainer.class);
        molecule.setID(output.getInchi());
        molecule.setAtomCount(output.getAtomCount());
        molecule.setBondCount(output.getBondCount());
        molecule.setStereoElements(output.getStereoElements());
        molecule.setProperties(output.getProperties());
        molecule.setProperty(InChIFactory.INCHI_VERSION, output.getInchiVersion());
        molecule.setProperty(InChIFactory.INCHI_RETURN_CODE, output.getReturnCode());
        molecule.setProperty(InChIFactory.INCHI_MESSAGE, output.getMessage());
        molecule.setProperty(InChIFactory.INCHI_WARNING, output.getWarning());
        molecule.setProperty(InChIFactory.INCHI_INPUT_MESSAGE, output.getInputMessage());
        molecule.setProperty(InChIFactory.INCHI_INPUT_MESSAGE_CODE, output.getInputMessageCode());
        molecule.setProperty(InChIFactory.INCHI_INPUT_MESSAGE_TOKEN, output.getInputMessageToken());
        molecule.setProperty(InChIFactory.INCHI_INPUT_MESSAGE_TOKEN_CODE, output.getInputMessageTokenCode());
        molecule.setProperty(InChIFactory.INCHI_INPUT_MESSAGE_TOKEN_VALUE, output.getInputMessageTokenValue());
        molecule.setProperty(InChIFactory.INCHI_INPUT_MESSAGE_TOKEN_VALUE_CODE, output.getInputMessageTokenValueCode());
        molecule.setProperty(InChIFactory.INCHI_INPUT_MESSAGE_TOKEN_VALUE_CODE_EXT, output.getInputMessageTokenValueCodeExt());
        molecule.setProperty(InChIFactory.INCHI_INPUT_MESSAGE_TOKEN_VALUE_EXT, output.getInputMessageTokenValueExt());
        molecule.setProperty(       
 }"," protected void generateAtomContainerFromInchi(IChemObjectBuilder builder) throws CDKException{
        molecule = builder.newInstance(IAtomContainer.class);
        molecule.setID(output.getInchi());
        molecule.setProperty(CDKConstants.TITLE, output.getInchi());
        molecule.setProperty(CDKConstants.INCHI, output.getInchi());
        molecule.setProperty(CDKConstants.INCHI_KEY, output.getInchiKey());
        molecule.setProperty(CDKConstants.FORMAL_CHARGE, output.getCharge());
        molecule.setProperty(CDKConstants.MASS_NUMBER, output.getMass());
        molecule.setProperty(CDKConstants.MOL_WEIGHT, output.getMw());
        molecule.setProperty(CDKConstants.EXPLICIT_HYDROGEN_COUNT, output.getNumH());
        molecule.setProperty(CDKConstants.TOTAL_CHARGE, output.getTotalCharge());
        molecule.setProperty(CDKConstants.ATOM_COUNT, output.getNumAtoms());
        molecule.setProperty(CDKConstants.BOND_COUNT, output.getNumBonds());
        molecule.setProperty(CDKConstants.STEREO_COUNT, output.getNumStereo());
        molecule.setProperty(CDKConstants.STEREO_COUNT_CIS, output.getNumCis());
        molecule.setProperty(CDKConstants.STEREO        
 }","protected void generateAtomContainerFromInchi(IChemObjectBuilder builder) throws CDKException{
        molecule = builder.newInstance(IAtomContainer.class);
        int numAtoms = output.getAtomCount();
        int numBonds = output.getBondCount();
        int numStereo0D = output.getStereo0DCount();
        int numStereoEZ = output.getStereoEZCount();
        int numStereoCisTrans = output.getStereoCisTransCount();
        int numStereoExt = output.getStereoExtCount();
        int numStereoTetra = output.getStereoTetraCount();
        int numStereoTetraInv = output.getStereoTetraInvCount();
        int numStereoTetraZ = output.getStereoTetraZCount();
        int numStereoTetraInvZ = output.getStereoTetraInvZCount();
        int numStereoTetraM = output.getStereoTetraMCount();
        int numStereoTetraInvM = output.getStereoTetraInvMCount();
        int numStereoTetraZM = output.getStereoTetraZMCount();
        int numStereoTetraInvZM = output.getStereoTetraInvZMCount();
        int numStereoTetraP = output.getStereoTetraPCount();
        int numStereoTetraInvP = output.getStereoTetraInvPCount();
        int numStereoTetraZP = output.getStereoTetraZPCount();
        int numStereoTetraInvZP = output.getStereoTetraInvZPCount();
        int numStereoTetraMZ = output.getStereoTetraMZCount();
        int numStereoTetraInvMZ = output.getStereoTetraInvMZCount();
        int numStereoTetraZMZ = output.getStereoTetraZMZCount();
        int numStereoTetraInvZMZ = output.getStereoTetraInvZMZCount();      
 }","protected void generateAtomContainerFromInchi(IChemObjectBuilder builder) throws CDKException{
        molecule = builder.newInstance(IAtomContainer.class);
        int numAtoms = output.getAtomCount();
        int numBonds = output.getBondCount();
        int numStereo0D = output.getStereo0DCount();
        int numStereoEZ = output.getStereoEZCount();
        int numStereoCisTrans = output.getStereoCisTransCount();
        int numStereoExt = output.getStereoExtCount();
        int numStereoTetra = output.getStereoTetraCount();
        int numStereoTetraInv = output.getStereoTetraInvCount();
        int numStereoTetraZ = output.getStereoTetraZCount();
        int numStereoTetraInvZ = output.getStereoTetraInvZCount();
        int numStereoTetraDir = output.getStereoTetraDirCount();
        int numStereoTetraInvDir = output.getStereoTetraInvDirCount();
        int numStereoTetraDirZ = output.getStereoTetraDirZCount();
        int numStereoTetraInvDirZ = output.getStereoTetraInvDirZCount();
        int numStereoTetraDirInv = output.getStereoTetraDirInvCount();
        int numStereoTetraInvDirInv = output.getStereoTetraInvDirInvCount();
        int numStereoTetraDirInvZ = output.getStereoTetraDirInvZCount();
        int numStereoTetraInvDirInvZ = output.getStereoTetraInvDirInvZCount();
        int numStereoTetraDirInvDir = output.getStereoTetraDirInvDirCount();
        int numStereoTetraInvDirInvDir = output.getStereoTetraInvDirInvDirCount();
        int numStereoTetraDirInvDirZ = output.getStereoTetraDirInvDirZCount();
        int numStereoTetraInvDirInvDirZ     
 }",Syntax Error,Syntax Error,Syntax Error,NOT PASS,None,None,None,  0.06920146602577004,None,None,None,None,1216.0,0.9007407407407407,1211.0,0.8970370370370371,None,None,162.0,0.6183206106870229,164.0,0.6259541984732825,12.0,0.5714285714285714,10.0,0.5882352941176471,5.0,0.35714285714285715
242,cdk,"private void layoutAcyclicParts() throws CDKException{
    logger.debug(""Start of handleAliphatics"");
    int safetyCounter = 0;
    IAtomContainer unplacedAtoms = null;
    IAtomContainer placedAtoms = null;
    IAtomContainer longestUnplacedChain = null;
    IAtom atom = null;
    Vector2d direction = null;
    Vector2d startVector = null;
    boolean done;
    do {
        safetyCounter++;
        done = false;
        atom = getNextAtomWithAliphaticUnplacedNeigbors();
        if (atom != null) {
            unplacedAtoms = getUnplacedAtoms(atom);
            placedAtoms = getPlacedAtoms(atom);
            longestUnplacedChain = atomPlacer.getLongestUnplacedChain(molecule, atom);
            logger.debug(""---start of longest unplaced chain---"");
            try {
                logger.debug(""Start at atom no. "" + (molecule.indexOf(atom) + 1));
                logger.debug(AtomPlacer.listNumbers(molecule, longestUnplacedChain));
            } catch (Exception exc) {
                logger.debug(exc);
            }
            logger.debug(""---end of longest unplaced chain---"");
            if (longestUnplacedChain.getAtomCount() > 1) {
                if (placedAtoms.getAtomCount() > 1) {
                    logger.debug(""More than one atoms placed already"");
                    logger.debug(""trying to place neighbors of atom "" + (molecule.indexOf(atom) + 1));
                    atomPlacer.distributePartners(atom, placedAtoms, GeometryUtil.get2DCenter(placedAtoms), unplacedAtoms, bondLength);
                    direction = new Vector2d(longestUnplacedChain.getAtom(1).getPoint2d());
                    startVector = new Vector2d(atom.getPoint2d());
                    direction.sub(startVector);
                    logger.debug(""Done placing neighbors of atom "" + (molecule.indexOf(atom) + 1));
                } else {
                    logger.debug(""Less than or equal one atoms placed already"");
                    logger.debug(""Trying to get next bond vector."");
                    direction = atomPlacer.getNextBondVector(atom, placedAtoms.getAtom(0), GeometryUtil.get2DCenter(molecule), true);
                }
                for (int f = 1; f < longestUnplacedChain.getAtomCount(); f++) {
                    longestUnplacedChain.getAtom(f).setFlag(CDKConstants.ISPLACED, false);
                }
                atomPlacer.placeLinearChain(longestUnplacedChain, direction, bondLength);
            } else {
                done = true;
            }
        } else {
            done = true;
        }
    } while (!done && safetyCounter <= molecule.getAtomCount());
    logger.debug(""End of handleAliphatics"");
}",layoutAcyclicParts,org/openscience/cdk/layout/StructureDiagramGenerator.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/StructureDiagramGenerator.java,"/**
     * Does a layout of all aliphatic parts connected to the parts of the molecule
     * that have already been laid out. Starts at the first bond with unplaced
     * neighbours and stops when a ring is encountered.
     *
     * @throws CDKException if an error occurs
     */",1829-1900,"('layoutAcyclicParts', {'INSTRUCTION': {'covered': 192, 'missed': 4}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 41, 'missed': 2}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",413.0,21.0,Does a layout of all aliphatic parts connected to the parts of the molecule  that have already been laid out.,On the basis of all the aliphatic parts connected to the parts of the molecule already arranged makes an arrangement. It starts from the first bond with unpositioned neighbours and stops when a ring is encountered.,Does a layout of all the aliphatic parts of the molecule.,0.538570797595953,  Makes a layout of all the aliphatic parts connected to the parts of the molecule that have already been arranged.," private void layoutAcyclicParts() throws CDKException{
        for (IAtomContainer part : molecule.getConnectedComponents()) {
            if (part.getFlag(CDKConstants.ISPLACED)) {
                part.setFlag(CDKConstants.ISPLACED, false);
                layoutAcyclicPart(part);
            }
        }
    }",Not Valid,"private void layoutAcyclicParts() throws CDKException{
        for (IAtomContainer ac : molecule.getConnectedComponents()) {
            if (ac.getAtomCount() > 1) {
                layout(ac);
            }
        }
    }",Not Valid,NOT PASS,Not Valid,Not Valid,NOT PASS,  0.0714135038923342,None,None,  0.06595630231962347,373.0,0.9009661835748792,None,None,None,None,381.0,0.9202898550724637,None,None,None,None,20.0,0.38461538461538464,25.0,0.6756756756756757,4.0,0.19047619047619047,12.0,0.5714285714285714
243,cdk,"public void registerParameters(IGenerator<? extends IChemObject> generator){
    for (IGeneratorParameter<?> param : generator.getParameters()) {
        try {
            renderingParameters.put(param.getClass().getName(), param.getClass().newInstance());
        } catch (InstantiationException | IllegalAccessException e) {
            throw new IllegalStateException(""Could not create a copy of rendering parameter."");
        }
    }
}",registerParameters,org/openscience/cdk/renderer/RendererModel.java,/display/render/src/main/java/org/openscience/cdk/renderer/RendererModel.java,"/**
     * Registers rendering parameters from {@link IGenerator}s
     * with this model.
     *
     * @param generator
     */",266-281,"('registerParameters', {'INSTRUCTION': {'covered': 25, 'missed': 6}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,14.0,Registers rendering parameters from {@link IGenerator}s  with this model.,Registers rendering parameters from {@link IGenerator}s with this template,Registers parameters from @link IGenerators.,1.66844739372781,  Saves the rendering parameters of {@link IGenerator} with this template.," public void registerParameters(IGenerator<? extends IChemObject> generator){
        for (IGeneratorParameter<?> parameter : generator.getParameters()) {
            if (renderingParameters.containsKey(parameter.getClass().getName())) {
                throw new IllegalArgumentException(""A generator has registered a parameter with the same name as ""
                        + ""an already registered parameter. This is not allowed. Please change the name of the ""
                        + ""parameter in the generator."");
            }
            renderingParameters.put(parameter.getClass().getName(), parameter);
        }
    }"," public void registerParameters(IGenerator<? extends IChemObject> generator){
        for (IGeneratorParameter<?> parameter : generator.getParameters()) {
            if (renderingParameters.containsKey(parameter.getClass().getName())) {
                renderingParameters.get(parameter.getClass().getName()).setValue(parameter.getValue());
            } else {
                renderingParameters.put(parameter.getClass().getName(), parameter);
            }
        }
    }"," public void registerParameters(IGenerator<? extends IChemObject> generator){
        for (IGeneratorParameter<?> parameter : generator.getParameters()) {
            if (renderingParameters.containsKey(parameter.getClass().getName())) {
                throw new IllegalArgumentException(""The parameter "" + parameter.getClass().getName()
                        + "" is already registered."");
            }
            renderingParameters.put(parameter.getClass().getName(), parameter);
        }
    }"," public void registerParameters(IGenerator<? extends IChemObject> generator){
        for (IGeneratorParameter<?> parameter : generator.getParameters()) {
            if (renderingParameters.containsKey(parameter.getClass().getName())) {
                renderingParameters.get(parameter.getClass().getName()).setValue(parameter.getValue());
            }
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6258609985764093,  0.6606365296094934,  0.6537448399632807,  0.6415441741510468,30.0,0.38461538461538464,38.0,0.40425531914893614,26.0,0.3466666666666667,32.0,0.37209302325581395,24.0,0.2553191489361702,20.0,0.2564102564102564,11.0,0.12790697674418605,1.0,0.1,5.0,0.45454545454545453,6.0,0.6
244,jackson-databind,"public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource){
    _mixIns.addLocalDefinition(target, mixinSource);
    return this;
}",addMixIn,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Method to use for adding mix-in annotations to use for augmenting
     * specified class or interface. All annotations from
     * <code>mixinSource</code> are taken to override annotations
     * that <code>target</code> (or its supertypes) has.
     *
     * @param target Class (or interface) whose annotations to effectively override
     * @param mixinSource Class (or interface) whose annotations are to
     *   be ""added"" to target's annotations, overriding as necessary
     *
     * @since 2.5
     */",1502-1518,"('addMixIn', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,16.0,Method to use for adding mix-in annotations to use for augmenting  specified class or interface.,Add mix-in annotations to be used to augment the specified class or interface. The mixinSource annotations are considered to override the annotations that the target (or its supertypes) possesses.,Adding mix-in annotations is a method to use.,0.625928163930459,  Method to use to add mix annotations to use to augment the specified class or interface.," public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource){
        _mixIns.addMixIn(target, mixinSource);
        return this;
    }"," public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource){
        _mixIns.addMixIn(target, mixinSource);
        return this;
    }"," public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource){
        _mixIns.addMixIn(target, mixinSource);
        return this;
    }"," public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource){
        _mixIns.addMixIn(target, mixinSource);
        return this;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.9553545683606741,  0.9553545683606741,  0.9553545683606741,  0.9553545683606741,1.0,0.03225806451612903,1.0,0.03225806451612903,1.0,0.03225806451612903,1.0,0.03225806451612903,0.0,0.0,0.0,0.0,0.0,0.0,26.0,0.8666666666666667,6.0,0.35294117647058826,13.0,0.8125
245,cdk,"static Point2d[] decodeCoordinates(String str){
    if (str.startsWith(""|("")) {
        int end = str.indexOf(')', 2);
        if (end < 0)
            return new Point2d[0];
        String[] strs = str.substring(2, end).split("";"");
        Point2d[] points = new Point2d[strs.length];
        for (int i = 0; i < strs.length; i++) {
            String coord = strs[i];
            int first = coord.indexOf(',');
            int second = coord.indexOf(',', first + 1);
            String x = coord.substring(0, first);
            String y = coord.substring(first + 1, second);
            if (x.isEmpty())
                x = ""0"";
            if (y.isEmpty())
                y = ""0"";
            points[i] = new Point2d(Double.parseDouble(x), Double.parseDouble(y));
        }
        return points;
    } else {
        String[] strs = str.split("", "");
        Point2d[] points = new Point2d[strs.length / 2];
        for (int i = 0; i < strs.length; i += 2) {
            points[i / 2] = new Point2d(Double.parseDouble(strs[i]), Double.parseDouble(strs[i + 1]));
        }
        return points;
    }
}",decodeCoordinates,org/openscience/cdk/layout/IdentityTemplateLibrary.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/IdentityTemplateLibrary.java,"/**
     * Decode coordinates that have been placed in a byte buffer.
     *
     * @param str the string to decode
     * @return array of coordinates
     */",245-280,"('decodeCoordinates', {'INSTRUCTION': {'covered': 115, 'missed': 5}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 22, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",290.0,11.0,Decode coordinates that have been placed in a byte buffer.,Coordinates that have been entered into a byte buffer are decoded,The coordinates are in a buffer.,0.275746538701339,  Decode the coordinates that have been placed in a byte buffer.,"static Point2d[] decodeCoordinates(String str){
        final byte[] bytes = Base64.getDecoder().decode(str);
        final Point2d[] points = new Point2d[bytes.length / 8];
        for (int i = 0; i < points.length; i++) {
            points[i] = new Point2d(bytes[i * 8], bytes[i * 8 + 1]);
        }
        return points;
    }","static Point2d[] decodeCoordinates(String str){
        final byte[] bytes = Base64.getDecoder().decode(str);
        final Point2d[] points = new Point2d[bytes.length / 8];
        for (int i = 0; i < points.length; i++) {
            points[i] = new Point2d(bytes[i * 8], bytes[i * 8 + 1]);
        }
        return points;
    }","static Point2d[] decodeCoordinates(String str){
        final int n = str.length() / 8;
        final Point2d[] points = new Point2d[n];
        for (int i = 0; i < n; i++) {
            points[i] = new Point2d(Double.parseDouble(str.substring(i * 8, i * 8 + 8)),
                                    Double.parseDouble(str.substring(i * 8 + 8, i * 8 + 16)));
        }
        return points;
    }","static Point2d[] decodeCoordinates(String str){
        final byte[] bytes = Base64.getDecoder().decode(str);
        final Point2d[] points = new Point2d[bytes.length / 8];
        for (int i = 0; i < points.length; i++) {
            points[i] = new Point2d(bytes[i * 8], bytes[i * 8 + 1]);
        }
        return points;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.1991586508448756,  0.20173597043250446,  0.20689060960776218,  0.19199832497636124,222.0,0.7628865979381443,222.0,0.7628865979381443,222.0,0.7628865979381443,217.0,0.7457044673539519,0.0,0.0,0.0,0.0,52.0,0.49056603773584906,7.0,0.5833333333333334,1.0,0.08333333333333333,6.0,0.5454545454545454
246,cdk,"TextOutline resize(final double scaleX, final double scaleY){
    final Point2D center = getCenter();
    final AffineTransform transform = new AffineTransform();
    transform.translate(center.getX(), center.getY());
    transform.scale(scaleX, scaleY);
    transform.translate(-center.getX(), -center.getY());
    return transform(transform);
}",resize,org/openscience/cdk/renderer/generators/standard/TextOutline.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/TextOutline.java,"/**
     * Convenience function to resize the outline and maintain the existing
     * center point.
     *
     * @param scaleX scale x-axis
     * @param scaleY scale y-axis
     * @return resized outline
     */",215-230,"('resize', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",81.0,13.0,Convenience function to resize the outline and maintain the existing  center point.,Function to maintain the existing centre point and resize the contour,"To maintain the center point, the convenience function is needed.",1.46906205936172,  Convenience function to resize the outline and hold the existing center point.," TextOutline resize(final double scaleX, final double scaleY){
        final AffineTransform scale = new AffineTransform();
        scale.scale(scaleX, scaleY);
        return transform(scale);        
 }"," TextOutline resize(final double scaleX, final double scaleY){
      
      final AffineTransform scaleTransform = new AffineTransform();
      scaleTransform.scale(scaleX, scaleY);
      
      final Shape scaledOutline = scaleTransform.createTransformedShape(outline);
      
      return new TextOutline(text, glyphs, scaledOutline, transform);           
 }"," TextOutline resize(final double scaleX, final double scaleY){
        final AffineTransform scale = new AffineTransform();
        scale.scale(scaleX, scaleY);
        return transform(scale);        
 }","TextOutline resize(final double scaleX, final double scaleY){
        final Point2D center = getCenter();
        final AffineTransform scale = AffineTransform.getScaleInstance(scaleX, scaleY);
        return transform(scale).transform(AffineTransform.getTranslateInstance(-center.getX(), -center.getY()));        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3984269841565147,  0.42593296680397447,  0.6082478094334749,  0.3984269841565147,47.0,0.573170731707317,46.0,0.5609756097560976,31.0,0.3780487804878049,47.0,0.573170731707317,22.0,0.39285714285714285,31.0,0.49206349206349204,0.0,0.0,10.0,0.7692307692307693,1.0,0.07692307692307693,11.0,0.8461538461538461
247,cdk,"void markRow(int i, int marking){
    for (int j = (i * mCols), end = j + mCols; j < end; j++) if (data[j] > 0)
        data[j] = marking;
}",markRow,org/openscience/cdk/isomorphism/CompatibilityMatrix.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/CompatibilityMatrix.java,"/**
     * Mark all values in row i allowing it to be reset later.
     *
     * @param i       row index
     * @param marking the marking to store (should be negative)
     */",102-111,"('markRow', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,13.0,Mark all values in row i allowing it to be reset later.,"Since we want to reset the values later, we mark all of them in a row",I allow the values to be reset later on.,0.333236765128875,Mark all values in line i to allow it to be reset later.,"void markRow(int i, int marking){
        for (int j = 0; j < mCols; j++)
            mark(i, j, marking);
    }","void markRow(int i, int marking){
        for (int j = 0; j < mCols; j++)
            mark(i, j, marking);
    }","void markRow(int i, int marking){
        for (int j = 0; j < mCols; j++)
            mark(i, j, marking);
    }","void markRow(int i, int marking){
        for (int j = 0; j < mCols; j++)
            mark(i, j, marking);        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.472204372403755,  0.472204372403755,  0.472204372403755,  0.472204372403755,24.0,0.46153846153846156,24.0,0.46153846153846156,24.0,0.46153846153846156,24.0,0.46153846153846156,0.0,0.0,0.0,0.0,0.0,0.0,15.0,0.8823529411764706,3.0,0.21428571428571427,10.0,0.7692307692307693
248,cdk,"private List<IIsotope> orderList(List<IIsotope> isotopes_TO){
    List<IIsotope> newOrderList = new ArrayList<IIsotope>();
    for (int i = 0; i < orderElements.length; i++) {
        String symbol = orderElements[i];
        Iterator<IIsotope> itIso = isotopes_TO.iterator();
        while (itIso.hasNext()) {
            IIsotope isotopeToCo = itIso.next();
            if (isotopeToCo.getSymbol().equals(symbol)) {
                newOrderList.add(isotopeToCo);
            }
        }
    }
    return newOrderList;
}",orderList,org/openscience/cdk/formula/MassToFormulaTool.java,/legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java,"/**
     * Put the order the List of IIsotope according the probability occurrence.
     *
     * @param isotopes_TO  The List of IIsotope
     * @return             The list of IIsotope ordered
     */",417-436,"('orderList', {'INSTRUCTION': {'covered': 40, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",111.0,12.0,Put the order the List of IIsotope according the probability occurrence.,Order the list of IIsotope based on the probability of their occurrence.,The order of the List of IIsotope should be decided by the probability occurrence.,0.253152591949335,Put the order of the IIsotope List according to the probability of occurrence.," private List<IIsotope> orderList(List<IIsotope> isotopes_TO){
        List<IIsotope> isotopes_TO_Ordered = new ArrayList<IIsotope>();
        List<Double> prob_Occ = new ArrayList<Double>();
        for(IIsotope isotope : isotopes_TO){
            prob_Occ.add(isotope.getProbability());
        }
        Collections.sort(prob_Occ);
        for(Double prob : prob_Occ){
            for(IIsotope isotope : isotopes_TO){
                if(isotope.getProbability() == prob){
                    isotopes_TO_Ordered.add(isotope);
                }
            }
        }
        return isotopes_TO_Ordered;     
 }"," private List<IIsotope> orderList(List<IIsotope> isotopes_TO){
        List<IIsotope> isotopes_TO_Ordered = new ArrayList<IIsotope>();
        List<Double> prob_TO = new ArrayList<Double>();
        for(IIsotope isotope : isotopes_TO){
            prob_TO.add(isotope.getProbability());
        }
        Collections.sort(prob_TO);
        for(Double prob : prob_TO){
            for(IIsotope isotope : isotopes_TO){
                if(isotope.getProbability() == prob){
                    isotopes_TO_Ordered.add(isotope);
                }
            }
        }
        return isotopes_TO_Ordered;     
 }",Not Valid,"private List<IIsotope> orderList(List<IIsotope> isotopes_TO){
        List<IIsotope> isotopes_TO_Ordered = new ArrayList<IIsotope>();
        for(int i = 0; i < isotopes_TO.size(); i++){
            IIsotope isotope = isotopes_TO.get(i);
            int count = mfRange.getIsotopeCount(isotope);
            for(int j = 0; j < count; j++){
                isotopes_TO_Ordered.add(isotope);
            }
        }
        return isotopes_TO_Ordered;     
 }",NOT PASS,NOT PASS,NOT PASS,Not Valid,  0.46451158137589876,  0.46451158137589876,  0.5571171099995503,None,60.0,0.5357142857142857,60.0,0.5357142857142857,49.0,0.4375,None,None,4.0,0.036036036036036036,54.0,0.4864864864864865,None,None,8.0,0.6153846153846154,6.0,0.42857142857142855,7.0,0.4666666666666667
249,matsim-libs,"public AttributeConverter<?> putAttributeConverter(final Class<?> clazz, final AttributeConverter<?> converter){
    return this.converter.putAttributeConverter(clazz, converter);
}",putAttributeConverter,org/matsim/utils/objectattributes/ObjectAttributesXmlReader.java,/matsim/src/main/java/org/matsim/utils/objectattributes/ObjectAttributesXmlReader.java,"/**
	 * Sets the converter for reading attributes of the specified class.
	 *
	 * @param clazz
	 * @param converter
	 * @return the previously registered converter for this class, or <code>null</code> if none was set before.
	 */",110-119,"('putAttributeConverter', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,11.0,Sets the converter for reading attributes of the specified class.,"For the specified class, we define the converter to be used for reading the attributes.",The class is specified and the class reading attributes are set.,0.593543186463413,Sets the converter for reading the attributes of the specified class.," public AttributeConverter<?> putAttributeConverter(final Class<?> clazz, final AttributeConverter<?> converter){
	 	return this.converter.putAttributeConverter(clazz, converter);		
 }"," public AttributeConverter<?> putAttributeConverter(final Class<?> clazz, final AttributeConverter<?> converter){
	 	this.converter.putConverter(clazz, converter);
 	return converter;		
 }"," public AttributeConverter<?> putAttributeConverter(final Class<?> clazz, final AttributeConverter<?> converter){
	 	return this.converter.putAttributeConverter(clazz, converter);		
 }"," public AttributeConverter<?> putAttributeConverter(final Class<?> clazz, final AttributeConverter<?> converter){
	 	return this.converter.putAttributeConverter(clazz, converter);		
 }",PASS,NOT PASS,PASS,PASS,  1.0,  0.7677372171915664,  1.0,  1.0,0.0,0.0,5.0,0.13157894736842105,0.0,0.0,0.0,0.0,5.0,0.13157894736842105,0.0,0.0,0.0,0.0,13.0,0.8125,1.0,0.08333333333333333,11.0,0.9166666666666666
250,shardingsphere-elasticjob,"public boolean hasShardingInfoInOfflineServers(){
    List<String> onlineInstances = jobNodeStorage.getJobNodeChildrenKeys(InstanceNode.ROOT);
    int shardingTotalCount = configService.load(true).getShardingTotalCount();
    for (int i = 0; i < shardingTotalCount; i++) {
        if (!onlineInstances.contains(jobNodeStorage.getJobNodeData(ShardingNode.getInstanceNode(i)))) {
            return true;
        }
    }
    return false;
}",hasShardingInfoInOfflineServers,org/apache/shardingsphere/elasticjob/lite/internal/sharding/ShardingService.java,/elasticjob-lite/elasticjob-lite-core/src/main/java/org/apache/shardingsphere/elasticjob/lite/internal/sharding/ShardingService.java,"/**
     * Query has sharding info in offline servers or not.
     * 
     * @return has sharding info in offline servers or not
     */",211-225,"('hasShardingInfoInOfflineServers', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",80.0,10.0,Query has sharding info in offline servers or not.,Return whether the query has sharding info in offline servers.,There is a query that has sharding info in offline server.,0.283056602238684,The query may or may not contain partitioning information in the offline servers.," public boolean hasShardingInfoInOfflineServers(){
        List<String> offlineServers = serverService.getOfflineServers();
        for (String serverIp : offlineServers) {
            if (jobNodeStorage.isJobNodeExisted(ShardingNode.getServerNode(serverIp))) {
                return true;
            }
        }
        return false;
    }"," public boolean hasShardingInfoInOfflineServers(){
        List<String> offlineServers = serverService.getOfflineServers();
        for (String serverIp : offlineServers) {
            if (serverService.isEnableServer(serverIp)) {
                return true;
            }
        }
        return false;
    }"," public boolean hasShardingInfoInOfflineServers(){
        List<String> offlineServers = serverService.getOfflineServers();
        for (String serverIp : offlineServers) {
            if (serverService.isEnableServer(serverIp)) {
                return true;
            }
        }
        return false;
    }"," public boolean hasShardingInfoInOfflineServers(){
        return jobNodeStorage.isJobNodeExisted(ShardingNode.NECESSARY);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.30435061592217183,  0.2804026763100959,  0.07797161076214387,  0.2804026763100959,40.0,0.49382716049382713,45.0,0.5555555555555556,66.0,0.8148148148148148,45.0,0.5555555555555556,7.0,0.13725490196078433,35.0,0.6862745098039216,7.0,0.13725490196078433,7.0,0.6363636363636364,13.0,0.9285714285714286,8.0,0.6666666666666666
251,glowstone,"public boolean iterateCompoundList(@NonNls String key, Consumer<? super CompoundTag> consumer){
    return readCompoundList(key, compoundTags -> compoundTags.forEach(consumer));
}",iterateCompoundList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to each compound tag in a compound-list subtag, if that subtag
     * exists.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was iterated over (even if it was empty); false otherwise
     */",572-582,"('iterateCompoundList', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,18.0,"Applies the given function to each compound tag in a compound-list subtag, if that subtag  exists.","If a specific subtag exists, we apply the given function to each tag in the compound list of subtags. The function returns true if the tag exists and the function has been called, false otherwise.","If a compound-list subtag exists, apply the given function to it.",0.436413659936604,"Applies the given function to each compound tag in a compound list subtag, if that subtag exists."," public boolean iterateCompoundList(@NonNls String key, Consumer<? super CompoundTag> consumer){
        return readList(key, TagType.COMPOUND, list -> {
            for (Tag tag : list) {
                consumer.accept((CompoundTag) tag);
            }
        });
    }"," public boolean iterateCompoundList(@NonNls String key, Consumer<? super CompoundTag> consumer){
        return readList(key, TagType.COMPOUND, list -> {
            for (Tag tag : list) {
                consumer.accept((CompoundTag) tag);
            }
        });
    }"," public boolean iterateCompoundList(@NonNls String key, Consumer<? super CompoundTag> consumer){
        return readList(key, TagType.COMPOUND, list -> {
            for (Tag tag : list) {
                consumer.accept((CompoundTag) tag);
            }
        });
    }"," public boolean iterateCompoundList(@NonNls String key, Consumer<? super CompoundTag> consumer){
        return readList(key, TagType.COMPOUND, list -> {
            for (Tag tag : list) {
                consumer.accept((CompoundTag) tag);
            }
        });
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6673730531773623,  0.6673730531773623,  0.6673730531773623,  0.6673730531773623,24.0,0.4444444444444444,24.0,0.4444444444444444,24.0,0.4444444444444444,24.0,0.4444444444444444,0.0,0.0,0.0,0.0,0.0,0.0,28.0,0.7777777777777778,2.0,0.1111111111111111,16.0,0.9411764705882353
252,tablesaw,"public Table melt(List<String> idVariables, List<NumericColumn<?>> measuredVariables, Boolean dropMissing){
    Table result = Table.create(name);
    for (String idColName : idVariables) {
        result.addColumns(column(idColName).type().create(idColName));
    }
    result.addColumns(StringColumn.create(MELT_VARIABLE_COLUMN_NAME), DoubleColumn.create(MELT_VALUE_COLUMN_NAME));
    List<String> measureColumnNames = measuredVariables.stream().map(Column::name).collect(Collectors.toList());
    TableSliceGroup slices = splitOn(idVariables.toArray(new String[0]));
    for (TableSlice slice : slices) {
        for (Row row : slice) {
            for (String colName : measureColumnNames) {
                if (!dropMissing || !row.isMissing(colName)) {
                    writeIdVariables(idVariables, result, row);
                    result.stringColumn(MELT_VARIABLE_COLUMN_NAME).append(colName);
                    double value = row.getNumber(colName);
                    result.doubleColumn(MELT_VALUE_COLUMN_NAME).append(value);
                }
            }
        }
    }
    return result;
}",melt,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,"/**
   * Melt implements the 'tidy' melt operation as described in these papers by Hadley Wickham.
   *
   * <p>Tidy concepts: {@see https://www.jstatsoft.org/article/view/v059i10}
   *
   * <p>Cast function details: {@see https://www.jstatsoft.org/article/view/v021i12}
   *
   * <p>In short, melt turns columns into rows, but in a particular way. Used with the cast method,
   * it can help make data tidy. In a tidy dataset, every variable is a column and every observation
   * a row.
   *
   * <p>This method returns a table that contains all the data in this table, but organized such
   * that there is a set of identifier variables (columns) and a single measured variable (column).
   * For example, given a table with columns:
   *
   * <p>patient_id, gender, age, weight, temperature,
   *
   * <p>it returns a table with the columns:
   *
   * <p>patient_id, variable, value
   *
   * <p>In the new format, the strings age, weight, and temperature have become cells in the
   * measurement table, such that a single row in the source table might look like this in the
   * result table:
   *
   * <p>1234, gender, male 1234, age, 42 1234, weight, 186 1234, temperature, 97.4
   *
   * <p>This kind of structure often makes for a good intermediate format for performing subsequent
   * transformations. It is especially useful when combined with the {@link #cast()} operation
   *
   * @param idVariables A list of column names intended to be used as identifiers. In he example,
   *     only patient_id would be an identifier
   * @param measuredVariables A list of columns intended to be used as measured variables. All
   *     columns must have the same type
   * @param dropMissing drop any row where the value is missing
   */",1554-1619,"('melt', {'INSTRUCTION': {'covered': 123, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 22, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",214.0,16.0,Melt implements the 'tidy' melt operation as described in these papers by Hadley Wickham.,The function Melt implements the same melt operation described in the papers by Hadley Wickham.,The 'tidy' melt operation is described in these papers.,1.01330556827075,"Melt implements the ""ordered"" merge operation described in these articles by Hadley Wickham.",Not Valid," public Table melt(List<String> idVariables, List<NumericColumn<?>> measuredVariables, Boolean dropMissing){
    if (idVariables.size() != measuredVariables.size()) {
      throw new IllegalArgumentException(
          ""The number of id variables must match the number of measured variables"");
    }
    if (idVariables.isEmpty()) {
      throw new IllegalArgumentException(""At least one id variable must be specified"");
    }
    if (measuredVariables.isEmpty()) {
      throw new IllegalArgumentException(""At least one measured variable must be specified"");
    }
    if (dropMissing == null) {
      throw new IllegalArgumentException(""dropMissing must be specified"");
    }
    if (dropMissing) {
      return melt(idVariables, measuredVariables);
    } else {
      return melt(idVariables, measuredVariables, false);
    }   
 }",Not Valid,"public Table melt(List<String> idVariables, List<NumericColumn<?>> measuredVariables, Boolean dropMissing){
    if (idVariables.size() != measuredVariables.size()) {
      throw new IllegalArgumentException(
          ""The number of id variables must match the number of measured variables"");
    }
    if (idVariables.isEmpty()) {
      throw new IllegalArgumentException(""At least one id variable must be specified"");
    }
    if (measuredVariables.isEmpty()) {
      throw new IllegalArgumentException(""At least one measured variable must be specified"");
    }
  
    // Create the new table
    Table newTable = Table.create(this.name);
  
    // Create the new columns
    for (int i = 0; i < measuredVariables.size(); i++) {
      NumericColumn<?> measuredVariable = measuredVariables.get(i);
      String idVariable = idVariables.get(i);
      String newColumnName = measuredVariable.name() + ""_"" + idVariable;
      newTable.addColumn(measuredVariable.type(), newColumnName);
    }
  
    // Create the new rows
    for (int row = 0; row < this.rowCount(); row++) {
      for (int i = 0; i < measuredVariables.size(); i++) {
        NumericColumn<?> measuredVariable = measuredVariables.get(i);
        String idVariable = idVariables.get(i);
        String newColumnName = measuredVariable.name() + ""_"" + idVariable;
        newTable.set(newColumnName, row, measuredVariable.get(row));
      }
    }
  
    // Drop missing values
    if (dropMissing != null && dropMissing) {
      newTable.dropMissing();
    }
  
    return newTable;    
 }",Not Valid,NOT PASS,NOT PASS,Not Valid,None,  0.198038213512777,  0.31796949580517575,None,None,None,148.0,0.6883720930232559,185.0,0.6751824817518248,None,None,123.0,0.9919354838709677,273.0,0.9963503649635036,None,None,5.0,0.3125,4.0,0.26666666666666666,8.0,0.5333333333333333
253,tablesaw,"StringColumn hourMinute(){
    StringColumn newColumn = StringColumn.create(this.name() + "" hour & minute"");
    for (int r = 0; r < this.size(); r++) {
        long c1 = this.getLongInternal(r);
        if (DateTimeColumn.valueIsMissing(c1)) {
            newColumn.append(StringColumnType.missingValueIndicator());
        } else {
            String hm = Strings.padStart(String.valueOf(getHour(c1)), 2, '0');
            hm = hm + "":"" + Strings.padStart(String.valueOf(getMinute(c1)), 2, '0');
            newColumn.append(hm);
        }
    }
    return newColumn;
}",hourMinute,tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,"/**
   * Returns a StringColumn with the year and week-of-year derived from this column concatenated
   * into a String that will sort lexicographically in temporal order.
   *
   * <p>This simplifies the production of plots and tables that aggregate values into standard
   * temporal units (e.g., you want monthly data but your source data is more than a year long and
   * you don't want months from different years aggregated together).
   */",261-282,"('hourMinute', {'INSTRUCTION': {'covered': 55, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",134.0,24.0,Returns a StringColumn with the year and week-of-year derived from this column concatenated  into a String that will sort lexicographically in temporal order.,Create a String Column that contains the year and the week of the year. The column is sorted lexicographically in temporal order.,The year and week-of-year derived from this column will be returned as a String.,0.361055965283091,Returns a StringColumn with the year and week of the year derived from this column concatenated into a String that will sort lexicographically in temporal order.,"StringColumn hourMinute(){
    StringColumn newColumn = StringColumn.create(this.name() + "" hour & minute"");
    for (int r = 0; r < this.size(); r++) {
      long c1 = this.getLongInternal(r);
      if (DateTimeColumn.valueIsMissing(c1)) {
        newColumn.append(StringColumnType.missingValueIndicator());
      } else {
        String ym = String.valueOf(getHour(c1));
        ym = ym + ""-"" + Strings.padStart(String.valueOf(getMinute(c1)), 2, '0');
        newColumn.append(ym);
      }
    }
    return newColumn;
  }","StringColumn hourMinute(){
    StringColumn newColumn = StringColumn.create(this.name() + "" hour & minute"");
    for (int r = 0; r < this.size(); r++) {
      long c1 = this.getLongInternal(r);
      if (DateTimeColumn.valueIsMissing(c1)) {
        newColumn.append(StringColumnType.missingValueIndicator());
      } else {
        String ym = String.valueOf(getHour(c1));
        ym = ym + ""-"" + Strings.padStart(String.valueOf(getMinute(c1)), 2, '0');
        newColumn.append(ym);
      }
    }
    return newColumn;   
 }","StringColumn hourMinute(){
    StringColumn newColumn = StringColumn.create(this.name() + "" hour & minute"");
    for (int r = 0; r < this.size(); r++) {
      long c1 = this.getLongInternal(r);
      if (DateTimeColumn.valueIsMissing(c1)) {
        newColumn.append(StringColumnType.missingValueIndicator());
      } else {
        String hm = String.valueOf(getHour(c1));
        hm = hm + "":"" + Strings.padStart(String.valueOf(getMinute(c1)), 2, '0');
        newColumn.append(hm);
      }
    }
    return newColumn;   
 }","StringColumn hourMinute(){
    StringColumn newColumn = StringColumn.create(this.name() + "" hour & minute"");
    for (int r = 0; r < this.size(); r++) {
      long c1 = this.getLongInternal(r);
      if (DateTimeColumn.valueIsMissing(c1)) {
        newColumn.append(StringColumnType.missingValueIndicator());
      } else {
        String ym = String.valueOf(getHour(c1));
        ym = ym + ""-"" + Strings.padStart(String.valueOf(getMinute(c1)), 2, '0');
        newColumn.append(ym);
      }
    }
    return newColumn;   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8108224525708798,  0.8163780081264354,  0.8163780081264354,  0.8643937231755574,14.0,0.1037037037037037,14.0,0.1037037037037037,14.0,0.1037037037037037,9.0,0.06666666666666667,0.0,0.0,0.0,0.0,5.0,0.03968253968253968,17.0,0.7083333333333334,4.0,0.14814814814814814,15.0,0.625
255,matsim-libs,"private Map<Id<Link>, Link> findCluster(final Link startLink, final Set<String> modes){
    final Map<Id<Link>, DoubleFlagRole> linkRoles = new HashMap<>(this.network.getLinks().size());
    ArrayList<Node> pendingForward = new ArrayList<>();
    ArrayList<Node> pendingBackward = new ArrayList<>();
    TreeMap<Id<Link>, Link> clusterLinks = new TreeMap<>();
    pendingForward.add(startLink.getToNode());
    pendingBackward.add(startLink.getFromNode());
    while (pendingForward.size() > 0) {
        int idx = pendingForward.size() - 1;
        Node currNode = pendingForward.remove(idx);
        for (Link link : currNode.getOutLinks().values()) {
            if (intersectingSets(modes, link.getAllowedModes())) {
                DoubleFlagRole r = getDoubleFlag(link, linkRoles);
                if (!r.forwardFlag) {
                    r.forwardFlag = true;
                    pendingForward.add(link.getToNode());
                }
            }
        }
    }
    while (pendingBackward.size() > 0) {
        int idx = pendingBackward.size() - 1;
        Node currNode = pendingBackward.remove(idx);
        for (Link link : currNode.getInLinks().values()) {
            if (intersectingSets(modes, link.getAllowedModes())) {
                DoubleFlagRole r = getDoubleFlag(link, linkRoles);
                if (!r.backwardFlag) {
                    r.backwardFlag = true;
                    pendingBackward.add(link.getFromNode());
                    if (r.forwardFlag) {
                        clusterLinks.put(link.getId(), link);
                    }
                }
            }
        }
    }
    return clusterLinks;
}",findCluster,org/matsim/core/network/algorithms/MultimodalNetworkCleaner.java,/matsim/src/main/java/org/matsim/core/network/algorithms/MultimodalNetworkCleaner.java,"/**
	 * Finds the cluster of links <pre>startLink</pre> is part of. The cluster
	 * contains all links which can be reached starting at <code>startLink</code>
	 * and from where it is also possible to return again to <code>startLink</code>.
	 *
	 * @param startLink the link to start building the cluster
	 * @param modes the set of modes that are allowed to
	 * @return cluster of links <pre>startLink</pre> is part of
	 */",168-224,"('findCluster', {'INSTRUCTION': {'covered': 137, 'missed': 0}, 'BRANCH': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 31, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",347.0,16.0,Finds the cluster of links <pre>startLink</pre> is part of.,"Starting from <pre>startLink</pre>, we look for the cluster of links that contain it. All these links can be reached starting from <code>startLink</code> and from where we can also return again to <code>startLink</code>",Starts with the startLink and ends with the part of the cluster.,0.247843138528595,Finds the link cluster that <pre>startLink</pre> is a part of.," private Map<Id<Link>, Link> findCluster(final Link startLink, final Set<String> modes){
	 		final Map<Id<Link>, Link> visitedLinks = new TreeMap<>();
 		final Map<Id<Link>, Link> cluster = new TreeMap<>();
 		final Queue<Link> queue = new LinkedList<>();
 		queue.add(startLink);
 		visitedLinks.put(startLink.getId(), startLink);
 		while (!queue.isEmpty()) {
 			Link currentLink = queue.remove();
 			if (intersectingSets(modes, currentLink.getAllowedModes())) {
 				cluster.put(currentLink.getId(), currentLink);
 				for (Link outLink : currentLink.getToNode().getOutLinks().values()) {
 					if (!visitedLinks.containsKey(outLink.getId())) {
 						visitedLinks.put(outLink.getId(), outLink);
 						queue.add(outLink);
 					}
 				}
 				for (Link inLink : currentLink.getFromNode().getInLinks().values()) {
 					if (!visitedLinks.containsKey(inLink.getId())) {
 						visitedLinks.put(inLink.getId(), inLink);
 						queue.add(inLink);
 					}
 				}
 			}
 		}
 		return cluster;
 	}"," private Map<Id<Link>, Link> findCluster(final Link startLink, final Set<String> modes){
	 		final Map<Id<Link>, Link> visitedLinks = new TreeMap<>();
 		final Map<Id<Link>, Link> cluster = new TreeMap<>();
 		final Queue<Link> queue = new LinkedList<>();
 		queue.add(startLink);
 		visitedLinks.put(startLink.getId(), startLink);
 		while (!queue.isEmpty()) {
 			Link currentLink = queue.remove();
 			if (intersectingSets(modes, currentLink.getAllowedModes())) {
 				cluster.put(currentLink.getId(), currentLink);
 				for (Link outLink : currentLink.getToNode().getOutLinks().values()) {
 					if (!visitedLinks.containsKey(outLink.getId())) {
 						visitedLinks.put(outLink.getId(), outLink);
 						queue.add(outLink);
 					}
 				}
 				for (Link inLink : currentLink.getFromNode().getInLinks().values()) {
 					if (!visitedLinks.containsKey(inLink.getId())) {
 						visitedLinks.put(inLink.getId(), inLink);
 						queue.add(inLink);
 					}
 				}
 			}
 		}
 		return cluster;
 	}"," private Map<Id<Link>, Link> findCluster(final Link startLink, final Set<String> modes){
	 		Map<Id<Link>, Link> visitedLinks = new TreeMap<>();
 		Map<Id<Link>, Link> cluster = new TreeMap<>();
 		Queue<Link> queue = new LinkedList<>();
 		queue.add(startLink);
 		visitedLinks.put(startLink.getId(), startLink);
 		while (!queue.isEmpty()) {
 			Link currentLink = queue.poll();
 			if (intersectingSets(modes, currentLink.getAllowedModes())) {
 				cluster.put(currentLink.getId(), currentLink);
 				for (Link link : currentLink.getToNode().getOutLinks().values()) {
 					if (!visitedLinks.containsKey(link.getId())) {
 						visitedLinks.put(link.getId(), link);
 						queue.add(link);
 					}
 				}
 				for (Link link : currentLink.getFromNode().getInLinks().values()) {
 					if (!visitedLinks.containsKey(link.getId())) {
 						visitedLinks.put(link.getId(), link);
 						queue.add(link);
 					}
 				}
 			}
 		}
 		return cluster;
 	}"," private Map<Id<Link>, Link> findCluster(final Link startLink, final Set<String> modes){
	 		final Map<Id<Link>, Link> visitedLinks = new TreeMap<>();
 		final Map<Id<Link>, Link> cluster = new TreeMap<>();
 		final Queue<Link> queue = new LinkedList<>();
 		queue.add(startLink);
 		visitedLinks.put(startLink.getId(), startLink);
 		while (!queue.isEmpty()) {
 			Link currentLink = queue.poll();
 			if (intersectingSets(modes, currentLink.getAllowedModes())) {
 				cluster.put(currentLink.getId(), currentLink);
 				for (Link link : currentLink.getToNode().getOutLinks().values()) {
 					if (!visitedLinks.containsKey(link.getId())) {
 						visitedLinks.put(link.getId(), link);
 						queue.add(link);
 					}
 				}
 				for (Link link : currentLink.getFromNode().getInLinks().values()) {
 					if (!visitedLinks.containsKey(link.getId())) {
 						visitedLinks.put(link.getId(), link);
 						queue.add(link);
 					}
 				}
 			}
 		}
 		return cluster;
 	}",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.43029579533896667,  0.4479428541624961,  0.44648629493670045,  0.46062804242272876,196.0,0.5632183908045977,196.0,0.5632183908045977,192.0,0.5517241379310345,192.0,0.5517241379310345,0.0,0.0,11.0,0.04182509505703422,14.0,0.053231939163498096,28.0,0.8484848484848485,4.0,0.36363636363636365,10.0,0.7692307692307693
256,weblogic-kubernetes-operator,"public static String toExternalServiceName(String domainUid, String serverName){
    return toDns1123LegalName(String.format(EXTERNAL_SERVICE_PATTERN, domainUid, serverName, getExternalServiceNameSuffix()));
}",toExternalServiceName,oracle/kubernetes/operator/helpers/LegalNames.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/LegalNames.java,"/**
   * Generates the introspector job name based on the given domainUid.
   *
   * @param domainUid domainUid
   * @param serverName WebLogic server name
   * @return String introspector job name
   */",108-121,"('toExternalServiceName', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,11.0,Generates the introspector job name based on the given domainUid.,"Given a domainUid, generates the introspector job name.",The job name is generated based on the domainUid.,0.224815792081671,Generates the name of the introspector task based on the given domainUid.,"public static String toExternalServiceName(String domainUid, String serverName){
    return toDns1123LegalName(String.format(
        EXTERNAL_SERVICE_PATTERN,
        domainUid,
        serverName,
        getExternalServiceNameSuffix()));
  }"," public static String toExternalServiceName(String domainUid, String serverName){
    return toExternalServiceName(domainUid, serverName, getExternalServiceNameSuffix());    
 }"," public static String toExternalServiceName(String domainUid, String serverName){
    return toExternalServiceName(domainUid, serverName, DEFAULT_EXTERNAL_SERVICE_NAME_SUFFIX);    
 }","public static String toExternalServiceName(String domainUid, String serverName){
    return toDns1123LegalName(String.format(
        EXTERNAL_SERVICE_PATTERN,
        domainUid,
        serverName,
        getExternalServiceNameSuffix()));   
 }",PASS,NOT PASS,PASS,NOT PASS,  1.0,  0.7157243610108701,  1.0,  0.6097936105486604,0.0,0.0,8.0,0.24242424242424243,0.0,0.0,11.0,0.3333333333333333,8.0,0.24242424242424243,0.0,0.0,11.0,0.3333333333333333,10.0,0.9090909090909091,5.0,0.38461538461538464,6.0,0.5454545454545454
257,jeromq,"public boolean sendPicture(Socket socket, String picture, Object... args){
    if (!FORMAT.matcher(picture).matches()) {
        throw new ZMQException(picture + "" is not in expected format "" + FORMAT.pattern(), ZError.EPROTO);
    }
    ZMsg msg = new ZMsg();
    for (int pictureIndex = 0, argIndex = 0; pictureIndex < picture.length(); pictureIndex++, argIndex++) {
        char pattern = picture.charAt(pictureIndex);
        switch(pattern) {
            case 'i':
                {
                    msg.add(String.format(""%d"", (int) args[argIndex]));
                    break;
                }
            case '1':
                {
                    msg.add(String.format(""%d"", (0xff) & (int) args[argIndex]));
                    break;
                }
            case '2':
                {
                    msg.add(String.format(""%d"", (0xffff) & (int) args[argIndex]));
                    break;
                }
            case '4':
                {
                    msg.add(String.format(""%d"", (0xffffffff) & (int) args[argIndex]));
                    break;
                }
            case '8':
                {
                    msg.add(String.format(""%d"", (long) args[argIndex]));
                    break;
                }
            case 's':
                {
                    msg.add((String) args[argIndex]);
                    break;
                }
            case 'b':
            case 'c':
                {
                    msg.add((byte[]) args[argIndex]);
                    break;
                }
            case 'f':
                {
                    msg.add((ZFrame) args[argIndex]);
                    break;
                }
            case 'm':
                {
                    ZMsg msgParm = (ZMsg) args[argIndex];
                    while (msgParm.size() > 0) {
                        msg.add(msgParm.pop());
                    }
                    break;
                }
            case 'z':
                {
                    msg.add((byte[]) null);
                    argIndex--;
                    break;
                }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    return msg.send(socket, false);
}",sendPicture,org/zeromq/proto/ZPicture.java,/src/main/java/org/zeromq/proto/ZPicture.java,"/**
     * Queues a 'picture' message to the socket (or actor), so it can be sent.
     *
     * @param picture The picture is a string that defines the type of each frame.
     *                This makes it easy to send a complex multiframe message in
     *                one call. The picture can contain any of these characters,
     *                each corresponding to zero or one arguments:
     *
     *                <table>
     *                <caption> </caption>
     *                <tr><td>i = int  (stores signed integer)</td></tr>
     *                <tr><td>1 = byte (stores 8-bit unsigned integer)</td></tr>
     *                <tr><td>2 = int  (stores 16-bit unsigned integer)</td></tr>
     *                <tr><td>4 = long (stores 32-bit unsigned integer)</td></tr>
     *                <tr><td>8 = long (stores 64-bit unsigned integer)</td></tr>
     *                <tr><td>s = String</td></tr>
     *                <tr><td>b = byte[]</td></tr>
     *                <tr><td>c = byte[]</td></tr>
     *                <tr><td>f = ZFrame</td></tr>
     *                <tr><td>m = ZMsg (sends all frames in the ZMsg)<b>Has to be the last element of the picture</b></td></tr>
     *                <tr><td>z = sends zero-sized frame (0 arguments)</td></tr>
     *                </table>
     *                Note that s, b, f and m are encoded the same way and the choice is
     *                offered as a convenience to the sender, which may or may not already
     *                have data in a ZFrame or ZMsg. Does not change or take ownership of
     *                any arguments.
     *
     *                Also see {@link #recvPicture(Socket, String)}} how to recv a
     *                multiframe picture.
     * @param args    Arguments according to the picture
     * @return true if successful, false if sending failed for any reason
     */",247-339,"('sendPicture', {'INSTRUCTION': {'covered': 183, 'missed': 16}, 'BRANCH': {'covered': 16, 'missed': 3}, 'LINE': {'covered': 29, 'missed': 1}, 'COMPLEXITY': {'covered': 13, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",400.0,19.0,"Queues a 'picture' message to the socket (or actor), so it can be sent.","The function add a 'picture' message to the socket/actor queue, in order to be sent.",The picture message is sent to the actor.,0.299505152296428,"Queues an ""image"" message on the socket (or actor), so that it can be sent."," public boolean sendPicture(Socket socket, String picture, Object... args){
        return msgPicture(picture, args).send(socket);      
 }"," public boolean sendPicture(Socket socket, String picture, Object... args){
        return msgPicture(picture, args).send(socket);      
 }"," public boolean sendPicture(Socket socket, String picture, Object... args){
        return msgPicture(picture, args).send(socket);      
 }"," public boolean sendPicture(Socket socket, String picture, Object... args){
        return msgPicture(picture, args).send(socket);      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.045338725565487945,  0.045338725565487945,  0.045338725565487945,  0.045338725565487945,373.0,0.9301745635910225,373.0,0.9301745635910225,373.0,0.9301745635910225,373.0,0.9301745635910225,0.0,0.0,0.0,0.0,0.0,0.0,9.0,0.5625,4.0,0.25,13.0,0.8666666666666667
258,cdk,"TextOutline positionChargeLabel(int hydrogens, HydrogenPosition position, TextOutline charge, TextOutline element, TextOutline hydrogen){
    final Rectangle2D chargeBounds = charge.getBounds();
    Rectangle2D referenceBounds = element.getBounds();
    if (hydrogens > 0 && (position == Left || position == Right))
        referenceBounds = hydrogen.getBounds();
    if (position == Left)
        return charge.translate((referenceBounds.getMinX() - padding) - chargeBounds.getMaxX(), (referenceBounds.getMinY() - (chargeBounds.getHeight() / 2)) - chargeBounds.getMinY());
    else
        return charge.translate((referenceBounds.getMaxX() + padding) - chargeBounds.getMinX(), (referenceBounds.getMinY() - (chargeBounds.getHeight() / 2)) - chargeBounds.getMinY());
}",positionChargeLabel,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,"/**
     * Position the charge label on the top right of either the element or hydrogen label. Where the
     * charge is placed depends on the number of hydrogens and their position relative to the
     * element symbol.
     *
     * @param hydrogens number of hydrogen
     * @param position  position of hydrogen
     * @param charge    the charge label outline (to be positioned)
     * @param element   the element label outline
     * @param hydrogen  the hydrogen label outline
     * @return positioned charge label
     */",493-526,"('positionChargeLabel', {'INSTRUCTION': {'covered': 62, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",162.0,16.0,Position the charge label on the top right of either the element or hydrogen label.,"Given a charge, put the charge label on the top right of the element or of the hydrogen label. The position of the charge depends on the number of hydrogens and on their position in the element symbol.",The charge label should be on the top right of the element.,0.0442017544502708,Place the charging label at the top right of the item or hydrogen label.,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,26.0,0.6666666666666666,5.0,0.3125,9.0,0.5625
259,acs-aem-commons,"protected String resultToPlainText(final String title, final List<HealthCheckExecutionResult> results){
    final StringBuilder sb = new StringBuilder();
    sb.append(title);
    sb.append(System.lineSeparator());
    if (results.size() == 0) {
        sb.append(""No "" + StringUtils.lowerCase(title) + "" could be found!"");
        sb.append(System.lineSeparator());
    } else {
        sb.append(StringUtils.repeat(""-"", NUM_DASHES));
        sb.append(System.lineSeparator());
        for (final HealthCheckExecutionResult result : results) {
            sb.append(StringUtils.rightPad(""[ "" + result.getHealthCheckResult().getStatus().name() + "" ]"", HEALTH_CHECK_STATUS_PADDING));
            sb.append(""  "");
            sb.append(result.getHealthCheckMetadata().getTitle());
            sb.append(System.lineSeparator());
        }
    }
    return sb.toString();
}",resultToPlainText,com/adobe/acs/commons/hc/impl/HealthCheckStatusEmailer.java,/bundle/src/main/java/com/adobe/acs/commons/hc/impl/HealthCheckStatusEmailer.java,"/**
     * Gererates the plain-text email sections for sets of Health Check Execution Results.
     *
     * @param title The section title
     * @param results the  Health Check Execution Results to render as plain text
     * @return the String for this section to be embedded in the e-mail
     */",262-291,"('resultToPlainText', {'INSTRUCTION': {'covered': 90, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",191.0,13.0,Gererates the plain-text email sections for sets of Health Check Execution Results.,Create for the sets of Health Check Execution Results the section of the email with the plain-text.,The plain-text email sections for the Health Check Execution Results are gererates.,0.367476340322326,Manage plain text email sections for status check execution result sets.," protected String resultToPlainText(final String title, final List<HealthCheckExecutionResult> results){
        final StringBuilder sb = new StringBuilder();
        sb.append(title);
        sb.append(""\n"");
        sb.append(""\n"");
        for (HealthCheckExecutionResult result : results) {
            sb.append(result.getHealthCheck().getName());
            sb.append(""\n"");
            sb.append(result.getHealthCheck().getDescription());
            sb.append(""\n"");
            sb.append(""\n"");
        }
        return sb.toString();
    }"," protected String resultToPlainText(final String title, final List<HealthCheckExecutionResult> results){
        final StringBuilder sb = new StringBuilder();
        sb.append(title);
        sb.append(""\n"");
        sb.append(""\n"");
        for (HealthCheckExecutionResult result : results) {
            sb.append(result.getHealthCheck().getName());
            sb.append(""\n"");
            sb.append(result.getHealthCheck().getDescription());
            sb.append(""\n"");
            sb.append(""\n"");
        }
        return sb.toString();
    }"," protected String resultToPlainText(final String title, final List<HealthCheckExecutionResult> results){
        final StringBuilder sb = new StringBuilder();
        sb.append(title).append(""\n"");
        for (HealthCheckExecutionResult result : results) {
            sb.append(result.getHealthCheck().getName()).append(""\n"");
            sb.append(result.getHealthCheckResult().getMessage()).append(""\n"");
            sb.append(""\n"");
        }
        return sb.toString();
    }"," protected String resultToPlainText(final String title, final List<HealthCheckExecutionResult> results){
        final StringBuilder sb = new StringBuilder();
        sb.append(title).append(""\n"");
        for (HealthCheckExecutionResult result : results) {
            sb.append(result.getHealthCheck().getName()).append(""\n"");
            sb.append(result.getHealthCheckResult().getMessage()).append(""\n"");
            sb.append(""\n"");
        }
        return sb.toString();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4892657834085916,  0.4892657834085916,  0.4206500643639549,  0.4206500643639549,93.0,0.484375,93.0,0.484375,103.0,0.5364583333333334,103.0,0.5364583333333334,0.0,0.0,15.0,0.13043478260869565,15.0,0.13043478260869565,15.0,0.8333333333333334,9.0,0.6923076923076923,7.0,0.5384615384615384
260,cdk,"public Iterable<IAtom> atoms(){
    return new Iterable<IAtom>() {

        @Override
        public Iterator<IAtom> iterator() {
            return new AtomsIterator();
        }
    };
}",atoms,org/openscience/cdk/Bond.java,/base/data/src/main/java/org/openscience/cdk/Bond.java,"/**
     * Returns the Iterator to atoms making up this bond.
     * Iterator.remove() is not implemented.
     *
     * @return An Iterator to atoms participating in this bond
     * @see #setAtoms
     */",158-174,"('atoms', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,10.0,Returns the Iterator to atoms making up this bond.,Returns for the atoms in the bond the Iterator.,This bond is made up of atoms.,0.228279668519479,Returns the iterator to the atoms that make up this bond.,Not Valid," public Iterable<IAtom> atoms(){
        return new IteratorIterable<IAtom>(atoms);
    }",Not Valid,Not Valid,Not Valid,NOT PASS,Not Valid,Not Valid,None, 0.2736786168727329,None,None,None,None,21.0,0.525,None,None,None,None,20.0,0.9523809523809523,None,None,None,None,8.0,0.8,4.0,0.3333333333333333,8.0,0.8
261,egeria,"public String upsertSchemaType(String userId, SchemaType schemaType, String externalSourceName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
    final String methodName = ""upsertSchemaType"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateName(schemaType.getQualifiedName(), QUALIFIED_NAME_PROPERTY_NAME, methodName);
    invalidParameterHandler.validateName(schemaType.getDisplayName(), DISPLAY_NAME_PROPERTY_NAME, methodName);
    Optional<EntityDetail> originalSchemaTypeEntity = findSchemaTypeEntity(userId, schemaType.getQualifiedName());
    SchemaTypeBuilder schemaTypeBuilder = getSchemaTypeBuilder(schemaType);
    String externalSourceGUID = dataEngineRegistrationHandler.getExternalDataEngine(userId, externalSourceName);
    String schemaTypeGUID;
    if (originalSchemaTypeEntity.isEmpty()) {
        schemaTypeGUID = schemaTypeHandler.addSchemaType(userId, externalSourceGUID, externalSourceName, schemaTypeBuilder, methodName);
    } else {
        schemaTypeGUID = originalSchemaTypeEntity.get().getGUID();
        EntityDetail updatedSchemaTypeEntity = buildSchemaTypeEntityDetail(schemaTypeGUID, schemaType);
        EntityDetailDifferences entityDetailDifferences = repositoryHelper.getEntityDetailDifferences(originalSchemaTypeEntity.get(), updatedSchemaTypeEntity, true);
        if (entityDetailDifferences.hasInstancePropertiesDifferences()) {
            schemaTypeHandler.updateSchemaType(userId, externalSourceGUID, externalSourceName, schemaTypeGUID, SCHEMA_TYPE_GUID_PARAMETER_NAME, schemaTypeBuilder);
        }
    }
    dataEngineSchemaAttributeHandler.upsertSchemaAttributes(userId, schemaType.getAttributeList(), externalSourceName, externalSourceGUID, schemaTypeGUID);
    return schemaTypeGUID;
}",upsertSchemaType,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineSchemaTypeHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineSchemaTypeHandler.java,"/**
     * Create the schema type entity, with the corresponding schema attributes and relationships if it doesn't exist or
     * updates the existing one.
     *
     * @param userId             the name of the calling user
     * @param schemaType         the schema type values
     * @param externalSourceName the unique name of the external source
     *
     * @return unique identifier of the schema type in the repository
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",79-127,"('upsertSchemaType', {'INSTRUCTION': {'covered': 92, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",225.0,24.0,"Create the schema type entity, with the corresponding schema attributes and relationships if it doesn't exist or  updates the existing one.","Create the schema type entity. It contains the schema attributes and relationship, updating them if they already exist.","If the existing entity doesn't exist or is not updated, create a new entity with the corresponding attributes and relationships.",0.36938886623245,"Create the schema entity, with the corresponding attributes and schema relationships if it does not exist, or update the existing entity."," public String upsertSchemaType(String userId, SchemaType schemaType, String externalSourceName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
        final String methodName = ""upsertSchemaType"";
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateObject(schemaType, SCHEMA_TYPE_TYPE_NAME, methodName);
    
        String schemaTypeGUID = null;
        if (schemaType.getGUID() != null) {
            schemaTypeGUID = schemaType.getGUID();
        } else {
            schemaTypeGUID = dataEngineRegistrationHandler.getExternalDataEngineGUID(userId, externalSourceName);
        }
    
        EntityDetail entity = dataEngineCommonHandler.getEntityDetail(userId, schemaTypeGUID, methodName);
        if (entity == null) {
            entity = createSchemaType(userId, schemaType, externalSourceName);
        } else {
            entity = updateSchemaType(userId, schemaType, entity, externalSourceName);
        }
    
        return entity.getGUID();        
 }"," public String upsertSchemaType(String userId, SchemaType schemaType, String externalSourceName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
        final String methodName = ""upsertSchemaType"";
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateObject(schemaType, SCHEMA_TYPE_TYPE_NAME, methodName);
    
        String schemaTypeGUID = null;
        EntityDetail schemaTypeEntity = null;
        EntityDetailDifferences schemaTypeDifferences = null;
    
        try {
            schemaTypeGUID = schemaType.getGUID();
            if (schemaTypeGUID == null) {
                schemaTypeGUID = repositoryHelper.getGUIDFromName(userId, externalSourceName, TABULAR_SCHEMA_TYPE_TYPE_NAME, schemaType.getName());
            }
    
            if (schemaTypeGUID == null) {
                schemaTypeEntity = createSchemaTypeEntity(userId, schemaType, externalSourceName);
                schemaTypeGUID = schemaTypeEntity.getGUID();
            } else {
                schemaTypeEntity = repositoryHelper.getEntityForUpdate(userId, schemaTypeGUID, externalSourceName, methodName);
                schemaTypeDifferences = new EntityDetailDifferences(schemaTypeEntity);
                updateSchemaTypeEntity(userId, schemaType, schemaTypeDifferences, externalSourceName);
            }
    
            if (schemaTypeDifferences != null) {
                schemaTypeEntity = repositoryHelper.updateEntity(userId, schemaTypeEntity, schemaTypeDifferences, methodName);
            }
    
            return schemaTypeGUID;
        } catch (FunctionNotSupportedException error) {
            throw new PropertyServerException(DataEngineErrorCode.FUNCTION_NOT_SUPPORTED.getMessageDefinition(methodName),
                                                this.getClass().getName(), methodName, error);
        } catch (org.odpi.openmetadata.repositoryservices.ffdc.exception.EntityNotKnownException error) {
            throw new PropertyServerException(DataEngineErrorCode.ENTITY_NOT_KNOWN.getMessageDefinition(methodName),
                                                this.getClass().getName(), methodName, error);
        } catch (org.       
 }"," public String upsertSchemaType(String userId, SchemaType schemaType, String externalSourceName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
        final String methodName = ""upsertSchemaType"";
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateGUID(schemaType.getGUID(), GUID_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateName(schemaType.getName(), QUALIFIED_NAME_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateName(schemaType.getDisplayName(), DISPLAY_NAME_PROPERTY_NAME, methodName);
        invalidParameterHandler.validateExternalSourceName(externalSourceName, methodName);
    
        EntityDetail entity = null;
        try {
            entity = repositoryHelper.getEntityForUpdate(userId,
                    schemaType.getGUID(),
                    SCHEMA_TYPE_TYPE_GUID,
                    methodName);
        } catch (org.odpi.openmetadata.repositoryservices.ffdc.exception.EntityNotKnownException e) {
            entity = null;
        }
    
        if (entity == null) {
            entity = new EntityDetail();
            entity.setEntityType(SCHEMA_TYPE_TYPE_GUID);
            entity.setGUID(schemaType.getGUID());
            entity.setQualifiedName(schemaType.getName());
            entity.setDisplayName(schemaType.getDisplayName());
            entity.setStatus(InstanceStatus.ACTIVE);
            entity.setExternalSourceGUID(externalSourceName);
            entity.setExternalSourceName(externalSourceName);
            entity.setProperties(new HashSet<>());
            entity.setClassifications(new HashSet<>());
            entity.setRelationships(new HashSet<>());
        }
    
        entity = schemaTypeHandler.updateSchemaType(userId, entity, schemaType);
    
        return entity.getGUID();        
 }"," public String upsertSchemaType(String userId, SchemaType schemaType, String externalSourceName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
        final String methodName = ""upsertSchemaType"";
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateObject(schemaType, methodName);
    
        String externalDataEngineGUID = dataEngineRegistrationHandler.getExternalDataEngineGUID(userId, externalSourceName);
    
        EntityDetail entity = schemaTypeHandler.getEntityByGUID(userId, schemaType.getGUID(), externalDataEngineGUID, methodName);
    
        if (entity == null) {
            entity = createSchemaTypeEntity(userId, schemaType, externalDataEngineGUID, methodName);
        } else {
            entity = updateSchemaTypeEntity(userId, schemaType, entity, externalDataEngineGUID, methodName);
        }
    
        return entity.getGUID();        
 }",NOT PASS,Syntax Error,NOT PASS,NOT PASS,  0.3820787569515375,None,  0.3552120040712209,  0.4770713342848607,130.0,0.5752212389380531,None,None,136.0,0.6017699115044248,164.0,0.5963636363636363,None,None,45.0,0.3146853146853147,179.0,0.6509090909090909,14.0,0.6363636363636364,8.0,0.36363636363636365,20.0,0.9090909090909091
262,cdk,"private static String muliplier(String formula, int factor){
    String finalformula = """";
    String recentElementSymbol = """";
    String recentElementCountString = ""0"";
    for (int f = 0; f < formula.length(); f++) {
        char thisChar = formula.charAt(f);
        if (f < formula.length()) {
            if (thisChar >= 'A' && thisChar <= 'Z') {
                recentElementSymbol = String.valueOf(thisChar);
                recentElementCountString = ""0"";
            }
            if (thisChar >= 'a' && thisChar <= 'z') {
                recentElementSymbol += thisChar;
            }
            if (thisChar >= '0' && thisChar <= '9') {
                recentElementCountString += thisChar;
            }
        }
        if (f == formula.length() - 1 || (formula.charAt(f + 1) >= 'A' && formula.charAt(f + 1) <= 'Z')) {
            Integer recentElementCount = Integer.valueOf(recentElementCountString);
            if (recentElementCount == 0)
                finalformula += recentElementSymbol + factor;
            else
                finalformula += recentElementSymbol + recentElementCount * factor;
        }
    }
    return finalformula;
}",muliplier,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * This method multiply all the element over a value.
     *
     * @param formula Formula to correct
     * @param factor  Factor to multiply
     * @return        Formula with the correction
     */",1471-1505,"('muliplier', {'INSTRUCTION': {'covered': 117, 'missed': 0}, 'BRANCH': {'covered': 21, 'missed': 3}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",199.0,10.0,This method multiply all the element over a value.,"Given a value, the method multiply all the elements over it.",The method is used to add all the elements over a value.,0.708638083006823,This method multiplies the entire item on a value.,"private static String muliplier(String formula, int factor){
        String newFormula = """";
        for (int i = 0; i < formula.length(); i++) {
            char thisChar = formula.charAt(i);
            if (thisChar >= 'A' && thisChar <= 'Z') {
                newFormula += thisChar;
            }
            if (thisChar >= 'a' && thisChar <= 'z') {
                newFormula += thisChar;
            }
            if (thisChar >= '0' && thisChar <= '9') {
                newFormula += thisChar;
            }
        }
        return newFormula;
    }","private static String muliplier(String formula, int factor){
        String newFormula = """";
        for (int i = 0; i < formula.length(); i++) {
            char thisChar = formula.charAt(i);
            if (thisChar >= 'A' && thisChar <= 'Z') {
                newFormula += thisChar;
            }
            if (thisChar >= 'a' && thisChar <= 'z') {
                newFormula += thisChar;
            }
            if (thisChar >= '0' && thisChar <= '9') {
                newFormula += thisChar;
            }
        }
        return newFormula;
    }","private static String muliplier(String formula, int factor){
        String newFormula = """";
        for (int i = 0; i < formula.length(); i++) {
            char thisChar = formula.charAt(i);
            if (thisChar >= 'A' && thisChar <= 'Z') {
                newFormula += thisChar;
            }
            if (thisChar >= 'a' && thisChar <= 'z') {
                newFormula += thisChar;
            }
            if (thisChar >= '0' && thisChar <= '9') {
                newFormula += thisChar;
            }
        }
        return newFormula;
    }","private static String muliplier(String formula, int factor){
        String newFormula = """";
        for (int f = 0; f < formula.length(); f++) {
            char thisChar = formula.charAt(f);
            if (thisChar >= 'A' && thisChar <= 'Z') {
                newFormula += thisChar;
            }
            if (thisChar >= 'a' && thisChar <= 'z') {
                newFormula += thisChar;
            }
            if (thisChar >= '0' && thisChar <= '9') {
                newFormula += thisChar;
            }
        }
        return newFormula;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.338992305988177,  0.338992305988177,  0.3626046861952712,  0.338992305988177,110.0,0.55,110.0,0.55,106.0,0.53,110.0,0.55,0.0,0.0,4.0,0.04,0.0,0.0,7.0,0.5833333333333334,5.0,0.5,6.0,0.46153846153846156
263,matsim-libs,"public boolean remove(E value){
    if (value == null)
        return false;
    int index = indices[this.getIndex(value)];
    if (index < 0) {
        return false;
    } else {
        if (classicalRemove) {
            boolean decreasedKey = decreaseKey(value, Double.NEGATIVE_INFINITY);
            if (decreasedKey && data[0] == value) {
                this.poll();
                return true;
            } else
                return false;
        } else {
            siftDownUp(index);
            indices[this.getIndex(value)] = -1;
            this.modCount++;
            return true;
        }
    }
}",remove,org/matsim/core/router/priorityqueue/BinaryMinHeap.java,/matsim/src/main/java/org/matsim/core/router/priorityqueue/BinaryMinHeap.java,"/**
	 * Removes a single instance of the specified element from this
	 * queue, if it is present.
	 *
	 * @return <tt>true</tt> if the queue contained the specified
	 *         element.
	 */",275-311,"('remove', {'INSTRUCTION': {'covered': 54, 'missed': 2}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 13, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",118.0,17.0,"Removes a single instance of the specified element from this  queue, if it is present.","If an instance of the specified element exists, we remove it.","If there is a single instance of the specified element present, it is removed.",1.10046574649611,"Removes a single instance of the specified item from this queue, if present.","public boolean remove(E value){
	 if (value == null) {
		 throw new NullPointerException(""null values are not supported!"");
	 }
	 
	 int index = indices[this.getIndex(value)];
	 if (index < 0) {
		 return false;
	 } else {
		 this.modCount++;
		 if (classicalRemove) {
			 data[index] = data[heapSize - 1];
			 costs[index] = costs[heapSize - 1];
			 indices[this.getIndex(data[index])] = index;
			 indices[this.getIndex(value)] = -1;
			 heapSize--;
			 if (heapSize > 0) siftDown(index);
		 } else {
			 siftDownUp(index);
			 indices[this.getIndex(value)] = -1;
		 }
		 return true;
	 }
 }","public boolean remove(E value){
	 if (value == null) {
		 throw new NullPointerException(""null values are not supported!"");
	 }
	 
	 int index = indices[this.getIndex(value)];
	 if (index >= 0) {
		 this.modCount++;
		 if (classicalRemove) {
			 data[index] = data[heapSize - 1];
			 costs[index] = costs[heapSize - 1];
			 indices[this.getIndex(data[index])] = index;
			 indices[this.getIndex(value)] = -1;
			 heapSize--;
			 if (heapSize > 0) siftDown(index);
		 } else {
			 siftDownUp(index);
			 indices[this.getIndex(value)] = -1;
		 }
		 return true;
	 } else {
		 return false;
	 }
 }","public boolean remove(E value){
	 	
 	if (value == null) {
 		throw new NullPointerException(""null values are not supported!"");
 	}
 	
 	int index = indices[this.getIndex(value)];
 	if (index >= 0) {
 		this.modCount++;
 		
 		if (classicalRemove) {
 			// Swap entry with heap's last entry.
 			data[index] = data[heapSize - 1];
 			costs[index] = costs[heapSize - 1];
 			indices[this.getIndex(data[index])] = index;
 			indices[this.getIndex(value)] = -1;
 
 			heapSize--;
 			if (heapSize > 0) siftDown(index);
 		} else {
 			siftDownUp(index);
 
 			indices[this.getIndex(value)] = -1;
 		}
 		return true;
 	} else {
 		return false;
 	}
 }","public boolean remove(E value){
	 	if (value == null) {
 		throw new NullPointerException(""null values are not supported!"");
 	}
 	
 	int index = indices[this.getIndex(value)];
 	if (index >= 0) {
 		this.modCount++;
 		if (classicalRemove) {
 			copyData(index, heapSize - 1);
 			heapSize--;
 			siftDown(index);
 		} else {
 			siftDownUp(index);
 			indices[this.getIndex(value)] = -1;
 		}
 		return true;
 	} else {
 		return false;
 	}
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5731189655918547,  0.5728245164727137,  0.5594311635623385,  0.5728245164727137,73.0,0.477124183006536,78.0,0.5098039215686274,56.0,0.47058823529411764,78.0,0.5098039215686274,13.0,0.08496732026143791,65.0,0.42483660130718953,13.0,0.08496732026143791,10.0,0.625,3.0,0.1875,8.0,0.5
264,acs-aem-commons," void parseParameters() throws ParseException{
    if (payloadPaths != null) {
        payloads = payloadPaths.stream().map(Pattern::compile).collect(Collectors.toList());
    }
    if (StringUtils.isNotEmpty(olderThanVal)) {
        final SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss"");
        Date d = sdf.parse(olderThanVal);
        olderThan = Calendar.getInstance();
        olderThan.setTime(d);
    }
    workflowRemovalConfig = new WorkflowRemovalConfig(modelIds, statuses, payloads, olderThan, olderThanMillis);
    workflowRemovalConfig.setBatchSize(BATCH_SIZE);
    workflowRemovalConfig.setMaxDurationInMins(MAX_DURATION_MINS);
}",parseParameters,com/adobe/acs/commons/mcp/impl/processes/WorkflowRemover.java,/bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/WorkflowRemover.java,"/**
     * Parse the input parameters into the form needed to call workflowInstanceRemover. The results are set into
     * instance variables.  Method is package scope for unit testing.
     *
     * @throws ParseException
     *             if the date is in an invalid format.
     * @throws PatternSyntaxException
     *          if the payloads contain illegal patterns
     */",164-188,"('parseParameters', {'INSTRUCTION': {'covered': 58, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",116.0,12.0,Parse the input parameters into the form needed to call workflowInstanceRemover.,The method parse the input parameters into the form used for calling workflowInstanceRemover and set them into instance variables.,The form needed to call theInstanceRemover requires input parameters.,0.73982975329067,Analyze the input parameters in the form needed to call workflowInstanceRemover.,"void parseParameters() throws ParseException{
        if (payloads != null) {
            payloads.clear();
        } else {
            payloads = new ArrayList<>();
        }
     
        if (StringUtils.isNotBlank(olderThanVal)) {
            olderThan = DateUtils.parseDate(olderThanVal, new String[] { ""yyyy-MM-dd"", ""yyyy-MM-dd HH:mm:ss"" });
        }
     
        if (payloadPaths != null) {
            for (String payloadPath : payloadPaths) {
                payloads.add(Pattern.compile(payloadPath));
            }
        }
     
        if (modelIds != null) {
            workflowRemovalConfig = new WorkflowRemovalConfig();
            workflowRemovalConfig.setModelIds(modelIds);
        }
     
        if (statuses != null) {
            workflowRemovalConfig = new WorkflowRemovalConfig();
            workflowRemovalConfig.setStatuses(statuses);
        }
     
        if (olderThanMillis > 0) {
            workflowRemovalConfig = new WorkflowRemovalConfig();
            workflowRemovalConfig.setOlderThanMillis(olderThanMillis);
        }
     
        if (olderThan != null) {
            workflowRemovalConfig = new WorkflowRemovalConfig();
            workflowRemovalConfig.setOlderThan(olderThan);
        }
     
        if (workflowRemovalConfig == null) {
            throw new IllegalArgumentException(""No parameters specified"");
        }
     
            
  }","void parseParameters() throws ParseException{
        if (payloads != null) {
            payloads.clear();
        }
        if (payloads == null) {
            payloads = new ArrayList<>();
        }
        if (payloadPaths != null) {
            for (String payloadPath : payloadPaths) {
                if (StringUtils.isNotBlank(payloadPath)) {
                    payloads.add(Pattern.compile(payloadPath));
                }
            }
        }
        if (olderThanVal != null) {
            olderThan = Calendar.getInstance();
            olderThan.setTime(DateUtils.parseDate(olderThanVal));
        }
        if (olderThanMillis > 0) {
            olderThan = Calendar.getInstance();
            olderThan.setTimeInMillis(olderThanMillis);
        }
        if (modelIds != null) {
            modelIds.removeAll(Collections.singleton(null));
        }
        if (statuses != null) {
            statuses.removeAll(Collections.singleton(null));
        }
        workflowRemovalConfig = new WorkflowRemovalConfig(payloads, olderThan, modelIds, statuses);
    }","void parseParameters() throws ParseException{
     
      if (StringUtils.isNotBlank(olderThanVal)) {
            olderThan = DatePickerComponent.parseDate(olderThanVal);
      }
     
      if (olderThanMillis > 0) {
            olderThan = new GregorianCalendar();
            olderThan.setTimeInMillis(olderThanMillis);
      }
     
      if (payloadPaths != null) {
            payloads = payloadPaths.stream().map(Pattern::compile).collect(Collectors.toList());
      }
     
      workflowRemovalConfig = new WorkflowRemovalConfig(olderThan, payloads, statuses, modelIds);
     
      }","void parseParameters() throws ParseException{
        if (StringUtils.isNotBlank(olderThanVal)) {
            olderThan = DateUtils.parseDate(olderThanVal);
        }
     
        if (olderThanMillis > 0) {
            olderThan = new GregorianCalendar();
            olderThan.setTimeInMillis(olderThanMillis);
        }
     
        if (payloadPaths != null) {
            payloads = payloadPaths.stream().map(Pattern::compile).collect(Collectors.toList());
        }
     
        workflowRemovalConfig = new WorkflowRemovalConfig(olderThan, payloads, statuses, modelIds);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4189226797804294,  0.46059993761293894,  0.5649347959984603,  0.5649347959984603,133.0,0.6751269035532995,121.0,0.654054054054054,76.0,0.6495726495726496,76.0,0.6495726495726496,99.0,0.5025380710659898,128.0,0.649746192893401,129.0,0.6548223350253807,13.0,0.65,2.0,0.16666666666666666,10.0,0.8333333333333334
265,jackson-databind,"public byte[] writeValueAsBytes(Object value) throws JsonProcessingException{
    try (ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler())) {
        _writeValueAndClose(createGenerator(bb, JsonEncoding.UTF8), value);
        final byte[] result = bb.toByteArray();
        bb.release();
        return result;
    } catch (JsonProcessingException e) {
        throw e;
    } catch (IOException e) {
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
}",writeValueAsBytes,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Method that can be used to serialize any Java value as
     * a byte array. Functionally equivalent to calling
     * {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}
     * and getting bytes, but more efficient.
     * Encoding used will be UTF-8.
     *<p>
     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
     */",3830-3853,"('writeValueAsBytes', {'INSTRUCTION': {'covered': 23, 'missed': 7}, 'LINE': {'covered': 5, 'missed': 4}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",90.0,15.0,Method that can be used to serialize any Java value as  a byte array.,This method can be called to serialize any Java value as an array of bytes.,Any Java value can be serialized using this method.,0.65145852650661,A method that can be used to serialize any Java value as an array of bytes.," public byte[] writeValueAsBytes(Object value) throws JsonProcessingException{
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        try {
            _writeValueAndClose(createGenerator(out), value);
        } catch (JsonProcessingException e) {
            throw e;
        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:
            throw JsonMappingException.fromUnexpectedIOE(e);
        }
        return out.toByteArray();
    }"," public byte[] writeValueAsBytes(Object value) throws JsonProcessingException{
        // alas, we have to pull the recycler directly here...
        SegmentedByteArrayOutputStream sw = new SegmentedByteArrayOutputStream(_jsonFactory._getBufferRecycler());
        try {
            _writeValueAndClose(createGenerator(sw), value);
        } catch (JsonProcessingException e) {
            throw e;
        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:
            throw JsonMappingException.fromUnexpectedIOE(e);
        }
        return sw.getAndClear();
    }"," public byte[] writeValueAsBytes(Object value) throws JsonProcessingException{
        ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());
        try {
            _writeValueAndClose(createGenerator(bb), value);
        } catch (JsonProcessingException e) {
            throw e;
        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:
            throw JsonMappingException.fromUnexpectedIOE(e);
        }
        return bb.toByteArray();
    }"," public byte[] writeValueAsBytes(Object value) throws JsonProcessingException{
        ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());
        try {
            _writeValueAndClose(createGenerator(bb), value);
        } catch (JsonProcessingException e) {
            throw e;
        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:
            throw JsonMappingException.fromUnexpectedIOE(e);
        }
        return bb.toByteArray();
    }",PASS,NOT PASS,PASS,PASS,  0.530780446134977,  0.5910023779196406,  0.6359818437138858,  0.6359818437138858,44.0,0.4835164835164835,40.0,0.43956043956043955,36.0,0.3956043956043956,36.0,0.3956043956043956,11.0,0.1527777777777778,10.0,0.1388888888888889,10.0,0.1388888888888889,7.0,0.4375,6.0,0.35294117647058826,13.0,0.8666666666666667
266,cdk,"static int[] moveToBack(int[] neighbors, int v){
    int j = 0;
    for (int i = 0; i < neighbors.length; i++) {
        if (neighbors[i] != v) {
            neighbors[j++] = neighbors[i];
        }
    }
    neighbors[neighbors.length - 1] = v;
    return neighbors;
}",moveToBack,org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,"/**
     * Utility method for shifting a specified value in an index to the back
     * (see {@link #permutation(int[])}).
     *
     * @param neighbors list of neighbors
     * @param v         the value to shift to the back
     * @return <i>neighbors</i> array
     */",216-233,"('moveToBack', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,28.0,Utility method for shifting a specified value in an index to the back  (see {@link #permutation(int[])}).,This utility method can shift a specific value contained in an index to the end of the array.,The method for shifting a specified value in an index to the back is a utility method.,0.448550744531805,A utility method for moving a specified value in an index backwards (see {@link #permutation(int[])}).,"static int[] moveToBack(int[] neighbors, int v){
        int[] result = new int[neighbors.length];
        System.arraycopy(neighbors, 0, result, 0, v);
        System.arraycopy(neighbors, v, result, v + 1, neighbors.length - v - 1);
        result[v] = neighbors[neighbors.length - 1];
        return result;
    }","static int[] moveToBack(int[] neighbors, int v){
        int[] result = new int[neighbors.length];
        System.arraycopy(neighbors, 0, result, 0, v);
        System.arraycopy(neighbors, v, result, v + 1, neighbors.length - v - 1);
        result[v] = neighbors[neighbors.length - 1];
        return result;
    }","static int[] moveToBack(int[] neighbors, int v){
        int[] result = new int[neighbors.length];
        int index = 0;
        for (int i = 0; i < neighbors.length; i++) {
            if (neighbors[i] != v) {
                result[index++] = neighbors[i];
            }
        }
        result[index] = v;
        return result;
    }","static int[] moveToBack(int[] neighbors, int v){
        int[] result = new int[neighbors.length];
        int i = 0;
        for (int n : neighbors) {
            if (n != v) {
                result[i++] = n;
            }
        }
        result[i] = v;
        return result;
    }",NOT PASS,NOT PASS,PASS,PASS,  0.44204417329731527,  0.44204417329731527,  0.5057171081133995,  0.6992608966037921,51.0,0.6,51.0,0.6,36.0,0.47368421052631576,23.0,0.27058823529411763,0.0,0.0,44.0,0.5176470588235295,45.0,0.5294117647058824,10.0,0.5263157894736842,6.0,0.35294117647058826,5.0,0.2777777777777778
267,cdk,"void readPropertiesFast(final BufferedReader input, final IAtomContainer container, final int nAtoms) throws IOException, CDKException{
    String line;
    int offset = container.getAtomCount() - nAtoms;
    Map<Integer, Sgroup> sgroups = new LinkedHashMap<>();
    LINES: while ((line = input.readLine()) != null) {
        int index, count, lnOffset;
        Sgroup sgroup;
        int length = line.length();
        final PropertyKey key = PropertyKey.of(line);
        switch(key) {
            case ATOM_ALIAS:
                index = readMolfileInt(line, 3) - 1;
                final String label = input.readLine();
                if (label == null)
                    return;
                label(container, offset + index, label);
                break;
            case ATOM_VALUE:
                index = readMolfileInt(line, 3) - 1;
                final String comment = line.substring(7);
                container.getAtom(offset + index).setProperty(CDKConstants.COMMENT, comment);
                break;
            case GROUP_ABBREVIATION:
                final String group = input.readLine();
                if (group == null)
                    return;
                break;
            case LEGACY_ATOM_LIST:
                index = readUInt(line, 0, 3) - 1;
                {
                    boolean negate = line.charAt(3) == 'T' || line.charAt(4) == 'T';
                    Expr expr = new Expr(Expr.Type.TRUE);
                    StringBuilder sb = new StringBuilder();
                    for (int i = 11; i < line.length(); i += 4) {
                        int atomicNumber = readUInt(line, i, 3);
                        expr.or(new Expr(Expr.Type.ELEMENT, atomicNumber));
                    }
                    if (negate)
                        expr.negate();
                    IAtom atom = container.getAtom(index);
                    if (AtomRef.deref(atom) instanceof QueryAtom) {
                        QueryAtom ref = (QueryAtom) AtomRef.deref(atom);
                        ref.setExpression(expr);
                    } else {
                        QueryAtom queryAtom = new QueryAtom(expr);
                        queryAtom.setPoint2d(atom.getPoint2d());
                        queryAtom.setPoint3d(atom.getPoint3d());
                        container.setAtom(index, queryAtom);
                    }
                }
                break;
            case M_ALS:
                index = readUInt(line, 7, 3) - 1;
                {
                    boolean negate = line.charAt(13) == 'T' || line.charAt(14) == 'T';
                    Expr expr = new Expr(Expr.Type.TRUE);
                    StringBuilder sb = new StringBuilder();
                    for (int i = 16; i < line.length(); i++) {
                        if (line.charAt(i) != ' ') {
                            sb.append(line.charAt(i));
                        } else if (sb.length() != 0) {
                            int elem = Elements.ofString(sb.toString()).number();
                            if (elem != 0)
                                expr.or(new Expr(Expr.Type.ELEMENT, elem));
                            sb.setLength(0);
                        }
                    }
                    if (sb.length() != 0) {
                        int elem = Elements.ofString(sb.toString()).number();
                        if (elem != 0)
                            expr.or(new Expr(Expr.Type.ELEMENT, elem));
                    }
                    if (negate)
                        expr.negate();
                    IAtom atom = container.getAtom(index);
                    if (AtomRef.deref(atom) instanceof QueryAtom) {
                        QueryAtom ref = (QueryAtom) AtomRef.deref(atom);
                        ref.setExpression(expr);
                    } else {
                        QueryAtom queryAtom = new QueryAtom(expr);
                        queryAtom.setPoint2d(atom.getPoint2d());
                        queryAtom.setPoint3d(atom.getPoint3d());
                        container.setAtom(index, queryAtom);
                    }
                }
                break;
            case M_CHG:
                count = readUInt(line, 6, 3);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    index = readMolfileInt(line, st) - 1;
                    int charge = readMolfileInt(line, st + 4);
                    container.getAtom(offset + index).setFormalCharge(charge);
                }
                break;
            case M_ISO:
                count = readUInt(line, 6, 3);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    index = readMolfileInt(line, st) - 1;
                    int mass = readMolfileInt(line, st + 4);
                    if (mass < 0)
                        handleError(""Absolute mass number should be >= 0, "" + line);
                    else
                        container.getAtom(offset + index).setMassNumber(mass);
                }
                break;
            case M_RAD:
                count = readUInt(line, 6, 3);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    index = readMolfileInt(line, st) - 1;
                    int value = readMolfileInt(line, st + 4);
                    SPIN_MULTIPLICITY multiplicity = SPIN_MULTIPLICITY.ofValue(value);
                    container.getAtom(offset + index).setProperty(CDKConstants.SPIN_MULTIPLICITY, multiplicity);
                    for (int e = 0; e < multiplicity.getSingleElectrons(); e++) container.addSingleElectron(offset + index);
                }
                break;
            case M_RGP:
                count = readUInt(line, 6, 3);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    index = readMolfileInt(line, st) - 1;
                    int number = readMolfileInt(line, st + 4);
                    label(container, offset + index, ""R"" + number);
                }
                break;
            case M_ZZC:
                if (mode == Mode.STRICT) {
                    throw new CDKException(""Atom property ZZC is illegal in STRICT mode"");
                }
                index = readMolfileInt(line, 7) - 1;
                String atomLabel = line.substring(11);
                container.getAtom(offset + index).setProperty(CDKConstants.ACDLABS_LABEL, atomLabel);
                break;
            case M_STY:
                count = readMolfileInt(line, 6);
                for (int i = 0; i < count; i++) {
                    lnOffset = 10 + (i * 8);
                    index = readMolfileInt(line, lnOffset);
                    if (mode == Mode.STRICT && sgroups.containsKey(index))
                        handleError(""STY line must appear before any other line that supplies Sgroup information"");
                    sgroup = new Sgroup();
                    sgroups.put(index, sgroup);
                    SgroupType type = SgroupType.parseCtabKey(line.substring(lnOffset + 4, lnOffset + 7));
                    if (type != null)
                        sgroup.setType(type);
                }
                break;
            case M_SST:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    if (mode == Mode.STRICT && sgroup.getType() != SgroupType.CtabCopolymer)
                        handleError(""SST (Sgroup Subtype) specified for a non co-polymer group"");
                    String sst = line.substring(st + 4, st + 7);
                    if (mode == Mode.STRICT && !(""ALT"".equals(sst) || ""RAN"".equals(sst) || ""BLO"".equals(sst)))
                        handleError(""Invalid sgroup subtype: "" + sst + "" expected (ALT, RAN, or BLO)"");
                    sgroup.putValue(SgroupKey.CtabSubType, sst);
                }
                break;
            case M_SAL:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                count = readMolfileInt(line, 10);
                for (int i = 0, st = 14; i < count && st + 3 <= length; i++, st += 4) {
                    index = readMolfileInt(line, st) - 1;
                    sgroup.addAtom(container.getAtom(offset + index));
                }
                break;
            case M_SBL:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                count = readMolfileInt(line, 10);
                for (int i = 0, st = 14; i < count && st + 3 <= length; i++, st += 4) {
                    index = readMolfileInt(line, st) - 1;
                    sgroup.addBond(container.getBond(offset + index));
                }
                break;
            case M_SPL:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 6 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    sgroup.addParent(ensureSgroup(sgroups, readMolfileInt(line, st + 4)));
                }
                break;
            case M_SCN:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 6 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    String con = line.substring(st + 4, Math.min(length, st + 7)).trim();
                    if (mode == Mode.STRICT && !(""HH"".equals(con) || ""HT"".equals(con) || ""EU"".equals(con)))
                        handleError(""Unknown SCN type (expected: HH, HT, or EU) was "" + con);
                    sgroup.putValue(SgroupKey.CtabConnectivity, con);
                }
                break;
            case M_SDI:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                count = readMolfileInt(line, 10);
                assert count == 4;
                sgroup.addBracket(new SgroupBracket(readMDLCoordinate(line, 13), readMDLCoordinate(line, 23), readMDLCoordinate(line, 33), readMDLCoordinate(line, 43)));
                break;
            case M_SMT:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                sgroup.putValue(SgroupKey.CtabSubScript, line.substring(11).trim());
                break;
            case M_SBT:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    sgroup.putValue(SgroupKey.CtabBracketStyle, readMolfileInt(line, st + 4));
                }
                break;
            case M_SDS:
                if (""EXP"".equals(line.substring(7, 10))) {
                    count = readMolfileInt(line, 10);
                    for (int i = 0, st = 14; i < count && st + 3 <= length; i++, st += 4) {
                        sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                        sgroup.putValue(SgroupKey.CtabExpansion, true);
                    }
                } else if (mode == Mode.STRICT) {
                    handleError(""Expected EXP to follow SDS tag"");
                }
                break;
            case M_SPA:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                count = readMolfileInt(line, 10);
                Collection<IAtom> parentAtomList = sgroup.getValue(SgroupKey.CtabParentAtomList);
                if (parentAtomList == null) {
                    sgroup.putValue(SgroupKey.CtabParentAtomList, parentAtomList = new HashSet<IAtom>());
                }
                for (int i = 0, st = 14; i < count && st + 3 <= length; i++, st += 4) {
                    index = readMolfileInt(line, st) - 1;
                    parentAtomList.add(container.getAtom(offset + index));
                }
                break;
            case M_SNC:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    sgroup.putValue(SgroupKey.CtabComponentNumber, readMolfileInt(line, st + 4));
                }
                break;
            case M_SDT:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                if (length < 11)
                    break;
                String name = line.substring(11, Math.min(41, length)).trim();
                sgroup.putValue(SgroupKey.DataFieldName, name);
                if (length < 41)
                    break;
                String fmt = line.substring(41, Math.min(43, length)).trim();
                if (fmt.length() == 1 && fmt.charAt(0) != 'F' && fmt.charAt(0) != 'N' && fmt.charAt(0) != 'T')
                    handleError(""Invalid Data Sgroup field format: "" + fmt);
                if (!fmt.isEmpty())
                    sgroup.putValue(SgroupKey.DataFieldFormat, fmt);
                if (length < 43)
                    break;
                String units = line.substring(43, Math.min(63, length)).trim();
                if (!units.isEmpty())
                    sgroup.putValue(SgroupKey.DataFieldUnits, units);
                break;
            case M_SDD:
                break;
            case M_SCD:
            case M_SED:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                String data = line.substring(11, Math.min(79, length));
                String curr = sgroup.getValue(SgroupKey.Data);
                if (curr != null)
                    data = curr + data;
                sgroup.putValue(SgroupKey.Data, data);
                break;
            case M_END:
                break LINES;
        }
    }
    for (IAtom atom : container.atoms()) {
        if (atom.getMassNumber() != null && atom.getMassNumber() < 0) {
            handleError(""Unstable use of mass delta on "" + atom.getSymbol() + "" please use M  ISO"");
            atom.setMassNumber(null);
        }
    }
    if (!sgroups.isEmpty()) {
        List<Sgroup> sgroupOrgList = new ArrayList<>(sgroups.values());
        List<Sgroup> sgroupCpyList = new ArrayList<>(sgroupOrgList.size());
        for (int i = 0; i < sgroupOrgList.size(); i++) {
            Sgroup cpy = sgroupOrgList.get(i).downcast();
            sgroupCpyList.add(cpy);
        }
        for (int i = 0; i < sgroupOrgList.size(); i++) {
            Sgroup newSgroup = sgroupCpyList.get(i);
            Set<Sgroup> oldParents = new HashSet<>(newSgroup.getParents());
            newSgroup.removeParents(oldParents);
            for (Sgroup parent : oldParents) {
                newSgroup.addParent(sgroupCpyList.get(sgroupOrgList.indexOf(parent)));
            }
        }
        container.setProperty(CDKConstants.CTAB_SGROUPS, sgroupCpyList);
    }
}",readPropertiesFast,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Reads the property block from the {@code input} setting the values in the
     * container.
     *
     * @param input     input resource
     * @param container the structure with atoms / bonds present
     * @param nAtoms    the number of atoms in the atoms block
     * @throws IOException low-level IO error
     */",880-1442,"('readPropertiesFast', {'INSTRUCTION': {'covered': 1184, 'missed': 129}, 'BRANCH': {'covered': 143, 'missed': 50}, 'LINE': {'covered': 225, 'missed': 18}, 'COMPLEXITY': {'covered': 66, 'missed': 44}, 'METHOD': {'covered': 1, 'missed': 0}})",2851.0,18.0,Reads the property block from the {@code input} setting the values in the  container.,reads the input and sets the values of the property block in the container.,The property block is read from the code input.,0.147679399644273,Reads the property block from the value {@code input} in the container.,Not Valid,"void readPropertiesFast(final BufferedReader input, final IAtomContainer container, final int nAtoms) throws IOException, CDKException{
        String line = input.readLine();
        if (line == null) return;
        if (line.length() == 0) return;
        if (line.charAt(0) != '>') return;
        while (line.charAt(0) == '>') {
            line = line.substring(1);
            int index = line.indexOf('<');
            if (index == -1) {
                throw new CDKException(""invalid property block: "" + line);
            }
            String key = line.substring(0, index);
            String value = line.substring(index + 1);
            container.setProperty(key, value);
            line = input.readLine();
        }       
 }","void readPropertiesFast(final BufferedReader input, final IAtomContainer container, final int nAtoms) throws IOException, CDKException{
        String line;
        while ((line = input.readLine()) != null) {
            if (line.length() == 0) continue;
            if (line.charAt(0) == 'M') break;
            if (line.charAt(0) == 'A') {
                readAtomPropertiesFast(input, container, nAtoms);
            } else if (line.charAt(0) == 'B') {
                readBondPropertiesFast(input, container, nAtoms);
            } else {
                throw new CDKException(""unrecognised property block: "" + line);
            }
        }       
 }","void readPropertiesFast(final BufferedReader input, final IAtomContainer container, final int nAtoms) throws IOException, CDKException{
        String line;
        while ((line = input.readLine()) != null) {
            if (line.length() == 0) continue;
            if (line.charAt(0) == 'M') break;
            if (line.charAt(0) == 'A') {
                readAtomPropertiesFast(line, container, nAtoms);
            } else if (line.charAt(0) == 'B') {
                readBondPropertiesFast(line, container, nAtoms);
            } else {
                throw new CDKException(""unrecognised property block: "" + line);
            }
        }
    }",Not Valid,NOT PASS,NOT PASS,NOT PASS,None,  0.0616226574174761,  0.054042465685436095,  0.05391419772861325,None,None,2721.0,0.9540673211781207,2746.0,0.9628330995792427,2747.0,0.9631837307152875,154.0,0.9935483870967742,122.0,0.991869918699187,122.0,0.991869918699187,9.0,0.6,4.0,0.26666666666666666,11.0,0.7333333333333333
268,soul,"public Mono<Void> execute(final ServerWebExchange exchange, final ShenyuPluginChain chain){
    String pluginName = named();
    PluginData pluginData = BaseDataCache.getInstance().obtainPluginData(pluginName);
    if (pluginData != null && pluginData.getEnabled()) {
        final Collection<SelectorData> selectors = BaseDataCache.getInstance().obtainSelectorData(pluginName);
        if (CollectionUtils.isEmpty(selectors)) {
            return handleSelectorIfNull(pluginName, exchange, chain);
        }
        SelectorData selectorData = matchSelector(exchange, selectors);
        if (Objects.isNull(selectorData)) {
            return handleSelectorIfNull(pluginName, exchange, chain);
        }
        selectorLog(selectorData, pluginName);
        List<RuleData> rules = BaseDataCache.getInstance().obtainRuleData(selectorData.getId());
        if (CollectionUtils.isEmpty(rules)) {
            return handleRuleIfNull(pluginName, exchange, chain);
        }
        RuleData rule;
        if (selectorData.getType() == SelectorTypeEnum.FULL_FLOW.getCode()) {
            // get last
            rule = rules.get(rules.size() - 1);
        } else {
            rule = matchRule(exchange, rules);
        }
        if (Objects.isNull(rule)) {
            return handleRuleIfNull(pluginName, exchange, chain);
        }
        ruleLog(rule, pluginName);
        return doExecute(exchange, chain, selectorData, rule);
    }
    return chain.execute(exchange);
}",execute,org/apache/shenyu/plugin/base/AbstractShenyuPlugin.java,/shenyu-plugin/shenyu-plugin-base/src/main/java/org/apache/shenyu/plugin/base/AbstractShenyuPlugin.java,"/**
     * Process the Web request and (optionally) delegate to the next
     * {@code ShenyuPlugin} through the given {@link ShenyuPluginChain}.
     *
     * @param exchange the current server exchange
     * @param chain    provides a way to delegate to the next plugin
     * @return {@code Mono<Void>} to indicate when request processing is complete
     */",56-96,"('execute', {'INSTRUCTION': {'covered': 80, 'missed': 22}, 'BRANCH': {'covered': 9, 'missed': 5}, 'LINE': {'covered': 17, 'missed': 4}, 'COMPLEXITY': {'covered': 3, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",267.0,26.0,Process the Web request and (optionally) delegate to the next  {@code ShenyuPlugin} through the given {@link ShenyuPluginChain}.,The method processes a web request. It can optionally delegate the operation to the next ShenyuPlugin,"If you want to delegate to the next @code ShenyuPlugin, Process the Web request and give the @link ShenyuPluginChain.",1.26981716543868,Process the web request and (optionally) delegate it to the next {@code ShenyuPlugin} via the given {@link ShenyuPluginChain}.," public Mono<Void> execute(final ServerWebExchange exchange, final ShenyuPluginChain chain){
        final SelectorData selector = getSelector(exchange);
        final RuleData rule = getRule(exchange);
        if (Objects.isNull(selector) || Objects.isNull(rule)) {
            return chain.next(exchange);
        }
        return doExecute(exchange, chain, selector, rule);
    }"," public Mono<Void> execute(final ServerWebExchange exchange, final ShenyuPluginChain chain){
        final SelectorData selector = getSelector(exchange);
        final RuleData rule = getRule(exchange);
        if (Objects.isNull(selector) || Objects.isNull(rule)) {
            return chain.execute(exchange);
        }
        return doExecute(exchange, chain, selector, rule);
    }",Not Valid," public Mono<Void> execute(final ServerWebExchange exchange, final ShenyuPluginChain chain){
        return Mono.fromSupplier(() -> {
            //get selector
            SelectorData selector = BaseDataCache.getSelector(exchange);
            if (Objects.isNull(selector)) {
                LOG.error(""selector is null"");
                return null;
            }
            //get rule
            RuleData rule = BaseDataCache.getRule(exchange);
            if (Objects.isNull(rule)) {
                LOG.error(""rule is null"");
                return null;
            }
            //get plugin data
            PluginData pluginData = BaseDataCache.getPluginData(exchange);
            if (Objects.isNull(pluginData)) {
                LOG.error(""plugin data is null"");
                return null;
            }
            //get match strategy
            MatchStrategyFactory matchStrategyFactory = MatchStrategyFactory.getInstance();
            Collection<SelectorData> selectors = matchStrategyFactory.getMatchStrategy(selector.getType()).match(selector, rule);
            if (CollectionUtils.isEmpty(selectors)) {
                LOG.error(""selector is empty"");
                return null;
            }
            //get plugin chain
            List<ShenyuPlugin> plugins = pluginData.getPlugins();
            if (CollectionUtils.isEmpty(plugins)) {
                LOG.error(""plugin is empty"");
                return null;
            }
            //get plugin chain
            ShenyuPluginChain pluginChain = pluginData.getPluginChain();
            if (Objects.isNull(pluginChain)) {
                LOG.error(""plugin chain is null"");
                return null;
            }
            //get plugin chain
            return doExecute(exchange, pluginChain, selector, rule);
        });
    }       ",NOT PASS,NOT PASS,NOT PASS,Not Valid,  0.16061255403253405,  0.18324883605890926,  0.39082549296587293,None,207.0,0.7723880597014925,207.0,0.7723880597014925,155.0,0.5783582089552238,None,None,1.0,0.013513513513513514,186.0,0.7380952380952381,None,None,16.0,0.8888888888888888,3.0,0.15789473684210525,16.0,0.8
269,jackson-databind,"public ObjectReader readerForArrayOf(Class<?> type){
    return _newReader(getDeserializationConfig(), _typeFactory.constructArrayType(type), null, null, _injectableValues);
}",readerForArrayOf,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Factory method for constructing {@link ObjectReader} that will
     * read values of a type {@code List<type>}.
     * Functionally same as:
     *<pre>
     *    readerFor(type[].class);
     *</pre>
     *
     * @since 2.11
     */",4145-4159,"('readerForArrayOf', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,25.0,Factory method for constructing {@link ObjectReader} that will  read values of a type {@code List<type>}.,The method can construct the ObjectReader in order to read a list of values.,The method for constructing @link ObjectReader will read values of a type.,1.14950756092578,A factory method for constructing {@link ObjectReader} that will read the values of a {@code List<type>} type.," public ObjectReader readerForArrayOf(Class<?> type){
    return readerFor(TypeFactory.defaultInstance().constructCollectionType(List.class, type));
     }"," public ObjectReader readerForArrayOf(Class<?> type){
        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,
                    null, _injectableValues);
    }"," public ObjectReader readerForArrayOf(Class<?> type){
        return _newReader(getDeserializationConfig(), _typeFactory.constructArrayType(_typeFactory.constructType(type)), null,
                    null, _injectableValues);
    }"," public ObjectReader readerForArrayOf(Class<?> type){
        return _newReader(getDeserializationConfig(), _typeFactory.constructArrayType(_typeFactory.constructType(type)), null,
                null, _injectableValues);
    }",NOT PASS,NOT PASS,PASS,PASS,  0.6071575202606415,  0.9595831295324171,  0.8724776949721852,  0.8724776949721852,14.0,0.4117647058823529,1.0,0.029411764705882353,5.0,0.1282051282051282,5.0,0.1282051282051282,14.0,0.4117647058823529,17.0,0.4358974358974359,17.0,0.4358974358974359,13.0,0.8125,6.0,0.3333333333333333,7.0,0.4375
270,weblogic-kubernetes-operator,"public static Step readIntrospectionVersionStep(String ns, String domainUid){
    String configMapName = getIntrospectorConfigMapName(domainUid);
    return new CallBuilder().readConfigMapAsync(configMapName, ns, domainUid, new ReadIntrospectionVersionStep());
}",readIntrospectionVersionStep,oracle/kubernetes/operator/helpers/ConfigMapHelper.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/ConfigMapHelper.java,"/**
   * Reads the introspector config map for the specified domain, populating the following packet entries.
   *   INTROSPECTION_STATE_LABEL          the value of the domain's 'introspectVersion' when this map was created
   *
   * @param ns the namespace of the domain
   * @param domainUid the unique domain ID
   * @return a step to do the processing.
   */",924-935,"('readIntrospectionVersionStep', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,16.0,"Reads the introspector config map for the specified domain, populating the following packet entries.","Given a introspector config map for a specific domaiin, reads it and populate the packet entries.",The following packet entries are filled with the following config map.,0.704545234844214,"Reads the introspector's configuration card for the specified domain, filling in the following packet entries."," public static Step readIntrospectionVersionStep(String ns, String domainUid){
    String configMapName = getIntrospectorConfigMapName(domainUid);
    return new CallBuilder().readConfigMapAsync(configMapName, ns, domainUid, new ReadIntrospectionVersionStep());    
 }"," public static Step readIntrospectionVersionStep(String ns, String domainUid){
    String configMapName = getIntrospectorConfigMapName(domainUid);
    return new CallBuilder().readConfigMapAsync(configMapName, ns, domainUid, new ReadIntrospectionVersionStep());    
 }"," public static Step readIntrospectionVersionStep(String ns, String domainUid){
    String configMapName = getIntrospectorConfigMapName(domainUid);
    return new CallBuilder().readConfigMapAsync(configMapName, ns, domainUid, new ReadIntrospectionVersionStep());    
 }"," public static Step readIntrospectionVersionStep(String ns, String domainUid){
    String configMapName = getIntrospectorConfigMapName(domainUid);
    return new CallBuilder().readConfigMapAsync(configMapName, ns, domainUid, new ReadIntrospectionVersionStep());    
 }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10.0,0.5882352941176471,5.0,0.3125,12.0,0.8
271,cdk,"public void writeMolecule(IAtomContainer mol) throws IOException{
    String st = """";
    boolean writecharge = true;
    try {
        String s1 = """" + mol.getAtomCount();
        writer.write(s1, 0, s1.length());
        writer.write('\n');
        String s2 = mol.getTitle();
        if (s2 != null) {
            writer.write(s2, 0, s2.length());
        }
        writer.write('\n');
        Iterator<IAtom> atoms = mol.atoms().iterator();
        while (atoms.hasNext()) {
            IAtom a = atoms.next();
            st = a.getSymbol();
            Point3d p3 = a.getPoint3d();
            if (p3 != null) {
                st = st + ""\t"" + (p3.x < 0 ? """" : "" "") + fsb.format(p3.x) + ""\t"" + (p3.y < 0 ? """" : "" "") + fsb.format(p3.y) + ""\t"" + (p3.z < 0 ? """" : "" "") + fsb.format(p3.z);
            } else {
                st = st + ""\t "" + fsb.format(0.0) + ""\t "" + fsb.format(0.0) + ""\t "" + fsb.format(0.0);
            }
            if (writecharge) {
                double ct = a.getCharge() == CDKConstants.UNSET ? 0.0 : a.getCharge();
                st = st + ""\t"" + ct;
            }
            writer.write(st, 0, st.length());
            writer.write('\n');
        }
    } catch (IOException e) {
        logger.error(""Error while writing file: "", e.getMessage());
        logger.debug(e);
    }
}",writeMolecule,org/openscience/cdk/io/XYZWriter.java,/storage/io/src/main/java/org/openscience/cdk/io/XYZWriter.java,"/**
    * writes a single frame in XYZ format to the Writer.
    * @param mol the Molecule to write
    */",136-185,"('writeMolecule', {'INSTRUCTION': {'covered': 172, 'missed': 26}, 'BRANCH': {'covered': 12, 'missed': 4}, 'LINE': {'covered': 25, 'missed': 4}, 'COMPLEXITY': {'covered': 5, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",347.0,11.0,writes a single frame in XYZ format to the Writer.,"Using the XYZ format, writes the frame to the Writer.",A single frame is written to the writer.,0.329706345601129,writes a single image in XYZ format to the recorder.,"public void writeMolecule(IAtomContainer mol) throws IOException{
        int atomCount = mol.getAtomCount();
        int bondCount = mol.getBondCount();
        writer.write(Integer.toString(atomCount));
        writer.write(""\n"");
        writer.write(Integer.toString(bondCount));
        writer.write(""\n"");
        for (int i = 0; i < atomCount; i++) {
            IAtom atom = mol.getAtom(i);
            writer.write(atom.getSymbol());
            writer.write("" "");
            writer.write(fsb.format(atom.getPoint3d().x));
            writer.write("" "");
            writer.write(fsb.format(atom.getPoint3d().y));
            writer.write("" "");
            writer.write(fsb.format(atom.getPoint3d().z));
            writer.write(""\n"");
        }
        for (int i = 0; i < bondCount; i++) {
            writer.write(Integer.toString(mol.getBond(i).getAtomNumber(0) + 1));
            writer.write("" "");
            writer.write(Integer.toString(mol.getBond(i).getAtomNumber(1) + 1));
            writer.write("" "");
            writer.write(Integer.toString(mol.getBond(i).getOrder().numeric()));
            writer.write(""\n"");
        }
        writer.write(""\n"");
    }","public void writeMolecule(IAtomContainer mol) throws IOException{
        writer.write(mol.getAtomCount() + ""\n"");
        writer.write(mol.getTitle() + ""\n"");
        for (IAtom atom : mol.atoms()) {
            writer.write(atom.getSymbol() + "" "");
            writer.write(fsb.format(atom.getPoint3d().x) + "" "");
            writer.write(fsb.format(atom.getPoint3d().y) + "" "");
            writer.write(fsb.format(atom.getPoint3d().z) + ""\n"");
        }
    }","public void writeMolecule(IAtomContainer mol) throws IOException{
        int nAtoms = mol.getAtomCount();
        int nBonds = mol.getBondCount();
        writer.write(nAtoms + "" "" + nBonds + ""\n"");
        for (int i = 0; i < nAtoms; i++) {
            IAtom atom = mol.getAtom(i);
            writer.write(atom.getSymbol());
            Point3d p = atom.getPoint3d();
            if (p != null) {
                writer.write("" "" + fsb.format(p.x) + "" "" + fsb.format(p.y) + "" "" + fsb.format(p.z));
            }
            writer.write(""\n"");
        }
        for (int i = 0; i < nBonds; i++) {
            writer.write(mol.getBond(i).getBeginIndex() + 1 + "" "" + mol.getBond(i).getEndIndex() + 1);
            if (mol.getBond(i).getOrder() != CDKConstants.UNSET) {
                writer.write("" "" + mol.getBond(i).getOrder());
            }
            writer.write(""\n"");
        }
        writer.write(""\n"");
    }","public void writeMolecule(IAtomContainer mol) throws IOException{
        int atomCount = mol.getAtomCount();
        int bondCount = mol.getBondCount();
        writer.write(Integer.toString(atomCount));
        writer.write(""\n"");
        writer.write(Integer.toString(bondCount));
        writer.write(""\n"");
        for (int i = 0; i < atomCount; i++) {
            IAtom atom = mol.getAtom(i);
            writer.write(atom.getSymbol());
            Point3d p = atom.getPoint3d();
            if (p != null) {
                writer.write("" "");
                writer.write(fsb.format(p.x));
                writer.write("" "");
                writer.write(fsb.format(p.y));
                writer.write("" "");
                writer.write(fsb.format(p.z));
            }
            writer.write(""\n"");
        }
        for (int i = 0; i < bondCount; i++) {
            writer.write(Integer.toString(mol.getBond(i).getAtom(0).getIndex() + 1));
            writer.write("" "");
            writer.write(Integer.toString(mol.getBond(i).getAtom(1).getIndex() + 1));
            writer.write("" "");
            writer.write(Integer.toString(mol.getBond(i).getOrder()));
            writer.write(""\n"");
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2602806414289884,  0.1621537102954892,  0.3055592271943673,  0.2992616759066207,235.0,0.6752873563218391,260.0,0.7471264367816092,222.0,0.6379310344827587,230.0,0.6609195402298851,193.0,0.6348684210526315,53.0,0.17320261437908496,128.0,0.42105263157894735,7.0,0.6363636363636364,2.0,0.18181818181818182,6.0,0.5454545454545454
273,cdk,"public synchronized void searchMCS(boolean shouldMatchBonds){
    List<List<Integer>> mappings = null;
    try {
        if (source.getAtomCount() >= target.getAtomCount()) {
            mappings = new MCSPlus().getOverlaps(source, target, shouldMatchBonds);
        } else {
            flagExchange = true;
            mappings = new MCSPlus().getOverlaps(target, source, shouldMatchBonds);
        }
        PostFilter.filter(mappings);
        setAllMapping();
        setAllAtomMapping();
        setFirstMapping();
        setFirstAtomMapping();
    } catch (CDKException e) {
        mappings = null;
    }
}",searchMCS,org/openscience/cdk/smsd/algorithm/mcsplus/MCSPlusHandler.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/mcsplus/MCSPlusHandler.java,"/** {@inheritDoc}
     * Function is called by the main program and serves as a starting point for the comparison procedure.
     *
     * @param shouldMatchBonds
     */",93-116,"('searchMCS', {'INSTRUCTION': {'covered': 46, 'missed': 3}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",113.0,22.0,{@inheritDoc}  Function is called by the main program and serves as a starting point for the comparison procedure.,the function starts the comparison procedure and is called by the main program.,The function is called by the main program and serves as a starting point for comparison procedures.,0.269893903122951,{@inheritDoc}  The function is called by the main program and serves as a starting point for the comparison procedure.,"public synchronized void searchMCS(boolean shouldMatchBonds){
        try {
            if (source == null || target == null) {
                throw new CDKException(""Source or target is null"");
            }
            if (source.getAtomCount() == 0 || target.getAtomCount() == 0) {
                throw new CDKException(""Source or target is empty"");
            }
            if (source.getAtomCount() > target.getAtomCount()) {
                flagExchange = true;
                IAtomContainer temp = source;
                source = target;
                target = temp;
            }
            if (shouldMatchBonds) {
                matchBonds();
            }
            matchAtoms();
            if (flagExchange) {
                flagExchange = false;
                IAtomContainer temp = source;
                source = target;
                target = temp;
            }
            if (atomsMCS.size() == 0) {
                throw new CDKException(""No MCS found"");
            }
            if (firstMCS.size() == 0) {
                throw new CDKException(""No MCS found"");
            }
            if (allMCS.size() == 0) {
                throw new CDKException(""No MCS found"");
            }
            if (allAtomMCS.size() == 0) {
                throw new CDKException(""No MCS found"");
            }
        } catch (CDKException e) {
            e.printStackTrace();
        }
    }","public synchronized void searchMCS(boolean shouldMatchBonds){
        try {
            if (source == null || target == null) {
                throw new CDKException(""Source or target is null"");
            }
            if (source.getAtomCount() == 0 || target.getAtomCount() == 0) {
                throw new CDKException(""Source or target is empty"");
            }
            if (source.getAtomCount() > target.getAtomCount()) {
                flagExchange = true;
                IAtomContainer temp = source;
                source = target;
                target = temp;
            }
            if (shouldMatchBonds) {
                matchBonds();
            }
            matchAtoms();
            if (flagExchange) {
                flagExchange = false;
                IAtomContainer temp = source;
                source = target;
                target = temp;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }       
 }",Not Valid,Not Valid,NOT PASS,NOT PASS,Not Valid,Not Valid,  0.38290017458693004,  0.38213738327209457,None,None,149.0,0.680365296803653,89.0,0.6223776223776224,None,None,None,None,77.0,0.3515981735159817,None,None,None,None,15.0,0.7894736842105263,2.0,0.1,4.0,0.21052631578947367
274,acs-aem-commons,"private void populateBinaryContent() throws RepositoryException{
    final Node contents = getOrCreateByPath(entryNode, JCRHttpCacheStoreConstants.PATH_CONTENTS, JcrConstants.NT_FILE, JcrConstants.NT_FILE);
    final Node jcrContent = getOrCreateByPath(contents, JcrConstants.JCR_CONTENT, JcrConstants.NT_RESOURCE, JcrConstants.NT_RESOURCE);
    final Binary binary = session.getValueFactory().createBinary(cacheContent.getInputDataStream());
    jcrContent.setProperty(JcrConstants.JCR_DATA, binary);
    jcrContent.setProperty(JcrConstants.JCR_MIMETYPE, cacheContent.getContentType());
}",populateBinaryContent,com/adobe/acs/commons/httpcache/store/jcr/impl/writer/EntryNodeWriter.java,/bundle/src/main/java/com/adobe/acs/commons/httpcache/store/jcr/impl/writer/EntryNodeWriter.java,"/**
     * Save the inputstream to a binary property under the cache entry node.
     * @throws RepositoryException
     */",99-112,"('populateBinaryContent', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",96.0,13.0,Save the inputstream to a binary property under the cache entry node.,"using the cache entry node, saves in binary format the inputstream.","Under the cache entry node, save the inputstream to a property.",0.73859558896823,Save the input stream to a binary property under the cache input node.," private void populateBinaryContent() throws RepositoryException{
        Binary binary = session.getValueFactory().createBinary(new ByteArrayInputStream(cacheContent.getContent()));
        entryNode.setProperty(JCRHttpCacheStoreConstants.PN_BINARY_CONTENT, binary);
    }"," private void populateBinaryContent() throws RepositoryException{
        Binary binary = session.getValueFactory().createBinary(new ByteArrayInputStream(cacheContent.getContent()));
        entryNode.setProperty(JCRHttpCacheStoreConstants.PN_BINARY_CONTENT, binary);
    }"," private void populateBinaryContent() throws RepositoryException{
        Binary binary = session.getValueFactory().createBinary(new ByteArrayInputStream(cacheContent.getContent()));
        entryNode.setProperty(JCRHttpCacheStoreConstants.PN_CONTENT, binary);
    }"," private void populateBinaryContent() throws RepositoryException{
        Binary binary = session.getValueFactory().createBinary(new ByteArrayInputStream(cacheContent.getContent()));
        entryNode.setProperty(JCRHttpCacheStoreConstants.PN_BINARY_CONTENT, binary);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3262665822906281,  0.3262665822906281,  0.3262665822906281,  0.3262665822906281,64.0,0.6597938144329897,64.0,0.6597938144329897,64.0,0.6597938144329897,64.0,0.6597938144329897,0.0,0.0,0.0,0.0,1.0,0.023255813953488372,11.0,0.8461538461538461,3.0,0.21428571428571427,11.0,0.8461538461538461
275,acs-aem-commons,"public List<Resource> findResources(final ResourceResolver resourceResolver, final String language, final String statement, final String relPath) throws RepositoryException{
    if (StringUtils.isEmpty(statement)) {
        return Collections.emptyList();
    }
    final String[] lines = StringUtils.split(statement, '\n');
    if (QUERY_BUILDER.equalsIgnoreCase(language)) {
        return getResourcesFromQueryBuilder(resourceResolver, lines, relPath);
    } else if (LIST.equalsIgnoreCase(language)) {
        return getResourcesFromList(resourceResolver, lines, relPath);
    } else {
        return getResourcesFromQuery(resourceResolver, language, statement, relPath);
    }
}",findResources,com/adobe/acs/commons/util/impl/QueryHelperImpl.java,/bundle/src/main/java/com/adobe/acs/commons/util/impl/QueryHelperImpl.java,"/**
     * Find all the resources needed for the package definition.
     *
     * @param resourceResolver the resource resolver to find the resources
     * @param language         the Query language
     * @param statement        the Query statement
     * @param relPath          the relative path to resolve against query result nodes for package resources
     * @return a unique set of paths to include in the package
     * @throws RepositoryException
     */",60-87,"('findResources', {'INSTRUCTION': {'covered': 34, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",118.0,10.0,Find all the resources needed for the package definition.,Collect all the resources for the definition of the package.,The package definition requires all the resources found here.,0.172615768564587,Find all the resources needed to define the package.," public List<Resource> findResources(final ResourceResolver resourceResolver, final String language, final String statement, final String relPath) throws RepositoryException{
        final List<Resource> resources = new ArrayList<>();
        final Query query = queryBuilder.createQuery(statement, language);
        final QueryManager queryManager = resourceResolver.adaptTo(Session.class).getWorkspace().getQueryManager();
        final QueryResult queryResult = queryManager.executeQuery(query, Collections.emptyMap());
        final RowIterator rowIterator = queryResult.getRows();
        while (rowIterator.hasNext()) {
            final Row row = rowIterator.nextRow();
            final String path = row.getValue(""path"").getString();
            final Resource resource = resourceResolver.getResource(path);
            if (resource != null) {
                resources.add(resource);
            }
        }
        return resources;       
 }","public List<Resource> findResources(final ResourceResolver resourceResolver, final String language, final String statement, final String relPath) throws RepositoryException{
        final List<Resource> resources = new ArrayList<>();
        final Session session = resourceResolver.adaptTo(Session.class);
        final QueryManager queryManager = session.getWorkspace().getQueryManager();
        final Query query = queryManager.createQuery(statement, Query.JCR_SQL2);
        final QueryResult queryResult = query.execute();
        final RowIterator rowIterator = queryResult.getRows();
        while (rowIterator.hasNext()) {
            final Row row = rowIterator.nextRow();
            final String path = row.getValue(""path"").getString();
            final Resource resource = resourceResolver.getResource(path);
            if (resource != null) {
                resources.add(resource);
            }
        }
        return resources;       
 }"," public List<Resource> findResources(final ResourceResolver resourceResolver, final String language, final String statement, final String relPath) throws RepositoryException{
        return findResources(resourceResolver, language, statement, relPath, null);     
 }","public List<Resource> findResources(final ResourceResolver resourceResolver, final String language, final String statement, final String relPath) throws RepositoryException{
        final Session session = resourceResolver.adaptTo(Session.class);
        final QueryManager queryManager = session.getWorkspace().getQueryManager();
        final Query query = queryManager.createQuery(statement, Query.JCR_SQL2);
        final QueryResult queryResult = query.execute();
        final RowIterator rowIterator = queryResult.getRows();
        final List<Resource> resources = new ArrayList<>();
        while (rowIterator.hasNext()) {
            final Row row = rowIterator.nextRow();
            final String path = row.getValue(""jcr:path"").getString();
            final Resource resource = resourceResolver.getResource(path);
            if (resource != null) {
                resources.add(resource);
            }
        }
        return resources;       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.39316338038254395,  0.3883077622107334,  0.35569906655855943,  0.29029294311982484,109.0,0.6526946107784432,109.0,0.6488095238095238,110.0,0.6547619047619048,80.0,0.6722689075630253,31.0,0.18452380952380953,54.0,0.32142857142857145,132.0,0.7904191616766467,6.0,0.5454545454545454,4.0,0.4,9.0,0.9
276,weblogic-kubernetes-operator,"private static Step createServerStatusReaderStep(DomainPresenceInfo info, V1Pod pod, String serverName, long timeoutSeconds){
    return new ServerStatusReaderStep(info, pod, serverName, timeoutSeconds, new ServerHealthStep(serverName, pod, null));
}",createServerStatusReaderStep,oracle/kubernetes/operator/ServerStatusReader.java,/operator/src/main/java/oracle/kubernetes/operator/ServerStatusReader.java,"/**
   * Creates asynchronous step to read WebLogic server state from a particular pod.
   *
   * @param info the domain presence
   * @param pod The pod
   * @param serverName Server name
   * @param timeoutSeconds Timeout in seconds
   * @return Created step
   */",61-74,"('createServerStatusReaderStep', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",42.0,13.0,Creates asynchronous step to read WebLogic server state from a particular pod.,"From a specific pod, reads the WebLogic server state in an asyncronous step",A step is created to read the server state from a particular Pod.,0.294409124334335,Creates an asynchronous step to read the status of the WebLogic server from a particular space.,"private static Step createServerStatusReaderStep(DomainPresenceInfo info, V1Pod pod, String serverName, long timeoutSeconds){
    return new ServerStatusReaderStep(info, pod, serverName, timeoutSeconds);
  }","private static Step createServerStatusReaderStep(DomainPresenceInfo info, V1Pod pod, String serverName, long timeoutSeconds){
    return new ServerStatusReaderStep(info, pod, serverName, timeoutSeconds);
  }","private static Step createServerStatusReaderStep(DomainPresenceInfo info, V1Pod pod, String serverName, long timeoutSeconds){
    return new ServerStatusReaderStep(info, pod, serverName, timeoutSeconds);
  }","private static Step createServerStatusReaderStep(DomainPresenceInfo info, V1Pod pod, String serverName, long timeoutSeconds){
    return new ServerStatusReaderStep(info, pod, serverName, timeoutSeconds);
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7006144652751316,  0.7006144652751316,  0.7006144652751316,  0.7006144652751316,10.0,0.23255813953488372,10.0,0.23255813953488372,10.0,0.23255813953488372,10.0,0.23255813953488372,0.0,0.0,0.0,0.0,0.0,0.0,10.0,0.7142857142857143,7.0,0.4117647058823529,6.0,0.42857142857142855
277,glowstone,"private static Location findSafeSpawnLocation(Location spawn){
    World world = spawn.getWorld();
    int blockX = spawn.getBlockX();
    int blockY = spawn.getBlockY();
    int blockZ = spawn.getBlockZ();
    int highestY = world.getHighestBlockYAt(blockX, blockZ);
    int y = blockY;
    boolean wasPreviousSafe = false;
    for (; y <= highestY; y++) {
        Material type = world.getBlockAt(blockX, y, blockZ).getType();
        boolean safe = Material.AIR.equals(type);
        if (wasPreviousSafe && safe) {
            y--;
            break;
        }
        wasPreviousSafe = safe;
    }
    return new Location(world, blockX + 0.5, y, blockZ + 0.5);
}",findSafeSpawnLocation,net/glowstone/entity/GlowPlayer.java,/src/main/java/net/glowstone/entity/GlowPlayer.java,"/**
     * Find a a Location obove or below the specified Location, which is on ground.
     *
     * <p>The returned Location will be at the center of the block, X and Y wise.
     *
     * @param spawn The Location a safe spawn position should be found at.
     * @return The location to spawn the player at.
     */",633-663,"('findSafeSpawnLocation', {'INSTRUCTION': {'covered': 56, 'missed': 4}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 13, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",144.0,16.0,"Find a a Location obove or below the specified Location, which is on ground.","Given a specific location on the ground, find a new location above or below.",The location is on the ground.,0.888315682226204,"Find an obove location or below the specified location, which is on the ground.","private static Location findSafeSpawnLocation(Location spawn){
        Location loc = spawn.clone();
        loc.setY(loc.getY() + 1);
        while(!loc.getBlock().getType().isSolid()){
            loc.setY(loc.getY() + 1);
        }
        loc.setY(loc.getY() - 1);
        return loc;
    }","private static Location findSafeSpawnLocation(Location spawn){
        Location loc = spawn.clone();
        loc.setY(loc.getY() + 1);
        if(loc.getBlock().getType() == Material.AIR){
            return loc;
        }
        loc.setY(loc.getY() - 2);
        if(loc.getBlock().getType() == Material.AIR){
            return loc;
        }
        return spawn;       
 }"," private static Location findSafeSpawnLocation(Location spawn){
        Location loc = spawn.clone();
        loc.setY(loc.getWorld().getHighestBlockYAt(loc));
        return loc;     
 }","private static Location findSafeSpawnLocation(Location spawn){
        Location loc = spawn.clone();
        loc.setY(loc.getY() + 1);
        while (loc.getBlock().getType() != Material.AIR){
            loc.setY(loc.getY() + 1);
        }
        return loc;     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.19910425247869584,  0.23391053833437236,  0.1998549578962339,  0.15217490397683517,103.0,0.7103448275862069,100.0,0.6896551724137931,104.0,0.7172413793103448,115.0,0.7931034482758621,26.0,0.2857142857142857,18.0,0.2222222222222222,44.0,0.5432098765432098,13.0,0.8666666666666667,6.0,0.4,12.0,0.8
278,cdk,"protected boolean canDraw(IAtom atom, IAtomContainer container, RendererModel model){
    if (!hasCoordinates(atom)) {
        return false;
    }
    if (invisibleHydrogen(atom, model)) {
        return false;
    }
    if (invisibleCarbon(atom, container, model)) {
        return false;
    }
    return true;
}",canDraw,org/openscience/cdk/renderer/generators/BasicAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/BasicAtomGenerator.java,"/**
     * Checks an atom to see if it should be drawn. There are three reasons
     * not to draw an atom - a) no coordinates, b) an invisible hydrogen or
     * c) an invisible carbon.
     *
     * @param atom the atom to check
     * @param container the atom container the atom is part of
     * @param model the renderer model
     * @return true if the atom should be drawn
     */",279-306,"('canDraw', {'INSTRUCTION': {'covered': 21, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,11.0,Checks an atom to see if it should be drawn.,"Check whether we can draw an atom. This can not be done in three circumstances: there are no coordinates, there is an invisible hydrogen or an invisible carbon.",The atom is checked to see if it should be drawn.,0.503171778164863,Check an atom to see if it needs to be drawn.," protected boolean canDraw(IAtom atom, IAtomContainer container, RendererModel model){
        return !invisibleHydrogen(atom, model) && !invisibleCarbon(atom, container, model);
    }"," protected boolean canDraw(IAtom atom, IAtomContainer container, RendererModel model){
        return hasCoordinates(atom) && !invisibleHydrogen(atom, model) && !invisibleCarbon(atom, container, model);
    }"," protected boolean canDraw(IAtom atom, IAtomContainer container, RendererModel model){
        return !invisibleHydrogen(atom, model) && !invisibleCarbon(atom, container, model);
    }"," protected boolean canDraw(IAtom atom, IAtomContainer container, RendererModel model){
        return !invisibleHydrogen(atom, model) && !invisibleCarbon(atom, container, model);     
 }",PASS,PASS,PASS,PASS,  0.5089100526089461,  0.5785304137823821,  0.5089100526089461,  0.5089100526089461,30.0,0.4838709677419355,27.0,0.43548387096774194,30.0,0.4838709677419355,30.0,0.4838709677419355,5.0,0.125,0.0,0.0,0.0,0.0,27.0,0.9310344827586207,3.0,0.25,4.0,0.3333333333333333
279,acs-aem-commons,"private List<SyntheticChildAsPropertyResource> deserialize() throws InvalidDataFormatException{
    final long start = System.currentTimeMillis();
    final String propertyData = this.resource.getValueMap().get(this.propertyName, EMPTY_JSON);
    List<SyntheticChildAsPropertyResource> resources;
    resources = deserializeToSyntheticChildResources(JsonObjectUtil.toJsonObject(propertyData));
    if (this.comparator != null) {
        Collections.sort(resources, this.comparator);
    }
    log.debug(""Get operation for [ {} ] in [ {} ms ]"", this.resource.getPath() + ""/"" + this.propertyName, System.currentTimeMillis() - start);
    return resources;
}",deserialize,com/adobe/acs/commons/synth/children/ChildrenAsPropertyResource.java,/bundle/src/main/java/com/adobe/acs/commons/synth/children/ChildrenAsPropertyResource.java,"/**
     * Convert the serialized JSON data found in the node property to Resources.
     *
     * @return the list of children sorting using the comparator.
     * @throws InvalidDataFormatException
     */",294-318,"('deserialize', {'INSTRUCTION': {'covered': 45, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",114.0,13.0,Convert the serialized JSON data found in the node property to Resources.,Read a serialized JSON data found in the properties of the node and convert them to Resources.,The data in the property is serialized.,0.483869666869148,Convert the serialized JSON data found in the node property to Resources.," private List<SyntheticChildAsPropertyResource> deserialize() throws InvalidDataFormatException{
        final long start = System.currentTimeMillis();
    
        final ValueMap valueMap = this.resource.getValueMap();
        final String json = valueMap.get(this.propertyName, String.class);
    
        if (json == null) {
            return Collections.emptyList();
        }
    
        final JsonObject childrenJSON = new JsonObject(json);
    
        final List<SyntheticChildAsPropertyResource> children = new ArrayList<SyntheticChildAsPropertyResource>();
    
        for (Map.Entry<String, JsonValue> entry : childrenJSON.entrySet()) {
            final String name = entry.getKey();
            final JsonValue value = entry.getValue();
    
            final SyntheticChildAsPropertyResource child =
                    new SyntheticChildAsPropertyResource(this.resource, name, value);
    
            children.add(child);
            this.lookupCache.put(name, child);
            this.orderedCache.add(child);
        }
    
        log.debug(""Deserialize operation for [ {} ] in [ {} ms ]"",
                this.resource.getPath() + ""/"" + this.propertyName,
                System.currentTimeMillis() - start);
    
        return children;        
 }"," private List<SyntheticChildAsPropertyResource> deserialize() throws InvalidDataFormatException{
        final long start = System.currentTimeMillis();
    
        final ValueMap valueMap = this.resource.getValueMap();
        final String jsonString = valueMap.get(this.propertyName, String.class);
    
        if (jsonString == null) {
            return Collections.emptyList();
        }
    
        final JsonObject jsonObject = new JsonObject(jsonString);
    
        final List<SyntheticChildAsPropertyResource> children = new ArrayList<SyntheticChildAsPropertyResource>();
    
        for (Map.Entry<String, JsonElement> entry : jsonObject.entrySet()) {
            children.add(this.deserializeFromJSON(entry.getKey(), entry.getValue()));
        }
    
        log.debug(""Deserialize operation for [ {} ] in [ {} ms ]"",
                this.resource.getPath() + ""/"" + this.propertyName,
                System.currentTimeMillis() - start);
    
        return children;
    }"," private List<SyntheticChildAsPropertyResource> deserialize() throws InvalidDataFormatException{
        final long start = System.currentTimeMillis();
    
        final String jsonString = this.resource.getValueMap().get(this.propertyName, String.class);
    
        if (jsonString == null) {
            return Collections.emptyList();
        }
    
        final JsonParser parser = new JsonParser();
        final JsonElement jsonElement = parser.parse(jsonString);
    
        if (!jsonElement.isJsonObject()) {
            throw new InvalidDataFormatException(this.resource, this.propertyName, jsonString);
        }
    
        final JsonObject jsonObject = jsonElement.getAsJsonObject();
    
        final List<SyntheticChildAsPropertyResource> children = new ArrayList<SyntheticChildAsPropertyResource>();
    
        for (Map.Entry<String, JsonElement> entry : jsonObject.entrySet()) {
            final SyntheticChildAsPropertyResource child =
                    new SyntheticChildAsPropertyResource(this.resource, entry.getKey(), entry.getValue());
    
            children.add(child);
        }
    
        log.debug(""Deserialize operation for [ {} ] in [ {} ms ]"",
                this.resource.getPath() + ""/"" + this.propertyName,
                System.currentTimeMillis() - start);
    
        return children;        
 }"," private List<SyntheticChildAsPropertyResource> deserialize() throws InvalidDataFormatException{
        final long start = System.currentTimeMillis();
    
        final String json = this.resource.getValueMap().get(this.propertyName, String.class);
    
        if (json == null) {
            return new ArrayList<SyntheticChildAsPropertyResource>();
        }
    
        final JsonParser parser = new JsonParser();
        final JsonElement element = parser.parse(json);
    
        if (!element.isJsonObject()) {
            throw new InvalidDataFormatException(this.resource, this.propertyName, json);
        }
    
        final JsonObject jsonObject = element.getAsJsonObject();
    
        final List<SyntheticChildAsPropertyResource> children = new ArrayList<SyntheticChildAsPropertyResource>();
    
        for (Map.Entry<String, JsonElement> entry : jsonObject.entrySet()) {
            final String name = entry.getKey();
            final JsonElement jsonElement = entry.getValue();
    
            if (!jsonElement.isJsonObject()) {
                throw new InvalidDataFormatException(this.resource, this.propertyName, json);
            }
    
            final JsonObject jsonChild = jsonElement.getAsJsonObject();
    
            final SyntheticChildAsPropertyResource child =
                    new SyntheticChildAsPropertyResource(this.resource, name, jsonChild);
    
            children.add(child);
        }
    
        log.debug(""Deserialize operation for [ {} ] in [ {} ms ]"",
                this.resource.getPath() + ""/"" + this.propertyName,
                System.currentTimeMillis() - start);
    
        return children;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6054663373503548,  0.622767662631837,  0.5792187217279622,  0.5881594653112989,114.0,0.5507246376811594,79.0,0.4759036144578313,170.0,0.6415094339622641,124.0,0.5767441860465117,56.0,0.27053140096618356,104.0,0.39245283018867927,96.0,0.44651162790697674,8.0,0.4444444444444444,0.0,0.0,8.0,0.6153846153846154
280,egeria,"private List<String> parseRecord(String fileRecord){
    if ((fileRecord == null) || (fileRecord.isEmpty())) {
        return null;
    }
    List<String> result = new ArrayList<>();
    StringBuffer currentValue = new StringBuffer();
    boolean inQuotes = false;
    boolean startCollectingCharacters = false;
    boolean doubleQuotesInColumn = false;
    char[] characters = fileRecord.toCharArray();
    for (char character : characters) {
        if (inQuotes) {
            startCollectingCharacters = true;
            if (character == quoteChar) {
                inQuotes = false;
                doubleQuotesInColumn = false;
            } else {
                if (character == '\""') {
                    if (!doubleQuotesInColumn) {
                        currentValue.append(character);
                        doubleQuotesInColumn = true;
                    }
                } else {
                    currentValue.append(character);
                }
            }
        } else {
            if (character == quoteChar) {
                inQuotes = true;
                if (characters[0] != '""' && quoteChar == '\""') {
                    currentValue.append('""');
                }
                if (startCollectingCharacters) {
                    currentValue.append('""');
                }
            } else if (character == delimiterChar) {
                result.add(currentValue.toString());
                currentValue = new StringBuffer();
                startCollectingCharacters = false;
            } else if (character == '\n') {
                break;
            } else if (character != '\r') {
                currentValue.append(character);
            }
        }
    }
    result.add(currentValue.toString());
    return result;
}",parseRecord,org/odpi/openmetadata/adapters/connectors/datastore/csvfile/CSVFileStoreConnector.java,/open-metadata-implementation/adapters/open-connectors/data-store-connectors/file-connectors/csv-file-connector/src/main/java/org/odpi/openmetadata/adapters/connectors/datastore/csvfile/CSVFileStoreConnector.java,"/**
     * Step through the record, character by character, extracting each column and enduring that escaped double quotes
     * and other tricks found in CSV files are handled.
     *
     * @param fileRecord a single record from the CSV file store
     * @return an array of column values extracted from the record
     */",274-364,"('parseRecord', {'INSTRUCTION': {'covered': 118, 'missed': 12}, 'BRANCH': {'covered': 20, 'missed': 8}, 'LINE': {'covered': 30, 'missed': 5}, 'COMPLEXITY': {'covered': 8, 'missed': 7}, 'METHOD': {'covered': 1, 'missed': 0}})",276.0,28.0,"Step through the record, character by character, extracting each column and enduring that escaped double quotes  and other tricks found in CSV files are handled.","Parse a specific record, character by character and extract each column. The function handle double quotes and other tricks contained in the CSV file",The character by character method of character by character extract and the escape of double quotes are handled.,1.08205686836471,"Browse the record, character by character, extracting each column and supporting escaped double quotes and other tricks found in CSV files are handled.","private List<String> parseRecord(String fileRecord){
        List<String> record = new ArrayList<String>();
        StringBuilder column = new StringBuilder();
        boolean inQuote = false;
        for (int i = 0; i < fileRecord.length(); i++) {
            char c = fileRecord.charAt(i);
            if (c == quoteChar) {
                if (inQuote) {
                    if (i < fileRecord.length() - 1 && fileRecord.charAt(i + 1) == quoteChar) {
                        column.append(c);
                        i++;
                    } else {
                        inQuote = false;
                    }
                } else {
                    inQuote = true;
                }
            } else if (c == delimiterChar) {
                if (inQuote) {
                    column.append(c);
                } else {
                    record.add(column.toString());
                    column = new StringBuilder();
                }
            } else {
                column.append(c);
            }
        }
        record.add(column.toString());
        return record;
    }","private List<String> parseRecord(String fileRecord){
        List<String> record = new ArrayList<String>();
        StringBuilder currentColumn = new StringBuilder();
        boolean inQuote = false;
        for (int i = 0; i < fileRecord.length(); i++) {
            char c = fileRecord.charAt(i);
            if (c == quoteChar) {
                inQuote = !inQuote;
            }
            if (c == delimiterChar && !inQuote) {
                record.add(currentColumn.toString());
                currentColumn = new StringBuilder();
            } else {
                currentColumn.append(c);
            }
        }
        record.add(currentColumn.toString());
        return record;
    }","private List<String> parseRecord(String fileRecord){
        List<String> record = new ArrayList<>();
        StringBuilder field = new StringBuilder();
        boolean inQuote = false;
        for (int i = 0; i < fileRecord.length(); i++) {
            char c = fileRecord.charAt(i);
            if (c == quoteChar) {
                if (inQuote) {
                    if (i + 1 < fileRecord.length() && fileRecord.charAt(i + 1) == quoteChar) {
                        field.append(c);
                        i++;
                    } else {
                        inQuote = false;
                    }
                } else {
                    inQuote = true;
                }
            } else if (c == delimiterChar) {
                if (inQuote) {
                    field.append(c);
                } else {
                    record.add(field.toString());
                    field = new StringBuilder();
                }
            } else {
                field.append(c);
            }
        }
        record.add(field.toString());
        return record;
    }","private List<String> parseRecord(String fileRecord){
        List<String> record = new ArrayList<String>();
        StringBuilder column = new StringBuilder();
        boolean inQuotes = false;
        boolean inEscape = false;
        for (int i = 0; i < fileRecord.length(); i++) {
            char c = fileRecord.charAt(i);
            if (inEscape) {
                column.append(c);
                inEscape = false;
            } else if (c == quoteChar) {
                if (inQuotes) {
                    if (i + 1 < fileRecord.length() && fileRecord.charAt(i + 1) == quoteChar) {
                        column.append(c);
                        i++;
                    } else {
                        inQuotes = false;
                    }
                } else {
                    inQuotes = true;
                }
            } else if (c == delimiterChar) {
                if (inQuotes) {
                    column.append(c);
                } else {
                    record.add(column.toString());
                    column = new StringBuilder();
                }
            } else if (c == '\n') {
                if (inQuotes) {
                    column.append(c);
                } else {
                    record.add(column.toString());
                    column = new StringBuilder();
                    break;
                }
            } else if (c == '\r') {
                if (inQuotes) {
                    column.append(c);
                } else {
                    record.add(column.toString());
                    column = new StringBuilder();
                    break;
                }
            } else if (c == '\\') {
                if (inQuotes) {
                    column.append(c);
                    inEscape = true;
                } else {
                    column.append(c);
                }
            } else {
                column.append(c);
            }
        }
        if (column.length() > 0) {
            record.add(column.toString());
        }
        return record;      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3779721240913295,  0.27308595775978883,  0.43452854917943273,  0.47127825711552923,161.0,0.5812274368231047,182.0,0.6570397111913358,236.0,0.6537396121883656,160.0,0.5776173285198556,72.0,0.36,170.0,0.4709141274238227,12.0,0.06,16.0,0.6153846153846154,4.0,0.15384615384615385,20.0,0.7692307692307693
281,egeria,"public void upsertFolderHierarchy(String fileGuid, String pathName, String externalSourceGuid, String externalSourceName, String userId, String methodName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
    if (StringUtils.isEmpty(pathName)) {
        return;
    }
    validateParameters(fileGuid, externalSourceGuid, externalSourceName, userId, methodName);
    List<FileFolder> folders = extractFolders(pathName, externalSourceName, methodName);
    String folderGuid = """";
    String previousEntityGuid = fileGuid;
    String relationshipTypeName = NESTED_FILE_TYPE_NAME;
    for (FileFolder folder : folders) {
        if (relationshipTypeName.equals(NESTED_FILE_TYPE_NAME)) {
            deleteExistingNestedFileRelationships(fileGuid, externalSourceGuid, externalSourceName, userId, methodName);
        }
        folderGuid = upsertFolder(externalSourceGuid, externalSourceName, folder, userId, methodName);
        dataEngineCommonHandler.upsertExternalRelationship(userId, folderGuid, previousEntityGuid, relationshipTypeName, FILE_FOLDER_TYPE_NAME, externalSourceName, null);
        previousEntityGuid = folderGuid;
        relationshipTypeName = FOLDER_HIERARCHY_TYPE_NAME;
    }
    dataEngineCommonHandler.upsertExternalRelationship(userId, externalSourceGuid, folderGuid, SERVER_ASSET_USE_TYPE_NAME, SOFTWARE_SERVER_CAPABILITY_TYPE_NAME, externalSourceName, null);
}",upsertFolderHierarchy,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineFolderHierarchyHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineFolderHierarchyHandler.java,"/**
     * Construct the folder structure in which a data file is stored all the way to the SoftwareServerCapability. Care is
     * taken to maintain uniqueness of the relationship NestedFile that is between the file and the first folder.
     *
     * @param fileGuid           data file guid
     * @param pathName           file path
     * @param externalSourceGuid external source guid
     * @param externalSourceName external source name
     * @param userId             user id
     * @param methodName         method name
     *
     * @throws InvalidParameterException  if invalid parameters
     * @throws PropertyServerException    if errors in repository
     * @throws UserNotAuthorizedException if user not authorized
     */",65-107,"('upsertFolderHierarchy', {'INSTRUCTION': {'covered': 77, 'missed': 1}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 16, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",180.0,18.0,Construct the folder structure in which a data file is stored all the way to the SoftwareServerCapability.,Create the folder structure where the data file is stored until SoftwareServerCapability. Uniqueness of the relationship NestedFile is maintained.,The folder structure should have a data file in it.,0.543769217701536,Build the folder structure in which a data file is stored up to SoftwareServerCapability.," public void upsertFolderHierarchy(String fileGuid, String pathName, String externalSourceGuid, String externalSourceName, String userId, String methodName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
     
      if (StringUtils.isEmpty(fileGuid)) {
            invalidParameterHandler.throwInvalidParameterException(methodName,
                                                                  null,
                                                                  ""fileGuid"",
                                                                  ""The file guid is null or empty"");
      }
     
      if (StringUtils.isEmpty(pathName)) {
            invalidParameterHandler.throwInvalidParameterException(methodName,
                                                                  null,
                                                                  ""pathName"",
                                                                  ""The path name is null or empty"");
      }
     
      if (StringUtils.isEmpty(externalSourceGuid)) {
            invalidParameterHandler.throwInvalidParameterException(methodName,
                                                                  null,
                                                                  ""externalSourceGuid"",
                                                                  ""The external source guid is null or empty"");
      }
     
      if (StringUtils.isEmpty(externalSourceName)) {
            invalidParameterHandler.throwInvalidParameterException(methodName,
                                                                  null,
                                                                  ""externalSourceName"",
                                                                  ""The external source name is null or empty"");
      }
     
      if (StringUtils.isEmpty(userId)) {
            invalidParameterHandler.throwInvalidParameterException(methodName,
                                                                  null,
                                                                  ""userId"",
                                                                  ""The userId is null or empty"");
      }
     
      if (StringUtils.isEmpty(methodName)) {
            invalidParameterHandler.throwInvalidParameterException(methodName,
                                                                  null,
                                                                  ""methodName"",
                                                                  ""The method name is null or empty"");
      }
     
      Path path = Paths.get(pathName);
      String fileName = path.getFileName().toString();
     
      FileFolder fileFolder = new FileFolder();
      fileFolder.setGuid(fileGuid);
      fileFolder.setName(fileName);
      fileFolder.setOwner(userId);
      fileFolder.setOwnerType(OwnerType.USER);
      fileFolder.setExternalSourceGuid(externalSourceGu         
 }"," public void upsertFolderHierarchy(String fileGuid, String pathName, String externalSourceGuid, String externalSourceName, String userId, String methodName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
     
      if (StringUtils.isEmpty(fileGuid)) {
            invalidParameterHandler.throwInvalidParameterException(methodName,
                                                                  null,
                                                                  ""fileGuid"",
                                                                  ""The file guid is null or empty"");
      }
     
      if (StringUtils.isEmpty(pathName)) {
            invalidParameterHandler.throwInvalidParameterException(methodName,
                                                                  null,
                                                                  ""pathName"",
                                                                  ""The path name is null or empty"");
      }
     
      if (StringUtils.isEmpty(externalSourceGuid)) {
            invalidParameterHandler.throwInvalidParameterException(methodName,
                                                                  null,
                                                                  ""externalSourceGuid"",
                                                                  ""The external source guid is null or empty"");
      }
     
      if (StringUtils.isEmpty(externalSourceName)) {
            invalidParameterHandler.throwInvalidParameterException(methodName,
                                                                  null,
                                                                  ""externalSourceName"",
                                                                  ""The external source name is null or empty"");
      }
     
      if (StringUtils.isEmpty(userId)) {
            invalidParameterHandler.throwInvalidParameterException(methodName,
                                                                  null,
                                                                  ""userId"",
                                                                  ""The userId is null or empty"");
      }
     
      if (StringUtils.isEmpty(methodName)) {
            invalidParameterHandler.throwInvalidParameterException(methodName,
                                                                  null,
                                                                  ""methodName"",
                                                                  ""The method name is null or empty"");
      }
     
      Path path = Paths.get(pathName);
      List<String> pathList = new ArrayList<>();
      for (Path p : path) {
            pathList.add(p.toString());
      }
     
      String parentFolderGuid = null;
      String folderGuid = null;
      String folderName = null;
      String folderTypeName = null;
      String folderTypeGuid = null;         
 }"," public void upsertFolderHierarchy(String fileGuid, String pathName, String externalSourceGuid, String externalSourceName, String userId, String methodName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
     
      if (StringUtils.isBlank(fileGuid)) {
            invalidParameterHandler.throwInvalidParameterException(methodName, null, ""fileGuid"", ""The file guid is null or empty"");
      }
     
      if (StringUtils.isBlank(pathName)) {
            invalidParameterHandler.throwInvalidParameterException(methodName, null, ""pathName"", ""The path name is null or empty"");
      }
     
      if (StringUtils.isBlank(externalSourceGuid)) {
            invalidParameterHandler.throwInvalidParameterException(methodName, null, ""externalSourceGuid"", ""The external source guid is null or empty"");
      }
     
      if (StringUtils.isBlank(externalSourceName)) {
            invalidParameterHandler.throwInvalidParameterException(methodName, null, ""externalSourceName"", ""The external source name is null or empty"");
      }
     
      if (StringUtils.isBlank(userId)) {
            invalidParameterHandler.throwInvalidParameterException(methodName, null, ""userId"", ""The userId is null or empty"");
      }
     
      if (StringUtils.isBlank(methodName)) {
            invalidParameterHandler.throwInvalidParameterException(methodName, null, ""methodName"", ""The method name is null or empty"");
      }
     
      // The path name is a list of folder names separated by the file separator character.
      // The last folder name is the file name.
      // The first folder name is the root folder name.
      // The root folder name is the name of the server.
      // The root folder name is the name of the software server capability.
      // The root folder name is the name of the asset.
      // The root folder name is the name of the asset's owner.
      // The root folder name is the name of the asset's owner's owner.
      // The root folder name is the name of the asset's owner's owner's owner.
      // The root folder name is the name of the asset's owner's owner's owner's owner.
      // The root folder name is the name of the asset's owner's owner's owner's owner's owner          
 }",Empty Method,Syntax Error,NOT PASS,Empty Method,NOT PASS,None,  0.3433210671478758,None,  0.29485853243453725,None,None,159.0,0.654320987654321,None,None,114.0,0.6298342541436464,49.0,0.20164609053497942,None,None,72.0,0.2987551867219917,12.0,0.6,5.0,0.2777777777777778,12.0,0.6666666666666666
282,cdk,"private void flip(IBond bond){
    bond.setAtoms(new IAtom[] { bond.getEnd(), bond.getBegin() });
}",flip,org/openscience/cdk/inchi/InChIToStructure.java,/storage/inchi/src/main/java/org/openscience/cdk/inchi/InChIToStructure.java,"/**
     * Flip the storage order of atoms in a bond.
     * @param bond the bond
     */",150-156,"('flip', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,10.0,Flip the storage order of atoms in a bond.,Invert the order in which atoms in a bond are stored.,The storage order of atoms should be changed.,0.23574340791507,Reverse the order in which atoms are stored in a bond.,Empty Method,Empty Method,"private void flip(IBond bond){
        IAtom atom1 = bond.getAtom(0);
        IAtom atom2 = bond.getAtom(1);
        bond.setAtom(0, atom2);
        bond.setAtom(1, atom1);
    }","private void flip(IBond bond){
        IAtom atom1 = bond.getAtom(0);
        IAtom atom2 = bond.getAtom(1);
        bond.setAtom(0, atom2);
        bond.setAtom(1, atom1);
    }",Empty Method,Empty Method,NOT PASS,NOT PASS,None,None,  0.46996067620110255,  0.46996067620110255,None,None,None,None,25.0,0.5208333333333334,25.0,0.5208333333333334,None,None,47.0,0.9791666666666666,47.0,0.9791666666666666,7.0,0.5833333333333334,6.0,0.5,5.0,0.5
283,cdk,"protected static String formatMDLInt(int x, int n){
    char[] buf = new char[n];
    Arrays.fill(buf, ' ');
    String val = Integer.toString(x);
    if (val.length() > n)
        val = ""0"";
    int off = n - val.length();
    for (int i = 0; i < val.length(); i++) buf[off + i] = val.charAt(i);
    return new String(buf);
}",formatMDLInt,org/openscience/cdk/io/MDLV2000Writer.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Writer.java,"/**
     * Formats an integer to fit into the connection table and changes it
     * to a String.
     *
     * @param x The int to be formated
     * @param n Length of the String
     * @return The String to be written into the connectiontable
     */",1327-1345,"('formatMDLInt', {'INSTRUCTION': {'covered': 39, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",107.0,16.0,Formats an integer to fit into the connection table and changes it  to a String.,Change the format of an integer in order to fit into the connection table. The value is changed into a String.,The connection table has an integer that can be formatted to fit in.,0.557650317003611,Formats an integer to fit the connection table and replaces it with a string.," protected static String formatMDLInt(int x, int n){
        String s = Integer.toString(x);
        while (s.length() < n) s = "" "" + s;
        return s;
    }"," protected static String formatMDLInt(int x, int n){
        String s = Integer.toString(x);
        while (s.length() < n) s = "" "" + s;
        return s;
    }"," protected static String formatMDLInt(int x, int n){
        String s = Integer.toString(x);
        if (s.length() > n)
            throw new IllegalArgumentException(""Number too large to fit in "" + n + "" digits"");
        while (s.length() < n)
            s = "" "" + s;
        return s;       
 }"," protected static String formatMDLInt(int x, int n){
        String s = Integer.toString(x);
        int len = s.length();
        if (len < n) {
            StringBuffer sb = new StringBuffer(n);
            sb.append(s);
            for (int i = len; i < n; i++) {
                sb.append(' ');
            }
            return sb.toString();
        } else {
            return s;
        }       
 }",PASS,PASS,NOT PASS,PASS,  0.26244692001813014,  0.26244692001813014,  0.42640079551348575,  0.3336944200902321,73.0,0.6759259259259259,73.0,0.6759259259259259,64.0,0.5925925925925926,63.0,0.5833333333333334,0.0,0.0,55.0,0.5913978494623656,21.0,0.328125,12.0,0.5454545454545454,4.0,0.25,14.0,0.875
284,cdk,"private static int toCharge(final char c){
    switch(c) {
        case '1':
            return +3;
        case '2':
            return +2;
        case '3':
            return +1;
        case '4':
            return 0;
        case '5':
            return -1;
        case '6':
            return -2;
        case '7':
            return -3;
    }
    return 0;
}",toCharge,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Convert the a character (from an MDL V2000 input) to a charge value:
     * 1 = +1, 2 = +2, 3 = +3, 4 = doublet radical, 5 = -1, 6 = -2, 7 = -3.
     *
     * @param c a character
     * @return formal charge
     */",1620-1645,"('toCharge', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",68.0,45.0,"Convert the a character (from an MDL V2000 input) to a charge value:  1 = +1, 2 = +2, 3 = +3, 4 = doublet radical, 5 = -1, 6 = -2, 7 = -3.","Convert a specific character into a charge, starting from MDL V2000 input.",The a character is converted to a charge value of 1 + 1 + 2 + 3 + 4 + 5 + 6 + 7.,0.73073023592939,"Convert the character a (from an MDL V2000 entry) to the load value: 1 = +1, 2 = +2, 3 = +3, 4 = doublet radical, 5 = -1, 6 = -2, 7 = -3.","private static int toCharge(final char c){
        switch (c) {
            case '1':
                return 1;
            case '2':
                return 2;
            case '3':
                return 3;
            case '4':
                return 2;
            case '5':
                return -1;
            case '6':
                return -2;
            case '7':
                return -3;
            default:
                return 0;
        }
    }","private static int toCharge(final char c){
        switch (c) {
            case '+':
                return 1;
            case '-':
                return -1;
            case '0':
                return 0;
            default:
                return 0;
        }
    }","private static int toCharge(final char c){
        switch (c) {
            case '+':
                return 1;
            case '-':
                return -1;
            case '0':
                return 0;
            case '1':
                return 1;
            case '2':
                return 2;
            case '3':
                return 3;
            case '4':
                return 4;
            case '5':
                return 5;
            case '6':
                return 6;
            case '7':
                return 7;
            default:
                return 0;
        }
    }","private static int toCharge(final char c){
        switch (c) {
            case '1':
                return 1;
            case '2':
                return 2;
            case '3':
                return 3;
            case '4':
                return 4;
            case '5':
                return -1;
            case '6':
                return -2;
            case '7':
                return -3;
            default:
                return 0;
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8773898991568366,  0.6564646547315376,  0.8773898991568366,  0.7955315477541081,9.0,0.13043478260869565,33.0,0.4782608695652174,9.0,0.13043478260869565,34.0,0.40476190476190477,30.0,0.4411764705882353,1.0,0.014705882352941176,26.0,0.30952380952380953,32.0,0.8888888888888888,5.0,0.1388888888888889,26.0,0.7222222222222222
285,tablesaw,"public static Function<Table, Selection> notBoth(Function<Table, Selection> sel1, Function<Table, Selection> sel2){
    return new Not(both(sel1, sel2));
}",notBoth,tech/tablesaw/api/QuerySupport.java,/core/src/main/java/tech/tablesaw/api/QuerySupport.java,"/**
   * Returns a selection for all records that don't match both of the given functions. In other
   * words, if both sel1 and sel2 are true, the record as a whole is false, and if either (or both)
   * of sel1 or sel2 is {@code false}, the record as a whole is {@code true}.
   */",35-43,"('notBoth', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,16.0,Returns a selection for all records that don't match both of the given functions.,"For all records that don't match both the given functions, return a selection.",A selection is returned for records that don't match the functions.,0.203432381098079,Returns a selection for all records that do not match the two given functions.,"public static Function<Table, Selection> notBoth(Function<Table, Selection> sel1, Function<Table, Selection> sel2){
    return new Not(both(sel1, sel2));
  }","public static Function<Table, Selection> notBoth(Function<Table, Selection> sel1, Function<Table, Selection> sel2){
    return new Not(both(sel1, sel2));
  }","public static Function<Table, Selection> notBoth(Function<Table, Selection> sel1, Function<Table, Selection> sel2){
    return new Not(both(sel1, sel2));
  }","public static Function<Table, Selection> notBoth(Function<Table, Selection> sel1, Function<Table, Selection> sel2){
    return new Not(both(sel1, sel2));
  }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,9.0,0.6,5.0,0.3333333333333333,8.0,0.5333333333333333
286,cdk,"private boolean familyHalogen(IAtom atom){
    String symbol = atom.getSymbol();
    return symbol.equals(""F"") || symbol.equals(""Cl"") || symbol.equals(""Br"") || symbol.equals(""I"");
}",familyHalogen,org/openscience/cdk/qsar/descriptors/atomic/IPAtomicHOSEDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/IPAtomicHOSEDescriptor.java,"/**
     * Looking if the Atom belongs to the halogen family.
     *
     * @param  atom  The IAtom
     * @return       True, if it belongs
     */",162-171,"('familyHalogen', {'INSTRUCTION': {'covered': 22, 'missed': 1}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,10.0,Looking if the Atom belongs to the halogen family.,checks whether the selected Atom's familiy is halogen.,The atom is being looked at to see if it belongs to the halogen family.,0.556170552942032,See if the Atom belongs to the halogen family.," private boolean familyHalogen(IAtom atom){
        String atomSymbol = atom.getSymbol();
        if (atomSymbol.equals(""F"") || atomSymbol.equals(""Cl"") || atomSymbol.equals(""Br"") || atomSymbol.equals(""I"")){
            return true;
        }
        return false;       
 }"," private boolean familyHalogen(IAtom atom){
        String family = atom.getAtomTypeName();
        if (family.equals(""Cl"") || family.equals(""Br"") || family.equals(""I"") || family.equals(""F"") || family.equals(""At""))
            return true;
        else
            return false;       
 }"," private boolean familyHalogen(IAtom atom){
        String symbol = atom.getSymbol();
        if (symbol.equals(""Cl"") || symbol.equals(""Br"") || symbol.equals(""I"") || symbol.equals(""F"") || symbol.equals(""At""))
            return true;
        else
            return false;       
 }"," private boolean familyHalogen(IAtom atom){
        String symbol = atom.getSymbol();
        if (symbol.equals(""Cl"") || symbol.equals(""Br"") || symbol.equals(""I"") || symbol.equals(""F"") || symbol.equals(""At""))
            return true;
        else
            return false;       
 }",PASS,PASS,PASS,PASS,  0.772237408868989,  0.7303000595913846,  0.8718736607590515,  0.8718736607590515,15.0,0.2631578947368421,26.0,0.4126984126984127,20.0,0.31746031746031744,20.0,0.31746031746031744,18.0,0.2857142857142857,17.0,0.2698412698412698,17.0,0.2698412698412698,8.0,0.8,1.0,0.1,10.0,0.625
287,matsim-libs,"public final void addModule(final ConfigGroup specializedConfigModule){
    String name = specializedConfigModule.getName();
    if (name == null || name.isEmpty()) {
        throw new RuntimeException(""cannot insert module with empty name"");
    }
    ConfigGroup m = this.modules.get(name);
    if (m != null) {
        if (m.getClass() == ConfigGroup.class && specializedConfigModule.getClass() != ConfigGroup.class) {
            copyTo(m, specializedConfigModule);
            this.modules.put(name, specializedConfigModule);
        } else {
            throw new IllegalArgumentException(""Module "" + name + "" exists already."");
        }
    }
    this.modules.put(name, specializedConfigModule);
}",addModule,org/matsim/core/config/Config.java,/matsim/src/main/java/org/matsim/core/config/Config.java,"/**
	 * Adds the specified module / config-group with the specified name to the
	 * configuration.
	 * <p></p>
	 * This is the typical way to ""materialize"" material that, so far, exists only as Map, into a specialized module.
	 * @param specializedConfigModule
	 *
	 * @throws IllegalArgumentException
	 *             if a config-group with the specified name already exists.
	 */",245-279,"('addModule', {'INSTRUCTION': {'covered': 41, 'missed': 11}, 'BRANCH': {'covered': 6, 'missed': 4}, 'LINE': {'covered': 9, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",128.0,14.0,Adds the specified module / config-group with the specified name to the  configuration.,"Given the configuration, adds the module and config-group with the specified name.",The specified module is added to the configuration.,0.442515907608469,Adds the specified configuration module/group with the specified name to the configuration.," public final void addModule(final ConfigGroup specializedConfigModule){
	 if (this.modules.containsKey(specializedConfigModule.getName())) {
		 throw new IllegalArgumentException(""Module "" + specializedConfigModule.getName() + "" exists already."");
	 }
	 this.modules.put(specializedConfigModule.getName(), specializedConfigModule);
 }"," public final void addModule(final ConfigGroup specializedConfigModule){
	 if (this.modules.containsKey(specializedConfigModule.getName())) {
		 throw new IllegalArgumentException(""Module "" + specializedConfigModule.getName() + "" exists already."");
	 }
	 this.modules.put(specializedConfigModule.getName(), specializedConfigModule);
 }"," public final void addModule(final ConfigGroup specializedConfigModule){
	 		if (this.modules.containsKey(specializedConfigModule.getName())) {
 			throw new IllegalArgumentException(""Module "" + specializedConfigModule.getName() + "" exists already."");
 		}
 		this.modules.put(specializedConfigModule.getName(), specializedConfigModule);
 	}"," public final void addModule(final ConfigGroup specializedConfigModule){
	 		if (this.modules.containsKey(specializedConfigModule.getName())) {
 			throw new IllegalArgumentException(""Module "" + specializedConfigModule.getName() + "" exists already."");
 		}
 		this.modules.put(specializedConfigModule.getName(), specializedConfigModule);
 	}",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2678182064771904,  0.2678182064771904,  0.2678182064771904,  0.2678182064771904,88.0,0.6821705426356589,88.0,0.6821705426356589,88.0,0.6821705426356589,88.0,0.6821705426356589,0.0,0.0,0.0,0.0,0.0,0.0,9.0,0.6428571428571429,3.0,0.21428571428571427,8.0,0.5714285714285714
288,cdk,"static int length(final String str){
    int i = str.length() - 1;
    while (i >= 0 && str.charAt(i) == ' ') {
        i--;
    }
    return i + 1;
}",length,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Determine the length of the line excluding trailing whitespace.
     *
     * @param str a string
     * @return the length when trailing white space is removed
     */",1490-1502,"('length', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,10.0,Determine the length of the line excluding trailing whitespace.,"Ignoring the whitespaces at the end of a line, compute the line length.",The length of the line should be determined.,0.220993198326707,Determine the length of the line excluding trailing white space.,"static int length(final String str){
        int len = str.length();
        while (len > 0 && str.charAt(len - 1) <= ' ') len--;
        return len;
    }","static int length(final String str){
        int length = str.length();
        while (length > 0 && str.charAt(length - 1) == ' ') length--;
        return length;
    }",Empty Method,Empty Method,PASS,PASS,Empty Method,Empty Method,  0.4995749085859166,  0.5003838137441582,None,None,15.0,0.3191489361702128,14.0,0.2978723404255319,None,None,None,None,6.0,0.13953488372093023,None,None,None,None,11.0,0.7857142857142857,2.0,0.18181818181818182,5.0,0.5
289,acs-aem-commons,"protected boolean runScript(ResourceResolver resourceResolver, OnDeployScript script){
    Resource statusResource = getOrCreateStatusTrackingResource(resourceResolver, script.getClass());
    String status = getScriptStatus(statusResource);
    if (status == null || status.equals(SCRIPT_STATUS_FAIL)) {
        trackScriptStart(statusResource);
        try {
            script.execute(resourceResolver);
            logger.info(""On-deploy script completed successfully: {}"", statusResource.getPath());
            trackScriptEnd(statusResource, SCRIPT_STATUS_SUCCESS, """");
            return true;
        } catch (Exception e) {
            String errMsg = ""On-deploy script failed: "" + statusResource.getPath();
            logger.error(errMsg, e);
            resourceResolver.revert();
            trackScriptEnd(statusResource, SCRIPT_STATUS_FAIL, ExceptionUtils.getStackTrace(e.getCause()));
            throw new OnDeployEarlyTerminationException(new RuntimeException(errMsg));
        }
    } else if (!status.equals(SCRIPT_STATUS_SUCCESS)) {
        String errMsg = ""On-deploy script is already running or in an otherwise unknown state: "" + statusResource.getPath() + "" - status: "" + status;
        logger.error(errMsg);
        throw new OnDeployEarlyTerminationException(new RuntimeException(errMsg));
    } else {
        logger.debug(""Skipping on-deploy script, as it is already complete: {}"", statusResource.getPath());
    }
    return false;
}",runScript,com/adobe/acs/commons/ondeploy/impl/OnDeployExecutorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/ondeploy/impl/OnDeployExecutorImpl.java,"/**
     * Run the {@link OnDeployScript}, if it has not previously been run successfully.
     * @param resourceResolver the resource resolver to use when running
     * @param script the script to run.
     * @return true if the script is executed, false if it has previous been run successfully
     */",191-225,"('runScript', {'INSTRUCTION': {'covered': 102, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 20, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",216.0,17.0,"Run the {@link OnDeployScript}, if it has not previously been run successfully.",Run the OnDeployScript only if the previous run were not successfully.,"If it has not been successfully run before, then you need to run the @link OnDeployScript.",1.08587842435127,"Run the {onDeployScript} @link, if it has not yet been run successfully."," protected boolean runScript(ResourceResolver resourceResolver, OnDeployScript script){
        Resource statusResource = getOrCreateStatusTrackingResource(resourceResolver, script.getClass());
        if (statusResource == null) {
            return false;
        }
    
        String status = getScriptStatus(statusResource);
        if (status != null && status.equals(SCRIPT_STATUS_SUCCESS)) {
            logger.debug(""Skipping on-deploy script {} because it has already been run successfully"", script.getClass().getName());
            return false;
        }
    
        logger.info(""Running on-deploy script {}"", script.getClass().getName());
        try {
            script.run(resourceResolver);
            statusResource.getValueMap().put(SCRIPT_STATUS, SCRIPT_STATUS_SUCCESS);
            statusResource.getValueMap().put(SCRIPT_DATE_END, new Date());
            return true;
        } catch (Exception e) {
            logger.error(""On-deploy script {} failed"", script.getClass().getName(), e);
            statusResource.getValueMap().put(SCRIPT_STATUS, SCRIPT_STATUS_FAIL);
            statusResource.getValueMap().put(SCRIPT_DATE_END, new Date());
            statusResource.getValueMap().put(SCRIPT_OUTPUT, e.getMessage());
            return false;
        }       
 }"," protected boolean runScript(ResourceResolver resourceResolver, OnDeployScript script){
        Resource statusResource = getOrCreateStatusTrackingResource(resourceResolver, script.getClass());
        if (statusResource == null) {
            return false;
        }
    
        String status = getScriptStatus(statusResource);
        if (status == null) {
            status = SCRIPT_STATUS_RUNNING;
        } else if (status.equals(SCRIPT_STATUS_SUCCESS)) {
            logger.debug(""Skipping on-deploy script {} because it was already successfully run"", script.getClass().getName());
            return false;
        }
    
        try {
            statusResource.getValueMap().put(SCRIPT_STATUS, SCRIPT_STATUS_RUNNING);
            statusResource.getValueMap().put(SCRIPT_DATE_START, new Date());
            statusResource.getValueMap().put(SCRIPT_OUTPUT, """");
            resourceResolver.commit();
        } catch (PersistenceException pe) {
            logger.error(""On-deploy script cannot be run because the system could not update the script status node: {}"", statusResource.getPath());
            throw new OnDeployEarlyTerminationException(pe);
        }
    
        try {
            script.run();
            statusResource.getValueMap().put(SCRIPT_STATUS, SCRIPT_STATUS_SUCCESS);
            statusResource.getValueMap().put(SCRIPT_DATE_END, new Date());
            resourceResolver.commit();
        } catch (Exception e) {
            logger.error(""On-deploy script {} failed"", script.getClass().getName(), e);
            statusResource.getValueMap().put(SCRIPT_STATUS, SCRIPT_STATUS_FAIL);
            statusResource.getValueMap().put(SCRIPT_DATE_END, new Date());
            statusResource.getValueMap().put(SCRIPT_OUTPUT, e.getMessage());
            resourceResolver.commit();
            throw new OnDeployEarlyTerminationException(e);
        }
    
        return true;        
 }"," protected boolean runScript(ResourceResolver resourceResolver, OnDeployScript script){
        Resource statusResource = getOrCreateStatusTrackingResource(resourceResolver, script.getClass());
        String status = getScriptStatus(statusResource);
        if (status == null || status.equals(SCRIPT_STATUS_SUCCESS)) {
            logger.info(""Executing on-deploy script: {}"", script.getClass().getName());
            try {
                script.execute(resourceResolver);
                statusResource.getValueMap().put(SCRIPT_STATUS, SCRIPT_STATUS_SUCCESS);
                statusResource.getValueMap().put(SCRIPT_DATE_END, new GregorianCalendar());
            } catch (Exception e) {
                logger.error(""On-deploy script failed: {}"", script.getClass().getName(), e);
                statusResource.getValueMap().put(SCRIPT_STATUS, SCRIPT_STATUS_FAIL);
                statusResource.getValueMap().put(SCRIPT_OUTPUT, e.getMessage());
                statusResource.getValueMap().put(SCRIPT_DATE_END, new GregorianCalendar());
                return false;
            }
        } else {
            logger.info(""Skipping on-deploy script: {}"", script.getClass().getName());
        }
        return true;
    }",Not Valid,NOT PASS,NOT PASS,Not Valid,NOT PASS,  0.5152412498133767,  0.5618753819836252,None,  0.528635637744964,130.0,0.5990783410138248,179.0,0.5966666666666667,None,None,117.0,0.5391705069124424,100.0,0.3333333333333333,None,None,73.0,0.3395348837209302,8.0,0.6153846153846154,3.0,0.23076923076923078,15.0,0.8823529411764706
290,cdk,"private Integer[] findPaths(IAtomContainer container){
    ShortestPathWalker walker = new ShortestPathWalker(container);
    List<Integer> paths = new ArrayList<Integer>();
    int patternIndex = 0;
    for (String s : walker.paths()) {
        int toHashCode = s.hashCode();
        paths.add(patternIndex, toHashCode);
        patternIndex++;
    }
    IRingSet sssr = Cycles.essential(container).toRingSet();
    RingSetManipulator.sort(sssr);
    for (Iterator<IAtomContainer> it = sssr.atomContainers().iterator(); it.hasNext(); ) {
        IAtomContainer ring = it.next();
        int toHashCode = String.valueOf(ring.getAtomCount()).hashCode();
        paths.add(patternIndex, toHashCode);
        patternIndex++;
    }
    List<String> l = new ArrayList<String>();
    for (Iterator<IAtom> it = container.atoms().iterator(); it.hasNext(); ) {
        IAtom atom = it.next();
        int charge = atom.getFormalCharge() == null ? 0 : atom.getFormalCharge();
        if (charge != 0) {
            l.add(atom.getSymbol().concat(String.valueOf(charge)));
        }
    }
    Collections.sort(l);
    int toHashCode = l.hashCode();
    paths.add(patternIndex, toHashCode);
    patternIndex++;
    l = new ArrayList<String>();
    for (Iterator<IAtom> it = container.atoms().iterator(); it.hasNext(); ) {
        IAtom atom = it.next();
        int st = atom.getStereoParity() == null ? 0 : atom.getStereoParity();
        if (st != 0) {
            l.add(atom.getSymbol().concat(String.valueOf(st)));
        }
    }
    Collections.sort(l);
    toHashCode = l.hashCode();
    paths.add(patternIndex, toHashCode);
    patternIndex++;
    if (container.getSingleElectronCount() > 0) {
        StringBuilder radicalInformation = new StringBuilder();
        radicalInformation.append(""RAD: "").append(String.valueOf(container.getSingleElectronCount()));
        paths.add(patternIndex, radicalInformation.toString().hashCode());
        patternIndex++;
    }
    if (container.getLonePairCount() > 0) {
        StringBuilder lpInformation = new StringBuilder();
        lpInformation.append(""LP: "").append(String.valueOf(container.getLonePairCount()));
        paths.add(patternIndex, lpInformation.toString().hashCode());
        patternIndex++;
    }
    return paths.toArray(new Integer[paths.size()]);
}",findPaths,org/openscience/cdk/fingerprint/ShortestPathFingerprinter.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/ShortestPathFingerprinter.java,"/**
     * Get all paths of lengths 0 to the specified length.
     *
     * This method will find all paths upto length N starting from each atom in the molecule and return the unique set
     * of such paths.
     *
     * @param container The molecule to search
     * @return A map of path strings, keyed on themselves
     */",177-255,"('findPaths', {'INSTRUCTION': {'covered': 156, 'missed': 50}, 'BRANCH': {'covered': 16, 'missed': 4}, 'LINE': {'covered': 40, 'missed': 9}, 'COMPLEXITY': {'covered': 7, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",545.0,11.0,Get all paths of lengths 0 to the specified length.,Return a unique set of all paths that start from each atom in the molecule with a length between 0 and N.,Get the paths of lengths 0 to the length.,0.222193016599033,Get all paths from length 0 to the specified length.,Not Valid,Not Valid,"private Integer[] findPaths(IAtomContainer container){
        int length = container.getAtomCount();
        Integer[] hashes = new Integer[length];
        for (int i = 0; i < length; i++) {
            IAtom atom = container.getAtom(i);
            int hash = getAtomHash(atom);
            hashes[i] = hash;
        }
        return hashes;      
 }","private Integer[] findPaths(IAtomContainer container){
        int length = container.getAtomCount();
        Integer[] hashes = new Integer[length];
        for (int i = 0; i < length; i++) {
            IAtom atom = container.getAtom(i);
            int hash = getAtomHash(atom);
            hashes[i] = hash;
        }
        return hashes;      
 }",Not Valid,Not Valid,NOT PASS,NOT PASS,None,None,  0.1365135172724442,  0.13498912702854177,None,None,None,None,496.0,0.9084249084249084,496.0,0.9084249084249084,None,None,75.0,0.9868421052631579,75.0,0.9868421052631579,19.0,0.8260869565217391,2.0,0.18181818181818182,2.0,0.18181818181818182
291,jackson-databind,"public static Class<?> primitiveType(Class<?> type){
    if (type.isPrimitive()) {
        return type;
    }
    if (type == Integer.class) {
        return Integer.TYPE;
    }
    if (type == Long.class) {
        return Long.TYPE;
    }
    if (type == Boolean.class) {
        return Boolean.TYPE;
    }
    if (type == Double.class) {
        return Double.TYPE;
    }
    if (type == Float.class) {
        return Float.TYPE;
    }
    if (type == Byte.class) {
        return Byte.TYPE;
    }
    if (type == Short.class) {
        return Short.TYPE;
    }
    if (type == Character.class) {
        return Character.TYPE;
    }
    return null;
}",primitiveType,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * Method that can be used to find primitive type for given class if (but only if)
     * it is either wrapper type or primitive type; returns {@code null} if type is neither.
     *
     * @since 2.7
     */",911-948,"('primitiveType', {'INSTRUCTION': {'covered': 47, 'missed': 0}, 'BRANCH': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",152.0,38.0,Method that can be used to find primitive type for given class if (but only if)  it is either wrapper type or primitive type; returns {@code null} if type is neither.,-,"If it is either wrapper type or primitive type, the method can be used to find primitive type for given class.",1.05062973103661,A method that can be used to find a primitive type for a given class if (but only if) it is either a wrapper type or a primitive type; returns {@code null} if the type is neither.," public static Class<?> primitiveType(Class<?> type){
        if (type == Integer.class) {
            return Integer.TYPE;
        }
        if (type == Long.class) {
            return Long.TYPE;
        }
        if (type == Boolean.class) {
            return Boolean.TYPE;
        }
        if (type == Double.class) {
            return Double.TYPE;
        }
        if (type == Float.class) {
            return Float.TYPE;
        }
        if (type == Byte.class) {
            return Byte.TYPE;
        }
        if (type == Short.class) {
            return Short.TYPE;
        }
        if (type == Character.class) {
            return Character.TYPE;
        }
        return null;
    }"," public static Class<?> primitiveType(Class<?> type){
        if(type == Integer.class){
            return Integer.TYPE;
        }
        if(type == Long.class){
            return Long.TYPE;
        }
        if(type == Boolean.class){
            return Boolean.TYPE;
        }
        if(type == Double.class){
            return Double.TYPE;
        }
        if(type == Float.class){
            return Float.TYPE;
        }
        if(type == Byte.class){
            return Byte.TYPE;
        }
        if(type == Short.class){
            return Short.TYPE;
        }
        if(type == Character.class){
            return Character.TYPE;
        }
        return null;
    }"," public static Class<?> primitiveType(Class<?> type){
        if(type == Integer.class){
            return Integer.TYPE;
        }
        if(type == Long.class){
            return Long.TYPE;
        }
        if(type == Boolean.class){
            return Boolean.TYPE;
        }
        if(type == Double.class){
            return Double.TYPE;
        }
        if(type == Float.class){
            return Float.TYPE;
        }
        if(type == Byte.class){
            return Byte.TYPE;
        }
        if(type == Short.class){
            return Short.TYPE;
        }
        if(type == Character.class){
            return Character.TYPE;
        }
        return type;
    }"," public static Class<?> primitiveType(Class<?> type){
        if (type == Integer.class) {
            return Integer.TYPE;
        }
        if (type == Long.class) {
            return Long.TYPE;
        }
        if (type == Boolean.class) {
            return Boolean.TYPE;
        }
        if (type == Double.class) {
            return Double.TYPE;
        }
        if (type == Float.class) {
            return Float.TYPE;
        }
        if (type == Byte.class) {
            return Byte.TYPE;
        }
        if (type == Short.class) {
            return Short.TYPE;
        }
        if (type == Character.class) {
            return Character.TYPE;
        }
        return null;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.9189271827790398,  0.9189271827790398,  0.9189271827790398,  0.9222211001020102,13.0,0.08496732026143791,13.0,0.08496732026143791,13.0,0.08496732026143791,14.0,0.0915032679738562,0.0,0.0,0.0,0.0,1.0,0.007142857142857143,31.0,0.96875,7.0,0.18421052631578946,28.0,0.875
292,cucumber-reporting,"public boolean hasContent(){
    if (embeddings.length > 0) {
        // assuming that if the embedding exists then it is not empty
        return true;
    }
    if (StringUtils.isNotBlank(result.getErrorMessage())) {
        return true;
    }
    // TODO: hook with 'output' should be treated as empty or not?
    return false;
}",hasContent,net/masterthought/cucumber/json/Hook.java,/src/main/java/net/masterthought/cucumber/json/Hook.java,"/**
     * Checks if the hook has content meaning as it has at least attachment or result with error message.
     *
     * @return <code>true</code> if the hook has content otherwise <code>false</code>
     */",43-58,"('hasContent', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,19.0,Checks if the hook has content meaning as it has at least attachment or result with error message.,Check the presence of the content in the hook; this happens if there is an attachment or a result with an error message.,"If the hook has at least an attachment or result with an error message, it's checked.",0.735270647616884,Checks whether the hook has a content meaning because it has at least one attachment or result with error message.," public boolean hasContent(){
        return !StringUtils.isEmpty(getResult().getErrorMessage()) || !getOutputs().isEmpty();
    }"," public boolean hasContent(){
        return !StringUtils.isEmpty(getContent());      
 }","public boolean hasContent(){
        return (getOutputs().length > 0 || getResult().getErrorMessage() != null);      
 }","public boolean hasContent(){
        return !StringUtils.isEmpty(getResult().getErrorMessage()) || getOutputs().length > 0;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS, 0.24906416189353903, 0.12201857141713607, 0.29805338429965633, 0.2556968711262075,26.0,0.6190476190476191,26.0,0.6190476190476191,25.0,0.5952380952380952,25.0,0.5952380952380952,14.0,0.4375,4.0,0.125,15.0,0.46875,16.0,0.6666666666666666,4.0,0.19047619047619047,12.0,0.631578947368421
293,cdk," static String auxInfo(IAtomContainer container, INCHI_OPTION... options) throws CDKException{
    InChIGeneratorFactory factory = InChIGeneratorFactory.getInstance();
    boolean org = factory.getIgnoreAromaticBonds();
    factory.setIgnoreAromaticBonds(true);
    InChIGenerator gen = factory.getInChIGenerator(container, Arrays.asList(options));
    factory.setIgnoreAromaticBonds(org);
    if (gen.getReturnStatus() != INCHI_RET.OKAY && gen.getReturnStatus() != INCHI_RET.WARNING)
        throw new CDKException(""Could not generate InChI Numbers: "" + gen.getMessage());
    return gen.getAuxInfo();
}",auxInfo,org/openscience/cdk/graph/invariant/InChINumbersTools.java,/storage/inchi/src/main/java/org/openscience/cdk/graph/invariant/InChINumbersTools.java,"/**
     * Obtain the InChI auxiliary info for the provided structure using
     * using the specified InChI options.
     *
     * @param  container the structure to obtain the numbers of
     * @return auxiliary info
     * @throws CDKException the inchi could not be generated
     */",224-241,"('auxInfo', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",106.0,16.0,Obtain the InChI auxiliary info for the provided structure using  using the specified InChI options.,"Get the InChi auxiliary info, using the specified options, for the given structure.",The InChI auxiliary info can be obtained using the specified options.,0.502110203370694,Obtain the InChI auxiliary information for the provided structure using the specified InChI options.,"  static String auxInfo(IAtomContainer container, INCHI_OPTION... options) throws CDKException{
    return auxInfo(container, Arrays.asList(options));          
  }","  static String auxInfo(IAtomContainer container, INCHI_OPTION... options) throws CDKException{
    return auxInfo(container, Arrays.asList(options));          
  }","  static String auxInfo(IAtomContainer container, INCHI_OPTION... options) throws CDKException{
    return auxInfo(container, Arrays.asList(options));          
  }","  static String auxInfo(IAtomContainer container, INCHI_OPTION... options) throws CDKException{
    return auxInfo(container, options, null);           
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.18009537001464632,  0.18009537001464632,  0.13257142744230754,  0.18009537001464632,80.0,0.7476635514018691,80.0,0.7476635514018691,85.0,0.794392523364486,80.0,0.7476635514018691,0.0,0.0,6.0,0.20689655172413793,0.0,0.0,11.0,0.6875,2.0,0.125,8.0,0.5
294,cdk,"public List<Orbit> calculateOrbits(){
    List<Orbit> orbits = new ArrayList<Orbit>();
    List<SymmetryClass> symmetryClasses = super.getSymmetryClasses();
    for (SymmetryClass symmetryClass : symmetryClasses) {
        Orbit orbit = new Orbit(symmetryClass.getSignatureString(), -1);
        for (int atomIndex : symmetryClass) {
            orbit.addAtom(atomIndex);
        }
        orbits.add(orbit);
    }
    return orbits;
}",calculateOrbits,org/openscience/cdk/signature/MoleculeSignature.java,/descriptor/signature/src/main/java/org/openscience/cdk/signature/MoleculeSignature.java,"/**
     * Calculates the orbits of the atoms of the molecule.
     *
     * @return a list of orbits
     */",153-169,"('calculateOrbits', {'INSTRUCTION': {'covered': 46, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,10.0,Calculates the orbits of the atoms of the molecule.,Returns the list of the orbits of all the atoms in the molecule.,The molecule's atoms are calculated.,0.536357632222563,Calculates the orbits of the atoms of the molecule.," public List<Orbit> calculateOrbits(){
        List<Orbit> orbits = new ArrayList<Orbit>();
        Orbit orbit = new Orbit(this.molecule);
        while (orbit.hasNext()) {
            orbits.add(orbit);
            orbit = orbit.next();
        }
        return orbits;
    }","public List<Orbit> calculateOrbits(){
        List<Orbit> orbits = new ArrayList<Orbit>();
        for (int i = 0; i < this.getVertexCount(); i++) {
            Orbit orbit = new Orbit(i, this.molecule);
            orbits.add(orbit);
        }
        return orbits;
    }"," public List<Orbit> calculateOrbits(){
        List<Orbit> orbits = new ArrayList<Orbit>();
        int[] orbit = new int[this.molecule.getAtomCount()];
        int[] orbitCount = new int[this.molecule.getAtomCount()];
        int[] orbitSize = new int[this.molecule.getAtomCount()];
        int[] orbitColor = new int[this.molecule.getAtomCount()];
        int[] orbitColorCount = new int[this.molecule.getAtomCount()];
        int[] orbitColorSize = new int[this.molecule.getAtomCount()];
        int[] orbitColorClass = new int[this.molecule.getAtomCount()];
        int[] orbitColorClassCount = new int[this.molecule.getAtomCount()];
        int[] orbitColorClassSize = new int[this.molecule.getAtomCount()];
        int[] orbitColorClassSymmetry = new int[this.molecule.getAtomCount()];
        int[] orbitColorClassSymmetryCount = new int[this.molecule.getAtomCount()];
        int[] orbitColorClassSymmetrySize = new int[this.molecule.getAtomCount()];
        int[] orbitColorClassSymmetryClass = new int[this.molecule.getAtomCount()];
        int[] orbitColorClassSymmetryClassCount = new int[this.molecule.getAtomCount()];
        int[] orbitColorClassSymmetryClassSize = new int[this.molecule.getAtomCount()];
        int[] orbitColorClassSymmetryClassSymmetry = new int[this.molecule.getAtomCount()];
        int[] orbitColorClassSymmetryClassSymmetryCount = new int[this.molecule.getAtomCount()];
        int[] orbitColorClassSymmetryClassSymmetrySize = new int[this.molecule.getAtomCount()];
        int[] orbitColorClassSymmetryClassSymmetryClass = new int[this.molecule     
 }","public List<Orbit> calculateOrbits(){
        List<Orbit> orbits = new ArrayList<Orbit>();
        Orbit orbit;
        for (int i = 0; i < this.getVertexCount(); i++) {
            orbit = new Orbit(i, this.molecule);
            orbits.add(orbit);
        }
        return orbits;      
 }",NOT PASS,NOT PASS,NOT PASS,Syntax Error,  0.5101271417210754,  0.561897010887106,  0.549817301335472,None,41.0,0.4659090909090909,38.0,0.4318181818181818,41.0,0.4659090909090909,290.0,0.847953216374269,30.0,0.4411764705882353,28.0,0.4,293.0,0.8567251461988304,6.0,0.42857142857142855,0.0,0.0,8.0,0.8
295,acs-aem-commons,"private boolean isResourceOnly(final Agent agent){
    final ValueMap properties = agent.getConfiguration().getProperties();
    final String[] headers = properties.get(AgentConfig.PROTOCOL_HTTP_HEADERS, new String[] {});
    for (final String header : headers) {
        if (StringUtils.equals(header, CQ_SCOPE_ACTION_HEADER)) {
            return true;
        }
    }
    return false;
}",isResourceOnly,com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,"/**
     * Checks if the agent has valid CQ-Action-Scope: ResourceOnly header.
     *
     * @param agent Agent to check
     * @return true if the Agent's headers contain the expected values
     */",174-191,"('isResourceOnly', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,11.0,Checks if the agent has valid CQ-Action-Scope: ResourceOnly header.,Returns whether the Agent has a valid CQ-Action-Scope.,The agent is checked if it has a valid ResourceOnly header.,1.47112645415745,Checks whether the agent has a valid CQ-Action-Scope: ResourceOnly header.,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,7.0,0.7,2.0,0.18181818181818182,8.0,0.6666666666666666
296,shenyu,"public static LocalDateTime formatLocalDateTimeFromTimestamp(final Long timestamp){
    return LocalDateTime.ofEpochSecond(timestamp / 1000, 0, ZoneOffset.ofHours(8));
}",formatLocalDateTimeFromTimestamp,org/apache/shenyu/common/utils/DateUtils.java,/shenyu-common/src/main/java/org/apache/shenyu/common/utils/DateUtils.java,"/**
     * Format local date time from timestamp local date time.
     *
     * @param timestamp the timestamp
     * @return the local date time
     */",81-89,"('formatLocalDateTimeFromTimestamp', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,10.0,Format local date time from timestamp local date time.,Returns the local date time formatted from the timestamp of the local date time.,Local date time from local time stamp.,0.168517840529983,Format the local date and time from the local date timestamp.," public static LocalDateTime formatLocalDateTimeFromTimestamp(final Long timestamp){
        return LocalDateTime.ofInstant(OffsetDateTime.ofInstant(timestamp, ZoneOffset.UTC).toInstant(), ZoneOffset.UTC);
    }"," public static LocalDateTime formatLocalDateTimeFromTimestamp(final Long timestamp){
        return LocalDateTime.ofInstant(OffsetDateTime.ofInstant(timestamp, ZoneOffset.UTC).toInstant(), ZoneOffset.UTC);
    }"," public static LocalDateTime formatLocalDateTimeFromTimestamp(final Long timestamp){
        return LocalDateTime.ofInstant(OffsetDateTime.ofInstant(timestamp, ZoneOffset.UTC).toInstant(), ZoneOffset.UTC);        
 }"," public static LocalDateTime formatLocalDateTimeFromTimestamp(final Long timestamp){
        return LocalDateTime.ofInstant(OffsetDateTime.ofInstant(timestamp, ZoneOffset.UTC).toInstant(), ZoneOffset.UTC);        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6127235381428394,  0.6127235381428394,  0.6127235381428394,  0.6127235381428394,15.0,0.40540540540540543,15.0,0.40540540540540543,15.0,0.40540540540540543,15.0,0.40540540540540543,0.0,0.0,0.0,0.0,0.0,0.0,6.0,0.4,4.0,0.3333333333333333,5.0,0.5
297,tablesaw,"public Row appendRow(){
    for (final Column<?> column : columnList) {
        column.appendMissing();
    }
    return row(rowCount() - 1);
}",appendRow,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,"/**
   * Appends an empty row and returns a Row object indexed to the newly added row so values can be
   * set.
   *
   * <p>Intended usage:
   *
   * <p>for (int i = 0; ...) { Row row = table.appendRow(); row.setString(""name"", ""Bob"");
   * row.setFloat(""IQ"", 123.4f); ...etc. }
   */",1098-1112,"('appendRow', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,21.0,Appends an empty row and returns a Row object indexed to the newly added row so values can be  set.,"The function appends an empty row, returning a Row object pointing to the new inserted row in order to be set.",Appends an empty row and returns a Row object that is related to the new row.,1.06966574019092,Adds a blank row and returns an indexed Row object to the newly added row so that values can be set.," public Row appendRow(){
    Row r = new Row(columnCount());
    append(r);
    return r;
  }"," public Row appendRow(){
    Row row = new Row(this);
    rowList.add(row);
    return row;
  }"," public Row appendRow(){
    Row row = new Row(this);
    append(row);
    return row;
  }"," public Row appendRow(){
    Row r = new Row(this);
    rowList.add(r);
    return r;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.25679165029451995,  0.22270074120361083,  0.21884904957166212,  0.2201786551497859,23.0,0.6216216216216216,22.0,0.5945945945945946,23.0,0.6216216216216216,23.0,0.6216216216216216,9.0,0.3333333333333333,6.0,0.2222222222222222,6.0,0.2222222222222222,12.0,0.5454545454545454,7.0,0.3181818181818182,11.0,0.5238095238095238
298,matsim-libs,"public static OptionalTime decideOnActivityEndTime(Activity act, double now, Config config){
    return decideOnActivityEndTime(act, now, config.plans().getActivityDurationInterpretation());
}",decideOnActivityEndTime,org/matsim/core/population/PopulationUtils.java,/matsim/src/main/java/org/matsim/core/population/PopulationUtils.java,"/**
         * Computes the (expected or planned) activity end time, depending on the configured time interpretation.
         */",458-463,"('decideOnActivityEndTime', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,18.0,"Computes the (expected or planned) activity end time, depending on the configured time interpretation.","After reading the configured time interpretation, computes the activity end time that is expected or planned.",The end time is computed based on the configured time interpretation.,0.1718143258513,"Calculates the end time of the activity (scheduled or scheduled), based on the interpretation of the configured time."," public static OptionalTime decideOnActivityEndTime(Activity act, double now, Config config){
	 OptionalTime endTime = act.getEndTime() ;
	 if (endTime.isUndefined()){
		 endTime = act.getExpectedEndTime() ;
	 }
	 if (endTime.isUndefined()){
		 endTime = act.getPlannedEndTime() ;
	 }
	 if (endTime.isUndefined()){
		 endTime = act.getExpectedDuration() ;
	 }
	 if (endTime.isUndefined()){
		 endTime = act.getPlannedDuration() ;
	 }
	 if (endTime.isUndefined()){
		 endTime = act.getMaximumDuration() ;
	 }
	 if (endTime.isUndefined()){
		 endTime = act.getMinimumDuration() ;
	 }
	 if (endTime.isUndefined()){
		 endTime = act.getMaximumDuration() ;
	 }
	 if (endTime.isUndefined()){
		 endTime = act.getMinimumDuration() ;
	 }
	 if (endTime.isUndefined()){
		 endTime = act.getMaximumDuration() ;
	 }
	 if (endTime.isUndefined()){
		 endTime = act.getMinimumDuration() ;
	 }
	 if (endTime.isUndefined()){
		 endTime = act.getMaximumDuration() ;
	 }
	 if (endTime.isUndefined()){
		 endTime = act.getMinimumDuration() ;
	 }
	 if (endTime.isUndefined()){
		 endTime = act.getMaximumDuration() ;
	 }
	 if (endTime.isUndefined()){
		 endTime = act.getMinimumDuration() ;
	 }
	 if (endTime.isUndefined()){
		 endTime = act.getMaximumDuration() ;
	 }
	 if (endTime.isUndefined()){
		 endTime = act.getMinimumDuration() ;
	 }
	 if (endTime.isUndefined()){
		 endTime = act.getMaximumDuration() ;
	 }
	 if (			
 }"," public static OptionalTime decideOnActivityEndTime(Activity act, double now, Config config){
	 OptionalTime endTime = act.getEndTime() ;
	 if (endTime.isUndefined()){
		 endTime = config.plans().getActivityEndTimeInterpretation() ;
	 }
	 return endTime ;
 }"," public static OptionalTime decideOnActivityEndTime(Activity act, double now, Config config){
	 		if (act.getEndTime() != Time.UNDEFINED_TIME) {
 			return OptionalTime.of(act.getEndTime());
 		}
 		else {
 			return OptionalTime.of(now + act.getMaximumDuration());
 		}
 	}"," public static OptionalTime decideOnActivityEndTime(Activity act, double now, Config config){
		if (act.getEndTime() != Time.UNDEFINED_TIME) {
			return OptionalTime.of(act.getEndTime());
		}
		else {
			return decideOnActivityEndTime(act, now, config.travelTimeCalculator(), config.timeAllocationMutator());
		}
	}",Syntax Error,NOT PASS,NOT PASS,NOT PASS,None,  0.6386034227053438,  0.7223610781997996,  0.5896330295051725,None,None,24.0,0.47058823529411764,33.0,0.5,33.0,0.55,287.0,0.8592814371257484,287.0,0.8592814371257484,288.0,0.8622754491017964,14.0,0.8235294117647058,14.0,0.7368421052631579,9.0,0.6
299,acs-aem-commons,"protected String aggregateChecksums(final Map<String, String> checksums){
    if (checksums.isEmpty()) {
        return null;
    }
    StringBuilder data = new StringBuilder();
    for (Map.Entry<String, String> entry : checksums.entrySet()) {
        data.append(entry.getKey() + ""="" + entry.getValue());
    }
    return DigestUtils.sha1Hex(data.toString());
}",aggregateChecksums,com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,"/**
     * Aggregates a set of checksum entries into a single checksum value.
     * @param checksums the checksums
     * @return the checksum value
     */",376-391,"('aggregateChecksums', {'INSTRUCTION': {'covered': 42, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,12.0,Aggregates a set of checksum entries into a single checksum value.,Returns the checksum value computed by aggregating a set of checksum entries.,A set of entries are aggregated into a single value.,0.367690462440356,Groups a set of checksum entries into a single checksum value.,"protected String aggregateChecksums(final Map<String, String> checksums){
        final StringBuilder builder = new StringBuilder();
    
        for (final Map.Entry<String, String> entry : checksums.entrySet()) {
            builder.append(entry.getKey());
            builder.append(entry.getValue());
        }
    
        return DigestUtils.sha1Hex(builder.toString());
    }","protected String aggregateChecksums(final Map<String, String> checksums){
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<String, String> entry : checksums.entrySet()) {
            sb.append(entry.getKey());
            sb.append(entry.getValue());
        }
        return DigestUtils.sha1Hex(sb.toString());
    }"," protected String aggregateChecksums(final Map<String, String> checksums){
        StringBuilder sb = new StringBuilder();
    
        for (Map.Entry<String, String> entry : checksums.entrySet()) {
            sb.append(entry.getKey());
            sb.append("":"");
            sb.append(entry.getValue());
            sb.append("";"");
        }
    
        return sb.toString();
    }","protected String aggregateChecksums(final Map<String, String> checksums){
        StringBuilder checksum = new StringBuilder();
    
        for (Map.Entry<String, String> entry : checksums.entrySet()) {
            checksum.append(entry.getKey());
            checksum.append(entry.getValue());
        }
    
        return DigestUtils.sha1Hex(checksum.toString());
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.742823397748062,  0.7579784947480488,  0.7579784947480488,  0.7259972791126401,23.0,0.26136363636363635,22.0,0.25,22.0,0.25,39.0,0.4431818181818182,6.0,0.075,6.0,0.075,23.0,0.26436781609195403,10.0,0.7692307692307693,1.0,0.08333333333333333,6.0,0.5
300,cdk,"public static void translateAllPositive(IAtomContainer atomCon){
    double minX = Double.MAX_VALUE;
    double minY = Double.MAX_VALUE;
    Iterator<IAtom> atoms = atomCon.atoms().iterator();
    while (atoms.hasNext()) {
        IAtom atom = (IAtom) atoms.next();
        if (atom.getPoint2d() != null) {
            if (atom.getPoint2d().x < minX) {
                minX = atom.getPoint2d().x;
            }
            if (atom.getPoint2d().y < minY) {
                minY = atom.getPoint2d().y;
            }
        }
    }
    logger.debug(""Translating: minx="" + minX + "", minY="" + minY);
    translate2D(atomCon, minX * -1, minY * -1);
}",translateAllPositive,org/openscience/cdk/geometry/GeometryTools.java,/legacy/src/main/java/org/openscience/cdk/geometry/GeometryTools.java,"/**
     *  Adds an automatically calculated offset to the coordinates of all atoms
     *  such that all coordinates are positive and the smallest x or y coordinate
     *  is exactly zero.
     *  See comment for center(IAtomContainer atomCon, Dimension areaDim, HashMap renderingCoordinates) for details on coordinate sets
     *
     *@param  atomCon  AtomContainer for which all the atoms are translated to
     *      positive coordinates
     */",102-128,"('translateAllPositive', {'INSTRUCTION': {'covered': 62, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",150.0,28.0,Adds an automatically calculated offset to the coordinates of all atoms  such that all coordinates are positive and the smallest x or y coordinate  is exactly zero.,The function calculates an offset that has to be added to the coordinates of all atoms so that the smallest x or y coordinates is exactly zero.,The smallest x or y coordinate is exactly zero when calculating the offset.,0.611724182652086,Adds an automatically calculated offset to the coordinates of all atoms so that all coordinates are positive and the smallest x or y coordinate is exactly zero.,"public static void translateAllPositive(IAtomContainer atomCon){
        double minX = Double.POSITIVE_INFINITY;
        double minY = Double.POSITIVE_INFINITY;
        double minZ = Double.POSITIVE_INFINITY;
        for (IAtom atom : atomCon.atoms()) {
            if (atom.getPoint2d() != null) {
                minX = Math.min(minX, atom.getPoint2d().x);
                minY = Math.min(minY, atom.getPoint2d().y);
            }
            if (atom.getPoint3d() != null) {
                minX = Math.min(minX, atom.getPoint3d().x);
                minY = Math.min(minY, atom.getPoint3d().y);
                minZ = Math.min(minZ, atom.getPoint3d().z);
            }
        }
        for (IAtom atom : atomCon.atoms()) {
            if (atom.getPoint2d() != null) {
                atom.setPoint2d(new Point2d(atom.getPoint2d().x - minX, atom.getPoint2d().y - minY));
            }
            if (atom.getPoint3d() != null) {
                atom.setPoint3d(new Point3d(atom.getPoint3d().x - minX, atom.getPoint3d().y - minY, atom.getPoint3d().z - minZ));
            }
        }
    }","public static void translateAllPositive(IAtomContainer atomCon){
        double minX = Double.POSITIVE_INFINITY;
        double minY = Double.POSITIVE_INFINITY;
        double minZ = Double.POSITIVE_INFINITY;
        for (IAtom atom : atomCon.atoms()) {
            if (atom.getPoint2d() != null) {
                minX = Math.min(minX, atom.getPoint2d().x);
                minY = Math.min(minY, atom.getPoint2d().y);
            }
            if (atom.getPoint3d() != null) {
                minX = Math.min(minX, atom.getPoint3d().x);
                minY = Math.min(minY, atom.getPoint3d().y);
                minZ = Math.min(minZ, atom.getPoint3d().z);
            }
        }
        for (IAtom atom : atomCon.atoms()) {
            if (atom.getPoint2d() != null) {
                atom.setPoint2d(new Point2d(atom.getPoint2d().x - minX, atom.getPoint2d().y - minY));
            }
            if (atom.getPoint3d() != null) {
                atom.setPoint3d(new Point3d(atom.getPoint3d().x - minX, atom.getPoint3d().y - minY, atom.getPoint3d().z - minZ));
            }
        }
    }","public static void translateAllPositive(IAtomContainer atomCon){
        double minX = Double.MAX_VALUE;
        double minY = Double.MAX_VALUE;
        for (IAtom atom : atomCon.atoms()) {
            if (atom.getPoint2d() != null) {
                minX = Math.min(minX, atom.getPoint2d().x);
                minY = Math.min(minY, atom.getPoint2d().y);
            }
        }
        if (minX < 0) {
            for (IAtom atom : atomCon.atoms()) {
                if (atom.getPoint2d() != null) {
                    atom.getPoint2d().x -= minX;
                }
            }
        }
        if (minY < 0) {
            for (IAtom atom : atomCon.atoms()) {
                if (atom.getPoint2d() != null) {
                    atom.getPoint2d().y -= minY;
                }
            }
        }
    }","public static void translateAllPositive(IAtomContainer atomCon){
        double minX = Double.POSITIVE_INFINITY;
        double minY = Double.POSITIVE_INFINITY;
        double minZ = Double.POSITIVE_INFINITY;
        for (IAtom atom : atomCon.atoms()) {
            if (atom.getPoint2d() != null) {
                minX = Math.min(minX, atom.getPoint2d().x);
                minY = Math.min(minY, atom.getPoint2d().y);
            }
            if (atom.getPoint3d() != null) {
                minX = Math.min(minX, atom.getPoint3d().x);
                minY = Math.min(minY, atom.getPoint3d().y);
                minZ = Math.min(minZ, atom.getPoint3d().z);
            }
        }
        for (IAtom atom : atomCon.atoms()) {
            if (atom.getPoint2d() != null) {
                atom.setPoint2d(new Point2d(atom.getPoint2d().x - minX, atom.getPoint2d().y - minY));
            }
            if (atom.getPoint3d() != null) {
                atom.setPoint3d(new Point3d(atom.getPoint3d().x - minX, atom.getPoint3d().y - minY, atom.getPoint3d().z - minZ));
            }
        }
    }",PASS,NOT PASS,PASS,PASS,  0.5290335613000432,  0.5290335613000432,  0.5290335613000432,  0.5071583790445394,165.0,0.637065637065637,165.0,0.637065637065637,165.0,0.637065637065637,101.0,0.5941176470588235,0.0,0.0,0.0,0.0,124.0,0.47876447876447875,16.0,0.5714285714285714,1.0,0.03571428571428571,24.0,0.8571428571428571
301,cdk,"private int permutationParity(int[] vs){
    int n = 0;
    for (int i = 0; i < vs.length; i++) for (int j = i + 1; j < vs.length; j++) if (vs[i] > vs[j])
        n++;
    return (n & 0x1) == 1 ? -1 : 1;
}",permutationParity,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,"/**
     * Compute the permutation parity of the values {@code vs}. The parity is
     * whether we need to do an odd or even number of swaps to put the values in
     * sorted order.
     *
     * @param vs values
     * @return parity of the permutation (odd = -1, even = +1)
     */",310-324,"('permutationParity', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",79.0,13.0,Compute the permutation parity of the values {@code vs}.,"Given a list of values, it returns the permutation parity. The parity is equal to -1 if we need a odd number of swaps to sort the list or +1 if we need a even number of swaps.",The permutation parity of the values is computed.,0.196910072447064,Calculate the permutation parity of the {@code vs} values.,"private int permutationParity(int[] vs){
        int p = 1;
        for (int i = 0; i < vs.length; i++) {
            for (int j = i + 1; j < vs.length; j++) {
                if (vs[i] > vs[j]) p *= -1;
            }
        }
        return p;
    }","private int permutationParity(int[] vs){
        int parity = 1;
        for (int i = 0; i < vs.length; i++) {
            for (int j = i + 1; j < vs.length; j++) {
                if (vs[i] > vs[j]) {
                    parity *= -1;
                    int tmp = vs[i];
                    vs[i] = vs[j];
                    vs[j] = tmp;
                }
            }
        }
        return parity;
    }","private int permutationParity(int[] vs){
        int parity = 1;
        for (int i = 0; i < vs.length; i++) {
            for (int j = i + 1; j < vs.length; j++) {
                if (vs[i] > vs[j]) parity *= -1;
            }
        }
        return parity;
    }","private int permutationParity(int[] vs){
        int parity = 1;
        for (int i = 0; i < vs.length; i++) {
            for (int j = i + 1; j < vs.length; j++) {
                if (vs[i] > vs[j]) parity *= -1;
            }
        }
        return parity;
    }",PASS,PASS,PASS,PASS,  0.6995090168647379,  0.6592166273455665,  0.6995090168647379,  0.6995090168647379,19.0,0.2375,39.0,0.38235294117647056,19.0,0.2375,19.0,0.2375,30.0,0.29411764705882354,3.0,0.04,3.0,0.04,33.0,0.8461538461538461,4.0,0.4,4.0,0.4
302,glowstone,"public boolean isList(@NonNls String key, TagType type){
    if (!is(key, ListTag.class)) {
        return false;
    }
    ListTag tag = getTag(key, ListTag.class);
    return tag.getChildType() == type;
}",isList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Test whether the subtag with the given key is of {@link List} type.
     *
     * @param key the key to look up
     * @param type the {@link TagType} of the list's elements
     * @return true if the subtag exists and is a {@link List}; false otherwise
     */",842-855,"('isList', {'INSTRUCTION': {'covered': 20, 'missed': 1}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",52.0,17.0,Test whether the subtag with the given key is of {@link List} type.,"Given a key, check whether the subtag containing the key is of List type.",The subtag with the given key is of the @link List type.,1.02217324065121,Check if the subtag with the given key is of type {@link List}.," public boolean isList(@NonNls String key, TagType type){
        return is(key, ListTag.class, type);
    }"," public boolean isList(@NonNls String key, TagType type){
        return is(key, ListTag.class, type);        
 }"," public boolean isList(@NonNls String key, TagType type){
        return is(key, ListTag.class, type);
    }"," public boolean isList(@NonNls String key, TagType type){
        return is(key, ListTag.class, type);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.34165306742630464,  0.34165306742630464,  0.34165306742630464,  0.34165306742630464,28.0,0.5283018867924528,28.0,0.5283018867924528,28.0,0.5283018867924528,28.0,0.5283018867924528,0.0,0.0,0.0,0.0,0.0,0.0,8.0,0.5333333333333333,5.0,0.35714285714285715,6.0,0.42857142857142855
303,cdk,"public int[] findHeavyAtomsInChain(IAtomContainer molecule, IAtomContainer chain){
    int[] heavy = { -1, -1 };
    int hc = 0;
    for (int i = 0; i < chain.getAtomCount(); i++) {
        if (isHeavyAtom(chain.getAtom(i))) {
            if (heavy[0] < 0) {
                heavy[0] = molecule.indexOf(chain.getAtom(i));
            }
            hc++;
        }
    }
    heavy[1] = hc;
    return heavy;
}",findHeavyAtomsInChain,org/openscience/cdk/modeling/builder3d/AtomPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomPlacer3D.java,"/**
     *  Count and find first heavy atom(s) (non Hydrogens) in a chain.
     *
     * @param  molecule the reference molecule for searching the chain
     * @param  chain  chain to be searched
     * @return        the atom number of the first heavy atom the number of heavy atoms in the chain
     */",81-101,"('findHeavyAtomsInChain', {'INSTRUCTION': {'covered': 46, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",107.0,17.0,Count and find first heavy atom(s) (non Hydrogens) in a chain.,"The function can count and found the first heavy atom in the chain, ignoring Hydrogens.",Find the first heavy atom in a chain.,0.380739529018082,Count and find the first heavy atom(s) (non-hydrogen) in a chain.,"public int[] findHeavyAtomsInChain(IAtomContainer molecule, IAtomContainer chain){
        int[] firstAtoms = new int[chain.getAtomCount()];
        int counter = 0;
        for (int i = 0; i < chain.getAtomCount(); i++) {
            IAtom atom = chain.getAtom(i);
            if (!atom.getSymbol().equals(""H"")) {
                firstAtoms[counter] = i;
                counter++;
            }
        }
        int[] firstAtoms2 = new int[counter];
        System.arraycopy(firstAtoms, 0, firstAtoms2, 0, counter);
        return firstAtoms2;     
 }","public int[] findHeavyAtomsInChain(IAtomContainer molecule, IAtomContainer chain){
        int[] firstAtoms = new int[chain.getAtomCount()];
        int counter = 0;
        for (int i = 0; i < chain.getAtomCount(); i++) {
            if (chain.getAtom(i).getSymbol().equals(""H"")) {
                continue;
            }
            firstAtoms[counter] = i;
            counter++;
        }
        return firstAtoms;      
 }","public int[] findHeavyAtomsInChain(IAtomContainer molecule, IAtomContainer chain){
        int[] heavyAtoms = new int[chain.getAtomCount()];
        int counter = 0;
        for (int i = 0; i < chain.getAtomCount(); i++) {
            if (!chain.getAtom(i).getSymbol().equals(""H"")) {
                heavyAtoms[counter] = i;
                counter++;
            }
        }
        int[] result = new int[counter];
        System.arraycopy(heavyAtoms, 0, result, 0, counter);
        return result;      
 }","public int[] findHeavyAtomsInChain(IAtomContainer molecule, IAtomContainer chain){
        int[] firstAtoms = new int[chain.getAtomCount()];
        int count = 0;
        for (int i = 0; i < chain.getAtomCount(); i++) {
            if (!chain.getAtom(i).getSymbol().equals(""H"")) {
                firstAtoms[count] = i;
                count++;
            }
        }
        int[] firstAtoms2 = new int[count];
        System.arraycopy(firstAtoms, 0, firstAtoms2, 0, count);
        return firstAtoms2;     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4690695618170161,  0.4491455596002317,  0.48095945131415674,  0.48095945131415674,62.0,0.5166666666666667,49.0,0.4537037037037037,57.0,0.4956521739130435,57.0,0.4956521739130435,39.0,0.325,13.0,0.10833333333333334,14.0,0.11666666666666667,12.0,0.75,3.0,0.25,6.0,0.5
304,matsim-libs,"private void consolidateData(final TravelTimeData data){
    synchronized (data) {
        if (data.isNeedingConsolidation()) {
            // initialize prevTravelTime with ttime from time bin 0 and time 0.  (The interface comment already states that
            // having both as argument does not make sense.)
            double prevTravelTime = data.getTravelTime(0, 0.0);
            // changed (1, 0.0) to (0, 0.0) since Michal has convinced me (by a test) that using ""1"" is wrong
            // because you get the wrong result for time slot number 1.  This change does not affect the existing
            // unit tests.  kai, oct'11
            // go from time slot 1 forward in time:
            for (int i = 1; i < this.numSlots; i++) {
                // once more the getter is weird since it needs both the time slot and the time:
                double travelTime = data.getTravelTime(i, i * this.timeSlice);
                // if the travel time in the previous time slice was X, then now it is X-S, where S is the time slice:
                double minTravelTime = prevTravelTime - this.timeSlice;
                // if the travel time that has been measured so far is less than that minimum travel time, then do something:
                if (travelTime < minTravelTime) {
                    // (set the travel time to the smallest possible travel time that makes sense according to the argument above)
                    travelTime = minTravelTime;
                    data.setTravelTime(i, travelTime);
                }
                prevTravelTime = travelTime;
            }
            data.setNeedsConsolidation(false);
        }
    }
}",consolidateData,org/matsim/core/trafficmonitoring/TravelTimeCalculator.java,/matsim/src/main/java/org/matsim/core/trafficmonitoring/TravelTimeCalculator.java,"/**
	 * Makes sure that the travel times ""make sense"".
	 * <p></p>
	 * Imagine short bin sizes (e.g. 5min), small links (e.g. 300 veh/hour)
	 * and small sample sizes (e.g. 2%). This would mean that effectively
	 * in the simulation only 6 vehicles can pass the link in one hour,
	 * one every 10min. So, the travel time in one time slot could be 
	 * >= 10min if two cars enter the link at the same time. If no car
	 * enters in the next time bin, the travel time in that time bin should
	 * still be >=5 minutes (10min - binSize), and not freespeedTraveltime,
	 * because actually every car entering the link in this bin will be behind
	 * the car entered before, which still needs >=5min until it can leave.
	 * <p></p>
	 * This method ensures that the travel time in a time bin
	 * cannot be smaller than the travel time in the bin before minus the
	 * bin size.
	 *
	 */",439-488,"('consolidateData', {'INSTRUCTION': {'covered': 54, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",113.0,11.0,"Makes sure that the travel times ""make sense"".","Checks that the travel times are meaningful. Imagine that the bin size is 5 min, the links is 300 veh/hour and the sample size is 2%. It means that only 6 vehicles can pass the link every hour (one every 10 minutes). This imply that the travel time in a time slot can be >=10 minutes if two cars enter the link at the same time. If we see that no car enters in the next time been, hence the travel time must be >=5 minutes.",It's important that the travel times make sense.,0.638665515646668,"Makes sure travel times ""make sense."""," private void consolidateData(final TravelTimeData data){
	 		if (this.calculateLinkTravelTimes) {
 			this.aggregator.consolidate(data);
 		}
 		if (this.calculateLinkToLinkTravelTimes) {
 			this.aggregator.consolidate(data);
 		}
 	}"," private void consolidateData(final TravelTimeData data){
		if (data.isNeedingConsolidation()){
			data.consolidate();
			data.setNeedsConsolidation(false);
		}
	}"," private void consolidateData(final TravelTimeData data){
	 		if (this.calculateLinkTravelTimes) {
 			this.aggregator.consolidate(data);
 		}
 		if (this.calculateLinkToLinkTravelTimes) {
 			this.aggregator.consolidate(data);
 		}
 	}"," private void consolidateData(final TravelTimeData data){
	 		if (data.isNeedingConsolidation()){
 			this.aggregator.consolidate(data);
 			data.setNeedsConsolidation( false );
 		}
 	}",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.14708058730147225,  0.16473642622477006,  0.18640750203308473,  0.14708058730147225,82.0,0.7192982456140351,81.0,0.7105263157894737,79.0,0.6929824561403509,82.0,0.7192982456140351,21.0,0.4666666666666667,17.0,0.37777777777777777,0.0,0.0,83.0,0.9540229885057471,3.0,0.3333333333333333,4.0,0.4444444444444444
305,mybatis-3,"public ResolverUtil<T> findImplementations(Class<?> parent, String... packageNames){
    if (packageNames == null) {
        return this;
    }
    Test test = new IsA(parent);
    for (String pkg : packageNames) {
        find(test, pkg);
    }
    return this;
}",findImplementations,org/apache/ibatis/io/ResolverUtil.java,/src/main/java/org/apache/ibatis/io/ResolverUtil.java,"/**
   * Attempts to discover classes that are assignable to the type provided. In the case
   * that an interface is provided this method will collect implementations. In the case
   * of a non-interface class, subclasses will be collected.  Accumulated classes can be
   * accessed by calling {@link #getClasses()}.
   *
   * @param parent
   *          the class of interface to find subclasses or implementations of
   * @param packageNames
   *          one or more package names to scan (including subpackages) for classes
   * @return the resolver util
   */",185-208,"('findImplementations', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",58.0,12.0,Attempts to discover classes that are assignable to the type provided.,"Given the provided type, it tries to find classes that are assignable. The method will collect implementations if we provide an interface and subclasses if we provide a non-interface class. You can acces to the found classes by calling getClasses()",Attempts to find classes that are assignable.,0.338556048005858,Attempts to discover which classes can be assigned to the type provided.," public ResolverUtil<T> findImplementations(Class<?> parent, String... packageNames){
    for (String packageName : packageNames) {
      find(new IsA(parent), packageName);
    }
    return this;    
 }"," public ResolverUtil<T> findImplementations(Class<?> parent, String... packageNames){
    for (String packageName : packageNames) {
      find(new IsA(parent), packageName);
    }
    return this;    
 }"," public ResolverUtil<T> findImplementations(Class<?> parent, String... packageNames){
    for (String packageName : packageNames) {
      findImplementation(parent, packageName);
    }
    return this;
  }"," public ResolverUtil<T> findImplementations(Class<?> parent, String... packageNames){
    for (String packageName : packageNames) {
      findImplementations(parent, packageName);
    }
    return this;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.523776594078562,  0.523776594078562,  0.5250854866957417,  0.502358213968469,25.0,0.423728813559322,25.0,0.423728813559322,24.0,0.4067796610169492,24.0,0.4067796610169492,0.0,0.0,5.0,0.11627906976744186,5.0,0.11627906976744186,34.0,0.8292682926829268,4.0,0.3076923076923077,6.0,0.5
306,cdk,"public boolean mapTemplates(IAtomContainer molecule) throws CDKException{
    for (Pattern anonPattern : elemPatterns) {
        for (Map<IAtom, IAtom> atoms : anonPattern.matchAll(molecule).toAtomMap()) {
            for (Map.Entry<IAtom, IAtom> e : atoms.entrySet()) {
                e.getValue().setPoint2d(new Point2d(e.getKey().getPoint2d()));
                e.getValue().setFlag(CDKConstants.ISPLACED, true);
            }
            if (!atoms.isEmpty())
                return true;
        }
    }
    for (Pattern anonPattern : anonPatterns) {
        for (Map<IAtom, IAtom> atoms : anonPattern.matchAll(molecule).toAtomMap()) {
            for (Map.Entry<IAtom, IAtom> e : atoms.entrySet()) {
                e.getValue().setPoint2d(new Point2d(e.getKey().getPoint2d()));
                e.getValue().setFlag(CDKConstants.ISPLACED, true);
            }
            if (!atoms.isEmpty())
                return true;
        }
    }
    return false;
}",mapTemplates,org/openscience/cdk/layout/TemplateHandler.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/TemplateHandler.java,"/**
     * Checks if one of the loaded templates is a substructure in the given
     * Molecule. If so, it assigns the coordinates from the template to the
     * respective atoms in the Molecule, and marks the atoms as ISPLACED.
     *
     * @param molecule The molecule to be check for potential templates
     * @return True if there was a possible mapping
     */",209-241,"('mapTemplates', {'INSTRUCTION': {'covered': 120, 'missed': 2}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 19, 'missed': 2}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",218.0,15.0,Checks if one of the loaded templates is a substructure in the given  Molecule.,"Given a molecule, verifies if one of the templates that have been loaded is a substructure. It this happens, the function assigns the coordintes from the template to the involved atoms, marking them as ISPLACED.","If one of the loaded templates is a substructure, the check is done.",0.234761477131769,Checks whether any of the charged models is a substructure in the given molecule.,"public boolean mapTemplates(IAtomContainer molecule) throws CDKException{
        for (IAtomContainer template : templates) {
            Mappings mappings = VentoFoggia.findSubstructure(template, anonAtomMatcher, anonBondMatcher)
                                            .matchAll(molecule);
            for (Map<IAtom, IAtom> atoms : mappings.toAtomMap()) {
                for (Map.Entry<IAtom, IAtom> e : atoms.entrySet()) {
                    e.getValue().setPoint2d(new Point2d(e.getKey().getPoint2d()));
                    e.getValue().setFlag(CDKConstants.ISPLACED, true);
                }
                if (!atoms.isEmpty())
                    return true;
            }
        }
        return false;
    }","public boolean mapTemplates(IAtomContainer molecule) throws CDKException{
        for (IAtomContainer template : templates) {
            Mappings mappings = VentoFoggia.findSubstructure(template, anonAtomMatcher, anonBondMatcher)
                                            .matchAll(molecule);
            for (Map<IAtom, IAtom> atoms : mappings.toAtomMap()) {
                for (Map.Entry<IAtom, IAtom> e : atoms.entrySet()) {
                    e.getValue().setPoint2d(new Point2d(e.getKey().getPoint2d()));
                    e.getValue().setFlag(CDKConstants.ISPLACED, true);
                }
                if (!atoms.isEmpty())
                    return true;
            }
        }
        return false;
    }","public boolean mapTemplates(IAtomContainer molecule) throws CDKException{
        for (IAtomContainer template : templates) {
            Mappings mappings = VentoFoggia.findSubstructure(template, anonAtomMatcher, anonBondMatcher)
                                            .matchAll(molecule);
            for (Map<IAtom, IAtom> atoms : mappings.toAtomMap()) {
                for (Map.Entry<IAtom, IAtom> e : atoms.entrySet()) {
                    e.getValue().setPoint2d(new Point2d(e.getKey().getPoint2d()));
                    e.getValue().setFlag(CDKConstants.ISPLACED, true);
                }
                if (!atoms.isEmpty())
                    return true;
            }
        }
        return false;
    }","public boolean mapTemplates(IAtomContainer molecule) throws CDKException{
        for (IAtomContainer template : templates) {
            Mappings mappings = VentoFoggia.findSubstructure(template, anonAtomMatcher, anonBondMatcher)
                                            .matchAll(molecule);
            for (Map<IAtom, IAtom> atoms : mappings.toAtomMap()) {
                for (Map.Entry<IAtom, IAtom> e : atoms.entrySet()) {
                    e.getValue().setPoint2d(new Point2d(e.getKey().getPoint2d()));
                    e.getValue().setFlag(CDKConstants.ISPLACED, true);
                }
                if (!atoms.isEmpty())
                    return true;
            }
        }
        return false;
    }",PASS,PASS,PASS,PASS,  0.5609474261911276,  0.5609474261911276,  0.5609474261911276,  0.5609474261911276,102.0,0.4657534246575342,102.0,0.4657534246575342,102.0,0.4657534246575342,102.0,0.4657534246575342,0.0,0.0,0.0,0.0,0.0,0.0,28.0,0.7777777777777778,5.0,0.3333333333333333,7.0,0.4666666666666667
307,matsim-libs,"private void checkNodeIsMarkedAsCountStation(Node node){
    Link linkToBlock = null;
    if (this.shortNameMap.keySet().contains(node.getId().toString())) {
        // node is marked as count station
        if (node.getInLinks().size() == 1 && node.getOutLinks().size() == 1) {
            // ok, node has one in and one outLink, so put the count station on the shorter one and block it
            // Prefer the inLink, if both have the same length
            for (Link inLink : node.getInLinks().values()) {
                for (Link outLink : node.getOutLinks().values()) {
                    if (inLink.getLength() > outLink.getLength()) {
                        linkToBlock = outLink;
                    } else {
                        linkToBlock = inLink;
                    }
                    break;
                }
                break;
            }
            // check, if count data is present
            Id<Link> shortNameId = Id.create(this.shortNameMap.get(node.getId().toString()), Link.class);
            if (this.outCounts.getCount(shortNameId) == null) {
                // Count station wasn't added to outCounts, yet
                Count<Link> oldCount = this.inCounts.getCount(shortNameId);
                if (oldCount == null) {
                    // count station was mapped, but data can not be provided, do nothing
                    // TODO [AN] Check, if linkToBlock can be removed
                } else {
                    // create new count with correct locId and migrate data
                    if (linkToBlock != null) {
                        this.outCounts.createAndAddCount(linkToBlock.getId(), oldCount.getCsLabel());
                        Count<Link> newCount = this.outCounts.getCount(linkToBlock.getId());
                        newCount.setCoord(oldCount.getCoord());
                        for (Volume volume : oldCount.getVolumes().values()) {
                            newCount.createVolume(volume.getHourOfDayStartingWithOne(), volume.getValue());
                        }
                    }
                }
            } else {
                // count station was already processed and moved to outCounts
            }
        } else {
            log.warn(""Count station "" + this.shortNameMap.get(node.getId().toString()) + "" is registerd to node "" + node.getId().toString() + "" which has "" + node.getInLinks().size() + "" inLinks and "" + node.getOutLinks().size() + "" outLinks. Can only map one to one. Removing count station from counts data."");
        }
    }
    // everything worked fine, check if a link was blocked
    if (linkToBlock != null) {
        this.linksBlockedByFacility.add(linkToBlock.getId().toString());
    }
}",checkNodeIsMarkedAsCountStation,playground/vsp/andreas/osmBB/PTCountsNetworkSimplifier.java,/contribs/vsp/src/main/java/playground/vsp/andreas/osmBB/PTCountsNetworkSimplifier.java,"/**
         * Check whether the node is marked as count station. If that is the case, migrate its count data to outCounts and mark it as non modifiable
         * @param node The node to be checked
         */",354-408,"('checkNodeIsMarkedAsCountStation', {'INSTRUCTION': {'covered': 146, 'missed': 4}, 'BRANCH': {'covered': 15, 'missed': 7}, 'LINE': {'covered': 25, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 7}, 'METHOD': {'covered': 1, 'missed': 0}})",389.0,10.0,Check whether the node is marked as count station.,"If the node is marked as count station, move the count data to outCount and mark the node as non changeable",The count station is marked by the location of the node.,0.477508440086464,Check if the node is marked as a counting station.," private void checkNodeIsMarkedAsCountStation(Node node){
	 	if(node.getAttributes().getAttribute(COUNT_STATION_ATTRIBUTE) != null){
 		this.linksBlockedByFacility.add(node.getId().toString());
 	}
 }"," private void checkNodeIsMarkedAsCountStation(Node node){
	 	if(node.getUserData() != null){
 		if(node.getUserData().equals(CountStation.COUNT_STATION)){
 			this.outCount.addNode(node);
 			node.setUserData(null);
 		}
 	}
 }"," private void checkNodeIsMarkedAsCountStation(Node node){
	 	if(node.getCoord() != null){
 		this.linksBlockedByFacility.add(node.getCoord().toString());
 	}		
 }"," private void checkNodeIsMarkedAsCountStation(Node node){
	 	if(node.getAttributes().getAttribute(COUNT_STATION_ATTRIBUTE) != null){
 		this.linksBlockedByFacility.add(node.getId().toString());
 	}
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.15468382442024842,  0.1341841864948029,  0.15468382442024842,  0.1534370775861897,350.0,0.8974358974358975,346.0,0.8871794871794871,350.0,0.8974358974358975,353.0,0.9051282051282051,26.0,0.4727272727272727,0.0,0.0,7.0,0.1590909090909091,16.0,0.7272727272727273,3.0,0.2727272727272727,10.0,0.8333333333333334
308,cdk,"private static boolean isHueckelValid(IAtomContainer singleRing) throws CDKException{
    int electronCount = 0;
    for (IAtom ringAtom : singleRing.atoms()) {
        if (ringAtom.getHybridization() != CDKConstants.UNSET && (ringAtom.getHybridization() == Hybridization.SP2) || ringAtom.getHybridization() == Hybridization.PLANAR3) {
            // for example, a carbon
            // note: the double bond is in the ring, that has been tested earlier
            // FIXME: this does assume bond orders to be resolved too, when detecting
            // sprouting double bonds
            if (""N.planar3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""N.minus.planar3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""N.amide"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""S.2"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""S.planar3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""C.minus.planar"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""O.planar3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""N.sp2.3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 1;
            } else {
                if (factory == null) {
                    factory = AtomTypeFactory.getInstance(""org/openscience/cdk/dict/data/cdk-atom-types.owl"", ringAtom.getBuilder());
                }
                IAtomType type = factory.getAtomType(ringAtom.getAtomTypeName());
                Object property = type.getProperty(CDKConstants.PI_BOND_COUNT);
                if (property != null && property instanceof Integer) {
                    electronCount += ((Integer) property).intValue();
                }
            }
        } else if (ringAtom.getHybridization() != null && ringAtom.getHybridization() == Hybridization.SP3 && getLonePairCount(ringAtom) > 0) {
            // for example, a nitrogen or oxygen
            electronCount += 2;
        }
    }
    return (electronCount % 4 == 2) && (electronCount > 2);
}",isHueckelValid,org/openscience/cdk/aromaticity/DoubleBondAcceptingAromaticityDetector.java,/legacy/src/main/java/org/openscience/cdk/aromaticity/DoubleBondAcceptingAromaticityDetector.java,"/**
     * Tests if the electron count matches the H&uuml;ckel 4n+2 rule.
     */",124-170,"('isHueckelValid', {'INSTRUCTION': {'covered': 118, 'missed': 15}, 'BRANCH': {'covered': 27, 'missed': 13}, 'LINE': {'covered': 28, 'missed': 5}, 'COMPLEXITY': {'covered': 11, 'missed': 10}, 'METHOD': {'covered': 1, 'missed': 0}})",351.0,15.0,Tests if the electron count matches the H&uuml;ckel 4n+2 rule.,"Using the 4n+2 rule, the function evaluates if the electron count matches the H&uuml",The H&uuml;ckel 4n+2 rule requires tests if the electron count matches it.,0.358461452030907,Tests whether the number of electrons corresponds to the Hückel 4n+2 rule.,"private static boolean isHueckelValid(IAtomContainer singleRing) throws CDKException{
        int electronCount = 0;
        for (IAtom atom : singleRing.atoms()) {
            IAtomType type = getAtomType(atom);
            if (type == null) return false;
            electronCount += type.getTotalBondOrderSum();
        }
        return electronCount == 4 * singleRing.getAtomCount() + 2;      
 }","private static boolean isHueckelValid(IAtomContainer singleRing) throws CDKException{
        int electronCount = 0;
        int doubleBondCount = 0;
        int tripleBondCount = 0;
        int aromaticBondCount = 0;
        int aromaticAtomCount = 0;
        int doubleBondAtomCount = 0;
        int tripleBondAtomCount = 0;
        int aromaticAtomCount = 0;
        int doubleBondAtomCount = 0;
        int tripleBondAtomCount = 0;
        int aromaticAtomCount = 0;
        int doubleBondAtomCount = 0;
        int tripleBondAtomCount = 0;
        int aromaticAtomCount = 0;
        int doubleBondAtomCount = 0;
        int tripleBondAtomCount = 0;
        int aromaticAtomCount = 0;
        int doubleBondAtomCount = 0;
        int tripleBondAtomCount = 0;
        int aromaticAtomCount = 0;
        int doubleBondAtomCount = 0;
        int tripleBondAtomCount = 0;
        int aromaticAtomCount = 0;
        int doubleBondAtomCount = 0;
        int tripleBondAtomCount = 0;
        int aromaticAtomCount = 0;
        int doubleBondAtomCount = 0;
        int tripleBondAtomCount = 0;
        int aromaticAtomCount = 0;
        int doubleBondAtomCount = 0;
        int tripleBondAtomCount = 0;
        int aromaticAtomCount = 0;
        int doubleBondAtomCount = 0;
        int tripleBondAtomCount = 0;
        int aromaticAtomCount = 0;
        int doubleBondAtomCount = 0;
        int tripleBondAtomCount = 0;
        int aromaticAtomCount = 0;
        int doubleBondAtomCount = 0;
        int tripleBondAtomCount = 0;
        int aromaticAtomCount = 0;
        int doubleBondAtomCount = 0;
        int tripleBondAtomCount = 0;
        int aromaticAtomCount = 0;
        int doubleBondAtomCount =       
 }",Not Valid,Not Valid,NOT PASS,Syntax Error,Not Valid,Not Valid,  0.1332188653773429,None,None,None,300.0,0.8522727272727273,None,None,None,None,None,None,None,None,None,None,None,None,10.0,0.6666666666666666,7.0,0.5384615384615384,10.0,0.7692307692307693
309,tablesaw,"public List<LocalTime> top(int n){
    List<LocalTime> top = new ArrayList<>();
    int[] values = data.toIntArray();
    IntArrays.parallelQuickSort(values, IntComparators.OPPOSITE_COMPARATOR);
    for (int i = 0; i < n && i < values.length; i++) {
        top.add(PackedLocalTime.asLocalTime(values[i]));
    }
    return top;
}",top,tech/tablesaw/api/TimeColumn.java,/core/src/main/java/tech/tablesaw/api/TimeColumn.java,"/**
   * Returns the largest (""top"") n values in the column. Does not change the order in this column
   *
   * @param n The maximum number of records to return. The actual number will be smaller if n is
   *     greater than the number of observations in the column
   * @return A list, possibly empty, of the largest observations
   */",495-510,"('top', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,14.0,"Returns the largest (""top"") n values in the column.","Returns a list of the largest n observation in the column, without changing the order of the element in that column.",The largest values are in the column.,0.468040413201937,"Returns the n largest values (""top"") in the column.","public List<LocalTime> top(int n){
    List<LocalTime> top = new ArrayList<LocalTime>();
    for (int i = 0; i < n; i++) {
      top.add(get(i));
    }
    return top;   
 }","public List<LocalTime> top(int n){
    if (n > size()) {
      n = size();
    }
    List<LocalTime> top = new ArrayList<LocalTime>(n);
    for (int i = 0; i < n; i++) {
      top.add(get(i));
    }
    return top;   
 }","public List<LocalTime> top(int n){
    List<LocalTime> top = new ArrayList<LocalTime>();
    for (int i = 0; i < n; i++) {
      top.add(get(i));
    }
    return top;   
 }"," public List<LocalTime> top(int n){
    return top(n, null);    
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4377437384888935,  0.4337082644137913,  0.14541526458076914,  0.4377437384888935,35.0,0.3977272727272727,42.0,0.4772727272727273,70.0,0.7954545454545454,35.0,0.3977272727272727,17.0,0.2328767123287671,38.0,0.6785714285714286,0.0,0.0,15.0,0.6818181818181818,4.0,0.4,5.0,0.5
310,shardingsphere-elasticjob,"public boolean isDisabled(@Param(name = ""jobName"", source = ParamSource.PATH) final String jobName){
    return facadeService.isJobDisabled(jobName);
}",isDisabled,org/apache/shardingsphere/elasticjob/cloud/console/controller/CloudJobController.java,/elasticjob-cloud/elasticjob-cloud-scheduler/src/main/java/org/apache/shardingsphere/elasticjob/cloud/console/controller/CloudJobController.java,"/**
     * Check whether the cloud job is disabled or not.
     *
     * @param jobName job name
     * @return true is disabled, otherwise not
     */",142-151,"('isDisabled', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,10.0,Check whether the cloud job is disabled or not.,"Given a jobName, returns true if the cloud job is disabled and false otherwise.",Check to see if the cloud job is disabled.,0.417081237679259,Check if the cloud task is disabled or not.," public boolean isDisabled(@Param(name = ""jobName"", source = ParamSource.PATH) final String jobName){
        return producerManager.isDisabled(jobName);
    }"," public boolean isDisabled(@Param(name = ""jobName"", source = ParamSource.PATH) final String jobName){
        return producerManager.isDisabled(jobName);
    }"," public boolean isDisabled(@Param(name = ""jobName"", source = ParamSource.PATH) final String jobName){
        return producerManager.isDisabled(jobName);
    }"," public boolean isDisabled(@Param(name = ""jobName"", source = ParamSource.PATH) final String jobName){
        return !producerManager.isEnabled(jobName);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.9272904615774291,  0.9272904615774291,  0.8761788062597855,  0.9272904615774291,2.0,0.0625,2.0,0.0625,3.0,0.09090909090909091,2.0,0.0625,0.0,0.0,2.0,0.06060606060606061,0.0,0.0,9.0,0.6,2.0,0.2,6.0,0.6
311,cdk,"private IAtomContainer connectAtoms(String inputInchi, IAtomContainer inputMolecule, Map<Integer, IAtom> inchiAtomsByPosition) throws CDKException{
    String inchi = inputInchi;
    inchi = inchi.substring(inchi.indexOf('/') + 1);
    inchi = inchi.substring(inchi.indexOf('/') + 1);
    String connections = inchi.substring(1, inchi.indexOf('/'));
    Pattern connectionPattern = Pattern.compile(""(-|\\(|\\)|,|([0-9])*)"");
    Matcher match = connectionPattern.matcher(connections);
    Stack<IAtom> atomStack = new Stack<IAtom>();
    IAtomContainer inchiMolGraph = inputMolecule.getBuilder().newInstance(IAtomContainer.class);
    boolean pop = false;
    boolean push = true;
    while (match.find()) {
        String group = match.group();
        push = true;
        if (!group.isEmpty()) {
            if (group.matches(""[0-9]*"")) {
                IAtom atom = inchiAtomsByPosition.get(Integer.valueOf(group));
                if (!inchiMolGraph.contains(atom))
                    inchiMolGraph.addAtom(atom);
                IAtom prevAtom = null;
                if (atomStack.size() != 0) {
                    if (pop) {
                        prevAtom = atomStack.pop();
                    } else {
                        prevAtom = atomStack.get(atomStack.size() - 1);
                    }
                    IBond bond = inputMolecule.getBuilder().newInstance(IBond.class, prevAtom, atom, IBond.Order.SINGLE);
                    inchiMolGraph.addBond(bond);
                }
                if (push) {
                    atomStack.push(atom);
                }
            } else if (group.equals(""-"")) {
                pop = true;
                push = true;
            } else if (group.equals("","")) {
                atomStack.pop();
                pop = false;
                push = false;
            } else if (group.equals(""("")) {
                pop = false;
                push = true;
            } else if (group.equals("")"")) {
                atomStack.pop();
                pop = true;
                push = true;
            } else {
                throw new CDKException(""Unexpected token "" + group + "" in connection table encountered."");
            }
        }
    }
    for (IAtom at : inchiAtomsByPosition.values()) {
        if (!inchiMolGraph.contains(at))
            inchiMolGraph.addAtom(at);
    }
    return inchiMolGraph;
}",connectAtoms,org/openscience/cdk/tautomers/InChITautomerGenerator.java,/tool/tautomer/src/main/java/org/openscience/cdk/tautomers/InChITautomerGenerator.java,"/**
     * Pops and pushes its ways through the InChI connection table to build up a simple molecule.
     * @param inputInchi user input InChI
     * @param inputMolecule user input molecule
     * @param inchiAtomsByPosition
     * @return molecule with single bonds and no hydrogens.
     */",249-313,"('connectAtoms', {'INSTRUCTION': {'covered': 179, 'missed': 25}, 'BRANCH': {'covered': 22, 'missed': 4}, 'LINE': {'covered': 42, 'missed': 4}, 'COMPLEXITY': {'covered': 10, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",447.0,17.0,Pops and pushes its ways through the InChI connection table to build up a simple molecule.,"In order to build up a simple molecule, using the InChi connection table, the method pops and pushes its ways returning a molecule with only one bond and no hydrogens.",Pops and pushes its way through the InChI connection table to build a molecule.,0.230125983703327,Pops and pushes its way through the InChI connection table to build a simple molecule.," private IAtomContainer connectAtoms(String inputInchi, IAtomContainer inputMolecule, Map<Integer, IAtom> inchiAtomsByPosition) throws CDKException{
        IAtomContainer inchiMolGraph = inputMolecule.getBuilder().newInstance(IAtomContainer.class);
        inchiMolGraph.setID(inputMolecule.getID());
        inchiMolGraph.setAtomCount(inputMolecule.getAtomCount());
        inchiMolGraph.setBondCount(inputMolecule.getBondCount());
        inchiMolGraph.setProperties(inputMolecule.getProperties());
        inchiMolGraph.setFlags(inputMolecule.getFlags());
        inchiMolGraph.setProperty(CDKConstants.TITLE, inputMolecule.getProperty(CDKConstants.TITLE));
        inchiMolGraph.setProperty(CDKConstants.DESCRIPTION, inputMolecule.getProperty(CDKConstants.DESCRIPTION));
        inchiMolGraph.setProperty(CDKConstants.FORMAL_CHARGE, inputMolecule.getProperty(CDKConstants.FORMAL_CHARGE));
        inchiMolGraph.setProperty(CDKConstants.DEFINITION_URL, inputMolecule.getProperty(CDKConstants.DEFINITION_URL));
        inchiMolGraph.setProperty(CDKConstants.PUBLIC_IDENTIFIER, inputMolecule.getProperty(CDKConstants.PUBLIC_IDENTIFIER));
        inchiMolGraph.setProperty(CDKConstants.PRIVATE_IDENTIFIER, inputMolecule.getProperty(CDKConstants.PRIVATE_IDENTIFIER));
        inchiMolGraph.setProperty(CDKConstants.TITLE, inputMolecule.getProperty(CDKConstants.TITLE));
        inchiMolGraph.setProperty(CDKConstants.DESCRIPTION, inputMolecule.getProperty(CDKConstants.DESCRIPTION));
        inchiMolGraph.setProperty(CDKConstants.FORMAL_CHARGE, inputMolecule.getProperty(CDKConstants.FORMAL_CHARGE));
        inchiMolGraph.setProperty(CDKConst      
 }",Not Valid,Not Valid,Not Valid,Syntax Error,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,27.0,0.8709677419354839,2.0,0.11764705882352941,3.0,0.17647058823529413
312,cdk,"public DescriptorValue calculate(IAtomContainer container){
    // don't mod original
    container = clone(container);
    MurckoFragmenter fragmenter = new MurckoFragmenter(true, 3);
    DoubleResult result;
    try {
        fragmenter.generateFragments(container);
        IAtomContainer[] framework = fragmenter.getFrameworksAsContainers();
        IAtomContainer[] ringSystems = fragmenter.getRingSystemsAsContainers();
        if (framework.length == 1) {
            result = new DoubleResult(framework[0].getAtomCount() / (double) container.getAtomCount());
        } else if (framework.length == 0 && ringSystems.length == 1) {
            result = new DoubleResult(ringSystems[0].getAtomCount() / (double) container.getAtomCount());
        } else
            result = new DoubleResult(0.0);
    } catch (CDKException e) {
        result = new DoubleResult(Double.NaN);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), result, getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/FMFDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/FMFDescriptor.java,"/**
     * Calculates the FMF descriptor value for the given {@link IAtomContainer}.
     *
     * @param container An {@link org.openscience.cdk.interfaces.IAtomContainer} for which this descriptor
     *                  should be calculated
     * @return An object of {@link org.openscience.cdk.qsar.DescriptorValue} that contains the
     *         calculated FMF descriptor value as well as specification details
     */",58-89,"('calculate', {'INSTRUCTION': {'covered': 62, 'missed': 20}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 12, 'missed': 3}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",186.0,14.0,Calculates the FMF descriptor value for the given {@link IAtomContainer}.,"GIven a IAtomContainer, returns an objet that contains the FMF value calculated with the specification details.",The given @link IAtomContainer is calculated.,0.999927363451456,Calculates the value of the FMF descriptor for the given {@link IAtomContainer}.," public DescriptorValue calculate(IAtomContainer container){
        if (container == null) return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), ""null"");
        try {
            double fmf = calculateFMF(container);
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(fmf));
        } catch (Exception e) {
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), ""Exception"", e);
        }       
 }"," public DescriptorValue calculate(IAtomContainer container){
        if (container == null) return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), ""Empty container"", Double.NaN);
        try {
            double fmf = calculateFMF(container);
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), container, fmf);
        } catch (Exception e) {
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), ""Error"", Double.NaN);
        }       
 }"," public DescriptorValue calculate(IAtomContainer container){
     
      try {
            double fmf = calculateFMF(container);
            return new DescriptorValue(getSpecification(), getParameterNames(),
                  new DoubleResult(fmf), getDescriptorNames());
      } catch (Exception e) {
            logger.error(""An exception has occurred in FMF descriptor calculation. See the stack trace for more information."", e);
            return new DescriptorValue(getSpecification(), getParameterNames(),
                  new DoubleResult(Double.NaN), getDescriptorNames());
      }         
 }","public DescriptorValue calculate(IAtomContainer container){
     
      if (container == null) return new DescriptorValue(getSpecification(), getParameterNames(),
                 getParameters(), new DoubleResult(Double.NaN), getDescriptorNames());
     
      try {
            MurckoFragmenter fragmenter = new MurckoFragmenter();
            IAtomContainer fragment = fragmenter.getFragment(container);
            int heavyAtoms = fragment.getAtomCount();
            for (int i = 0; i < fragment.getBondCount(); i++) {
                 if (fragment.getBond(i).getOrder() == 1) heavyAtoms--;
            }
            double fmf = (double) heavyAtoms / (double) container.getAtomCount();
            return new DescriptorValue(getSpecification(), getParameterNames(),
                  getParameters(), new DoubleResult(fmf), getDescriptorNames());
      } catch (CDKException e) {
            return new DescriptorValue(getSpecification(), getParameterNames(),
                  getParameters(), new DoubleResult(Double.NaN), getDescriptorNames());
      }         
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.20922770951710043,  0.2360760230864279,  0.4181229858808576,  0.23412454032042726,126.0,0.6737967914438503,127.0,0.679144385026738,129.0,0.6683937823834197,132.0,0.7058823529411765,13.0,0.12871287128712872,101.0,0.5233160621761658,48.0,0.4948453608247423,14.0,0.8235294117647058,4.0,0.3076923076923077,10.0,0.9090909090909091
313,shardingsphere-elasticjob,"public static JobContext from(final CloudJobConfiguration cloudJobConfig, final ExecutionType type){
    int shardingTotalCount = cloudJobConfig.getJobConfig().getShardingTotalCount();
    List<Integer> shardingItems = new ArrayList<>(shardingTotalCount);
    for (int i = 0; i < shardingTotalCount; i++) {
        shardingItems.add(i);
    }
    return new JobContext(cloudJobConfig, shardingItems, type);
}",from,org/apache/shardingsphere/elasticjob/cloud/scheduler/context/JobContext.java,/elasticjob-cloud/elasticjob-cloud-scheduler/src/main/java/org/apache/shardingsphere/elasticjob/cloud/scheduler/context/JobContext.java,"/**
     * Create job running context from job configuration and execution type.
     *
     * @param cloudJobConfig cloud job configuration
     * @param type execution type
     * @return Job running context
     */",41-55,"('from', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",76.0,11.0,Create job running context from job configuration and execution type.,Returns the created Job running context starting from the job configuration and the execution time.,Job configuration and execution type are used to create a job.,0.513835445199866,Create a task execution context from the task configuration and execution type.," public static JobContext from(final CloudJobConfiguration cloudJobConfig, final ExecutionType type){
      return new JobContext(cloudJobConfig, new ArrayList<>(), type); 
 }"," public static JobContext from(final CloudJobConfiguration cloudJobConfig, final ExecutionType type){
      return new JobContext(cloudJobConfig, new ArrayList<>(), type); 
 }"," public static JobContext from(final CloudJobConfiguration cloudJobConfig, final ExecutionType type){
      return new JobContext(cloudJobConfig, new ArrayList<>(), type); 
 }"," public static JobContext from(final CloudJobConfiguration cloudJobConfig, final ExecutionType type){
      return new JobContext(cloudJobConfig, new ArrayList<>(), type); 
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.26608234498655314,  0.26608234498655314,  0.26608234498655314,  0.26608234498655314,50.0,0.6493506493506493,50.0,0.6493506493506493,50.0,0.6493506493506493,50.0,0.6493506493506493,0.0,0.0,0.0,0.0,0.0,0.0,8.0,0.5,5.0,0.38461538461538464,11.0,0.9166666666666666
314,cdk,"private boolean isMajorIsotope(int number, int mass){
    try {
        IIsotope isotope = Isotopes.getInstance().getMajorIsotope(number);
        return isotope != null && isotope.getMassNumber().equals(mass);
    } catch (IOException e) {
        return false;
    }
}",isMajorIsotope,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,"/**
     * Utility to determine if the specified mass is the major isotope for the given atomic number.
     *
     * @param number atomic number
     * @param mass   atomic mass
     * @return the mass is the major mass for the atomic number
     */",571-585,"('isMajorIsotope', {'INSTRUCTION': {'covered': 15, 'missed': 4}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 2, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,17.0,Utility to determine if the specified mass is the major isotope for the given atomic number.,"Given an atomic number, the utility can determine if a specific mass is the major isotope for that atomic number.",The mass is the major isotope for the number.,0.204602834727738,Utility for determining whether the specified mass is the primary isotope for the given atomic number.,"private boolean isMajorIsotope(int number, int mass){
        return (mass == number || mass == number + 1);
    }","private boolean isMajorIsotope(int number, int mass){
        if(number == 1){
            return mass == 1;
        }else if(number == 2){
            return mass == 2;
        }else if(number == 3){
            return mass == 3;
        }else if(number == 4){
            return mass == 4;
        }else if(number == 5){
            return mass == 5;
        }else if(number == 6){
            return mass == 6;
        }else if(number == 7){
            return mass == 7;
        }else if(number == 8){
            return mass == 8;
        }else if(number == 9){
            return mass == 9;
        }else if(number == 10){
            return mass == 10;
        }else if(number == 11){
            return mass == 11;
        }else if(number == 12){
            return mass == 12;
        }else if(number == 13){
            return mass == 13;
        }else if(number == 14){
            return mass == 14;
        }else if(number == 15){
            return mass == 15;
        }else if(number == 16){
            return mass == 16;
        }else if(number == 17){
            return mass == 17;
        }else if(number == 18){
            return mass == 18;
        }else if(number == 19){
            return mass == 19;
        }else if(number == 20){
            return mass == 20;
        }else if(number == 21){
            return mass == 21;
        }else if(number == 22){
            return mass == 22;
        }else if(number == 23){
            return mass == 23;
        }else if(number == 24){
            return mass == 24;
        }else if(number == 25){
            return mass == 25;
        }else if(number == 26){
            return mass == 26;
        }else if(number == 27){
            return mass == 27;
        }else if(number == 28){
            return mass == 28;
        }else if(number == 29){
            return mass == 29;
        }else if(number == 30       
 }"," private boolean isMajorIsotope(int number, int mass){
        return number == mass;      
 }","private boolean isMajorIsotope(int number, int mass){
        return number == 1 && mass == 1 || number == 2 && mass == 4 || number == 3 && mass == 6 || number == 4 && mass == 9 || number == 5 && mass == 10 || number == 6 && mass == 12 || number == 7 && mass == 14 || number == 8 && mass == 16 || number == 9 && mass == 19 || number == 10 && mass == 20 || number == 11 && mass == 22 || number == 12 && mass == 24 || number == 13 && mass == 27 || number == 14 && mass == 28 || number == 15 && mass == 30 || number == 16 && mass == 32 || number == 17 && mass == 35 || number == 18 && mass == 36 || number == 19 && mass == 39 || number == 20 && mass == 40 || number == 21 && mass == 42 || number == 22 && mass == 45 || number == 23 && mass == 48 || number == 24 && mass == 50 || number == 25 && mass == 52 || number == 26 && mass == 55 || number == 27 && mass == 58 || number == 28 && mass == 60 || number == 29 && mass == 64 || number == 30 && mass == 65 || number == 31 && mass == 69 || number == 32 && mass == 72 || number == 33 && mass == 74 || number == 34 && mass == 77 || number == 35 && mass == 79 || number == 36 && mass == 82 || number == 37 && mass == 85 || number == 38 && mass == 87 || number == 39 && mass == 91 || number == 40 && mass == 92 || number == 41 && mass == 95 || number == 42 && mass == 98 || number == 43 && mass == 101 || number == 44 && mass == 103 || number == 45 && mass == 106 || number == 46 && mass == 108 || number == 47 && mass == 112 || number == 48 && mass == 114 || number == 49 && mass == 117 || number == 50 && mass == 120 || number == 51 && mass == 122 || number == 52 && mass == 126 || number == 53 && mass == 128 || number == 54 && mass == 131 || number == 55 && mass == 133 || number == 56 && mass == 137 || number == 57 && mass == 138 || number == 58 && mass == 140 || number == 59 && mass == 144 || number == 60 && mass == 147 || number == 61 && mass == 150 || number == 62 && mass == 152 || number        
 }",NOT PASS,Syntax Error,Syntax Error,NOT PASS,  0.2730304006299543,None,None,  0.24866106023138904,38.0,0.6785714285714286,None,None,495.0,0.9686888454011742,40.0,0.7142857142857143,None,None,490.0,0.958904109589041,9.0,0.34615384615384615,11.0,0.5238095238095238,4.0,0.23529411764705882,8.0,0.47058823529411764
315,acs-aem-commons,"public Map<String, String> generateChecksums(Session session, String path) throws RepositoryException, IOException{
    return generateChecksums(session, path, new DefaultChecksumGeneratorOptions());
}",generateChecksums,com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,"/**
     * Convenience method for  generateChecksums(session, path, new DefaultChecksumGeneratorOptions()).
     *
     * @param session the session
     * @param path tthe root path to generate checksums for
     * @return the map of abs path ~&gt; checksums
     * @throws RepositoryException
     * @throws IOException
     */",65-77,"('generateChecksums', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,15.0,"Convenience method for generateChecksums(session, path, new DefaultChecksumGeneratorOptions()).","Given a session and the root path, it generates the checksums.",The convenience method for generating checks is DefaultChecksumGeneratorOptions.,0.373452842913686,"Convenience method for generateChecksums(session, path, new DefaultChecksumGeneratorOptions())."," public Map<String, String> generateChecksums(Session session, String path) throws RepositoryException, IOException{
        return generateChecksums(session, path, new DefaultChecksumGeneratorOptions());     
 }"," public Map<String, String> generateChecksums(Session session, String path) throws RepositoryException, IOException{
        return generateChecksums(session, path, new DefaultChecksumGeneratorOptions());     
 }"," public Map<String, String> generateChecksums(Session session, String path) throws RepositoryException, IOException{
        return generateChecksums(session, path, new DefaultChecksumGeneratorOptions());     
 }"," public Map<String, String> generateChecksums(Session session, String path) throws RepositoryException, IOException{
        return generateChecksums(session, path, new DefaultChecksumGeneratorOptions());     
 }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10.0,0.8333333333333334,0.0,0.0,6.0,0.6666666666666666
316,cdk,"long next(long seed){
    seed = seed ^ seed << 21;
    seed = seed ^ seed >>> 35;
    return seed ^ seed << 4;
}",next,org/openscience/cdk/hash/Xorshift.java,/tool/hash/src/main/java/org/openscience/cdk/hash/Xorshift.java,"/**
     * Generate the next pseudorandom number for the provided <i>seed</i>.
     *
     * @param seed random number seed
     * @return the next pseudorandom number
     */",39-50,"('next', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,16.0,Generate the next pseudorandom number for the provided <i>seed</i>.,"Given a seed, it returns the next pseudorandom number.",The next pseudorandom number is provided.,0.653185444013288,Generate the following pseudo-random number for the <i>seed</i> provided.,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,9.0,0.9,4.0,0.4,6.0,0.6
318,openapi-generator,"public String toVarName(final String name){
    if (reservedWords.contains(name)) {
        return escapeReservedWord(name);
    } else if (name.chars().anyMatch(character -> specialCharReplacements.containsKey(String.valueOf((char) character)))) {
        return escape(name, specialCharReplacements, null, null);
    }
    return name;
}",toVarName,org/openapitools/codegen/DefaultCodegen.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java,"/**
     * Return the variable name by removing invalid characters and proper escaping if
     * it's a reserved word.
     *
     * @param name the variable name
     * @return the sanitized variable name
     */",1451-1465,"('toVarName', {'INSTRUCTION': {'covered': 20, 'missed': 4}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",73.0,18.0,Return the variable name by removing invalid characters and proper escaping if  it's a reserved word.,"Given a variable name, the function sanitized id by removing invalid characters and escaping reserved words.",Remove invalid characters and proper escaping if the variable name is a reserved word.,0.312029275883449,Return the variable name by removing invalid characters and the appropriate escape if it is a reserved word.," public String toVarName(final String name){
        return underscore(name);
    }"," public String toVarName(final String name){
        return sanitizeName(name);
    }"," public String toVarName(final String name){
        return sanitizeName(name, """", false);
    }"," public String toVarName(final String name){
        return toVarName(name, true);       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.183267046564415,  0.183267046564415,  0.19601651742658238,  0.1490598261466377,58.0,0.7837837837837838,58.0,0.7837837837837838,57.0,0.7702702702702703,56.0,0.7567567567567568,1.0,0.058823529411764705,3.0,0.15789473684210525,5.0,0.23809523809523808,12.0,0.7058823529411765,5.0,0.2631578947368421,10.0,0.5882352941176471
319,cdk,"private Result compareRowwise(Permutation perm){
    int m = perm.size();
    for (int i = 0; i < m - 1; i++) {
        for (int j = i + 1; j < m; j++) {
            int x = getConnectivity(best.get(i), best.get(j));
            int y = getConnectivity(perm.get(i), perm.get(j));
            if (x > y)
                return Result.WORSE;
            if (x < y)
                return Result.BETTER;
        }
    }
    return Result.EQUAL;
}",compareRowwise,org/openscience/cdk/group/AbstractDiscretePartitionRefiner.java,/tool/group/src/main/java/org/openscience/cdk/group/AbstractDiscretePartitionRefiner.java,"/**
     * Check a permutation to see if it is better, equal, or worse than the
     * current best.
     *
     * @param perm the permutation to check
     * @return BETTER, EQUAL, or WORSE
     */",335-353,"('compareRowwise', {'INSTRUCTION': {'covered': 49, 'missed': 4}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",121.0,19.0,"Check a permutation to see if it is better, equal, or worse than the  current best.","Given the current best permutation, checks whether the new found permutation is worse, better, or equal than the best one.","To see if it is better, equal, or worse than the current best, check a permutation.",0.527037406011076,"Check a permutation to see if it is better, equal, or worse than the current best.","private Result compareRowwise(Permutation perm){
        int vertexCount = getVertexCount();
        int[] permF = new int[vertexCount];
        int[] invF = new int[vertexCount];
        for (int i = 0; i < vertexCount; i++) {
            permF[i] = i;
            invF[i] = i;
        }
        for (int j = 0; j < vertexCount; j++) {
            int x = perm.get(j);
            int i = invF[x];
            int h = permF[j];
            permF[j] = x;
            permF[i] = h;
            invF[h] = i;
            invF[x] = j;
        }
        Permutation pPermF = new Permutation(permF);
        Permutation g = group.get(first.invert(), pPermF);
        if (g == null) {
            return Result.BETTER;
        } else if (g.isIdentity()) {
            return Result.EQUAL;
        } else {
            return Result.WORSE;
        }
    }","private Result compareRowwise(Permutation perm){
        int vertexCount = getVertexCount();
        String halfMatrixString = getHalfMatrixString(perm);
        String bestHalfMatrixString = getHalfMatrixString();
        if (halfMatrixString.compareTo(bestHalfMatrixString) < 0) {
            return Result.BETTER;
        } else if (halfMatrixString.compareTo(bestHalfMatrixString) == 0) {
            return Result.EQUAL;
        } else {
            return Result.WORSE;
        }
    }","private Result compareRowwise(Permutation perm){
        String halfMatrixString = getHalfMatrixString(perm);
        if (halfMatrixString.compareTo(bestHalfMatrixString) > 0) {
            return Result.BETTER;
        } else if (halfMatrixString.compareTo(bestHalfMatrixString) == 0) {
            return Result.EQUAL;
        } else {
            return Result.WORSE;
        }
    }","private Result compareRowwise(Permutation perm){
        int vertexCount = getVertexCount();
        String halfMatrixString = getHalfMatrixString(perm);
        String firstHalfMatrixString = getFirstHalfMatrixString();
        if (halfMatrixString.compareTo(firstHalfMatrixString) > 0) {
            return Result.BETTER;
        } else if (halfMatrixString.compareTo(firstHalfMatrixString) == 0) {
            return Result.EQUAL;
        } else {
            return Result.WORSE;
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4627980352579171,  0.2587182878527966,  0.27746828785279665,  0.21462985592660802,130.0,0.6467661691542289,84.0,0.6885245901639344,84.0,0.6885245901639344,89.0,0.7295081967213115,144.0,0.7164179104477612,144.0,0.7164179104477612,155.0,0.7711442786069652,16.0,0.7619047619047619,0.0,0.0,8.0,0.47058823529411764
320,anserini,"public String documentContents(int ldocid){
    try {
        return reader.document(ldocid).get(IndexArgs.CONTENTS);
    } catch (Exception e) {
        return null;
    }
}",documentContents,io/anserini/search/SimpleImpactSearcher.java,/src/main/java/io/anserini/search/SimpleImpactSearcher.java,"/**
     * Returns the ""contents"" field of a document based on an internal Lucene docid.
     * The method is named to be consistent with Lucene's {@link IndexReader#document(int)}, contra Java's standard
     * method naming conventions.
     *
     * @param ldocid internal Lucene docid
     * @return the ""contents"" field the document
     */",317-332,"('documentContents', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,16.0,"Returns the ""contents"" field of a document based on an internal Lucene docid.","Starting from a Lucene internal documentation id, returns the ""contents"" field.","The ""contents"" field is based on an internal docid.",1.68958674371626,"Returns the ""contents"" field of a document based on an internal Lucene docid."," public String documentContents(int ldocid){
    Document doc = document(ldocid);
    if (doc == null) {
      return null;
    }
    return doc.getField(IndexArgs.CONTENTS).stringValue();
  }"," public String documentContents(int ldocid){
    Document doc = document(ldocid);
    if (doc == null) {
      return null;
    }
    return doc.getField(IndexArgs.CONTENTS).stringValue();
  }"," public String documentContents(int ldocid){
    try {
      return reader.document(ldocid).getField(IndexArgs.CONTENTS).stringValue();
    } catch (Exception e) {
      // Eat any exceptions and just return null.
      return null;
    }
  }"," public String documentContents(int ldocid){
    try {
      Document doc = reader.document(ldocid);
      IndexableField field = doc.getField(IndexArgs.CONTENTS);
      return field == null ? null : field.stringValue();
    } catch (Exception e) {
      // Eat any exceptions and just return null.
      return null;
    }
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6264416563264456,  0.6264416563264456,  0.7723083074360206,  0.8732813935259967,25.0,0.5813953488372093,25.0,0.5813953488372093,22.0,0.3793103448275862,5.0,0.11904761904761904,0.0,0.0,32.0,0.5517241379310345,26.0,0.6046511627906976,13.0,0.9285714285714286,0.0,0.0,6.0,0.42857142857142855
321,shardingsphere-elasticjob,"public Collection<Map<String, String>> sandbox(@Param(name = ""appName"", source = ParamSource.QUERY) final String appName) throws JsonParseException{
    Preconditions.checkArgument(!Strings.isNullOrEmpty(appName), ""Lack param 'appName'"");
    return mesosStateService.sandbox(appName);
}",sandbox,org/apache/shardingsphere/elasticjob/cloud/console/controller/CloudOperationController.java,/elasticjob-cloud/elasticjob-cloud-scheduler/src/main/java/org/apache/shardingsphere/elasticjob/cloud/console/controller/CloudOperationController.java,"/**
     * Get sandbox of the cloud job by app name.
     *
     * @param appName application name
     * @return sandbox info
     * @throws JsonParseException parse json exception
     */",94-105,"('sandbox', {'INSTRUCTION': {'covered': 11, 'missed': 1}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",56.0,10.0,Get sandbox of the cloud job by app name.,"Starting from the app name, the function provides a sandbox for the cloud job",The cloud job can be accessed by app name.,0.125551702804531,Get the sandbox of the cloud job by application name.,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,13.0,0.8666666666666667,2.0,0.18181818181818182,6.0,0.6
322,jeromq,"public ZMsg wrap(ZFrame frame){
    if (frame != null) {
        push(new ZFrame(""""));
        push(frame);
    }
    return this;
}",wrap,org/zeromq/ZMsg.java,/src/main/java/org/zeromq/ZMsg.java,"/**
     * Push frame plus empty frame to front of message, before 1st frame.
     * Message takes ownership of frame, will destroy it when message is sent.
     * @param frame
     */",115-127,"('wrap', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,14.0,"Push frame plus empty frame to front of message, before 1st frame.",Push before the first frame in from of the message the current frame followed by an empty frame. The message will destroy the frame after the sending.,The empty frame should be placed in front of the message before the first frame.,1.12701376195257,"Push the frame plus the blank frame towards the front of the message, before the 1st image."," public ZMsg wrap(ZFrame frame){
        frames.addFirst(frame);
        frames.addFirst(new ZFrame());
        return this;        
 }"," public ZMsg wrap(ZFrame frame){
        if (frame == null) {
            throw new IllegalArgumentException(""frame cannot be null"");
        }
        frames.addFirst(frame);
        frames.addFirst(new ZFrame());
        return this;
    }"," public ZMsg wrap(ZFrame frame){
        frames.addFirst(frame);
        return this;
    }"," public ZMsg wrap(ZFrame frame){
        frames.addFirst(frame);
        frames.addFirst(new ZFrame());
        return this;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5182445002743682,  0.6510266087174315,  0.5182445002743682,  0.3532646314201636,15.0,0.42857142857142855,20.0,0.4444444444444444,15.0,0.42857142857142855,18.0,0.5142857142857142,15.0,0.3333333333333333,0.0,0.0,10.0,0.3333333333333333,23.0,0.8214285714285714,8.0,0.4444444444444444,10.0,0.625
323,egeria,"public Optional<EntityDetail> findPortAliasEntity(String userId, String qualifiedName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, PORT_ALIAS_TYPE_NAME);
}",findPortAliasEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,"/**
     * Find out if the PortAlias object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",349-365,"('findPortAliasEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,13.0,Find out if the PortAlias object is already stored in the repository.,"Discover whether the PortAlias object is already present in the repository, using the fully qualified name for retrieving the entity.","If the PortAlias object is already in the repository, you should find it.",0.207766070085106,Check if the PortAlias object is already stored in the repository.," public Optional<EntityDetail> findPortAliasEntity(String userId, String qualifiedName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        return dataEngineCommonHandler.findEntity(userId, qualifiedName, PORT_ALIAS_TYPE_NAME);
    }"," public Optional<EntityDetail> findPortAliasEntity(String userId, String qualifiedName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        return dataEngineCommonHandler.findEntity(userId, qualifiedName, PORT_ALIAS_TYPE_NAME);
    }"," public Optional<EntityDetail> findPortAliasEntity(String userId, String qualifiedName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        return dataEngineCommonHandler.findEntity(userId, qualifiedName, PORT_ALIAS_TYPE_NAME);
    }"," public Optional<EntityDetail> findPortAliasEntity(String userId, String qualifiedName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        return dataEngineCommonHandler.findEntity(userId, qualifiedName, PORT_ALIAS_TYPE_NAME);
    }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,14.0,0.6666666666666666,2.0,0.15384615384615385,9.0,0.6428571428571429
324,cdk,"public static boolean has3DCoordinates(IAtomContainer container){
    if (container == null || container.getAtomCount() == 0)
        return Boolean.FALSE;
    for (IAtom atom : container.atoms()) {
        if (atom == null || atom.getPoint3d() == null)
            return Boolean.FALSE;
    }
    return Boolean.TRUE;
}",has3DCoordinates,org/openscience/cdk/geometry/GeometryTools.java,/legacy/src/main/java/org/openscience/cdk/geometry/GeometryTools.java,"/**
     * Determines if all this {@link IAtomContainer}'s atoms contain 3D coordinates. If any atom
     * is null or has unset 3D coordinates this method will return false. If the provided
     * container is null false is returned.
     *
     * @param container the atom container to examine
     *
     * @return indication that all 3D coordinates are available
     *
     * @see org.openscience.cdk.interfaces.IAtom#getPoint3d()
     */",1080-1103,"('has3DCoordinates', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,15.0,Determines if all this {@link IAtomContainer}'s atoms contain 3D coordinates.,Checks whether the IAtomContainer's atoms have 3D coordinates. Returns false if any atom is null or does not have 3D coordinates.,If all this is IAtomContainer's atoms have 3D coordinates.,0.354613282855063,Determines whether all of these {@link atoms of IAtomContainer} contain 3D coordinates.,"public static boolean has3DCoordinates(IAtomContainer container){
        if (container == null || container.getAtomCount() == 0) return Boolean.FALSE;
    
        for (IAtom atom : container.atoms()) {
    
            if (atom == null || atom.getPoint3d() == null) return Boolean.FALSE;
    
        }
    
        return Boolean.TRUE;        
 }","public static boolean has3DCoordinates(IAtomContainer container){
        if (container == null || container.getAtomCount() == 0) return false;
        for (IAtom atom : container.atoms()) {
            if (atom == null || atom.getPoint3d() == null) return false;
        }
        return true;        
 }","public static boolean has3DCoordinates(IAtomContainer container){
        if (container == null || container.getAtomCount() == 0) return Boolean.FALSE;
    
        for (IAtom atom : container.atoms()) {
    
            if (atom == null || atom.getPoint3d() == null) return Boolean.FALSE;
    
        }
    
        return Boolean.TRUE;        
 }","public static boolean has3DCoordinates(IAtomContainer container){
        if (container == null || container.getAtomCount() == 0) return Boolean.FALSE;
    
        for (IAtom atom : container.atoms()) {
    
            if (atom == null || atom.getPoint3d() == null) return Boolean.FALSE;
    
        }
    
        return Boolean.TRUE;        
 }",PASS,PASS,PASS,PASS,  1.0,  0.679543878616993,  1.0,  1.0,0.0,0.0,9.0,0.13432835820895522,0.0,0.0,0.0,0.0,9.0,0.13432835820895522,0.0,0.0,0.0,0.0,18.0,0.8181818181818182,6.0,0.46153846153846156,5.0,0.45454545454545453
325,jackson-databind,"public static String backticked(String text){
    if (text == null) {
        return ""[null]"";
    }
    return new StringBuilder(text.length() + 2).append('`').append(text).append('`').toString();
}",backticked,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * Returns either {@code `text`} (backtick-quoted) or {@code [null]}.
     *
     * @since 2.9
     */",793-803,"('backticked', {'INSTRUCTION': {'covered': 17, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,21.0,Returns either {@code `text`} (backtick-quoted) or {@code [null]}.,"Returns the fields 'text', blacktick-quoted or null.",Either @code text or @code [null] returns.,0.869858260293606,Returns {@code 'text'} (quotation marks back) or {@code [null]}.," public static String backticked(String text){
        if (text == null) {
            return ""[null]"";
        }
        return String.format(""`%s`"", text);     
 }"," public static String backticked(String text){
        if (text == null) {
            return ""[null]"";
        }
        return String.format(""`%s`"", text);     
 }"," public static String backticked(String text){
        if (text == null) {
            return ""[null]"";
        }
        return '`' + text + '`';        
 }"," public static String backticked(String text){
        if (text == null) {
            return ""[null]"";
        }
        return String.format(""`%s`"", text);     
 }",NOT PASS,PASS,PASS,PASS,  0.41014903163741867,  0.41014903163741867,  0.41014903163741867,  0.39673448301199415,26.0,0.48148148148148145,26.0,0.48148148148148145,26.0,0.48148148148148145,27.0,0.5,0.0,0.0,0.0,0.0,8.0,0.25,6.0,0.6666666666666666,5.0,0.5,8.0,0.8888888888888888
326,cdk,"public void build() throws CDKException{
    trainingSize = training.size();
    trainingActives = numActive;
    contribs.clear();
    final int sz = training.size();
    final double invSz = 1.0 / sz;
    final double P_AT = numActive * invSz;
    for (Integer hash : inHash.keySet()) {
        final int[] AT = inHash.get(hash);
        final int A = AT[0], T = AT[1];
        final double Pcorr = (A + 1) / (T * P_AT + 1);
        final double P = Math.log(Pcorr);
        contribs.put(hash, P);
    }
    lowThresh = Double.POSITIVE_INFINITY;
    highThresh = Double.NEGATIVE_INFINITY;
    for (int[] fp : training) {
        double val = 0;
        for (int hash : fp) val += contribs.get(hash);
        lowThresh = Math.min(lowThresh, val);
        highThresh = Math.max(highThresh, val);
    }
    range = highThresh - lowThresh;
    invRange = range > 0 ? 1 / range : 0;
}",build,org/openscience/cdk/fingerprint/model/Bayesian.java,/tool/model/src/main/java/org/openscience/cdk/fingerprint/model/Bayesian.java,"/**
     * Performs that Bayesian model generation, using the {molecule:activity} pairs that have been submitted up to this
     * point. Once this method has finished, the object can be used to generate predictions, validation data or to
     * serialise for later use.
     */",223-263,"('build', {'INSTRUCTION': {'covered': 154, 'missed': 1}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 25, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",217.0,23.0,"Performs that Bayesian model generation, using the {molecule:activity} pairs that have been submitted up to this  point.","Using the molecule:activity pairs submited, it performs the Bayesian model generation. After calling this method, the object is able to generate predictions, validate data, or can be serialized for later execution.",The molecule:activity pairs that have been submitted up to this point are used to perform that model generation.,0.38303532828896,"Perform this Bayesian model generation, using the {molecule:activity} pairs that have been submitted so far."," public void build() throws CDKException{
        // build the model
        buildModel();
    
        // calculate self-validation metrics
        calculateEstimates();
    }","public void build() throws CDKException{
        // build the model
        for (int i = 0; i < training.size(); i++) {
            int[] hashes = training.get(i);
            boolean active = activity.get(i);
            for (int h : hashes) {
                double contrib = contribs.get(h);
                if (contrib == 0) {
                    contrib = 1.0 / (double) numActive;
                    contribs.put(h, contrib);
                } else {
                    contrib = (contrib * (double) numActive + 1.0) / (double) (numActive + 1);
                    contribs.put(h, contrib);
                }
                if (active) contrib = -contrib;
                else contrib = -contrib;
                contribs.put(h, contrib);
            }
        }
    
        // calculate the self-validation metrics
        if (estimates != null) {
            double[] estimates = new double[training.size()];
            for (int i = 0; i < training.size(); i++) {
                int[] hashes = training.get(i);
                double est = 0;
                for (int h : hashes)
                    est += contribs.get(h);
                estimates[i] = est;
            }
            this.estimates = estimates;
        }
    
        // calculate the ROC curve
        if (rocX != null) {
            double[] rocX = new double[training.size()];
            double[] rocY = new double[training.size()];
            for (int i = 0; i < training.size(); i++) {
                int[] hashes = training.get(i);
                double est = 0;
                for (int h : hashes)
                    est += contribs.get(h);
                rocX[i] = est;
                rocY[i] = activity.get(i) ? 1 : 0;
            }
            this.rocX = rocX;
            this.rocY = rocY;
        }
    
        // calculate the ROC AUC        
 }","public void build() throws CDKException{
        // build the model
        if (training.size() == 0) throw new CDKException(""No training data available."");
    
        // build the model
        for (int i = 0; i < training.size(); i++) {
            int[] hashes = training.get(i);
            boolean active = activity.get(i);
            for (int h : hashes) {
                double contrib = contribs.get(h);
                if (contrib == 0) contribs.put(h, 1.0);
                else contribs.put(h, contrib + 1.0);
            }
        }
    
        // calculate the model parameters
        double total = training.size();
        double active = numActive;
        double inactive = total - active;
        double invTotal = 1.0 / total;
        double invActive = 1.0 / active;
        double invInactive = 1.0 / inactive;
    
        // calculate the model thresholds
        double low = 0, high = 0;
        for (int h : contribs.keySet()) {
            double contrib = contribs.get(h);
            if (contrib < low) low = contrib;
            if (contrib > high) high = contrib;
        }
        lowThresh = low * invTotal;
        highThresh = high * invTotal;
        range = high - low;
        invRange = 1.0 / range;
    
        // calculate the model estimates
        estimates = new double[training.size()];
        for (int i = 0; i < training.size(); i++) {
            int[] hashes = training.get(i);
            double est = 0;
            for (int h : hashes) {
                double contrib = contribs.get(h);
                est += contrib * invRange;
            }
            estimates[i] = est;
        }
    
        // calculate the ROC curve
        rocX = new float[training.size()];
        rocY = new float[training.size()];
        for (int i = 0; i < training.size();        
 }"," public void build() throws CDKException{
        // build the model
        buildModel();
    
        // calculate self-validation metrics
        calculateEstimates();
    }",NOT PASS,NOT PASS,NOT PASS,Syntax Error,  0.049054166487554375,  0.2915031707251687,  0.049054166487554375,None,202.0,0.926605504587156,278.0,0.7513513513513513,202.0,0.926605504587156,259.0,0.7337110481586402,354.0,0.9567567567567568,0.0,0.0,337.0,0.9546742209631728,28.0,0.875,6.0,0.3333333333333333,16.0,0.8421052631578947
327,cdk,"TextOutline positionHydrogenLabel(HydrogenPosition position, TextOutline element, TextOutline hydrogen){
    final Rectangle2D elementBounds = element.getBounds();
    final Rectangle2D hydrogenBounds = hydrogen.getBounds();
    switch(position) {
        case Above:
            return hydrogen.translate(0, (elementBounds.getMinY() - padding) - hydrogenBounds.getMaxY());
        case Right:
            return hydrogen.translate((elementBounds.getMaxX() + padding) - hydrogenBounds.getMinX(), 0);
        case Below:
            return hydrogen.translate(0, (elementBounds.getMaxY() + padding) - hydrogenBounds.getMinY());
        case Left:
            return hydrogen.translate((elementBounds.getMinX() - padding) - hydrogenBounds.getMaxX(), 0);
    }
    return hydrogen;
}",positionHydrogenLabel,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,"/**
     * Position the hydrogen label relative to the element label.
     *
     * @param position relative position where the hydrogen is placed
     * @param element  the outline of the element label
     * @param hydrogen the outline of the hydrogen
     * @return positioned hydrogen label
     */",438-460,"('positionHydrogenLabel', {'INSTRUCTION': {'covered': 59, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",151.0,10.0,Position the hydrogen label relative to the element label.,Compute the position of the hydrogen label relatetive the label of the element.,The hydrogen label should be placed relative to the element label.,0.14672351315642,Position the hydrogen label relative to the item label.,"TextOutline positionHydrogenLabel(HydrogenPosition position, TextOutline element, TextOutline hydrogen){
        switch (position) {
            case Left:
                return hydrogen.translate(element.getBounds().getWidth() + padding, 0);
            case Right:
                return hydrogen.translate(-hydrogen.getBounds().getWidth() - padding, 0);
            case Below:
                return hydrogen.translate(0, element.getBounds().getHeight() + padding);
            case Above:
                return hydrogen.translate(0, -hydrogen.getBounds().getHeight() - padding);
            default:
                throw new IllegalArgumentException(""Unknown hydrogen position: "" + position);
        }       
 }",Not Valid,Not Valid,"TextOutline positionHydrogenLabel(HydrogenPosition position, TextOutline element, TextOutline hydrogen){
        switch (position) {
            case Left:
                return hydrogen.translate(element.getBounds().getWidth() + padding, 0);
            case Right:
                return hydrogen.translate(-hydrogen.getBounds().getWidth() - padding, 0);
            case Above:
                return hydrogen.translate(0, element.getBounds().getHeight() + padding);
            case Below:
                return hydrogen.translate(0, -hydrogen.getBounds().getHeight() - padding);
            default:
                throw new IllegalArgumentException(""Unknown hydrogen position: "" + position);
        }       
 }",NOT PASS,Not Valid,NOT PASS,Not Valid,  0.5231575930862616,None,  0.5231575930862616,None,77.0,0.506578947368421,None,None,78.0,0.5131578947368421,None,None,None,None,2.0,0.015873015873015872,None,None,10.0,0.7142857142857143,1.0,0.1,5.0,0.4166666666666667
328,dcache,"void calcHashCode(){
    int code = 0;
    int elementCount = 0;
    for (String element : _elements) {
        int stringHash = 0;
        if (element == null) {
            stringHash = NULL_ELEMENT_HASH;
        } else {
            byte[] bytes = element.getBytes();
            int len = bytes.length > 10 ? 10 : bytes.length;
            for (int i = 0; i < len; i++) {
                stringHash ^= (bytes[i]) << (i * 5 + elementCount) % 24;
            }
        }
        code ^= stringHash;
        elementCount++;
    }
    _myHashCode = code;
    _haveHashCode = true;
}",calcHashCode,org/dcache/services/info/base/StatePath.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StatePath.java,"/**
     * Calculate the hash code and store it for later quick reference.
     */",104-132,"('calcHashCode', {'INSTRUCTION': {'covered': 68, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",121.0,12.0,Calculate the hash code and store it for later quick reference.,"Generate and store the hash code, that can be used for quick reference.",Store the code for later reference.,1.01497881433736,Calculate the hash code and store it for quick reference later.,"void calcHashCode(){
        int hash = 0;
        for (String element : _elements) {
            if (element != null) {
                hash ^= element.hashCode();
            } else {
                hash ^= NULL_ELEMENT_HASH;
            }
        }
        _myHashCode = hash;
        _haveHashCode = true;
    }","void calcHashCode(){
        int hash = 0;
        for (String element : _elements) {
            if (element != null) {
                hash ^= element.hashCode();
            } else {
                hash ^= NULL_ELEMENT_HASH;
            }
        }
        _myHashCode = hash;
        _haveHashCode = true;
    }","void calcHashCode(){
        int hash = NULL_ELEMENT_HASH;
        for (String element : _elements) {
            hash = hash * 31 + (element == null ? 0 : element.hashCode());
        }
        _myHashCode = hash;
        _haveHashCode = true;
    }","void calcHashCode(){
        int hash = NULL_ELEMENT_HASH;
        for (String element : _elements) {
            hash = hash * 31 + (element == null ? 0 : element.hashCode());
        }
        _myHashCode = hash;
        _haveHashCode = true;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2719674719078212,  0.2719674719078212,  0.20640378357343425,  0.20640378357343425,80.0,0.6557377049180327,80.0,0.6557377049180327,85.0,0.6967213114754098,85.0,0.6967213114754098,0.0,0.0,20.0,0.38461538461538464,20.0,0.38461538461538464,9.0,0.6428571428571429,3.0,0.25,6.0,0.5
329,cdk,"public boolean matches(IBond bond){
    bond = BondRef.deref(bond);
    if (bond instanceof PharmacophoreAngleBond) {
        PharmacophoreAngleBond pbond = (PharmacophoreAngleBond) bond;
        double bondLength = round(pbond.getBondLength(), 2);
        return bondLength >= lower && bondLength <= upper;
    } else
        return false;
}",matches,org/openscience/cdk/pharmacophore/PharmacophoreQueryAngleBond.java,/tool/pcore/src/main/java/org/openscience/cdk/pharmacophore/PharmacophoreQueryAngleBond.java,"/**
     * Checks whether the query angle constraint matches a target distance.
     * 
     * This method checks whether a query constraint is satisfied by an observed
     * angle (represented by a {@link org.openscience.cdk.pharmacophore.PharmacophoreAngleBond} in the target molecule.
     * Note that angles are compared upto 2 decimal places.
     *
     * @param bond The angle relationship in a target molecule
     * @return true if the target angle lies within the range of the query constraint
     */",85-104,"('matches', {'INSTRUCTION': {'covered': 29, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,11.0,Checks whether the query angle constraint matches a target distance.,The method returns true if the target angle is within the range of the query angle constraint.,The query angle constraint is checked to see if it matches the target distance.,0.316299927276104,Checks whether the query angle constraint matches a target distance.," public boolean matches(IBond bond){
        if(bond instanceof PharmacophoreQueryAngleBond){
            PharmacophoreQueryAngleBond qbond = (PharmacophoreQueryAngleBond)bond;
            if(qbond.upper == this.upper && qbond.lower == this.lower){
                return true;
            }
        }
        return false;
    }"," public boolean matches(IBond bond){
        if (bond instanceof PharmacophoreQueryAngleBond) {
            PharmacophoreQueryAngleBond queryBond = (PharmacophoreQueryAngleBond)bond;
            double targetAngle = queryBond.getAngle();
            return targetAngle >= lower && targetAngle <= upper;
        }
        return false;
    }","public boolean matches(IBond bond){
        if(!(bond instanceof Bond)) return false;
        if(!(bond.getAtom(0) instanceof PharmacophoreQueryAtom)) return false;
        if(!(bond.getAtom(1) instanceof PharmacophoreQueryAtom)) return false;
        if(!(bond.getAtom(2) instanceof PharmacophoreQueryAtom)) return false;
        PharmacophoreQueryAtom atom1 = (PharmacophoreQueryAtom)bond.getAtom(0);
        PharmacophoreQueryAtom atom2 = (PharmacophoreQueryAtom)bond.getAtom(1);
        PharmacophoreQueryAtom atom3 = (PharmacophoreQueryAtom)bond.getAtom(2);
        double angle = getAngle(atom1, atom2, atom3);
        return (angle >= lower && angle <= upper);
    }","public boolean matches(IBond bond){
        if(!(bond instanceof Bond)) return false;
        if(!(bond.getAtom(0) instanceof PharmacophoreQueryAtom)) return false;
        if(!(bond.getAtom(1) instanceof PharmacophoreQueryAtom)) return false;
        if(!(bond.getAtom(2) instanceof PharmacophoreQueryAtom)) return false;
        PharmacophoreQueryAtom atom1 = (PharmacophoreQueryAtom)bond.getAtom(0);
        PharmacophoreQueryAtom atom2 = (PharmacophoreQueryAtom)bond.getAtom(1);
        PharmacophoreQueryAtom atom3 = (PharmacophoreQueryAtom)bond.getAtom(2);
        double angle = getAngle(atom1, atom2, atom3);
        return (angle >= lower && angle <= upper);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3191087408181569,  0.4092246321921909,  0.3763254105747908,  0.3763254105747908,35.0,0.5645161290322581,24.0,0.3870967741935484,98.0,0.725925925925926,98.0,0.725925925925926,21.0,0.40384615384615385,107.0,0.7925925925925926,107.0,0.7925925925925926,15.0,0.8333333333333334,0.0,0.0,10.0,0.6666666666666666
331,cdk,"private void encodeExpr(int idx, int bprev, StringBuilder sb){
    avisit[idx] = numVisit++;
    sb.append(aexpr[idx]);
    final int d = deg[idx];
    int remain = d;
    for (int j = 0; j < d; j++) {
        int nbr = atomAdj[idx][j];
        int bidx = bondAdj[idx][j];
        if (rbnds[bidx] < 0) {
            final int rnum = chooseRingNumber();
            if (rnum > 9)
                sb.append('%');
            sb.append(rnum);
            rbnds[bidx] = rnum;
        } else if (rbnds[bidx] > 0) {
            final int rnum = rbnds[bidx];
            releaseRingNumber(rnum);
            if (rnum > 9)
                sb.append('%');
            sb.append(rnum);
        }
        if (mode == MODE_EXACT && avisit[nbr] == 0 || bidx == bprev || rbnds[bidx] != 0)
            remain--;
    }
    for (int j = 0; j < d; j++) {
        int nbr = atomAdj[idx][j];
        int bidx = bondAdj[idx][j];
        if (mode == MODE_EXACT && avisit[nbr] == 0 || bidx == bprev || rbnds[bidx] != 0)
            continue;
        remain--;
        if (avisit[nbr] == 0) {
            if (remain > 0)
                sb.append('(');
            sb.append(bexpr[bidx]);
            sb.append(mol.getAtom(nbr).isAromatic() ? 'a' : '*');
            if (remain > 0)
                sb.append(')');
        } else {
            if (remain > 0)
                sb.append('(');
            sb.append(bexpr[bidx]);
            encodeExpr(nbr, bidx, sb);
            if (remain > 0)
                sb.append(')');
        }
    }
}",encodeExpr,org/openscience/cdk/smarts/SmartsFragmentExtractor.java,/tool/smarts/src/main/java/org/openscience/cdk/smarts/SmartsFragmentExtractor.java,"/**
     * Recursively encodes a SMARTS expression into the provides
     * string builder.
     *
     * @param idx   atom index
     * @param bprev previous bond
     * @param sb    destition to write SMARTS to
     */",259-319,"('encodeExpr', {'INSTRUCTION': {'covered': 215, 'missed': 0}, 'BRANCH': {'covered': 40, 'missed': 0}, 'LINE': {'covered': 35, 'missed': 0}, 'COMPLEXITY': {'covered': 21, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",386.0,11.0,Recursively encodes a SMARTS expression into the provides  string builder.,"Given an atom index, recursively encode into a string builder a SMARTS expression.",The provides string builder has a SMARTS expression.,0.381159531182284,Recursively encodes a SMARTS expression in the provides string generator.,"private void encodeExpr(int idx, int bprev, StringBuilder sb){
        final int d = deg[idx];
        for (int j = 0; j < d; j++) {
            int nbr = atomAdj[idx][j];
            int bidx = bondAdj[idx][j];
            if (avisit[nbr] == 0 || bidx == bprev)
                continue; // ignored
            else if (avisit[nbr] < 0)
                encodeExpr(nbr, bidx, sb);
            else if (avisit[nbr] < avisit[idx])
                sb.append('.');
        }
        sb.append(aexpr[idx]);
    }","private void encodeExpr(int idx, int bprev, StringBuilder sb){
        final int d = deg[idx];
        for (int j = 0; j < d; j++) {
            int nbr = atomAdj[idx][j];
            int bidx = bondAdj[idx][j];
            if (avisit[nbr] == 0 || bidx == bprev)
                continue; // ignored
            else if (avisit[nbr] < 0)
                encodeExpr(nbr, bidx, sb);
            else if (avisit[nbr] < avisit[idx])
                sb.append('.');
        }
        sb.append(aexpr[idx]);
    }","private void encodeExpr(int idx, int bprev, StringBuilder sb){
        final int d = deg[idx];
        for (int j = 0; j < d; j++) {
            int nbr = atomAdj[idx][j];
            int bidx = bondAdj[idx][j];
            if (avisit[nbr] == 0 || bidx == bprev)
                continue; // ignored
            else if (avisit[nbr] < 0)
                encodeExpr(nbr, bidx, sb);
            else if (avisit[nbr] < avisit[idx])
                sb.append('.');
        }
        sb.append(aexpr[idx]);
    }","private void encodeExpr(int idx, int bprev, StringBuilder sb){
        final int d = deg[idx];
        for (int j = 0; j < d; j++) {
            int nbr = atomAdj[idx][j];
            int bidx = bondAdj[idx][j];
            if (avisit[nbr] == 0 || bidx == bprev)
                continue; // ignored
            else if (avisit[nbr] < 0)
                encodeExpr(nbr, bidx, sb);
            else if (avisit[nbr] < avisit[idx])
                sb.append('.');
        }
        sb.append(aexpr[idx]);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2937658990631751,  0.2937658990631751,  0.2937658990631751,  0.2937658990631751,277.0,0.7157622739018088,277.0,0.7157622739018088,277.0,0.7157622739018088,277.0,0.7157622739018088,0.0,0.0,0.0,0.0,0.0,0.0,12.0,0.8571428571428571,2.0,0.18181818181818182,10.0,0.9090909090909091
332,egeria,"public Optional<EntityDetail> findTopicEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, TOPIC_TYPE_NAME);
}",findTopicEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineTopicHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineTopicHandler.java,"/**
     * Find out if the Topic object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",98-114,"('findTopicEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,13.0,Find out if the Topic object is already stored in the repository.,"Discover whether the Topic object is already present in the repository, using the fully qualified name for retrieving the entity.","If the object is already in the repository, you should find it.",0.157903166321782,Find out if the Topic object is already stored in the repository.," public Optional<EntityDetail> findTopicEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        final String methodName = ""findTopicEntity"";
        validateParameters(userId, methodName, qualifiedName);
    
        return topicHandler.getEntityByQualifiedName(userId, qualifiedName, methodName);
    }"," public Optional<EntityDetail> findTopicEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        final String methodName = ""findTopicEntity"";
        validateParameters(userId, methodName, qualifiedName);
    
        return topicHandler.getEntityByQualifiedName(userId, qualifiedName, methodName);
    }"," public Optional<EntityDetail> findTopicEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        final String methodName = ""findTopicEntity"";
        validateParameters(userId, methodName, qualifiedName);
    
        return topicHandler.findEntityByGUID(userId, qualifiedName, TOPIC_TYPE_GUID, TOPIC_TYPE_NAME, methodName);
    }"," public Optional<EntityDetail> findTopicEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        final String methodName = ""findTopicEntity"";
        validateParameters(userId, methodName, qualifiedName);
    
        return topicHandler.getEntityByGUID(userId, qualifiedName, TOPIC_GUID_PARAMETER_NAME, TOPIC_TYPE_GUID, TOPIC_TYPE_NAME, methodName);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7806958539115615,  0.7806958539115615,  0.7354693861309992,  0.7400161730004401,18.0,0.3673469387755102,18.0,0.3673469387755102,23.0,0.41818181818181815,21.0,0.39622641509433965,0.0,0.0,7.0,0.12727272727272726,5.0,0.09433962264150944,14.0,0.6666666666666666,0.0,0.0,10.0,0.7692307692307693
333,jacoco-plugin,"private static Map<Type, Coverage> loadRatios(JacocoReportDir layout, String[] includes, String... excludes) throws IOException{
    Map<CoverageElement.Type, Coverage> ratios = new LinkedHashMap<>();
    ExecutionFileLoader efl = layout.parse(includes, excludes);
    IBundleCoverage bundleCoverage = efl.getBundleCoverage();
    if (bundleCoverage == null) {
        return null;
    }
    Coverage ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getClassCounter().getMissedCount(), bundleCoverage.getClassCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.CLASS, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getBranchCounter().getMissedCount(), bundleCoverage.getBranchCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.BRANCH, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getInstructionCounter().getMissedCount(), bundleCoverage.getInstructionCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.INSTRUCTION, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getMethodCounter().getMissedCount(), bundleCoverage.getMethodCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.METHOD, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getComplexityCounter().getMissedCount(), bundleCoverage.getComplexityCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.COMPLEXITY, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getLineCounter().getMissedCount(), bundleCoverage.getLineCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.LINE, ratio);
    return ratios;
}",loadRatios,hudson/plugins/jacoco/JacocoBuildAction.java,/src/main/java/hudson/plugins/jacoco/JacocoBuildAction.java,"/**
	 * Extracts top-level coverage information from the JaCoCo report document.
	 */",326-363,"('loadRatios', {'INSTRUCTION': {'covered': 120, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",349.0,10.0,Extracts top-level coverage information from the JaCoCo report document.,"Using the JaCoCo report, it finds the top-level converage information.",The JaCoCo report document has top-level coverage information.,0.302898450422585,Extracts high-level coverage information from the JaCoCo report document.," private static Map<Type, Coverage> loadRatios(JacocoReportDir layout, String[] includes, String... excludes) throws IOException{
	 	Map<Type, Coverage> ratios = new LinkedHashMap<>();
 	for(Type type : Type.values()) {
 		Coverage coverage = layout.parse(includes, excludes, type);
 		if(coverage!=null) {
 			ratios.put(type, coverage);
 		}
 	}
 	return ratios;
 }"," private static Map<Type, Coverage> loadRatios(JacocoReportDir layout, String[] includes, String... excludes) throws IOException{
	 	Map<CoverageElement.Type,Coverage> ratios = new LinkedHashMap<>();
 	for(CoverageElement.Type type : CoverageElement.Type.values()) {
 		Coverage coverage = layout.parse(includes, excludes, type);
 		if(coverage!=null) {
 			ratios.put(type, coverage);
 		}
 	}
 	return ratios;
 }"," private static Map<Type, Coverage> loadRatios(JacocoReportDir layout, String[] includes, String... excludes) throws IOException{
	 	Map<Type, Coverage> ratios = new LinkedHashMap<>();
 	for(Type type : Type.values()) {
 		Coverage coverage = layout.parse(includes, excludes, type);
 		ratios.put(type, coverage);
 	}
 	return ratios;
 }"," private static Map<Type, Coverage> loadRatios(JacocoReportDir layout, String[] includes, String... excludes) throws IOException{
	 		Map<Type, Coverage> ratios = new HashMap<>();
 		for (CoverageElement.Type type : CoverageElement.Type.values()) {
 			Coverage coverage = layout.parse(includes, excludes, type);
 			if(coverage!=null) {
 				ratios.put(type, coverage);
 			}
 		}
 		return ratios;
 	}",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.18685359095170617,  0.19763743271895864,  0.18627641056628458,  0.18024618287557448,282.0,0.8057142857142857,276.0,0.7885714285714286,279.0,0.7971428571428572,284.0,0.8114285714285714,6.0,0.06315789473684211,5.0,0.053763440860215055,8.0,0.0898876404494382,9.0,0.8181818181818182,1.0,0.1,9.0,0.9
334,cdk,"public void addListener(IChemObjectListener col){
    List<IChemObjectListener> listeners = lazyChemObjectListeners();
    if (!listeners.contains(col)) {
        listeners.add(col);
    }
}",addListener,org/openscience/cdk/ChemObject.java,/base/data/src/main/java/org/openscience/cdk/ChemObject.java,"/**
     *  Use this to add yourself to this IChemObject as a listener. In order to do
     *  so, you must implement the ChemObjectListener Interface.
     *
     *@param  col  the ChemObjectListener
     *@see         #removeListener
     */",119-135,"('addListener', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,12.0,Use this to add yourself to this IChemObject as a listener.,Add yourself to the IChemObject as a listener but the ChemObjectListener interface must be implemented.,Add yourself to this IChem object.,0.137432359657595,Use it to add yourself to this IChemObject as a listener.," public void addListener(IChemObjectListener col){
        lazyChemObjectListeners().add(col);     
 }"," public void addListener(IChemObjectListener col){
        lazyChemObjectListeners().add(col);     
 }"," public void addListener(IChemObjectListener col){
        lazyChemObjectListeners().add(col);     
 }"," public void addListener(IChemObjectListener col){
        lazyChemObjectListeners().add(col);     
 }",PASS,PASS,PASS,PASS,  0.337112264768889,  0.337112264768889,  0.337112264768889,  0.337112264768889,20.0,0.5128205128205128,20.0,0.5128205128205128,20.0,0.5128205128205128,20.0,0.5128205128205128,0.0,0.0,0.0,0.0,0.0,0.0,13.0,0.8125,1.0,0.08333333333333333,8.0,0.6666666666666666
336,cdk,"public int parity(long[] current){
    int count = 0;
    for (int i = 0, n = indices.length; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int cmp = compare(current[indices[i]], current[indices[j]]);
            if (cmp == 0)
                return 0;
            else if (cmp > 0)
                count++;
        }
    }
    // value is odd, -1 or value is even +1
    return Integer.lowestOneBit(count) == 1 ? -1 : +1;
}",parity,org/openscience/cdk/hash/stereo/BasicPermutationParity.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/BasicPermutationParity.java,"/**
     * The number values to check is typically small ({@literal < 5}) and thus
     * we use brute-force to count the number of inversions.
     *
     *{@inheritDoc}
     */",55-77,"('parity', {'INSTRUCTION': {'covered': 51, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",113.0,28.0,The number values to check is typically small ({@literal < 5}) and thus  we use brute-force to count the number of inversions.,"Counts the number of inversion using a brute-force procedure, sine the number values to check is in general small.",The number values to check are usually small and therefore we use brute- force to count the number of inversions.,0.514156185861105,The numerical values to be checked are usually small ({@literal < 5}) and so we use brute force to count the number of inversions.,Empty Method,"public int parity(long[] current){
        int parity = 0;
        for (int i = 0; i < indices.length; i++) {
            for (int j = i + 1; j < indices.length; j++) {
                if (current[indices[i]] > current[indices[j]]) {
                    parity++;
                }
            }
        }
        return parity;
    }",Empty Method,Empty Method,Empty Method,NOT PASS,Empty Method,Empty Method,None,  0.5112960394416292,None,None,None,None,49.0,0.4298245614035088,None,None,None,None,80.0,0.9876543209876543,None,None,None,None,21.0,0.9130434782608695,8.0,0.32,8.0,0.34782608695652173
337,egeria,"public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
        return false;
    }
    LogRecordRequestBody that = (LogRecordRequestBody) objectToCompare;
    return Objects.equals(getConnectorInstanceId(), that.getConnectorInstanceId()) && Objects.equals(getConnectionName(), that.getConnectionName()) && Objects.equals(getConnectorType(), that.getConnectorType()) && Objects.equals(getContextId(), that.getContextId()) && Objects.equals(getMessage(), that.getMessage());
}",equals,org/odpi/openmetadata/accessservices/assetconsumer/rest/LogRecordRequestBody.java,/open-metadata-implementation/access-services/asset-consumer/asset-consumer-api/src/main/java/org/odpi/openmetadata/accessservices/assetconsumer/rest/LogRecordRequestBody.java,"/**
     * Equals method that returns true if containing properties are the same.
     *
     * @param objectToCompare object to compare
     * @return boolean result of comparison
     */",186-209,"('equals', {'INSTRUCTION': {'covered': 51, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 5}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",125.0,12.0,Equals method that returns true if containing properties are the same.,It returns true if the containing properties are the same.,"If the properties are the same, the equal method returns true.",0.388343962593669,Equal method; returns true if the properties containing are identical.," public boolean equals(Object objectToCompare){
        if (objectToCompare == null)
        {
            return false;
        }
    
        if (objectToCompare instanceof LogRecordRequestBody)
        {
            LogRecordRequestBody logRecordRequestBody = (LogRecordRequestBody) objectToCompare;
    
            return Objects.equals(this.connectorInstanceId, logRecordRequestBody.connectorInstanceId) &&
                    Objects.equals(this.connectionName, logRecordRequestBody.connectionName) &&
                    Objects.equals(this.connectorType, logRecordRequestBody.connectorType) &&
                    Objects.equals(this.contextId, logRecordRequestBody.contextId) &&
                    Objects.equals(this.message, logRecordRequestBody.message);
        }
    
        return false;
    }"," public boolean equals(Object objectToCompare){
        if (objectToCompare instanceof LogRecordRequestBody) {
            LogRecordRequestBody logRecordRequestBody = (LogRecordRequestBody) objectToCompare;
            return Objects.equals(this.connectorInstanceId, logRecordRequestBody.connectorInstanceId) &&
                    Objects.equals(this.connectionName, logRecordRequestBody.connectionName) &&
                    Objects.equals(this.connectorType, logRecordRequestBody.connectorType) &&
                    Objects.equals(this.contextId, logRecordRequestBody.contextId) &&
                    Objects.equals(this.message, logRecordRequestBody.message);
        }
        return false;
    }"," public boolean equals(Object objectToCompare){
     
      if (objectToCompare == null)
      {
            return false;
      }
     
      if (objectToCompare instanceof LogRecordRequestBody)
      {
            LogRecordRequestBody logRecordRequestBody = (LogRecordRequestBody) objectToCompare;
     
            return Objects.equals(this.connectorInstanceId, logRecordRequestBody.connectorInstanceId) &&
                  Objects.equals(this.connectionName, logRecordRequestBody.connectionName) &&
                  Objects.equals(this.connectorType, logRecordRequestBody.connectorType) &&
                  Objects.equals(this.contextId, logRecordRequestBody.contextId) &&
                  Objects.equals(this.message, logRecordRequestBody.message);
      }
     
      return false;
     }"," public boolean equals(Object objectToCompare){
        if (this == objectToCompare)
        {
            return true;
        }
    
        if (objectToCompare == null)
        {
            return false;
        }
    
        if (getClass() != objectToCompare.getClass())
        {
            return false;
        }
    
        LogRecordRequestBody that = (LogRecordRequestBody) objectToCompare;
    
        return Objects.equals(this.connectorInstanceId, that.connectorInstanceId) &&
                Objects.equals(this.connectionName, that.connectionName) &&
                Objects.equals(this.connectorType, that.connectorType) &&
                Objects.equals(this.contextId, that.contextId) &&
                Objects.equals(this.message, that.message);     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.43022849901048477,  0.38263332544613315,  0.7260663573755519,  0.43022849901048477,58.0,0.4603174603174603,66.0,0.5238095238095238,38.0,0.30158730158730157,58.0,0.4603174603174603,11.0,0.10377358490566038,33.0,0.2682926829268293,0.0,0.0,4.0,0.3333333333333333,7.0,0.5833333333333334,11.0,0.9166666666666666
338,cdk,"static boolean parse(String label, List<String> tokens){
    int i = 0;
    int len = label.length();
    while (i < len) {
        int st = i;
        int last;
        char c = label.charAt(i);
        // BRACKETS we treat as separate
        if (c == '(' || c == ')') {
            tokens.add(Character.toString(c));
            i++;
            // digits following closing brackets
            if (c == ')') {
                st = i;
                while (i < len && isDigit(c = label.charAt(i))) {
                    i++;
                }
                if (i > st)
                    tokens.add(label.substring(st, i));
            }
            continue;
        }
        // separators
        if (c == '/' || c == '·' || c == '.' || c == '•' || c == '=') {
            tokens.add(Character.toString(c));
            i++;
            int beg = i;
            while (i < label.length() && isDigit(label.charAt(i))) {
                i++;
            }
            if (i > beg)
                tokens.add(label.substring(beg, i));
            continue;
        }
        // SYMBOL Tokens
        // optional prefix o- m- p- etc.
        if ((last = findPrefix(PREFIX_TRIE, label, i, -1)) > 0) {
            i += (last - i);
        }
        final int symSt = i;
        // a valid symbol token
        if ((last = findPrefix(SYMBOL_TRIE, label, i, -1)) > 0) {
            i += (last - i);
            // an optional number suffix e.g. O2 F3 Ph3 etc.
            while (i < len && isDigit(label.charAt(i))) {
                i++;
            }
        } else // a charge token, only if it's after some other parts
        if (i == st && st > 0) {
            c = norm(label.charAt(i));
            if (c == '-' || c == '+') {
                i++;
                while (i < len && isDigit(label.charAt(i))) {
                    i++;
                }
                // we expect charge at the end of the string.. if there is
                // still more it's not good input
                if (i < len) {
                    return failParse(label, tokens);
                }
            }
        }
        if (i == st || i == symSt) {
            return failParse(label, tokens);
        }
        tokens.add(label.substring(st, i));
    }
    return true;
}",parse,org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,"/**
     * Split a label it to recognised tokens for reversing, the
     * validity of the label is not checked! The method is intended
     * for zero/single attachments only and linkers are not supported.
     * 
     * 
     * Example: 
     * {@code NHCH2Ph -> N,H,C,H2,Ph -> reverse/join -> PhH2CHN}
     * 
     * 
     * 
     * The method return value signals whether formula
     * formatting (sub- and super- script) can be applied.
     *
     * @param label  abbreviation label
     * @param tokens the list of tokens from the input (n>0)
     * @return whether the label parsed okay (i.e. apply formatting)
     */",146-247,"('parse', {'INSTRUCTION': {'covered': 179, 'missed': 14}, 'BRANCH': {'covered': 46, 'missed': 10}, 'LINE': {'covered': 40, 'missed': 2}, 'COMPLEXITY': {'covered': 21, 'missed': 8}, 'METHOD': {'covered': 1, 'missed': 0}})",431.0,33.0,"Split a label it to recognised tokens for reversing, the  validity of the label is not checked! The method is intended  for zero/single attachments only and linkers are not supported.","Divide a label to find tokens for reversing, without checking the validity of the label. The method can be used if there is at most one attachment, without supporting the linkers.",The method is only for single attachment only and does not support linkers.,0.148063328194153,"Divide a label into recognized tokens to reverse it, the validity of the label is not verified! The method is for zero/single attachments only and linkers are not supported.","static boolean parse(String label, List<String> tokens){
        if (label == null)
            return false;
        if (tokens == null)
            return false;
        tokens.clear();
        int len = label.length();
        if (len == 0)
            return false;
        int i = 0;
        int style = STYLE_NORMAL;
        StringBuilder sb = new StringBuilder();
        while (i < len) {
            char c = label.charAt(i);
            if (c == '_') {
                if (style == STYLE_NORMAL)
                    style = STYLE_SUBSCRIPT;
                else if (style == STYLE_SUBSCRIPT)
                    style = STYLE_NORMAL;
                else
                    style = STYLE_SUBSCRIPT;
            } else if (c == '^') {
                if (style == STYLE_NORMAL)
                    style = STYLE_SUPSCRIPT;
                else if (style == STYLE_SUPSCRIPT)
                    style = STYLE_NORMAL;
                else
                    style = STYLE_SUPSCRIPT;
            } else if (c == ' ') {
                if (sb.length() > 0) {
                    tokens.add(sb.toString());
                    sb.setLength(0);
                }
            } else if (c == '\\') {
                if (i + 1 < len) {
                    char c2 = label.charAt(i + 1);
                    if (c2 == '_' || c2 == '^') {
                        if (sb.length() > 0) {
                            tokens.add(sb.toString());
                            sb.setLength(0);
                        }
                        tokens.add(Character.toString(c2));
                        i++;
                    } else {
                        sb.append(c);
                        sb.append(c2);
                        i++;
                    }
                } else {
                    sb.append(c);
                }
            } else {
                sb.append(c);
            }
            i++;
        }
        if      
 }","static boolean parse(String label, List<String> tokens){
        int i = 0;
        int j = 0;
        int k = 0;
        int l = 0;
        int m = 0;
        int n = 0;
        int o = 0;
        int p = 0;
        int q = 0;
        int r = 0;
        int s = 0;
        int t = 0;
        int u = 0;
        int v = 0;
        int w = 0;
        int x = 0;
        int y = 0;
        int z = 0;
        int aa = 0;
        int bb = 0;
        int cc = 0;
        int dd = 0;
        int ee = 0;
        int ff = 0;
        int gg = 0;
        int hh = 0;
        int ii = 0;
        int jj = 0;
        int kk = 0;
        int ll = 0;
        int mm = 0;
        int nn = 0;
        int oo = 0;
        int pp = 0;
        int qq = 0;
        int rr = 0;
        int ss = 0;
        int tt = 0;
        int uu = 0;
        int vv = 0;
        int ww = 0;
        int xx = 0;
        int yy = 0;
        int zz = 0;
        int aaa = 0;
        int bbb = 0;
        int ccc = 0;
        int ddd = 0;
        int eee = 0;
        int fff = 0;
        int ggg = 0;
        int hhh = 0;
        int iii = 0;
        int jjj =       
 }","static boolean parse(String label, List<String> tokens){
        if (label == null || label.isEmpty())
            return false;
        String[] parts = label.split(""\\s+"");
        for (String part : parts) {
            if (part.isEmpty())
                continue;
            if (part.startsWith(""["")) {
                if (part.endsWith(""]"")) {
                    tokens.add(part.substring(1, part.length() - 1));
                } else {
                    tokens.add(part.substring(1));
                }
            } else {
                tokens.add(part);
            }
        }
        return true;
    }","static boolean parse(String label, List<String> tokens){
        tokens.clear();
        int i = 0;
        while (i < label.length()) {
            int j = i;
            while (j < label.length() && Character.isLetterOrDigit(label.charAt(j)))
                j++;
            if (j > i) {
                String token = label.substring(i, j);
                if (token.length() > 1) {
                    if (token.length() > 2 && token.charAt(0) == '[' && token.charAt(token.length() - 1) == ']') {
                        token = token.substring(1, token.length() - 1);
                    }
                    tokens.add(token);
                }
            }
            i = j;
        }
        return !tokens.isEmpty();
    }",Syntax Error,Syntax Error,NOT PASS - TIMEOUT,NOT PASS,None,None,  0.20577496630947073,  0.10359429939266843,None,None,None,None,323.0,0.7476851851851852,343.0,0.7939814814814815,None,None,238.0,0.7125748502994012,244.0,0.7305389221556886,22.0,0.6875,9.0,0.2903225806451613,24.0,0.7741935483870968
339,cdk,"public static IBioPolymer addAminoAcidAtCTerminus(IBioPolymer protein, IAminoAcid aaToAdd, IStrand strand, IAminoAcid aaToAddTo){
    addAminoAcid(protein, aaToAdd, strand);
    if ((protein.getMonomerCount() != 0) && (aaToAddTo != null)) {
        protein.addBond(aaToAdd.getBuilder().newInstance(IBond.class, aaToAddTo.getCTerminus(), aaToAdd.getNTerminus(), IBond.Order.SINGLE));
    }
    return protein;
}",addAminoAcidAtCTerminus,org/openscience/cdk/tools/ProteinBuilderTool.java,/storage/pdb/src/main/java/org/openscience/cdk/tools/ProteinBuilderTool.java,"/**
     * Builds a protein by connecting a new amino acid at the C-terminus of the
     * given strand. The acidic oxygen of the added amino acid is removed so that
     * additional amino acids can be added savely. But this also means that you
     * might want to add an oxygen at the end of the protein building!
     *
     * @param protein protein to which the strand belongs
     * @param aaToAdd amino acid to add to the strand of the protein
     * @param strand  strand to which the protein is added
     */",74-96,"('addAminoAcidAtCTerminus', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,17.0,Builds a protein by connecting a new amino acid at the C-terminus of the  given strand.,"Creates a protein connecting the new amino acid to the C-terminus, removing the acidic oxygen from the amino acid so that it can be added safely. You may want to add at the end of the protein an oxygen.",A new amino acid is connected to the C-terminus of the strand.,0.685385771620528,Builds a protein by connecting a new amino acid to the C termination of the given strand.,"public static IBioPolymer addAminoAcidAtCTerminus(IBioPolymer protein, IAminoAcid aaToAdd, IStrand strand, IAminoAcid aaToAddTo){
        // then add the amino acid
        addAminoAcid(protein, aaToAdd, strand);
        // Now think about the protein back bone connection
        if (protein.getMonomerCount() == 0) {
            // make the connection between that aminoAcid's C-terminus and the
            // protein's N-terminus
            protein.addBond(aaToAdd.getBuilder().newInstance(IBond.class, aaToAdd.getNTerminus(),
                    aaToAddTo.getCTerminus(), IBond.Order.SINGLE));
        } // else : no current N-terminus, so nothing special to do
        return protein;
    }","public static IBioPolymer addAminoAcidAtCTerminus(IBioPolymer protein, IAminoAcid aaToAdd, IStrand strand, IAminoAcid aaToAddTo){
        // then add the amino acid
        addAminoAcid(protein, aaToAdd, strand);
        // Now think about the protein back bone connection
        if (protein.getMonomerCount() == 0) {
            // make the connection between that aminoAcid's C-terminus and the
            // protein's N-terminus
            protein.addBond(aaToAdd.getBuilder().newInstance(IBond.class, aaToAdd.getNTerminus(),
                    aaToAddTo.getCTerminus(), IBond.Order.SINGLE));
        } // else : no current N-terminus, so nothing special to do
        return protein;
    }","public static IBioPolymer addAminoAcidAtCTerminus(IBioPolymer protein, IAminoAcid aaToAdd, IStrand strand, IAminoAcid aaToAddTo){
        // then add the amino acid
        addAminoAcid(protein, aaToAdd, strand);
        // Now think about the protein back bone connection
        if (protein.getMonomerCount() == 0) {
            // make the connection between that aminoAcid's C-terminus and the
            // protein's N-terminus
            protein.addBond(aaToAdd.getBuilder().newInstance(IBond.class, aaToAdd.getNTerminus(),
                    aaToAddTo.getCTerminus(), IBond.Order.SINGLE));
        } // else : no current N-terminus, so nothing special to do
        return protein;
    }","public static IBioPolymer addAminoAcidAtCTerminus(IBioPolymer protein, IAminoAcid aaToAdd, IStrand strand, IAminoAcid aaToAddTo){
        // then add the amino acid
        addAminoAcid(protein, aaToAdd, strand);
        // Now think about the protein back bone connection
        if (protein.getMonomerCount() == 0) {
            // make the connection between that aminoAcid's C-terminus and the
            // protein's N-terminus
            protein.addBond(aaToAdd.getBuilder().newInstance(IBond.class, aaToAdd.getNTerminus(),
                    aaToAddTo.getCTerminus(), IBond.Order.SINGLE));
        } // else : no current N-terminus, so nothing special to do
        return protein;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8614713968571188,  0.8614713968571188,  0.8614713968571188,  0.8614713968571188,13.0,0.14772727272727273,13.0,0.14772727272727273,13.0,0.14772727272727273,13.0,0.14772727272727273,0.0,0.0,0.0,0.0,0.0,0.0,30.0,0.75,3.0,0.16666666666666666,10.0,0.5882352941176471
340,matsim-libs,"public static List<Link> findIntersectingLinks(Link link, final Network network){
    LineString segment = GeometryUtils.createGeotoolsLineString(link);
    return GeometryUtils.findIntersectingLinks(segment, network);
}",findIntersectingLinks,org/matsim/core/utils/geometry/GeometryUtils.java,/matsim/src/main/java/org/matsim/core/utils/geometry/GeometryUtils.java,"/**
	 * Method to find all links in {@link Network} that intersect a given {@link Link}.  Convenience method that
	 * only uses MATSim objects.
	 * 
	 * @param link
	 * @param network
	 * @return
	 */",55-66,"('findIntersectingLinks', {'INSTRUCTION': {'covered': 55, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,21.0,Method to find all links in {@link Network} that intersect a given {@link Link}.,"The method, that uses MATSim objects, find all the links in the Netwok that intersect the given Link.",The method to find links in the @link Network intersect a given one.,1.06597364492386,Method to search for all links in {@link Network} that cross a given {@link Link}.," public static List<Link> findIntersectingLinks(Link link, final Network network){
	 List<Link> intersectingLinks = new ArrayList<>();
	 for(Link l : network.getLinks().values()){
		 if(l.getGeometry().intersects(link.getGeometry())){
			 intersectingLinks.add(l);
		 }
	 }
	 return intersectingLinks;			
 }"," public static List<Link> findIntersectingLinks(Link link, final Network network){
	 List<Link> intersectingLinks = new ArrayList<>();
	 for(Link l : network.getLinks().values()){
		 if(link.getGeometry().intersects(l.getGeometry())){
			 intersectingLinks.add(l);
		 }
	 }
	 return intersectingLinks;			
 }"," public static List<Link> findIntersectingLinks(Link link, final Network network){
	 	List<Link> intersectingLinks = new ArrayList<>();
 	for(Link l : network.getLinks().values()){
 		if(link.getGeometry().intersects(l.getGeometry())){
 			intersectingLinks.add(l);
 		}
 	}
 	return intersectingLinks;		
 }"," public static List<Link> findIntersectingLinks(Link link, final Network network){
	 	List<Link> intersectingLinks = new ArrayList<>();
 	for (Link l : network.getLinks().values()) {
 		if (l.getGeometry().intersects(link.getGeometry())) {
 			intersectingLinks.add(l);
 		}
 	}
 	return intersectingLinks;		
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5078866631926376,  0.5078866631926376,  0.5078866631926376,  0.5078866631926376,51.0,0.6623376623376623,50.0,0.6493506493506493,51.0,0.6623376623376623,50.0,0.6493506493506493,2.0,0.025974025974025976,0.0,0.0,2.0,0.025974025974025976,12.0,0.631578947368421,3.0,0.1875,8.0,0.5333333333333333
341,sonar-cxx,"public static SourceFile scanSingleInputFile(InputFile inputFile, SquidAstVisitor<Grammar>... visitors){
    return scanSingleInputFileConfig(inputFile, new CxxSquidConfiguration(), visitors);
}",scanSingleInputFile,org/sonar/cxx/CxxAstScanner.java,/cxx-squid/src/main/java/org/sonar/cxx/CxxAstScanner.java,"/**
   * Helper method for testing checks without having to deploy them on a Sonar instance.
   *
   * @param inputFile is the file to be checked
   * @param visitors AST checks and visitors to use
   * @return file checked with measures and issues
   */",66-76,"('scanSingleInputFile', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,15.0,Helper method for testing checks without having to deploy them on a Sonar instance.,The method allows you to test checks without the deployment on Sonar instance.,The method is for testing checks without having to deploy them.,0.417191243386658,A helper method for testing checks without having to deploy them to a Sonar instance.," public static SourceFile scanSingleInputFile(InputFile inputFile, SquidAstVisitor<Grammar>... visitors){
    return scanSingleInputFile(inputFile, null, visitors);    
 }"," public static SourceFile scanSingleInputFile(InputFile inputFile, SquidAstVisitor<Grammar>... visitors){
    return scanSingleInputFile(inputFile, null, visitors);    
 }"," public static SourceFile scanSingleInputFile(InputFile inputFile, SquidAstVisitor<Grammar>... visitors){
    return scanSingleInputFile(inputFile, new CxxSquidConfiguration(), visitors);   
 }"," public static SourceFile scanSingleInputFile(InputFile inputFile, SquidAstVisitor<Grammar>... visitors){
    return scanSingleInputFile(inputFile, CxxSquidConfiguration.create(inputFile.getFile().getAbsolutePath()), visitors);   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7505821862490099,  0.7505821862490099,  0.7423566248211508,  0.9554753399540596,5.0,0.16129032258064516,5.0,0.16129032258064516,13.0,0.3170731707317073,1.0,0.03225806451612903,0.0,0.0,14.0,0.34146341463414637,4.0,0.12903225806451613,10.0,0.6666666666666666,3.0,0.1875,7.0,0.4666666666666667
342,tablesaw,"public static IntColumn indexColumn(final String columnName, final int size, final int startsWith){
    final IntColumn indexColumn = IntColumn.create(columnName, size);
    for (int i = 0; i < size; i++) {
        indexColumn.set(i, i + startsWith);
    }
    return indexColumn;
}",indexColumn,tech/tablesaw/api/IntColumn.java,/core/src/main/java/tech/tablesaw/api/IntColumn.java,"/**
   * Returns a new numeric column initialized with the given name and size. The values in the column
   * are integers beginning at startsWith and continuing through size (exclusive), monotonically
   * increasing by 1 TODO consider a generic fill function including steps or random samples from
   * various distributions
   */",71-84,"('indexColumn', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",62.0,13.0,Returns a new numeric column initialized with the given name and size.,"Creates a new numeric column with the specified name and size, inserting values that beginning at startsWith and continuing through the size.",The new column is initialized with the given size and name.,0.191660446220208,Returns a new numeric column initialized with the given name and size.,"public static IntColumn indexColumn(final String columnName, final int size, final int startsWith){
    IntColumn column = new IntColumn(columnName, new IntArrayList(size));
    for(int i = 0; i < size; i++){
      column.set(i, startsWith + i);
    }
    return column;
  }","public static IntColumn indexColumn(final String columnName, final int size, final int startsWith){
    IntColumn column = create(columnName, size);
    for(int i = 0; i < size; i++){
      column.set(i, startsWith + i);
    }
    return column;
  }","public static IntColumn indexColumn(final String columnName, final int size, final int startsWith){
    IntColumn newColumn = create(columnName, size);
    for(int i = 0; i < size; i++){
      newColumn.set(i, startsWith + i);
    }
    return newColumn;
  }","public static IntColumn indexColumn(final String columnName, final int size, final int startsWith){
    IntColumn column = new IntColumn(columnName, new IntArrayList(size));
    for(int i = 0; i < size; i++){
      column.set(i, startsWith + i);
    }
    return column;
  }",NOT PASS,PASS,NOT PASS,PASS,  0.7762294519619913,  0.6969997492896032,  0.7762294519619913,  0.6969997492896032,13.0,0.2,8.0,0.12698412698412698,13.0,0.2,8.0,0.12698412698412698,6.0,0.09230769230769231,0.0,0.0,9.0,0.13846153846153847,14.0,0.6086956521739131,0.0,0.0,6.0,0.46153846153846156
343,weblogic-kubernetes-operator," static boolean checkUpdateDynamicClusterSizeJsonResult(String jsonResult){
    final String expectedResult = ""{}"";
    boolean result = false;
    if (expectedResult.equals(jsonResult)) {
        result = true;
    }
    return result;
}",checkUpdateDynamicClusterSizeJsonResult,oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,"/**
   * Checks the JSON result from the dynamic cluster size update REST request.
   *
   * @param jsonResult The JSON String result from the dynamic server cluster size update REST
   *     request
   * @return true if the result means the update was successful, false otherwise
   */",118-133,"('checkUpdateDynamicClusterSizeJsonResult', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,13.0,Checks the JSON result from the dynamic cluster size update REST request.,"Returns true if the update to the REST request, done usiing a JSON file from a dynamic cluster, was successful, false otherwise",The result of the dynamic cluster size update is checked.,0.304511585002596,Verifies the JSON result of the dynamic update REST request for the cluster size.,"  static boolean checkUpdateDynamicClusterSizeJsonResult(String jsonResult){
    return jsonResult.contains(""\""status\"":\""success\"""");     
  }","  static boolean checkUpdateDynamicClusterSizeJsonResult(String jsonResult){
    return jsonResult.contains(""\""status\"":\""success\"""");     
  }","  static boolean checkUpdateDynamicClusterSizeJsonResult(String jsonResult){
    return jsonResult.contains(""\""status\"":\""success\"""");     
  }","  static boolean checkUpdateDynamicClusterSizeJsonResult(String jsonResult){
    return jsonResult.contains(""\""name\"":\""clusterSize\"""");     
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2574856661168311,  0.2574856661168311,  0.2574856661168311,  0.2574856661168311,25.0,0.6410256410256411,25.0,0.6410256410256411,25.0,0.6410256410256411,25.0,0.6410256410256411,0.0,0.0,1.0,0.05555555555555555,0.0,0.0,18.0,0.782608695652174,9.0,0.6,6.0,0.46153846153846156
344,cdk,"int intType(final String sym){
    Integer intType = typeMap.get(sym);
    if (intType == null) {
        return 0;
    }
    return intType;
}",intType,org/openscience/cdk/forcefield/mmff/MmffParamSet.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffParamSet.java,"/**
     * Obtain the integer MMFF atom type for a given symbolic MMFF type.
     *
     * @param sym Symbolic MMFF type
     * @return integer MMFF type
     */",92-104,"('intType', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,13.0,Obtain the integer MMFF atom type for a given symbolic MMFF type.,"Starting from a given symbolic MMFF type, return the integer MMFF atom type.",Obtain the MMFF atom type for a symbolic MMFF type.,0.538384973450306,Get the whole MMFF atom type for a given symbolic MMFF type.,"int intType(final String sym){
        return typeMap.getOrDefault(sym, -1);
    }","int intType(final String sym){
        return typeMap.getOrDefault(sym, -1);
    }","int intType(final String sym){
        return typeMap.getOrDefault(sym, -1);
    }"," int intType(final String sym){
        return typeMap.get(sym);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3009865300456255,  0.3009865300456255,  0.37498835687605336,  0.3009865300456255,18.0,0.5294117647058824,18.0,0.5294117647058824,17.0,0.5,18.0,0.5294117647058824,0.0,0.0,4.0,0.19047619047619047,0.0,0.0,11.0,0.7857142857142857,2.0,0.15384615384615385,2.0,0.15384615384615385
345,weblogic-kubernetes-operator,"boolean deleteServerServiceFromEvent(String serverName, V1Service event){
    if (serverName == null) {
        return false;
    }
    V1Service deletedService = getSko(serverName).getService().getAndAccumulate(event, this::getNewerCurrentOrNull);
    return deletedService != null;
}",deleteServerServiceFromEvent,oracle/kubernetes/operator/helpers/DomainPresenceInfo.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/DomainPresenceInfo.java,"/**
   * Given the service associated with a server service-deleted event, removes the service if it is
   * not older than the one recorded.
   *
   * @param serverName the name of the associated server
   * @param event the service associated with the event
   * @return true if the service was actually removed
   */",379-394,"('deleteServerServiceFromEvent', {'INSTRUCTION': {'covered': 18, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,23.0,"Given the service associated with a server service-deleted event, removes the service if it is  not older than the one recorded.","If the service associated with a server service-deleted event is not older than the one that has been recorded, remove it.","If the service is older than the one recorded, it is removed.",0.190836588382327,"Given the service associated with an event removed from the server service, deletes the service if it is not older than the registered service.","boolean deleteServerServiceFromEvent(String serverName, V1Service event){
    if (serverName == null) {
      return false;
    }
    ServerKubernetesObjects sko = getSko(serverName);
    V1Service deletedService = sko.getService().getAndAccumulate(event, this::getNewerCurrentOrNull);
    if (deletedService != null) {
      sko.getLastKnownStatus().set(new LastKnownStatus(WebLogicConstants.SHUTDOWN_STATE));
    }
    return deletedService != null;
  }","boolean deleteServerServiceFromEvent(String serverName, V1Service event){
    if (serverName == null) {
      return false;
    }
    ServerKubernetesObjects sko = getSko(serverName);
    V1Service deletedService = sko.getService().getAndAccumulate(event, this::getNewerCurrentOrNull);
    if (deletedService != null) {
      sko.getLastKnownStatus().set(new LastKnownStatus(WebLogicConstants.SHUTDOWN_STATE));
    }
    return deletedService != null;
  }","boolean deleteServerServiceFromEvent(String serverName, V1Service event){
    if (serverName == null) {
      return false;
    }
    ServerKubernetesObjects sko = getSko(serverName);
    V1Service deletedService = sko.getService().getAndAccumulate(event, this::getNewerCurrentOrNull);
    if (deletedService != null) {
      sko.getLastKnownStatus().set(new LastKnownStatus(WebLogicConstants.SHUTDOWN_STATE));
    }
    return deletedService != null;
  }","boolean deleteServerServiceFromEvent(String serverName, V1Service event){
    if (serverName == null) {
      return false;
    }
    ServerKubernetesObjects sko = getSko(serverName);
    V1Service deletedService = sko.getService().getAndAccumulate(event, this::getNewerCurrentOrNull);
    if (deletedService != null) {
      sko.getLastKnownStatus().set(new LastKnownStatus(WebLogicConstants.SHUTDOWN_STATE));
    }
    return deletedService != null;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7250114964081071,  0.7250114964081071,  0.7250114964081071,  0.7250114964081071,32.0,0.4050632911392405,32.0,0.4050632911392405,32.0,0.4050632911392405,32.0,0.4050632911392405,0.0,0.0,0.0,0.0,0.0,0.0,13.0,0.5909090909090909,10.0,0.4,16.0,0.7272727272727273
346,cdk,"public DescriptorValue calculate(IAtomContainer mol){
    if (checkRingSystem)
        Cycles.markRingAtomsAndBonds(mol);
    IAtomContainer aliphaticParts = mol.getBuilder().newAtomContainer();
    for (IAtom atom : mol.atoms()) {
        if (isAcyclicCarbon(atom))
            aliphaticParts.addAtom(atom);
    }
    for (IBond bond : mol.bonds()) {
        if (isAcyclicCarbon(bond.getBegin()) && isAcyclicCarbon(bond.getEnd()))
            aliphaticParts.addBond(bond);
    }
    int longest = 0;
    final int[][] adjlist = GraphUtil.toAdjList(aliphaticParts);
    for (int i = 0; i < adjlist.length; i++) {
        if (adjlist[i].length != 1)
            continue;
        int length = getMaxDepth(adjlist, i, -1);
        if (length > longest)
            longest = length;
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(longest), getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/LongestAliphaticChainDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/LongestAliphaticChainDescriptor.java,"/**
     * Calculate the count of atoms of the longest aliphatic chain in the supplied {@link IAtomContainer}.
     * <p>
     * The method require one parameter:
     * if checkRingSyste is true the CDKConstant.ISINRING will be set
     *
     * @param mol The {@link IAtomContainer} for which this descriptor is to be calculated
     * @return the number of atoms in the longest aliphatic chain of this AtomContainer
     * @see #setParameters
     */",166-209,"('calculate', {'INSTRUCTION': {'covered': 97, 'missed': 0}, 'BRANCH': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",201.0,19.0,Calculate the count of atoms of the longest aliphatic chain in the supplied {@link IAtomContainer}.,"Given a IAtomContainer, it computes the highest number of atoms of the longest aliphatic chain.",The supplied IAtomContainer has a count of atoms of the longest aliphatic chain.,0.401325297400462,Calculate the number of atoms of the longest aliphatic chain in the provided {@link IAtomContainer}.,"public DescriptorValue calculate(IAtomContainer mol){
        try {
            int nAtomLAC = 0;
            int[][] adjlist = GraphUtil.toAdjList(mol);
            for (int i = 0; i < adjlist.length; i++) {
                if (isAcyclicCarbon(mol.getAtom(i))) {
                    int length = getMaxDepth(adjlist, i, -1);
                    if (length > nAtomLAC)
                        nAtomLAC = length;
                }
            }
            return new DescriptorValue(getSpecification(),
                                        getParameterNames(),
                                        getParameters(),
                                        new IntegerResult(nAtomLAC),
                                        getDescriptorNames());
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }","public DescriptorValue calculate(IAtomContainer mol){
        try {
            int nAtomLAC = 0;
            int[][] adjlist = GraphUtil.toAdjList(mol);
            for (int i = 0; i < adjlist.length; i++) {
                if (isAcyclicCarbon(mol.getAtom(i))) {
                    int length = getMaxDepth(adjlist, i, -1);
                    if (length > nAtomLAC)
                        nAtomLAC = length;
                }
            }
            return new DescriptorValue(getSpecification(),
                                        getParameterNames(),
                                        getParameters(),
                                        new IntegerResult(nAtomLAC),
                                        getDescriptorNames());
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }","public DescriptorValue calculate(IAtomContainer mol){
        try {
            int nAtomLAC = 0;
            int[][] adjlist = GraphUtil.toAdjList(mol);
            for (int i = 0; i < adjlist.length; i++) {
                if (isAcyclicCarbon(mol.getAtom(i))) {
                    int length = getMaxDepth(adjlist, i, -1);
                    if (length > nAtomLAC)
                        nAtomLAC = length;
                }
            }
            return new DescriptorValue(getSpecification(),
                                        getParameterNames(),
                                        getParameters(),
                                        new IntegerResult(nAtomLAC),
                                        getDescriptorNames());
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }","public DescriptorValue calculate(IAtomContainer mol){
        try {
            int[][] adjlist = GraphUtil.toAdjList(mol);
            int max = 0;
            for (int i = 0; i < adjlist.length; i++) {
                if (isAcyclicCarbon(mol.getAtom(i))) {
                    int length = getMaxDepth(adjlist, i, -1);
                    if (length > max)
                        max = length;
                }
            }
            return new DescriptorValue(getSpecification(),
                                        getParameterNames(),
                                        getParameters(),
                                        new IntegerResult(max),
                                        getDescriptorNames());
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.43457295013253217,  0.43457295013253217,  0.4478937362170006,  0.43457295013253217,121.0,0.599009900990099,121.0,0.599009900990099,129.0,0.6386138613861386,121.0,0.599009900990099,0.0,0.0,13.0,0.10236220472440945,0.0,0.0,13.0,0.8125,2.0,0.125,11.0,0.6875
347,cdk,"public static CDKRGraph buildRGraph(IAtomContainer sourceGraph, IAtomContainer targetGraph, boolean shouldMatchBonds) throws CDKException{
    CDKRGraph rGraph = new CDKRGraph();
    nodeConstructor(rGraph, sourceGraph, targetGraph, shouldMatchBonds);
    arcConstructor(rGraph, sourceGraph, targetGraph);
    return rGraph;
}",buildRGraph,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,"/**
     * Builds the CDKRGraph ( resolution graph ), from two atomContainer
     * (description of the two molecules to compare)
     * This is the interface point between the CDK model and
     * the generic MCSS algorithm based on the RGRaph.
     *
     * @param  sourceGraph  Description of the first molecule
     * @param  targetGraph  Description of the second molecule
     * @param shouldMatchBonds
     * @return     the rGraph
     * @throws CDKException
     */",437-455,"('buildRGraph', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",49.0,39.0,"Builds the CDKRGraph ( resolution graph ), from two atomContainer  (description of the two molecules to compare)  This is the interface point between the CDK model and  the generic MCSS algorithm based on the RGRaph.",Starting from to atomContainer build the resolution graph CDKRGraph.,The interface point between the CDK model and the generic MCSS algorithm is built from two atomContainers.,0.555313444624081,"Builds the CDKRGraph (resolution graph), from two atomContainer (description of the two molecules to be compared) This is the interface point between the CDK model and the generic MCSS algorithm based on the RGRaph."," public static CDKRGraph buildRGraph(IAtomContainer sourceGraph, IAtomContainer targetGraph, boolean shouldMatchBonds) throws CDKException{
        CDKRGraph rGraph = new CDKRGraph();
        rGraph.setSource(sourceGraph);
        rGraph.setTarget(targetGraph);
        rGraph.setShouldMatchBonds(shouldMatchBonds);
        rGraph.setAtomMap(getAtomMap(sourceGraph, targetGraph, shouldMatchBonds));
        rGraph.setBondMap(getBondMap(sourceGraph, targetGraph, shouldMatchBonds));
        return rGraph;
    }"," public static CDKRGraph buildRGraph(IAtomContainer sourceGraph, IAtomContainer targetGraph, boolean shouldMatchBonds) throws CDKException{
        CDKRGraph rGraph = new CDKRGraph(sourceGraph, targetGraph, shouldMatchBonds);
        return rGraph;
    }"," public static CDKRGraph buildRGraph(IAtomContainer sourceGraph, IAtomContainer targetGraph, boolean shouldMatchBonds) throws CDKException{
        CDKRGraph rGraph = new CDKRGraph(sourceGraph, targetGraph, shouldMatchBonds);
        return rGraph;
    }"," public static CDKRGraph buildRGraph(IAtomContainer sourceGraph, IAtomContainer targetGraph, boolean shouldMatchBonds) throws CDKException{
        CDKRGraph rGraph = new CDKRGraph(sourceGraph, targetGraph, shouldMatchBonds);
        return rGraph;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7360506877991808,  0.5914554128558329,  0.5914554128558329,  0.5914554128558329,34.0,0.43037974683544306,15.0,0.3,15.0,0.3,15.0,0.3,44.0,0.5569620253164557,44.0,0.5569620253164557,44.0,0.5569620253164557,32.0,0.8888888888888888,6.0,0.16666666666666666,25.0,0.6944444444444444
348,cdk,"public int indexOf(Object o){
    IAtomContainer atomContainer = (IAtomContainer) o;
    if (!atomContainer.getTitle().equals(title))
        return -1;
    if (atomContainer.getAtomCount() != this.atomContainer.getAtomCount())
        return -1;
    boolean coordsMatch;
    int index = 0;
    for (Point3d[] coords : coordinates) {
        coordsMatch = true;
        for (int i = 0; i < atomContainer.getAtomCount(); i++) {
            Point3d p = atomContainer.getAtom(i).getPoint3d();
            if (!(p.x == coords[i].x && p.y == coords[i].y && p.z == coords[i].z)) {
                coordsMatch = false;
                break;
            }
        }
        if (coordsMatch)
            return index;
        index++;
    }
    return -1;
}",indexOf,org/openscience/cdk/ConformerContainer.java,/base/data/src/main/java/org/openscience/cdk/ConformerContainer.java,"/**
     * Returns the lowest index at which the specific IAtomContainer appears in the list or -1 if is not found.
     * 
     * A given IAtomContainer will occur in the list if the title matches the stored title for
     * the conformers in this container and if the coordinates for each atom in the specified molecule
     * are equal to the coordinates of the corresponding atoms in a conformer.
     *
     * @param o The IAtomContainer whose presence is being tested
     * @return The index where o was found
     */",366-398,"('indexOf', {'INSTRUCTION': {'covered': 78, 'missed': 4}, 'BRANCH': {'covered': 12, 'missed': 4}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",172.0,20.0,Returns the lowest index at which the specific IAtomContainer appears in the list or -1 if is not found.,"Given an IAtomContainer, returns the lowest index of appearence of that atom or -1 if the atom is not present","If the IAtomContainer is not found, the lowest index will be -1.",0.283459770170359,Returns the lowest index at which the specific IAtomContainer appears in the list or -1 if it cannot be found.,"public int indexOf(Object o){
        IAtomContainer atomContainer = (IAtomContainer) o;
        for (int i = 0; i < size(); i++) {
            if (get(i).equals(atomContainer)) return i;
        }
        return -1;
    }","public int indexOf(Object o){
        IAtomContainer atomContainer = (IAtomContainer) o;
        for (int i = 0; i < coordinates.size(); i++) {
            Point3d[] tmp = coordinates.get(i);
            for (int j = 0; j < atomContainer.getAtomCount(); j++) {
                IAtom atom = atomContainer.getAtom(j);
                if (atom.getPoint3d().equals(tmp[j])) return i;
            }
        }
        return -1;
    }","public int indexOf(Object o){
        IAtomContainer atomContainer = (IAtomContainer) o;
        Point3d[] tmp = getCoordinateList(atomContainer);
        for (int i = 0; i < coordinates.size(); i++) {
            if (Arrays.equals(coordinates.get(i), tmp)) return i;
        }
        return -1;
    }","public int indexOf(Object o){
        IAtomContainer atomContainer = (IAtomContainer) o;
        Point3d[] tmp = getCoordinateList(atomContainer);
        for (int i = 0; i < coordinates.size(); i++) {
            if (Arrays.equals(coordinates.get(i), tmp))
                return i;
        }
        return -1;
    }",NOT PASS,PASS,NOT PASS,NOT PASS,  0.23132461395985326,  0.385997788194098,  0.29015999882936694,  0.29015999882936694,125.0,0.7225433526011561,106.0,0.6127167630057804,120.0,0.6936416184971098,120.0,0.6936416184971098,51.0,0.49514563106796117,22.0,0.30985915492957744,22.0,0.30985915492957744,16.0,0.7619047619047619,3.0,0.14285714285714285,17.0,0.85
350,cdk,"private String cansmi(IAtomContainer mol, int[] ordering) throws CDKException{
    Integer[] hcntBackup = new Integer[mol.getAtomCount()];
    Map<IAtom, Integer> idxs = new HashMap<>();
    for (int i = 0; i < mol.getAtomCount(); i++) {
        hcntBackup[i] = mol.getAtom(i).getImplicitHydrogenCount();
        idxs.put(mol.getAtom(i), i);
    }
    int[] bondedValence = new int[mol.getAtomCount()];
    for (int i = 0; i < mol.getBondCount(); i++) {
        IBond bond = mol.getBond(i);
        bondedValence[idxs.get(bond.getBegin())] += bond.getOrder().numeric();
        bondedValence[idxs.get(bond.getEnd())] += bond.getOrder().numeric();
    }
    for (int i = 0; i < mol.getAtomCount(); i++) {
        IAtom atom = mol.getAtom(i);
        atom.setImplicitHydrogenCount(0);
        switch(atom.getAtomicNumber()) {
            case 5:
                if (bondedValence[i] <= 3)
                    atom.setImplicitHydrogenCount(3 - bondedValence[i]);
                break;
            case 6:
                if (bondedValence[i] <= 4)
                    atom.setImplicitHydrogenCount(4 - bondedValence[i]);
                break;
            case 7:
            case 15:
                if (bondedValence[i] <= 3)
                    atom.setImplicitHydrogenCount(3 - bondedValence[i]);
                else if (bondedValence[i] <= 5)
                    atom.setImplicitHydrogenCount(5 - bondedValence[i]);
                break;
            case 8:
                if (bondedValence[i] <= 2)
                    atom.setImplicitHydrogenCount(2 - bondedValence[i]);
                break;
            case 16:
                if (bondedValence[i] <= 2)
                    atom.setImplicitHydrogenCount(2 - bondedValence[i]);
                else if (bondedValence[i] <= 4)
                    atom.setImplicitHydrogenCount(4 - bondedValence[i]);
                else if (bondedValence[i] <= 6)
                    atom.setImplicitHydrogenCount(6 - bondedValence[i]);
                break;
            case 9:
            case 17:
            case 35:
            case 53:
                if (bondedValence[i] <= 1)
                    atom.setImplicitHydrogenCount(1 - bondedValence[i]);
                break;
            default:
                atom.setImplicitHydrogenCount(0);
                break;
        }
    }
    String smi = null;
    try {
        smi = smigen.create(mol, ordering);
    } finally {
        for (int i = 0; i < mol.getAtomCount(); i++) mol.getAtom(i).setImplicitHydrogenCount(hcntBackup[i]);
    }
    return smi;
}",cansmi,org/openscience/cdk/layout/IdentityTemplateLibrary.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/IdentityTemplateLibrary.java,"/**
     * Internal - create a canonical SMILES string temporarily adjusting to default
     * hydrogen count. This method may be moved to the SMILESGenerator in future.
     *
     * @param mol molecule
     * @param ordering ordering output
     * @return SMILES
     * @throws CDKException SMILES could be generate
     */",111-193,"('cansmi', {'INSTRUCTION': {'covered': 192, 'missed': 60}, 'BRANCH': {'covered': 18, 'missed': 15}, 'LINE': {'covered': 29, 'missed': 9}, 'COMPLEXITY': {'covered': 9, 'missed': 11}, 'METHOD': {'covered': 1, 'missed': 0}})",539.0,14.0,Internal - create a canonical SMILES string temporarily adjusting to default  hydrogen count.,The internal function creates a canonical SMILEY string after the adjustment of the hydrogen count.,The internal SMILES string temporarily adjusting to default hydrogen count.,0.389951683860561,Internal - create a canonical SMILES string that temporarily adjusts to the default hydrogen number.,"private String cansmi(IAtomContainer mol, int[] ordering) throws CDKException{
        IAtomContainer copy = mol.clone();
        for (IAtom atom : copy.atoms()) {
            if (atom.getImplicitHydrogenCount() == null)
                atom.setImplicitHydrogenCount(0);
        }
        return smigen.create(copy, ordering);
    }","private String cansmi(IAtomContainer mol, int[] ordering) throws CDKException{
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < mol.getAtomCount(); i++) {
            IAtom atom = mol.getAtom(ordering[i]);
            sb.append(atom.getSymbol());
            if (atom.getImplicitHydrogenCount() > 0) {
                sb.append(atom.getImplicitHydrogenCount());
            }
        }
        return smigen.create(sb.toString());
    }"," private String cansmi(IAtomContainer mol, int[] ordering) throws CDKException{
        String smiles = smigen.create(mol);
        if (smiles.contains(""@"")) {
            smiles = smiles.replace(""@"", ""H"");
        }
        return smiles;
    }","private String cansmi(IAtomContainer mol, int[] ordering) throws CDKException{
        IAtomContainer tmp = mol.getBuilder().newInstance(IAtomContainer.class, mol);
        for (int i = 0; i < ordering.length; i++) {
            tmp.setAtomAt(i, mol.getAtom(ordering[i]));
        }
        return smigen.create(tmp);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.08869484663996782,  0.1441466650992864,  0.14328308339351917,  0.06050704083277672,485.0,0.8981481481481481,453.0,0.8388888888888889,476.0,0.8814814814814815,501.0,0.9277777777777778,54.0,0.5192307692307693,41.0,0.5256410256410257,33.0,0.5,10.0,0.625,4.0,0.25,5.0,0.35714285714285715
351,cdk,"private static boolean queryAdjacencyAndOrder(IBond bond1, IBond bond2, IBond queryBond1, IBond queryBond2){
    IAtom centralAtom = null;
    IAtom centralQueryAtom = null;
    if (bond1.contains(bond2.getBegin())) {
        centralAtom = bond2.getBegin();
    } else if (bond1.contains(bond2.getEnd())) {
        centralAtom = bond2.getEnd();
    }
    if (queryBond1.contains(queryBond2.getBegin())) {
        centralQueryAtom = queryBond2.getBegin();
    } else if (queryBond1.contains(queryBond2.getEnd())) {
        centralQueryAtom = queryBond2.getEnd();
    }
    if (centralAtom != null && centralQueryAtom != null && ((IQueryAtom) centralQueryAtom).matches(centralAtom)) {
        IQueryAtom queryAtom1 = (IQueryAtom) queryBond1.getOther(centralQueryAtom);
        IQueryAtom queryAtom2 = (IQueryAtom) queryBond2.getOther(centralQueryAtom);
        IAtom atom1 = bond1.getOther(centralAtom);
        IAtom atom2 = bond2.getOther(centralAtom);
        if (queryAtom1.matches(atom1) && queryAtom2.matches(atom2) || queryAtom1.matches(atom2) && queryAtom2.matches(atom1)) {
            return true;
        } else {
            return false;
        }
    } else {
        return centralAtom == null && centralQueryAtom == null;
    }
}",queryAdjacencyAndOrder,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,"/**
     *  Determines if 2 bondA1 have 1 atom in common if second is atom query AtomContainer
     *  and wheter the order of the atoms is correct (atoms match).
     *
     * @param  bondA1  first bondA1
     * @param  bond2  second bondA1
     * @param queryBond1 first query bondA1
     * @param queryBond2 second query bondA1
     * @return    the symbol of the common atom or """" if the 2 bonds have no common atom
     */",966-1008,"('queryAdjacencyAndOrder', {'INSTRUCTION': {'covered': 89, 'missed': 4}, 'BRANCH': {'covered': 21, 'missed': 5}, 'LINE': {'covered': 19, 'missed': 1}, 'COMPLEXITY': {'covered': 10, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",246.0,29.0,Determines if 2 bondA1 have 1 atom in common if second is atom query AtomContainer  and wheter the order of the atoms is correct (atoms match).,"If two bondsA1 have an atom in common, return the atom or """" otherwise. It also returns if  the order of the atoms is correct.","If the second atom query is correct and the order of the atoms is correct, then the second bondA1 has 1 atom in common.",0.515923757632448,Determines whether 2 bondA1 have 1 atom in common if the second is atom query AtomContainer and the order of the atoms is correct (atom match).,"private static boolean queryAdjacencyAndOrder(IBond bond1, IBond bond2, IBond queryBond1, IBond queryBond2){
        IAtom atom1 = null;
        IAtom atom2 = null;
    
        if (bond1.contains(bond2.getBegin())) {
            atom1 = bond2.getBegin();
        } else if (bond1.contains(bond2.getEnd())) {
            atom1 = bond2.getEnd();
        }
    
        if (queryBond1.contains(queryBond2.getBegin())) {
            atom2 = queryBond2.getBegin();
        } else if (queryBond1.contains(queryBond2.getEnd())) {
            atom2 = queryBond2.getEnd();
        }
    
        if (atom1 != null && atom2 != null) {
            // well, this looks fishy: the atom2 is not always atom IQueryAtom !
            return ((IQueryAtom) atom2).matches(atom1) && ((IQueryAtom) atom2).matches(queryBond1.getBegin());
        } else {
            return atom1 == null && atom2 == null;
        }
    
    }","private static boolean queryAdjacencyAndOrder(IBond bond1, IBond bond2, IBond queryBond1, IBond queryBond2){
        IAtom atom1 = null;
        IAtom atom2 = null;
    
        if (bond1.contains(bond2.getBegin())) {
            atom1 = bond2.getBegin();
        } else if (bond1.contains(bond2.getEnd())) {
            atom1 = bond2.getEnd();
        }
    
        if (queryBond1.contains(queryBond2.getBegin())) {
            atom2 = queryBond2.getBegin();
        } else if (queryBond1.contains(queryBond2.getEnd())) {
            atom2 = queryBond2.getEnd();
        }
    
        if (atom1 != null && atom2 != null) {
            // well, this looks fishy: the atom2 is not always atom IQueryAtom !
            return ((IQueryAtom) atom2).matches(atom1) && queryBond1.getOrder().equals(queryBond2.getOrder());
        } else {
            return atom1 == null && atom2 == null;
        }
    }","private static boolean queryAdjacencyAndOrder(IBond bond1, IBond bond2, IBond queryBond1, IBond queryBond2){
        if (queryAdjacency(bond1, bond2, queryBond1, queryBond2)){
            if (bond1.getOrder() == queryBond1.getOrder() && bond2.getOrder() == queryBond2.getOrder()){
                return true;
            }
        }
        return false;
    }","private static boolean queryAdjacencyAndOrder(IBond bond1, IBond bond2, IBond queryBond1, IBond queryBond2){
        if(!queryAdjacency(bond1, bond2, queryBond1, queryBond2)) return false;
        if(!queryBond1.getOrder().equals(queryBond2.getOrder())) return false;
        return true;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6040061969968901,  0.5984894190532296,  0.14507421242495888,  0.15478394209665802,87.0,0.3522267206477733,87.0,0.3522267206477733,199.0,0.805668016194332,192.0,0.7773279352226721,8.0,0.04519774011299435,132.0,0.7457627118644068,127.0,0.7175141242937854,19.0,0.7037037037037037,4.0,0.14814814814814814,24.0,0.8888888888888888
352,acs-aem-commons,"private String replaceInString(String input, Map<String, Object> contentVariableReplacements){
    final List<String> keys = ContentVariableReplacementUtil.getKeys(input);
    for (String key : keys) {
        if (ContentVariableReplacementUtil.hasKey(contentVariableReplacements, key)) {
            String replaceValue = (String) ContentVariableReplacementUtil.getValue(contentVariableReplacements, key);
            input = ContentVariableReplacementUtil.doReplacement(input, key, replaceValue, propertyConfigService.getAction(key));
        }
    }
    return input;
}",replaceInString,com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,/bundle/src/main/java/com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,"/**
     * Reusable method to replace placeholders in the input string./
     *
     * @param input String input
     * @param contentVariableReplacements current map of content variables
     * @return The replaced or original String
     */",219-236,"('replaceInString', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,10.0,Reusable method to replace placeholders in the input string.,The function can replace placeholders in the input string.,The method is re-usable.,1.08896028615545,A reusable method for replacing placeholders in the input string.," private String replaceInString(String input, Map<String, Object> contentVariableReplacements){
        String replaced = input;
        for (Map.Entry<String, Object> entry : contentVariableReplacements.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();
            if (value != null) {
                replaced = replaced.replaceAll(key, value.toString());
            }
        }
        return replaced;
    }"," private String replaceInString(String input, Map<String, Object> contentVariableReplacements){
        String output = input;
        for (Map.Entry<String, Object> entry : contentVariableReplacements.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();
            if (value != null) {
                output = output.replaceAll(""\\$\\{"" + key + ""\\}"", value.toString());
            }
        }
        return output;
    }"," private String replaceInString(String input, Map<String, Object> contentVariableReplacements){
        String output = input;
        for (Map.Entry<String, Object> entry : contentVariableReplacements.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();
            if (value != null) {
                output = output.replaceAll(""\\$\\{"" + key + ""\\}"", value.toString());
            }
        }
        return output;
    }"," private String replaceInString(String input, Map<String, Object> contentVariableReplacements){
        String replaced = input;
        for (Map.Entry<String, Object> entry : contentVariableReplacements.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();
            if (value != null) {
                replaced = replaced.replaceAll(key, value.toString());
            }
        }
        return replaced;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.34379565006335966,  0.3414976940083771,  0.34379565006335966,  0.3414976940083771,54.0,0.5869565217391305,54.0,0.5869565217391305,54.0,0.5869565217391305,54.0,0.5869565217391305,8.0,0.08791208791208792,0.0,0.0,8.0,0.08791208791208792,3.0,0.3,4.0,0.36363636363636365,8.0,0.8
353,metrics,"public void unregister(String name){
    HealthCheck healthCheck;
    synchronized (lock) {
        healthCheck = healthChecks.remove(name);
        if (healthCheck instanceof AsyncHealthCheckDecorator) {
            ((AsyncHealthCheckDecorator) healthCheck).tearDown();
        }
    }
    if (healthCheck != null) {
        onHealthCheckRemoved(name, healthCheck);
    }
}",unregister,io/dropwizard/metrics5/health/HealthCheckRegistry.java,/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/HealthCheckRegistry.java,"/**
     * Unregisters the application {@link HealthCheck} with the given name.
     *
     * @param name the name of the {@link HealthCheck} instance
     */",112-128,"('unregister', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,13.0,Unregisters the application {@link HealthCheck} with the given name.,"Given a name, unregisters the application HealthCheck that has that name.",The application is not registered with the given name.,0.159115782741925,Unregisters the application {@link HealthCheck} with the given name.," public void unregister(String name){
        HealthCheck removed;
        synchronized (lock) {
            removed = healthChecks.remove(name);
        }
        onHealthCheckRemoved(name, removed);
    }"," public void unregister(String name){
        HealthCheck registered;
        synchronized (lock) {
            registered = healthChecks.remove(name);
        }
        if (registered != null) {
            onHealthCheckRemoved(name, registered);
        }
    }"," public void unregister(String name){
        synchronized (lock) {
            HealthCheck healthCheck = healthChecks.remove(name);
            if (healthCheck != null) {
                onHealthCheckRemoved(name, healthCheck);
            }
        }
    }"," public void unregister(String name){
        HealthCheck registered;
        synchronized (lock) {
            registered = healthChecks.remove(name);
        }
        if (registered != null) {
            onHealthCheckRemoved(name, registered);
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4685268019287532,  0.5853420041631756,  0.5853420041631756,  0.5878544891995741,30.0,0.4838709677419355,23.0,0.3709677419354839,23.0,0.3709677419354839,25.0,0.4032258064516129,11.0,0.2558139534883721,11.0,0.2558139534883721,15.0,0.36585365853658536,9.0,0.75,0.0,0.0,5.0,0.5
354,matsim-libs,"private static void createShipmentsFromServices(Carrier carrierWS, Carrier carrier){
    TreeMap<Id<CarrierService>, Id<Link>> depotServiceIsdeliveredFrom = new TreeMap<>();
    try {
        carrier.getSelectedPlan();
    } catch (Exception e) {
        throw new RuntimeException(""Carrier "" + carrier.getId() + "" has NO selectedPlan. --> CanNOT create a new carrier from solution"");
    }
    Collection<ScheduledTour> tours;
    try {
        tours = carrier.getSelectedPlan().getScheduledTours();
    } catch (Exception e) {
        throw new RuntimeException(""Carrier "" + carrier.getId() + "" has NO ScheduledTours. --> CanNOT create a new carrier from solution"");
    }
    for (ScheduledTour tour : tours) {
        Id<Link> depotForTour = tour.getVehicle().getLocation();
        for (TourElement te : tour.getTour().getTourElements()) {
            if (te instanceof ServiceActivity) {
                ServiceActivity act = (ServiceActivity) te;
                depotServiceIsdeliveredFrom.put(act.getService().getId(), depotForTour);
            }
        }
    }
    for (CarrierService carrierService : carrier.getServices().values()) {
        log.debug(""Converting CarrierService to CarrierShipment: "" + carrierService.getId());
        CarrierShipment carrierShipment = CarrierShipment.Builder.newInstance(Id.create(carrierService.getId().toString(), CarrierShipment.class), depotServiceIsdeliveredFrom.get(carrierService.getId()), carrierService.getLocationLinkId(), carrierService.getCapacityDemand()).setDeliveryServiceTime(carrierService.getServiceDuration()).setDeliveryTimeWindow(carrierService.getServiceStartTimeWindow()).setPickupTimeWindow(TimeWindow.newInstance(0.0, carrierService.getServiceStartTimeWindow().getEnd())).build();
        CarrierUtils.addShipment(carrierWS, carrierShipment);
    }
}",createShipmentsFromServices,org/matsim/contrib/freight/utils/FreightUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/utils/FreightUtils.java,"/**
	 * Transform all services from the existing carrier to the new carrier with
	 * shipments. The location of the depot from which the ""old"" carrier starts the
	 * tour to the service is used as fromLocation for the new Shipment.
	 *
	 * @param carrierWS the ""new"" carrier with Shipments
	 * @param carrier   the already existing carrier
	 */",264-308,"('createShipmentsFromServices', {'INSTRUCTION': {'covered': 105, 'missed': 16}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 26, 'missed': 4}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",316.0,14.0,Transform all services from the existing carrier to the new carrier with  shipments.,The function takes all services from the existing carrier and transform them with the shipment. The starting depot from the old carrier is used as fromLocatio for the new shipment.,All services should be transferred to the new carrier with shipments.,0.309582997409275,Transform all services from the existing carrier to the new carrier with shipments.," private static void createShipmentsFromServices(Carrier carrierWS, Carrier carrier){
	 		for (CarrierService carrierService : carrier.getServices().values()) {
 			log.debug(""Create CarrierShipment: "" + carrierService.toString());
 			CarrierUtils.addShipment(carrierWS, carrierService);
 		}
 	}"," private static void createShipmentsFromServices(Carrier carrierWS, Carrier carrier){
	 		for (CarrierService carrierService : carrier.getServices().values()) {
 			log.debug(""Copy CarrierService: "" + carrierService.toString());
 			CarrierUtils.addShipment(carrierWS, carrierService);
 		}
 	}"," private static void createShipmentsFromServices(Carrier carrierWS, Carrier carrier){
	 		for (CarrierService carrierService : carrier.getServices().values()) {
 			log.debug(""Create CarrierShipment: "" + carrierService.toString());
 			CarrierUtils.addShipment(carrierWS, carrierService);
 		}
 	}"," private static void createShipmentsFromServices(Carrier carrierWS, Carrier carrier){
	 		for (CarrierService carrierService : carrier.getServices().values()) {
 			log.debug(""Create CarrierShipment: "" + carrierService.toString());
 			CarrierUtils.addShipment(carrierWS, carrierService);
 		}
 	}",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.17825117810344332,  0.17751652251067565,  0.17825117810344332,  0.17825117810344332,266.0,0.8391167192429022,266.0,0.8391167192429022,266.0,0.8391167192429022,266.0,0.8391167192429022,1.0,0.018867924528301886,0.0,0.0,0.0,0.0,22.0,0.7096774193548387,0.0,0.0,6.0,0.42857142857142855
355,cdk,"void assign(IAtomContainer container, String[] symbs, EdgeToBondMap bonds, int[][] graph, Set<IBond> mmffArom){
    int[] contribution = new int[graph.length];
    int[] doubleBonds = new int[graph.length];
    Arrays.fill(doubleBonds, -1);
    setupContributionAndDoubleBonds(container, bonds, graph, contribution, doubleBonds);
    int[][] cycles = findAromaticRings(cyclesOfSizeFiveOrSix(container, graph), contribution, doubleBonds);
    for (int[] cycle : cycles) {
        int len = cycle.length - 1;
        if (len == 6) {
            updateAromaticTypesInSixMemberRing(cycle, symbs);
        }
        if (len == 5 && normaliseCycle(cycle, contribution)) {
            updateAromaticTypesInFiveMemberRing(cycle, symbs);
        }
        // mark aromatic bonds
        for (int i = 1; i < cycle.length; i++) mmffArom.add(bonds.get(cycle[i], cycle[i - 1]));
    }
}",assign,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,"/**
     * Given the assigned preliminary MMFF atom types (symbs[]) update these to the aromatic types.
     * To begin, all the 5 and 6 member aromatic cycles are discovered. The symbolic types of five
     * and six member cycles are then update with {@link #updateAromaticTypesInFiveMemberRing(int[],
     * String[])} and {@link #updateAromaticTypesInSixMemberRing(int[], String[])}.
     *
     * @param container structure representation
     * @param symbs     vector of symbolic types for the whole structure
     * @param bonds     edge to bond map lookup
     * @param graph     adjacency list graph representation of structure
     * @param mmffArom  set of bonds that are aromatic
     */",78-111,"('assign', {'INSTRUCTION': {'covered': 84, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",194.0,19.0,Given the assigned preliminary MMFF atom types (symbs[]) update these to the aromatic types.,"Given a preliminary MMFF atom types, update them to the aromatic ones. It starts finding the 5 and 6 member aromatic types, that are then updated with updateAromaticTypesInFiveMemberRing and updateAromaticTypesInSixMemberRing.",Update the MMFF atom types to the aromatic types.,0.58834253527078,"Given the assigned preliminary MMFF atom types (symbs[]), update them for aromatic types.","void assign(IAtomContainer container, String[] symbs, EdgeToBondMap bonds, int[][] graph, Set<IBond> mmffArom){
        // find the aromatic rings
        int[] ringSizes = findAromaticRings(graph, bonds, mmffArom);
    
        // update the aromatic types in the rings
        updateAromaticTypesInSixMemberRing(ringSizes, symbs);
        updateAromaticTypesInFiveMemberRing(ringSizes, symbs);
    
        // update the atom types
        for (int i = 0; i < container.getAtomCount(); i++) {
            container.getAtom(i).setSymbol(symbs[i]);
        }
    }","void assign(IAtomContainer container, String[] symbs, EdgeToBondMap bonds, int[][] graph, Set<IBond> mmffArom){
        // find the 5 and 6 member aromatic rings
        int[] fiveMemberRings = findAromaticRings(graph, symbs, bonds);
        int[] sixMemberRings = findAromaticRings(graph, symbs, bonds, fiveMemberRings);
    
        // update the 5 and 6 member aromatic rings
        updateAromaticTypesInFiveMemberRing(fiveMemberRings, symbs);
        updateAromaticTypesInSixMemberRing(sixMemberRings, symbs);
    
        // update the preliminary MMFF atom types
        updatePreliminaryTypes(container, symbs, mmffArom);
    }","void assign(IAtomContainer container, String[] symbs, EdgeToBondMap bonds, int[][] graph, Set<IBond> mmffArom){
        // find the aromatic rings
        int[] ringSizes = findAromaticRings(graph, symbs, bonds);
    
        // update the aromatic types in the rings
        for (int i = 0; i < ringSizes.length; i++) {
            if (ringSizes[i] == 6) {
                updateAromaticTypesInSixMemberRing(graph, symbs, i);
            } else if (ringSizes[i] == 5) {
                updateAromaticTypesInFiveMemberRing(graph, symbs, i);
            }
        }
    
        // update the MMFF atom types
        for (int i = 0; i < symbs.length; i++) {
            if (symbs[i].startsWith(""AROM"")) {
                symbs[i] = symbs[i].substring(4);
            }
        }
    }","void assign(IAtomContainer container, String[] symbs, EdgeToBondMap bonds, int[][] graph, Set<IBond> mmffArom){
        // find the aromatic rings
        int[] ringSizes = findAromaticRings(graph, bonds, mmffArom);
    
        // update the aromatic types in the rings
        updateAromaticTypesInSixMemberRing(ringSizes, symbs);
        updateAromaticTypesInFiveMemberRing(ringSizes, symbs);
    
        // update the preliminary MMFF atom types
        for (int i = 0; i < container.getAtomCount(); i++) {
            IAtom atom = container.getAtom(i);
            String sym = symbs[i];
            if (sym.startsWith(""AROM"")) {
                sym = sym.substring(4);
                atom.setSymbol(sym);
            }
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3181492593870569,  0.2900960847426568,  0.3550855730960919,  0.3653421519374203,123.0,0.6307692307692307,129.0,0.6615384615384615,128.0,0.6564102564102564,119.0,0.6102564102564103,43.0,0.46236559139784944,33.0,0.2682926829268293,73.0,0.4866666666666667,24.0,0.7741935483870968,4.0,0.26666666666666666,6.0,0.4
357,jackson-databind,"public static void closeOnFailAndThrowAsIOE(JsonGenerator g, Exception fail) throws IOException{
    g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);
    try {
        g.close();
    } catch (Exception e) {
        fail.addSuppressed(e);
    }
    throwIfIOE(fail);
    throwIfRTE(fail);
    throw new RuntimeException(fail);
}",closeOnFailAndThrowAsIOE,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * Helper method that encapsulate logic in trying to close output generator
     * in case of failure; useful mostly in forcing flush()ing as otherwise
     * error conditions tend to be hard to diagnose. However, it is often the
     * case that output state may be corrupt so we need to be prepared for
     * secondary exception without masking original one.
     *
     * @since 2.8
     */",480-504,"('closeOnFailAndThrowAsIOE', {'INSTRUCTION': {'covered': 25, 'missed': 8}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 4}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,35.0,Helper method that encapsulate logic in trying to close output generator  in case of failure; useful mostly in forcing flush()ing as otherwise  error conditions tend to be hard to diagnose.,The method encapsulates the logic when it tries to close the output generator if there is a failure. In that case it helps in forcing the flushing the error condition that are difficult to diagnose.,The method that helps in closing the output generator in case of failure is useful in forcing flush and other error conditions to be diagnosed.,0.607141068184654,"Assistive method that encapsulates the logic by trying to close the output generator in case of failure; useful mainly for forcing rinsing, because otherwise error conditions tend to be difficult to diagnose."," public static void closeOnFailAndThrowAsIOE(JsonGenerator g, Exception fail) throws IOException{
        if (g != null) {
            try {
                g.close();
            } catch (IOException e) {
                fail.addSuppressed(e);
            }
        }
        throw fail;
    }"," public static void closeOnFailAndThrowAsIOE(JsonGenerator g, Exception fail) throws IOException{
        if(g != null){
            try{
                g.close();
            }catch(Exception e){
                fail.addSuppressed(e);
            }
        }
        throwAsIOE(fail);
    }"," public static void closeOnFailAndThrowAsIOE(JsonGenerator g, Exception fail) throws IOException{
        if (g != null) {
            try {
                g.close();
            } catch (IOException e) {
                fail.addSuppressed(e);
                throw e;
            }
        }
    }"," public static void closeOnFailAndThrowAsIOE(JsonGenerator g, Exception fail) throws IOException{
        if (g != null) {
            try {
                g.close();
            } catch (IOException e) {
                fail.addSuppressed(e);
                throw e;
            }
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6112211827442822,  0.6772569972060163,  0.5612328836880471,  0.5612328836880471,24.0,0.3582089552238806,22.0,0.3283582089552239,27.0,0.40298507462686567,27.0,0.40298507462686567,4.0,0.07692307692307693,5.0,0.1,5.0,0.1,25.0,0.6944444444444444,10.0,0.30303030303030304,16.0,0.5161290322580645
358,cdk,"private static IAtomContainer clearHydrogenCounts(IAtomContainer container){
    for (IAtom atom : container.atoms()) atom.setImplicitHydrogenCount(0);
    return container;
}",clearHydrogenCounts,org/openscience/cdk/layout/StructureDiagramGenerator.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/StructureDiagramGenerator.java,"/**
     * Simple helper function that sets all hydrogen counts to 0.
     *
     * @param container a structure representation
     * @return the input container
     */",1662-1672,"('clearHydrogenCounts', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,11.0,Simple helper function that sets all hydrogen counts to 0.,Resets to 0 all the counts of the hydrogen.,The function sets all hydrogen counts to 0.,0.691717655574184,Simple assistance function that sets all hydrogen counts to 0.,"private static IAtomContainer clearHydrogenCounts(IAtomContainer container){
        for (IAtom atom : container.atoms()) {
            if (atom.getAtomicNumber() != null)
                atom.setImplicitHydrogenCount(0);
        }
        return container;       
 }","private static IAtomContainer clearHydrogenCounts(IAtomContainer container){
        for (IAtom atom : container.atoms()) {
            if (isHydrogen(atom)) {
                atom.setImplicitHydrogenCount(0);
            }
        }
        return container;       
 }","private static IAtomContainer clearHydrogenCounts(IAtomContainer container){
        for (IAtom atom : container.atoms()) {
            if (atom.getAtomicNumber() == 1) {
                atom.setImplicitHydrogenCount(0);
            }
        }
        return container;       
 }","private static IAtomContainer clearHydrogenCounts(IAtomContainer container){
        for (IAtom atom : container.atoms())
            if (atom.getAtomicNumber() == 1)
                atom.setImplicitHydrogenCount(0);
        return container;       
 }",PASS,PASS,PASS,PASS,  0.842818124437416,  0.8352406204248135,  0.8748902505359201,  0.8240384821938889,12.0,0.2727272727272727,11.0,0.2558139534883721,10.0,0.23809523809523808,14.0,0.30434782608695654,8.0,0.18181818181818182,4.0,0.09090909090909091,4.0,0.08695652173913043,9.0,0.8181818181818182,1.0,0.09090909090909091,3.0,0.2727272727272727
359,cdk,"public static String diff(IChemObject first, IChemObject second){
    IDifference diff = difference(first, second);
    if (diff == null) {
        return """";
    } else {
        return diff.toString();
    }
}",diff,org/openscience/cdk/tools/diff/AtomDiff.java,/misc/diff/src/main/java/org/openscience/cdk/tools/diff/AtomDiff.java,"/**
     * Compare two {@link IChemObject} classes and return the difference as a {@link String}.
     *
     * @param first  the first of the two classes to compare
     * @param second the second of the two classes to compare
     * @return a {@link String} representation of the difference between the first and second {@link IChemObject}.
     */",45-59,"('diff', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,20.0,Compare two {@link IChemObject} classes and return the difference as a {@link String}.,Returns the difference as a String between two IChemObject classes.,You can compare two classes and return a different result.,0.236781027046564,Compare two {@link IChemObject} classes and return the difference as a {@link String}.," public static String diff(IChemObject first, IChemObject second){
        ChemObjectDifference diff = diff(first, second);
        return diff.toString();     
 }"," public static String diff(IChemObject first, IChemObject second){
        StringBuffer sb = new StringBuffer();
        diff(first, second, sb);
        return sb.toString();       
 }",Not Valid," public static String diff(IChemObject first, IChemObject second){
        StringBuffer sb = new StringBuffer();
        diff(first, second, sb);
        return sb.toString();       
 }",NOT PASS,NOT PASS,NOT PASS,Not Valid,  0.5636858827600711,  0.48738839495423375,  0.48738839495423375,None,16.0,0.35555555555555557,20.0,0.4444444444444444,20.0,0.4444444444444444,None,None,10.0,0.2631578947368421,10.0,0.2631578947368421,None,None,12.0,0.8571428571428571,0.0,0.0,9.0,0.6428571428571429
360,cdk,"private static IAtom findPiBondedOxygen(IAtomContainer container, IAtom atom){
    for (IBond bond : container.getConnectedBondsList(atom)) {
        if (bond.getOrder() == IBond.Order.DOUBLE) {
            IAtom neighbor = bond.getOther(atom);
            int charge = neighbor.getFormalCharge() == null ? 0 : neighbor.getFormalCharge();
            if (neighbor.getAtomicNumber() == 8 && charge == 0)
                return neighbor;
        }
    }
    return null;
}",findPiBondedOxygen,org/openscience/cdk/graph/invariant/InChINumbersTools.java,/storage/inchi/src/main/java/org/openscience/cdk/graph/invariant/InChINumbersTools.java,"/**
     * Find a neutral oxygen bonded to the {@code atom} with a pi bond.
     *
     * @param container the container
     * @param atom      an atom from the container
     * @return a pi bonded oxygen (or null if not found)
     */",206-222,"('findPiBondedOxygen', {'INSTRUCTION': {'covered': 37, 'missed': 4}, 'BRANCH': {'covered': 6, 'missed': 4}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,17.0,Find a neutral oxygen bonded to the {@code atom} with a pi bond.,"Given the atom, return a pi bonded oxygen, or null if not found.",A neutral oxygen bond is found to the @code atom.,1.01572351097496,Find a neutral oxygen bound to the atom {@code} with a pi bond.,"private static IAtom findPiBondedOxygen(IAtomContainer container, IAtom atom){
        for (IAtom connected : container.getConnectedAtomsList(atom)) {
            if (connected.getAtomicNumber() == 8 && connected.getFormalCharge() == 0)
                return connected;
        }
        return null;
    }","private static IAtom findPiBondedOxygen(IAtomContainer container, IAtom atom){
        for (IAtom connected : container.getConnectedAtomsList(atom)) {
            if (connected.getAtomicNumber() == 8 && connected.getFormalCharge() == 0) {
                if (container.getConnectedBondsCount(connected) == 1) {
                    IBond bond = container.getConnectedBondsList(connected).get(0);
                    if (bond.getOrder() == IBond.Order.PI) return connected;
                }
            }
        }
        return null;        
 }","private static IAtom findPiBondedOxygen(IAtomContainer container, IAtom atom){
        for (IAtom neighbor : container.getConnectedAtomsList(atom)) {
            if (neighbor.getAtomicNumber() == 8 && neighbor.getFormalCharge() == 0) {
                return neighbor;
            }
        }
        return null;        
 }","private static IAtom findPiBondedOxygen(IAtomContainer container, IAtom atom){
        for (IAtom neighbor : container.getConnectedAtomsList(atom)) {
            if (neighbor.getAtomicNumber() == 8 && neighbor.getFormalCharge() == 0) {
                if (container.getBond(atom, neighbor).getOrder() == IBond.Order.PI)
                    return neighbor;
            }
        }
        return null;
    }",PASS,NOT PASS,NOT PASS,PASS,  0.3977072791147718,  0.5833333186799953,  0.5651872469079668,  0.4252585646246487,50.0,0.5376344086021505,45.0,0.46875,43.0,0.46236559139784944,47.0,0.5053763440860215,44.0,0.4583333333333333,27.0,0.36,6.0,0.1111111111111111,13.0,0.9285714285714286,3.0,0.21428571428571427,11.0,0.7857142857142857
361,cdk,"private IChemFile readChemFile(IChemFile chemFile) throws CDKException{
    IChemSequence chemSequence = chemFile.getBuilder().newInstance(IChemSequence.class);
    IChemModel chemModel = chemFile.getBuilder().newInstance(IChemModel.class);
    chemSequence.addChemModel(readChemModel(chemModel));
    chemFile.addChemSequence(chemSequence);
    return chemFile;
}",readChemFile,org/openscience/cdk/io/MDLRXNReader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLRXNReader.java,"/**
    * Read a ChemFile from a file in MDL RDF format.
    *
    * @param  chemFile The IChemFile
    * @return          The IChemFile that was read from the RDF file.
    */",177-190,"('readChemFile', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",63.0,11.0,Read a ChemFile from a file in MDL RDF format.,"Using a file in MDL RDF format, read a ChemFile",The file is in MDL RDF format.,0.324081389857139,Read a ChemFile from a file in RDF MDL format.," private IChemFile readChemFile(IChemFile chemFile) throws CDKException{
        IChemSequence chemSequence = chemFile.getBuilder().newInstance(IChemSequence.class);
        chemFile.setChemSequence(chemSequence);
        IChemSequence reactionSequence = chemFile.getBuilder().newInstance(IChemSequence.class);
        chemFile.setReactionSequence(reactionSequence);
        IChemSequence modelSequence = chemFile.getBuilder().newInstance(IChemSequence.class);
        chemFile.setModelSequence(modelSequence);
        String line;
        try {
            while ((line = input.readLine()) != null) {
                if (line.startsWith(""$RXN"")) {
                    IReaction reaction = readReaction(chemFile.getBuilder());
                    reactionSequence.addChemSequence(reaction);
                } else if (line.startsWith(""$MOL"")) {
                    IChemModel model = readChemModel(chemFile.getBuilder());
                    modelSequence.addChemSequence(model);
                } else if (line.startsWith(""$MDL"")) {
                    IChemModel model = readChemModel(chemFile.getBuilder());
                    modelSequence.addChemSequence(model);
                } else if (line.startsWith(""$END"")) {
                    break;
                }
            }
        } catch (IOException e) {
            throw new CDKException(""IOException while reading file: "" + e.getMessage(), e);
        }
        return chemFile;        
 }"," private IChemFile readChemFile(IChemFile chemFile) throws CDKException{
        IChemSequence chemSequence = chemFile.getBuilder().newInstance(IChemSequence.class);
        chemFile.setChemSequence(chemSequence);
        IChemSequence reactionSequence = chemFile.getBuilder().newInstance(IChemSequence.class);
        chemFile.setReactionSequence(reactionSequence);
        IChemSequence modelSequence = chemFile.getBuilder().newInstance(IChemSequence.class);
        chemFile.setModelSequence(modelSequence);
        String line;
        try {
            while ((line = input.readLine()) != null) {
                if (line.startsWith(""$RXN"")) {
                    IReaction reaction = readReaction(chemFile.getBuilder());
                    reactionSequence.addChemSequence(reaction);
                } else if (line.startsWith(""$MOL"")) {
                    IChemModel model = readChemModel(chemFile.getBuilder());
                    modelSequence.addChemSequence(model);
                } else if (line.startsWith(""$MDL"")) {
                    IChemModel model = readChemModel(chemFile.getBuilder());
                    modelSequence.addChemSequence(model);
                } else if (line.startsWith(""$END"")) {
                    break;
                }
            }
        } catch (IOException e) {
            throw new CDKException(""IOException while reading file: "" + e.getMessage(), e);
        }
        return chemFile;        
 }"," private IChemFile readChemFile(IChemFile chemFile) throws CDKException{
        IChemSequence chemSequence = chemFile.getBuilder().newInstance(IChemSequence.class);
        chemFile.setChemSequence(chemSequence);
        String line;
        try {
            while ((line = input.readLine()) != null) {
                if (line.startsWith(""$RXN"")) {
                    IReaction reaction = readReaction(chemFile.getBuilder());
                    chemSequence.addChemModel(reaction.getBuilder().newInstance(IChemModel.class, reaction));
                }
            }
        } catch (IOException exception) {
            throw new CDKException(""IOException while reading file: "" + exception.getMessage(), exception);
        }
        return chemFile;        
 }"," private IChemFile readChemFile(IChemFile chemFile) throws CDKException{
        IChemSequence chemSequence = chemFile.getBuilder().newInstance(IChemSequence.class);
        chemFile.setChemSequence(chemSequence);
        IChemModel chemModel = null;
        while (true) {
            try {
                String line = input.readLine();
                if (line == null) break;
                if (line.startsWith(""$RXN"")) {
                    chemModel = readReaction(chemFile.getBuilder());
                    chemSequence.addChemModel(chemModel);
                } else if (line.startsWith(""$MOL"")) {
                    chemModel = readMolecule(chemFile.getBuilder());
                    chemSequence.addChemModel(chemModel);
                } else if (line.startsWith(""$"")) {
                    // ignore
                } else {
                    logger.warn(""Unexpected line: "" + line);
                }
            } catch (IOException exception) {
                throw new CDKException(""IOException while reading file: "" + exception.getMessage(), exception);
            }
        }
        return chemFile;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6387012040447804,  0.6387012040447804,  0.6107072944902843,  0.6647882183200987,177.0,0.7564102564102564,177.0,0.7564102564102564,118.0,0.6781609195402298,73.0,0.584,0.0,0.0,100.0,0.42735042735042733,118.0,0.5042735042735043,8.0,0.7272727272727273,2.0,0.18181818181818182,6.0,0.5454545454545454
362,metrics,"public void dump(OutputStream output){
    try (PrintWriter out = new PrintWriter(new OutputStreamWriter(output, UTF_8))) {
        for (long value : values) {
            out.printf(""%d%n"", value);
        }
    }
}",dump,io/dropwizard/metrics5/UniformSnapshot.java,/metrics-core/src/main/java/io/dropwizard/metrics5/UniformSnapshot.java,"/**
     * Writes the values of the snapshot to the given stream.
     *
     * @param output an output stream
     */",164-176,"('dump', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,11.0,Writes the values of the snapshot to the given stream.,"Given a stream, the method writes the values of the snapshot in that stream.",The values of the snapshot are written.,0.358793915122853,Writes the snapshot values to the given stream.,"public void dump(OutputStream output){
        try (PrintWriter writer = new PrintWriter(new OutputStreamWriter(output, UTF_8))) {
            for (long value : values) {
                writer.println(value);
            }
        }
    }","public void dump(OutputStream output){
        try (PrintWriter writer = new PrintWriter(new OutputStreamWriter(output, UTF_8))) {
            for (long value : values) {
                writer.println(value);
            }
        }
    }","public void dump(OutputStream output){
        try (PrintWriter writer = new PrintWriter(new OutputStreamWriter(output, UTF_8))) {
            for (long value : values) {
                writer.println(value);
            }
        }
    }","public void dump(OutputStream output){
        try (PrintWriter writer = new PrintWriter(new OutputStreamWriter(output, UTF_8))) {
            for (long value : values) {
                writer.println(value);
            }
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7908285876544738,  0.7908285876544738,  0.7908285876544738,  0.7908285876544738,5.0,0.10638297872340426,5.0,0.10638297872340426,5.0,0.10638297872340426,5.0,0.10638297872340426,0.0,0.0,0.0,0.0,0.0,0.0,9.0,0.6,4.0,0.36363636363636365,6.0,0.5454545454545454
363,tablesaw,"StringColumn yearQuarter(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & quarter"");
    for (int r = 0; r < this.size(); r++) {
        int c1 = this.getIntInternal(r);
        if (DateColumn.valueIsMissing(c1)) {
            newColumn.appendMissing();
        } else {
            String yq = String.valueOf(PackedLocalDate.getYear(c1));
            yq = yq + ""-"" + Strings.padStart(String.valueOf(PackedLocalDate.getQuarter(c1)), 2, '0');
            newColumn.append(yq);
        }
    }
    return newColumn;
}",yearQuarter,tech/tablesaw/columns/dates/DateMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/dates/DateMapFunctions.java,"/**
   * Returns a StringColumn with the year and quarter from this column concatenated into a String
   * that will sort lexicographically in temporal order.
   *
   * <p>This simplifies the production of plots and tables that aggregate values into standard
   * temporal units (e.g., you want monthly data but your source data is more than a year long and
   * you don't want months from different years aggregated together).
   */",125-146,"('yearQuarter', {'INSTRUCTION': {'covered': 52, 'missed': 4}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",124.0,23.0,Returns a StringColumn with the year and quarter from this column concatenated into a String  that will sort lexicographically in temporal order.,Creates a StringColumn containing the year and the quarter and sort the column lexicographically in temporal order.,The year and quarter from this column will be used to sort the lexicographically in temporal order.,1.02300841287859,Returns a StringColumn with the year and quarter of this column concatenated into a String that will sort lexicographically in temporal order.,"StringColumn yearQuarter(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year quarter"");
    for (int r = 0; r < this.size(); r++) {
      int c1 = this.getIntInternal(r);
      if (DateColumn.valueIsMissing(c1)) {
        newColumn.appendMissing();
      } else {
        newColumn.append(PackedLocalDate.getYearQuarter(c1));
      }
    }
    return newColumn;
  }","StringColumn yearQuarter(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year quarter"");
    for (int r = 0; r < this.size(); r++) {
      int c1 = this.getIntInternal(r);
      if (DateColumn.valueIsMissing(c1)) {
        newColumn.appendMissing();
      } else {
        newColumn.append(PackedLocalDate.getYearQuarter(c1));
      }
    }
    return newColumn;
  }","StringColumn yearQuarter(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year quarter"");
    for (int r = 0; r < this.size(); r++) {
      int c1 = this.getIntInternal(r);
      if (DateColumn.valueIsMissing(c1)) {
        newColumn.appendMissing();
      } else {
        newColumn.append(PackedLocalDate.getYearQuarter(c1));
      }
    }
    return newColumn;
  }","StringColumn yearQuarter(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year quarter"");
    for (int r = 0; r < this.size(); r++) {
      int c1 = this.getIntInternal(r);
      if (DateColumn.valueIsMissing(c1)) {
        newColumn.appendMissing();
      } else {
        newColumn.append(PackedLocalDate.getYearQuarter(c1));
      }
    }
    return newColumn;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.64479699928551,  0.64479699928551,  0.64479699928551,  0.64479699928551,41.0,0.328,41.0,0.328,41.0,0.328,41.0,0.328,0.0,0.0,0.0,0.0,0.0,0.0,13.0,0.5652173913043478,1.0,0.043478260869565216,12.0,0.5217391304347826
364,metrics,"public void tick(){
    final long count = uncounted.sumThenReset();
    final double instantRate = count / interval;
    if (initialized) {
        final double oldRate = this.rate;
        rate = oldRate + (alpha * (instantRate - oldRate));
    } else {
        rate = instantRate;
        initialized = true;
    }
}",tick,io/dropwizard/metrics5/EWMA.java,/metrics-core/src/main/java/io/dropwizard/metrics5/EWMA.java,"/**
     * Mark the passage of time and decay the current rate accordingly.
     */",84-97,"('tick', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",64.0,12.0,Mark the passage of time and decay the current rate accordingly.,The function marks the time passed and decrease the current rate.,The current rate should be decayd according to the passage of time.,0.520690025044074,Mark the passage of time and disrupt the current rate accordingly.," public void tick(){
        if (initialized) {
            long count = uncounted.sumThenReset();
            long duration = interval;
            rate += alpha * (count - rate) / duration;
        } else {
            initialized = true;
        }
    }","public void tick(){
        long now = System.nanoTime();
        double elapsed = (now - lastTick) / 1.0e9;
        lastTick = now;
        rate = alpha * (rate * (1 - elapsed) + uncounted.sumThenReset() * 1.0e9 / interval);
    }"," public void tick(){
        if(!initialized){
            rate = uncounted.sum();
            initialized = true;
        }else{
            double instantRate = uncounted.sum();
            rate += (alpha * (instantRate - rate));
            uncounted.reset();
        }
    }"," public void tick(){
        if(!initialized){
            rate = uncounted.sum();
            initialized = true;
        }else{
            double instantRate = uncounted.sum();
            uncounted.reset();
            rate += (alpha * (instantRate - rate));
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.43253201103799344,  0.3314922260188452,  0.3556011222985914,  0.35111117993462415,35.0,0.5384615384615384,38.0,0.5846153846153846,44.0,0.676923076923077,38.0,0.5846153846153846,37.0,0.6607142857142857,34.0,0.5964912280701754,28.0,0.49122807017543857,8.0,0.6666666666666666,1.0,0.08333333333333333,11.0,0.8461538461538461
365,cdk,"static int[][] cyclesOfSizeFiveOrSix(IAtomContainer container, int[][] graph){
    try {
        return Cycles.all(6).find(container, graph, 6).paths();
    } catch (Intractable intractable) {
        return new int[0][];
    }
}",cyclesOfSizeFiveOrSix,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,"/**
     * Locate all 5 and 6 member cycles (rings) in a structure representation.
     *
     * @param container structure representation
     * @param graph     adjacency list graph representation of structure
     * @return closed walks (first = last vertex) of the cycles
     */",384-397,"('cyclesOfSizeFiveOrSix', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,15.0,Locate all 5 and 6 member cycles (rings) in a structure representation.,"It finds the 5 and 6 member cycles in the representation of the structure, called rings.",All 5 and 6 member cycles are in a structure representation.,0.487911270283485,Locate the cycles of 5 and 6 limbs (rings) in a structure representation.,"static int[][] cyclesOfSizeFiveOrSix(IAtomContainer container, int[][] graph){
        int[][] cycles = new int[][]{};
        int[] visited = new int[container.getAtomCount()];
        int[] stack = new int[container.getAtomCount()];
        int[] contribution = new int[container.getAtomCount()];
        int[] cycle = new int[container.getAtomCount()];
        int[] cycle2 = new int[container.getAtomCount()];
        int[] cycle3 = new int[container.getAtomCount()];
        int[] cycle4 = new int[container.getAtomCount()];
        int[] cycle5 = new int[container.getAtomCount()];
        int[] cycle6 = new int[container.getAtomCount()];
        int[] cycle7 = new int[container.getAtomCount()];
        int[] cycle8 = new int[container.getAtomCount()];
        int[] cycle9 = new int[container.getAtomCount()];
        int[] cycle10 = new int[container.getAtomCount()];
        int[] cycle11 = new int[container.getAtomCount()];
        int[] cycle12 = new int[container.getAtomCount()];
        int[] cycle13 = new int[container.getAtomCount()];
        int[] cycle14 = new int[container.getAtomCount()];
        int[] cycle15 = new int[container.getAtomCount()];
        int[] cycle16 = new int[container.getAtomCount()];
        int[] cycle17 = new int[container.getAtomCount()];
        int[] cycle18 = new int[container.getAtomCount()];
        int[] cycle19 = new int[container.getAtomCount()];
        int[] cycle20 = new int[container.getAtomCount()];
        int[] cycle21 = new int[container.getAtomCount()];
        int[] cycle22 = new int[container.getAtomCount()];
        int[] cycle23 = new int[container.getAtomCount()];
        int[] cycle24 = new int[container.getAtomCount()];
        int     
 }"," static int[][] cyclesOfSizeFiveOrSix(IAtomContainer container, int[][] graph){
        int[][] cycles = new int[][]{};
        int[][] rings = new int[][]{};
        int[][] ringsOfSizeFive = new int[][]{};
        int[][] ringsOfSizeSix = new int[][]{};
        int[][] ringsOfSizeSeven = new int[][]{};
        int[][] ringsOfSizeEight = new int[][]{};
        int[][] ringsOfSizeNine = new int[][]{};
        int[][] ringsOfSizeTen = new int[][]{};
        int[][] ringsOfSizeEleven = new int[][]{};
        int[][] ringsOfSizeTwelve = new int[][]{};
        int[][] ringsOfSizeThirteen = new int[][]{};
        int[][] ringsOfSizeFourteen = new int[][]{};
        int[][] ringsOfSizeFifteen = new int[][]{};
        int[][] ringsOfSizeSixteen = new int[][]{};
        int[][] ringsOfSizeSeventeen = new int[][]{};
        int[][] ringsOfSizeEighteen = new int[][]{};
        int[][] ringsOfSizeNineteen = new int[][]{};
        int[][] ringsOfSizeTwenty = new int[][]{};
        int[][] ringsOfSizeTwentyOne = new int[][]{};
        int[][] ringsOfSizeTwentyTwo = new int[][]{};
        int[][] ringsOfSizeTwentyThree = new int[][]{};
        int[][] ringsOfSizeTwentyFour = new int[][]{};
        int[][] ringsOfSizeTwentyFive = new int[][]{};
        int[][] ringsOfSizeTwentySix = new int[][]{};
        int[][] ringsOfSizeTwentySeven = new int[][]{};
        int[][] ringsOfSizeTwentyEight = new int[][]{};
        int[][] ringsOfSizeTwentyNine = new int[][]{};      
 }","static int[][] cyclesOfSizeFiveOrSix(IAtomContainer container, int[][] graph){
        int[][] cycles = new int[0][];
        for (int i = 0; i < graph.length; i++) {
            int[] cycle = graph[i];
            if (cycle.length == 5 || cycle.length == 6) {
                cycles = ArrayUtils.add(cycles, cycle);
            }
        }
        return cycles;
    }","static int[][] cyclesOfSizeFiveOrSix(IAtomContainer container, int[][] graph){
        int[][] cycles = new int[][]{};
        int[] visited = new int[container.getAtomCount()];
        int[] stack = new int[container.getAtomCount()];
        int[] parent = new int[container.getAtomCount()];
        int[] depth = new int[container.getAtomCount()];
        int[] contribution = new int[container.getAtomCount()];
        int[] cycle = new int[container.getAtomCount()];
        int[] cycle2 = new int[container.getAtomCount()];
        int[] cycle3 = new int[container.getAtomCount()];
        int[] cycle4 = new int[container.getAtomCount()];
        int[] cycle5 = new int[container.getAtomCount()];
        int[] cycle6 = new int[container.getAtomCount()];
        int[] cycle7 = new int[container.getAtomCount()];
        int[] cycle8 = new int[container.getAtomCount()];
        int[] cycle9 = new int[container.getAtomCount()];
        int[] cycle10 = new int[container.getAtomCount()];
        int[] cycle11 = new int[container.getAtomCount()];
        int[] cycle12 = new int[container.getAtomCount()];
        int[] cycle13 = new int[container.getAtomCount()];
        int[] cycle14 = new int[container.getAtomCount()];
        int[] cycle15 = new int[container.getAtomCount()];
        int[] cycle16 = new int[container.getAtomCount()];
        int[] cycle17 = new int[container.getAtomCount()];
        int[] cycle18 = new int[container.getAtomCount()];
        int[] cycle19 = new int[container.getAtomCount()];
        int[] cycle20 = new int[container.getAtomCount()];
        int[] cycle21 = new int[container.getAtomCount()];
        int[] cycle22 = new int[container.getAtomCount()];
        int[] cycle     
 }",Syntax Error,NOT PASS,Syntax Error,NOT PASS,None,  0.21902786521991902,None,  0.5208247598920867,None,None,420.0,0.9271523178807947,404.0,0.905829596412556,65.0,0.6914893617021277,244.0,0.5386313465783664,28.0,0.06278026905829596,384.0,0.8668171557562077,11.0,0.6470588235294118,5.0,0.35714285714285715,3.0,0.23076923076923078
366,shardingsphere-elasticjob,"public Map<String, String> toSingleValueMap(){
    return queryMap.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().get(0)));
}",toSingleValueMap,org/apache/shardingsphere/elasticjob/restful/wrapper/QueryParameterMap.java,/elasticjob-infra/elasticjob-restful/src/main/java/org/apache/shardingsphere/elasticjob/restful/wrapper/QueryParameterMap.java,"/**
     * Convert to a single value map, abandon values except the first of each parameter.
     *
     * @return single value map
     */",98-105,"('toSingleValueMap', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",50.0,16.0,"Convert to a single value map, abandon values except the first of each parameter.","Ignoring all the parameters but the first, convert them to a single value map.","Abandon values except the first one, if you want to convert to a single value map.",0.499489854916491,"Convert to a single value card, abandon the values except the first of each parameter.","public Map<String, String> toSingleValueMap(){
        return queryMap.entrySet().stream().collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue().get(0)));
    }","public Map<String, String> toSingleValueMap(){
        return queryMap.entrySet().stream().collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue().get(0)));
    }","public Map<String, String> toSingleValueMap(){
        return queryMap.entrySet().stream().collect(Collectors.toMap(
                entry -> entry.getKey(),
                entry -> entry.getValue().get(0)));
    }","public Map<String, String> toSingleValueMap(){
        return queryMap.entrySet().stream().collect(Collectors.toMap(
                entry -> entry.getKey(),
                entry -> entry.getValue().get(0)));
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8032176505042956,  0.8032176505042956,  0.8390348450828289,  0.8390348450828289,8.0,0.1509433962264151,8.0,0.1509433962264151,6.0,0.11320754716981132,6.0,0.11320754716981132,0.0,0.0,4.0,0.07547169811320754,4.0,0.07547169811320754,14.0,0.9333333333333333,2.0,0.125,16.0,0.9411764705882353
367,cdk,"private static IChemModel newModel(final IAtomContainer container){
    if (container == null)
        throw new NullPointerException(""cannot create chem model for a null container"");
    final IChemObjectBuilder builder = container.getBuilder();
    final IChemModel model = builder.newInstance(IChemModel.class);
    final IAtomContainerSet containers = builder.newInstance(IAtomContainerSet.class);
    containers.addAtomContainer(container);
    model.setMoleculeSet(containers);
    return model;
}",newModel,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Create a new chem model for a single {@link IAtomContainer}.
     *
     * @param container the container to create the model for
     * @return a new {@link IChemModel}
     */",283-301,"('newModel', {'INSTRUCTION': {'covered': 27, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,14.0,Create a new chem model for a single {@link IAtomContainer}.,"For the given IAtomContainer, create a new chem model.",A single CHEM model for a single IAtomContainer is needed.,0.285831928196952,Create a chemical template for a single {@link IAtomContainer}.," private static IChemModel newModel(final IAtomContainer container){
        IChemModel model = new ChemModel();
        model.setMoleculeSet(new AtomContainerSet());
        model.getMoleculeSet().addAtomContainer(container);
        return model;
    }"," private static IChemModel newModel(final IAtomContainer container){
        IChemModel model = new ChemModel();
        model.setMoleculeSet(new AtomContainerSet());
        model.getMoleculeSet().addAtomContainer(container);
        return model;
    }"," private static IChemModel newModel(final IAtomContainer container){
        IChemModel model = new ChemModel();
        model.setMoleculeSet(new AtomContainerSet());
        model.getMoleculeSet().addAtomContainer(container);
        return model;       
 }"," private static IChemModel newModel(final IAtomContainer container){
        IChemModel model = new ChemModel();
        model.setMoleculeSet(new AtomContainerSet());
        model.getMoleculeSet().addAtomContainer(container);
        return model;       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.28947870019470656,  0.28947870019470656,  0.28947870019470656,  0.28947870019470656,45.0,0.5769230769230769,45.0,0.5769230769230769,45.0,0.5769230769230769,45.0,0.5769230769230769,0.0,0.0,0.0,0.0,0.0,0.0,9.0,0.8181818181818182,3.0,0.2727272727272727,7.0,0.6363636363636364
368,cdk,"private int otherIndex(int i){
    IDoubleBondStereochemistry element = (IDoubleBondStereochemistry) queryElements[i];
    return queryMap.get(element.getStereoBond().getOther(query.getAtom(i)));
}",otherIndex,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,"/**
     * Given an index of an atom in the query get the index of the other atom in
     * the double bond.
     *
     * @param i query atom index
     * @return the other atom index involved in a double bond
     */",326-336,"('otherIndex', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",42.0,21.0,Given an index of an atom in the query get the index of the other atom in  the double bond.,"Returns the index of all the atoms in the double bond, starting from the index of an atom in the query.",The double bond's index of the other atom is given when you give an index of an atom.,0.545879831336274,"Given an index of one atom in the query, get the index of the other atom in the double bond.","private int otherIndex(int i){
        int j = 0;
        for (int k = 0; k < queryElements.length; k++) {
            if (queryElements[k] instanceof IDoubleBondStereochemistry) {
                if (j == i) {
                    return k;
                }
                j++;
            }
        }
        return -1;
    }","private int otherIndex(int i){
        int[] indices = new int[2];
        for (int j = 0; j < queryElements.length; j++) {
            if (queryElements[j] instanceof IDoubleBondStereochemistry) {
                IDoubleBondStereochemistry element = (IDoubleBondStereochemistry) queryElements[j];
                if (element.getStereoBond().contains(query.getAtom(i))) {
                    indices[0] = queryMap.get(element.getStereoBond().getBegin());
                    indices[1] = queryMap.get(element.getStereoBond().getEnd());
                }
            }
        }
        return indices[0] == i ? indices[1] : indices[0];
    }","private int otherIndex(int i){
        return i==0?1:0;
    }","private int otherIndex(int i){
        return ((IDoubleBondStereochemistry)queryElements[i]).getBonds()[0].getOther(query.getAtom(i)).getIndex();
    }",NOT PASS,PASS,NOT PASS,NOT PASS,  0.34217126561357475,  0.6371383853046312,  0.5464903476973171,  0.23928667483262786,44.0,0.7096774193548387,102.0,0.7338129496402878,15.0,0.3488372093023256,31.0,0.7209302325581395,91.0,0.6546762589928058,43.0,0.6935483870967742,49.0,0.7903225806451613,13.0,0.5909090909090909,2.0,0.09523809523809523,18.0,0.8571428571428571
369,cdk,"public Iterable<IIsotope> isotopes(){
    return new Iterable<IIsotope>() {

        @Override
        public Iterator<IIsotope> iterator() {
            return isotopesMax.keySet().iterator();
        }
    };
}",isotopes,org/openscience/cdk/formula/MolecularFormulaRange.java,/tool/formula/src/main/java/org/openscience/cdk/formula/MolecularFormulaRange.java,"/**
     *  Returns an Iterator for looping over all isotopes in this MolecularFormulaExpand.
     *
     * @return    An Iterator with the isotopes in this MolecularFormulaExpand
     */",157-170,"('isotopes', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,12.0,Returns an Iterator for looping over all isotopes in this MolecularFormulaExpand.,The function takes a MolecularFormulaExpand and returns an iterator for looping over all the isotopes.,The Iterator is used to loop over all the isotopes.,0.536296435966525,Returns an iterator for the loop over all isotopes in this MolecularFormulaExpand.," public Iterable<IIsotope> isotopes(){
        return isotopesMax.keySet();
    }"," public Iterable<IIsotope> isotopes(){
        return isotopesMax.keySet();
    }"," public Iterable<IIsotope> isotopes(){
        return isotopesMax.keySet();
    }"," public Iterable<IIsotope> isotopes(){
        return isotopesMax.keySet();
    }",NOT PASS,NOT PASS,PASS,PASS,  0.28782750532540763,  0.28782750532540763,  0.28782750532540763,  0.28782750532540763,27.0,0.6,27.0,0.6,27.0,0.6,27.0,0.6,0.0,0.0,0.0,0.0,0.0,0.0,12.0,0.75,3.0,0.23076923076923078,10.0,0.8333333333333334
370,cdk,"public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
    if (factory == null)
        try {
            factory = AtomTypeFactory.getInstance(""org/openscience/cdk/config/data/jmol_atomtypes.txt"", ac.getBuilder());
        } catch (Exception exception) {
            return getDummyDescriptorValue(exception);
        }
    double atomicHardness;
    double radiusTarget;
    Iterator<IAtom> allAtoms = ac.atoms().iterator();
    atomicHardness = 0;
    double partial;
    double radius;
    String symbol;
    IAtomType type;
    try {
        symbol = atom.getSymbol();
        type = factory.getAtomType(symbol);
        radiusTarget = type.getCovalentRadius();
    } catch (Exception exception) {
        logger.debug(exception);
        return getDummyDescriptorValue(exception);
    }
    while (allAtoms.hasNext()) {
        IAtom curAtom = allAtoms.next();
        if (atom.getPoint3d() == null || curAtom.getPoint3d() == null) {
            return getDummyDescriptorValue(new CDKException(""The target atom or current atom had no 3D coordinates. These are required""));
        }
        if (!atom.equals(curAtom)) {
            partial = 0;
            symbol = curAtom.getSymbol();
            try {
                type = factory.getAtomType(symbol);
            } catch (Exception exception) {
                logger.debug(exception);
                return getDummyDescriptorValue(exception);
            }
            radius = type.getCovalentRadius();
            partial += radius * radius;
            partial += (radiusTarget * radiusTarget);
            partial = partial / (calculateSquareDistanceBetweenTwoAtoms(atom, curAtom));
            atomicHardness += partial;
        }
    }
    atomicHardness = 2 * atomicHardness;
    atomicHardness = atomicHardness * 0.172;
    atomicHardness = 1 / atomicHardness;
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(atomicHardness), NAMES);
}",calculate,org/openscience/cdk/qsar/descriptors/atomic/InductiveAtomicHardnessDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/InductiveAtomicHardnessDescriptor.java,"/**
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from
     *  the class tools.HydrogenAdder, and 3D coordinates.
     *
     *@param  atom              The IAtom for which the DescriptorValue is requested
     *@param  ac                AtomContainer
     *@return                   a double with polarizability of the heavy atom
     */",129-196,"('calculate', {'INSTRUCTION': {'covered': 112, 'missed': 28}, 'BRANCH': {'covered': 7, 'missed': 3}, 'LINE': {'covered': 28, 'missed': 9}, 'COMPLEXITY': {'covered': 3, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",322.0,13.0,It is needed to call the addExplicitHydrogensToSatisfyValency method from  the class tools.,"The function returns a double with polarizability of the heavy atom, needed for calling addExplicitHydrogensToSatisfyValency method.",The class tools have a method called the addExplicitHydrogensToSatisfyValency method.,0.469815085889578,It is necessary to call the addExplicitHydrogensToSatisfyValency method from the class tools.,Not Valid,"public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
        try {
            if (atom.getPoint3d() == null) {
                logger.error(""Atom has no 3D coordinates, cannot calculate descriptor"");
                return getDummyDescriptorValue(new CDKException(""Atom has no 3D coordinates, cannot calculate descriptor""));
            }
            if (factory == null) {
                factory = AtomTypeFactory.getInstance();
            }
            IAtomType type = factory.getAtomType(atom);
            if (type == null) {
                logger.error(""Atom has no atom type, cannot calculate descriptor"");
                return getDummyDescriptorValue(new CDKException(""Atom has no atom type, cannot calculate descriptor""));
            }
            double polarizability = type.getPolarizability();
            if (polarizability == 0) {
                logger.error(""Atom has no polarizability, cannot calculate descriptor"");
                return getDummyDescriptorValue(new CDKException(""Atom has no polarizability, cannot calculate descriptor""));
            }
            double charge = atom.getFormalCharge();
            if (charge == 0) {
                logger.error(""Atom has no charge, cannot calculate descriptor"");
                return getDummyDescriptorValue(new CDKException(""Atom has no charge, cannot calculate descriptor""));
            }
            double hardness = polarizability * charge;
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(
                    hardness), NAMES);
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }",Not Valid,Not Valid,Not Valid,NOT PASS,Not Valid,Not Valid,None,  0.3605356433700324,None,None,None,None,217.0,0.6718266253869969,None,None,None,None,208.0,0.9952153110047847,None,None,None,None,15.0,0.8823529411764706,1.0,0.07692307692307693,10.0,0.7692307692307693
372,cdk,"public void validateLeaveOneOut(){
    final int sz = training.size();
    estimates = new double[sz];
    for (int n = 0; n < sz; n++) estimates[n] = singleLeaveOneOut(n);
    calculateROC();
    rocType = ""leave-one-out"";
}",validateLeaveOneOut,org/openscience/cdk/fingerprint/model/Bayesian.java,/tool/model/src/main/java/org/openscience/cdk/fingerprint/model/Bayesian.java,"/**
     * Produces an ROC validation set, using the inputs provided prior to the model building, using leave-one-out. Note that
     * this should only be used for small datasets, since it is very thorough, and scales as O(N^2) relative to training set
     * size.
     */",315-327,"('validateLeaveOneOut', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",57.0,19.0,"Produces an ROC validation set, using the inputs provided prior to the model building, using leave-one-out.","Using the leave-one-out approach onhte inputs provided before the model creation, produces a ROC validaton set. Since it scales O(N^2), it should be used on small datasets.",The ROC validation set is produced using inputs provided prior to the model building.,0.240977764676658,"Produces an OCR validation set, using the inputs provided before the model was built, using the leave it aside.","public void validateLeaveOneOut(){
        // create a validation set
        int[] validation = new int[trainingSize];
        for (int i = 0; i < trainingSize; i++)
            validation[i] = i;
    
        // shuffle the validation set
        Random rng = new Random();
        for (int i = 0; i < trainingSize; i++) {
            int j = rng.nextInt(trainingSize);
            int tmp = validation[i];
            validation[i] = validation[j];
            validation[j] = tmp;
        }
    
        // validate the model
        validate(validation);       
 }","public void validateLeaveOneOut(){
      
      //create a list of all the molecules in the training set
      List<IAtomContainer> trainingMols = new ArrayList<IAtomContainer>();
      for(int i = 0; i < training.size(); i++){
            trainingMols.add(training.get(i)[0]);
      }
      
      //create a list of all the molecules in the training set
      List<IAtomContainer> testMols = new ArrayList<IAtomContainer>();
      for(int i = 0; i < training.size(); i++){
            testMols.add(training.get(i)[0]);
      }
      
      //create a list of all the molecules in the training set
      List<IAtomContainer> validationMols = new ArrayList<IAtomContainer>();
      for(int i = 0; i < training.size(); i++){
            validationMols.add(training.get(i)[0]);
      }
      
      //create a list of all the molecules in the training set
      List<IAtomContainer> trainingMols2 = new ArrayList<IAtomContainer>();
      for(int i = 0; i < training.size(); i++){
            trainingMols2.add(training.get(i)[0]);
      }
      
      //create a list of all the molecules in the training set
      List<IAtomContainer> testMols2 = new ArrayList<IAtomContainer>();
      for(int i = 0; i < training.size(); i++){
            testMols2.add(training.get(i)[0]);
      }
      
      //create a list of all the molecules in the training set
      List<IAtomContainer> validationMols2 = new ArrayList<IAtomContainer>();
      for(int i = 0; i < training.size(); i++){
            validationMols2.add(training.get(i)[0]);
      }
      
      //create a list of all the molecules in the training set
      List<IAtomContainer>          
 }",Empty Method,"public void validateLeaveOneOut(){
      
      for(int i = 0; i < training.size(); i++){
            
            int[] fp = training.get(i);
            boolean active = activity.get(i);
            
            if(active){
                 
                 for(int j = 0; j < training.size(); j++){
                  
                  if(j != i){
                        
                        int[] fp2 = training.get(j);
                        boolean active2 = activity.get(j);
                        
                        if(!active2){
                             
                             double pred = predict(fp2);
                             double scaled = scalePredictor(pred);
                             
                             if(scaled > 0.5){
                              
                              System.out.println(""ACTIVE: "" + i + "" "" + j);
                             }
                        }
                  }
                 }
            }
      }         
 }",NOT PASS,Syntax Error,NOT PASS,Empty Method,  0.3051657401927418,None,  0.29107395350216736,None,74.0,0.7115384615384616,None,None,114.0,0.75,None,None,None,None,109.0,0.7171052631578947,None,None,26.0,0.9285714285714286,9.0,0.45,9.0,0.5294117647058824
373,twilio-java,"public String create(List<String> sortedIncludedHeaders){
    // Add the method and uri
    StringBuilder canonicalRequest = new StringBuilder();
    canonicalRequest.append(method).append(NEW_LINE);
    String canonicalUri = CANONICALIZE_PATH.apply(uri);
    canonicalRequest.append(canonicalUri).append(NEW_LINE);
    // Get the query args, replace whitespace and values that should be not encoded, sort and rejoin
    String canonicalQuery = CANONICALIZE_QUERY.apply(queryString);
    canonicalRequest.append(canonicalQuery).append(NEW_LINE);
    // Normalize all the headers
    Header[] normalizedHeaders = NORMALIZE_HEADERS.apply(headers);
    Map<String, List<String>> combinedHeaders = COMBINE_HEADERS.apply(normalizedHeaders);
    // Add the headers that we care about
    for (String header : sortedIncludedHeaders) {
        String lowercase = header.toLowerCase().trim();
        if (combinedHeaders.containsKey(lowercase)) {
            List<String> values = combinedHeaders.get(lowercase);
            Collections.sort(values);
            canonicalRequest.append(lowercase).append("":"").append(String.join("","", values)).append(NEW_LINE);
        }
    }
    canonicalRequest.append(NEW_LINE);
    // Mark the headers that we care about
    canonicalRequest.append(String.join("";"", sortedIncludedHeaders)).append(NEW_LINE);
    // Hash and hex the request payload
    if (requestBody != null && !requestBody.isEmpty()) {
        String hashedPayload = DigestUtils.sha256Hex(requestBody);
        canonicalRequest.append(hashedPayload);
    }
    return canonicalRequest.toString();
}",create,com/twilio/jwt/validation/RequestCanonicalizer.java,/src/main/java/com/twilio/jwt/validation/RequestCanonicalizer.java,"/**
     * Creates a canonical request string out of HTTP request components.
     *
     * @param sortedIncludedHeaders the headers that should be included into canonical request string
     * @return a string representing the canonical request
     */",44-90,"('create', {'INSTRUCTION': {'covered': 114, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",253.0,11.0,Creates a canonical request string out of HTTP request components.,"Starting from a HTTP request, it creates the canonical request string.",A string of request components is created.,0.734887903699347,Creates a canonical query string from the HTTP request components.," public String create(List<String> sortedIncludedHeaders){
        StringBuilder canonicalRequest = new StringBuilder();
        canonicalRequest.append(method).append(NEW_LINE);
        canonicalRequest.append(canonicalUri()).append(NEW_LINE);
        canonicalRequest.append(canonicalQueryString()).append(NEW_LINE);
        canonicalRequest.append(canonicalHeaders(sortedIncludedHeaders)).append(NEW_LINE);
        canonicalRequest.append(canonicalRequestBody());
        return canonicalRequest.toString();
    }"," public String create(List<String> sortedIncludedHeaders){
        StringBuilder canonicalRequest = new StringBuilder();
        canonicalRequest.append(method).append(NEW_LINE);
        canonicalRequest.append(canonicalUri()).append(NEW_LINE);
        canonicalRequest.append(canonicalQueryString()).append(NEW_LINE);
        canonicalRequest.append(canonicalHeaders(sortedIncludedHeaders)).append(NEW_LINE);
        canonicalRequest.append(canonicalRequestBody());
        return canonicalRequest.toString();
    }"," public String create(List<String> sortedIncludedHeaders){
        StringBuilder sb = new StringBuilder();
        sb.append(method).append(NEW_LINE);
        sb.append(uri).append(NEW_LINE);
        sb.append(queryString).append(NEW_LINE);
        sb.append(requestBody).append(NEW_LINE);
        sb.append(createSortedHeaders(sortedIncludedHeaders));
        return sb.toString();       
 }"," public String create(List<String> sortedIncludedHeaders){
        StringBuilder canonicalQueryString = new StringBuilder();
        if (queryString != null) {
            canonicalQueryString.append(queryString);
        }
        if (sortedIncludedHeaders != null) {
            canonicalQueryString.append(createCanonicalQueryString(sortedIncludedHeaders));
        }
        return canonicalQueryString.toString();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3210906223610144,  0.3210906223610144,  0.21249302650945504,  0.28842825344004186,167.0,0.65748031496063,167.0,0.65748031496063,207.0,0.8149606299212598,179.0,0.7047244094488189,0.0,0.0,49.0,0.532608695652174,19.0,0.20652173913043478,9.0,0.75,3.0,0.2727272727272727,9.0,0.8181818181818182
375,mybatis-3,"public ResolverUtil<T> findAnnotated(Class<? extends Annotation> annotation, String... packageNames){
    if (packageNames == null) {
        return this;
    }
    Test test = new AnnotatedWith(annotation);
    for (String pkg : packageNames) {
        find(test, pkg);
    }
    return this;
}",findAnnotated,org/apache/ibatis/io/ResolverUtil.java,/src/main/java/org/apache/ibatis/io/ResolverUtil.java,"/**
   * Attempts to discover classes that are annotated with the annotation. Accumulated
   * classes can be accessed by calling {@link #getClasses()}.
   *
   * @param annotation
   *          the annotation that should be present on matching classes
   * @param packageNames
   *          one or more package names to scan (including subpackages) for classes
   * @return the resolver util
   */",210-231,"('findAnnotated', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,11.0,Attempts to discover classes that are annotated with the annotation.,"Given an annotation, tries to discover all the classes that have that annotaion, that can be accessed using getClasses() method",Attempts to find classes that are annotated.,0.204634388269915,Attempts to discover classes annotated with annotation.," public ResolverUtil<T> findAnnotated(Class<? extends Annotation> annotation, String... packageNames){
    if (packageNames == null) {
      return this;
    }
  
    Test test = new AnnotatedWith(annotation);
    for (String pkg : packageNames) {
      find(test, pkg);
    }
  
    return this;
  }"," public ResolverUtil<T> findAnnotated(Class<? extends Annotation> annotation, String... packageNames){
    if (packageNames == null) {
      return this;
    }
  
    Test test = new AnnotatedWith(annotation);
    for (String pkg : packageNames) {
      find(test, pkg);
    }
  
    return this;
  }"," public ResolverUtil<T> findAnnotated(Class<? extends Annotation> annotation, String... packageNames){
    if (packageNames == null) {
      return this;
    }
  
    Test test = new AnnotatedWith(annotation);
    for (String pkg : packageNames) {
      find(test, pkg);
    }
  
    return this;
  }"," public ResolverUtil<T> findAnnotated(Class<? extends Annotation> annotation, String... packageNames){
    if (packageNames == null) {
      return this;
    }
  
    Test test = new AnnotatedWith(annotation);
    for (String pkg : packageNames) {
      find(test, pkg);
    }
  
    return this;
  }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,16.0,0.7619047619047619,3.0,0.2727272727272727,5.0,0.45454545454545453
376,glowstone,"public void putCompoundList(@NonNls String key, List<CompoundTag> list){
    put(key, new ListTag<>(TagType.COMPOUND, list));
}",putCompoundList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Adds or replaces a list subtag with a list of compound tags.
     *
     * @param key the key to write to
     * @param list the list contents as compound tags
     */",947-955,"('putCompoundList', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,13.0,Adds or replaces a list subtag with a list of compound tags.,"Using a list of compound tags, the function adds or replaces a list of subtags.",A list subtag is added or replaced with a list of compound tags.,0.114138514497338,Adds or replaces a list subtag with a list of compound tags.," public void putCompoundList(@NonNls String key, List<CompoundTag> list){
        putList(key, TagType.COMPOUND, list, CompoundTag::new);
    }"," public void putCompoundList(@NonNls String key, List<CompoundTag> list){
        putList(key, TagType.COMPOUND, list, CompoundTag::new);
    }"," public void putCompoundList(@NonNls String key, List<CompoundTag> list){
        putList(key, TagType.COMPOUND, list, CompoundTag::new);
    }"," public void putCompoundList(@NonNls String key, List<CompoundTag> list){
        putList(key, TagType.COMPOUND, list, CompoundTag::new);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7138352571747411,  0.7138352571747411,  0.7138352571747411,  0.7138352571747411,10.0,0.2857142857142857,10.0,0.2857142857142857,10.0,0.2857142857142857,10.0,0.2857142857142857,0.0,0.0,0.0,0.0,0.0,0.0,13.0,0.8125,0.0,0.0,7.0,0.5
377,cdk,"public static int has2DCoordinatesNew(IAtomContainer container){
    if (container == null)
        return 0;
    boolean no2d = false;
    boolean with2d = false;
    for (IAtom atom : container.atoms()) {
        if (atom.getPoint2d() == null) {
            no2d = true;
        } else {
            with2d = true;
        }
    }
    if (!no2d && with2d) {
        return 2;
    } else if (no2d && with2d) {
        return 1;
    } else {
        return 0;
    }
}",has2DCoordinatesNew,org/openscience/cdk/geometry/GeometryTools.java,/legacy/src/main/java/org/openscience/cdk/geometry/GeometryTools.java,"/**
     *  Determines if this AtomContainer contains 2D coordinates for some or all molecules.
     *  See comment for center(IAtomContainer atomCon, Dimension areaDim, HashMap renderingCoordinates) for details on coordinate sets
     *
     *
     * @param container the molecule to be considered
     * @return    0 no 2d, 1=some, 2= for each atom
     * @deprecated use {@link #get2DCoordinateCoverage(org.openscience.cdk.interfaces.IAtomContainer)} for determining
     *             partial coordinates
     * @see #get2DCoordinateCoverage(org.openscience.cdk.interfaces.IAtomContainer)
     */",1020-1051,"('has2DCoordinatesNew', {'INSTRUCTION': {'covered': 40, 'missed': 2}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",95.0,13.0,Determines if this AtomContainer contains 2D coordinates for some or all molecules.,The function checks whether the AtomContainer contains 2D coordinates for some (or all) the molecules.,"If the AtomContainer contains 2D coordinates for some or all of the molecules, it's determined.",0.481839509837346,Determines whether this AtomContainer contains 2D coordinates for some or all of the molecules.,"public static int has2DCoordinatesNew(IAtomContainer container){
        if (container == null || container.getAtomCount() == 0) return 0;
        int count = 0;
        for (IAtom atom : container.atoms()) {
            count += atom != null && atom.getPoint2d() != null ? 1 : 0;
        }
        return count;       
 }","public static int has2DCoordinatesNew(IAtomContainer container){
        if (container == null || container.getAtomCount() == 0) return 0;
        int count = 0;
        for (IAtom atom : container.atoms()) {
            if (atom.getPoint2d() != null) count++;
        }
        return count;
    }","public static int has2DCoordinatesNew(IAtomContainer container){
        if (container == null || container.getAtomCount() == 0) return 0;
        int count = 0;
        for (IAtom atom : container.atoms()) {
            if (atom.getPoint2d() != null) count++;
        }
        return count;
    }","public static int has2DCoordinatesNew(IAtomContainer container){
        if (container == null || container.getAtomCount() == 0) return 0;
        int count = 0;
        for (IAtom atom : container.atoms()) {
            count += atom != null && atom.getPoint2d() != null ? 1 : 0;
        }
        return count;       
 }",PASS,PASS,PASS,PASS,  0.4252158701971087,  0.4469529735946627,  0.4252158701971087,  0.4469529735946627,60.0,0.625,55.0,0.5729166666666666,60.0,0.625,55.0,0.5729166666666666,10.0,0.14925373134328357,0.0,0.0,10.0,0.14925373134328357,8.0,0.5,3.0,0.2,8.0,0.5
378,weblogic-kubernetes-operator,"public static List<V1EnvVar> createCopy(List<V1EnvVar> envVars){
    ArrayList<V1EnvVar> copy = new ArrayList<>();
    if (envVars != null) {
        for (V1EnvVar envVar : envVars) {
            copy.add(new V1EnvVarBuilder(envVar).build());
        }
    }
    return copy;
}",createCopy,oracle/kubernetes/operator/helpers/PodHelper.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/PodHelper.java,"/**
   * Create a copy of the list of V1EnvVar environment variables.
   *
   * @param envVars list of environment variables to copy
   * @return List containing a copy of the original list.
   */",263-280,"('createCopy', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",64.0,11.0,Create a copy of the list of V1EnvVar environment variables.,"Given a list of environment variables, generate a copy of that V1EnvVar list.",The list of V1EnvVar environment variables can be created.,0.525472721860478,Create a copy of the V1EnvVar environment variable list.,"public static List<V1EnvVar> createCopy(List<V1EnvVar> envVars){
    List<V1EnvVar> copy = new ArrayList<>();
    for (V1EnvVar envVar : envVars) {
      copy.add(new V1EnvVar(envVar));
    }
    return copy;
  }","public static List<V1EnvVar> createCopy(List<V1EnvVar> envVars){
    List<V1EnvVar> copy = new ArrayList<>();
    for (V1EnvVar envVar : envVars) {
      copy.add(new V1EnvVar(envVar));
    }
    return copy;    
 }","public static List<V1EnvVar> createCopy(List<V1EnvVar> envVars){
    List<V1EnvVar> envVarList = new ArrayList<>();
    for (V1EnvVar envVar : envVars) {
      V1EnvVar envVarCopy = new V1EnvVar();
      envVarCopy.setName(envVar.getName());
      envVarCopy.setValue(envVar.getValue());
      envVarCopy.setValueFrom(envVar.getValueFrom());
      envVarList.add(envVarCopy);
    }
    return envVarList;
  }","public static List<V1EnvVar> createCopy(List<V1EnvVar> envVars){
    List<V1EnvVar> copy = new ArrayList<>();
    for (V1EnvVar envVar : envVars) {
      copy.add(new V1EnvVar(envVar));
    }
    return copy;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7011160857402201,  0.7011160857402201,  0.7011160857402201,  0.5954016382109809,14.0,0.2153846153846154,14.0,0.2153846153846154,14.0,0.2153846153846154,44.0,0.4888888888888889,0.0,0.0,0.0,0.0,43.0,0.4777777777777778,10.0,0.7142857142857143,4.0,0.36363636363636365,9.0,0.8181818181818182
379,cdk,"public static IAtomContainer assign(final IAtomContainer container){
    GraphUtil.EdgeToBondMap edgeToBond = GraphUtil.EdgeToBondMap.withSpaceFor(container);
    new NonplanarBonds(container, GraphUtil.toAdjList(container, edgeToBond), edgeToBond);
    return container;
}",assign,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,"/**
     * Assign non-planar, up and down labels to indicate tetrahedral configuration. Currently all
     * existing directional labels are removed before assigning new labels.
     *
     * @param container the structure to assign labels to
     * @return a container with assigned labels (currently the same as the input)
     * @throws IllegalArgumentException an atom had no 2D coordinates or labels could not be
     *                                  assigned to a tetrahedral centre
     */",104-117,"('assign', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,12.0,"Assign non-planar, up and down labels to indicate tetrahedral configuration.","In order to indicate the tetrahedral configuration, remove all existing directional labels and assigns all the labels (non-planar, up and down)","The non-planar, up and down labels are used to indicate the configuration.",0.399620384516078,"Assign non-flat, up, and down labels to indicate the tetrahedral configuration."," public static IAtomContainer assign(final IAtomContainer container){
        final NonplanarBonds bonds = new NonplanarBonds(container);
        bonds.assign();
        return container;
    }"," public static IAtomContainer assign(final IAtomContainer container){
        final NonplanarBonds npb = new NonplanarBonds(container);
        npb.assign();
        return container;
    }"," public static IAtomContainer assign(final IAtomContainer container){
        return new NonplanarBonds(container).assign();
    }"," public static IAtomContainer assign(final IAtomContainer container){
        return new NonplanarBonds(container).assign();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.409395959996918,  0.409395959996918,  0.2931214320895993,  0.3139547654229326,22.0,0.4782608695652174,22.0,0.4782608695652174,26.0,0.5652173913043478,26.0,0.5652173913043478,2.0,0.06451612903225806,9.0,0.2903225806451613,9.0,0.2903225806451613,19.0,0.8636363636363636,3.0,0.25,4.0,0.3076923076923077
380,cdk,"private void ensureDefaultOccurElements(IChemObjectBuilder builder){
    if (mfRange == null) {
        String[] elements = new String[] { ""C"", ""H"", ""O"", ""N"", ""Si"", ""P"", ""S"", ""F"", ""Cl"", ""Br"", ""I"", ""Sn"", ""B"", ""Pb"", ""Tl"", ""Ba"", ""In"", ""Pd"", ""Pt"", ""Os"", ""Ag"", ""Zr"", ""Se"", ""Zn"", ""Cu"", ""Ni"", ""Co"", ""Fe"", ""Cr"", ""Ti"", ""Ca"", ""K"", ""Al"", ""Mg"", ""Na"", ""Ce"", ""Hg"", ""Au"", ""Ir"", ""Re"", ""W"", ""Ta"", ""Hf"", ""Lu"", ""Yb"", ""Tm"", ""Er"", ""Ho"", ""Dy"", ""Tb"", ""Gd"", ""Eu"", ""Sm"", ""Pm"", ""Nd"", ""Pr"", ""La"", ""Cs"", ""Xe"", ""Te"", ""Sb"", ""Cd"", ""Rh"", ""Ru"", ""Tc"", ""Mo"", ""Nb"", ""Y"", ""Sr"", ""Rb"", ""Kr"", ""As"", ""Ge"", ""Ga"", ""Mn"", ""V"", ""Sc"", ""Ar"", ""Ne"", ""Be"", ""Li"", ""Tl"", ""Pb"", ""Bi"", ""Po"", ""At"", ""Rn"", ""Fr"", ""Ra"", ""Ac"", ""Th"", ""Pa"", ""U"", ""Np"", ""Pu"" };
        mfRange = new MolecularFormulaRange();
        for (int i = 0; i < elements.length; i++) mfRange.addIsotope(builder.newInstance(IIsotope.class, elements[i]), 0, 50);
    }
}",ensureDefaultOccurElements,org/openscience/cdk/formula/rules/ElementRule.java,/tool/formula/src/main/java/org/openscience/cdk/formula/rules/ElementRule.java,"/**
     * Initiate the MolecularFormulaExpand with the maximum and minimum occurrence of the Elements.
     * In this case all elements of the periodic table are loaded.
     */",128-145,"('ensureDefaultOccurElements', {'INSTRUCTION': {'covered': 417, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",264.0,13.0,Initiate the MolecularFormulaExpand with the maximum and minimum occurrence of the Elements.,"Given the MolecularFormulaExpand, the function sets the minimum and maximum occurrence of the Elements, loading them from the periodic table.",The maximum and minimum occurrence of the Elements are the things that should be initiated.,0.742548331833114,Launch molecularFormulaExpand with the maximum and minimum instance of the elements.,"private void ensureDefaultOccurElements(IChemObjectBuilder builder){
        if (mfRange == null) {
            mfRange = new MolecularFormulaRange(builder);
            mfRange.addIsotopeCount(builder.newInstance(IIsotope.class, ""C""), 0, 100);
            mfRange.addIsotopeCount(builder.newInstance(IIsotope.class, ""H""), 0, 100);
            mfRange.addIsotopeCount(builder.newInstance(IIsotope.class, ""N""), 0, 100);
            mfRange.addIsotopeCount(builder.newInstance(IIsotope.class, ""O""), 0, 100);
        }       
 }","private void ensureDefaultOccurElements(IChemObjectBuilder builder){
        if (mfRange == null) mfRange = new MolecularFormulaRange();
        if (mfRange.getIsotopeCountMin() == null) {
            mfRange.setIsotopeCountMin(builder.newInstance(IIsotope.class, ""C""), 0);
            mfRange.setIsotopeCountMin(builder.newInstance(IIsotope.class, ""H""), 0);
            mfRange.setIsotopeCountMin(builder.newInstance(IIsotope.class, ""N""), 0);
            mfRange.setIsotopeCountMin(builder.newInstance(IIsotope.class, ""O""), 0);
        }
        if (mfRange.getIsotopeCountMax() == null) {
            mfRange.setIsotopeCountMax(builder.newInstance(IIsotope.class, ""C""), 100);
            mfRange.setIsotopeCountMax(builder.newInstance(IIsotope.class, ""H""), 100);
            mfRange.setIsotopeCountMax(builder.newInstance(IIsotope.class, ""N""), 100);
            mfRange.setIsotopeCountMax(builder.newInstance(IIsotope.class, ""O""), 100);
        }       
 }","private void ensureDefaultOccurElements(IChemObjectBuilder builder){
        if (mfRange == null) {
            mfRange = new MolecularFormulaRange();
        }
        if (mfRange.getIsotopeCountMin(builder.newInstance(IIsotope.class, ""C"")) == 0) {
            mfRange.setIsotopeCountMin(builder.newInstance(IIsotope.class, ""C""), 0);
        }
        if (mfRange.getIsotopeCountMax(builder.newInstance(IIsotope.class, ""C"")) == 0) {
            mfRange.setIsotopeCountMax(builder.newInstance(IIsotope.class, ""C""), 100);
        }
        if (mfRange.getIsotopeCountMin(builder.newInstance(IIsotope.class, ""H"")) == 0) {
            mfRange.setIsotopeCountMin(builder.newInstance(IIsotope.class, ""H""), 0);
        }
        if (mfRange.getIsotopeCountMax(builder.newInstance(IIsotope.class, ""H"")) == 0) {
            mfRange.setIsotopeCountMax(builder.newInstance(IIsotope.class, ""H""), 100);
        }
        if (mfRange.getIsotopeCountMin(builder.newInstance(IIsotope.class, ""N"")) == 0) {
            mfRange.setIsotopeCountMin(builder.newInstance(IIsotope.class, ""N""), 0);
        }
        if (mfRange.getIsotopeCountMax(builder.newInstance(IIsotope.class, ""N"")) == 0) {
            mfRange.setIsotopeCountMax(builder.newInstance(IIsotope.class, ""N""), 100);
        }
        if (mfRange.getIsotopeCountMin(builder.newInstance(IIsotope.class, ""O"")) == 0) {
            mfRange.setIsotopeCountMin(builder.newInstance(IIsotope.class, ""O""), 0);
        }
        if (m       
 }","private void ensureDefaultOccurElements(IChemObjectBuilder builder){
        if (mfRange == null) {
            mfRange = new MolecularFormulaRange(builder);
        }
        if (mfRange.getIsotopeCountMin(builder.newInstance(IIsotope.class, ""C"")) == 0) {
            mfRange.setIsotopeCountMin(builder.newInstance(IIsotope.class, ""C""), 1);
        }
        if (mfRange.getIsotopeCountMax(builder.newInstance(IIsotope.class, ""C"")) == 0) {
            mfRange.setIsotopeCountMax(builder.newInstance(IIsotope.class, ""C""), 100);
        }
        if (mfRange.getIsotopeCountMin(builder.newInstance(IIsotope.class, ""H"")) == 0) {
            mfRange.setIsotopeCountMin(builder.newInstance(IIsotope.class, ""H""), 1);
        }
        if (mfRange.getIsotopeCountMax(builder.newInstance(IIsotope.class, ""H"")) == 0) {
            mfRange.setIsotopeCountMax(builder.newInstance(IIsotope.class, ""H""), 100);
        }
        if (mfRange.getIsotopeCountMin(builder.newInstance(IIsotope.class, ""N"")) == 0) {
            mfRange.setIsotopeCountMin(builder.newInstance(IIsotope.class, ""N""), 1);
        }
        if (mfRange.getIsotopeCountMax(builder.newInstance(IIsotope.class, ""N"")) == 0) {
            mfRange.setIsotopeCountMax(builder.newInstance(IIsotope.class, ""N""), 100);
        }
        if (mfRange.getIsotopeCountMin(builder.newInstance(IIsotope.class, ""O"")) == 0) {
            mfRange.setIsotopeCountMin(builder.newInstance(IIsotope.class, ""O""), 1);
        }
        if      
 }",NOT PASS,NOT PASS,Syntax Error,Syntax Error,  0.1351533009941773,  0.18008198649146714,None,None,217.0,0.8188679245283019,214.0,0.8075471698113208,253.0,0.8241042345276873,254.0,0.8246753246753247,100.0,0.5235602094240838,207.0,0.6742671009771987,209.0,0.6785714285714286,14.0,0.6666666666666666,5.0,0.38461538461538464,13.0,0.8125
381,matsim-libs,"public void addSeries(final String title, final double[] xs, final double[] ys){
    XYSeries series = new XYSeries(title, false, true);
    for (int i = 0, n = Math.min(xs.length, ys.length); i < n; i++) {
        series.add(xs[i], ys[i]);
    }
    this.dataset.addSeries(series);
}",addSeries,org/matsim/core/utils/charts/XYScatterChart.java,/matsim/src/main/java/org/matsim/core/utils/charts/XYScatterChart.java,"/**
	 * Adds a new data series to the chart with the specified title.
	 * <code>xs<code> and <code>ys</code> should have the same length. If not,
	 * only as many items are shown as the shorter array contains.
	 * 
	 * @param title
	 * @param xs
	 *            The x values.
	 * @param ys
	 *            The y values.
	 */",80-98,"('addSeries', {'INSTRUCTION': {'covered': 33, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",90.0,13.0,Adds a new data series to the chart with the specified title.,"Given the title, adds the new series to the chart. Remember that <code>xs</code> and <code>ys</code> should have the same length (otherwise the exceeding elements will be ignored).",A new data series is added to the chart.,0.468578597523322,Adds a new data series to the chart with the specified title.,"public void addSeries(final String title, final double[] xs, final double[] ys){
	 	XYSeries series = new XYSeries(title);
 	for (int i = 0; i < xs.length; i++) {
 		series.add(xs[i], ys[i]);
 	}
 	this.dataset.addSeries(series);		
 }","public void addSeries(final String title, final double[] xs, final double[] ys){
	 XYSeries series = new XYSeries(title);
	 for (int i = 0; i < xs.length; i++) {
		 series.add(xs[i], ys[i]);
	 }
	 this.dataset.addSeries(series);
 }","public void addSeries(final String title, final double[] xs, final double[] ys){
	 	XYSeries series = new XYSeries(title);
 	for (int i = 0; i < xs.length; i++) {
 		series.add(xs[i], ys[i]);
 	}
 	this.dataset.addSeries(series);
 }","public void addSeries(final String title, final double[] xs, final double[] ys){
	 	XYSeries series = new XYSeries(title);
 	for (int i = 0; i < xs.length; i++) {
 		series.add(xs[i], ys[i]);
 	}
 	this.dataset.addSeries(series);
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7355980309952268,  0.7355980309952268,  0.7263387717359676,  0.7263387717359676,20.0,0.21978021978021978,20.0,0.21978021978021978,20.0,0.21978021978021978,20.0,0.21978021978021978,0.0,0.0,0.0,0.0,0.0,0.0,23.0,0.8214285714285714,0.0,0.0,8.0,0.6153846153846154
382,openapi-generator,"public static boolean isFreeFormObject(OpenAPI openAPI, Schema schema){
    if (schema == null) {
        once(LOGGER).error(""Schema cannot be null in isFreeFormObject check"");
        return false;
    }
    if (schema instanceof ComposedSchema) {
        ComposedSchema cs = (ComposedSchema) schema;
        List<Schema> interfaces = ModelUtils.getInterfaces(cs);
        if (interfaces != null && !interfaces.isEmpty()) {
            return false;
        }
    }
    if (""object"".equals(schema.getType())) {
        if ((schema.getProperties() == null || schema.getProperties().isEmpty())) {
            Schema addlProps = getAdditionalProperties(openAPI, schema);
            if (schema.getExtensions() != null && schema.getExtensions().containsKey(freeFormExplicit)) {
                boolean isFreeFormExplicit = Boolean.parseBoolean(String.valueOf(schema.getExtensions().get(freeFormExplicit)));
                if (!isFreeFormExplicit && addlProps != null && addlProps.getProperties() != null && !addlProps.getProperties().isEmpty()) {
                    once(LOGGER).error(String.format(Locale.ROOT, ""Potentially confusing usage of %s within model which defines additional properties"", freeFormExplicit));
                }
                return isFreeFormExplicit;
            }
            if (addlProps == null) {
                return true;
            } else {
                if (addlProps instanceof ObjectSchema) {
                    ObjectSchema objSchema = (ObjectSchema) addlProps;
                    if (objSchema.getProperties() == null || objSchema.getProperties().isEmpty()) {
                        return true;
                    }
                } else if (addlProps instanceof Schema) {
                    if (addlProps.getType() == null && addlProps.get$ref() == null && (addlProps.getProperties() == null || addlProps.getProperties().isEmpty())) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}",isFreeFormObject,org/openapitools/codegen/utils/ModelUtils.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ModelUtils.java,"/**
     * Check to see if the schema is a free form object.
     *
     * A free form object is an object (i.e. 'type: object' in a OAS document) that:
     * 1) Does not define properties, and
     * 2) Is not a composed schema (no anyOf, oneOf, allOf), and
     * 3) additionalproperties is not defined, or additionalproperties: true, or additionalproperties: {}.
     *
     * Examples:
     *
     * components:
     *   schemas:
     *     arbitraryObject:
     *       type: object
     *       description: This is a free-form object.
     *         The value must be a map of strings to values. The value cannot be 'null'.
     *         It cannot be array, string, integer, number.
     *     arbitraryNullableObject:
     *       type: object
     *       description: This is a free-form object.
     *         The value must be a map of strings to values. The value can be 'null',
     *         It cannot be array, string, integer, number.
     *       nullable: true
     *     arbitraryTypeValue:
     *       description: This is NOT a free-form object.
     *         The value can be any type except the 'null' value.
     *
     * @param openAPI the object that encapsulates the OAS document.
     * @param schema potentially containing a '$ref'
     * @return true if it's a free-form object
     */",753-836,"('isFreeFormObject', {'INSTRUCTION': {'covered': 97, 'missed': 23}, 'BRANCH': {'covered': 33, 'missed': 11}, 'LINE': {'covered': 25, 'missed': 1}, 'COMPLEXITY': {'covered': 15, 'missed': 8}, 'METHOD': {'covered': 1, 'missed': 0}})",341.0,12.0,Check to see if the schema is a free form object.,"check the schema to see if it is a free form object, so it does not define properties, it is not a composed scheama and does not define the additionalproperty","If the schema is a free form object, you should check it.",0.507955093875062,Check if the schema is a freeform object.,Not Valid," public static boolean isFreeFormObject(OpenAPI openAPI, Schema schema){
        if(schema instanceof ComposedSchema){
            return false;
        }
        if(schema instanceof ObjectSchema){
            return false;
        }
        if(schema instanceof RefSchema){
            return false;
        }
        if(schema instanceof ArraySchema){
            return false;
        }
        if(schema instanceof FileSchema){
            return false;
        }
        if(schema instanceof BinarySchema){
            return false;
        }
        if(schema instanceof ByteArraySchema){
            return false;
        }
        if(schema instanceof DateSchema){
            return false;
        }
        if(schema instanceof DateTimeSchema){
            return false;
        }
        if(schema instanceof PasswordSchema){
            return false;
        }
        if(schema instanceof UUIDSchema){
            return false;
        }
        if(schema instanceof URISchema){
            return false;
        }
        if(schema instanceof EmailSchema){
            return false;
        }
        if(schema instanceof DecimalSchema){
            return false;
        }
        if(schema instanceof IntegerSchema){
            return false;
        }
        if(schema instanceof NumberSchema){
            return false;
        }
        if(schema instanceof StringSchema){
            return false;
        }
        if(schema instanceof BooleanSchema){
            return false;
        }
        if(schema instanceof NullSchema){
            return false;
        }
        if(schema instanceof AnySchema){
            return false;
        }
        if(schema instanceof OneOfSchema){
            return false;
        }
        if(schema instanceof AllOfSchema){
            return false;
        }
        if(schema instanceof AnyOfSchema){
            return false;
        }
        if(schema instanceof NotSchema){
            return false;
        }
        if(schema instanceof LinkSche       
 }"," public static boolean isFreeFormObject(OpenAPI openAPI, Schema schema){
        if(schema instanceof ObjectSchema){
            return true;
        }
        if(schema instanceof ComposedSchema){
            ComposedSchema composedSchema = (ComposedSchema)schema;
            if(composedSchema.getAllOf() != null){
                for(Schema s : composedSchema.getAllOf()){
                    if(isFreeFormObject(openAPI, s)){
                        return true;
                    }
                }
            }
            if(composedSchema.getOneOf() != null){
                for(Schema s : composedSchema.getOneOf()){
                    if(isFreeFormObject(openAPI, s)){
                        return true;
                    }
                }
            }
            if(composedSchema.getAnyOf() != null){
                for(Schema s : composedSchema.getAnyOf()){
                    if(isFreeFormObject(openAPI, s)){
                        return true;
                    }
                }
            }
            if(composedSchema.getNot() != null){
                if(isFreeFormObject(openAPI, composedSchema.getNot())){
                    return true;
                }
            }
            if(composedSchema.getProperties() != null){
                for(String key : composedSchema.getProperties().keySet()){
                    if(isFreeFormObject(openAPI, composedSchema.getProperties().get(key))){
                        return true;
                    }
                }
            }
            if(composedSchema.getAdditionalProperties() != null){
                if(isFreeFormObject(openAPI, composedSchema.getAdditionalProperties())){
                    return true;
                }
            }
        }
        return false;
    }"," public static boolean isFreeFormObject(OpenAPI openAPI, Schema schema){
        if (schema instanceof ObjectSchema) {
            return true;
        }
        if (schema instanceof ComposedSchema) {
            ComposedSchema composedSchema = (ComposedSchema) schema;
            if (composedSchema.getAllOf() != null) {
                for (Schema s : composedSchema.getAllOf()) {
                    if (isFreeFormObject(openAPI, s)) {
                        return true;
                    }
                }
            }
            if (composedSchema.getOneOf() != null) {
                for (Schema s : composedSchema.getOneOf()) {
                    if (isFreeFormObject(openAPI, s)) {
                        return true;
                    }
                }
            }
            if (composedSchema.getAnyOf() != null) {
                for (Schema s : composedSchema.getAnyOf()) {
                    if (isFreeFormObject(openAPI, s)) {
                        return true;
                    }
                }
            }
            if (composedSchema.getNot() != null) {
                if (isFreeFormObject(openAPI, composedSchema.getNot())) {
                    return true;
                }
            }
            if (composedSchema.getProperties() != null) {
                for (Map.Entry<String, Schema> entry : composedSchema.getProperties().entrySet()) {
                    if (isFreeFormObject(openAPI, entry.getValue())) {
                        return true;
                    }
                }
            }
            if (composedSchema.getAdditionalProperties() != null) {
                if (isFreeFormObject(openAPI, composedSchema.getAdditionalProperties())) {
                    return true;
                }
            }
        }
        return false;
    }",Not Valid,Syntax Error,NOT PASS,NOT PASS,None,None,  0.3414054635109691,  0.3596765663557909,None,None,None,None,221.0,0.6461988304093568,218.0,0.6374269005847953,None,None,274.0,0.9963636363636363,272.0,0.9963369963369964,24.0,0.7741935483870968,4.0,0.3333333333333333,9.0,0.6923076923076923
383,cdk,"private IMolecularFormulaSet returnOrdered(double mass, IMolecularFormulaSet formulaSet){
    IMolecularFormulaSet solutions_new = null;
    if (formulaSet.size() != 0) {
        double valueMin = 100;
        int i_final = 0;
        solutions_new = formulaSet.getBuilder().newInstance(IMolecularFormulaSet.class);
        List<Integer> listI = new ArrayList<Integer>();
        for (int j = 0; j < formulaSet.size(); j++) {
            for (int i = 0; i < formulaSet.size(); i++) {
                if (listI.contains(i))
                    continue;
                double value = MolecularFormulaManipulator.getTotalExactMass(formulaSet.getMolecularFormula(i));
                double diff = Math.abs(mass - Math.abs(value));
                if (valueMin > diff) {
                    valueMin = diff;
                    i_final = i;
                }
            }
            valueMin = 100;
            solutions_new.addMolecularFormula(formulaSet.getMolecularFormula(i_final));
            listI.add(i_final);
        }
    }
    return solutions_new;
}",returnOrdered,org/openscience/cdk/formula/MassToFormulaTool.java,/legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java,"/**
     * Return all molecular formulas but ordered according the tolerance difference between masses.
     *
     * @param  mass        The mass to analyze
     * @param  formulaSet  The IMolecularFormulaSet to order
     * @return             The IMolecularFormulaSet ordered
     */",538-573,"('returnOrdered', {'INSTRUCTION': {'covered': 76, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",193.0,13.0,Return all molecular formulas but ordered according the tolerance difference between masses.,Order the molecular formulas using the tolerance difference between the masses,Return all formulas but order them according to the tolerance difference.,0.312967099220703,Return all molecular formulas but ordered according to the tolerance difference between the masses.,"private IMolecularFormulaSet returnOrdered(double mass, IMolecularFormulaSet formulaSet){
        IMolecularFormulaSet new_formulaSet = builder.newInstance(IMolecularFormulaSet.class);
        for (int i = 0; i < formulaSet.getCount(); i++) {
            IMolecularFormula formula = formulaSet.getMolecularFormula(i);
            double mass_formula = MolecularFormulaManipulator.getTotalExactMass(formula);
            if (Math.abs(mass_formula - mass) <= tolerance)
                new_formulaSet.add(formula);
        }
        return new_formulaSet;
    }","private IMolecularFormulaSet returnOrdered(double mass, IMolecularFormulaSet formulaSet){
        IMolecularFormulaSet new_formulaSet = builder.newInstance(IMolecularFormulaSet.class);
        for (int i = 0; i < formulaSet.getCount(); i++) {
            IMolecularFormula formula = formulaSet.getMolecularFormula(i);
            double mass_formula = MolecularFormulaManipulator.getTotalExactMass(formula);
            if (Math.abs(mass_formula - mass) <= tolerance) {
                new_formulaSet.add(formula);
            }
        }
        return new_formulaSet;
    }","private IMolecularFormulaSet returnOrdered(double mass, IMolecularFormulaSet formulaSet){
        IMolecularFormulaSet orderedFormulaSet = builder.newInstance(IMolecularFormulaSet.class);
        for (int i = 0; i < formulaSet.getMolecularFormulaCount(); i++) {
            IMolecularFormula formula = formulaSet.getMolecularFormula(i);
            double massFormula = MolecularFormulaManipulator.getTotalExactMass(formula);
            double diff = Math.abs(mass - massFormula);
            if (diff < tolerance) {
                orderedFormulaSet.addMolecularFormula(formula);
            }
        }
        return orderedFormulaSet;
    }","private IMolecularFormulaSet returnOrdered(double mass, IMolecularFormulaSet formulaSet){
        IMolecularFormulaSet orderedFormulaSet = builder.newInstance(IMolecularFormulaSet.class);
        for (int i = 0; i < formulaSet.getMolecularFormulaCount(); i++) {
            IMolecularFormula formula = formulaSet.getMolecularFormula(i);
            double massFormula = MolecularFormulaManipulator.getTotalExactMass(formula);
            double massDiff = Math.abs(mass - massFormula);
            if (massDiff < tolerance) {
                orderedFormulaSet.addMolecularFormula(formula);
            }
        }
        return orderedFormulaSet;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3073376808611429,  0.3130005329621927,  0.33127280816753935,  0.33802825910441114,126.0,0.6494845360824743,124.0,0.6391752577319587,118.0,0.6082474226804123,117.0,0.6030927835051546,2.0,0.022222222222222223,18.0,0.18947368421052632,18.0,0.18947368421052632,7.0,0.5384615384615384,2.0,0.13333333333333333,7.0,0.5384615384615384
384,cdk,"static int contribution(int elem, int x, int v){
    switch(elem) {
        case 6:
            if (x == 3 && v == 4)
                return 1;
            break;
        case 7:
            if (x == 2 && v == 3)
                return 1;
            if (x == 3 && v == 4)
                return 1;
            if (x == 3 && v == 3)
                return 2;
            if (x == 2 && v == 2)
                return 2;
            break;
        case 8:
        case 16:
            if (x == 2 && v == 2)
                return 2;
            break;
    }
    return -1;
}",contribution,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,"/**
     * Electron contribution of an element with the specified connectivity and valence.
     *
     * @param elem atomic number
     * @param x    connectivity
     * @param v    bonded valence
     * @return p electrons
     */",355-382,"('contribution', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'BRANCH': {'covered': 28, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 16, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",121.0,12.0,Electron contribution of an element with the specified connectivity and valence.,It returns the contribution of an electron with the defined connectivity and valence.,The element has a specified electron contribution.,0.531232650644111,Electronic contribution of an element with the specified connectivity and valence.,"static int contribution(int elem, int x, int v){
        int c = 0;
        if (x == 1) c = 1;
        else if (x == 2) c = 2;
        else if (x == 3) c = 3;
        else if (x == 4) c = 4;
        else if (x == 5) c = 5;
        else if (x == 6) c = 6;
        else if (x == 7) c = 7;
        else if (x == 8) c = 8;
        else if (x == 9) c = 9;
        else if (x == 10) c = 10;
        else if (x == 11) c = 11;
        else if (x == 12) c = 12;
        else if (x == 13) c = 13;
        else if (x == 14) c = 14;
        else if (x == 15) c = 15;
        else if (x == 16) c = 16;
        else if (x == 17) c = 17;
        else if (x == 18) c = 18;
        else if (x == 19) c = 19;
        else if (x == 20) c = 20;
        else if (x == 21) c = 21;
        else if (x == 22) c = 22;
        else if (x == 23) c = 23;
        else if (x == 24) c = 24;
        else if (x == 25) c = 25;
        else if (x == 26) c = 26;
        else if (x == 27) c = 27;
        else if (x == 28) c = 28;
        else if (x == 29) c = 29;
        else if (x == 30) c = 30;
        else if (x == 31) c = 31;
        else if (x == 32) c = 32;
        else if (x == 33) c = 33;
        else if (x == 34) c = 34;
        else if (x == 35) c = 35;
        else if (x == 36) c = 36;
        else if (x == 37) c = 37;
        else if (x == 38) c = 38;       
 }",Not Valid,"static int contribution(int elem, int x, int v){
        return (elem & (1 << (x + v * 5))) != 0 ? 1 : 0;
    }",Not Valid,NOT PASS,Not Valid,Not Valid,NOT PASS,  0.23891364079859728,None,None,  0.23542960723409062,371.0,0.8470319634703196,None,None,None,None,94.0,0.7704918032786885,None,None,None,None,413.0,0.9429223744292238,5.0,0.35714285714285715,1.0,0.08333333333333333,9.0,0.75
385,openapi-generator,"public static boolean isNullType(Schema schema){
    if (""null"".equals(schema.getType())) {
        return true;
    }
    return false;
}",isNullType,org/openapitools/codegen/utils/ModelUtils.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ModelUtils.java,"/**
     * isNullType returns true if the input schema is the 'null' type.
     *
     * The 'null' type is supported in OAS 3.1 and above. It is not supported
     * in OAS 2.0 and OAS 3.0.x.
     *
     * For example, the ""null"" type could be used to specify that a value must
     * either be null or a specified type:
     *
     * OptionalOrder:
     *   oneOf:
     *     - type: 'null'
     *     - $ref: '#/components/schemas/Order'
     *
     * @param schema the OpenAPI schema
     * @return true if the schema is the 'null' type
     */",1481-1503,"('isNullType', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,13.0,isNullType returns true if the input schema is the 'null' type.,The function returns true if the schema of the input fulfill the 'null' type.,"If the input is a null type, isNullType returns true.",0.635784208155832,isNullType returns true if the input schema is of type 'null'.," public static boolean isNullType(Schema schema){
        if (schema == null) {
            return false;
        }
        if (schema.getType() == null) {
            return false;
        }
        if (schema.getType().equals(SchemaType.NULL)) {
            return true;
        }
        return false;
    }"," public static boolean isNullType(Schema schema){
        if (schema == null) {
            return false;
        }
        if (schema.getType() == null) {
            return false;
        }
        if (schema.getType().equals(SchemaType.NULL)) {
            return true;
        }
        return false;
    }"," public static boolean isNullType(Schema schema){
        if (schema == null) {
            return false;
        }
        if (schema.getType() == null) {
            return false;
        }
        if (schema.getType().equals(Schema.Type.NULL)) {
            return true;
        }
        return false;
    }"," public static boolean isNullType(Schema schema){
        if (schema == null) {
            return false;
        }
        if (schema.getType() == null) {
            return false;
        }
        if (schema.getType().equals(Schema.Type.NULL)) {
            return true;
        }
        return false;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7254414501674668,  0.7254414501674668,  0.7218747631273655,  0.7218747631273655,30.0,0.5,30.0,0.5,32.0,0.5161290322580645,32.0,0.5161290322580645,0.0,0.0,3.0,0.04838709677419355,3.0,0.04838709677419355,7.0,0.4666666666666667,3.0,0.25,11.0,0.9166666666666666
386,acs-aem-commons,"private boolean shouldProcess(String urlPath){
    // If includes are specified but none are valid we skip all requests.
    if (allInvalidIncludes) {
        LOG.debug(""Include patterns are empty due to invalid regex patterns, not processing any requests"");
        return false;
    }
    // If include and exclude lists are both empty we process all requests.
    if (includePatterns.isEmpty() && excludePatterns.isEmpty()) {
        LOG.debug(""Include and Exclude patterns are empty, processing all requests"");
        return true;
    }
    boolean shouldProcess = false;
    for (Pattern pattern : includePatterns) {
        if (pattern.matcher(urlPath).matches()) {
            LOG.debug(""URL path {} matches INCLUDE pattern {}"", urlPath, pattern.toString());
            shouldProcess = true;
            break;
        }
    }
    for (Pattern pattern : excludePatterns) {
        if (pattern.matcher(urlPath).matches()) {
            LOG.debug(""URL path {} matches EXCLUDE pattern {}"", urlPath, pattern.toString());
            shouldProcess = false;
            break;
        }
    }
    LOG.debug(""URL path {} is processed: {}"", urlPath, shouldProcess);
    return shouldProcess;
}",shouldProcess,com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,/bundle/src/main/java/com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,"/**
     * Checks the current URL path against the included and excluded patterns. Exclusions hold priority.
     *
     * @param urlPath Current request path
     * @return if the request should be processed
     */",122-156,"('shouldProcess', {'INSTRUCTION': {'covered': 81, 'missed': 2}, 'BRANCH': {'covered': 10, 'missed': 4}, 'LINE': {'covered': 19, 'missed': 2}, 'COMPLEXITY': {'covered': 4, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",160.0,12.0,Checks the current URL path against the included and excluded patterns.,"Giving priority to the exclusion patterns, check the current URL path agains included and excluded patterns.",The current URL path is checked against the included and excluded patterns.,0.346607690995069,Checks the current URL path against the included and excluded templates.,"private boolean shouldProcess(String urlPath){
        if (includePatterns == null || includePatterns.size() == 0) {
            return false;
        }
        if (excludePatterns != null && excludePatterns.size() > 0) {
            for (Pattern excludePattern : excludePatterns) {
                if (excludePattern.matcher(urlPath).matches()) {
                    return false;
                }
            }
        }
        for (Pattern includePattern : includePatterns) {
            if (includePattern.matcher(urlPath).matches()) {
                return true;
            }
        }
        return allInvalidIncludes;
    }","private boolean shouldProcess(String urlPath){
        if(includePatterns == null || includePatterns.size() == 0){
            return true;
        }
        if(excludePatterns == null || excludePatterns.size() == 0){
            return false;
        }
        for(Pattern excludePattern : excludePatterns){
            if(excludePattern.matcher(urlPath).matches()){
                return false;
            }
        }
        for(Pattern includePattern : includePatterns){
            if(includePattern.matcher(urlPath).matches()){
                return true;
            }
        }
        return allInvalidIncludes;
    }"," private boolean shouldProcess(String urlPath){
        if (includePatterns == null || excludePatterns == null) {
            return true;
        }
        for (Pattern includePattern : includePatterns) {
            if (includePattern.matcher(urlPath).matches()) {
                return true;
            }
        }
        for (Pattern excludePattern : excludePatterns) {
            if (excludePattern.matcher(urlPath).matches()) {
                return false;
            }
        }
        return allInvalidIncludes;
    }","private boolean shouldProcess(String urlPath){
        if (includePatterns == null || includePatterns.size() == 0) {
            return true;
        }
        if (excludePatterns == null || excludePatterns.size() == 0) {
            return true;
        }
        for (Pattern includePattern : includePatterns) {
            if (includePattern.matcher(urlPath).matches()) {
                for (Pattern excludePattern : excludePatterns) {
                    if (excludePattern.matcher(urlPath).matches()) {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.33151314922623926,  0.3330698165265496,  0.32648848684603554,  0.266679527906797,91.0,0.5652173913043478,90.0,0.5590062111801242,89.0,0.5527950310559007,91.0,0.5652173913043478,9.0,0.08571428571428572,26.0,0.24761904761904763,31.0,0.30392156862745096,9.0,0.5294117647058824,1.0,0.08333333333333333,4.0,0.3076923076923077
387,egeria,"private void processDeclassifiedEntityEvent(EntityDetail entityDetail) throws OCFCheckedExceptionBase, JsonProcessingException{
    if (!immutableValidLineageEntityEvents.contains(entityDetail.getType().getTypeDefName())) {
        return;
    }
    log.debug(PROCESSING_ENTITY_DETAIL_DEBUG_MESSAGE, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT.getEventTypeName(), entityDetail.getGUID(), entityDetail.getType().getTypeDefName());
    if (anyLineageClassificationsLeft(entityDetail)) {
        publisher.publishClassificationContext(entityDetail, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT);
        return;
    }
    publishEntityEvent(entityDetail, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT);
}",processDeclassifiedEntityEvent,org/odpi/openmetadata/accessservices/assetlineage/listeners/AssetLineageOMRSTopicListener.java,/open-metadata-implementation/access-services/asset-lineage/asset-lineage-server/src/main/java/org/odpi/openmetadata/accessservices/assetlineage/listeners/AssetLineageOMRSTopicListener.java,"/**
     * Process De-Classified Entity event for lineage entity
     * The entity context is published if there is no lineage classification left.
     * The Classification Context event is sent if there are lineage classifications available on lineage entity.
     *
     * @param entityDetail the entity object that contains a classification that has been deleted
     *
     * @throws OCFCheckedExceptionBase unable to send the event due to connectivity issue
     * @throws JsonProcessingException exception parsing the event json
     */",269-293,"('processDeclassifiedEntityEvent', {'INSTRUCTION': {'covered': 43, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",97.0,20.0,Process De-Classified Entity event for lineage entity  The entity context is published if there is no lineage classification left.,Process the event of the De-Classified Entity for lineage entity; the context will be published if all the lineage classification are done. The context event is sent if the lineage entity has lineage classification available.,"If there is no classification left, the entity context is published.",0.376279899317992,Process declassified entity event for lineage entity The entity context is published if there is no lineage classification left.," private void processDeclassifiedEntityEvent(EntityDetail entityDetail) throws OCFCheckedExceptionBase, JsonProcessingException{
        if (!immutableValidLineageEntityEvents.contains(entityDetail.getType().getTypeDefName()))
            return;
    
        if (!anyLineageClassificationsLeft(entityDetail))
            return;
    
        if (!publisher.isEntityEligibleForPublishing(entityDetail)) {
            return;
        }
    
        log.debug(PROCESSING_ENTITY_DETAIL_DEBUG_MESSAGE, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT.getEventTypeName(),
                entityDetail.getGUID(), entityDetail.getType().getTypeDefName());
        publisher.publishClassificationContext(entityDetail, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT);
    }"," private void processDeclassifiedEntityEvent(EntityDetail entityDetail) throws OCFCheckedExceptionBase, JsonProcessingException{
        if (!immutableValidLineageEntityEvents.contains(entityDetail.getType().getTypeDefName()))
            return;
    
        if (!anyLineageClassificationsLeft(entityDetail))
            return;
    
        if (!publisher.isEntityEligibleForPublishing(entityDetail)) {
            return;
        }
    
        log.debug(PROCESSING_ENTITY_DETAIL_DEBUG_MESSAGE, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT.getEventTypeName(),
                entityDetail.getGUID(), entityDetail.getType().getTypeDefName());
        publisher.publishClassificationContext(entityDetail, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT);
    }"," private void processDeclassifiedEntityEvent(EntityDetail entityDetail) throws OCFCheckedExceptionBase, JsonProcessingException{
        if (!immutableValidLineageEntityEvents.contains(entityDetail.getType().getTypeDefName()))
            return;
    
        if (!anyLineageClassificationsLeft(entityDetail))
            return;
    
        if (!publisher.isEntityEligibleForPublishing(entityDetail)) {
            return;
        }
    
        log.debug(PROCESSING_ENTITY_DETAIL_DEBUG_MESSAGE, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT.getEventTypeName(),
                entityDetail.getGUID(), entityDetail.getType().getTypeDefName());
        publisher.publishClassificationContext(entityDetail, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT);
    }"," private void processDeclassifiedEntityEvent(EntityDetail entityDetail) throws OCFCheckedExceptionBase, JsonProcessingException{
        if (!immutableValidLineageEntityEvents.contains(entityDetail.getType().getTypeDefName()))
            return;
    
        if (!anyLineageClassificationsLeft(entityDetail))
            return;
    
        if (!publisher.isEntityEligibleForPublishing(entityDetail)) {
            return;
        }
    
        log.debug(PROCESSING_ENTITY_DETAIL_DEBUG_MESSAGE, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT.getEventTypeName(),
                entityDetail.getGUID(), entityDetail.getType().getTypeDefName());
        publisher.publishClassificationContext(entityDetail, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8452331694703147,  0.8452331694703147,  0.8452331694703147,  0.8452331694703147,42.0,0.42,42.0,0.42,42.0,0.42,42.0,0.42,0.0,0.0,0.0,0.0,0.0,0.0,26.0,0.7222222222222222,2.0,0.1,16.0,0.8
388,liquibase,"protected void printHelp(List<String> errorMessages, PrintStream stream){
    stream.println(coreBundle.getString(""errors""));
    for (String message : errorMessages) {
        stream.println(""  "" + message);
    }
    stream.println();
}",printHelp,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,"/**
     * If any errors have been found, print the list of errors first, then print the command line help text.
     *
     * @param errorMessages List of error messages
     * @param stream        the output stream to write the text to
     */",1143-1155,"('printHelp', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,22.0,"If any errors have been found, print the list of errors first, then print the command line help text.","If there are errors, it prints the list of errors followed by the help text.","If there are any errors, you should print the list and then the help text.",0.160908969678521,"If errors were detected, first print the list of errors, and then print the help text from the command line.","protected void printHelp(List<String> errorMessages, PrintStream stream){
        if (!errorMessages.isEmpty()) {
            stream.println(coreBundle.getString(""errors.found""));
            for (String errorMessage : errorMessages) {
                stream.println(errorMessage);
            }
        }
        stream.println(coreBundle.getString(""help.header""));
        stream.println(coreBundle.getString(""help.usage""));
        stream.println(coreBundle.getString(""help.options""));
        stream.println(coreBundle.getString(""help.command.line.options""));
        stream.println(coreBundle.getString(""help.command.line.options.long""));
        stream.println(coreBundle.getString(""help.command.line.options.long.2""));
        stream.println(coreBundle.getString(""help.command.line.options.long.3""));
        stream.println(coreBundle.getString(""help.command.line.options.long.4""));
        stream.println(coreBundle.getString(""help.command.line.options.long.5""));
        stream.println(coreBundle.getString(""help.command.line.options.long.6""));
        stream.println(coreBundle.getString(""help.command.line.options.long.7""));
        stream.println(coreBundle.getString(""help.command.line.options.long.8""));
        stream.println(coreBundle.getString(""help.command.line.options.long.9""));
        stream.println(coreBundle.getString(""help.command.line.options.long.10""));
        stream.println(coreBundle.getString(""help.command.line.options.long.11""));
        stream.println(coreBundle.getString(""help.command.line.options.long.12""));
        stream.println(coreBundle.getString(""help.command.line.options.long.13""));
        stream.println(coreBundle.getString(""help.command.line.options.long.14""));
        stream.     
 }"," protected void printHelp(List<String> errorMessages, PrintStream stream){
        if (!errorMessages.isEmpty()) {
            stream.println(coreBundle.getString(""errors.encountered""));
            for (String errorMessage : errorMessages) {
                stream.println(errorMessage);
            }
        }
        stream.println(coreBundle.getString(""help.text""));
    }","protected void printHelp(List<String> errorMessages, PrintStream stream){
        if (errorMessages.size() > 0) {
            stream.println(coreBundle.getString(""errors.found""));
            for (String errorMessage : errorMessages) {
                stream.println(errorMessage);
            }
        }
        stream.println(coreBundle.getString(""help.header""));
        stream.println(coreBundle.getString(""help.usage""));
        stream.println(coreBundle.getString(""help.options""));
        stream.println(coreBundle.getString(""help.command.list""));
        stream.println(coreBundle.getString(""help.command.list.details""));
        stream.println(coreBundle.getString(""help.command.list.details.2""));
        stream.println(coreBundle.getString(""help.command.list.details.3""));
        stream.println(coreBundle.getString(""help.command.list.details.4""));
        stream.println(coreBundle.getString(""help.command.list.details.5""));
        stream.println(coreBundle.getString(""help.command.list.details.6""));
        stream.println(coreBundle.getString(""help.command.list.details.7""));
        stream.println(coreBundle.getString(""help.command.list.details.8""));
        stream.println(coreBundle.getString(""help.command.list.details.9""));
        stream.println(coreBundle.getString(""help.command.list.details.10""));
        stream.println(coreBundle.getString(""help.command.list.details.11""));
        stream.println(coreBundle.getString(""help.command.list.details.12""));
        stream.println(coreBundle.getString(""help.command.list.details.13""));
        stream.println(coreBundle.getString(""help.command.list.details.14""));
        stream.println(coreBundle.getString(""help.command.list.details.15""));
        stream.println(coreB        
 }","protected void printHelp(List<String> errorMessages, PrintStream stream){
        if (!errorMessages.isEmpty()) {
            stream.println(coreBundle.getString(""errors.found""));
            for (String errorMessage : errorMessages) {
                stream.println(errorMessage);
            }
        }
        stream.println(coreBundle.getString(""help.header""));
        stream.println(coreBundle.getString(""help.usage""));
        stream.println(coreBundle.getString(""help.options""));
        stream.println(coreBundle.getString(""help.command.line.options""));
        stream.println(coreBundle.getString(""help.command.line.options.description""));
        stream.println(coreBundle.getString(""help.command.line.options.description.2""));
        stream.println(coreBundle.getString(""help.command.line.options.description.3""));
        stream.println(coreBundle.getString(""help.command.line.options.description.4""));
        stream.println(coreBundle.getString(""help.command.line.options.description.5""));
        stream.println(coreBundle.getString(""help.command.line.options.description.6""));
        stream.println(coreBundle.getString(""help.command.line.options.description.7""));
        stream.println(coreBundle.getString(""help.command.line.options.description.8""));
        stream.println(coreBundle.getString(""help.command.line.options.description.9""));
        stream.println(coreBundle.getString(""help.command.line.options.description.10""));
        stream.println(coreBundle.getString(""help.command.line.options.description.11""));
        stream.println(coreBundle.getString(""help.command.line.options.description.12""));
        stream.println(coreBundle.getString(""help.command.line.options.description.13""));
        stream.println(coreBundle.getString(""help.command.line.options.description.14""));
        stream.     
 }",Syntax Error,PASS,Syntax Error,Syntax Error,None,  0.7158646032504581,None,None,None,None,22.0,0.3283582089552239,227.0,0.8315018315018315,243.0,0.8408304498269896,208.0,0.7619047619047619,14.0,0.05128205128205128,34.0,0.11764705882352941,11.0,0.55,12.0,0.5714285714285714,12.0,0.6
389,glowstone,"public static boolean hasMoved(Location first, Location second){
    return first.getX() != second.getX() || first.getY() != second.getY() || first.getZ() != second.getZ();
}",hasMoved,net/glowstone/util/Position.java,/src/main/java/net/glowstone/util/Position.java,"/**
     * Gets whether there has been a position change between the two Locations.
     *
     * @param first The initial location.
     * @param second The final location.
     * @return A boolean.
     */",76-86,"('hasMoved', {'INSTRUCTION': {'covered': 20, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",50.0,13.0,Gets whether there has been a position change between the two Locations.,Return true if between two locations there has been a change in the position.,Does it mean there has been a position change between the two locations?,0.232918435079785,Gets whether a position change occurred between the two locations.," public static boolean hasMoved(Location first, Location second){
        return !first.getBlock().getLocation().equals(second.getBlock().getLocation());
    }"," public static boolean hasMoved(Location first, Location second){
        return first.getX() != second.getX() || first.getY() != second.getY() || first.getZ() != second.getZ();
    }"," public static boolean hasMoved(Location first, Location second){
        return !first.getBlock().getLocation().equals(second.getBlock().getLocation());
    }"," public static boolean hasMoved(Location first, Location second){
        return first.getBlockX() != second.getBlockX() || first.getBlockY() != second.getBlockY() || first.getBlockZ() != second.getBlockZ();
    }",NOT PASS,PASS,NOT PASS,NOT PASS,  0.4905885304562555,  1.0,  0.8370844755056251,  0.4905885304562555,19.0,0.37254901960784315,0.0,0.0,6.0,0.11764705882352941,19.0,0.37254901960784315,19.0,0.37254901960784315,19.0,0.37254901960784315,0.0,0.0,10.0,0.6666666666666666,5.0,0.38461538461538464,4.0,0.2857142857142857
390,cdk,"public void calculate(IAtomContainer mol) throws CDKException{
    this.mol = mol;
    fplist.clear();
    atomClass = classType <= CLASS_ECFP6 ? ATOMCLASS_ECFP : ATOMCLASS_FCFP;
    excavateMolecule();
    if (atomClass == ATOMCLASS_FCFP)
        calculateBioTypes();
    final int na = mol.getAtomCount();
    identity = new int[na];
    resolvedChiral = new boolean[na];
    atomGroup = new int[na][];
    for (int n = 0; n < na; n++) if (amask[n]) {
        if (atomClass == ATOMCLASS_ECFP)
            identity[n] = initialIdentityECFP(n);
        else
            identity[n] = initialIdentityFCFP(n);
        atomGroup[n] = new int[] { n };
        fplist.add(new FP(identity[n], 0, atomGroup[n]));
    }
    int niter = classType == CLASS_ECFP2 || classType == CLASS_FCFP2 ? 1 : classType == CLASS_ECFP4 || classType == CLASS_FCFP4 ? 2 : classType == CLASS_ECFP6 || classType == CLASS_FCFP6 ? 3 : 0;
    for (int iter = 1; iter <= niter; iter++) {
        final int[] newident = new int[na];
        for (int n = 0; n < na; n++) if (amask[n])
            newident[n] = circularIterate(iter, n);
        identity = newident;
        for (int n = 0; n < na; n++) if (amask[n]) {
            atomGroup[n] = growAtoms(atomGroup[n]);
            considerNewFP(new FP(identity[n], iter, atomGroup[n]));
        }
    }
}",calculate,org/openscience/cdk/fingerprint/CircularFingerprinter.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/CircularFingerprinter.java,"/**
     * Calculates the fingerprints for the given {@link IAtomContainer}, and stores them for subsequent retrieval.
     *
     * @param mol chemical structure; all nodes should be known legitimate elements
     */",227-272,"('calculate', {'INSTRUCTION': {'covered': 189, 'missed': 7}, 'BRANCH': {'covered': 26, 'missed': 6}, 'LINE': {'covered': 28, 'missed': 0}, 'COMPLEXITY': {'covered': 12, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",322.0,19.0,"Calculates the fingerprints for the given {@link IAtomContainer}, and stores them for subsequent retrieval.","Given a IAtomContainer, the function computes the fingerprint and stores it.",The fingerprints are calculated and stored for later use.,0.34468492508322,Calculates fingerprints for the given {@link IAtomContainer} and stores them for later retrieval.," public void calculate(IAtomContainer mol) throws CDKException{
        this.mol = mol;
        calculate();
    }"," public void calculate(IAtomContainer mol) throws CDKException{
        this.mol = mol;
        this.fplist.clear();
        this.identity = new int[mol.getAtomCount()];
        this.resolvedChiral = new boolean[mol.getAtomCount()];
        this.atomGroup = new int[mol.getAtomCount()][];
        this.amask = new boolean[mol.getAtomCount()];
        this.hcount = new int[mol.getAtomCount()];
        this.atomAdj = new int[mol.getAtomCount()][];
        this.bondAdj = new int[mol.getAtomCount()][];
        this.ringBlock = new int[mol.getAtomCount()];
        this.smallRings = new int[mol.getAtomCount()][];
        this.bondOrder = new int[mol.getBondCount()];
        this.atomArom = new boolean[mol.getAtomCount()];
        this.bondArom = new boolean[mol.getBondCount()];
        this.tetra = new int[mol.getAtomCount()][];
        this.maskDon = new boolean[mol.getAtomCount()];
        this.maskAcc = new boolean[mol.getAtomCount()];
        this.maskPos = new boolean[mol.getAtomCount()];
        this.maskNeg = new boolean[mol.getAtomCount()];
        this.maskAro = new boolean[mol.getAtomCount()];
        this.maskHal = new boolean[mol.getAtomCount()];
        this.bondSum = new int[mol.getAtomCount()];
        this.hasDouble = new boolean[mol.getAtomCount()];
        this.aliphatic = new boolean[mol.getAtomCount()];
        this.isOxide = new boolean[mol.getAtomCount()];
        this.lonePair = new boolean[mol.getAtomCount()];
        this.tetrazole = new boolean[mol.getAtomCount()];
        this.calculateF     
 }","public void calculate(IAtomContainer mol) throws CDKException{
        this.mol = mol;
        // initialize the fingerprint list
        fplist.clear();
    
        // initialize the molecule
        initMolecule();
    
        // calculate the fingerprints
        switch (classType) {
            case CLASS_ECFP0: calculateECFP0(); break;
            case CLASS_ECFP2: calculateECFP2(); break;
            case CLASS_ECFP4: calculateECFP4(); break;
            case CLASS_ECFP6: calculateECFP6(); break;
            case CLASS_FCFP0: calculateFCFP0(); break;
            case CLASS_FCFP2: calculateFCFP2(); break;
            case CLASS_FCFP4: calculateFCFP4(); break;
            case CLASS_FCFP6: calculateFCFP6(); break;
        }
    }"," public void calculate(IAtomContainer mol) throws CDKException{
        this.mol = mol;
        calculate();
    }",NOT PASS,Syntax Error,NOT PASS,NOT PASS,  0.05401015679618455,None,  0.05401015679618455,  0.07766318502252734,302.0,0.934984520123839,None,None,302.0,0.934984520123839,262.0,0.8111455108359134,None,None,0.0,0.0,85.0,0.8018867924528302,12.0,0.8,3.0,0.2,11.0,0.7333333333333333
391,glowstone,"public void putFloatList(@NonNls String key, List<Float> list){
    putList(key, TagType.FLOAT, list, FloatTag::new);
}",putFloatList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Adds or replaces a list subtag with a list of floats.
     *
     * @param key the key to write to
     * @param list the list contents as floats, to convert to float tags
     */",967-975,"('putFloatList', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,12.0,Adds or replaces a list subtag with a list of floats.,"Given a list subtag, it adds or replace this list with floats.",A list subtag is replaced with a list of floats.,0.300604074180798,Adds or replaces a list subtag with a floating list.," public void putFloatList(@NonNls String key, List<Float> list){
        putList(key, TagType.FLOAT, list, FloatTag::new);       
 }"," public void putFloatList(@NonNls String key, List<Float> list){
        putList(key, TagType.FLOAT, list, FloatTag::new);       
 }"," public void putFloatList(@NonNls String key, List<Float> list){
        putList(key, TagType.FLOAT, list, FloatTag::new);       
 }"," public void putFloatList(@NonNls String key, List<Float> list){
        putList(key, TagType.FLOAT, list, FloatTag::new);       
 }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10.0,0.7692307692307693,3.0,0.25,6.0,0.5
392,glowstone,"public boolean readStringList(@NonNls String key, Consumer<? super List<String>> consumer){
    return readList(key, TagType.STRING, consumer);
}",readStringList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to a list subtag if it is present and its contents are string
     * tags.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */",584-594,"('readStringList', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,19.0,Applies the given function to a list subtag if it is present and its contents are string  tags.,"If the contents of a list of subtag (if present) are string, apply the provided function. ","If the function is present and the contents are string tags, apply it to the list subtag.",0.482688015856047,Applies the given function to a list subtag if it is present and its contents consist of string tags.," public boolean readStringList(@NonNls String key, Consumer<? super List<String>> consumer){
        return readList(key, TagType.STRING, consumer);
    }"," public boolean readStringList(@NonNls String key, Consumer<? super List<String>> consumer){
        return readList(key, TagType.STRING, consumer);
    }"," public boolean readStringList(@NonNls String key, Consumer<? super List<String>> consumer){
        return readList(key, TagType.STRING, consumer);
    }"," public boolean readStringList(@NonNls String key, Consumer<? super List<String>> consumer){
        return readList(key, TagType.STRING, consumer);
    }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,15.0,0.7894736842105263,2.0,0.1,16.0,0.8421052631578947
393,cdk,"private static Integer findIdx(Map<T, Integer> idxs, T obj){
    Integer idx = idxs.get(obj);
    if (idx == null)
        return -1;
    return idx;
}",findIdx,org/openscience/cdk/io/MDLV3000Writer.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV3000Writer.java,"/**
     * Access the index of Obj->Int map, if the entry isn't found we return -1.
     *
     * @param idxs index map
     * @param obj the object
     * @param <T> the object type
     * @return index or -1 if not found
     */",132-145,"('findIdx', {'INSTRUCTION': {'covered': 9, 'missed': 3}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,19.0,"Access the index of Obj->Int map, if the entry isn't found we return -1.","Return the index of Obj->Int map if found, otherwise -1.","If the entry isn't found, we return -1.",0.416573464775299,"Go to the index of the Obj->Int card, if the entry is not found, we return -1.","private static Integer findIdx(Map<T, Integer> idxs, T obj){
        Integer idx = idxs.get(obj);
        return idx == null ? -1 : idx;
    }","private static Integer findIdx(Map<T, Integer> idxs, T obj){
        Integer idx = idxs.get(obj);
        return idx == null ? -1 : idx;
    }","private static Integer findIdx(Map<T, Integer> idxs, T obj){
        Integer idx = idxs.get(obj);
        return idx == null ? -1 : idx;
    }","private static Integer findIdx(Map<T, Integer> idxs, T obj){
        Integer idx = idxs.get(obj);
        if (idx == null) return -1;
        return idx;
    }",NOT PASS,NOT PASS,PASS,NOT PASS,  0.8019999038577571,  0.8019999038577571,  1.0,  0.8019999038577571,6.0,0.14285714285714285,6.0,0.14285714285714285,0.0,0.0,6.0,0.14285714285714285,0.0,0.0,6.0,0.14285714285714285,0.0,0.0,8.0,0.5333333333333333,7.0,0.3888888888888889,8.0,0.5333333333333333
394,matsim-libs,"public final Volume createVolume(final int h, final double val){
    if (h < 1) {
        throw new RuntimeException(""counts start at 1, not at 0.  If you have a use case where you need to go below one, "" + ""let us know and we think about it, but so far we had numerous debugging sessions because someone inserted counts at 0."");
    }
    // overkill?
    Volume v = new Volume(h, val);
    this.volumes.put(Integer.valueOf(h), v);
    return v;
}",createVolume,org/matsim/counts/Count.java,/matsim/src/main/java/org/matsim/counts/Count.java,"/**
	 * Creates and adds a {@link Volume} to the {@link Count}ing station.
	 * @param h indicating the hour-of-day. <b><i>Note: the hours for a counting 
	 * 		station must be from 1-24, and <b><i>not</i></b> from 0-23, 
	 * 		otherwise the {@link MatsimCountsReader} will throw an error.
	 * 		</i></b>
	 * @param val the total number of vehicles counted during hour <code>h</code>.
	 * @return the {@link Count}ing station's {@link Volume}.
	 */",43-61,"('createVolume', {'INSTRUCTION': {'covered': 18, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",62.0,19.0,Creates and adds a {@link Volume} to the {@link Count}ing station.,The function creates a Volume and adds it to the Count station and ,The @link Volume is added to the @link Counting station.,0.91265673397013,Creates and adds a {@link Volume} to the station {@link Count}ing.," public final Volume createVolume(final int h, final double val){
	 	Volume v = volumes.get(h);
 	if (v == null) {
 		v = new Volume(h, val);
 		volumes.put(h, v);
 	} else {
 		v.add(val);
 	}
 	return v;
 }"," public final Volume createVolume(final int h, final double val){
	 	Volume v = volumes.get(h);
 	if (v == null) {
 		v = new Volume(h, val);
 		volumes.put(h, v);
 	} else {
 		v.add(val);
 	}
 	return v;		
 }"," public final Volume createVolume(final int h, final double val){
	 	if(volumes.containsKey(h)){
 		throw new RuntimeException(""Count already contains a volume for hour ""+h);
 	}
 	Volume v = new Volume(h,val);
 	volumes.put(h,v);
 	return v;		
 }"," public final Volume createVolume(final int h, final double val){
	 	if(volumes.containsKey(h)){
 		throw new RuntimeException(""Count already contains a volume for hour ""+h);
 	}
 	Volume v = new Volume(h,val);
 	volumes.put(h,v);
 	return v;		
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.45712265475699654,  0.48212265475699656,  0.5200640208406511,  0.5200640208406511,32.0,0.48484848484848486,32.0,0.48484848484848486,15.0,0.23809523809523808,15.0,0.23809523809523808,0.0,0.0,26.0,0.3939393939393939,26.0,0.3939393939393939,10.0,0.7142857142857143,3.0,0.25,8.0,0.6666666666666666
395,cdk,"public String toString(){
    StringBuffer stringContent = new StringBuffer(64);
    stringContent.append(""Atom("").append(hashCode());
    if (getSymbol() != null) {
        stringContent.append("", S:"").append(getSymbol());
    }
    if (getImplicitHydrogenCount() != null) {
        stringContent.append("", H:"").append(getImplicitHydrogenCount());
    }
    if (getStereoParity() != null) {
        stringContent.append("", SP:"").append(getStereoParity());
    }
    if (getPoint2d() != null) {
        stringContent.append("", 2D:["").append(getPoint2d()).append(']');
    }
    if (getPoint3d() != null) {
        stringContent.append("", 3D:["").append(getPoint3d()).append(']');
    }
    if (getFractionalPoint3d() != null) {
        stringContent.append("", F3D:["").append(getFractionalPoint3d());
    }
    if (getCharge() != null) {
        stringContent.append("", C:"").append(getCharge());
    }
    stringContent.append("", "").append(super.toString());
    stringContent.append(')');
    return stringContent.toString();
}",toString,org/openscience/cdk/silent/Atom.java,/base/silent/src/main/java/org/openscience/cdk/silent/Atom.java,"/**
     * Returns a one line string representation of this Atom.
     * Methods is conform RFC #9.
     *
     * @return  The string representation of this Atom
     */",489-523,"('toString', {'INSTRUCTION': {'covered': 75, 'missed': 25}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 16, 'missed': 3}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",238.0,10.0,Returns a one line string representation of this Atom.,The function provides a single line representation of the Atom.,A one line string representation of this atom is returned.,0.318444078332272,Returns a string representation of a line of this atom.,"public String toString(){
        StringBuffer sb = new StringBuffer();
        sb.append(getSymbol());
        sb.append(""("");
        sb.append(getPoint2d().x);
        sb.append("","");
        sb.append(getPoint2d().y);
        sb.append("")"");
        return sb.toString();
    }","public String toString(){
        StringBuilder sb = new StringBuilder();
        sb.append(getSymbol());
        sb.append(""("");
        sb.append(getPoint2d().x);
        sb.append("","");
        sb.append(getPoint2d().y);
        sb.append("")"");
        return sb.toString();
    }","public String toString(){
        return super.toString() + "" "" + getSymbol() + "" "" + getPoint3d();
    }","public String toString(){
        StringBuffer sb = new StringBuffer();
        sb.append(getSymbol());
        sb.append("" "");
        sb.append(getPoint2d());
        sb.append("" "");
        sb.append(getPoint3d());
        sb.append("" "");
        sb.append(getFractionalPoint3d());
        sb.append("" "");
        sb.append(getCharge());
        sb.append("" "");
        sb.append(getImplicitHydrogenCount());
        sb.append("" "");
        sb.append(getStereoParity());
        sb.append("" "");
        sb.append(getFlag(CDKConstants.ISINRING));
        sb.append("" "");
        sb.append(getFlag(CDKConstants.ISAROMATIC));
        return sb.toString();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.22365872330099132,  0.21992881237148346,  0.36279362338917887,  0.09825214323429377,178.0,0.7447698744769874,180.0,0.7531380753138075,138.0,0.5774058577405857,221.0,0.9246861924686193,2.0,0.02666666666666667,97.0,0.5843373493975904,59.0,0.7866666666666666,6.0,0.5454545454545454,6.0,0.5454545454545454,5.0,0.45454545454545453
396,jeromq,"public ZMsg msgBinaryPicture(String picture, Object... args){
    if (!BINARY_FORMAT.matcher(picture).matches()) {
        throw new ZMQException(picture + "" is not in expected binary format "" + BINARY_FORMAT.pattern(), ZError.EPROTO);
    }
    ZMsg msg = new ZMsg();
    // Pass 1: calculate total size of data frame
    int frameSize = 0;
    for (int index = 0; index < picture.length(); index++) {
        char pattern = picture.charAt(index);
        switch(pattern) {
            case '1':
                {
                    frameSize += 1;
                    break;
                }
            case '2':
                {
                    frameSize += 2;
                    break;
                }
            case '4':
                {
                    frameSize += 4;
                    break;
                }
            case '8':
                {
                    frameSize += 8;
                    break;
                }
            case 's':
                {
                    String string = (String) args[index];
                    frameSize += 1 + (string != null ? string.getBytes(ZMQ.CHARSET).length : 0);
                    break;
                }
            case 'S':
                {
                    String string = (String) args[index];
                    frameSize += 4 + (string != null ? string.getBytes(ZMQ.CHARSET).length : 0);
                    break;
                }
            case 'b':
            case 'c':
                {
                    byte[] block = (byte[]) args[index];
                    frameSize += 4 + block.length;
                    break;
                }
            case 'f':
                {
                    ZFrame frame = (ZFrame) args[index];
                    msg.add(frame);
                    break;
                }
            case 'm':
                {
                    ZMsg other = (ZMsg) args[index];
                    if (other == null) {
                        msg.add(new ZFrame((byte[]) null));
                    } else {
                        msg.addAll(other);
                    }
                    break;
                }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    // Pass 2: encode data into data frame
    ZFrame frame = new ZFrame(new byte[frameSize]);
    ZNeedle needle = new ZNeedle(frame);
    for (int index = 0; index < picture.length(); index++) {
        char pattern = picture.charAt(index);
        switch(pattern) {
            case '1':
                {
                    needle.putNumber1((int) args[index]);
                    break;
                }
            case '2':
                {
                    needle.putNumber2((int) args[index]);
                    break;
                }
            case '4':
                {
                    needle.putNumber4((int) args[index]);
                    break;
                }
            case '8':
                {
                    needle.putNumber8((long) args[index]);
                    break;
                }
            case 's':
                {
                    needle.putString((String) args[index]);
                    break;
                }
            case 'S':
                {
                    needle.putLongString((String) args[index]);
                    break;
                }
            case 'b':
            case 'c':
                {
                    byte[] block = (byte[]) args[index];
                    needle.putNumber4(block.length);
                    needle.putBlock(block, block.length);
                    break;
                }
            case 'f':
            case 'm':
                break;
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    msg.addFirst(frame);
    return msg;
}",msgBinaryPicture,org/zeromq/proto/ZPicture.java,/src/main/java/org/zeromq/proto/ZPicture.java,"/**
     * Creates a binary encoded 'picture' message to the socket (or actor), so it can be sent.
     * The arguments are encoded in a binary format that is compatible with zproto, and
     * is designed to reduce memory allocations.
     *
     * @param picture The picture argument is a string that defines the
     *                type of each argument. Supports these argument types:
     *                <table>
     *                <caption> </caption>
     *                <tr><th style=""text-align:left"">pattern</th><th style=""text-align:left"">java type</th><th style=""text-align:left"">zproto type</th></tr>
     *                <tr><td>1</td><td>int</td><td>type = ""number"" size = ""1""</td></tr>
     *                <tr><td>2</td><td>int</td><td>type = ""number"" size = ""2""</td></tr>
     *                <tr><td>4</td><td>long</td><td>type = ""number"" size = ""3""</td></tr>
     *                <tr><td>8</td><td>long</td><td>type = ""number"" size = ""4""</td></tr>
     *                <tr><td>s</td><td>String, 0-255 chars</td><td>type = ""string""</td></tr>
     *                <tr><td>S</td><td>String, 0-2^32-1 chars</td><td>type = ""longstr""</td></tr>
     *                <tr><td>b</td><td>byte[], 0-2^32-1 bytes</td><td>type = ""chunk""</td></tr>
     *                <tr><td>c</td><td>byte[], 0-2^32-1 bytes</td><td>type = ""chunk""</td></tr>
     *                <tr><td>f</td><td>ZFrame</td><td>type = ""frame""</td></tr>
     *                <tr><td>m</td><td>ZMsg</td><td>type = ""msg"" <b>Has to be the last element of the picture</b></td></tr>
     *                </table>
     * @param args    Arguments according to the picture
     * @return true when it has been queued on the socket and ØMQ has assumed responsibility for the message.
     * This does not indicate that the message has been transmitted to the network.
     * @apiNote Does not change or take ownership of any arguments.
     */",25-163,"('msgBinaryPicture', {'INSTRUCTION': {'covered': 221, 'missed': 34}, 'BRANCH': {'covered': 27, 'missed': 8}, 'LINE': {'covered': 56, 'missed': 2}, 'COMPLEXITY': {'covered': 20, 'missed': 6}, 'METHOD': {'covered': 1, 'missed': 0}})",600.0,21.0,"Creates a binary encoded 'picture' message to the socket (or actor), so it can be sent.","It creates a binary encoded image of the message, compatible with zproto and optimized in memory allocation, to the socket for sending it. ",A picture message can be sent if it is created in a way that is compatible with the actor.,0.362218078381548,"Creates a binary-encoded 'image' message to the socket (or actor), so that it can be sent."," public ZMsg msgBinaryPicture(String picture, Object... args){
        ZMsg msg = new ZMsg();
        msg.add(picture);
        for (Object arg : args) {
            msg.add(arg);
        }
        return msg;     
 }"," public ZMsg msgBinaryPicture(String picture, Object... args){
        ZMsg msg = new ZMsg();
        msg.add(picture);
        for (Object arg : args) {
            msg.add(arg);
        }
        msg.add(msgBinary(picture, args));
        return msg;     
 }"," public ZMsg msgBinaryPicture(String picture, Object... args){
        ZMsg msg = new ZMsg();
        msg.add(picture);
        for (Object arg : args) {
            msg.add(arg);
        }
        return msg;     
 }"," public ZMsg msgBinaryPicture(String picture, Object... args){
        ZMsg msg = new ZMsg();
        msg.add(picture);
        for (Object arg : args) {
            msg.add(arg);
        }
        return msg;     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.05444726030486859,  0.06162811155011555,  0.05444726030486859,  0.05444726030486859,559.0,0.930116472545757,549.0,0.913477537437604,559.0,0.930116472545757,559.0,0.930116472545757,12.0,0.2,0.0,0.0,0.0,0.0,20.0,0.8333333333333334,4.0,0.23529411764705882,19.0,0.95
397,metrics,"private ByteBuffer encryptPacket(ByteBuffer packet){
    final ByteBuffer payload = (ByteBuffer) ByteBuffer.allocate(SHA1_LENGTH + packet.remaining()).put(sha1(packet)).put((ByteBuffer) packet.flip()).flip();
    final EncryptionResult er = encrypt(password, payload);
    return (ByteBuffer) ByteBuffer.allocate(BUFFER_SIZE).putShort((short) TYPE_ENCR_AES256).putShort((short) (ENCRYPT_DATA_LEN + username.length + er.output.remaining())).putShort((short) username.length).put(username).put(er.iv).put(er.output).flip();
}",encryptPacket,io/dropwizard/metrics5/collectd/PacketWriter.java,/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/PacketWriter.java,"/**
     * Encrypts the provided packet, so it's can't be eavesdropped during a transfer
     * to a CollectD server. Wire format:
     * <pre>
     * +---------------------------------+-------------------------------+
     * ! Type (0x0210)                   ! Length                        !
     * +---------------------------------+-------------------------------+
     * ! Username length in bytes        ! Username                      \
     * +-----------------------------------------------------------------+
     * ! Initialization Vector (IV)      !                               \
     * +---------------------------------+-------------------------------+
     * ! Encrypted bytes (AES (SHA1(packet) + packet))                   \
     * +---------------------------------+-------------------------------+
     * </pre>
     *
     * @see <a href=""https://collectd.org/wiki/index.php/Binary_protocol#Encrypted_part"">
     * Binary protocol - CollectD | Encrypted part</a>
     */",170-202,"('encryptPacket', {'INSTRUCTION': {'covered': 49, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",138.0,20.0,"Encrypts the provided packet, so it's can't be eavesdropped during a transfer  to a CollectD server.","The packet, in order to be eavesdropped when it is transfered to a CollectD server, is encrypted.",The packet can't be eavesdropped on during a transfer to a CollectD server.,0.598769580556177,"Encrypts the supplied packet, so that it cannot be listened to during a transfer to a CollectD server.","private ByteBuffer encryptPacket(ByteBuffer packet){
        final byte[] iv = new byte[IV_LENGTH];
        new SecureRandom().nextBytes(iv);
        final byte[] ciphertext = encrypt(password, iv, (ByteBuffer) ByteBuffer.allocate(packet.remaining() + username.length)
                .put(username)
                .put(packet)
                .flip());
        return (ByteBuffer) ByteBuffer.allocate(BUFFER_SIZE)
                .putShort((short) TYPE_ENCRYPT_AES256)
                .putShort((short) (username.length + ENCRYPT_DATA_LEN))
                .put(iv)
                .putShort((short) TYPE_SIGN_SHA256)
                .putShort((short) (username.length + SIGNATURE_LEN))
                .put(sign(password, (ByteBuffer) ByteBuffer.allocate(ciphertext.length + username.length)
                        .put(username)
                        .put(ciphertext)
                        .flip()))
                .put(username)
                .put(ciphertext)
                .flip();
    }","private ByteBuffer encryptPacket(ByteBuffer packet){
        final byte[] iv = new byte[IV_LENGTH];
        new SecureRandom().nextBytes(iv);
        final byte[] ciphertext = encrypt(password, iv, (ByteBuffer) ByteBuffer.allocate(packet.remaining() + username.length)
                .put(username)
                .put(packet)
                .flip());
        return (ByteBuffer) ByteBuffer.allocate(BUFFER_SIZE)
                .putShort((short) TYPE_ENCRYPT_AES256)
                .putShort((short) (username.length + ENCRYPT_DATA_LEN))
                .put(iv)
                .putShort((short) TYPE_SIGN_SHA256)
                .putShort((short) (username.length + SIGNATURE_LEN))
                .put(sign(password, (ByteBuffer) ByteBuffer.allocate(ciphertext.length + username.length)
                        .put(username)
                        .put(ciphertext)
                        .flip()))
                .put(username)
                .put(ciphertext)
                .flip();
    }","private ByteBuffer encryptPacket(ByteBuffer packet){
        final byte[] iv = new byte[IV_LENGTH];
        new SecureRandom().nextBytes(iv);
        final byte[] ciphertext = encrypt(password, iv, (ByteBuffer) ByteBuffer.allocate(packet.remaining() + username.length)
                .put(username)
                .put(packet)
                .flip());
        return (ByteBuffer) ByteBuffer.allocate(BUFFER_SIZE)
                .putShort((short) TYPE_ENCRYPT_AES256)
                .putShort((short) (username.length + ENCRYPT_DATA_LEN))
                .put(iv)
                .putShort((short) DATA_TYPE_GAUGE)
                .putShort((short) ciphertext.length)
                .put(ciphertext)
                .put(username)
                .put((ByteBuffer) packet.flip())
                .flip();
    }","private ByteBuffer encryptPacket(ByteBuffer packet){
        final byte[] iv = new byte[IV_LENGTH];
        new SecureRandom().nextBytes(iv);
        final byte[] ciphertext = encrypt(password, iv, (ByteBuffer) ByteBuffer.allocate(packet.remaining() + ENCRYPT_DATA_LEN)
                .put(iv)
                .putShort((short) TYPE_ENCRYPT_AES256)
                .putShort((short) (packet.remaining() + ENCRYPT_DATA_LEN))
                .put(packet)
                .flip());
        return (ByteBuffer) ByteBuffer.allocate(BUFFER_SIZE)
                .putShort((short) TYPE_ENCRYPT_AES256)
                .putShort((short) (ENCRYPT_DATA_LEN + ciphertext.length))
                .put(iv)
                .put(ciphertext)
                .flip();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5661128154316744,  0.5356250105536255,  0.5509772296216164,  0.6015567522820255,101.0,0.5343915343915344,101.0,0.5343915343915344,91.0,0.6232876712328768,76.0,0.4779874213836478,0.0,0.0,71.0,0.37566137566137564,35.0,0.18518518518518517,13.0,0.7222222222222222,6.0,0.3157894736842105,7.0,0.4117647058823529
398,cdk,"public boolean isDiscrete(){
    for (SortedSet<Integer> cell : cells) {
        if (cell.size() != 1) {
            return false;
        }
    }
    return true;
}",isDiscrete,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,"/**
     * Checks that all the cells are singletons - that is, they only have one
     * element. A discrete partition is equivalent to a permutation.
     *
     * @return true if all the cells are discrete
     */",141-154,"('isDiscrete', {'INSTRUCTION': {'covered': 18, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,17.0,"Checks that all the cells are singletons - that is, they only have one  element.","Verifies if all cells are singletons, so containing a single element.","The cells only have one element, so it's important to check that.",0.45793588886739,"Verifies that all cells are singletons - that is, they have only one element.","public boolean isDiscrete(){
        for (SortedSet<Integer> cell : cells) {
            if (cell.size() != 1) return false;
        }
        return true;
    }","public boolean isDiscrete(){
        for (SortedSet<Integer> cell : cells) {
            if (cell.size() != 1) {
                return false;
            }
        }
        return true;
    }","public boolean isDiscrete(){
        for (SortedSet<Integer> cell : cells) {
            if (cell.size() > 1) {
                return false;
            }
        }
        return true;
    }","public boolean isDiscrete(){
        for (SortedSet<Integer> cell : cells) {
            if (cell.size() != 1) return false;
        }
        return true;
    }",PASS,PASS,PASS,PASS,  0.8607245621933981,  1.0,  0.8607245621933981,  0.9645803653700176,2.0,0.05263157894736842,0.0,0.0,2.0,0.05263157894736842,1.0,0.02631578947368421,2.0,0.05263157894736842,0.0,0.0,3.0,0.07894736842105263,11.0,0.6875,4.0,0.25,14.0,0.875
401,anserini,"private static Set<String> nearestVector(Map<String, List<float[]>> vectors, String word, int topN){
    Set<String> intermediate = new TreeSet<>();
    List<float[]> inputs = vectors.get(word);
    String separateToken = ""__"";
    for (Map.Entry<String, List<float[]>> entry : vectors.entrySet()) {
        for (float[] value : entry.getValue()) {
            for (float[] input : inputs) {
                float sim = 0;
                for (int i = 0; i < value.length; i++) {
                    sim += value[i] * input[i];
                }
                // store the words, sorted by decreasing distance using natural order (in the $dist__$word format)
                intermediate.add((1 - sim) + separateToken + entry.getKey());
            }
        }
    }
    Set<String> result = new HashSet<>();
    int i = 0;
    for (String w : intermediate) {
        if (i == topN) {
            break;
        }
        // only add actual word String (not the distance) to the result collection
        result.add(w.substring(w.indexOf(separateToken) + 2));
        i++;
    }
    return result;
}",nearestVector,io/anserini/ann/ApproximateNearestNeighborEval.java,/src/main/java/io/anserini/ann/ApproximateNearestNeighborEval.java,"/**
   * Calculate the nearest <i>N</i> words for a given input word.
   *
   * @param vectors vectors, keyed by word
   * @param word    the input word
   * @param topN    the number of similar word vectors to output
   * @return the {@code topN} similar words of the input word
   */",216-251,"('nearestVector', {'INSTRUCTION': {'covered': 111, 'missed': 1}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 21, 'missed': 1}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",229.0,17.0,Calculate the nearest <i>N</i> words for a given input word.,"Given an input word, compute the nearest N words.",The nearest words for the input word are calculated.,0.137159731730175,Calculate the <i>N</i> closest words for a given entry word.," private static Set<String> nearestVector(Map<String, List<float[]>> vectors, String word, int topN){
    List<float[]> wordVectors = vectors.get(word);
    if (wordVectors == null) {
      return Collections.emptySet();
    }
    Set<String> nearest = new HashSet<>();
    for (float[] vector : wordVectors) {
      List<String> nearestWords = nearestVector(vectors, vector, topN);
      nearest.addAll(nearestWords);
    }
    return nearest;   
 }"," private static Set<String> nearestVector(Map<String, List<float[]>> vectors, String word, int topN){
    Set<String> nearest = new HashSet<>();
    List<float[]> wordVectors = vectors.get(word);
    if (wordVectors == null) {
      return nearest;
    }
    for (float[] vector : wordVectors) {
      List<String> nearestWords = nearestVector(vectors, vector, topN);
      nearest.addAll(nearestWords);
    }
    return nearest;   
 }","private static Set<String> nearestVector(Map<String, List<float[]>> vectors, String word, int topN){
    List<float[]> wordVectors = vectors.get(word);
    if (wordVectors == null) {
      return Collections.emptySet();
    }
    Set<String> nearest = new HashSet<>();
    for (float[] vector : wordVectors) {
      Map<String, Double> distances = new HashMap<>();
      for (String otherWord : vectors.keySet()) {
        if (!otherWord.equals(word)) {
          List<float[]> otherVectors = vectors.get(otherWord);
          for (float[] otherVector : otherVectors) {
            double distance = cosineDistance(vector, otherVector);
            distances.put(otherWord, distance);
          }
        }
      }
      List<Map.Entry<String, Double>> sorted = new ArrayList<>(distances.entrySet());
      sorted.sort(Comparator.comparing(Map.Entry::getValue));
      for (int i = 0; i < topN; i++) {
        Map.Entry<String, Double> entry = sorted.get(i);
        nearest.add(entry.getKey());
      }
    }
    return nearest;   
 }","private static Set<String> nearestVector(Map<String, List<float[]>> vectors, String word, int topN){
    List<float[]> wordVectors = vectors.get(word);
    if (wordVectors == null) {
      return Collections.emptySet();
    }
    List<float[]> allVectors = new ArrayList<>(vectors.values());
    float[] queryVector = wordVectors.get(0);
    float[] distances = new float[allVectors.size()];
    for (int i = 0; i < allVectors.size(); i++) {
      float[] vector = allVectors.get(i);
      distances[i] = cosineSimilarity(queryVector, vector);
    }
    Arrays.sort(distances);
    Set<String> nearest = new HashSet<>();
    for (int i = 0; i < topN; i++) {
      nearest.add(allVectors.get(distances[i]).toString());
    }
    return nearest;   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3039160875826192,  0.29765821791427244,  0.46744366152592065,  0.5301322566203842,156.0,0.6782608695652174,149.0,0.6478260869565218,123.0,0.5347826086956522,170.0,0.6614785992217899,31.0,0.28440366972477066,117.0,0.5598086124401914,154.0,0.5992217898832685,10.0,0.9090909090909091,3.0,0.2727272727272727,8.0,0.7272727272727273
402,cdk,"static void updateAromaticTypesInSixMemberRing(int[] cycle, String[] symbs){
    for (final int v : cycle) {
        if (NCN_PLUS.equals(symbs[v]) || ""N+=C"".equals(symbs[v]) || ""N=+C"".equals(symbs[v]))
            symbs[v] = ""NPD+"";
        else if (""N2OX"".equals(symbs[v]))
            symbs[v] = ""NPOX"";
        else if (""N=C"".equals(symbs[v]) || ""N=N"".equals(symbs[v]))
            symbs[v] = ""NPYD"";
        else if (symbs[v].startsWith(""C""))
            symbs[v] = ""CB"";
    }
}",updateAromaticTypesInSixMemberRing,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,"/**
     * Update aromatic atom types in a six member ring. The aromatic types here are hard coded from
     * the 'MMFFAROM.PAR' file.
     *
     * @param cycle 6-member aromatic cycle / ring
     * @param symbs vector of symbolic types for the whole structure
     */",219-236,"('updateAromaticTypesInSixMemberRing', {'INSTRUCTION': {'covered': 78, 'missed': 0}, 'BRANCH': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",135.0,10.0,Update aromatic atom types in a six member ring.,"Update the so called aromatic atoms, hard coded from MMFFAROM.PAR file, that are contained in a six member ring.",The aromatic atom types are updated.,0.318474221459417,Update the types of aromatic atoms in a six-member ring.,"static void updateAromaticTypesInSixMemberRing(int[] cycle, String[] symbs){
     
      int len = cycle.length - 1;
      int i = 0;
      int iPrev = len - 1;
      int iNext = 1;
     
      while (i < len) {
     
            int prev = cycle[iPrev];
            int curr = cycle[i];
            int next = cycle[iNext];
     
            String prevSymb = symbs[prev];
            String currSymb = symbs[curr];
            String nextSymb = symbs[next];
     
            if (prevSymb.equals(currSymb) && currSymb.equals(nextSymb)) {
                 symbs[curr] = ""A"";
            }
     
            iPrev = i;
            i = iNext;
            iNext = iNext + 1;
      }         
 }",Not Valid,"static void updateAromaticTypesInSixMemberRing(int[] cycle, String[] symbs){
     
      int i = 0;
      int iPrev = 5;
      int iNext = 1;
     
      while (i < 6) {
     
            int prev = cycle[iPrev];
            int curr = cycle[i];
            int next = cycle[iNext];
     
            String sym = symbs[curr];
     
            if (sym.equals(""C.ar"")) {
                 symbs[curr] = ""C.2"";
            } else if (sym.equals(""N.ar"")) {
                 symbs[curr] = ""N.2"";
            } else if (sym.equals(""O.ar"")) {
                 symbs[curr] = ""O.2"";
            } else if (sym.equals(""S.ar"")) {
                 symbs[curr] = ""S.2"";
            } else if (sym.equals(""P.ar"")) {
                 symbs[curr] = ""P.3"";
            } else if (sym.equals(""F.ar"")) {
                 symbs[curr] = ""F.2"";
            } else if (sym.equals(""Cl.ar"")) {
                 symbs[curr] = ""Cl.2"";
            } else if (sym.equals(""Br.ar"")) {
                 symbs[curr] = ""Br.2"";
            } else if (sym.equals(""I.ar"")) {
                 symbs[curr] = ""I.2"";
            }
     
            iPrev = i;
            i = iNext;
            iNext = iNext + 1;
      }         
 }","static void updateAromaticTypesInSixMemberRing(int[] cycle, String[] symbs){
     
      int i = 0;
      int iPrev = 5;
      int iNext = 1;
     
      while (i < 6) {
     
            int curr = cycle[i];
            int prev = cycle[iPrev];
            int next = cycle[iNext];
     
            if (symbs[curr].equals(MMFF94AtomType.AROMATIC_CARBON.getType())) {
                 symbs[curr] = MMFF94AtomType.AROMATIC_CARBON_SIX_MEMBER_RING.getType();
            }
     
            iPrev = i;
            i = iNext;
            iNext = iNext + 1;
      }         
 }",NOT PASS,Not Valid,NOT PASS,NOT PASS,  0.2870314865859172,None,  0.2361358223771807,  0.27789364131857136,103.0,0.7463768115942029,None,None,96.0,0.7058823529411765,164.0,0.640625,None,None,53.0,0.38405797101449274,155.0,0.60546875,12.0,0.6,7.0,0.6363636363636364,6.0,0.6
403,cdk,"public static IAtomContainer correct(IAtomContainer container){
    if (container.stereoElements().iterator().hasNext())
        new CorrectGeometricConfiguration(container);
    return container;
}",correct,org/openscience/cdk/layout/CorrectGeometricConfiguration.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/CorrectGeometricConfiguration.java,"/**
     * Adjust all double bond elements in the provided structure. <b>IMPORTANT:
     * up/down labels should be adjusted before adjust double-bond
     * configurations. coordinates are reflected by this method which can lead
     * to incorrect tetrahedral specification.</b>
     *
     * @param container the structure to adjust
     * @throws IllegalArgumentException an atom had unset coordinates
     */",70-83,"('correct', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,10.0,Adjust all double bond elements in the provided structure.,The function is used to adjust the double bond elements in the structure.,The structure has double bond elements.,0.399344700431223,Adjust all double-bonded elements in the provided structure.," public static IAtomContainer correct(IAtomContainer container){
        CorrectGeometricConfiguration c = new CorrectGeometricConfiguration(container);
        c.correct();
        return container;
    }"," public static IAtomContainer correct(IAtomContainer container){
        CorrectGeometricConfiguration correct = new CorrectGeometricConfiguration(container);
        correct.correct();
        return container;
    }"," public static IAtomContainer correct(IAtomContainer container){
        CorrectGeometricConfiguration cg = new CorrectGeometricConfiguration(container);
        cg.correct();
        return container;
    }"," public static IAtomContainer correct(IAtomContainer container){
        CorrectGeometricConfiguration cg = new CorrectGeometricConfiguration(container);
        cg.correct();
        return container;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5325810940041963,  0.5950810940041963,  0.5325810940041963,  0.5325810940041963,17.0,0.4722222222222222,17.0,0.4722222222222222,17.0,0.4722222222222222,17.0,0.4722222222222222,2.0,0.06896551724137931,2.0,0.06896551724137931,2.0,0.06896551724137931,8.0,0.5714285714285714,2.0,0.2,8.0,0.8
405,cdk,"final int nextM(int n, int m){
    if (size == 0)
        return m + 1;
    for (int i = m + 1; i < g2.length; i++) if (m2[i] == UNMAPPED && (t1[n] == 0 || t2[i] > 0))
        return i;
    return mMax();
}",nextM,org/openscience/cdk/isomorphism/AbstractVFState.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/AbstractVFState.java,"/**
     * Given the current target candidate (m), find the next candidate. The next
     * candidate is the next vertex > m (in some ordering) that is unmapped and
     * is adjacent to a mapped vertex (terminal). If there is no such vertex
     * (disconnected) the next unmapped vertex is returned. If there are no more
     * candidates m == |V| of G2.
     *
     * @param m previous candidate m
     * @return the next value of m
     */",94-112,"('nextM', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,14.0,"Given the current target candidate (m), find the next candidate.","Given the current target candidate, it returns the next candidate, the verted that is unmpapped and adjacent to a terminal mapped vertex. If it can not find the vertex, it returns the next unmapped vertex or the cardinality of the vertex if there are no more candidates.",The next candidate should be found given the current target candidate.,0.5337023697731,"Given the current target candidate (m), find the next candidate.","final int nextM(int n, int m){
        if (size == 0) return 0;
        for (int i = m + 1; i < g2.length; i++)
            if (m2[i] == UNMAPPED && t2[i] > 0) return i;
        for (int i = m + 1; i < g2.length; i++)
            if (m2[i] == UNMAPPED) return i;
        return mMax();
    }","final int nextM(int n, int m){
        if (size == 0) return 0;
        for (int i = m + 1; i < g2.length; i++)
            if (m2[i] == UNMAPPED && t2[i] > 0) return i;
        for (int i = m + 1; i < g2.length; i++)
            if (m2[i] == UNMAPPED) return i;
        return nMax();
    }","final int nextM(int n, int m){
        if (size == 0) return 0;
        for (int i = m + 1; i < g2.length; i++)
            if (m2[i] == UNMAPPED && t2[i] > 0) return i;
        for (int i = m + 1; i < g2.length; i++)
            if (m2[i] == UNMAPPED) return i;
        return mMax();
    }","final int nextM(int n, int m){
        if (size == 0) return 0;
        for (int i = m + 1; i < g2.length; i++)
            if (m2[i] == UNMAPPED && t2[i] > 0) return i;
        for (int i = m + 1; i < g2.length; i++)
            if (m2[i] == UNMAPPED) return i;
        return nMax();
    }",NOT PASS - TIMEOUT,NOT PASS - TIMEOUT,NOT PASS - TIMEOUT,NOT PASS - TIMEOUT,  0.6862962911493381,  0.6700710136492103,  0.6700710136492103,  0.6862962911493381,35.0,0.3723404255319149,36.0,0.3829787234042553,36.0,0.3829787234042553,35.0,0.3723404255319149,1.0,0.010638297872340425,1.0,0.010638297872340425,0.0,0.0,40.0,0.8333333333333334,0.0,0.0,9.0,0.75
406,cdk,"public void addIsotope(IIsotope isotope, int countMin, int countMax){
    if (isotope == null)
        throw new IllegalArgumentException(""Isotope must not be null"");
    boolean flag = false;
    for (Iterator<IIsotope> it = isotopes().iterator(); it.hasNext(); ) {
        IIsotope thisIsotope = it.next();
        if (isTheSame(thisIsotope, isotope)) {
            isotopesMax.put(thisIsotope, countMax);
            isotopesMin.put(thisIsotope, countMin);
            flag = true;
            break;
        }
    }
    if (!flag) {
        isotopesMax.put(isotope, countMax);
        isotopesMin.put(isotope, countMin);
    }
}",addIsotope,org/openscience/cdk/formula/MolecularFormulaRange.java,/tool/formula/src/main/java/org/openscience/cdk/formula/MolecularFormulaRange.java,"/**
     *  Adds an Isotope to this MolecularFormulaExpand in a number of
     *  maximum and minimum occurrences allowed.
     *
     * @param  isotope  The isotope to be added to this MolecularFormulaExpand
     * @param  countMax The maximal number of occurrences to add
     * @param  countMin The minimal number of occurrences to add
     *
     */",58-86,"('addIsotope', {'INSTRUCTION': {'covered': 60, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",127.0,16.0,Adds an Isotope to this MolecularFormulaExpand in a number of  maximum and minimum occurrences allowed.,Adds to the MolecularFormulaExpand the isotope in a number that represents the maximum and minimum occurrences allowed.,A number of maximum and minimum occurrences are allowed.,0.622435466431553,Adds an isotope to this MolecularFormulaExpand in a number of maximum and minimum allowed occurrences.," public void addIsotope(IIsotope isotope, int countMin, int countMax){
        isotopesMax.put(isotope, countMax);
        isotopesMin.put(isotope, countMin);     
 }"," public void addIsotope(IIsotope isotope, int countMin, int countMax){
        isotopesMax.put(isotope, countMax);
        isotopesMin.put(isotope, countMin);     
 }",Empty Method,Empty Method,NOT PASS,NOT PASS,Empty Method,Empty Method,  0.23674867697775287,  0.23674867697775287,None,None,94.0,0.734375,94.0,0.734375,None,None,None,None,0.0,0.0,None,None,None,None,8.0,0.4444444444444444,3.0,0.1875,9.0,0.5625
407,anserini,"public static Document documentByField(IndexReader reader, String field, String id){
    try {
        IndexSearcher searcher = new IndexSearcher(reader);
        Query q = new TermQuery(new Term(field, id));
        TopDocs rs = searcher.search(q, 1);
        ScoreDoc[] hits = rs.scoreDocs;
        if (hits == null || hits.length == 0) {
            return null;
        }
        return reader.document(hits[0].doc);
    } catch (IOException e) {
        return null;
    }
}",documentByField,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,"/**
   * Fetches the Lucene {@link Document} based on some field other than its unique collection docid. For example,
   * scientific articles might have DOIs. The method is named to be consistent with Lucene's
   * {@link IndexReader#document(int)}, contra Java's standard method naming conventions.
   *
   * @param reader index reader
   * @param field field
   * @param id unique id
   * @return corresponding Lucene {@link Document} based on the value of a specific field
   */",509-536,"('documentByField', {'INSTRUCTION': {'covered': 34, 'missed': 5}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 6, 'missed': 3}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",104.0,19.0,Fetches the Lucene {@link Document} based on some field other than its unique collection docid.,"Fetches the Lucene Document using some fields other than the docid, a unique collection id.",The Lucene @link Document is based on a field other than its unique collection.,1.23557630517751,Retrieves the Lucene {@link Document} based on a field other than its unique collection docid.," public static Document documentByField(IndexReader reader, String field, String id){
    try {
      return reader.document(reader.docFreq(new Term(field, id)));
    } catch (Exception e) {
      // Eat any exceptions and just return null.
      return null;
    }
  }"," public static Document documentByField(IndexReader reader, String field, String id){
    try {
      return reader.document(IndexReaderUtils.convertDocidToLuceneDocid(reader, field, id));
    } catch (Exception e) {
      // Eat any exceptions and just return null.
      return null;
    }
  }"," public static Document documentByField(IndexReader reader, String field, String id){
    try {
      return reader.document(IndexReaderUtils.convertDocidToLuceneDocidByField(reader, field, id));
    } catch (Exception e) {
      // Eat any exceptions and just return null.
      return null;
    }
  }"," public static Document documentByField(IndexReader reader, String field, String id){
    try {
      return reader.document(reader.docFreq(new Term(field, id)));
    } catch (Exception e) {
      // Eat any exceptions and just return null.
      return null;
    }
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3237689445188936,  0.29017621189657616,  0.3237689445188936,  0.29017621189657616,63.0,0.6,68.0,0.6476190476190476,63.0,0.6,68.0,0.6476190476190476,6.0,0.12244897959183673,0.0,0.0,6.0,0.12244897959183673,9.0,0.5625,2.0,0.125,8.0,0.5
408,cucumber-reporting,"private void applyPatchForFeatures(){
    for (int i = 0; i < totalFeatures.length; i++) {
        int total = totalFeatures[i];
        int failures = getFailedFeatures()[i];
        if (total < failures) {
            int tmp = total;
            totalFeatures[i] = failures;
            failedFeatures[i] = tmp;
        }
    }
}",applyPatchForFeatures,net/masterthought/cucumber/Trends.java,/src/main/java/net/masterthought/cucumber/Trends.java,"/**
     * Due to the error with old implementation where total features
     * were passed instead of failures (and vice versa) following correction must be applied for trends generated
     * between release 3.0.0 and 3.1.0.
     */",188-204,"('applyPatchForFeatures', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",70.0,32.0,Due to the error with old implementation where total features  were passed instead of failures (and vice versa) following correction must be applied for trends generated  between release 3.,Applies a patch returning the failure rather than the total features.,The old implementation where total features were passed instead of failures must be corrected.,1.89858938165924,"Due to the error with the old implementation where the total functionality was passed instead of failures (and vice versa), the following fix should be applied for trends generated between version 3.","private void applyPatchForFeatures(){
        if (passedFeatures.length > 0 && passedFeatures[0] > 0) {
            for (int i = 0; i < passedFeatures.length; i++) {
                passedFeatures[i] = passedFeatures[i] - failedFeatures[i];
            }
        }
    }","private void applyPatchForFeatures(){
        if (totalFeatures.length > 0) {
            int lastIndex = totalFeatures.length - 1;
            int lastValue = totalFeatures[lastIndex];
            if (lastValue > passedFeatures[lastIndex]) {
                totalFeatures[lastIndex] = lastValue - passedFeatures[lastIndex];
            }
        }
    }","private void applyPatchForFeatures(){
        if (failedFeatures.length < buildNumbers.length) {
            int[] newFailedFeatures = new int[buildNumbers.length];
            System.arraycopy(failedFeatures, 0, newFailedFeatures, 0, failedFeatures.length);
            failedFeatures = newFailedFeatures;
        }
    }","private void applyPatchForFeatures(){
        if (totalFeatures.length > 0 && totalFeatures[0] > 0 && passedFeatures[0] == 0){
            passedFeatures[0] = totalFeatures[0];
            totalFeatures[0] = 0;
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.36840755622511595,  0.2734599790592107,  0.15270016672215897,  0.2007727805331497,45.0,0.6338028169014085,38.0,0.5352112676056338,43.0,0.6056338028169014,47.0,0.6619718309859155,33.0,0.5689655172413793,27.0,0.46551724137931033,41.0,0.7068965517241379,29.0,0.9666666666666667,9.0,0.2727272727272727,17.0,0.5666666666666667
409,cdk,"public IChemFormat[] findChemFormats(int features){
    if (formats == null)
        loadFormats();
    Iterator<IChemFormat> iter = formats.iterator();
    List<IChemFormat> matches = new ArrayList<IChemFormat>();
    while (iter.hasNext()) {
        IChemFormat format = (IChemFormat) iter.next();
        if ((format.getSupportedDataFeatures() & features) == features)
            matches.add(format);
    }
    return (IChemFormat[]) matches.toArray(new IChemFormat[matches.size()]);
}",findChemFormats,org/openscience/cdk/io/WriterFactory.java,/storage/io/src/main/java/org/openscience/cdk/io/WriterFactory.java,"/**
     * Finds IChemFormats that provide a container for serialization for the
     * given features. The syntax of the integer is explained in the DataFeatures class.
     *
     * @param  features the data features for which a IChemFormat is searched
     * @return          an array of IChemFormat's that can contain the given features
     *
     * @see    org.openscience.cdk.tools.DataFeatures
     */",73-93,"('findChemFormats', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",111.0,13.0,Finds IChemFormats that provide a container for serialization for the  given features.,Provides a container for the serialization of a feature using IChemFormats.,IChemFormats provide a container for serialization.,0.842450092697043,Looks for IChemFormats that provide a container for serializing given features.," public IChemFormat[] findChemFormats(int features){
        List<IChemFormat> formats = new ArrayList<IChemFormat>();
        for (IChemFormat format : getChemFormats()) {
            if (format.getSupportedFeatures() == features) {
                formats.add(format);
            }
        }
        return formats.toArray(new IChemFormat[formats.size()]);
    }"," public IChemFormat[] findChemFormats(int features){
        List<IChemFormat> chemFormats = new ArrayList<IChemFormat>();
        for (IChemFormat format : getChemFormats()) {
            if ((format.getSupportedFeatures() & features) == features) {
                chemFormats.add(format);
            }
        }
        return chemFormats.toArray(new IChemFormat[chemFormats.size()]);
    }","public IChemFormat[] findChemFormats(int features){
        if (formats == null) {
            formats = new ArrayList<IChemFormat>();
            try {
                BufferedReader reader = new BufferedReader(new InputStreamReader(
                        this.getClass().getClassLoader().getResourceAsStream(IO_FORMATS_LIST)));
                String line = reader.readLine();
                while (line != null) {
                    if (line.startsWith(""#"") || line.length() == 0) {
                        line = reader.readLine();
                        continue;
                    }
                    String[] tokens = line.split(""\\s+"");
                    if (tokens.length != 3) {
                        logger.warn(""Could not parse line: "" + line);
                        line = reader.readLine();
                        continue;
                    }
                    String formatName = tokens[0];
                    String formatClass = tokens[1];
                    String formatDescription = tokens[2];
                    try {
                        Class<?> formatClassObject = Class.forName(formatClass);
                        if (IChemFormat.class.isAssignableFrom(formatClassObject)) {
                            IChemFormat format = (IChemFormat) formatClassObject.newInstance();
                            format.setFormatName(formatName);
                            format.setFormatDescription(formatDescription);
                            formats.add(format);
                        } else {
                            logger.warn(""Class "" + formatClass + "" is not a IChemFormat"");
                        }
                    } catch (ClassNotFoundException e) {
                        logger.warn(""Class "" + formatClass + "" not found"");
                    } catch (InstantiationException e) {
                        logger.warn(""Could not instantiate class "" + formatClass);
                    } catch (IllegalAccessException e) {
                        logger.warn(""Could not access class "" + formatClass);
                    }
                    line = reader.readLine();
                }
            } catch (Exception e) {
                logger.warn(""Could not read "" + IO_FORMATS_LIST + "": "" + e.getMessage());
            }
        }
        List<IChemFormat> result = new ArrayList<IChemFormat>();
        for (IChemFormat format : formats)      
 }"," public IChemFormat[] findChemFormats(int features){
        if (formats == null) {
            formats = new ArrayList<IChemFormat>();
            try {
                Class<?> clazz = Class.forName(IO_FORMATS_LIST);
                Method method = clazz.getMethod(""getFormats"");
                formats = (List<IChemFormat>) method.invoke(null);
            } catch (ClassNotFoundException e) {
                logger.error(""Could not find class: "" + IO_FORMATS_LIST);
            } catch (SecurityException e) {
                logger.error(""Could not access class: "" + IO_FORMATS_LIST);
            } catch (NoSuchMethodException e) {
                logger.error(""Could not find method: "" + IO_FORMATS_LIST);
            } catch (IllegalArgumentException e) {
                logger.error(""Could not invoke method: "" + IO_FORMATS_LIST);
            } catch (IllegalAccessException e) {
                logger.error(""Could not invoke method: "" + IO_FORMATS_LIST);
            } catch (InvocationTargetException e) {
                logger.error(""Could not invoke method: "" + IO_FORMATS_LIST);
            }
        }
        List<IChemFormat> result = new ArrayList<IChemFormat>();
        for (IChemFormat format : formats) {
            if (format.getSupportedType() == features) {
                result.add(format);
            }
        }
        return result.toArray(new IChemFormat[result.size()]);      
 }",NOT PASS,NOT PASS,NOT PASS,Syntax Error,  0.46265478630445345,  0.5054618345132432,  0.4503133805703746,None,54.0,0.48214285714285715,50.0,0.44642857142857145,151.0,0.6711111111111111,279.0,0.7994269340974212,8.0,0.10526315789473684,163.0,0.7244444444444444,298.0,0.8538681948424068,10.0,0.7692307692307693,5.0,0.38461538461538464,7.0,0.5384615384615384
410,cdk,"private void layoutRingSystem(Point3d originalCoord, IAtom placedRingAtom, IRingSet ringSet, Point3d centerPlacedMolecule, IAtom atomB, AtomPlacer3D ap3d){
    IAtomContainer ac = RingSetManipulator.getAllInOneContainer(ringSet);
    Point3d newCoord = placedRingAtom.getPoint3d();
    Vector3d axis = new Vector3d(atomB.getPoint3d().x - newCoord.x, atomB.getPoint3d().y - newCoord.y, atomB.getPoint3d().z - newCoord.z);
    translateStructure(originalCoord, newCoord, ac);
    Vector3d startAtomVector = new Vector3d(newCoord.x - atomB.getPoint3d().x, newCoord.y - atomB.getPoint3d().y, newCoord.z - atomB.getPoint3d().z);
    IAtom farthestAtom = ap3d.getFarthestAtom(placedRingAtom.getPoint3d(), ac);
    Vector3d farthestAtomVector = new Vector3d(farthestAtom.getPoint3d().x - newCoord.x, farthestAtom.getPoint3d().y - newCoord.y, farthestAtom.getPoint3d().z - newCoord.z);
    Vector3d n1 = new Vector3d();
    n1.cross(axis, farthestAtomVector);
    n1.normalize();
    double lengthFarthestAtomVector = farthestAtomVector.length();
    Vector3d farthestVector = new Vector3d(startAtomVector);
    farthestVector.normalize();
    farthestVector.scale((startAtomVector.length() + lengthFarthestAtomVector));
    double dotProduct = farthestAtomVector.dot(farthestVector);
    double angle = Math.acos(dotProduct / (farthestAtomVector.length() * farthestVector.length()));
    Vector3d ringCenter = new Vector3d();
    for (int i = 0; i < ac.getAtomCount(); i++) {
        if (!(ac.getAtom(i).getFlag(CDKConstants.ISPLACED))) {
            ringCenter.x = (ac.getAtom(i).getPoint3d()).x - newCoord.x;
            ringCenter.y = (ac.getAtom(i).getPoint3d()).y - newCoord.y;
            ringCenter.z = (ac.getAtom(i).getPoint3d()).z - newCoord.z;
            ringCenter = AtomTetrahedralLigandPlacer3D.rotate(ringCenter, n1, angle);
            ac.getAtom(i).setPoint3d(new Point3d(ringCenter.x + newCoord.x, ringCenter.y + newCoord.y, ringCenter.z + newCoord.z));
        }
    }
    Point3d pointRingCenter = GeometryUtil.get3DCenter(ac);
    double distance = 0;
    double rotAngleMax = 0;
    angle = 1 / 180 * Math.PI;
    ringCenter = new Vector3d(pointRingCenter.x, pointRingCenter.y, pointRingCenter.z);
    ringCenter.x = ringCenter.x - newCoord.x;
    ringCenter.y = ringCenter.y - newCoord.y;
    ringCenter.z = ringCenter.z - newCoord.z;
    for (int i = 1; i < 360; i++) {
        ringCenter = AtomTetrahedralLigandPlacer3D.rotate(ringCenter, axis, angle);
        if (centerPlacedMolecule.distance(new Point3d(ringCenter.x, ringCenter.y, ringCenter.z)) > distance) {
            rotAngleMax = i;
            distance = centerPlacedMolecule.distance(new Point3d(ringCenter.x, ringCenter.y, ringCenter.z));
        }
    }
    rotAngleMax = (rotAngleMax / 180) * Math.PI;
    for (int i = 0; i < ac.getAtomCount(); i++) {
        if (!(ac.getAtom(i).getFlag(CDKConstants.ISPLACED))) {
            ringCenter.x = (ac.getAtom(i).getPoint3d()).x;
            ringCenter.y = (ac.getAtom(i).getPoint3d()).y;
            ringCenter.z = (ac.getAtom(i).getPoint3d()).z;
            ringCenter = AtomTetrahedralLigandPlacer3D.rotate(ringCenter, axis, rotAngleMax);
            ac.getAtom(i).setPoint3d(new Point3d(ringCenter.x, ringCenter.y, ringCenter.z));
            ac.getAtom(i).setFlag(CDKConstants.ISPLACED, true);
        }
    }
}",layoutRingSystem,org/openscience/cdk/modeling/builder3d/ModelBuilder3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/ModelBuilder3D.java,"/**
     * Layout the ring system, rotate and translate the template.
     *
     *@param  originalCoord         coordinates of the placedRingAtom from the template
     *@param  placedRingAtom        placedRingAtom
     *@param  ringSet               ring system which placedRingAtom is part of
     *@param  centerPlacedMolecule  the geometric center of the already placed molecule
     *@param  atomB                 placed neighbour atom of  placedRingAtom
     */",314-390,"('layoutRingSystem', {'INSTRUCTION': {'covered': 344, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 50, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",794.0,11.0,"Layout the ring system, rotate and translate the template.","Defines the ring system, rotating and translating the template.","The ring system can be layout, rotate and translated.",0.423684153604406,"Lay out the ring system, rotate and translate the model.","private void layoutRingSystem(Point3d originalCoord, IAtom placedRingAtom, IRingSet ringSet, Point3d centerPlacedMolecule, IAtom atomB, AtomPlacer3D ap3d){
        //logger.debug(""****** LAYOUT RING SYSTEM *******"");
        IRingSet ringSetA = ringSet;
        IAtomContainer ringSetAContainer = RingSetManipulator.getAllInOneContainer(ringSetA);
        templateHandler.mapTemplates(ringSetAContainer, ringSetAContainer.getAtomCount());
        if (!checkAllRingAtomsHasCoordinates(ringSetAContainer)) {
            throw new CDKException(""RingAtomLayoutError: Not every ring atom is placed! Molecule cannot be layout."");
        }
        Point3d firstAtomOriginalCoord = originalCoord;
        Point3d centerPlacedMolecule = centerPlacedMolecule;
        IAtom atomB = atomB;
        AtomPlacer3D ap3d = ap3d;
        IAtomContainer ringSetContainer = ringSetAContainer;
        IAtomContainer ringSetContainerClone = (IAtomContainer) ringSetContainer.clone();
        IAtom atomA = null;
        IAtom atomC = null;
        IAtom atomD = null;
        IAtom atomE = null;
        IAtom atomF = null;
        IAtom atomG = null;
        IAtom atomH = null;
        IAtom atomI = null;
        IAtom atomJ = null;
        IAtom atomK = null;
        IAtom atomL = null;
        IAtom atomM = null;
        IAtom atomN = null;
        IAtom atomO = null;
        IAtom atomP = null;
        IAtom atomQ = null;
        IAtom atomR = null;
        IAtom atomS = null;
        IAtom atomT = null;
        IAtom atomU = null;
        IAtom atomV = null;
        IAtom atomW = null;
        IAtom atomX = null;
        IAtom atomY = null;
        IAtom atomZ = null;
        IAtom atomAA = null;        
 }","private void layoutRingSystem(Point3d originalCoord, IAtom placedRingAtom, IRingSet ringSet, Point3d centerPlacedMolecule, IAtom atomB, AtomPlacer3D ap3d){
        IRingSet ringSetA = ringSet;
        IAtom atomA = placedRingAtom;
        IAtom atomC = atomB;
        IAtom atomD = null;
        IAtom atomE = null;
        IAtom atomF = null;
        IAtom atomG = null;
        IAtom atomH = null;
        IAtom atomI = null;
        IAtom atomJ = null;
        IAtom atomK = null;
        IAtom atomL = null;
        IAtom atomM = null;
        IAtom atomN = null;
        IAtom atomO = null;
        IAtom atomP = null;
        IAtom atomQ = null;
        IAtom atomR = null;
        IAtom atomS = null;
        IAtom atomT = null;
        IAtom atomU = null;
        IAtom atomV = null;
        IAtom atomW = null;
        IAtom atomX = null;
        IAtom atomY = null;
        IAtom atomZ = null;
        IAtom atomAA = null;
        IAtom atomBB = null;
        IAtom atomCC = null;
        IAtom atomDD = null;
        IAtom atomEE = null;
        IAtom atomFF = null;
        IAtom atomGG = null;
        IAtom atomHH = null;
        IAtom atomII = null;
        IAtom atomJJ = null;
        IAtom atomKK = null;
        IAtom atomLL = null;
        IAtom atomMM = null;
        IAtom atomNN = null;
        IAtom atomOO = null;
        IAtom atomPP = null;
        IAtom atomQQ = null;
        IAtom atomRR = null;
        IAtom atomSS = null;
        IAtom atomTT = null;
        IAtom atomUU = null;
        IAtom atomVV = null;
        IAtom atomWW = null;        
 }","private void layoutRingSystem(Point3d originalCoord, IAtom placedRingAtom, IRingSet ringSet, Point3d centerPlacedMolecule, IAtom atomB, AtomPlacer3D ap3d){
        //logger.debug(""layoutRingSystem"");
        Point3d centerRingSystem = ap3d.geometricCenterAllPlacedAtoms(ringSet);
        Point3d centerRingSystemOriginalCoord = new Point3d(centerRingSystem);
        centerRingSystem.sub(centerPlacedMolecule);
        Point3d centerRingSystemPlacedCoord = new Point3d(centerRingSystem);
        centerRingSystem.sub(originalCoord);
        Point3d centerRingSystemPlacedCoordRotated = new Point3d(centerRingSystem);
        Point3d centerRingSystemPlacedCoordRotatedTranslated = new Point3d(centerRingSystem);
        Point3d centerRingSystemPlacedCoordRotatedTranslatedOriginalCoord = new Point3d(centerRingSystem);
        Point3d centerRingSystemPlacedCoordRotatedTranslatedPlacedCoord = new Point3d(centerRingSystem);
        Point3d centerRingSystemPlacedCoordRotatedTranslatedPlacedCoordOriginalCoord = new Point3d(centerRingSystem);
        Point3d centerRingSystemPlacedCoordRotatedTranslatedPlacedCoordPlacedCoord = new Point3d(centerRingSystem);
        Point3d centerRingSystemPlacedCoordRotatedTranslatedPlacedCoordPlacedCoordOriginalCoord = new Point3d(centerRingSystem);
        Point3d centerRingSystemPlacedCoordRotatedTranslatedPlacedCoordPlacedCoordPlacedCoord = new Point3d(centerRingSystem);
        Point3d centerRingSystemPlacedCoordRotatedTranslatedPlacedCoordPlacedCoordPlacedCoordOriginalCoord = new Point3d(centerRingSystem);
        Point3d centerRingSystemPlacedCoordRotatedTranslatedPlacedCoordPlacedCoordPlacedCoordPlacedCoord = new Point3d(centerRingSystem);
        Point3d centerRingSystemPlacedCoordRotatedTranslatedPlacedCoordPlacedCoordPlacedCoordPlacedCoordOriginalCoord = new Point3d(centerRingSystem);
        Point3d centerRingSystemPlacedCoordRotated      
 }","private void layoutRingSystem(Point3d originalCoord, IAtom placedRingAtom, IRingSet ringSet, Point3d centerPlacedMolecule, IAtom atomB, AtomPlacer3D ap3d){
        //logger.debug(""****** LAYOUT RING SYSTEM *******"");
        Point3d centerRingSystem = ap3d.geometricCenterAllPlacedAtoms(ringSet);
        Point3d centerRingSystemPlaced = ap3d.geometricCenterAllPlacedAtoms(ringSet);
        Point3d centerRingSystemOriginal = ap3d.geometricCenterAllPlacedAtoms(ringSet);
        Point3d centerPlacedMoleculePlaced = ap3d.geometricCenterAllPlacedAtoms(ringSet);
        Point3d centerPlacedMoleculeOriginal = ap3d.geometricCenterAllPlacedAtoms(ringSet);
        Point3d centerPlacedMolecule = ap3d.geometricCenterAllPlacedAtoms(ringSet);
        Point3d centerPlacedMoleculeOriginal = ap3d.geometricCenterAllPlacedAtoms(ringSet);
        Point3d centerPlacedMoleculePlaced = ap3d.geometricCenterAllPlacedAtoms(ringSet);
        Point3d centerPlacedMoleculeOriginal = ap3d.geometricCenterAllPlacedAtoms(ringSet);
        Point3d centerPlacedMolecule = ap3d.geometricCenterAllPlacedAtoms(ringSet);
        Point3d centerPlacedMoleculeOriginal = ap3d.geometricCenterAllPlacedAtoms(ringSet);
        Point3d centerPlacedMoleculePlaced = ap3d.geometricCenterAllPlacedAtoms(ringSet);
        Point3d centerPlacedMoleculeOriginal = ap3d.geometricCenterAllPlacedAtoms(ringSet);
        Point3d centerPlacedMolecule = ap3d.geometricCenterAllPlacedAtoms(ringSet);
        Point3d centerPlacedMoleculeOriginal = ap3d.geometricCenterAllPlacedAtoms(ringSet);
        Point3d centerPlacedMoleculePlaced = ap3d.geometricCenterAllPlacedAtoms(ringSet);
        Point3d centerPlacedMoleculeOriginal = ap3d.geometricCenterAllPlacedAtoms       
 }",NOT PASS,NOT PASS,Syntax Error,Syntax Error,  0.10409213093729286,  0.028175203292998465,None,None,685.0,0.8616352201257862,691.0,0.869182389937107,682.0,0.8578616352201258,689.0,0.8666666666666667,119.0,0.44074074074074077,169.0,0.7130801687763713,172.0,0.7257383966244726,3.0,0.3,3.0,0.2727272727272727,9.0,0.9
411,cdk,"private int[] neighbors(ITetrahedralChirality element, Map<IAtom, Integer> map){
    IAtom[] atoms = element.getLigands();
    int[] vs = new int[atoms.length];
    for (int i = 0; i < atoms.length; i++) vs[i] = map.get(atoms[i]);
    return vs;
}",neighbors,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,"/**
     * Access the neighbors of {@code element} as their indices.
     *
     * @param element tetrahedral element
     * @param map     atom index lookup
     * @return the neighbors
     */",282-295,"('neighbors', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,13.0,Access the neighbors of {@code element} as their indices.,"Given a tetrahedral element and an atom index, it accesses to the next element.",The neighbors of @code element are their indices.,0.831832873292271,Navigate to the neighbors of {@code element} as clues.,"private int[] neighbors(ITetrahedralChirality element, Map<IAtom, Integer> map){
        IAtom[] ligands = element.getLigands();
        int[] neighbors = new int[ligands.length];
        for (int i = 0; i < ligands.length; i++)
            neighbors[i] = map.get(ligands[i]);
        return neighbors;
    }","private int[] neighbors(ITetrahedralChirality element, Map<IAtom, Integer> map){
        int[] neighbors = new int[element.getLigands().length];
        for (int i = 0; i < neighbors.length; i++)
            neighbors[i] = map.get(element.getLigands()[i]);
        return neighbors;
    }","private int[] neighbors(ITetrahedralChirality element, Map<IAtom, Integer> map){
        List<IAtom> ligands = element.getLigands();
        int[] neighbors = new int[ligands.size()];
        for (int i = 0; i < ligands.size(); i++)
            neighbors[i] = map.get(ligands.get(i));
        return neighbors;
    }","private int[] neighbors(ITetrahedralChirality element, Map<IAtom, Integer> map){
        List<IAtom> ligands = element.getLigands();
        int[] neighbors = new int[ligands.size()];
        for (int i = 0; i < ligands.size(); i++)
            neighbors[i] = map.get(ligands.get(i));
        return neighbors;       
 }",PASS,PASS,NOT PASS,NOT PASS,  0.8829478640925031,  0.602698306237108,  0.7152917662894049,  0.6795774805751191,7.0,0.08974358974358974,23.0,0.2948717948717949,21.0,0.24705882352941178,21.0,0.24705882352941178,21.0,0.2692307692307692,14.0,0.16470588235294117,14.0,0.16470588235294117,14.0,0.9333333333333333,4.0,0.4,5.0,0.5
412,acs-aem-commons,"private void addReplicationStatusMixin(final Node node) throws RepositoryException{
    if (!this.hasMixin(node, ReplicationStatus.NODE_TYPE) && node.canAddMixin(ReplicationStatus.NODE_TYPE)) {
        node.addMixin(ReplicationStatus.NODE_TYPE);
    }
}",addReplicationStatusMixin,com/adobe/acs/commons/replication/status/impl/ReplicationStatusManagerImpl.java,/bundle/src/main/java/com/adobe/acs/commons/replication/status/impl/ReplicationStatusManagerImpl.java,"/**
     * Adds the cq:ReplicationStatus mixin if the node doesnt already have it or does have it as its jcr:supertype
     * already.
     *
     * @param node the node obj
     * @throws RepositoryException
     */",193-205,"('addReplicationStatusMixin', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,24.0,Adds the cq:ReplicationStatus mixin if the node doesnt already have it or does have it as its jcr:supertype  already.,"If the node does not have the cq:ReplicationStatus mixin (or it has it like jcr:superType), it is added it to the node.","If the jcr:supertype is already in the node, then the cq:ReplicationStatus mixin is added.",0.578271779822469,Adds the cq:ReplicationStatus mixin if the node does not already have it or already has it as jcr:supertype.," private void addReplicationStatusMixin(final Node node) throws RepositoryException{
        if (!node.isNodeType(ReplicationStatus.NODE_TYPE)) {
            node.addMixin(ReplicationStatus.NODE_TYPE);
        }       
 }"," private void addReplicationStatusMixin(final Node node) throws RepositoryException{
        if (!node.isNodeType(ReplicationStatus.NODE_TYPE)) {
            node.addMixin(ReplicationStatus.NODE_TYPE);
        }       
 }"," private void addReplicationStatusMixin(final Node node) throws RepositoryException{
        if (!node.isNodeType(ReplicationStatus.NODE_TYPE)) {
            node.addMixin(ReplicationStatus.NODE_TYPE);
        }       
 }"," private void addReplicationStatusMixin(final Node node) throws RepositoryException{
        if (!node.isNodeType(ReplicationStatus.NODE_TYPE)) {
            if (node.isNodeType(JcrConstants.NT_UNSTRUCTURED)) {
                node.addMixin(ReplicationStatus.NODE_TYPE);
            } else {
                node.addMixin(JcrConstants.NT_UNSTRUCTURED);
                node.addMixin(ReplicationStatus.NODE_TYPE);
            }
        }       
 }",PASS,PASS,PASS,PASS,  0.6711747632180285,  0.6711747632180285,  0.696779631767567,  0.6711747632180285,12.0,0.2553191489361702,12.0,0.2553191489361702,31.0,0.44285714285714284,12.0,0.2553191489361702,0.0,0.0,34.0,0.4857142857142857,0.0,0.0,19.0,0.8260869565217391,7.0,0.35,17.0,0.85
413,cdk,"public Iterable<IIsotope> isotopes(){
    return new Iterable<IIsotope>() {

        @Override
        public Iterator<IIsotope> iterator() {
            return isotopesList().iterator();
        }
    };
}",isotopes,org/openscience/cdk/silent/AdductFormula.java,/base/silent/src/main/java/org/openscience/cdk/silent/AdductFormula.java,"/**
     *  Returns an Iterator for looping over all isotopes in this adduct formula.
     *
     * @return    An Iterator with the isotopes in this adduct formula
     */",173-187,"('isotopes', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",42.0,13.0,Returns an Iterator for looping over all isotopes in this adduct formula.,Provides an iterator that can be used for looping over all isotopes in the formula.,This adduct formula returns an Iterator for looping over all the isotopes.,0.949278367083401,Returns an iterator for the loop over all isotopes of this adduct formula.," public Iterable<IIsotope> isotopes(){
        List<IIsotope> isotopes = new ArrayList<IIsotope>();
        for (IMolecularFormula mf : components) {
            isotopes.addAll(mf.isotopes());
        }
        return isotopes;
    }"," public Iterable<IIsotope> isotopes(){
        return isotopesList();
    }"," public Iterable<IIsotope> isotopes(){
        List<IIsotope> isotopes = new ArrayList<IIsotope>();
        for (IMolecularFormula mf : components) {
            isotopes.addAll(mf.isotopes());
        }
        return isotopes;        
 }"," public Iterable<IIsotope> isotopes(){
        List<IIsotope> isotopes = new ArrayList<IIsotope>();
        for (IMolecularFormula mf : components) {
            isotopes.addAll(mf.isotopes());
        }
        return isotopes;        
 }",NOT PASS,PASS,NOT PASS,NOT PASS,  0.4460038480798676,  0.2706495868720662,  0.4460038480798676,  0.4460038480798676,25.0,0.5208333333333334,27.0,0.627906976744186,25.0,0.5208333333333334,25.0,0.5208333333333334,34.0,0.7083333333333334,0.0,0.0,0.0,0.0,8.0,0.5,4.0,0.2857142857142857,9.0,0.6923076923076923
414,openapi-generator,"public static ValidationRule error(String failureMessage, Function<T, Result> fn){
    return new ValidationRule(Severity.ERROR, null, failureMessage, (Function<Object, Result>) fn);
}",error,org/openapitools/codegen/validation/ValidationRule.java,/modules/openapi-generator-core/src/main/java/org/openapitools/codegen/validation/ValidationRule.java,"/**
     * Create an instance of a {@link ValidationRule} which should result in an error should the evaluate of this rule fail.
     *
     * @param failureMessage The message to be displayed in the event of a test failure (intended to be user-facing).
     * @param fn The test condition to be applied as a part of this rule, when this function returns <code>true</code>,
     *             the evaluated instance will be considered ""valid"" according to this rule.
     * @param <T> The type of the object being evaluated.
     *
     * @return A new instance of a {@link ValidationRule}
     */",113-126,"('error', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,24.0,Create an instance of a {@link ValidationRule} which should result in an error should the evaluate of this rule fail.,Returns a ValidationRule instance that will return an error if the evaluation of the rule does not pass.,"If the evaluate of this rule fails, you should create an instance of the @link ValidationRule which should result in an error.",1.23922957383479,Create an instance of a {@link ValidationRule} that should cause an error if this rule fails to evaluate.," public static ValidationRule error(String failureMessage, Function<T, Result> fn){
        return create(Severity.ERROR, ""error"", failureMessage, fn);     
 }"," public static ValidationRule error(String failureMessage, Function<T, Result> fn){
        return create(Severity.ERROR, ""error"", failureMessage, fn);     
 }"," public static ValidationRule error(String failureMessage, Function<T, Result> fn){
        return create(Severity.ERROR, ""error"", failureMessage, fn);     
 }"," public static ValidationRule error(String failureMessage, Function<T, Result> fn){
        return create(Severity.ERROR, ""error"", failureMessage, fn);     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7121552559247681,  0.7121552559247681,  0.7121552559247681,  0.7121552559247681,11.0,0.2619047619047619,11.0,0.2619047619047619,11.0,0.2619047619047619,11.0,0.2619047619047619,0.0,0.0,0.0,0.0,0.0,0.0,16.0,0.7619047619047619,10.0,0.47619047619047616,19.0,0.8260869565217391
415,dataverse,"public String linkFor(String idpId, String redirectPage){
    AbstractOAuth2AuthenticationProvider idp = authenticationSvc.getOAuth2Provider(idpId);
    String state = createState(idp, toOption(redirectPage));
    return idp.buildAuthzUrl(state, systemConfig.getOAuth2CallbackUrl());
}",linkFor,edu/harvard/iq/dataverse/authorization/providers/oauth2/OAuth2LoginBackingBean.java,/src/main/java/edu/harvard/iq/dataverse/authorization/providers/oauth2/OAuth2LoginBackingBean.java,"/**
     * Generate the OAuth2 Provider URL to be used in the login page link for the provider.
     * @param idpId Unique ID for the provider (used to lookup in authn service bean)
     * @param redirectPage page part of URL where we should be redirected after login (e.g. ""dataverse.xhtml"")
     * @return A generated link for the OAuth2 provider login
     */",72-82,"('linkFor', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",49.0,17.0,Generate the OAuth2 Provider URL to be used in the login page link for the provider.,Create a OAuth2 Provider URL that can be used for the login for the provider.,The provider's login page link will be used if the OAuth2 Provider URL is generated.,0.434015868705152,Generate the URL of the OAuth2 provider to use in the link on the provider's login page.," public String linkFor(String idpId, String redirectPage){
        return systemConfig.getAuthenticationProvider(idpId).getLoginUrl(redirectPage);
    }"," public String linkFor(String idpId, String redirectPage){
        return systemConfig.getAuthenticationProvider(idpId).getLoginUrl(redirectPage);
    }","public String linkFor(String idpId, String redirectPage){
        return systemConfig.getOAuth2ProviderUrl(idpId) + ""?redirect_uri="" + redirectPage;
    }"," public String linkFor(String idpId, String redirectPage){
        return systemConfig.getAuthenticationProvider(idpId).getLoginUrl(redirectPage);     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.31387818580830906,  0.31387818580830906,  0.31387818580830906,  0.2965738480998574,29.0,0.58,29.0,0.58,29.0,0.58,31.0,0.62,0.0,0.0,0.0,0.0,5.0,0.19230769230769232,7.0,0.4117647058823529,13.0,0.7222222222222222,13.0,0.7647058823529411
417,tablesaw,"public Table[] stratifiedSampleSplit(CategoricalColumn<?> column, double table1Proportion){
    Preconditions.checkArgument(containsColumn(column), ""The categorical column must be part of the table, you can create a string column and add it to this table before sampling."");
    final Table first = emptyCopy();
    final Table second = emptyCopy();
    splitOn(column).asTableList().forEach(tab -> {
        Table[] splits = tab.sampleSplit(table1Proportion);
        first.append(splits[0]);
        second.append(splits[1]);
    });
    return new Table[] { first, second };
}",stratifiedSampleSplit,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,"/**
   * Splits the table into two stratified samples, this uses the specified column to divide the
   * table into groups, randomly assigning records to each according to the proportion given in
   * trainingProportion.
   *
   * @param column the column to be used for the stratified sampling
   * @param table1Proportion The proportion to go in the first table
   * @return An array two tables, with the first table having the proportion specified in the method
   *     parameter, and the second table having the balance of the rows
   */",524-551,"('stratifiedSampleSplit', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,33.0,"Splits the table into two stratified samples, this uses the specified column to divide the  table into groups, randomly assigning records to each according to the proportion given in  trainingProportion.","Using the specified column, it divides the table into two groups. Each record is assigned randomly to each group in order to maintain the proportion trainingProposrtion.","The table is split into two samples, with the specified column used to divide it into groups.",0.645193085298975,"Divides the table into two stratified samples, this uses the specified column to divide the table into groups, randomly assigning records to each based on the proportion given in trainingProportion.","public Table[] stratifiedSampleSplit(CategoricalColumn<?> column, double table1Proportion){
    Table[] tables = new Table[2];
    int table1Count = (int) Math.round(rowCount() * table1Proportion);
  
    Selection table2Selection = new BitmapBackedSelection();
    for (int i = 0; i < rowCount(); i++) {
      table2Selection.add(i);
    }
    Selection table1Selection = new BitmapBackedSelection();
  
    Selection table1Records = selectNRowsAtRandom(table1Count, rowCount());
    for (int table1Record : table1Records) {
      table1Selection.add(table1Record);
    }
    table2Selection.andNot(table1Selection);
    tables[0] = where(table1Selection);
    tables[1] = where(table2Selection);
    return tables;
  }","public Table[] stratifiedSampleSplit(CategoricalColumn<?> column, double table1Proportion){
    Table[] tables = new Table[2];
    int table1Count = (int) Math.round(rowCount() * table1Proportion);
  
    Selection table2Selection = new BitmapBackedSelection();
    for (int i = 0; i < rowCount(); i++) {
      table2Selection.add(i);
    }
    Selection table1Selection = new BitmapBackedSelection();
  
    Selection table1Records = selectNRowsAtRandom(table1Count, rowCount());
    for (int table1Record : table1Records) {
      table1Selection.add(table1Record);
    }
    table2Selection.andNot(table1Selection);
    tables[0] = where(table1Selection);
    tables[1] = where(table2Selection);
    return tables;
  }","public Table[] stratifiedSampleSplit(CategoricalColumn<?> column, double table1Proportion){
    Table[] tables = new Table[2];
    int table1Count = (int) Math.round(rowCount() * table1Proportion);
  
    Selection table2Selection = new BitmapBackedSelection();
    for (int i = 0; i < rowCount(); i++) {
      table2Selection.add(i);
    }
    Selection table1Selection = new BitmapBackedSelection();
  
    Selection table1Records = selectNRowsAtRandom(table1Count, rowCount());
    for (int table1Record : table1Records) {
      table1Selection.add(table1Record);
    }
    table2Selection.andNot(table1Selection);
    tables[0] = where(table1Selection);
    tables[1] = where(table2Selection);
    return tables;
  }","public Table[] stratifiedSampleSplit(CategoricalColumn<?> column, double table1Proportion){
    Table[] tables = new Table[2];
    int table1Count = (int) Math.round(rowCount() * table1Proportion);
  
    Selection table2Selection = new BitmapBackedSelection();
    for (int i = 0; i < rowCount(); i++) {
      table2Selection.add(i);
    }
    Selection table1Selection = new BitmapBackedSelection();
  
    Selection table1Records = selectNRowsAtRandom(table1Count, rowCount());
    for (int table1Record : table1Records) {
      table1Selection.add(table1Record);
    }
    table2Selection.andNot(table1Selection);
    tables[0] = where(table1Selection);
    tables[1] = where(table2Selection);
    return tables;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.37140685890453284,  0.37140685890453284,  0.359502096999771,  0.3833116208092948,99.0,0.6827586206896552,99.0,0.6827586206896552,99.0,0.6827586206896552,99.0,0.6827586206896552,0.0,0.0,0.0,0.0,0.0,0.0,25.0,0.8064516129032258,3.0,0.0967741935483871,23.0,0.7419354838709677
418,cdk,"static boolean accept(IAtom atom, List<IBond> bonds){
    int dbCount = 0;
    if (!IAtomType.Hybridization.SP2.equals(atom.getHybridization()))
        return false;
    if (bonds.size() == 1)
        return false;
    for (IBond bond : bonds) {
        if (DOUBLE.equals(bond.getOrder()))
            dbCount++;
        IBond.Stereo stereo = bond.getStereo();
        if (IBond.Stereo.UP_OR_DOWN.equals(stereo) || IBond.Stereo.UP_OR_DOWN_INVERTED.equals(stereo))
            return false;
    }
    return dbCount == 1;
}",accept,org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,"/**
     * Test whether we accept atom and it's connected bonds for inclusion in a
     * double bond configuration. This method checks for query bonds (up/down)
     * as well as double bond counts. If there is more then one double bond in
     * the connect bonds then it cannot have Z/E configuration.
     *
     * @param atom  a double bonded atom
     * @param bonds all bonds connected to the atom
     * @return whether the atom is accepted for configuration
     */",235-269,"('accept', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",122.0,18.0,Test whether we accept atom and it's connected bonds for inclusion in a  double bond configuration.,"The function returns true if we accept the atoms with the connected bonds in a double bound configuration. Considering query bonds (up/down) and bond counts, if there exists more than one double bound, it can not have Z/E configuration.","If we accept atom, we need to test whether it's connected bonds for inclusion.",0.693343119765149,Test whether we accept the atom and its connected bonds for inclusion in a dual-link configuration.,"static boolean accept(IAtom atom, List<IBond> bonds){
        if (bonds.size() == 1) {
            IBond bond = bonds.get(0);
            if (bond.getOrder() == IBond.Order.DOUBLE) {
                return true;
            }
        }
        return false;
    }","static boolean accept(IAtom atom, List<IBond> bonds){
        int up = 0;
        int down = 0;
        for (IBond bond : bonds) {
            if (bond.getOrder() == IBond.Order.DOUBLE) {
                if (bond.getBegin().equals(atom)) {
                    up++;
                } else {
                    down++;
                }
            }
        }
        return up == 1 && down == 1;
    }","static boolean accept(IAtom atom, List<IBond> bonds){
        if (bonds.size() == 0) return false;
        for (IBond bond : bonds) {
            if (bond.getFlag(CDKConstants.ISINRING)) return true;
        }
        return false;
    }","static boolean accept(IAtom atom, List<IBond> bonds){
        if (atom.getFlag(CDKConstants.ISINRING)) return false;
        if (bonds.size() != 2) return false;
        if (bonds.get(0).getFlag(CDKConstants.ISAROMATIC)) return false;
        if (bonds.get(1).getFlag(CDKConstants.ISAROMATIC)) return false;
        return true;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2875242808213406,  0.43871654594169907,  0.3504606474865476,  0.2848963047812627,77.0,0.6260162601626016,74.0,0.6016260162601627,64.0,0.5203252032520326,74.0,0.6016260162601627,48.0,0.5714285714285714,44.0,0.5238095238095238,20.0,0.3333333333333333,32.0,0.8,4.0,0.23529411764705882,14.0,0.8235294117647058
419,liquibase,"public Precondition create(String tagName){
    Class<?> aClass = preconditions.get(tagName);
    if (aClass == null) {
        return null;
    }
    try {
        return (Precondition) aClass.getConstructor().newInstance();
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}",create,liquibase/precondition/PreconditionFactory.java,/liquibase-core/src/main/java/liquibase/precondition/PreconditionFactory.java,"/**
     * Create a new Precondition subclass based on the given tag name.
     */",55-68,"('create', {'INSTRUCTION': {'covered': 19, 'missed': 6}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",64.0,12.0,Create a new Precondition subclass based on the given tag name.,"Starting from the given tag name, create a new Precondition subclass.",The given tag name will be used to create a new Precondition subclass.,0.4946996704009,Create a Precondition subclass based on the given tag name.," public Precondition create(String tagName){
        try {
            Class<? extends Precondition> preconditionClass = preconditions.get(tagName);
            if (preconditionClass == null) {
                throw new UnexpectedLiquibaseException(""Unknown precondition: "" + tagName);
            }
            return preconditionClass.newInstance();
        } catch (Exception e) {
            throw new UnexpectedLiquibaseException(e);
        }
    }       "," public Precondition create(String tagName){
        try {
            Class<? extends Precondition> preconditionClass = preconditions.get(tagName);
            if (preconditionClass == null) {
                throw new UnexpectedLiquibaseException(""No precondition found for tag "" + tagName);
            }
            return preconditionClass.newInstance();
        } catch (Exception e) {
            throw new UnexpectedLiquibaseException(e);
        }
    }       "," public Precondition create(String tagName){
        try {
            Class<? extends Precondition> preconditionClass = preconditions.get(tagName);
            if (preconditionClass == null) {
                throw new UnexpectedLiquibaseException(""Unknown precondition: "" + tagName);
            }
            return preconditionClass.newInstance();
        } catch (Exception e) {
            throw new UnexpectedLiquibaseException(e);
        }
    }       "," public Precondition create(String tagName){
        try {
            Class<? extends Precondition> preconditionClass = preconditions.get(tagName);
            if (preconditionClass == null) {
                throw new UnexpectedLiquibaseException(""Unknown precondition: "" + tagName);
            }
            return ServiceLocator.getInstance().newInstance(preconditionClass);
        } catch (Exception e) {
            throw new UnexpectedLiquibaseException(e);
        }
    }       ",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7001562279246134,  0.693745888058607,  0.6920747984621408,  0.7001562279246134,21.0,0.3181818181818182,21.0,0.3181818181818182,21.0,0.29577464788732394,21.0,0.3181818181818182,1.0,0.015151515151515152,6.0,0.08450704225352113,0.0,0.0,11.0,0.9166666666666666,1.0,0.08333333333333333,13.0,0.9285714285714286
420,cdk,"private void init(){
    for (IAtom atom : atoms) {
        if (atom.getPoint3d() == null)
            throw new IllegalArgumentException(""One or more atoms had no 3D coordinate set"");
    }
    Point3d cp = new Point3d(0, 0, 0);
    double maxRadius = 0;
    for (IAtom atom : atoms) {
        double vdwr = PeriodicTable.getVdwRadius(atom.getSymbol());
        if (vdwr + solventRadius > maxRadius)
            maxRadius = PeriodicTable.getVdwRadius(atom.getSymbol()) + solventRadius;
        cp.x = cp.x + atom.getPoint3d().x;
        cp.y = cp.y + atom.getPoint3d().y;
        cp.z = cp.z + atom.getPoint3d().z;
    }
    cp.x = cp.x / atoms.length;
    cp.y = cp.y / atoms.length;
    cp.z = cp.z / atoms.length;
    Tessellate tess = new Tessellate(""ico"", tesslevel);
    tess.doTessellate();
    logger.info(""Got tesselation, number of triangles = "" + tess.getNumberOfTriangles());
    NeighborList nbrlist = new NeighborList(atoms, maxRadius + solventRadius);
    logger.info(""Got neighbor list"");
    this.surfPoints = (List<Point3d>[]) new List[atoms.length];
    this.areas = new double[atoms.length];
    this.volumes = new double[atoms.length];
    for (int i = 0; i < atoms.length; i++) {
        int pointDensity = tess.getNumberOfTriangles() * 3;
        Point3d[][] points = atomicSurfacePoints(nbrlist, i, atoms[i], tess);
        translatePoints(i, points, pointDensity, atoms[i], cp);
    }
    logger.info(""Obtained points, areas and volumes"");
}",init,org/openscience/cdk/geometry/surface/NumericalSurface.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/geometry/surface/NumericalSurface.java,"/**
     * Initialize the surface, generating the points on the accessible surface
     * area of each atom as well as calculating the surface area of each atom.
     */",115-170,"('init', {'INSTRUCTION': {'covered': 206, 'missed': 5}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 28, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",348.0,26.0,"Initialize the surface, generating the points on the accessible surface  area of each atom as well as calculating the surface area of each atom.","The function is used for the initialization of the surface, by generating the points on the surface area of each atom and calculating the atom's surface area.",The surface area of each atom can be calculated by generating points on the accessible surface area of each atom.,0.429104577223317,"Initialize the surface, generate the points on the accessible surface of each atom as well as the calculation of the surface of each atom.","private void init(){
        // generate the points on the accessible surface area of each atom
        surfPoints = new List[atoms.length];
        for (int i = 0; i < atoms.length; i++) {
            surfPoints[i] = new ArrayList<Point3d>();
        }
        // generate the surface area of each atom
        areas = new double[atoms.length];
        volumes = new double[atoms.length];
        for (int i = 0; i < atoms.length; i++) {
            generateSurface(atoms[i], surfPoints[i], areas[i], volumes[i]);
        }
    }","private void init(){
        surfPoints = new List[atoms.length];
        areas = new double[atoms.length];
        volumes = new double[atoms.length];
        for (int i = 0; i < atoms.length; i++) {
            surfPoints[i] = new ArrayList<Point3d>();
            areas[i] = 0;
            volumes[i] = 0;
        }
        for (int i = 0; i < atoms.length; i++) {
            generateSurface(atoms[i], tesslevel);
        }
        for (int i = 0; i < atoms.length; i++) {
            volumes[i] = calculateVolume(surfPoints[i]);
            areas[i] = calculateArea(surfPoints[i]);
        }
    }","private void init(){
        // generate the points on the accessible surface area of each atom
        surfPoints = new List[atoms.length];
        for (int i = 0; i < atoms.length; i++) {
            surfPoints[i] = new ArrayList<Point3d>();
            generateSurfacePoints(atoms[i], surfPoints[i]);
        }
    
        // calculate the surface area of each atom
        areas = new double[atoms.length];
        for (int i = 0; i < atoms.length; i++) {
            areas[i] = calculateSurfaceArea(surfPoints[i]);
        }
    
        // calculate the volume of each atom
        volumes = new double[atoms.length];
        for (int i = 0; i < atoms.length; i++) {
            volumes[i] = calculateVolume(surfPoints[i]);
        }       
 }","private void init(){
        // generate the points on the accessible surface of each atom
        surfPoints = new List[atoms.length];
        for (int i = 0; i < atoms.length; i++) {
            surfPoints[i] = new ArrayList<Point3d>();
            generateSurface(atoms[i], surfPoints[i]);
        }
    
        // calculate the surface area of each atom
        areas = new double[atoms.length];
        for (int i = 0; i < atoms.length; i++) {
            areas[i] = calculateSurface(surfPoints[i]);
        }
    
        // calculate the volume of each atom
        volumes = new double[atoms.length];
        for (int i = 0; i < atoms.length; i++) {
            volumes[i] = calculateVolume(surfPoints[i]);
        }       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.1839002351154891,  0.1947973520881357,  0.20691211439470214,  0.20482878106136881,268.0,0.7679083094555874,274.0,0.7851002865329513,269.0,0.7707736389684814,269.0,0.7707736389684814,66.0,0.4258064516129032,53.0,0.3680555555555556,53.0,0.3680555555555556,18.0,0.6428571428571429,6.0,0.24,17.0,0.68
421,dataverse,"public Set<Group> collectAncestors(Collection<Group> groups){
    Set<Group> retVal = new HashSet<>();
    Set<Group> perimeter = new HashSet<>(groups);
    while (!perimeter.isEmpty()) {
        Group next = perimeter.iterator().next();
        retVal.add(next);
        perimeter.remove(next);
        explicitGroupService.findDirectlyContainingGroups(next).forEach(g -> {
            if (!retVal.contains(g)) {
                perimeter.add(g);
            }
        });
    }
    return retVal;
}",collectAncestors,edu/harvard/iq/dataverse/authorization/groups/GroupServiceBean.java,/src/main/java/edu/harvard/iq/dataverse/authorization/groups/GroupServiceBean.java,"/**
     * Returns all the groups that are in, of are ancestors of a group in
     * the passed group collection.
     * 
     * @param groups 
     * @return {@code groups} and their ancestors.
     */",180-206,"('collectAncestors', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",117.0,20.0,"Returns all the groups that are in, of are ancestors of a group in  the passed group collection.","Given a group, return all the ancestors.",The ancestors of a group in the passed group collection are returned.,0.253122373085084,"Returns all groups that are in, or are the ancestors of, a group in the transmitted group collection."," public Set<Group> collectAncestors(Collection<Group> groups){
        Set<Group> out = new HashSet<>();
        groups.forEach( g -> {
            out.add(g);
            if ( g instanceof ExplicitGroup ) {
                collectAncestors((ExplicitGroup) g, out);
            } 
        });
        return out;     
 }"," public Set<Group> collectAncestors(Collection<Group> groups){
        Set<Group> ancestors = new HashSet<>();
        groups.forEach(g -> {
            if (g instanceof ExplicitGroup) {
                ExplicitGroup eg = (ExplicitGroup) g;
                ancestors.addAll(collectAncestors(eg.getContainedExplicitGroups()));
            }
        });
        return ancestors;
    }"," public Set<Group> collectAncestors(Collection<Group> groups){
        Set<Group> out = new HashSet<>();
        groups.forEach( g -> {
            if ( g instanceof ExplicitGroup ) {
                collectAncestorContent((ExplicitGroup) g, out);
            } 
        });
        return out;     
 }"," public Set<Group> collectAncestors(Collection<Group> groups){
        Set<Group> out = new HashSet<>();
        groups.forEach( g -> {
            out.add(g);
            if ( g instanceof ExplicitGroup ) {
                collectAncestorContent((ExplicitGroup) g, out);
            } 
        });
        return out;     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.37368368108450084,  0.3279889432081109,  0.3986836810845008,  0.31010502270251084,67.0,0.5677966101694916,66.0,0.559322033898305,67.0,0.5677966101694916,72.0,0.6101694915254238,24.0,0.3333333333333333,1.0,0.014925373134328358,8.0,0.11940298507462686,17.0,0.8947368421052632,5.0,0.2631578947368421,12.0,0.631578947368421
422,cdk,"public static IsotopePattern sortByIntensity(IsotopePattern isotopeP){
    try {
        IsotopePattern isoSort = (IsotopePattern) isotopeP.clone();
        if (isoSort.getNumberOfIsotopes() == 0)
            return isoSort;
        List<IsotopeContainer> listISO = isoSort.getIsotopes();
        Collections.sort(listISO, new Comparator<IsotopeContainer>() {

            @Override
            public int compare(IsotopeContainer o1, IsotopeContainer o2) {
                return Double.compare(o2.getIntensity(), o1.getIntensity());
            }
        });
        isoSort.setMonoIsotope(listISO.get(0));
        return isoSort;
    } catch (CloneNotSupportedException e) {
        e.printStackTrace();
    }
    return null;
}",sortByIntensity,org/openscience/cdk/formula/IsotopePatternManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/formula/IsotopePatternManipulator.java,"/**
     * Return the isotope pattern sorted by intensity
     * to the highest abundance.
     *
     * @param isotopeP  The IsotopePattern object to sort
     * @return          The IsotopePattern sorted
     */",69-104,"('sortByIntensity', {'INSTRUCTION': {'covered': 23, 'missed': 7}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 4}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",130.0,12.0,Return the isotope pattern sorted by intensity  to the highest abundance.,"Given an isotope, it sorts the isotope pattern by intensity to the highest abundance.",The pattern of the isotope is sorted by intensity.,0.637276347141448,Bring the intensity-sorted isotopic pattern back to the greatest abundance.,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,6.0,0.4,7.0,0.5833333333333334,9.0,0.75
423,activiti,"protected ExecutionEntity processExecutionTree(String rootProcessInstanceId, List<ExecutionEntity> executions){
    ExecutionEntity rootExecution = null;
    // Collect executions
    Map<String, ExecutionEntity> executionMap = new HashMap<String, ExecutionEntity>(executions.size());
    for (ExecutionEntity executionEntity : executions) {
        if (executionEntity.getId().equals(rootProcessInstanceId)) {
            rootExecution = executionEntity;
        }
        executionMap.put(executionEntity.getId(), executionEntity);
    }
    // Set relationships
    for (ExecutionEntity executionEntity : executions) {
        // Root process instance relationship
        if (executionEntity.getRootProcessInstanceId() != null) {
            executionEntity.setRootProcessInstance(executionMap.get(executionEntity.getRootProcessInstanceId()));
        }
        // Process instance relationship
        if (executionEntity.getProcessInstanceId() != null) {
            executionEntity.setProcessInstance(executionMap.get(executionEntity.getProcessInstanceId()));
        }
        // Parent - child relationship
        if (executionEntity.getParentId() != null) {
            ExecutionEntity parentExecutionEntity = executionMap.get(executionEntity.getParentId());
            executionEntity.setParent(parentExecutionEntity);
            parentExecutionEntity.addChildExecution(executionEntity);
        }
        // Super - sub execution relationship
        if (executionEntity.getSuperExecution() != null) {
            ExecutionEntity superExecutionEntity = executionMap.get(executionEntity.getSuperExecutionId());
            executionEntity.setSuperExecution(superExecutionEntity);
            superExecutionEntity.setSubProcessInstance(executionEntity);
        }
    }
    return rootExecution;
}",processExecutionTree,org/activiti/engine/impl/persistence/entity/ExecutionEntityManagerImpl.java,/activiti-core/activiti-engine/src/main/java/org/activiti/engine/impl/persistence/entity/ExecutionEntityManagerImpl.java,"/**
   * Processes a collection of {@link ExecutionEntity} instances, which form on execution tree.
   * All the executions share the same rootProcessInstanceId (which is provided).
   * The return value will be the root {@link ExecutionEntity} instance, with all child {@link ExecutionEntity}
   * instances populated and set using the {@link ExecutionEntity} instances from the provided collections
   */",133-180,"('processExecutionTree', {'INSTRUCTION': {'covered': 95, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 2}, 'LINE': {'covered': 22, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",232.0,17.0,"Processes a collection of {@link ExecutionEntity} instances, which form on execution tree.","The function processes a collection of ExecutionEntity instances, that create an execution tree. It returns the root instance, with all children that share the same rootProcessInstanceId",A collection of instances form on the execution tree.,0.332797644740589,"Processes a collection of {@link ExecutionEntity} instances, which form in the runtime tree."," protected ExecutionEntity processExecutionTree(String rootProcessInstanceId, List<ExecutionEntity> executions){
    ExecutionEntity rootExecution = null;
    for (ExecutionEntity execution : executions) {
      if (execution.getProcessInstanceId().equals(rootProcessInstanceId)) {
        rootExecution = execution;
        break;
      }
    }
    if (rootExecution == null) {
      throw new ActivitiObjectNotFoundException(""No execution found for root process instance id: "" + rootProcessInstanceId, ProcessInstance.class);
    }
    for (ExecutionEntity execution : executions) {
      if (execution.getParentId() != null) {
        for (ExecutionEntity parentExecution : executions) {
          if (execution.getParentId().equals(parentExecution.getId())) {
            parentExecution.addChildExecution(execution);
            break;
          }
        }
      }
    }
    return rootExecution;
  }"," protected ExecutionEntity processExecutionTree(String rootProcessInstanceId, List<ExecutionEntity> executions){
    ExecutionEntity rootExecution = null;
    for (ExecutionEntity execution : executions) {
      if (execution.getRootProcessInstanceId().equals(rootProcessInstanceId)) {
        rootExecution = execution;
        break;
      }
    }
    if (rootExecution == null) {
      throw new ActivitiObjectNotFoundException(""No execution found for root process instance id: "" + rootProcessInstanceId, ExecutionEntity.class);
    }
    for (ExecutionEntity execution : executions) {
      if (execution.getRootProcessInstanceId().equals(rootProcessInstanceId)) {
        rootExecution.addChildExecution(execution);
      }
    }
    return rootExecution;
  }"," protected ExecutionEntity processExecutionTree(String rootProcessInstanceId, List<ExecutionEntity> executions){
    ExecutionEntity rootExecution = null;
    for (ExecutionEntity execution : executions) {
      if (execution.getRootProcessInstanceId().equals(rootProcessInstanceId)) {
        rootExecution = execution;
        break;
      }
    }
    if (rootExecution == null) {
      throw new ActivitiObjectNotFoundException(""No execution found for root process instance id: "" + rootProcessInstanceId, ProcessInstance.class);
    }
    return rootExecution;
  }"," protected ExecutionEntity processExecutionTree(String rootProcessInstanceId, List<ExecutionEntity> executions){
    ExecutionEntity rootExecution = null;
    for (ExecutionEntity execution : executions) {
      if (execution.getRootProcessInstanceId().equals(rootProcessInstanceId)) {
        rootExecution = execution;
        break;
      }
    }
    if (rootExecution == null) {
      throw new ActivitiObjectNotFoundException(""No execution found for root process instance id: "" + rootProcessInstanceId, ProcessInstance.class);
    }
    return processExecutionTree(rootExecution);   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3464757842874088,  0.2663433410617162,  0.1956004324030016,  0.20228780481194683,143.0,0.6137339055793991,156.0,0.6695278969957081,174.0,0.7467811158798283,174.0,0.7467811158798283,32.0,0.24060150375939848,59.0,0.44360902255639095,59.0,0.44360902255639095,21.0,0.7777777777777778,3.0,0.21428571428571427,7.0,0.5384615384615384
424,weblogic-kubernetes-operator," boolean isUseOnlineUpdate(){
    return Optional.ofNullable(configuration).map(Configuration::getModel).map(Model::getOnlineUpdate).map(OnlineUpdate::getEnabled).orElse(false);
}",isUseOnlineUpdate,oracle/kubernetes/weblogic/domain/model/DomainSpec.java,/operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainSpec.java,"/**
   * Test if the MII domain wants to use online update.
   *
   * @return true if using online update
   */",822-833,"('isUseOnlineUpdate', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,11.0,Test if the MII domain wants to use online update.,Returns true if the MII domain is using online updates.,"If the MII domain wants to use online update, you should test it.",0.248730666018798,Test whether the MII domain wants to use the online update.,"  boolean isUseOnlineUpdate(){
    return Optional.ofNullable(useOnlineUpdate).orElse(KubernetesConstants.DEFAULT_USE_ONLINE_UPDATE);      
  }","  boolean isUseOnlineUpdate(){
    return Optional.ofNullable(useOnlineUpdate).orElse(DEFAULT_USE_ONLINE_UPDATE);      
  }","  boolean isUseOnlineUpdate(){
    return Optional.ofNullable(useOnlineUpdate).orElse(false);      
  }","  boolean isUseOnlineUpdate(){
    return Optional.ofNullable(useOnlineUpdate).orElse(false);      
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2214455519166546,  0.21424772081197124,  0.2587180947635743,  0.2587180947635743,23.0,0.5609756097560976,23.0,0.5609756097560976,22.0,0.5365853658536586,22.0,0.5365853658536586,2.0,0.09090909090909091,3.0,0.13636363636363635,3.0,0.13636363636363635,6.0,0.5454545454545454,2.0,0.16666666666666666,7.0,0.5
425,tablesaw,"public Reader createReader(byte[] cachedBytes) throws IOException{
    if (cachedBytes != null) {
        return charset != null ? new InputStreamReader(new ByteArrayInputStream(cachedBytes), charset) : new InputStreamReader(new ByteArrayInputStream(cachedBytes));
    }
    if (inputStream != null) {
        return new InputStreamReader(inputStream, charset);
    }
    if (reader != null) {
        return reader;
    }
    return new InputStreamReader(new FileInputStream(file), charset);
}",createReader,tech/tablesaw/io/Source.java,/core/src/main/java/tech/tablesaw/io/Source.java,"/**
   * If cachedBytes are not null, returns a Reader created from the cachedBytes. Otherwise, returns
   * a Reader from the underlying source.
   */",86-103,"('createReader', {'INSTRUCTION': {'covered': 51, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",89.0,14.0,"If cachedBytes are not null, returns a Reader created from the cachedBytes.","It checks whether cachedBytes are not null, returning a Reader that use the cachedBytes, if not null, or the underlying source otherwise.",A Reader is created from the cachedBytes if they are not null.,0.66185881426421,"If cachedBytes is not null, returns a reader created from cachedBytes."," public Reader createReader(byte[] cachedBytes) throws IOException{
    if (cachedBytes != null) {
      return new InputStreamReader(new ByteArrayInputStream(cachedBytes), charset);
    } else {
      return new InputStreamReader(inputStream, charset);
    }
  }"," public Reader createReader(byte[] cachedBytes) throws IOException{
    if (cachedBytes != null) {
      return new InputStreamReader(new ByteArrayInputStream(cachedBytes), charset);
    } else {
      return createReader();
    }
  }"," public Reader createReader(byte[] cachedBytes) throws IOException{
    if (cachedBytes != null) {
      return new InputStreamReader(new ByteArrayInputStream(cachedBytes), charset);
    }
    if (reader != null) {
      return reader;
    }
    if (file != null) {
      return new InputStreamReader(new FileInputStream(file), charset);
    }
    if (inputStream != null) {
      return new InputStreamReader(inputStream, charset);
    }
    throw new IOException(""No source available"");
  }"," public Reader createReader(byte[] cachedBytes) throws IOException{
    if (cachedBytes != null) {
      return new InputStreamReader(new ByteArrayInputStream(cachedBytes), charset);
    }
    if (file != null) {
      return new InputStreamReader(new FileInputStream(file), charset);
    }
    if (reader != null) {
      return reader;
    }
    if (inputStream != null) {
      return new InputStreamReader(inputStream, charset);
    }
    throw new IllegalStateException(""No source available"");
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.44911416219091893,  0.42759315826858085,  0.8138036541107282,  0.7929703207773948,44.0,0.4888888888888889,49.0,0.5444444444444444,38.0,0.4175824175824176,35.0,0.38461538461538464,5.0,0.10638297872340426,45.0,0.4945054945054945,45.0,0.4945054945054945,15.0,0.6521739130434783,3.0,0.23076923076923078,12.0,0.9230769230769231
426,cdk,"static StereoEncoder newEncoder(IAtomContainer container, IAtom left, IAtom leftParent, IAtom right, IAtom rightParent, int[][] graph){
    List<IBond> leftBonds = container.getConnectedBondsList(left);
    List<IBond> rightBonds = container.getConnectedBondsList(right);
    if (accept(left, leftBonds) && accept(right, rightBonds)) {
        int leftIndex = container.indexOf(left);
        int rightIndex = container.indexOf(right);
        int leftParentIndex = container.indexOf(leftParent);
        int rightParentIndex = container.indexOf(rightParent);
        int[] leftNeighbors = moveToBack(graph[leftIndex], leftParentIndex);
        int[] rightNeighbors = moveToBack(graph[rightIndex], rightParentIndex);
        int l1 = leftNeighbors[0];
        int l2 = leftNeighbors[1] == leftParentIndex ? leftIndex : leftNeighbors[1];
        int r1 = rightNeighbors[0];
        int r2 = rightNeighbors[1] == rightParentIndex ? rightIndex : rightNeighbors[1];
        GeometricParity geometric = geometric(container, leftIndex, rightIndex, l1, l2, r1, r2);
        if (geometric != null) {
            return new GeometryEncoder(new int[] { leftIndex, rightIndex }, new CombinedPermutationParity(permutation(leftNeighbors), permutation(rightNeighbors)), geometric);
        }
    }
    return null;
}",newEncoder,org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,"/**
     * Create a new encoder for the specified left and right atoms. The parent
     * is the atom which is connected by a double bond to the left and right
     * atom. For simple double bonds the parent of each is the other atom, in
     * cumulenes the parents are not the same.
     *
     * @param container   the molecule
     * @param left        the left atom
     * @param leftParent  the left atoms parent (usually {@literal right})
     * @param right       the right atom
     * @param rightParent the right atoms parent (usually {@literal left})
     * @param graph       adjacency list representation of the molecule
     * @return a stereo encoder (or null)
     */",94-146,"('newEncoder', {'INSTRUCTION': {'covered': 109, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",254.0,12.0,Create a new encoder for the specified left and right atoms.,"Given a left and right atoms, return a stereo encoder for them. The parent is the atom connected by a double bond to the two atoms. In case of simple double bonds the parent is the other atom.",The left and right atoms are specified.,0.232184564051873,Create a new encoder for the specified left and right atoms.," static StereoEncoder newEncoder(IAtomContainer container, IAtom left, IAtom leftParent, IAtom right, IAtom rightParent, int[][] graph){
     
      // find substituents of each atom
      List<IAtom> leftSubstituents = new ArrayList<IAtom>();
      List<IAtom> rightSubstituents = new ArrayList<IAtom>();
     
      for (IAtom atom : container.atoms()) {
            if (atom != left && atom != right) {
                 if (graph[left.getIndex()].contains(atom.getIndex())) {
                  leftSubstituents.add(atom);
                 }
                 if (graph[right.getIndex()].contains(atom.getIndex())) {
                  rightSubstituents.add(atom);
                 }
            }
      }
     
      // if no substituents then no encoding
      if (leftSubstituents.isEmpty() || rightSubstituents.isEmpty()) return null;
     
      // if substituents are constitutionally double bonded then no encoding
      if (isDoubleBonded(leftSubstituents) || isDoubleBonded(rightSubstituents)) return null;
     
      // if substituents are constitutionally triple bonded then no encoding
      if (isTripleBonded(leftSubstituents) || isTripleBonded(rightSubstituents)) return null;
     
      // if substituents are constitutionally quadruple bonded then no encoding
      if (isQuadrupleBonded(leftSubstituents) || isQuadrupleBonded(rightSubstituents)) return null;
     
      // if substituents are constitutionally pentabonded then no encoding
      if (isPentaBonded(leftSubstituents) || isPentaBonded(rightSubstituents)) return null;
     
      // if substituents are constitutionally hexabonded then no encoding
      if (isHexaBonded(leftSubstituents) || isHexaBonded(rightSubstituents)) return null;
     
      // if substituents are constitutionally heptabonded then no encoding
      if (isHeptaBonded(leftSubst           
 }","static StereoEncoder newEncoder(IAtomContainer container, IAtom left, IAtom leftParent, IAtom right, IAtom rightParent, int[][] graph){
     
      // if left and right are constitutionally constitutionally bonded then skip
      if (graph[left.getIndex()][right.getIndex()] == 0) return null;
     
      // if left and right are constitutionally constitutionally bonded then skip
      if (graph[right.getIndex()][left.getIndex()] == 0) return null;
     
      // if left and right are constitutionally constitutionally bonded then skip
      if (graph[leftParent.getIndex()][rightParent.getIndex()] == 0) return null;
     
      // if left and right are constitutionally constitutionally bonded then skip
      if (graph[rightParent.getIndex()][leftParent.getIndex()] == 0) return null;
     
      // if left and right are constitutionally constitutionally bonded then skip
      if (graph[left.getIndex()][leftParent.getIndex()] == 0) return null;
     
      // if left and right are constitutionally constitutionally bonded then skip
      if (graph[right.getIndex()][rightParent.getIndex()] == 0) return null;
     
      // if left and right are constitutionally constitutionally bonded then skip
      if (graph[leftParent.getIndex()][right.getIndex()] == 0) return null;
     
      // if left and right are constitutionally bonded then skip
      if (graph[rightParent.getIndex()][left.getIndex()] == 0) return null;
     
      // if left and right are constitutionally bonded then skip
      if (graph[left.getIndex()][rightParent.getIndex()] == 0) return null;
     
      // if left and right are constitutionally bonded then skip
      if (graph[rightParent.getIndex()][leftParent.getIndex()] == 0) return null;
     
      // if left and right are constitutionally bonded then skip
      if (graph[leftParent.getIndex()][rightParent.getIndex()] == 0) return null;
     
      // if left and right are constitutionally bonded then skip
      if (graph[right.getIndex()][leftParent.getIndex()] == 0) return null;
     
      // if left and right are constitutionally bonded then skip
      if (graph[leftParent.         
 }",Not Valid," static StereoEncoder newEncoder(IAtomContainer container, IAtom left, IAtom leftParent, IAtom right, IAtom rightParent, int[][] graph){
     
      // if the left and right atoms are not bonded to each other
      if (!isBonded(left, right, graph)) return null;
     
      // if the left and right atoms are not bonded to each other
      if (!isBonded(right, left, graph)) return null;
     
      // if the left and right atoms are not bonded to each other
      if (!isBonded(leftParent, rightParent, graph)) return null;
     
      // if the left and right atoms are not bonded to each other
      if (!isBonded(rightParent, leftParent, graph)) return null;
     
      // if the left and right atoms are not bonded to each other
      if (!isBonded(left, leftParent, graph)) return null;
     
      // if the left and right atoms are not bonded to each other
      if (!isBonded(right, rightParent, graph)) return null;
     
      // if the left and right atoms are not bonded to each other
      if (!isBonded(leftParent, right, graph)) return null;
     
      // if the left and right atoms are not bonded to each other
      if (!isBonded(rightParent, left, graph)) return null;
     
      // if the left and right atoms are not bonded to each other
      if (!isBonded(left, rightParent, graph)) return null;
     
      // if the left and right atoms are not bonded to each other
      if (!isBonded(right, leftParent, graph)) return null;
     
      // if the left and right atoms are not bonded to each other
      if (!isBonded(leftParent, rightParent, graph)) return null;
     
      // if the left and right atoms are not bonded to each other
      if (!isBonded(rightParent, leftParent, graph)) return null;
     
      // if the left and right atoms are not bonded to each other
      if (!isBonded(leftParent, right, graph)) return null;
     
      // if the left and right atoms are not bonded to each other
      if (!isBonded(rightParent, left           
 }",Syntax Error,Syntax Error,Syntax Error,Not Valid,None,None,None,None,None,None,None,None,200.0,0.7843137254901961,None,None,None,None,154.0,0.6497890295358649,None,None,33.0,0.8461538461538461,0.0,0.0,10.0,0.8333333333333334
427,cdk,"static String chargeAdjunctText(final int charge, final int unpaired){
    StringBuilder sb = new StringBuilder();
    if (unpaired == 1) {
        if (charge != 0) {
            sb.append('(').append(BULLET).append(')');
        } else {
            sb.append(BULLET);
        }
    } else if (unpaired > 1) {
        if (charge != 0) {
            sb.append('(').append(unpaired).append(BULLET).append(')');
        } else {
            sb.append(unpaired).append(BULLET);
        }
    }
    final char sign = charge < 0 ? MINUS : PLUS;
    final int coefficient = Math.abs(charge);
    if (coefficient > 1)
        sb.append(coefficient);
    if (coefficient > 0)
        sb.append(sign);
    return sb.toString();
}",chargeAdjunctText,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,"/**
     * Create the charge adjunct text for the specified charge and number of unpaired electrons.
     *
     * @param charge   formal charge
     * @param unpaired number of unpaired electrons
     * @return adjunct text
     */",605-636,"('chargeAdjunctText', {'INSTRUCTION': {'covered': 70, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",175.0,15.0,Create the charge adjunct text for the specified charge and number of unpaired electrons.,"Given a formal charge and the unpaired number of electrons, it creates the adjunct text.",The charge and number of unpaired electrons are the specified charges.,0.298585373510349,Create the charge addition text for the specified charge and the number of unpaired electrons.,"static String chargeAdjunctText(final int charge, final int unpaired){
        if (charge == 0 && unpaired == 0)
            return """";
        if (charge == 0)
            return String.format(""%d unpaired electron"", unpaired);
        if (unpaired == 0)
            return String.format(""%d charge"", charge);
        return String.format(""%d%s%d unpaired electron"", charge, PLUS, unpaired);
    }","static String chargeAdjunctText(final int charge, final int unpaired){
        if (charge == 0 && unpaired == 0) {
            return """";
        }
        if (charge == 0) {
            return String.format(""%d unpaired electron"", unpaired);
        }
        if (unpaired == 0) {
            return String.format(""%d charge"", charge);
        }
        return String.format(""%d charge, %d unpaired electron"", charge, unpaired);
    }","static String chargeAdjunctText(final int charge, final int unpaired){
        if (charge == 0 && unpaired == 0)
            return """";
        if (charge == 0)
            return ""e"" + unpaired;
        if (unpaired == 0)
            return charge + """";
        return charge + ""e"" + unpaired;
    }","static String chargeAdjunctText(final int charge, final int unpaired){
        if (charge == 0 && unpaired == 0)
            return """";
        if (charge == 0)
            return ""("" + unpaired + "" unpaired)"";
        if (unpaired == 0)
            return ""("" + charge + "")"";
        return ""("" + charge + "","" + unpaired + "" unpaired)"";
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2261657805132004,  0.22873026659253598,  0.19400059675779424,  0.18944901516480794,134.0,0.7613636363636364,131.0,0.7443181818181818,141.0,0.8011363636363636,141.0,0.8011363636363636,9.0,0.11538461538461539,27.0,0.36486486486486486,25.0,0.33783783783783783,14.0,0.875,2.0,0.125,13.0,0.8666666666666667
429,glowstone,"public static float randomReal(float range){
    ThreadLocalRandom rand = ThreadLocalRandom.current();
    return (2.0F * rand.nextFloat() - 1.0F) * range;
}",randomReal,net/glowstone/util/SoundUtil.java,/src/main/java/net/glowstone/util/SoundUtil.java,"/**
     * Generates a random float between {@code -range} and {@code range}.
     *
     * @param range the bounds of the random float.
     * @return A randomly generated float.
     */",86-95,"('randomReal', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,17.0,Generates a random float between {@code -range} and {@code range}.,"Given a range of two floats, the method returns a random float in the range.",A random float is generated between @code -range and @code range.,0.551772747519207,Generates a random float between {@code -range} and {@code range}.,"public static float randomReal(float range){
        return ThreadLocalRandom.current().nextFloat() * range * 2 - range;
    }"," public static float randomReal(float range){
        return ThreadLocalRandom.current().nextFloat() * range;
    }","public static float randomReal(float range){
        return ThreadLocalRandom.current().nextFloat() * range * 2 - range;
    }","public static float randomReal(float range){
        return ThreadLocalRandom.current().nextFloat() * range * 2 - range;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.46884158985550045,  0.4758353585027638,  0.46884158985550045,  0.46884158985550045,14.0,0.4,12.0,0.34285714285714286,14.0,0.4,14.0,0.4,4.0,0.14285714285714285,0.0,0.0,0.0,0.0,14.0,0.875,0.0,0.0,8.0,0.6666666666666666
430,openapi-generator,"private static ValidationRule.Result apacheNginxHeaderCheck(ParameterWrapper parameterWrapper){
    Parameter parameter = parameterWrapper.getParameter();
    if (parameter == null || !""header"".equals(parameter.getIn()))
        return ValidationRule.Pass.empty();
    ValidationRule.Result result = ValidationRule.Pass.empty();
    String headerName = parameter.getName();
    if (StringUtils.isNotEmpty(headerName) && StringUtils.contains(headerName, '_')) {
        result = new ValidationRule.Fail();
        result.setDetails(String.format(Locale.ROOT, ""%s contains an underscore."", headerName));
    }
    return result;
}",apacheNginxHeaderCheck,org/openapitools/codegen/validations/oas/OpenApiParameterValidations.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/validations/oas/OpenApiParameterValidations.java,"/**
     * Apache and Nginx default to legacy CGI behavior in which header with underscore are ignored. Raise this for awareness to the user.
     *
     * @param parameter Any spec doc parameter. The method will handle {@link HeaderParameter} evaluation.
     * @return {@link ValidationRule.Pass} if the check succeeds, otherwise {@link ValidationRule.Fail} with details ""[key] contains an underscore.""
     */",29-47,"('apacheNginxHeaderCheck', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",120.0,16.0,Apache and Nginx default to legacy CGI behavior in which header with underscore are ignored.,"Returns ValidationRule.Pass if the chek of the Apache and Nginx default to legacy CGI behavior is OK, ValidationRule.Fail otherwise.",The legacy behavior of Apache and Nginx is ignored.,1.39901976590337,Apache and Nginx use legacy CGI behavior by default in which the underscore header is ignored.," private static ValidationRule.Result apacheNginxHeaderCheck(ParameterWrapper parameterWrapper){
        if (parameterWrapper.getParameter() instanceof HeaderParameter) {
            HeaderParameter headerParameter = (HeaderParameter) parameterWrapper.getParameter();
            if (StringUtils.contains(headerParameter.getName(), ""_"")) {
                return ValidationRule.Result.failure(
                        ValidationConstants.ApacheNginxUnderscoreFailureMessage
                );
            }
        }
        return ValidationRule.Result.success();
    }       "," private static ValidationRule.Result apacheNginxHeaderCheck(ParameterWrapper parameterWrapper){
        if (parameterWrapper.getParameter() instanceof HeaderParameter) {
            HeaderParameter headerParameter = (HeaderParameter) parameterWrapper.getParameter();
            if (StringUtils.isNotBlank(headerParameter.getDefault())) {
                if (headerParameter.getDefault().equalsIgnoreCase(""apache"") || headerParameter.getDefault().equalsIgnoreCase(""nginx"")) {
                    return ValidationRule.Pass;
                }
            }
        }
        return ValidationRule.Fail;
    }       "," private static ValidationRule.Result apacheNginxHeaderCheck(ParameterWrapper parameterWrapper){
        if (parameterWrapper.getParameter() instanceof HeaderParameter) {
            HeaderParameter headerParameter = (HeaderParameter) parameterWrapper.getParameter();
            if (StringUtils.isNotBlank(headerParameter.getName())) {
                String headerName = headerParameter.getName();
                if (headerName.startsWith(""X-"") || headerName.startsWith(""x-"")) {
                    return ValidationRule.Result.failure(
                            String.format(Locale.ROOT, ValidationConstants.ApacheNginxUnderscoreFailureMessage, headerName));
                }
            }
        }
        return ValidationRule.Result.success();
    }       "," private static ValidationRule.Result apacheNginxHeaderCheck(ParameterWrapper parameterWrapper){
        if (parameterWrapper.getParameter() instanceof HeaderParameter) {
            HeaderParameter headerParameter = (HeaderParameter) parameterWrapper.getParameter();
            if (StringUtils.containsIgnoreCase(headerParameter.getName(), ""_"")) {
                return ValidationRule.Result.failure(
                        String.format(Locale.ROOT, ValidationConstants.ApacheNginxUnderscoreFailureMessage, headerParameter.getName()));
            }
        }
        return ValidationRule.Result.success();
    }       ",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3040629313497137,  0.32484400518504664,  0.3638531740398443,  0.4294551091829288,79.0,0.6528925619834711,79.0,0.6528925619834711,79.0,0.6528925619834711,68.0,0.5619834710743802,33.0,0.375,16.0,0.17777777777777778,39.0,0.35135135135135137,14.0,0.7,8.0,0.47058823529411764,12.0,0.75
431,acs-aem-commons,"public void disableIndex(@Nonnull Resource oakIndex) throws PersistenceException{
    final ModifiableValueMap oakIndexProperties = oakIndex.adaptTo(ModifiableValueMap.class);
    oakIndexProperties.put(PN_TYPE, DISABLED);
    log.info(""Disabled index at {}"", oakIndex.getPath());
}",disableIndex,com/adobe/acs/commons/oak/impl/EnsureOakIndexJobHandler.java,/bundle/src/main/java/com/adobe/acs/commons/oak/impl/EnsureOakIndexJobHandler.java,"/**
     * Disables an index, so it's no longer updated by Oak.
     *
     * @param oakIndex the index
     * @throws PersistenceException
     */",474-485,"('disableIndex', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,13.0,"Disables an index, so it's no longer updated by Oak.","Given an oakIndex, the method disables it so that Oak will not update it anymore.",Oak has disabled an index so it's no longer updated.,0.422592211603339,Disables an index so that it is no longer updated by Oak.," public void disableIndex(@Nonnull Resource oakIndex) throws PersistenceException{
        final ModifiableValueMap mvm = oakIndex.adaptTo(ModifiableValueMap.class);
        if (mvm == null ) {
            String msg = String.format(""Cannot adapt %s to a ModifiableValueMap (permissions?)"", oakIndex.getPath());
            throw new PersistenceException(msg);
        }
        mvm.put(PN_ENABLED, false);
        log.info(""Disabled Oak Index at [ {} ]"", oakIndex.getPath());       
 }"," public void disableIndex(@Nonnull Resource oakIndex) throws PersistenceException{
        final ModifiableValueMap mvm = oakIndex.adaptTo(ModifiableValueMap.class);
        if (mvm == null ) {
            String msg = String.format(""Cannot adapt %s to a ModifiableValueMap (permissions?)"", oakIndex.getPath());
            throw new PersistenceException(msg);
        }
        mvm.put(PN_ENABLED, false);
        log.info(""Disabled Oak Index at [ {} ]"", oakIndex.getPath());       
 }"," public void disableIndex(@Nonnull Resource oakIndex) throws PersistenceException{
        final ModifiableValueMap mvm = oakIndex.adaptTo(ModifiableValueMap.class);
        if (mvm == null ) {
            String msg = String.format(""Cannot adapt %s to a ModifiableValueMap (permissions?)"", oakIndex.getPath());
            throw new PersistenceException(msg);
        }
        mvm.put(PN_ENABLED, false);
    }"," public void disableIndex(@Nonnull Resource oakIndex) throws PersistenceException{
        final ModifiableValueMap mvm = oakIndex.adaptTo(ModifiableValueMap.class);
        if (mvm == null ) {
            String msg = String.format(""Cannot adapt %s to a ModifiableValueMap (permissions?)"", oakIndex.getPath());
            throw new PersistenceException(msg);
        }
        mvm.put(PN_ENABLED, false);     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6652239351748414,  0.6652239351748414,  0.6402856270201731,  0.6402856270201731,36.0,0.45,36.0,0.45,31.0,0.4626865671641791,31.0,0.4626865671641791,0.0,0.0,13.0,0.1625,13.0,0.1625,13.0,0.8125,4.0,0.3076923076923077,7.0,0.6363636363636364
433,metrics,"public void addListener(HealthCheckRegistryListener listener){
    listeners.add(listener);
    for (Map.Entry<String, HealthCheck> entry : healthChecks.entrySet()) {
        listener.onHealthCheckAdded(entry.getKey(), entry.getValue());
    }
}",addListener,io/dropwizard/metrics5/health/HealthCheckRegistry.java,/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/HealthCheckRegistry.java,"/**
     * Adds a {@link HealthCheckRegistryListener} to a collection of listeners that will be notified on health check
     * registration. Listeners will be notified in the order in which they are added. The listener will be notified of all
     * existing health checks when it first registers.
     *
     * @param listener listener to add
     */",68-80,"('addListener', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,21.0,Adds a {@link HealthCheckRegistryListener} to a collection of listeners that will be notified on health check  registration.,"Adds the HealthCheckRegistryListener to the listeners notified, following the order in which they are added, during the registration of health check",A collection of listeners that will be notified on health check registration has been added.,0.211016938309729,Adds a {@link HealthCheckRegistryListener} to a collection of listeners that will be notified when the health check is saved.," public void addListener(HealthCheckRegistryListener listener){
        listeners.add(listener);        
 }"," public void addListener(HealthCheckRegistryListener listener){
        listeners.add(listener);        
 }"," public void addListener(HealthCheckRegistryListener listener){
        listeners.add(listener);        
 }"," public void addListener(HealthCheckRegistryListener listener){
        listeners.add(listener);        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2320741863659077,  0.2320741863659077,  0.2320741863659077,  0.2320741863659077,37.0,0.6851851851851852,37.0,0.6851851851851852,37.0,0.6851851851851852,37.0,0.6851851851851852,0.0,0.0,0.0,0.0,0.0,0.0,19.0,0.8636363636363636,4.0,0.2,10.0,0.5555555555555556
434,jackson-databind,"public static TextNode valueOf(String v){
    if (v == null) {
        return null;
    }
    if (v.isEmpty()) {
        return EMPTY_STRING_NODE;
    }
    return new TextNode(v);
}",valueOf,com/fasterxml/jackson/databind/node/TextNode.java,/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java,"/**
     * Factory method that should be used to construct instances.
     * For some common cases, can reuse canonical instances: currently
     * this is the case for empty Strings, in future possible for
     * others as well. If null is passed, will return null.
     *
     * @return Resulting {@link TextNode} object, if <b>v</b>
     *   is NOT null; null if it is.
     */",27-45,"('valueOf', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,10.0,Factory method that should be used to construct instances.,"This factory method is used to create instances, using canonical instances for common cases (only Strings at the moment). If we pass null, it returns null.",The factory method should be used to build instances.,0.510732829548495,The factory method that must be used to build instances.,"public static TextNode valueOf(String v){
        if (v == null) {
            return null;
        }
        if (v.length() == 0) {
            return EMPTY_STRING_NODE;
        }
        return new TextNode(v);
    }","public static TextNode valueOf(String v){
        if(v == null) return null;
        if(v.length() == 0) return EMPTY_STRING_NODE;
        return new TextNode(v);
    }","public static TextNode valueOf(String v){
        if (v == null) {
            return null;
        }
        if (v.length() == 0) {
            return EMPTY_STRING_NODE;
        }
        return new TextNode(v);     
 }","public static TextNode valueOf(String v){
        if (v == null) {
            return null;
        }
        if (v.length() == 0) {
            return EMPTY_STRING_NODE;
        }
        return new TextNode(v);
    }",PASS,PASS,PASS,PASS,  0.8953796668876334,  0.7476807283653929,  0.8953796668876334,  0.8953796668876334,3.0,0.06818181818181818,7.0,0.16666666666666666,3.0,0.06818181818181818,3.0,0.06818181818181818,4.0,0.09090909090909091,0.0,0.0,0.0,0.0,25.0,0.9259259259259259,4.0,0.36363636363636365,4.0,0.4
435,cdk,"public BitSet projectG2(BitSet set){
    BitSet projection = new BitSet(getSecondGraphSize());
    CDKRNode xNode = null;
    for (int x = set.nextSetBit(0); x >= 0; x = set.nextSetBit(x + 1)) {
        xNode = getGraph().get(x);
        projection.set(xNode.getRMap().getId2());
    }
    return projection;
}",projectG2,org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,"/**
     *  Projects a CDKRGraph bitset on the source graph G2.
     * @param  set  CDKRGraph BitSet to project
     * @return      The associate BitSet in G2
     */",546-560,"('projectG2', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",83.0,10.0,Projects a CDKRGraph bitset on the source graph G2.,"Given the source graph G2, the function projects a CDKRGraph bitset.",The bitset is on the source graph G2.,0.209183538563358,Projects a CDKRGraph bit set onto the G2 source graphic.,"public BitSet projectG2(BitSet set){
        BitSet projection = new BitSet(getSecondGraphSize());
        CDKRNode xNode = null;
    
        for (int x = set.nextSetBit(0); x >= 0; x = set.nextSetBit(x + 1)) {
            xNode = getGraph().get(x);
            projection.set(xNode.getRMap().getId2());
        }
        return projection;
    }","public BitSet projectG2(BitSet set){
        BitSet projection = new BitSet(getSecondGraphSize());
        CDKRNode xNode = null;
    
        for (int x = set.nextSetBit(0); x >= 0; x = set.nextSetBit(x + 1)) {
            xNode = getGraph().get(x);
            projection.set(xNode.getRMap().getId2());
        }
        return projection;
    }","public BitSet projectG2(BitSet set){
        BitSet projection = new BitSet(getSecondGraphSize());
        CDKRNode xNode = null;
    
        for (int x = set.nextSetBit(0); x >= 0; x = set.nextSetBit(x + 1)) {
            xNode = getGraph().get(x);
            projection.set(xNode.getRMap().getId2());
        }
        return projection;
    }","public BitSet projectG2(BitSet set){
        BitSet projection = new BitSet(getSecondGraphSize());
        CDKRNode xNode = null;
    
        for (int x = set.nextSetBit(0); x >= 0; x = set.nextSetBit(x + 1)) {
            xNode = getGraph().get(x);
            projection.set(xNode.getRMap().getId2());
        }
        return projection;
    }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10.0,0.8333333333333334,6.0,0.5454545454545454,4.0,0.4
436,cdk,"private boolean isMacroCycle(IRing ring, IRingSet rs){
    if (ring.getAtomCount() < 8)
        return false;
    for (IBond bond : ring.bonds()) {
        boolean found = false;
        for (IAtomContainer other : rs.atomContainers()) {
            if (ring == other)
                continue;
            if (other.contains(bond)) {
                found = true;
                break;
            }
        }
        if (!found)
            return true;
    }
    return false;
}",isMacroCycle,org/openscience/cdk/layout/StructureDiagramGenerator.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/StructureDiagramGenerator.java,"/**
     * Check if a ring in a ring set is a macro cycle. We define this as a
     * ring with >= 10 atom and has at least one bond that isn't contained
     * in any other rings.
     *
     * @param ring ring to check
     * @param rs   rest of ring system
     * @return ring is a macro cycle
     */",1801-1827,"('isMacroCycle', {'INSTRUCTION': {'covered': 43, 'missed': 6}, 'BRANCH': {'covered': 9, 'missed': 3}, 'LINE': {'covered': 11, 'missed': 4}, 'COMPLEXITY': {'covered': 4, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,13.0,Check if a ring in a ring set is a macro cycle.,"Verify if a defined ring, in a ring set, is a macro cycle. It is defined like a ring with more than 10 atoms with at least one bond that is not contained in other rings.","If a ring is a macro cycle, you should check it.",0.209778343070917,Check if a ring in a set of rings is a macro cycle.,Empty Method,"private boolean isMacroCycle(IRing ring, IRingSet rs){
        if (ring.getAtomCount() < 10) return false;
        for (IBond bond : ring.bonds()) {
            if (!rs.contains(bond)) return false;
        }
        return true;
    }",Empty Method,Empty Method,Empty Method,NOT PASS,Empty Method,Empty Method,None,  0.505287586593467,None,None,None,None,43.0,0.46236559139784944,None,None,None,None,54.0,0.9818181818181818,None,None,None,None,27.0,0.7297297297297297,3.0,0.21428571428571427,9.0,0.6923076923076923
438,egeria,"public void addCollectionMembershipRelationship(String userId, String processGUID, String collectionGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    dataEngineCommonHandler.upsertExternalRelationship(userId, processGUID, collectionGUID, REFERENCEABLE_TO_COLLECTION_TYPE_NAME, COLLECTION_TYPE_NAME, externalSourceName, null);
}",addCollectionMembershipRelationship,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCollectionHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCollectionHandler.java,"/**
     * Create CollectionMembership relationships between a Process asset and a Collection. Verifies that the
     * relationship is not present before creating it
     *
     * @param userId             the name of the calling user
     * @param processGUID        the unique identifier of the process
     * @param collectionGUID     the unique identifier of the collection
     * @param externalSourceName the unique name of the external source
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",110-130,"('addCollectionMembershipRelationship', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",43.0,11.0,Create CollectionMembership relationships between a Process asset and a Collection.,"Given a Process and a Collection, create a relationship called CollectionMembership if it is not already present.",CollectionMembership relationships are created between a Process asset and a collection.,0.33226790238063,Create CollectionMembership relationships between a Process resource and a collection.," public void addCollectionMembershipRelationship(String userId, String processGUID, String collectionGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        dataEngineCommonHandler.addRelationship(userId, processGUID, collectionGUID, REFERENCEABLE_TO_COLLECTION_TYPE_NAME, externalSourceName);        
 }",Not Valid," public void addCollectionMembershipRelationship(String userId, String processGUID, String collectionGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        dataEngineCommonHandler.addRelationship(userId, processGUID, REFERENCEABLE_TO_COLLECTION_TYPE_NAME, collectionGUID, externalSourceName);        
 }"," public void addCollectionMembershipRelationship(String userId, String processGUID, String collectionGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        dataEngineCommonHandler.addRelationship(userId, processGUID, collectionGUID, REFERENCEABLE_TO_COLLECTION_TYPE_NAME, externalSourceName);        
 }",NOT PASS,Not Valid,NOT PASS,NOT PASS,  0.8069624455490044,None,  0.8069624455490044,  0.7856783405666004,5.0,0.11363636363636363,None,None,5.0,0.11363636363636363,6.0,0.13636363636363635,None,None,0.0,0.0,2.0,0.05,16.0,0.8888888888888888,2.0,0.18181818181818182,4.0,0.3333333333333333
439,jackson-databind,"public static Class<?> wrapperType(Class<?> primitiveType){
    if (primitiveType == Integer.TYPE) {
        return Integer.class;
    }
    if (primitiveType == Long.TYPE) {
        return Long.class;
    }
    if (primitiveType == Boolean.TYPE) {
        return Boolean.class;
    }
    if (primitiveType == Double.TYPE) {
        return Double.class;
    }
    if (primitiveType == Float.TYPE) {
        return Float.class;
    }
    if (primitiveType == Byte.TYPE) {
        return Byte.class;
    }
    if (primitiveType == Short.TYPE) {
        return Short.class;
    }
    if (primitiveType == Character.TYPE) {
        return Character.class;
    }
    throw new IllegalArgumentException(""Class "" + primitiveType.getName() + "" is not a primitive type"");
}",wrapperType,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * Helper method for finding wrapper type for given primitive type (why isn't
     * there one in JDK?).
     * NOTE: throws {@link IllegalArgumentException} if given type is NOT primitive
     * type (caller has to check).
     */",876-909,"('wrapperType', {'INSTRUCTION': {'covered': 55, 'missed': 0}, 'BRANCH': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",151.0,21.0,Helper method for finding wrapper type for given primitive type (why isn't  there one in JDK?).,"Starting with a given primitive type, this helper method can find the wrapper type.",There is a method for finding a wrapper type.,0.315737203659688,Help method to find the wrapper type for a given primitive type (why isn't there one in JDK?).," public static Class<?> wrapperType(Class<?> primitiveType){
        if (primitiveType == Integer.TYPE) {
            return Integer.class;
        }
        if (primitiveType == Long.TYPE) {
            return Long.class;
        }
        if (primitiveType == Boolean.TYPE) {
            return Boolean.class;
        }
        if (primitiveType == Double.TYPE) {
            return Double.class;
        }
        if (primitiveType == Float.TYPE) {
            return Float.class;
        }
        if (primitiveType == Byte.TYPE) {
            return Byte.class;
        }
        if (primitiveType == Short.TYPE) {
            return Short.class;
        }
        if (primitiveType == Character.TYPE) {
            return Character.class;
        }
        throw new IllegalArgumentException(""Class ""+primitiveType.getName()+"" is not a primitive type"");
    }"," public static Class<?> wrapperType(Class<?> primitiveType){
        if (primitiveType == null) {
            return null;
        }
        if (primitiveType == Integer.TYPE) {
            return Integer.class;
        }
        if (primitiveType == Long.TYPE) {
            return Long.class;
        }
        if (primitiveType == Boolean.TYPE) {
            return Boolean.class;
        }
        if (primitiveType == Double.TYPE) {
            return Double.class;
        }
        if (primitiveType == Float.TYPE) {
            return Float.class;
        }
        if (primitiveType == Byte.TYPE) {
            return Byte.class;
        }
        if (primitiveType == Short.TYPE) {
            return Short.class;
        }
        if (primitiveType == Character.TYPE) {
            return Character.class;
        }
        throw new IllegalArgumentException(""Class ""+primitiveType.getName()+"" is not a primitive type"");
    }"," public static Class<?> wrapperType(Class<?> primitiveType){
        if (primitiveType == null) {
            return null;
        }
        if (primitiveType == Integer.TYPE) {
            return Integer.class;
        }
        if (primitiveType == Long.TYPE) {
            return Long.class;
        }
        if (primitiveType == Boolean.TYPE) {
            return Boolean.class;
        }
        if (primitiveType == Double.TYPE) {
            return Double.class;
        }
        if (primitiveType == Float.TYPE) {
            return Float.class;
        }
        if (primitiveType == Byte.TYPE) {
            return Byte.class;
        }
        if (primitiveType == Short.TYPE) {
            return Short.class;
        }
        if (primitiveType == Character.TYPE) {
            return Character.class;
        }
        throw new IllegalArgumentException(""Class ""+primitiveType.getName()+"" is not a primitive type"");
    }"," public static Class<?> wrapperType(Class<?> primitiveType){
        if (primitiveType == Integer.TYPE) {
            return Integer.class;
        }
        if (primitiveType == Long.TYPE) {
            return Long.class;
        }
        if (primitiveType == Boolean.TYPE) {
            return Boolean.class;
        }
        if (primitiveType == Double.TYPE) {
            return Double.class;
        }
        if (primitiveType == Float.TYPE) {
            return Float.class;
        }
        if (primitiveType == Byte.TYPE) {
            return Byte.class;
        }
        if (primitiveType == Short.TYPE) {
            return Short.class;
        }
        if (primitiveType == Character.TYPE) {
            return Character.class;
        }
        throw new IllegalArgumentException(""Class ""+primitiveType.getName()+"" is not a primitive type"");
    }",PASS,PASS,PASS,PASS,  1.0,  0.9769892058570855,  1.0,  0.9769892058570855,0.0,0.0,11.0,0.06748466257668712,0.0,0.0,11.0,0.06748466257668712,11.0,0.06748466257668712,0.0,0.0,11.0,0.06748466257668712,16.0,0.9411764705882353,5.0,0.2631578947368421,15.0,0.8823529411764706
440,acs-aem-commons,"private boolean isDispatcherHeaders(final Agent agent){
    final ValueMap properties = agent.getConfiguration().getProperties();
    final String[] headers = properties.get(AgentConfig.PROTOCOL_HTTP_HEADERS, new String[] {});
    for (final String header : headers) {
        if (StringUtils.startsWith(header, CQ_ACTION_HEADER)) {
            return true;
        }
    }
    return false;
}",isDispatcherHeaders,com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,"/**
     * Checks if the agent has a valid dispatcher headers.
     *
     * @param agent Agent to check
     * @return true if the Agent's headers contain the proper values
     */",155-172,"('isDispatcherHeaders', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,10.0,Checks if the agent has a valid dispatcher headers.,Verifies whether in the agent there are valid dispatcher headers.,The agent is checked if he has a valid dispatch.,0.931881377386189,Checks whether the agent has valid dispatcher headers.," private boolean isDispatcherHeaders(final Agent agent){
        final AgentConfig config = agent.getConfiguration();
        final ValueMap headers = config.getHeaders();
    
        return headers.containsKey(CQ_ACTION_HEADER)
                && headers.containsKey(CQ_SCOPE_ACTION_HEADER);     
 }"," private boolean isDispatcherHeaders(final Agent agent){
        final AgentConfig config = agent.getConfiguration();
        final ValueMap properties = config.getProperties();
        final String cqAction = properties.get(CQ_ACTION_HEADER, String.class);
        final String cqScope = properties.get(CQ_SCOPE_ACTION_HEADER, String.class);
    
        return StringUtils.isNotBlank(cqAction) && StringUtils.isNotBlank(cqScope);     
 }"," private boolean isDispatcherHeaders(final Agent agent){
        final AgentConfig config = agent.getConfiguration();
        final ValueMap properties = config.getProperties();
        final String cqAction = properties.get(CQ_ACTION_HEADER, String.class);
        final String cqScope = properties.get(CQ_SCOPE_ACTION_HEADER, String.class);
    
        return StringUtils.isNotBlank(cqAction) && StringUtils.isNotBlank(cqScope);     
 }"," private boolean isDispatcherHeaders(final Agent agent){
        final AgentConfig config = agent.getConfiguration();
        final ValueMap headers = config.getHeaders();
    
        return headers.containsKey(CQ_ACTION_HEADER)
                && headers.containsKey(CQ_SCOPE_ACTION_HEADER);     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.26682561989557146,  0.41579903075579905,  0.26682561989557146,  0.4305049131087403,44.0,0.5789473684210527,46.0,0.6052631578947368,44.0,0.5789473684210527,46.0,0.6052631578947368,38.0,0.5,0.0,0.0,38.0,0.5,5.0,0.45454545454545453,2.0,0.2,8.0,0.7272727272727273
441,matsim-libs,"private double findMinimalDistance(double minimalAdditionalDistance, double possibleAdditionalDistance){
    if (minimalAdditionalDistance == 0)
        minimalAdditionalDistance = possibleAdditionalDistance;
    else if (possibleAdditionalDistance < minimalAdditionalDistance)
        minimalAdditionalDistance = possibleAdditionalDistance;
    return minimalAdditionalDistance;
}",findMinimalDistance,org/matsim/contrib/freight/jsprit/DistanceConstraint.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/jsprit/DistanceConstraint.java,"/**
	 * Checks if the find possible distance is the minimal one.
	 *
	 * @param minimalAdditionalDistance
	 * @param possibleAdditionalDistance
	 * @return the minimal transport distance
	 */",287-300,"('findMinimalDistance', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,11.0,Checks if the find possible distance is the minimal one.,Verifies if the distance we found is the minimal one.,"If the find is minimal, it's checked.",0.123801918846869,Checks if the possible distance is minimal.," private double findMinimalDistance(double minimalAdditionalDistance, double possibleAdditionalDistance){
	 if(possibleAdditionalDistance < minimalAdditionalDistance){
		 minimalAdditionalDistance = possibleAdditionalDistance;
	 }
	 return minimalAdditionalDistance;
 }"," private double findMinimalDistance(double minimalAdditionalDistance, double possibleAdditionalDistance){
	 if(possibleAdditionalDistance < minimalAdditionalDistance){
		 minimalAdditionalDistance = possibleAdditionalDistance;
	 }
	 return minimalAdditionalDistance;			
 }","private double findMinimalDistance(double minimalAdditionalDistance, double possibleAdditionalDistance){
	 if (minimalAdditionalDistance == 0) {
		 minimalAdditionalDistance = possibleAdditionalDistance;
	 } else {
		 if (possibleAdditionalDistance < minimalAdditionalDistance) {
			 minimalAdditionalDistance = possibleAdditionalDistance;
		 }
	 }
	 return minimalAdditionalDistance;
 }","private double findMinimalDistance(double minimalAdditionalDistance, double possibleAdditionalDistance){
	 if (minimalAdditionalDistance == 0) {
		 minimalAdditionalDistance = possibleAdditionalDistance;
	 } else {
		 if (possibleAdditionalDistance < minimalAdditionalDistance) {
			 minimalAdditionalDistance = possibleAdditionalDistance;
		 }
	 }
	 return minimalAdditionalDistance;
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6452953121548923,  0.6452953121548923,  0.8204577386295011,  0.8204577386295011,13.0,0.35135135135135137,13.0,0.35135135135135137,6.0,0.13953488372093023,6.0,0.13953488372093023,0.0,0.0,15.0,0.3488372093023256,15.0,0.3488372093023256,4.0,0.36363636363636365,4.0,0.36363636363636365,7.0,0.6363636363636364
442,cdk,"public String toString(){
    StringBuffer resultString = new StringBuffer(32);
    resultString.append(""Bond("").append(this.hashCode());
    if (getOrder() != null) {
        resultString.append("", #O:"").append(getOrder());
    }
    resultString.append("", #S:"").append(getStereo());
    if (getAtomCount() > 0) {
        resultString.append("", #A:"").append(getAtomCount());
        for (int i = 0; i < atomCount; i++) {
            resultString.append("", "").append(atoms[i] == null ? ""null"" : atoms[i].toString());
        }
    }
    resultString.append("", "").append(super.toString());
    resultString.append(')');
    return resultString.toString();
}",toString,org/openscience/cdk/silent/Bond.java,/base/silent/src/main/java/org/openscience/cdk/silent/Bond.java,"/**
     * Returns a one line string representation of this Container. This method is
     * conform RFC #9.
     *
     * @return The string representation of this Container
     */",584-607,"('toString', {'INSTRUCTION': {'covered': 76, 'missed': 2}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",168.0,10.0,Returns a one line string representation of this Container.,Represent the Container using a string of one line.,A one line string representation of this container is returned.,0.302895802147426,Returns a string representation of a row in this container.," public String toString(){
        StringBuffer sb = new StringBuffer();
        sb.append(getBegin().getSymbol());
        sb.append(""-"");
        sb.append(getEnd().getSymbol());
        return sb.toString();
    }","public String toString(){
        StringBuffer sb = new StringBuffer();
        sb.append(atoms[0].getSymbol());
        sb.append(""-"");
        sb.append(atoms[1].getSymbol());
        return sb.toString();
    }","public String toString(){
        StringBuffer sb = new StringBuffer();
        sb.append(""Bond["");
        for (int i=0; i<atoms.length; i++) {
            sb.append(atoms[i].getSymbol());
            if (i<atoms.length-1) sb.append("","");
        }
        sb.append(""]"");
        return sb.toString();
    }","public String toString(){
        StringBuffer sb = new StringBuffer();
        sb.append(""Bond: "");
        sb.append(getAtom(0).getSymbol());
        sb.append(""-"");
        sb.append(getAtom(1).getSymbol());
        sb.append("";"");
        return sb.toString();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.19024416214954964,  0.19238465907548175,  0.21679510937197427,  0.27883097340860274,123.0,0.727810650887574,124.0,0.7337278106508875,113.0,0.6686390532544378,111.0,0.6568047337278107,8.0,0.13793103448275862,18.0,0.25,42.0,0.4883720930232558,8.0,0.8,6.0,0.5454545454545454,5.0,0.45454545454545453
443,cdk,"private Edge findDirectionalEdge(Graph g, int u){
    List<Edge> edges = g.edges(u);
    if (edges.size() == 1)
        return null;
    Edge first = null;
    for (Edge e : edges) {
        Bond b = e.bond();
        if (b == Bond.UP || b == Bond.DOWN) {
            if (first == null)
                first = e;
            else if (((first.either() == e.either()) == (first.bond() == b)))
                return null;
        }
    }
    return first;
}",findDirectionalEdge,org/openscience/cdk/smiles/BeamToCDK.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/BeamToCDK.java,"/**
     * Utility for find the first directional edge incident to a vertex. If
     * there are no directional labels then null is returned.
     *
     * @param g graph from Beam
     * @param u the vertex for which to find
     * @return first directional edge (or null if none)
     */",419-442,"('findDirectionalEdge', {'INSTRUCTION': {'covered': 54, 'missed': 3}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 12, 'missed': 1}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",122.0,12.0,Utility for find the first directional edge incident to a vertex.,"This utility can be used for finding the first directional edge that is incident to a vertex, returning null if no directional labels can be found.",The first incident to a vertex is a utility.,0.415331338494571,Utility to find the first directional edge incident at a vertex.," private Edge findDirectionalEdge(Graph g, int u){
        for (Edge e : g.edgesOf(u)) {
            if (g.directionOf(e) == Graph.Direction.OUT)
                return e;
        }
        return null;        
 }"," private Edge findDirectionalEdge(Graph g, int u){
        Edge e = g.firstEdge(u);
        while (e != null) {
            if (g.directionOf(e) != Graph.NONE)
                return e;
            e = g.nextEdge(e);
        }
        return null;        
 }","private Edge findDirectionalEdge(Graph g, int u){
        int[] nbrs = g.neighbors(u);
        for (int i = 0; i < nbrs.length; i++) {
            Edge e = g.getEdge(u, nbrs[i]);
            if (e.type() == Edge.Type.DIRECTED)
                return e;
        }
        return null;        
 }","private Edge findDirectionalEdge(Graph g, int u){
        int[] nbrs = g.neighbors(u);
        for (int i = 0; i < nbrs.length; i++) {
            Edge e = g.getEdge(u, nbrs[i]);
            if (e.type() == Edge.Type.DIRECTIONAL)
                return e;
        }
        return null;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2064403735097427,  0.22449405214101414,  0.3232275725844299,  0.3232275725844299,87.0,0.7073170731707317,83.0,0.6747967479674797,80.0,0.6504065040650406,80.0,0.6504065040650406,23.0,0.3898305084745763,41.0,0.5256410256410257,41.0,0.5256410256410257,18.0,0.6666666666666666,2.0,0.16666666666666666,10.0,0.8333333333333334
444,weblogic-kubernetes-operator,"public boolean matchesYaml(String yaml){
    final String thisJson = toJson();
    final String otherJson = createFromYaml(yaml).toJson();
    return JsonParser.parseString(thisJson).equals(JsonParser.parseString(otherJson));
}",matchesYaml,oracle/kubernetes/weblogic/domain/model/MonitoringExporterConfiguration.java,/operator/src/main/java/oracle/kubernetes/weblogic/domain/model/MonitoringExporterConfiguration.java,"/**
   * Returns true if the specified YAML string matches this configuration, ignoring unknown fields
   * and field ordering. Note that ordering of elements in arrays is considered significant for this comparison.
   * @param yaml a monitoring exporter configuration to compare to this object.
   */",58-67,"('matchesYaml', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,18.0,"Returns true if the specified YAML string matches this configuration, ignoring unknown fields  and field ordering.","If the specified YAML string matches the configuration (ignoring fields that are unknown and the order of fields), the function returns true","If the specified YAML string matches the configuration, returns true.",0.330182835182501,"Returns true if the specified YAML string matches this configuration, ignoring unknown fields and field order."," public boolean matchesYaml(String yaml){
    return new Gson().toJson(this).equals(convertToJson(yaml));
  }"," public boolean matchesYaml(String yaml){
    return convertToJson(yaml).equals(toJson());
  }"," public boolean matchesYaml(String yaml){
    return toYaml().equals(yaml);   
 }"," public boolean matchesYaml(String yaml){
    return new Gson().fromJson(JsonParser.parseString(convertToJson(yaml)), MonitoringExporterConfiguration.class).equals(this);
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.31680879879484514,  0.3059618968662208,  0.33639099177166465,  0.26637885119596827,26.0,0.5306122448979592,29.0,0.5918367346938775,28.0,0.5714285714285714,31.0,0.6326530612244898,9.0,0.3103448275862069,14.0,0.3684210526315789,10.0,0.3448275862068966,18.0,0.782608695652174,1.0,0.058823529411764705,10.0,0.5882352941176471
445,tablesaw,"DoubleColumn logN(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[logN]"", size());
    for (int i = 0; i < size(); i++) {
        newColumn.set(i, Math.log(getDouble(i)));
    }
    return newColumn;
}",logN,tech/tablesaw/columns/numbers/NumberMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/numbers/NumberMapFunctions.java,/** Returns the natural log of the values in this column as a NumberColumn. */,275-283,"('logN', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",62.0,14.0,Returns the natural log of the values in this column as a NumberColumn.,Fill a NumeralColumn with the natural log of the value in this column.,The log of values in this column is a NumberColumn.,0.0857088444965321,Returns the natural log of values in this column as a NumberColumn column.,"DoubleColumn logN(){
    DoubleColumn result = DoubleColumn.create(name() + ""[ln]"", size());
    for (int i = 0; i < size(); i++) {
      result.set(i, Math.log(getDouble(i)));
    }
    return result;    
 }","DoubleColumn logN(){
    DoubleColumn result = DoubleColumn.create(name() + ""[ln]"", size());
    for (int i = 0; i < size(); i++) {
      result.set(i, Math.log(getDouble(i)));
    }
    return result;    
 }","DoubleColumn logN(){
    DoubleColumn result = DoubleColumn.create(name() + ""[log]"", size());
    for (int r = 0; r < size(); r++) {
      double val = getDouble(r);
      if (DoubleColumnType.valueIsMissing(val)) {
        result.setMissing(r);
      } else {
        result.set(r, Math.log(val));
      }
    }
    return result;    
 }","DoubleColumn logN(){
    DoubleColumn result = DoubleColumn.create(name() + ""[ln]"", size());
    for (int r = 0; r < size(); r++) {
      double val = getDouble(r);
      if (DoubleColumnType.valueIsMissing(val)) {
        result.setMissing(r);
      } else {
        result.set(r, Math.log(val));
      }
    }
    return result;    
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.9046651828439718,  0.9178230775808139,  0.6673828733227802,  0.6542249785859381,4.0,0.06349206349206349,4.0,0.06349206349206349,41.0,0.4606741573033708,41.0,0.4606741573033708,0.0,0.0,37.0,0.4157303370786517,38.0,0.42696629213483145,9.0,0.6428571428571429,3.0,0.21428571428571427,5.0,0.35714285714285715
446,tablesaw,"StringColumn yearDay(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & month"");
    for (int r = 0; r < this.size(); r++) {
        long c1 = this.getLongInternal(r);
        if (DateTimeColumn.valueIsMissing(c1)) {
            newColumn.append(StringColumnType.missingValueIndicator());
        } else {
            String ym = String.valueOf(getYear(c1));
            ym = ym + ""-"" + Strings.padStart(String.valueOf(getDayOfYear(c1)), 3, '0');
            newColumn.append(ym);
        }
    }
    return newColumn;
}",yearDay,tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,"/**
   * Returns a StringColumn with the year and day-of-year derived from this column concatenated into
   * a String that will sort lexicographically in temporal order.
   *
   * <p>This simplifies the production of plots and tables that aggregate values into standard
   * temporal units (e.g., you want monthly data but your source data is more than a year long and
   * you don't want months from different years aggregated together).
   */",238-259,"('yearDay', {'INSTRUCTION': {'covered': 52, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",125.0,24.0,Returns a StringColumn with the year and day-of-year derived from this column concatenated into  a String that will sort lexicographically in temporal order.,Creates a StringColumn containing the year and the day of the year and sort the column lexicographically in temporal order.,The year and day-of-year derived from this column will be used to sort the string by temporal order.,0.366824091968015,Returns a StringColumn with the year and day of the year derived from this column concatenated into a String that will sort lexicographically in temporal order.,"StringColumn yearDay(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & day"");
    for (int r = 0; r < this.size(); r++) {
      long c1 = this.getLongInternal(r);
      if (DateTimeColumn.valueIsMissing(c1)) {
        newColumn.append(StringColumnType.missingValueIndicator());
      } else {
        String yd = String.valueOf(getYear(c1));
        yd = yd + ""-"" + Strings.padStart(String.valueOf(getDayOfYear(c1)), 3, '0');
        newColumn.append(yd);
      }
    }
    return newColumn;
  }","StringColumn yearDay(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & day"");
    for (int r = 0; r < this.size(); r++) {
      long c1 = this.getLongInternal(r);
      if (DateTimeColumn.valueIsMissing(c1)) {
        newColumn.append(StringColumnType.missingValueIndicator());
      } else {
        String yd = String.valueOf(getYear(c1));
        yd = yd + ""-"" + Strings.padStart(String.valueOf(getDayOfYear(c1)), 3, '0');
        newColumn.append(yd);
      }
    }
    return newColumn;
  }","StringColumn yearDay(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & day"");
    for (int r = 0; r < this.size(); r++) {
      long c1 = this.getLongInternal(r);
      if (DateTimeColumn.valueIsMissing(c1)) {
        newColumn.append(StringColumnType.missingValueIndicator());
      } else {
        String yd = String.valueOf(getYear(c1));
        yd = yd + ""-"" + Strings.padStart(String.valueOf(getDayOfYear(c1)), 3, '0');
        newColumn.append(yd);
      }
    }
    return newColumn;
  }","StringColumn yearDay(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & day"");
    for (int r = 0; r < this.size(); r++) {
      long c1 = this.getLongInternal(r);
      if (DateTimeColumn.valueIsMissing(c1)) {
        newColumn.append(StringColumnType.missingValueIndicator());
      } else {
        String yd = String.valueOf(getYear(c1));
        yd = yd + ""-"" + Strings.padStart(String.valueOf(getDayOfYear(c1)), 3, '0');
        newColumn.append(yd);
      }
    }
    return newColumn;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.9473762075833406,  0.9351810856321211,  0.9351810856321211,  0.9473762075833406,5.0,0.03968253968253968,5.0,0.03968253968253968,5.0,0.03968253968253968,5.0,0.03968253968253968,0.0,0.0,0.0,0.0,0.0,0.0,14.0,0.5833333333333334,4.0,0.14814814814814814,14.0,0.5833333333333334
447,cdk,"public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
    neighboors = ac.getConnectedAtomsList(atom);
    IAtomContainer clone;
    try {
        clone = (IAtomContainer) ac.clone();
    } catch (CloneNotSupportedException e) {
        return getDummyDescriptorValue(e);
    }
    try {
        peoe = new GasteigerMarsiliPartialCharges();
        peoe.setMaxGasteigerIters(6);
        peoe.assignGasteigerMarsiliSigmaPartialCharges(clone, true);
    } catch (Exception exception) {
        return getDummyDescriptorValue(exception);
    }
    IAtom localAtom = clone.getAtom(ac.indexOf(atom));
    neighboors = clone.getConnectedAtomsList(localAtom);
    DoubleArrayResult protonPartialCharge = new DoubleArrayResult(MAX_PROTON_COUNT);
    assert (neighboors.size() < MAX_PROTON_COUNT);
    protonPartialCharge.add(localAtom.getCharge());
    int hydrogenNeighbors = 0;
    for (IAtom neighboor : neighboors) {
        if (neighboor.getAtomicNumber() == IElement.H) {
            hydrogenNeighbors++;
            protonPartialCharge.add(neighboor.getCharge());
        }
    }
    int remainder = MAX_PROTON_COUNT - (hydrogenNeighbors + 1);
    for (int i = 0; i < remainder; i++) protonPartialCharge.add(Double.NaN);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), protonPartialCharge, getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/atomic/ProtonTotalPartialChargeDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/ProtonTotalPartialChargeDescriptor.java,"/**
     *  The method returns partial charges assigned to an heavy atom and its protons through Gasteiger Marsili
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *
     *@param  atom              The IAtom for which the DescriptorValue is requested
     *@param  ac                AtomContainer
     *@return                   an array of doubles with partial charges of [heavy, proton_1 ... proton_n]
     */",109-160,"('calculate', {'INSTRUCTION': {'covered': 107, 'missed': 14}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 23, 'missed': 4}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",244.0,29.0,The method returns partial charges assigned to an heavy atom and its protons through Gasteiger Marsili  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.,"Given a heavy atom, it returns the partial charges assigned and the protons through Gasteiger Marsili. You have to call addExplicitHydrogensToSatisfyValency method, defined in the class tools.HydrogenAdder.",The method returns partial charges assigned to an heavy atom and its protons through Gasteiger Marsili.,0.419789465673351,The method returns partial charges assigned to a heavy atom and its protons via Gasteiger Marsili It is necessary to call the addExplicit methodHydrogensToSatisfyValency from the class tools.,Not Valid,Not Valid,"public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
        try {
            if (peoe == null)
                peoe = new GasteigerMarsiliPartialCharges();
            neighboors = ac.getConnectedAtomsList(atom);
            double[] result = new double[MAX_PROTON_COUNT];
            for (int i = 0; i < MAX_PROTON_COUNT; i++)
                result[i] = Double.NaN;
            if (atom.getAtomicNumber() > 1) {
                result[0] = peoe.getPartialCharge(atom);
                if (neighboors.size() > 0) {
                    for (int i = 0; i < neighboors.size(); i++) {
                        if (neighboors.get(i).getAtomicNumber() == 1) {
                            result[i + 1] = peoe.getPartialCharge(neighboors.get(i));
                        }
                    }
                }
            }
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleArrayResult(
                    result), getDescriptorNames());
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }",Not Valid,Not Valid,Not Valid,Not Valid,NOT PASS,None,None,None,  0.43542635483151226,None,None,None,None,None,None,179.0,0.7306122448979592,None,None,None,None,203.0,0.9950980392156863,20.0,0.6896551724137931,5.0,0.1724137931034483,13.0,0.4482758620689655
448,cdk,"private IAtom[] pushHydrogensToBack(IAtomContainer mol, Map<IChemObject, Integer> atomToIdx){
    assert atomToIdx.isEmpty();
    IAtom[] atoms = new IAtom[mol.getAtomCount()];
    for (IAtom atom : mol.atoms()) {
        if (atom.getAtomicNumber() == 1)
            continue;
        atoms[atomToIdx.size()] = atom;
        atomToIdx.put(atom, atomToIdx.size() + 1);
    }
    for (IAtom atom : mol.atoms()) {
        if (atom.getAtomicNumber() != 1)
            continue;
        atoms[atomToIdx.size()] = atom;
        atomToIdx.put(atom, atomToIdx.size() + 1);
    }
    return atoms;
}",pushHydrogensToBack,org/openscience/cdk/io/MDLV3000Writer.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV3000Writer.java,"/**
     * CTfile specification is ambiguous as to how parity values should be written
     * for implicit hydrogens. Old applications (Symyx Draw) seem to push any
     * hydrogen to (implied) the last position but newer applications
     * (Accelrys/BioVia Draw) only do so for implicit hydrogens (makes more sense).
     * 
     * To avoid the ambiguity for those who read 0D stereo (bad anyways) we
     * actually do push all hydrogens atoms to the back of the atom list giving
     * them highest value (4) when writing parity values.
     *
     * @param mol       molecule
     * @param atomToIdx mapping that will be filled with the output index
     * @return the output order of atoms
     */",478-508,"('pushHydrogensToBack', {'INSTRUCTION': {'covered': 75, 'missed': 4}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",146.0,16.0,CTfile specification is ambiguous as to how parity values should be written  for implicit hydrogens.,"Since the old CTfile specification is ambiguous in the way in which parity values are written for implicit hydrogens, we actually push all hydrogens atoms at the end of the atom list and assigning them the highest value (4) for the parity values.",The specification for the CTfile is ambiguous.,0.274792717248591,The CTfile specification is ambiguous as to how parity values should be written for implicit hydrogens.,"private IAtom[] pushHydrogensToBack(IAtomContainer mol, Map<IChemObject, Integer> atomToIdx){
        List<IAtom> hydrogens = new ArrayList<>();
        for (IAtom atom : mol.atoms()) {
            if (atom.getImplicitHydrogenCount() > 0) {
                hydrogens.add(atom);
                atom.setImplicitHydrogenCount(0);
            }
        }
        for (IAtom atom : hydrogens) {
            int idx = atomToIdx.get(atom);
            mol.removeAtom(atom);
            mol.addAtom(atom);
            atomToIdx.put(atom, idx);
        }
        return hydrogens.toArray(new IAtom[hydrogens.size()]);      
 }"," private IAtom[] pushHydrogensToBack(IAtomContainer mol, Map<IChemObject, Integer> atomToIdx){
        List<IAtom> hydrogens = new ArrayList<>();
        for (IAtom atom : mol.atoms()) {
            if (atom.getSymbol().equals(""H"")) {
                hydrogens.add(atom);
            }
        }
        for (IAtom atom : hydrogens) {
            mol.removeAtom(atom);
            mol.addAtom(atom);
        }
        for (IAtom atom : hydrogens) {
            atomToIdx.put(atom, mol.getAtomCount());
        }
        return hydrogens.toArray(new IAtom[hydrogens.size()]);      
 }"," private IAtom[] pushHydrogensToBack(IAtomContainer mol, Map<IChemObject, Integer> atomToIdx){
        IAtom[] atoms = new IAtom[mol.getAtomCount()];
        for (IAtom atom : mol.atoms()) {
            atoms[atomToIdx.get(atom)] = atom;
        }
        return atoms;       
 }","private IAtom[] pushHydrogensToBack(IAtomContainer mol, Map<IChemObject, Integer> atomToIdx){
        List<IAtom> hydrogens = new ArrayList<>();
        for (IAtom atom : mol.atoms()) {
            if (atom.getImplicitHydrogenCount() > 0) {
                hydrogens.add(atom);
                atom.setImplicitHydrogenCount(0);
            }
        }
        for (IAtom atom : hydrogens) {
            int idx = findIdx(atomToIdx, atom);
            if (idx < 0)
                throw new IllegalStateException(""Hydrogen not present in the molecule."");
            mol.removeAtom(atom);
            mol.addAtom(atom);
        }
        return hydrogens.toArray(new IAtom[hydrogens.size()]);      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4899435713244086,  0.4629469218064012,  0.4692493402122422,  0.3304881486795636,81.0,0.5510204081632653,81.0,0.5510204081632653,85.0,0.5782312925170068,85.0,0.5782312925170068,31.0,0.23846153846153847,19.0,0.1417910447761194,85.0,0.6538461538461539,35.0,0.7954545454545454,1.0,0.058823529411764705,14.0,0.875
450,jackson-databind,"public static NameTransformer simpleTransformer(final String prefix, final String suffix){
    boolean hasPrefix = (prefix != null) && !prefix.isEmpty();
    boolean hasSuffix = (suffix != null) && !suffix.isEmpty();
    if (hasPrefix) {
        if (hasSuffix) {
            return new NameTransformer() {

                @Override
                public String transform(String name) {
                    return prefix + name + suffix;
                }

                @Override
                public String reverse(String transformed) {
                    if (transformed.startsWith(prefix)) {
                        String str = transformed.substring(prefix.length());
                        if (str.endsWith(suffix)) {
                            return str.substring(0, str.length() - suffix.length());
                        }
                    }
                    return null;
                }

                @Override
                public String toString() {
                    return ""[PreAndSuffixTransformer('"" + prefix + ""','"" + suffix + ""')]"";
                }
            };
        }
        return new NameTransformer() {

            @Override
            public String transform(String name) {
                return prefix + name;
            }

            @Override
            public String reverse(String transformed) {
                if (transformed.startsWith(prefix)) {
                    return transformed.substring(prefix.length());
                }
                return null;
            }

            @Override
            public String toString() {
                return ""[PrefixTransformer('"" + prefix + ""')]"";
            }
        };
    }
    if (hasSuffix) {
        return new NameTransformer() {

            @Override
            public String transform(String name) {
                return name + suffix;
            }

            @Override
            public String reverse(String transformed) {
                if (transformed.endsWith(suffix)) {
                    return transformed.substring(0, transformed.length() - suffix.length());
                }
                return null;
            }

            @Override
            public String toString() {
                return ""[SuffixTransformer('"" + suffix + ""')]"";
            }
        };
    }
    return NOP;
}",simpleTransformer,com/fasterxml/jackson/databind/util/NameTransformer.java,/src/main/java/com/fasterxml/jackson/databind/util/NameTransformer.java,"/**
     * Factory method for constructing a simple transformer based on
     * prefix and/or suffix.
     */",35-93,"('simpleTransformer', {'INSTRUCTION': {'covered': 42, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",346.0,13.0,Factory method for constructing a simple transformer based on  prefix and/or suffix.,The method is used for creating a simple transformer with prefix and/or suffix.,A simple transformer is constructed using the factory method.,0.305550167763403,Factory method to build a simple transformer based on a prefix and/or suffix.," public static NameTransformer simpleTransformer(final String prefix, final String suffix){
        if (prefix == null && suffix == null) {
            return NOP;
        }
        return new SimpleTransformer(prefix, suffix);
    }",Not Valid,Not Valid,Not Valid,NOT PASS,Not Valid,Not Valid,Not Valid,  0.053784605530924845,None,None,None,312.0,0.899135446685879,None,None,None,None,None,None,None,None,None,None,None,None,6.0,0.42857142857142855,3.0,0.21428571428571427,11.0,0.8461538461538461
451,matsim-libs,"public static double convertHHMMInteger(int hhmm){
    int h = hhmm / 100;
    int m = hhmm - (h * 100);
    double seconds = Math.abs(h) * 3600 + m * 60;
    return seconds;
}",convertHHMMInteger,org/matsim/core/utils/misc/Time.java,/matsim/src/main/java/org/matsim/core/utils/misc/Time.java,"/**
	 * Converts a number like 1634 to the time value of 16:34:00.
	 * 
	 * @param hhmm the time-representing number to convert.
	 * @return the time as seconds after midnight.
	 */",227-238,"('convertHHMMInteger', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,12.0,Converts a number like 1634 to the time value of 16:34:00.,"Given a number like 1634, the function converts it into time value, 16:34:00 in this case.",The time value is 16:34:00.,0.174594422286125,Converts a number like 1634 to a time value of 16:34:00.,"public static double convertHHMMInteger(int hhmm){
	 int h = hhmm / 100;
	 int m = hhmm % 100;
	 return h * 3600 + m * 60;
 }","public static double convertHHMMInteger(int hhmm){
		int h = hhmm / 100;
		int m = hhmm % 100;
		return h * 3600 + m * 60;
	}","public static double convertHHMMInteger(int hhmm){
	 int h = hhmm / 100;
	 int m = hhmm % 100;
	 return h * 3600 + m * 60;
 }","public static double convertHHMMInteger(int hhmm){
	 int h = hhmm / 100;
	 int m = hhmm % 100;
	 return h * 3600 + m * 60;
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.541071894177162,  0.541071894177162,  0.541071894177162,  0.541071894177162,16.0,0.3333333333333333,16.0,0.3333333333333333,16.0,0.3333333333333333,16.0,0.3333333333333333,0.0,0.0,0.0,0.0,0.0,0.0,12.0,0.7058823529411765,1.0,0.08333333333333333,8.0,0.6666666666666666
452,cdk,"public static int convertBondOrder(IBond bond){
    int value = 0;
    switch(bond.getOrder()) {
        case QUADRUPLE:
            value = 4;
            break;
        case TRIPLE:
            value = 3;
            break;
        case DOUBLE:
            value = 2;
            break;
        case SINGLE:
            value = 1;
            break;
        default:
            value = 0;
    }
    return value;
}",convertBondOrder,org/openscience/cdk/smsd/filters/ChemicalFilters.java,/legacy/src/main/java/org/openscience/cdk/smsd/filters/ChemicalFilters.java,"/**
     * Get bond order value as {@code int} value.
     *
     * @param  bond The {@link IBond} for which the order is returned.
     * @return      1 for a single bond, 2 for a double bond, 3 for a triple bond, 4 for a quadruple bond,
     *              and 0 for any other bond type.
     */",841-867,"('convertBondOrder', {'INSTRUCTION': {'covered': 18, 'missed': 6}, 'BRANCH': {'covered': 3, 'missed': 2}, 'LINE': {'covered': 8, 'missed': 4}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",70.0,12.0,Get bond order value as {@code int} value.,"Given a bond iBond, it returns the order value of the bond.",Get the bond order value.,0.1891197143153,Get the value of the bond order as the value {@code int}.,"public static int convertBondOrder(IBond bond){
        if (bond.getOrder() == Order.QUADRUPLE) {
            return 4;
        }
        if (bond.getOrder() == Order.TRIPLE) {
            return 3;
        }
        if (bond.getOrder() == Order.DOUBLE) {
            return 2;
        }
        if (bond.getOrder() == Order.SINGLE) {
            return 1;
        }
        return 0;
    }","public static int convertBondOrder(IBond bond){
        int order = 0;
        if (bond.getOrder() == Order.QUADRUPLE) {
            order = 4;
        } else if (bond.getOrder() == Order.TRIPLE) {
            order = 3;
        } else if (bond.getOrder() == Order.DOUBLE) {
            order = 2;
        } else if (bond.getOrder() == Order.SINGLE) {
            order = 1;
        }
        return order;
    }","public static int convertBondOrder(IBond bond){
        if (bond.getOrder() == Order.QUADRUPLE) {
            return 4;
        }
        if (bond.getOrder() == Order.TRIPLE) {
            return 3;
        }
        if (bond.getOrder() == Order.DOUBLE) {
            return 2;
        }
        if (bond.getOrder() == Order.SINGLE) {
            return 1;
        }
        return 0;       
 }","public static int convertBondOrder(IBond bond){
        if (bond.getOrder() == Order.QUADRUPLE) {
            return 4;
        }
        if (bond.getOrder() == Order.TRIPLE) {
            return 3;
        }
        if (bond.getOrder() == Order.DOUBLE) {
            return 2;
        }
        if (bond.getOrder() == Order.SINGLE) {
            return 1;
        }
        return 0;
    }",PASS,PASS,PASS,PASS,  0.24754984217526244,  0.5039568102185712,  0.24754984217526244,  0.24754984217526244,57.0,0.6951219512195121,56.0,0.5957446808510638,57.0,0.6951219512195121,57.0,0.6951219512195121,17.0,0.18085106382978725,0.0,0.0,0.0,0.0,10.0,0.7692307692307693,9.0,0.6923076923076923,5.0,0.5555555555555556
453,anserini,"public SortedMap<Integer, Map<String, String>> read(BufferedReader bRdr) throws IOException{
    SortedMap<Integer, Map<String, String>> map = new TreeMap<>();
    Map<String, String> fields = new HashMap<>();
    String number = """";
    Matcher m;
    String line;
    while ((line = bRdr.readLine()) != null) {
        line = line.trim();
        if (line.startsWith(""<num>"") && line.endsWith(""</num>"")) {
            m = NUM_PATTERN.matcher(line);
            if (!m.find()) {
                throw new IOException(""Error parsing "" + line);
            }
            number = m.group(1);
        }
        if (line.startsWith(""<query>"") && line.endsWith(""</query>"") || line.startsWith(""<title>"") && line.endsWith(""</title>"")) {
            m = TITLE_PATTERN.matcher(line);
            if (!m.find()) {
                m = TITLE_PATTERN2.matcher(line);
                if (!m.find()) {
                    throw new IOException(""Error parsing "" + line);
                }
            }
            fields.put(""title"", m.group(1));
        }
        if (line.startsWith(""<querytweettime>"") && line.endsWith(""</querytweettime>"")) {
            m = TWEETTIME_PATTERN.matcher(line);
            if (!m.find()) {
                throw new IOException(""Error parsing "" + line);
            }
            fields.put(""time"", m.group(1));
        }
        if (line.startsWith(""</top>"")) {
            map.put(Integer.valueOf(number), fields);
            fields = new HashMap<>();
        }
    }
    return map;
}",read,io/anserini/search/topicreader/MicroblogTopicReader.java,/src/main/java/io/anserini/search/topicreader/MicroblogTopicReader.java,"/**
   * Read topics of TREC Microblog Tracks from 2011 to 2014 including:
   * topics.microblog2011.txt
   * topics.microblog2012.txt
   * topics.microblog2013.txt
   * topics.microblog2014.txt
   * @return SortedMap where keys are query/topic IDs and values are title portions of the topics
   * @throws IOException any io exception
   */",47-98,"('read', {'INSTRUCTION': {'covered': 113, 'missed': 18}, 'BRANCH': {'covered': 21, 'missed': 7}, 'LINE': {'covered': 24, 'missed': 3}, 'COMPLEXITY': {'covered': 8, 'missed': 7}, 'METHOD': {'covered': 1, 'missed': 0}})",340.0,14.0,Read topics of TREC Microblog Tracks from 2011 to 2014 including:  topics.,Read from TREC Microblog Tracks published between 2011 and 2014 different topics and return a SortedMap where the keys are query/topic IDs and the values are the title.,The topics of the TREC Microblog Tracks from 2011 to 2014 are listed below.,0.681436977122317,"Read the topics of TREC Microblog Tracks from 2011 to 2014, including: the topics.","public SortedMap<Integer, Map<String, String>> read(BufferedReader bRdr) throws IOException{
    SortedMap<Integer, Map<String, String>> topics = new TreeMap<>();
    String line;
    while ((line = bRdr.readLine()) != null) {
      Matcher topMatcher = TOP_PATTERN.matcher(line);
      if (topMatcher.find()) {
         Map<String, String> topic = new HashMap<>();
         Matcher numMatcher = NUM_PATTERN.matcher(line);
         if (numMatcher.find()) {
            topic.put(""num"", numMatcher.group(1));
         }
         Matcher titleMatcher = TITLE_PATTERN.matcher(line);
         if (titleMatcher.find()) {
            topic.put(""title"", titleMatcher.group(1));
         } else {
            titleMatcher = TITLE_PATTERN2.matcher(line);
            if (titleMatcher.find()) {
              topic.put(""title"", titleMatcher.group(1));
            }
         }
         Matcher tweetTimeMatcher = TWEETTIME_PATTERN.matcher(line);
         if (tweetTimeMatcher.find()) {
            topic.put(""tweetTime"", tweetTimeMatcher.group(1));
         }
         topics.put(Integer.parseInt(topic.get(""num"")), topic);
      }
    }
    return topics;
     }","public SortedMap<Integer, Map<String, String>> read(BufferedReader bRdr) throws IOException{
    SortedMap<Integer, Map<String, String>> topics = new TreeMap<>();
    String line;
    while ((line = bRdr.readLine()) != null) {
      Matcher topMatcher = TOP_PATTERN.matcher(line);
      if (topMatcher.find()) {
         String top = topMatcher.group(1);
         Matcher numMatcher = NUM_PATTERN.matcher(top);
         if (numMatcher.find()) {
            String num = numMatcher.group(1);
            Map<String, String> topic = new HashMap<>();
            Matcher titleMatcher = TITLE_PATTERN.matcher(top);
            if (titleMatcher.find()) {
              String title = titleMatcher.group(1);
              topic.put(""title"", title);
            } else {
              titleMatcher = TITLE_PATTERN2.matcher(top);
              if (titleMatcher.find()) {
                 String title = titleMatcher.group(1);
                 topic.put(""title"", title);
              }
            }
            Matcher tweetTimeMatcher = TWEETTIME_PATTERN.matcher(top);
            if (tweetTimeMatcher.find()) {
              String tweetTime = tweetTimeMatcher.group(1);
              topic.put(""tweetTime"", tweetTime);
            }
            topics.put(Integer.parseInt(num), topic);
         }
      }
    }
    return topics;
     }","public SortedMap<Integer, Map<String, String>> read(BufferedReader bRdr) throws IOException{
    SortedMap<Integer, Map<String, String>> topics = new TreeMap<>();
    String line;
    while ((line = bRdr.readLine()) != null) {
      Matcher topMatcher = TOP_PATTERN.matcher(line);
      if (topMatcher.find()) {
         Map<String, String> topic = new HashMap<>();
         Matcher numMatcher = NUM_PATTERN.matcher(line);
         if (numMatcher.find()) {
            topic.put(""num"", numMatcher.group(1));
         }
         Matcher titleMatcher = TITLE_PATTERN.matcher(line);
         if (titleMatcher.find()) {
            topic.put(""title"", titleMatcher.group(1));
         } else {
            titleMatcher = TITLE_PATTERN2.matcher(line);
            if (titleMatcher.find()) {
              topic.put(""title"", titleMatcher.group(1));
            }
         }
         Matcher tweettimeMatcher = TWEETTIME_PATTERN.matcher(line);
         if (tweettimeMatcher.find()) {
            topic.put(""tweettime"", tweettimeMatcher.group(1));
         }
         topics.put(Integer.parseInt(topic.get(""num"")), topic);
      }
    }
    return topics;
     }","public SortedMap<Integer, Map<String, String>> read(BufferedReader bRdr) throws IOException{
    SortedMap<Integer, Map<String, String>> topics = new TreeMap<>();
    String line;
    while ((line = bRdr.readLine()) != null) {
      Matcher topMatcher = TOP_PATTERN.matcher(line);
      if (topMatcher.find()) {
         Map<String, String> topic = new HashMap<>();
         Matcher numMatcher = NUM_PATTERN.matcher(line);
         if (numMatcher.find()) {
            topic.put(""num"", numMatcher.group(1));
         }
         Matcher titleMatcher = TITLE_PATTERN.matcher(line);
         if (titleMatcher.find()) {
            topic.put(""title"", titleMatcher.group(1));
         } else {
            titleMatcher = TITLE_PATTERN2.matcher(line);
            if (titleMatcher.find()) {
              topic.put(""title"", titleMatcher.group(1));
            }
         }
         Matcher tweettimeMatcher = TWEETTIME_PATTERN.matcher(line);
         if (tweettimeMatcher.find()) {
            topic.put(""tweettime"", tweettimeMatcher.group(1));
         }
         topics.put(Integer.parseInt(topic.get(""num"")), topic);
      }
    }
    return topics;
     }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4655468428508852,  0.4254057494430337,  0.4655468428508852,  0.4655468428508852,175.0,0.5131964809384164,182.0,0.533724340175953,175.0,0.5131964809384164,175.0,0.5131964809384164,82.0,0.3014705882352941,4.0,0.015625,4.0,0.015625,23.0,0.7931034482758621,3.0,0.2,5.0,0.3333333333333333
454,matsim-libs,"public static void copyStream(final InputStream fromStream, final OutputStream toStream) throws UncheckedIOException{
    try {
        byte[] buffer = new byte[4096];
        int bytesRead;
        while ((bytesRead = fromStream.read(buffer)) != -1) {
            toStream.write(buffer, 0, bytesRead);
        }
    } catch (IOException e) {
        throw new UncheckedIOException(e);
    }
}",copyStream,org/matsim/core/utils/io/IOUtils.java,/matsim/src/main/java/org/matsim/core/utils/io/IOUtils.java,"/**
	 * Copies the content from one stream to another stream.
	 *
	 * @param fromStream The stream containing the data to be copied
	 * @param toStream   The stream the data should be written to
	 * 
	 * @throws UncheckedIOException
	 */",378-398,"('copyStream', {'INSTRUCTION': {'covered': 18, 'missed': 6}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,10.0,Copies the content from one stream to another stream.,"Given a stream, the method copies the content to another stream.",The content from one stream to another is copied.,0.462459323366171,Copies content from one stream to another.,"public static void copyStream(final InputStream fromStream, final OutputStream toStream) throws UncheckedIOException{
	 		try {
 			final byte[] buffer = new byte[1024];
 			int read;
 			while ((read = fromStream.read(buffer)) != -1) {
 				toStream.write(buffer, 0, read);
 			}
 		} catch (IOException e) {
 			throw new UncheckedIOException(e);
 		}
 	}","public static void copyStream(final InputStream fromStream, final OutputStream toStream) throws UncheckedIOException{
	 		try {
 			final byte[] buffer = new byte[1024];
 			int read;
 			while ((read = fromStream.read(buffer)) != -1) {
 				toStream.write(buffer, 0, read);
 			}
 		} catch (IOException e) {
 			throw new UncheckedIOException(e);
 		}
 	}","public static void copyStream(final InputStream fromStream, final OutputStream toStream) throws UncheckedIOException{
	 		try {
 			byte[] buffer = new byte[BUFFER_SIZE];
 			int bytesRead;
 			while ((bytesRead = fromStream.read(buffer)) != -1) {
 				toStream.write(buffer, 0, bytesRead);
 			}
 		} catch (IOException e) {
 			throw new UncheckedIOException(e);
 		}
 	}","public static void copyStream(final InputStream fromStream, final OutputStream toStream) throws UncheckedIOException{
	 		try {
 			byte[] buffer = new byte[BUFFER_SIZE];
 			int bytesRead;
 			while ((bytesRead = fromStream.read(buffer)) != -1) {
 				toStream.write(buffer, 0, bytesRead);
 			}
 		} catch (IOException e) {
 			throw new UncheckedIOException(e);
 		}
 	}",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8440970367965341,  0.8440970367965341,  0.9371055156445375,  0.9371055156445375,5.0,0.06329113924050633,5.0,0.06329113924050633,1.0,0.01282051282051282,1.0,0.01282051282051282,0.0,0.0,5.0,0.06329113924050633,5.0,0.06329113924050633,7.0,0.5833333333333334,3.0,0.3,4.0,0.4
455,logstash-logback-encoder,"private void appendPlaceHolder(StringBuilder builder, int indent, int consecutiveExcluded, String message){
    indent(builder, indent);
    builder.append(ELLIPSIS).append("" "").append(consecutiveExcluded).append("" "").append(message).append(CoreConstants.LINE_SEPARATOR);
}",appendPlaceHolder,net/logstash/logback/stacktrace/ShortenedThrowableConverter.java,/src/main/java/net/logstash/logback/stacktrace/ShortenedThrowableConverter.java,"/**
     * Appends a placeholder indicating that some frames were not written.
     */",460-471,"('appendPlaceHolder', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",59.0,11.0,Appends a placeholder indicating that some frames were not written.,"For indicating that some frames were not written in the StringBuilder, append a placeholder.",The appended information indicates that some frames were not written.,0.478800967442818,Adds a placeholder indicating that some images have not been written.," private void appendPlaceHolder(StringBuilder builder, int indent, int consecutiveExcluded, String message){
        if (builder.length() > maxLength) {
            return;
        }
        builder.append(CoreConstants.LINE_SEPARATOR);
        builder.append(indent(indent));
        builder.append(CoreConstants.PLACEHOLDER_PREFIX);
        builder.append(consecutiveExcluded);
        builder.append(CoreConstants.PLACEHOLDER_SUFFIX);
        builder.append(message);
    }"," private void appendPlaceHolder(StringBuilder builder, int indent, int consecutiveExcluded, String message){
        if (builder.length() > maxLength) {
            return;
        }
        builder.append(CoreConstants.LINE_SEPARATOR);
        builder.append(CoreConstants.INDENT_STRING.repeat(indent));
        builder.append(CoreConstants.PLACEHOLDER_PREFIX);
        builder.append(consecutiveExcluded);
        builder.append(CoreConstants.PLACEHOLDER_SUFFIX);
        builder.append(message);
    }",Empty Method," private void appendPlaceHolder(StringBuilder builder, int indent, int consecutiveExcluded, String message){
        if (builder.length() > maxLength) {
            return;
        }
        builder.append(CoreConstants.LINE_SEPARATOR);
        builder.append(indent(indent));
        builder.append(CoreConstants.PLACEHOLDER_PREFIX);
        builder.append(consecutiveExcluded);
        builder.append(CoreConstants.PLACEHOLDER_SUFFIX);
        builder.append(message);
    }",NOT PASS,NOT PASS,NOT PASS,Empty Method,  0.6706135105618793,  0.6468537570286961,  0.6706135105618793,None,37.0,0.44047619047619047,39.0,0.4431818181818182,37.0,0.44047619047619047,None,None,5.0,0.056818181818181816,0.0,0.0,None,None,10.0,0.6666666666666666,4.0,0.3333333333333333,4.0,0.36363636363636365
456,matsim-libs,"public void addCoreModules(){
    this.global = new GlobalConfigGroup();
    this.modules.put(GlobalConfigGroup.GROUP_NAME, this.global);
    this.controler = new ControlerConfigGroup();
    this.modules.put(ControlerConfigGroup.GROUP_NAME, this.controler);
    this.qSimConfigGroup = new QSimConfigGroup();
    this.modules.put(QSimConfigGroup.GROUP_NAME, this.qSimConfigGroup);
    this.counts = new CountsConfigGroup();
    this.modules.put(CountsConfigGroup.GROUP_NAME, this.counts);
    this.charyparNagelScoring = new PlanCalcScoreConfigGroup();
    this.modules.put(PlanCalcScoreConfigGroup.GROUP_NAME, this.charyparNagelScoring);
    this.network = new NetworkConfigGroup();
    this.modules.put(NetworkConfigGroup.GROUP_NAME, this.network);
    this.plans = new PlansConfigGroup();
    this.modules.put(PlansConfigGroup.GROUP_NAME, this.plans);
    this.households = new HouseholdsConfigGroup();
    this.modules.put(HouseholdsConfigGroup.GROUP_NAME, this.households);
    this.parallelEventHandling = new ParallelEventHandlingConfigGroup();
    this.modules.put(ParallelEventHandlingConfigGroup.GROUP_NAME, this.parallelEventHandling);
    this.facilities = new FacilitiesConfigGroup();
    this.modules.put(FacilitiesConfigGroup.GROUP_NAME, this.facilities);
    this.strategy = new StrategyConfigGroup();
    this.modules.put(StrategyConfigGroup.GROUP_NAME, this.strategy);
    this.travelTimeCalculatorConfigGroup = new TravelTimeCalculatorConfigGroup();
    this.modules.put(TravelTimeCalculatorConfigGroup.GROUPNAME, this.travelTimeCalculatorConfigGroup);
    this.scenarioConfigGroup = new ScenarioConfigGroup();
    this.modules.put(ScenarioConfigGroup.GROUP_NAME, this.scenarioConfigGroup);
    this.plansCalcRoute = new PlansCalcRouteConfigGroup();
    this.modules.put(PlansCalcRouteConfigGroup.GROUP_NAME, this.plansCalcRoute);
    this.timeAllocationMutator = new TimeAllocationMutatorConfigGroup();
    this.modules.put(TimeAllocationMutatorConfigGroup.GROUP_NAME, this.timeAllocationMutator);
    this.vspExperimentalGroup = new VspExperimentalConfigGroup();
    this.modules.put(VspExperimentalConfigGroup.GROUP_NAME, this.vspExperimentalGroup);
    this.ptCounts = new PtCountsConfigGroup();
    this.modules.put(PtCountsConfigGroup.GROUP_NAME, this.ptCounts);
    this.transit = new TransitConfigGroup();
    this.modules.put(TransitConfigGroup.GROUP_NAME, this.transit);
    this.linkStats = new LinkStatsConfigGroup();
    this.modules.put(LinkStatsConfigGroup.GROUP_NAME, this.linkStats);
    this.transitRouter = new TransitRouterConfigGroup();
    this.modules.put(TransitRouterConfigGroup.GROUP_NAME, this.transitRouter);
    this.subtourModeChoice = new SubtourModeChoiceConfigGroup();
    this.modules.put(SubtourModeChoiceConfigGroup.GROUP_NAME, this.subtourModeChoice);
    this.vehicles = new VehiclesConfigGroup();
    this.modules.put(VehiclesConfigGroup.GROUP_NAME, this.vehicles);
    this.changeMode = new ChangeModeConfigGroup();
    this.modules.put(ChangeModeConfigGroup.CONFIG_MODULE, this.changeMode);
    this.modules.put(ChangeLegModeConfigGroup.CONFIG_MODULE, new ChangeLegModeConfigGroup());
    // only to provide error messages. kai, may'16
    this.jdeqSim = new JDEQSimConfigGroup();
    this.modules.put(JDEQSimConfigGroup.NAME, this.jdeqSim);
    this.hermes = new HermesConfigGroup();
    this.modules.put(HermesConfigGroup.NAME, this.hermes);
    this.addConfigConsistencyChecker(new VspConfigConsistencyCheckerImpl());
    this.addConfigConsistencyChecker(new UnmaterializedConfigGroupChecker());
    this.addConfigConsistencyChecker(new BeanValidationConfigConsistencyChecker());
}",addCoreModules,org/matsim/core/config/Config.java,/matsim/src/main/java/org/matsim/core/config/Config.java,"/**
	 * Adds all the commonly used config-groups, also known as ""core modules"",
	 * to this config-instance. This should be called before reading any
	 * configuration from file.
	 */",112-200,"('addCoreModules', {'INSTRUCTION': {'covered': 324, 'missed': 0}, 'LINE': {'covered': 55, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",653.0,19.0,"Adds all the commonly used config-groups, also known as ""core modules"",  to this config-instance.","Given a config-instance, add the ""core modules"", the common used config-groups","The config-group that is added to this config-instance is also known as a ""core modules"" group.",2.64570414637703,"Adds all commonly used configuration groups, also known as ""core modules,"" to this configuration instance."," public void addCoreModules(){
	 addModule(new CharyparNagelScoringConfigGroup());
	 addModule(new ControlerConfigGroup());
	 addModule(new CountsConfigGroup());
	 addModule(new FacilitiesConfigGroup());
	 addModule(new GlobalConfigGroup());
	 addModule(new HouseholdsConfigGroup());
	 addModule(new NetworkConfigGroup());
	 addModule(new ParallelEventHandlingConfigGroup());
	 addModule(new PlansCalcRouteConfigGroup());
	 addModule(new PlansConfigGroup());
	 addModule(new QSimConfigGroup());
	 addModule(new ScenarioConfigGroup());
	 addModule(new StrategyConfigGroup());
	 addModule(new TransitConfigGroup());
	 addModule(new TransitRouterConfigGroup());
	 addModule(new LinkStatsConfigGroup());
	 addModule(new VspExperimentalConfigGroup());
	 addModule(new TimeAllocationMutatorConfigGroup());
	 addModule(new SubtourModeChoiceConfigGroup());
	 addModule(new TravelTimeCalculatorConfigGroup());
	 addModule(new PtCountsConfigGroup());
	 addModule(new VehiclesConfigGroup());
	 addModule(new ChangeModeConfigGroup());
	 addModule(new JDEQSimConfigGroup());
	 addModule(new HermesConfigGroup());
 }"," public void addCoreModules(){
	 this.addModule(new PlanCalcScoreConfigGroup());
	 this.addModule(new ControlerConfigGroup());
	 this.addModule(new CountsConfigGroup());
	 this.addModule(new FacilitiesConfigGroup());
	 this.addModule(new GlobalConfigGroup());
	 this.addModule(new HouseholdsConfigGroup());
	 this.addModule(new NetworkConfigGroup());
	 this.addModule(new ParallelEventHandlingConfigGroup());
	 this.addModule(new PlansCalcRouteConfigGroup());
	 this.addModule(new PlansConfigGroup());
	 this.addModule(new QSimConfigGroup());
	 this.addModule(new ScenarioConfigGroup());
	 this.addModule(new StrategyConfigGroup());
	 this.addModule(new TransitConfigGroup());
	 this.addModule(new TransitRouterConfigGroup());
	 this.addModule(new LinkStatsConfigGroup());
	 this.addModule(new VspExperimentalConfigGroup());
	 this.addModule(new TimeAllocationMutatorConfigGroup());
	 this.addModule(new SubtourModeChoiceConfigGroup());
	 this.addModule(new TravelTimeCalculatorConfigGroup());
	 this.addModule(new PtCountsConfigGroup());
	 this.addModule(new VehiclesConfigGroup());
	 this.addModule(new ChangeModeConfigGroup());
	 this.addModule(new JDEQSimConfigGroup());
	 this.addModule(new HermesConfigGroup());
 }"," public void addCoreModules(){
	 	this.addModule(new PlanCalcScoreConfigGroup());
 	this.addModule(new ControlerConfigGroup());
 	this.addModule(new CountsConfigGroup());
 	this.addModule(new FacilitiesConfigGroup());
 	this.addModule(new GlobalConfigGroup());
 	this.addModule(new HouseholdsConfigGroup());
 	this.addModule(new NetworkConfigGroup());
 	this.addModule(new ParallelEventHandlingConfigGroup());
 	this.addModule(new PlansCalcRouteConfigGroup());
 	this.addModule(new PlansConfigGroup());
 	this.addModule(new QSimConfigGroup());
 	this.addModule(new ScenarioConfigGroup());
 	this.addModule(new StrategyConfigGroup());
 	this.addModule(new TransitConfigGroup());
 	this.addModule(new TransitRouterConfigGroup());
 	this.addModule(new LinkStatsConfigGroup());
 	this.addModule(new VspExperimentalConfigGroup());
 	this.addModule(new TimeAllocationMutatorConfigGroup());
 	this.addModule(new SubtourModeChoiceConfigGroup());
 	this.addModule(new TravelTimeCalculatorConfigGroup());
 	this.addModule(new PtCountsConfigGroup());
 	this.addModule(new VehiclesConfigGroup());
 	this.addModule(new ChangeModeConfigGroup());
 	this.addModule(new JDEQSimConfigGroup());
	 this.addModule(new HermesConfigGroup());
 }"," public void addCoreModules(){
	 	addModule(new CountsConfigGroup());
 	addModule(new FacilitiesConfigGroup());
 	addModule(new GlobalConfigGroup());
 	addModule(new HouseholdsConfigGroup());
 	addModule(new NetworkConfigGroup());
 	addModule(new PlansCalcRouteConfigGroup());
 	addModule(new PlansConfigGroup());
 	addModule(new QSimConfigGroup());
 	addModule(new ScenarioConfigGroup());
 	addModule(new StrategyConfigGroup());
 	addModule(new TransitConfigGroup());
 	addModule(new TransitRouterConfigGroup());
 	addModule(new LinkStatsConfigGroup());
 	addModule(new VspExperimentalConfigGroup());
 	addModule(new TimeAllocationMutatorConfigGroup());
 	addModule(new SubtourModeChoiceConfigGroup());
 	addModule(new TravelTimeCalculatorConfigGroup());
 	addModule(new PtCountsConfigGroup());
 	addModule(new VehiclesConfigGroup());
 	addModule(new ChangeModeConfigGroup());
 	addModule(new JDEQSimConfigGroup());
	 addModule(new HermesConfigGroup());
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.0970422121638871,  0.13805242031896925,  0.09107381556449473,  0.13805242031896925,508.0,0.7767584097859327,458.0,0.7003058103975535,522.0,0.7981651376146789,458.0,0.7003058103975535,51.0,0.19767441860465115,24.0,0.11538461538461539,51.0,0.19767441860465115,13.0,0.8666666666666667,6.0,0.375,14.0,0.8235294117647058
457,cdk,"private static GeometryEncoder encoder(IDoubleBondStereochemistry dbs, Map<IAtom, Integer> atomToIndex, int[][] graph){
    IBond db = dbs.getStereoBond();
    int u = atomToIndex.get(db.getBegin());
    int v = atomToIndex.get(db.getEnd());
    IBond[] bs = dbs.getBonds();
    int[] us = new int[2];
    int[] vs = new int[2];
    us[0] = atomToIndex.get(bs[0].getOther(db.getBegin()));
    us[1] = graph[u].length == 2 ? u : findOther(graph[u], v, us[0]);
    vs[0] = atomToIndex.get(bs[1].getOther(db.getEnd()));
    vs[1] = graph[v].length == 2 ? v : findOther(graph[v], u, vs[0]);
    int parity = dbs.getStereo() == OPPOSITE ? +1 : -1;
    GeometricParity geomParity = GeometricParity.valueOf(parity);
    PermutationParity permParity = new CombinedPermutationParity(us[1] == u ? BasicPermutationParity.IDENTITY : new BasicPermutationParity(us), vs[1] == v ? BasicPermutationParity.IDENTITY : new BasicPermutationParity(vs));
    return new GeometryEncoder(new int[] { u, v }, permParity, geomParity);
}",encoder,org/openscience/cdk/hash/stereo/DoubleBondElementEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/DoubleBondElementEncoderFactory.java,"/**
     * Create an encoder for the {@link IDoubleBondStereochemistry} element.
     *
     * @param dbs          stereo element from an atom container
     * @param atomToIndex  map of atoms to indices
     * @param graph        adjacency list of connected vertices
     * @return a new geometry encoder
     */",74-117,"('encoder', {'INSTRUCTION': {'covered': 143, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",292.0,12.0,Create an encoder for the {@link IDoubleBondStereochemistry} element.,"Given the IDoubleBondStereochemistry, a stereo element from an atom container, create an encoder for it.",An Encoder is needed for the IDoubleBondStereochemistry element.,0.632106831071692,Create an encoder for the {@link IDoubleBondStereochemistry} element.,"private static GeometryEncoder encoder(IDoubleBondStereochemistry dbs, Map<IAtom, Integer> atomToIndex, int[][] graph){
     
      // the atom indices for the double bond
      int a1 = atomToIndex.get(dbs.getFirstAtom());
      int a2 = atomToIndex.get(dbs.getSecondAtom());
      int a3 = atomToIndex.get(dbs.getThirdAtom());
     
      // the bond indices for the double bond
      int b1 = graph[a1][a2];
      int b2 = graph[a2][a3];
      int b3 = graph[a3][a1];
     
      // the bond indices for the double bond
      int b4 = graph[a1][a3];
      int b5 = graph[a2][a1];
      int b6 = graph[a3][a2];
     
      // the bond indices for the double bond
      int b7 = graph[a1][a2];
      int b8 = graph[a2][a3];
      int b9 = graph[a3][a1];
     
      // the bond indices for the double bond
      int b10 = graph[a1][a3];
      int b11 = graph[a2][a1];
      int b12 = graph[a3][a2];
     
      // the bond indices for the double bond
      int b13 = graph[a1][a2];
      int b14 = graph[a2][a3];
      int b15 = graph[a3][a1];
     
      // the bond indices for the double bond
      int b16 = graph[a1][a3];
      int b17 = graph[a2][a1];
      int b18 = graph[a3][a2];
     
      // the bond indices for the double bond
      int b19 = graph[a1][a2];
      int b20 = graph[a2][a3];
      int b21 = graph[a3][a1];
     
      // the bond indices for the double bond
      int b22 = graph[a1][a3];
      int b23 = graph[a2][a1];
      int b24 = graph[a3            
 }","private static GeometryEncoder encoder(IDoubleBondStereochemistry dbs, Map<IAtom, Integer> atomToIndex, int[][] graph){
        IAtom a1 = dbs.getFirstAtom();
        IAtom a2 = dbs.getSecondAtom();
        IAtom a3 = dbs.getThirdAtom();
        IAtom a4 = dbs.getFourthAtom();
    
        int i1 = atomToIndex.get(a1);
        int i2 = atomToIndex.get(a2);
        int i3 = atomToIndex.get(a3);
        int i4 = atomToIndex.get(a4);
    
        int[] bonds = new int[4];
        bonds[0] = graph[i1][i2];
        bonds[1] = graph[i1][i3];
        bonds[2] = graph[i1][i4];
        bonds[3] = graph[i2][i3];
    
        return new GeometryEncoder(bonds);
    }","private static GeometryEncoder encoder(IDoubleBondStereochemistry dbs, Map<IAtom, Integer> atomToIndex, int[][] graph){
     
      // the atom indices of the double bond
      int a1 = atomToIndex.get(dbs.getFirstAtom());
      int a2 = atomToIndex.get(dbs.getSecondAtom());
     
      // the bond indices of the double bond
      int b1 = graph[a1][a2];
      int b2 = graph[a2][a1];
     
      // the bond indices of the bonds around the double bond
      int b3 = graph[a1][dbs.getConnectedAtom(dbs.getFirstAtom()).getIndex()];
      int b4 = graph[a2][dbs.getConnectedAtom(dbs.getSecondAtom()).getIndex()];
     
      // the bond indices of the bonds around the double bond's neighbours
      int b5 = graph[a1][dbs.getConnectedAtom(dbs.getFirstAtom()).getIndex()];
      int b6 = graph[a2][dbs.getConnectedAtom(dbs.getSecondAtom()).getIndex()];
     
      // the bond indices of the bonds around the double bond's neighbours
      int b7 = graph[a1][dbs.getConnectedAtom(dbs.getFirstAtom()).getIndex()];
      int b8 = graph[a2][dbs.getConnectedAtom(dbs.getSecondAtom()).getIndex()];
     
      // the bond indices of the bonds around the double bond's neighbours
      int b9 = graph[a1][dbs.getConnectedAtom(dbs.getFirstAtom()).getIndex()];
      int b10 = graph[a2][dbs.getConnectedAtom(dbs.getSecondAtom()).getIndex()];
     
      // the bond indices of the bonds around the double bond's neighbours
      int b11 = graph[a1][dbs.getConnectedAtom(dbs.getFirstAtom()).getIndex()];
      int b12 = graph[a2][dbs.getConnectedAtom(dbs.getSecondAtom()          
 }","private static GeometryEncoder encoder(IDoubleBondStereochemistry dbs, Map<IAtom, Integer> atomToIndex, int[][] graph){
     
      // the atom indices of the double bond
      int a1 = atomToIndex.get(dbs.getFirstAtom());
      int a2 = atomToIndex.get(dbs.getSecondAtom());
     
      // the atom indices of the atoms bonded to the double bond
      int a3 = atomToIndex.get(dbs.getAtom(0));
      int a4 = atomToIndex.get(dbs.getAtom(1));
     
      // the bond indices of the bonds connected to the double bond
      int b1 = graph[a1][a3];
      int b2 = graph[a1][a4];
      int b3 = graph[a2][a3];
      int b4 = graph[a2][a4];
     
      // the bond indices of the bonds connected to the double bond
      int b5 = graph[a3][a1];
      int b6 = graph[a3][a2];
      int b7 = graph[a4][a1];
      int b8 = graph[a4][a2];
     
      // the bond indices of the bonds connected to the double bond
      int b9 = graph[a1][a2];
      int b10 = graph[a3][a4];
     
      // the bond indices of the bonds connected to the double bond
      int b11 = graph[a2][a3];
      int b12 = graph[a2][a4];
     
      // the bond indices of the bonds connected to the double bond
      int b13 = graph[a1][a4];
      int b14 = graph[a2][a3];
     
      // the bond indices of the bonds connected to the double bond
      int b15 = graph[a1][a3];
      int b16 = graph[a1][a4];
     
      // the bond indices of the bonds connected to the double bond
      int b17 = graph[a2][a3];
      int b18 = graph[a2][a4];
     
      // the bond indices of the bonds connected to the double bond
      int b19 = graph[a1            
 }",Syntax Error,NOT PASS,Syntax Error,Syntax Error,None,  0.32991718950365617,None,None,None,None,194.0,0.6621160409556314,206.0,0.7030716723549488,221.0,0.7152103559870551,215.0,0.6574923547400612,94.0,0.2874617737003058,180.0,0.5504587155963303,14.0,0.875,0.0,0.0,6.0,0.6666666666666666
458,cdk,"static double adjacentLength(Vector2d hypotenuse, Vector2d adjacent, double oppositeLength){
    return Math.tan(hypotenuse.angle(adjacent)) * oppositeLength;
}",adjacentLength,org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,"/**
     * Given vectors for the hypotenuse and adjacent side of a right angled
     * triangle and the length of the opposite side, determine how long the
     * adjacent side size.
     *
     * @param hypotenuse vector for the hypotenuse
     * @param adjacent vector for the adjacent side
     * @param oppositeLength length of the opposite side of a triangle
     * @return length of the adjacent side
     */",210-222,"('adjacentLength', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,29.0,"Given vectors for the hypotenuse and adjacent side of a right angled  triangle and the length of the opposite side, determine how long the  adjacent side size.","Determine the length of the adjacent side of the provided vector for the hypotenus, the adjacent side of a triangle with a right angle, and the opposite side.",The length of the opposite side and the hypotenuse of the right triangle are given in the same way.,0.415205883251729,"Given the vectors of the hypotenuse and the adjacent side of a right-angled triangle and the length of the opposite side, determine the length of the size on the adjacent side.","static double adjacentLength(Vector2d hypotenuse, Vector2d adjacent, double oppositeLength){
        double adjacentLength = hypotenuse.dot(adjacent) / hypotenuse.length();
        return adjacentLength;
    }","static double adjacentLength(Vector2d hypotenuse, Vector2d adjacent, double oppositeLength){
        return Math.sqrt(Math.pow(hypotenuse.x, 2) + Math.pow(hypotenuse.y, 2)) - Math.sqrt(Math.pow(adjacent.x, 2) + Math.pow(adjacent.y, 2));
    }","static double adjacentLength(Vector2d hypotenuse, Vector2d adjacent, double oppositeLength){
        return Math.sqrt(hypotenuse.lengthSquared() - oppositeLength * oppositeLength);
    }","static double adjacentLength(Vector2d hypotenuse, Vector2d adjacent, double oppositeLength){
        double adjacentLength = hypotenuse.dot(adjacent) / oppositeLength;
        return adjacentLength;      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6360220683118415,  0.6234710950137285,  0.6940246774669011,  0.6289884101489956,13.0,0.37142857142857144,45.0,0.6338028169014085,11.0,0.3548387096774194,6.0,0.1875,47.0,0.6619718309859155,5.0,0.14285714285714285,14.0,0.4,24.0,0.8275862068965517,13.0,0.40625,20.0,0.7142857142857143
459,twilio-java,"public static void validateSslCertificate(){
    final NetworkHttpClient client = new NetworkHttpClient();
    final Request request = new Request(HttpMethod.GET, ""https://api.twilio.com:8443"");
    try {
        final Response response = client.makeRequest(request);
        if (!TwilioRestClient.SUCCESS.test(response.getStatusCode())) {
            throw new CertificateValidationException(""Unexpected response from certificate endpoint"", request, response);
        }
    } catch (final ApiException e) {
        throw new CertificateValidationException(""Could not get response from certificate endpoint"", request);
    }
}",validateSslCertificate,com/twilio/Twilio.java,/src/main/java/com/twilio/Twilio.java,"/**
     * Validate that we can connect to the new SSL certificate posted on api.twilio.com.
     *
     * @throws CertificateValidationException if the connection fails
     */",229-249,"('validateSslCertificate', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,14.0,Validate that we can connect to the new SSL certificate posted on api.,Check if we can use the SSL certificate from api.twiliio.com for the connection.,We can connect to the new certificate if we verify that we can.,0.413126887869741,Verify that we can connect to the new SSL certificate published on the API.," public static void validateSslCertificate(){
        try {
            HttpsURLConnection.setDefaultSSLSocketFactory(new TLSSocketFactory());
            HttpsURLConnection.setDefaultHostnameVerifier(new TLSSocketFactory.AllHostsValid());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }","public static void validateSslCertificate(){
        try {
            HttpsURLConnection.setDefaultSSLSocketFactory(new SSLConnectionSocketFactory(
                SSLContext.getDefault(),
                new String[]{""TLSv1.2""},
                null,
                SSLConnectionSocketFactory.getDefaultHostnameVerifier()
            ));
        } catch (NoSuchAlgorithmException | KeyManagementException e) {
            throw new RuntimeException(e);
        }
    }",Not Valid,Not Valid,NOT PASS,NOT PASS,Not Valid,Not Valid,  0.18411482427370648,  0.17286774893046056,None,None,59.0,0.6413043478260869,61.0,0.6630434782608695,None,None,None,None,22.0,0.3728813559322034,None,None,None,None,10.0,0.7142857142857143,4.0,0.26666666666666666,10.0,0.7142857142857143
460,liquibase,"private void parseDefaultPropertyFileFromResource(File potentialPropertyFile) throws IOException, CommandLineParsingException{
    try (InputStream resourceAsStream = getClass().getClassLoader().getResourceAsStream(potentialPropertyFile.getAbsolutePath())) {
        if (resourceAsStream != null) {
            parsePropertiesFile(resourceAsStream);
        }
    }
}",parseDefaultPropertyFileFromResource,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,"/**
     * Open a property file that is embedded as a Java resource and parse it.
     *
     * @param potentialPropertyFile location and file name of the property file
     * @throws IOException                 if the file cannot be opened
     * @throws CommandLineParsingException if an error occurs during parsing
     */",782-797,"('parseDefaultPropertyFileFromResource', {'INSTRUCTION': {'covered': 10, 'missed': 3}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",50.0,15.0,Open a property file that is embedded as a Java resource and parse it.,Open and parse a property file embedded as a Java resource.,You can open a property file that is embedded in a Java resource.,0.299277181594768,Open an embedded properties file as a Java resource and parse it.,"private void parseDefaultPropertyFileFromResource(File potentialPropertyFile) throws IOException, CommandLineParsingException{
        LOG.info(""Loading default property file from resource: "" + potentialPropertyFile);
        InputStream inputStream = getClass().getResourceAsStream(potentialPropertyFile.getPath().substring(1));
        if (inputStream == null) {
            throw new CommandLineParsingException(""Unable to find default property file: "" + potentialPropertyFile);
        }
        parseDefaultPropertyFile(inputStream);      
 }"," private void parseDefaultPropertyFileFromResource(File potentialPropertyFile) throws IOException, CommandLineParsingException{
        LOG.info(""Loading default property file from resource: "" + potentialPropertyFile);
        InputStream inputStream = getClass().getResourceAsStream(potentialPropertyFile.getPath());
        if (inputStream == null) {
            throw new CommandLineParsingException(""Unable to find default property file: "" + potentialPropertyFile);
        }
        parseDefaultPropertyFile(inputStream);      
 }","private void parseDefaultPropertyFileFromResource(File potentialPropertyFile) throws IOException, CommandLineParsingException{
        String resourceName = potentialPropertyFile.getName();
        if (resourceName.endsWith("".properties"")) {
            resourceName = resourceName.substring(0, resourceName.length() - "".properties"".length());
        }
        resourceName = resourceName.replace('.', '/') + "".properties"";
        InputStream is = getClass().getClassLoader().getResourceAsStream(resourceName);
        if (is == null) {
            throw new CommandLineParsingException(""Unable to find resource: "" + resourceName);
        }
        parseDefaultPropertyFileFromInputStream(is, potentialPropertyFile);
    }"," private void parseDefaultPropertyFileFromResource(File potentialPropertyFile) throws IOException, CommandLineParsingException{
        LOG.info(""Loading default properties from resource: "" + potentialPropertyFile.getName());
        InputStream inputStream = getClass().getResourceAsStream(potentialPropertyFile.getName());
        if (inputStream == null) {
            throw new CommandLineParsingException(""Unable to find resource: "" + potentialPropertyFile.getName());
        }
        parseDefaultPropertyFile(inputStream);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5501699200059138,  0.5630842607655564,  0.5612743184539252,  0.5380781546629103,29.0,0.4393939393939394,28.0,0.45901639344262296,34.0,0.4927536231884058,72.0,0.6666666666666666,5.0,0.07575757575757576,16.0,0.2318840579710145,62.0,0.5740740740740741,8.0,0.5333333333333333,6.0,0.4,8.0,0.5333333333333333
461,openapi-generator,"private static void visitSchema(OpenAPI openAPI, Schema schema, String mimeType, List<String> visitedSchemas, OpenAPISchemaVisitor visitor){
    visitor.visit(schema, mimeType);
    if (schema.get$ref() != null) {
        String ref = getSimpleRef(schema.get$ref());
        if (!visitedSchemas.contains(ref)) {
            visitedSchemas.add(ref);
            Schema referencedSchema = getSchemas(openAPI).get(ref);
            if (referencedSchema != null) {
                visitSchema(openAPI, referencedSchema, mimeType, visitedSchemas, visitor);
            }
        }
    }
    if (schema instanceof ComposedSchema) {
        List<Schema> oneOf = ((ComposedSchema) schema).getOneOf();
        if (oneOf != null) {
            for (Schema s : oneOf) {
                visitSchema(openAPI, s, mimeType, visitedSchemas, visitor);
            }
        }
        List<Schema> allOf = ((ComposedSchema) schema).getAllOf();
        if (allOf != null) {
            for (Schema s : allOf) {
                visitSchema(openAPI, s, mimeType, visitedSchemas, visitor);
            }
        }
        List<Schema> anyOf = ((ComposedSchema) schema).getAnyOf();
        if (anyOf != null) {
            for (Schema s : anyOf) {
                visitSchema(openAPI, s, mimeType, visitedSchemas, visitor);
            }
        }
    } else if (schema instanceof ArraySchema) {
        Schema itemsSchema = ((ArraySchema) schema).getItems();
        if (itemsSchema != null) {
            visitSchema(openAPI, itemsSchema, mimeType, visitedSchemas, visitor);
        }
    } else if (isMapSchema(schema)) {
        Object additionalProperties = schema.getAdditionalProperties();
        if (additionalProperties instanceof Schema) {
            visitSchema(openAPI, (Schema) additionalProperties, mimeType, visitedSchemas, visitor);
        }
    }
    if (schema.getNot() != null) {
        visitSchema(openAPI, schema.getNot(), mimeType, visitedSchemas, visitor);
    }
    Map<String, Schema> properties = schema.getProperties();
    if (properties != null) {
        for (Schema property : properties.values()) {
            visitSchema(openAPI, property, mimeType, visitedSchemas, visitor);
        }
    }
}",visitSchema,org/openapitools/codegen/utils/ModelUtils.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ModelUtils.java,"/**
     * Invoke the specified visitor function for every schema that matches mimeType in the OpenAPI document.
     *
     * To avoid infinite recursion, referenced schemas are visited only once. When a referenced schema is visited,
     * it is added to visitedSchemas.
     *
     * @param openAPI the OpenAPI document that contains schema objects.
     * @param schema the root schema object to be visited.
     * @param mimeType the mime type. TODO: does not seem to be used in a meaningful way.
     * @param visitedSchemas the list of referenced schemas that have been visited.
     * @param visitor the visitor function which is invoked for every visited schema.
     */",312-375,"('visitSchema', {'INSTRUCTION': {'covered': 172, 'missed': 0}, 'BRANCH': {'covered': 32, 'missed': 2}, 'LINE': {'covered': 40, 'missed': 0}, 'COMPLEXITY': {'covered': 16, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",424.0,16.0,Invoke the specified visitor function for every schema that matches mimeType in the OpenAPI document.,"If a schema matchs mimeType in the OpenAPI document, the method invokes the visitor function and is added to visitedAchemas . References schema are visited only one single time to avoid infiite recursion",Every schema that matches mimeType should be invoked with the specified visitor function.,0.974650298081132,Call the visitor function specified for each schema that corresponds to mimeType in the OpenAPI document.," private static void visitSchema(OpenAPI openAPI, Schema schema, String mimeType, List<String> visitedSchemas, OpenAPISchemaVisitor visitor){
        if (schema != null) {
            String ref = getSimpleRef(schema.get$ref());
            if (ref != null) {
                if (!visitedSchemas.contains(ref)) {
                    visitedSchemas.add(ref);
                    visitor.visit(ref, mimeType);
                }
            } else {
                if (schema.getProperties() != null) {
                    for (Entry<String, Schema> e : schema.getProperties().entrySet()) {
                        visitSchema(openAPI, e.getValue(), mimeType, visitedSchemas, visitor);
                    }
                }
                if (schema.getItems() != null) {
                    visitSchema(openAPI, schema.getItems(), mimeType, visitedSchemas, visitor);
                }
                if (schema.getAdditionalProperties() != null) {
                    visitSchema(openAPI, schema.getAdditionalProperties(), mimeType, visitedSchemas, visitor);
                }
            }
        }
    }"," private static void visitSchema(OpenAPI openAPI, Schema schema, String mimeType, List<String> visitedSchemas, OpenAPISchemaVisitor visitor){
        if (schema != null) {
            if (schema.get$ref() != null) {
                String ref = getSimpleRef(schema.get$ref());
                if (!visitedSchemas.contains(ref)) {
                    visitedSchemas.add(ref);
                    Schema referencedSchema = getReferencedSchema(openAPI, schema);
                    if (referencedSchema != null) {
                        visitSchema(openAPI, referencedSchema, mimeType, visitedSchemas, visitor);
                    }
                }
            } else {
                visitor.visit(schema, mimeType);
            }
        }
    }",Not Valid," private static void visitSchema(OpenAPI openAPI, Schema schema, String mimeType, List<String> visitedSchemas, OpenAPISchemaVisitor visitor){
        if (schema != null) {
            String ref = getSimpleRef(schema.get$ref());
            if (ref != null) {
                if (!visitedSchemas.contains(ref)) {
                    visitedSchemas.add(ref);
                    Schema referencedSchema = getReferencedSchema(openAPI, schema);
                    if (referencedSchema != null) {
                        visitSchema(openAPI, referencedSchema, mimeType, visitedSchemas, visitor);
                    }
                }
            } else {
                visitor.visit(schema, mimeType);
            }
        }
    }",NOT PASS,NOT PASS,NOT PASS,Not Valid,  0.34487397831636973,  0.26758267095979776,  0.2495250577728606,None,263.0,0.6188235294117647,313.0,0.7364705882352941,322.0,0.7576470588235295,None,None,105.0,0.5412371134020618,90.0,0.4639175257731959,None,None,29.0,0.8529411764705882,6.0,0.35294117647058826,14.0,0.875
462,tablesaw,"public Table xTabCounts(String column1Name, String column2Name){
    return CrossTab.counts(this, categoricalColumn(column1Name), categoricalColumn(column2Name));
}",xTabCounts,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,"/**
   * Returns a table with n by m + 1 cells. The first column contains labels, the other cells
   * contains the counts for every unique combination of values from the two specified columns in
   * this table.
   */",1249-1256,"('xTabCounts', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,11.0,Returns a table with n by m + 1 cells.,"Creates a table with n rows and m+1 columns. The first column contains the labels, while the other contains the number of unique combinations of values from the two specified columns.",A table with n by m and 1 cells.,0.337963950517331,Returns a table with n by m + 1 cells.,"public Table xTabCounts(String column1Name, String column2Name){
    return xTabCounts(column(column1Name), column(column2Name));    
 }","public Table xTabCounts(String column1Name, String column2Name){
    return xTabCounts(column(column1Name), column(column2Name));    
 }","public Table xTabCounts(String column1Name, String column2Name){
    return xTabCounts(column(column1Name), column(column2Name));    
 }","public Table xTabCounts(String column1Name, String column2Name){
    return xTabCounts(column(column1Name), column(column2Name));    
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7249347418217359,  0.7249347418217359,  0.7249347418217359,  0.7249347418217359,7.0,0.22580645161290322,7.0,0.22580645161290322,7.0,0.22580645161290322,7.0,0.22580645161290322,0.0,0.0,0.0,0.0,0.0,0.0,27.0,0.84375,0.0,0.0,3.0,0.2727272727272727
463,cdk,"private static Bond toBeamEdgeLabel(IBond b, int flavour) throws CDKException{
    if (SmiFlavor.isSet(flavour, SmiFlavor.UseAromaticSymbols) && b.isAromatic()) {
        if (!b.getBegin().isAromatic() || !b.getEnd().isAromatic())
            throw new IllegalStateException(""Aromatic bond connects non-aromatic atomic atoms"");
        return Bond.AROMATIC;
    }
    if (b.getOrder() == null)
        throw new CDKException(""A bond had undefined order, possible query bond?"");
    IBond.Order order = b.getOrder();
    switch(order) {
        case SINGLE:
            return Bond.SINGLE;
        case DOUBLE:
            return Bond.DOUBLE;
        case TRIPLE:
            return Bond.TRIPLE;
        case QUADRUPLE:
            return Bond.QUADRUPLE;
        default:
            if (!SmiFlavor.isSet(flavour, SmiFlavor.UseAromaticSymbols) && b.isAromatic())
                throw new CDKException(""Cannot write Kekulé SMILES output due to aromatic bond with unset bond order - molecule should be Kekulized"");
            throw new CDKException(""Unsupported bond order: "" + order);
    }
}",toBeamEdgeLabel,org/openscience/cdk/smiles/CDKToBeam.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/CDKToBeam.java,"/**
     * Convert a CDK {@link IBond} to the Beam edge label type.
     *
     * @param b cdk bond
     * @return the edge label for the Beam edge
     * @throws NullPointerException     the bond order was null and the bond was
     *                                  not-aromatic
     * @throws IllegalArgumentException the bond order could not be converted
     */",263-298,"('toBeamEdgeLabel', {'INSTRUCTION': {'covered': 70, 'missed': 0}, 'BRANCH': {'covered': 17, 'missed': 2}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",176.0,15.0,Convert a CDK {@link IBond} to the Beam edge label type.,"Given a CDK bond, it returns the edge label type for the Beam edge.",The CDK can be converted to the Beam edge label type.,0.381944877739515,Convert a CDK {@link IBond} to a beam edge label type.," private static Bond toBeamEdgeLabel(IBond b, int flavour) throws CDKException{
        BondOrder order = b.getOrder();
        if (order == null) throw new NullPointerException(""Bond order was undefined"");
    
        switch (order) {
            case SINGLE:
                return Bond.single();
            case DOUBLE:
                return Bond.doubleBond();
            case TRIPLE:
                return Bond.triple();
            case QUADRUPLE:
                return Bond.quadruple();
            case AROMATIC:
                return Bond.aromatic();
            case UNSET:
                throw new CDKException(""Bond order was undefined"");
            default:
                throw new CDKException(""Unsupported bond order: "" + order);
        }
    }"," private static Bond toBeamEdgeLabel(IBond b, int flavour) throws CDKException{
        Bond bond = Bond.of(b.getOrder());
        if (bond == null) throw new CDKException(""Unsupported bond order: "" + b.getOrder());
    
        if (SmiFlavor.isSet(flavour, SmiFlavor.UseAromaticSymbols) && b.getFlag(CDKConstants.ISAROMATIC)) {
            bond = Bond.aromatic(bond);
        }
    
        return bond;
    }"," private static Bond toBeamEdgeLabel(IBond b, int flavour) throws CDKException{
        Bond.Type type = b.getOrder();
        if (type == null) throw new NullPointerException(""Bond order was undefined"");
    
        if (SmiFlavor.isSet(flavour, SmiFlavor.UseAromaticSymbols) && b.getFlag(CDKConstants.ISAROMATIC)) {
            if (type == Bond.Type.SINGLE) return Bond.single().aromatic();
            if (type == Bond.Type.DOUBLE) return Bond.doubleBond().aromatic();
            if (type == Bond.Type.TRIPLE) return Bond.triple().aromatic();
            if (type == Bond.Type.QUADRUPLE) return Bond.quadruple().aromatic();
            if (type == Bond.Type.AROMATIC) return Bond.aromatic();
        }
    
        if (type == Bond.Type.SINGLE) return Bond.single();
        if (type == Bond.Type.DOUBLE) return Bond.doubleBond();
        if (type == Bond.Type.TRIPLE) return Bond.triple();
        if (type == Bond.Type.QUADRUPLE) return Bond.quadruple();
        if (type == Bond.Type.AROMATIC) return Bond.aromatic();
    
        throw new IllegalArgumentException(""Unsupported bond type: "" + type);       
 }"," private static Bond toBeamEdgeLabel(IBond b, int flavour) throws CDKException{
        Bond.Type type = Objects.requireNonNull(b.getOrder(), ""Bond order was undefined"");
    
        if (SmiFlavor.isSet(flavour, SmiFlavor.UseAromaticSymbols) && b.isAromatic()) {
            switch (type) {
                case SINGLE: return Bond.single(Bond.Type.AROMATIC);
                case DOUBLE: return Bond.doubleBond(Bond.Type.AROMATIC);
                case TRIPLE: return Bond.triple(Bond.Type.AROMATIC);
                case QUADRUPLE: return Bond.quadruple(Bond.Type.AROMATIC);
                case QUINTUPLE: return Bond.quintuple(Bond.Type.AROMATIC);
                case UNSET:
                default:
                    throw new CDKException(""Unsupported bond order: "" + type);
            }
        }
    
        switch (type) {
            case SINGLE: return Bond.single();
            case DOUBLE: return Bond.doubleBond();
            case TRIPLE: return Bond.triple();
            case QUADRUPLE: return Bond.quadruple();
            case QUINTUPLE: return Bond.quintuple();
            case UNSET:
            default:
                throw new CDKException(""Unsupported bond order: "" + type);
        }       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3608946301764206,  0.3164146355368114,  0.49553087883548375,  0.47197559792059707,104.0,0.5875706214689266,120.0,0.6779661016949152,130.0,0.5909090909090909,166.0,0.640926640926641,73.0,0.6347826086956522,120.0,0.5454545454545454,173.0,0.667953667953668,10.0,0.6666666666666666,2.0,0.16666666666666666,5.0,0.4166666666666667
464,cdk,"IAtom toCDKAtom(Atom beamAtom, int hCount){
    IAtom cdkAtom = newCDKAtom(beamAtom);
    cdkAtom.setImplicitHydrogenCount(hCount);
    cdkAtom.setFormalCharge(beamAtom.charge());
    if (beamAtom.isotope() >= 0)
        cdkAtom.setMassNumber(beamAtom.isotope());
    if (beamAtom.aromatic())
        cdkAtom.setIsAromatic(true);
    if (beamAtom.atomClass() > 0)
        cdkAtom.setProperty(ATOM_ATOM_MAPPING, beamAtom.atomClass());
    return cdkAtom;
}",toCDKAtom,org/openscience/cdk/smiles/BeamToCDK.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/BeamToCDK.java,"/**
     * Create a new CDK {@link IAtom} from the Beam Atom.
     *
     * @param beamAtom an Atom from the Beam ChemicalGraph
     * @param hCount   hydrogen count for the atom
     * @return the CDK atom to have it's properties set
     */",604-625,"('toCDKAtom', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",99.0,14.0,Create a new CDK {@link IAtom} from the Beam Atom.,"Starting from the beamAtom in a ChemicalGraph, create a new CDK IAtom.",A new CDK is created from the beam atom.,0.383405433508895,Create a new CDK {@link IAtom} from the beam atom.,"IAtom toCDKAtom(Atom beamAtom, int hCount){
        IAtom atom = new Atom(beamAtom.getSymbol());
        atom.setAtomicNumber(beamAtom.getAtomicNumber());
        atom.setImplicitHydrogenCount(hCount);
        atom.setFormalCharge(beamAtom.getFormalCharge());
        atom.setMassNumber(beamAtom.getMassNumber());
        atom.setMass(beamAtom.getMass());
        atom.setPoint3d(beamAtom.getPoint3d());
        atom.setPoint2d(beamAtom.getPoint2d());
        atom.setProperties(beamAtom.getProperties());
        return atom;
    }","IAtom toCDKAtom(Atom beamAtom, int hCount){
        IAtom atom = new Atom(beamAtom.getSymbol());
        atom.setImplicitHydrogenCount(hCount);
        atom.setMassNumber(beamAtom.getMassNumber());
        atom.setCharge(beamAtom.getCharge());
        atom.setFlag(CDKConstants.ISAROMATIC, beamAtom.isAromatic());
        atom.setFlag(CDKConstants.ISINRING, beamAtom.isInRing());
        atom.setFlag(CDKConstants.ISINRINGSIZE, beamAtom.isInRingSize());
        atom.setFlag(CDKConstants.ISINRINGSIZE2, beamAtom.isInRingSize2());
        atom.setFlag(CDKConstants.ISINRINGSIZE3, beamAtom.isInRingSize3());
        atom.setFlag(CDKConstants.ISINRINGSIZE4, beamAtom.isInRingSize4());
        atom.setFlag(CDKConstants.ISINRINGSIZE5, beamAtom.isInRingSize5());
        atom.setFlag(CDKConstants.ISINRINGSIZE6, beamAtom.isInRingSize6());
        atom.setFlag(CDKConstants.ISINRINGSIZE7, beamAtom.isInRingSize7());
        atom.setFlag(CDKConstants.ISINRINGSIZE8, beamAtom.isInRingSize8());
        atom.setFlag(CDKConstants.ISINRINGSIZE9, beamAtom.isInRingSize9());
        atom.setFlag(CDKConstants.ISINRINGSIZE10, beamAtom.isInRingSize10());
        atom.setFlag(CDKConstants.ISINRINGSIZE11, beamAtom.isInRingSize11());
        atom.setFlag(CDKConstants.ISINRINGSIZE12, beamAtom.isInRingSize12());
        atom.setFlag(CDKConstants.ISINRINGSIZE13, beamAtom.isInRingSize13());
        atom.setFlag(CDKConstants       
 }"," IAtom toCDKAtom(Atom beamAtom, int hCount){
        IAtom atom = new Atom(beamAtom.getElement());
        atom.setImplicitHydrogenCount(hCount);
        return atom;
    }"," IAtom toCDKAtom(Atom beamAtom, int hCount){
        IAtom atom = new Atom(beamAtom.getSymbol());
        atom.setAtomicNumber(beamAtom.getAtomicNumber());
        atom.setFormalCharge(beamAtom.getFormalCharge());
        atom.setImplicitHydrogenCount(hCount);
        return atom;
    }",NOT PASS,Syntax Error,NOT PASS,NOT PASS,  0.46974874155977847,None,  0.3748730140719799,  0.2713555221188676,52.0,0.4642857142857143,None,None,58.0,0.58,73.0,0.73,None,None,57.0,0.5089285714285714,78.0,0.6964285714285714,12.0,0.9230769230769231,2.0,0.18181818181818182,6.0,0.5454545454545454
465,cdk,"private static Map<IAtom, Integer> indexAtoms(IAtomContainer container){
    Map<IAtom, Integer> map = new HashMap<>(2 * container.getAtomCount());
    for (int i = 0; i < container.getAtomCount(); i++) map.put(container.getAtom(i), i);
    return map;
}",indexAtoms,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,"/**
     * Create an index of atoms for the provided {@code container}.
     *
     * @param container the container to index the atoms of
     * @return the index/lookup of atoms to the index they appear
     */",338-349,"('indexAtoms', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",72.0,14.0,Create an index of atoms for the provided {@code container}.,the method returns the index/lookup of atom for the given container.,The provided @code container has an index of atoms.,0.807122340183246,Create an index of atoms for the provided {container @code}.,"private static Map<IAtom, Integer> indexAtoms(IAtomContainer container){
        Map<IAtom, Integer> map = new HashMap<IAtom, Integer>();
        for (int i = 0; i < container.getAtomCount(); i++)
            map.put(container.getAtom(i), i);
        return map;     
 }","private static Map<IAtom, Integer> indexAtoms(IAtomContainer container){
        Map<IAtom, Integer> map = new HashMap<IAtom, Integer>();
        for (int i = 0; i < container.getAtomCount(); i++)
            map.put(container.getAtom(i), i);
        return map;     
 }","private static Map<IAtom, Integer> indexAtoms(IAtomContainer container){
        Map<IAtom, Integer> map = new HashMap<IAtom, Integer>();
        for (int i = 0; i < container.getAtomCount(); i++)
            map.put(container.getAtom(i), i);
        return map;
    }","private static Map<IAtom, Integer> indexAtoms(IAtomContainer container){
        Map<IAtom, Integer> map = new HashMap<IAtom, Integer>();
        for (int i = 0; i < container.getAtomCount(); i++)
            map.put(container.getAtom(i), i);
        return map;
    }",PASS,PASS,PASS,PASS,  0.8296909800119288,  0.8296909800119288,  0.8296909800119288,  0.8296909800119288,8.0,0.1095890410958904,8.0,0.1095890410958904,8.0,0.1095890410958904,8.0,0.1095890410958904,0.0,0.0,0.0,0.0,0.0,0.0,9.0,0.75,2.0,0.18181818181818182,10.0,0.9090909090909091
466,cdk,"public DescriptorValue calculate(IAtomContainer mol){
    DoubleResult result;
    try {
        int nC = 0;
        int nCSP3 = 0;
        CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.getInstance(mol.getBuilder());
        for (IAtom atom : mol.atoms()) {
            if (atom.getAtomicNumber() == 6) {
                nC++;
                IAtomType matched = matcher.findMatchingAtomType(mol, atom);
                if (matched != null && matched.getHybridization() == IAtomType.Hybridization.SP3) {
                    nCSP3++;
                }
            }
        }
        result = new DoubleResult(nC == 0 ? 0 : (double) nCSP3 / nC);
    } catch (CDKException e) {
        result = new DoubleResult(Double.NaN);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), result, getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/FractionalCSP3Descriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/FractionalCSP3Descriptor.java,"/**
     * Calculates the Fsp<sup>3</sup> descriptor value for the given {@link IAtomContainer}.
     *
     * @param mol An {@link org.openscience.cdk.interfaces.IAtomContainer} for which this descriptor
     *            should be calculated
     * @return An object of {@link org.openscience.cdk.qsar.DescriptorValue} that contains the
     *         calculated Fsp<sup>3</sup> descriptor value
     */",84-116,"('calculate', {'INSTRUCTION': {'covered': 65, 'missed': 6}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 14, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",161.0,21.0,Calculates the Fsp<sup>3</sup> descriptor value for the given {@link IAtomContainer}.,Computes the Fsp3 descriptor value for the provided IAtomContainer,The given @link IAtomContainer is calculated using the Fspsup>3/sup> descriptor value.,0.831272211610685,Calculates the value of the Fsp<sup>3</sup> descriptor for the given {@link IAtomContainer}.,"public DescriptorValue calculate(IAtomContainer mol){
        double fsp3 = 0.0;
        int nAtoms = mol.getAtomCount();
        int nCSP3 = 0;
        int nCSP2 = 0;
        int nCSP = 0;
        int nCSP2_3 = 0;
        int nCSP_3 = 0;
        int nCSP_2 = 0;
        int nCSP_2_3 = 0;
        int nCSP_3_2 = 0;
        int nCSP_3_2_1 = 0;
        int nCSP_3_2_2 = 0;
        int nCSP_3_2_3 = 0;
        int nCSP_3_2_4 = 0;
        int nCSP_3_2_5 = 0;
        int nCSP_3_2_6 = 0;
        int nCSP_3_2_7 = 0;
        int nCSP_3_2_8 = 0;
        int nCSP_3_2_9 = 0;
        int nCSP_3_2_10 = 0;
        int nCSP_3_2_11 = 0;
        int nCSP_3_2_12 = 0;
        int nCSP_3_2_13 = 0;
        int nCSP_3_2_14 = 0;
        int nCSP_3_2_15 = 0;
        int nCSP_3_2_16 = 0;
        int nCSP_3_2_17 = 0;
        int nCSP_3_2_18 = 0;
        int nCSP_3_2_19 = 0;
        int nCSP_3_2_20 = 0;
        int nCSP_3_2_21 = 0;
        int nCSP_3_2_22 = 0;
        int nCSP_3_2_23 = 0;
        int nCSP_3_2_24 = 0;
        int nCSP_3_2_25 = 0;
        int nCSP_3_2_       
 }","public DescriptorValue calculate(IAtomContainer mol){
        double fsp3 = 0.0;
        int nAtoms = mol.getAtomCount();
        int nCSP3 = 0;
        int nCSP2 = 0;
        int nCSP = 0;
        int nCSP2_3 = 0;
        int nCSP_3 = 0;
        int nCSP_2 = 0;
        int nCSP_2_3 = 0;
        int nCSP_3_2 = 0;
        int nCSP_3_2_1 = 0;
        int nCSP_3_2_2 = 0;
        int nCSP_3_2_3 = 0;
        int nCSP_3_2_4 = 0;
        int nCSP_3_2_5 = 0;
        int nCSP_3_2_6 = 0;
        int nCSP_3_2_7 = 0;
        int nCSP_3_2_8 = 0;
        int nCSP_3_2_9 = 0;
        int nCSP_3_2_10 = 0;
        int nCSP_3_2_11 = 0;
        int nCSP_3_2_12 = 0;
        int nCSP_3_2_13 = 0;
        int nCSP_3_2_14 = 0;
        int nCSP_3_2_15 = 0;
        int nCSP_3_2_16 = 0;
        int nCSP_3_2_17 = 0;
        int nCSP_3_2_18 = 0;
        int nCSP_3_2_19 = 0;
        int nCSP_3_2_20 = 0;
        int nCSP_3_2_21 = 0;
        int nCSP_3_2_22 = 0;
        int nCSP_3_2_23 = 0;
        int nCSP_3_2_24 = 0;
        int nCSP_3_2_25 = 0;
        int nCSP_3_2_       
 }","public DescriptorValue calculate(IAtomContainer mol){
        double value = 0.0;
        try {
            value = calculateFsp3(mol);
        } catch (CDKException e) {
            e.printStackTrace();
        }
        IDescriptorResult result = new DoubleResult(value, DoubleResultType.FSP3);
        return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), result);       
 }","public DescriptorValue calculate(IAtomContainer mol){
        double value = 0.0;
        int count = 0;
        for (IAtom atom : mol.atoms()) {
            IAtomType type = CDKAtomTypeMatcher.findAtomType(mol, atom);
            if (type.getFormalNeighbourCount() == 3) {
                value += type.getFormalNeighbourCount();
                count++;
            }
        }
        if (count == 0) {
            return new DescriptorValue(getSpecification(), getParameterNames(), new Object[]{}, new DoubleResult(0.0));
        }
        value /= count;
        return new DescriptorValue(getSpecification(), getParameterNames(), new Object[]{}, new DoubleResult(value));       
 }",Syntax Error,Syntax Error,NOT PASS,NOT PASS,None,None,  0.3768468641412202,  0.24294011496749657,None,None,None,None,97.0,0.5987654320987654,110.0,0.6790123456790124,None,None,165.0,0.8638743455497382,171.0,0.8952879581151832,5.0,0.45454545454545453,4.0,0.3076923076923077,10.0,0.8333333333333334
467,acs-aem-commons,"private void populateMetadataFromRow(Resource resource, Map<String, Object> nodeInfo) throws RepositoryException{
    LOG.debug(""Start of populateMetadataFromRow"");
    ModifiableValueMap resourceProperties = resource.adaptTo(ModifiableValueMap.class);
    Node node = resource.adaptTo(Node.class);
    for (Map.Entry entry : nodeInfo.entrySet()) {
        String key = (String) entry.getKey();
        Object value = entry.getValue();
        if (key != null && (mergeMode.overwriteProps || !resourceProperties.containsKey(key))) {
            if (node.hasProperty(key) && node.getProperty(key).isMultiple() && mergeMode.appendArrays) {
                appendArray(resourceProperties, entry);
            } else if (value != null) {
                resourceProperties.put(key, value);
            }
        }
    }
    LOG.debug(""End of populateMetadataFromRow"");
}",populateMetadataFromRow,com/adobe/acs/commons/mcp/impl/processes/DataImporter.java,/bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/DataImporter.java,"/**
     * Update the resource with the properties from the row.
     *
     * @param resource Resource object of which the properties are to be modified.
     * @param nodeInfo Map of properties from the row.
     */",364-389,"('populateMetadataFromRow', {'INSTRUCTION': {'covered': 58, 'missed': 13}, 'BRANCH': {'covered': 7, 'missed': 9}, 'LINE': {'covered': 13, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 7}, 'METHOD': {'covered': 1, 'missed': 0}})",166.0,10.0,Update the resource with the properties from the row.,"Given a row and a map of properties, update the resource.",The properties from the row should be updated.,0.256469514212581,Update the resource with the properties of the row.," private void populateMetadataFromRow(Resource resource, Map<String, Object> nodeInfo) throws RepositoryException{
        ModifiableValueMap resourceProperties = resource.adaptTo(ModifiableValueMap.class);
        for (Map.Entry<String, Object> entry : nodeInfo.entrySet()) {
            if (resourceProperties.containsKey(entry.getKey())) {
                if (resourceProperties.get(entry.getKey()) instanceof Object[]) {
                    appendArray(resourceProperties, entry);
                } else {
                    resourceProperties.put(entry.getKey(), entry.getValue());
                }
            } else {
                resourceProperties.put(entry.getKey(), entry.getValue());
            }
        }
    }"," private void populateMetadataFromRow(Resource resource, Map<String, Object> nodeInfo) throws RepositoryException{
        ModifiableValueMap resourceProperties = resource.adaptTo(ModifiableValueMap.class);
        for (Map.Entry<String, Object> entry : nodeInfo.entrySet()) {
            if (resourceProperties.containsKey(entry.getKey())) {
                if (resourceProperties.get(entry.getKey()) instanceof Object[]) {
                    appendArray(resourceProperties, entry);
                } else {
                    resourceProperties.put(entry.getKey(), entry.getValue());
                }
            } else {
                resourceProperties.put(entry.getKey(), entry.getValue());
            }
        }
    }",Not Valid,Not Valid,NOT PASS,PASS,Not Valid,Not Valid,  0.41613808815571285,  0.41613808815571285,None,None,95.0,0.5688622754491018,95.0,0.5688622754491018,None,None,None,None,0.0,0.0,None,None,None,None,10.0,0.8333333333333334,1.0,0.1,8.0,0.8
468,dataverse,"public static List<CharacterRule> parseConfigString(String configString){
    List<CharacterRule> characterRules = new ArrayList<>();
    String[] typePlusNums = configString.split("","");
    for (String typePlusNum : typePlusNums) {
        String[] configArray = typePlusNum.split("":"");
        String type = configArray[0];
        String num = configArray[1];
        EnglishCharacterData typeData = EnglishCharacterData.valueOf(type);
        characterRules.add(new CharacterRule(typeData, new Integer(num)));
    }
    return characterRules;
}",parseConfigString,edu/harvard/iq/dataverse/validation/PasswordValidatorUtil.java,/src/main/java/edu/harvard/iq/dataverse/validation/PasswordValidatorUtil.java,"/**
     * Parses the list of character rules as defined in the database. Recall how
     * configString is formatted: ""UpperCase:1,LowerCase:1,Digit:1,Special:1""
     */",40-55,"('parseConfigString', {'INSTRUCTION': {'covered': 53, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,12.0,Parses the list of character rules as defined in the database.,"Taking into account the formatting of the configString (""UpperCase:1,LowerCase:1,Digit:1,Special:1"") parses the list of characters that are defined in the database.",The list of character rules isParsed.,0.331012382815216,Parses the list of character rules as defined in the database.,"public static List<CharacterRule> parseConfigString(String configString){
        List<CharacterRule> rules = new ArrayList<>();
        String[] ruleStrings = configString.split("","");
        for (String ruleString : ruleStrings) {
            String[] ruleParts = ruleString.split("":"");
            if (ruleParts.length == 2) {
                String ruleName = ruleParts[0];
                String ruleCount = ruleParts[1];
                CharacterRule rule = new CharacterRule(ruleName, Integer.parseInt(ruleCount));
                rules.add(rule);
            } else {
                logger.warning(""Invalid character rule: "" + ruleString);
            }
        }
        return rules;
    }","public static List<CharacterRule> parseConfigString(String configString){
        List<CharacterRule> characterRules = new ArrayList<>();
        String[] configArray = configString.split("","");
        for (String config : configArray) {
            String[] configArray2 = config.split("":"");
            String characterType = configArray2[0];
            int minCount = Integer.parseInt(configArray2[1]);
            if (characterType.equals(""UpperCase"")) {
                characterRules.add(new CharacterRule(EnglishCharacterData.UpperCase, minCount));
            } else if (characterType.equals(""LowerCase"")) {
                characterRules.add(new CharacterRule(EnglishCharacterData.LowerCase, minCount));
            } else if (characterType.equals(""Digit"")) {
                characterRules.add(new CharacterRule(EnglishCharacterData.Digit, minCount));
            } else if (characterType.equals(""Special"")) {
                characterRules.add(new CharacterRule(EnglishCharacterData.Special, minCount));
            } else {
                logger.warning(""Unknown character type: "" + characterType);
            }
        }
        return characterRules;
    }","public static List<CharacterRule> parseConfigString(String configString){
        List<CharacterRule> rules = new ArrayList<>();
        String[] ruleStrings = configString.split("","");
        for (String ruleString : ruleStrings) {
            String[] ruleParts = ruleString.split("":"");
            if (ruleParts.length != 2) {
                logger.warning(""Invalid character rule: "" + ruleString);
                continue;
            }
            String ruleName = ruleParts[0].trim();
            String ruleCount = ruleParts[1].trim();
            int count = Integer.parseInt(ruleCount);
            CharacterRule rule = getRule(ruleName, count);
            if (rule != null) {
                rules.add(rule);
            }
        }
        return rules;       
 }","public static List<CharacterRule> parseConfigString(String configString){
        List<CharacterRule> rules = new ArrayList<>();
        String[] ruleStrings = configString.split("","");
        for (String ruleString : ruleStrings) {
            String[] ruleParts = ruleString.split("":"");
            if (ruleParts.length != 2) {
                logger.warning(""Invalid character rule: "" + ruleString);
                continue;
            }
            String ruleName = ruleParts[0].trim();
            String ruleValue = ruleParts[1].trim();
            CharacterRule rule = null;
            if (ruleName.equals(""Alphabetical"")) {
                rule = new CharacterRule(EnglishCharacterData.Alphabetical, Integer.parseInt(ruleValue));
            } else if (ruleName.equals(""Digit"")) {
                rule = new CharacterRule(EnglishCharacterData.Digit, Integer.parseInt(ruleValue));
            } else if (ruleName.equals(""Special"")) {
                rule = new CharacterRule(EnglishCharacterData.Special, Integer.parseInt(ruleValue));
            } else if (ruleName.equals(""Whitespace"")) {
                rule = new CharacterRule(EnglishCharacterData.Whitespace, Integer.parseInt(ruleValue));
            } else {
                logger.warning(""Invalid character rule: "" + ruleString);
                continue;
            }
            rules.add(rule);
        }
        return rules;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5978915874769439,  0.6208595561392524,  0.5393278746840057,  0.5694752033735264,45.0,0.3629032258064516,115.0,0.5665024630541872,161.0,0.6465863453815262,66.0,0.46153846153846156,116.0,0.5714285714285714,130.0,0.5220883534136547,45.0,0.3146853146853147,13.0,0.6190476190476191,0.0,0.0,7.0,0.5833333333333334
469,cdk,"private Pattern createPattern(String smarts, IChemObjectBuilder builder) throws IOException{
    SmartsPattern ptrn = SmartsPattern.create(smarts, builder);
    ptrn.setPrepare(false);
    return ptrn;
}",createPattern,org/openscience/cdk/fingerprint/MACCSFingerprinter.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/MACCSFingerprinter.java,"/**
     * Create a pattern for the provided SMARTS - if the SMARTS is '?' a pattern
     * is not created.
     *
     * @param smarts  a smarts pattern
     * @param builder chem object builder
     * @return the pattern to match
     */",307-319,"('createPattern', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,21.0,Create a pattern for the provided SMARTS - if the SMARTS is '?' a pattern  is not created.,"Using the SMARTS, it creates a pattern if the value of the SMART is different from '?'","If the SMARTS is '?', a pattern is not created.",0.440649438575239,"Create a template for the supplied SMARTS - if the SMARTS is '?', a template is not created."," private Pattern createPattern(String smarts, IChemObjectBuilder builder) throws IOException{
        if (smarts.equals(""?"")) return null;
        return Pattern.compile(smarts, Pattern.CASE_INSENSITIVE);
    }"," private Pattern createPattern(String smarts, IChemObjectBuilder builder) throws IOException{
        Pattern pattern = null;
        if (smarts.equals(""?"")) {
            pattern = Pattern.compile(""."");
        } else {
            SmartsParser parser = new SmartsParser(builder);
            pattern = parser.parse(smarts);
        }
        return pattern;
    }"," private Pattern createPattern(String smarts, IChemObjectBuilder builder) throws IOException{
        if (smarts.equals(""?"")) return null;
        return new SmartsPattern(smarts, builder);
    }"," private Pattern createPattern(String smarts, IChemObjectBuilder builder) throws IOException{
        if (smarts.equals(""?"")) return null;
        return Pattern.compile(smarts, Pattern.CASE_INSENSITIVE);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.42886371853548627,  0.4321363898025565,  0.42886371853548627,  0.4872934412562386,19.0,0.48717948717948717,37.0,0.578125,19.0,0.48717948717948717,18.0,0.4864864864864865,34.0,0.53125,0.0,0.0,6.0,0.15384615384615385,16.0,0.8421052631578947,4.0,0.21052631578947367,10.0,0.5263157894736842
470,cucumber-reporting,"private void fillMissingDurations(){
    long[] extendedArray = new long[buildNumbers.length];
    Arrays.fill(extendedArray, -1);
    System.arraycopy(durations, 0, extendedArray, buildNumbers.length - durations.length, durations.length);
    durations = extendedArray;
}",fillMissingDurations,net/masterthought/cucumber/Trends.java,/src/main/java/net/masterthought/cucumber/Trends.java,"/**
     * Since durations were added later there is need to fill missing data for those statuses.
     */",227-235,"('fillMissingDurations', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",57.0,16.0,Since durations were added later there is need to fill missing data for those statuses.,Integrate the durations for the statuses where it is missing.,There is need to fill in missing data for those statuses since durations were added later.,0.48075901214136,"Since the durations were added later, it is necessary to fill in the missing data for these statuses."," private void fillMissingDurations(){
        // correct only pending and undefined steps
        durations = fillMissingArray(durations);        
 }",Not Valid,Not Valid,Not Valid,NOT PASS,Not Valid,Not Valid,Not Valid,  0.11335543095628157,None,None,None,45.0,0.7758620689655172,None,None,None,None,None,None,None,None,None,None,None,None,15.0,0.9375,7.0,0.3684210526315789,13.0,0.7647058823529411
471,cron-utils,"private int generateNoneValues(final On on, final int year, final int month, final int reference){
    // the day of week the first of the month is on
    // 1-7
    final int dowForFirstDoM = LocalDate.of(year, month, 1).getDayOfWeek().getValue();
    // the day of week we need, normalize to jdk8time
    final int requiredDoW = ConstantsMapper.weekDayMapping(mondayDoWValue, ConstantsMapper.JAVA8, on.getTime().getValue());
    // the first day of the month
    // day 1 from given month
    int baseDay = 1;
    // the difference between the days of week
    final int diff = dowForFirstDoM - requiredDoW;
    // //base day remains the same if diff is zero
    if (diff < 0) {
        baseDay = baseDay + Math.abs(diff);
    }
    if (diff > 0) {
        baseDay = baseDay + 7 - diff;
    }
    // if baseDay is greater than the reference, we are returning the initial matching day value
    // Fix issue #92
    if (reference < 1) {
        return baseDay;
    }
    while (baseDay <= reference) {
        baseDay += 7;
    }
    return baseDay;
}",generateNoneValues,com/cronutils/model/time/generator/OnDayOfWeekValueGenerator.java,/src/main/java/com/cronutils/model/time/generator/OnDayOfWeekValueGenerator.java,"/**
     * Generate valid days of the month for the days of week expression. This method requires that you
     * pass it a -1 for the reference value when starting to generate a sequence of day values. That allows
     * it to handle the special case of which day of the month is the initial matching value.
     *
     * @param on        The expression object giving us the particular day of week we need.
     * @param year      The year for the calculation.
     * @param month     The month for the calculation.
     * @param reference This value must either be -1 indicating you are starting the sequence generation or an actual
     *                  day of month that meets the day of week criteria. So a value previously returned by this method.
     * @return
     */",124-161,"('generateNoneValues', {'INSTRUCTION': {'covered': 49, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",144.0,13.0,Generate valid days of the month for the days of week expression.,"The function takes the expression of the day of week and generates valid days. You need to pass -1 for the reference value for starting the generation of the sequence, allowing to handle special cases like when the day of the month is the initial matching value.",The days of week are expressed in valid days of the month.,0.359240218607499,Generate valid days of the month for the expression of the days of the week.,"private int generateNoneValues(final On on, final int year, final int month, final int reference){
        final int requiredDoW = ConstantsMapper.weekDayMapping(mondayDoWValue, ConstantsMapper.JAVA8, on.getTime().getValue());//to normalize to jdk8-time value
        final int dowDiff = LocalDate.of(year, month, 1).getDayOfWeek().getValue() - requiredDoW;
        if (dowDiff == 0) {
            return 1;
        }
        if (dowDiff < 0) {
            return 1 + Math.abs(dowDiff);
        }
        if (dowDiff > 0) {
            return 1 + 7 - dowDiff;
        }
        throw new NoSuchValueException();
    }","private int generateNoneValues(final On on, final int year, final int month, final int reference){
        final int requiredDoW = ConstantsMapper.weekDayMapping(mondayDoWValue, ConstantsMapper.JAVA8, on.getTime().getValue());//to normalize to jdk8-time value
        final int requiredNth = on.getNth().getValue();
        int baseDay = 1;//day 1 from given month
        final int diff = reference - requiredDoW;
        if (diff < 0) {
            baseDay = baseDay + Math.abs(diff);
        }
        if (diff > 0) {
            baseDay = baseDay + 7 - diff;
        }
        return (requiredNth - 1) * 7 + baseDay;
    }","private int generateNoneValues(final On on, final int year, final int month, final int reference){
        final int requiredDoW = ConstantsMapper.weekDayMapping(mondayDoWValue, ConstantsMapper.JAVA8, on.getTime().getValue());//to normalize to jdk8-time value
        final int dowDiff = LocalDate.of(year, month, 1).getDayOfWeek().getValue() - requiredDoW;
        if (dowDiff == 0) {
            return 1;
        }
        if (dowDiff < 0) {
            return 1 + Math.abs(dowDiff);
        }
        if (dowDiff > 0) {
            return 1 + 7 - dowDiff;
        }
        throw new NoSuchValueException();
    }","private int generateNoneValues(final On on, final int year, final int month, final int reference){
        final int requiredDoW = ConstantsMapper.weekDayMapping(mondayDoWValue, ConstantsMapper.JAVA8, on.getTime().getValue());//to normalize to jdk8-time value
        final int dowDiff = LocalDate.of(year, month, 1).getDayOfWeek().getValue() - requiredDoW;
        if (dowDiff == 0) {
            return 1;
        }
        if (dowDiff < 0) {
            return 1 + Math.abs(dowDiff);
        }
        if (dowDiff > 0) {
            return 1 + 7 - dowDiff;
        }
        throw new NoSuchValueException();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5614902005871151,  0.6207982385906327,  0.555808382405297,  0.5614902005871151,69.0,0.47586206896551725,45.0,0.3103448275862069,69.0,0.47586206896551725,69.0,0.47586206896551725,44.0,0.35772357723577236,0.0,0.0,0.0,0.0,42.0,0.875,5.0,0.3125,9.0,0.6923076923076923
472,openapi-generator,"public void addFromInterfaceModel(CodegenModel cm, List<Map<String, String>> modelsImports){
    // Add cm as implemented interface
    additionalInterfaces.add(cm.classname);
    // Add all vars defined on cm
    // a ""oneOf"" model (cm) by default inherits all properties from its ""interfaceModels"",
    // but we only want to add properties defined on cm itself
    List<CodegenProperty> toAdd = new ArrayList<CodegenProperty>(cm.vars);
    // note that we can't just toAdd.removeAll(m.vars) for every interfaceModel,
    // as they might have different value of `hasMore` and thus are not equal
    List<String> omitAdding = new ArrayList<String>();
    if (cm.interfaceModels != null) {
        for (CodegenModel m : cm.interfaceModels) {
            for (CodegenProperty v : m.vars) {
                omitAdding.add(v.baseName);
            }
        }
    }
    for (CodegenProperty v : toAdd) {
        if (!omitAdding.contains(v.baseName)) {
            additionalProps.add(v.clone());
        }
    }
    // Add all imports of cm
    for (Map<String, String> importMap : modelsImports) {
        // we're ok with shallow clone here, because imports are strings only
        additionalImports.add(new HashMap<String, String>(importMap));
    }
}",addFromInterfaceModel,org/openapitools/codegen/utils/OneOfImplementorAdditionalData.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/OneOfImplementorAdditionalData.java,"/**
     * Add data from a given CodegenModel that the oneOf implementor should implement. For example:
     *
     * @param cm model that the implementor should implement
     * @param modelsImports imports of the given `cm`
     */",59-94,"('addFromInterfaceModel', {'INSTRUCTION': {'covered': 90, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",165.0,13.0,Add data from a given CodegenModel that the oneOf implementor should implement.,Provide the data for the CodegenModel for the oneOf implementor,The one of implementor should add data from the CodegenModel.,0.461521527769203,Add data from a given CodegenModel that the oneOf implementer needs to implement.," public void addFromInterfaceModel(CodegenModel cm, List<Map<String, String>> modelsImports){
        if (cm.isInterface()) {
            additionalInterfaces.add(cm.getName());
            additionalImports.add(cm.getVendorExtensions());
        } else {
            LOGGER.warn(""CodegenModel {} is not an interface, skipping"", cm.getName());
        }       
 }"," public void addFromInterfaceModel(CodegenModel cm, List<Map<String, String>> modelsImports){
        if (cm.isInterface()) {
            additionalInterfaces.add(cm.getName());
            additionalImports.add(cm.getVendorExtensions());
        } else {
            LOGGER.warn(""CodegenModel {} is not an interface, skipping"", cm.getName());
        }       
 }"," public void addFromInterfaceModel(CodegenModel cm, List<Map<String, String>> modelsImports){
        if (cm.isInterface()) {
            LOGGER.debug(""Adding data from interface model: "" + cm.getName());
            this.additionalInterfaces.add(cm.getName());
            this.additionalProps.addAll(cm.getVars());
            this.additionalImports.addAll(modelsImports);
        }       
 }"," public void addFromInterfaceModel(CodegenModel cm, List<Map<String, String>> modelsImports){
        if (cm.isInterface()) {
            LOGGER.debug(""Adding interface {} to implementor {}"", cm.getName(), implementorName);
            additionalInterfaces.add(cm.getName());
            additionalImports.add(cm.getVars());
        }       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.21931422902433476,  0.21931422902433476,  0.224385758208477,  0.23943244576958359,113.0,0.6807228915662651,113.0,0.6807228915662651,114.0,0.6867469879518072,112.0,0.6746987951807228,0.0,0.0,16.0,0.2318840579710145,24.0,0.3037974683544304,8.0,0.6153846153846154,3.0,0.21428571428571427,12.0,0.9230769230769231
473,cdk,"public double calculateScaleForBondLength(double modelBondLength){
    if (Double.isNaN(modelBondLength) || modelBondLength == 0) {
        return DEFAULT_SCALE;
    } else {
        return rendererModel.getParameter(BondLength.class).getValue() / modelBondLength;
    }
}",calculateScaleForBondLength,org/openscience/cdk/renderer/AtomContainerRenderer.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/AtomContainerRenderer.java,"/**
     * Given a bond length for a model, calculate the scale that will transform
     * this length to the on screen bond length in RendererModel.
     *
     * @param modelBondLength the average bond length of the model
     * @return the scale necessary to transform this to a screen bond
     */",256-270,"('calculateScaleForBondLength', {'INSTRUCTION': {'covered': 18, 'missed': 2}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,25.0,"Given a bond length for a model, calculate the scale that will transform  this length to the on screen bond length in RendererModel.",Compute the scale for transforming the bond length to the on screen bond length for the RendererModel,"If you give a bond length for a model, calculate the scale that will transform it to the on screen bond length.",0.210351743948348,"Given the binding length of a model, calculate the scale that will turn that length into the link length on the screen in RendererModel."," public double calculateScaleForBondLength(double modelBondLength){
        double screenBondLength = rendererModel.getParameter(Scale.class).getValue();
        return modelBondLength / screenBondLength;
    }"," public double calculateScaleForBondLength(double modelBondLength){
        double screenBondLength = rendererModel.getParameter(BondLength.class).getValue();
        return screenBondLength / modelBondLength;
    }"," public double calculateScaleForBondLength(double modelBondLength){
        return modelBondLength / rendererModel.getParameter(Scale.class).getValue();
    }"," public double calculateScaleForBondLength(double modelBondLength){
        double screenBondLength = rendererModel.getParameter(BondLength.class).getValue();
        return screenBondLength / modelBondLength;
    }",PASS,PASS,PASS,PASS,  0.4164116182356392,  0.4622056189471217,  0.4622056189471217,  0.4119703048109202,27.0,0.574468085106383,25.0,0.5319148936170213,25.0,0.5319148936170213,24.0,0.5106382978723404,3.0,0.0967741935483871,3.0,0.0967741935483871,8.0,0.25806451612903225,15.0,0.625,11.0,0.44,8.0,0.3333333333333333
474,jackson-databind,"protected JsonMappingException rewrapCtorProblem(DeserializationContext ctxt, Throwable t){
    if ((t instanceof ExceptionInInitializerError) || (t instanceof InvocationTargetException)) {
        Throwable cause = t.getCause();
        if (cause != null) {
            t = cause;
        }
    }
    return wrapAsJsonMappingException(ctxt, t);
}",rewrapCtorProblem,com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java,/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java,"/**
     * Method that subclasses may call for standard handling of an exception thrown when
     * calling constructor or factory method. Will unwrap {@link ExceptionInInitializerError}
     * and {@link InvocationTargetException}s, then call {@link #wrapAsJsonMappingException}.
     *
     * @since 2.7
     */",590-611,"('rewrapCtorProblem', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",57.0,19.0,Method that subclasses may call for standard handling of an exception thrown when  calling constructor or factory method.,Subclasses may call this method for handling standard exception raised when constructors or factory method are called.,Method that subclasses call for standard handling of an exception thrown when calling a factory method,0.381183709852927,A method that subclasses can call for standard handling of an exception thrown when calling a constructor or factory method.," protected JsonMappingException rewrapCtorProblem(DeserializationContext ctxt, Throwable t){
        return ctxt.instantiationException(getValueClass(), t);
    }"," protected JsonMappingException rewrapCtorProblem(DeserializationContext ctxt, Throwable t){
        return ctxt.instantiationException(getValueClass(), t);
    }"," protected JsonMappingException rewrapCtorProblem(DeserializationContext ctxt, Throwable t){
        return ctxt.instantiationException(getValueClass(), t);
    }"," protected JsonMappingException rewrapCtorProblem(DeserializationContext ctxt, Throwable t){
        return ctxt.instantiationException(getValueClass(), t);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2525836732642996,  0.2525836732642996,  0.2525836732642996,  0.2525836732642996,37.0,0.6379310344827587,37.0,0.6379310344827587,37.0,0.6379310344827587,37.0,0.6379310344827587,0.0,0.0,0.0,0.0,0.0,0.0,14.0,0.7368421052631579,4.0,0.19047619047619047,4.0,0.21052631578947367
475,egeria,"public Optional<EntityDetail> findSchemaTypeEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, SCHEMA_TYPE_TYPE_NAME);
}",findSchemaTypeEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineSchemaTypeHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineSchemaTypeHandler.java,"/**
     * Find out if the SchemaType object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the schema type to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",129-145,"('findSchemaTypeEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,13.0,Find out if the SchemaType object is already stored in the repository.,"Check whether the SchemaType object is already stored in the repository, using the fully qualified name.","If the object is already in the repository, you should find it.",0.157638602656076,Check to see if the SchemaType object is already stored in the repository.," public Optional<EntityDetail> findSchemaTypeEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        final String methodName = ""findSchemaTypeEntity"";
    
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateName(qualifiedName, QUALIFIED_NAME_PROPERTY_NAME, methodName);
    
        return schemaTypeHandler.getSchemaTypeByName(userId, qualifiedName, methodName);
    }"," public Optional<EntityDetail> findSchemaTypeEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        final String methodName = ""findSchemaTypeEntity"";
    
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateName(qualifiedName, QUALIFIED_NAME_PROPERTY_NAME, methodName);
    
        return schemaTypeHandler.getSchemaTypeByName(userId, qualifiedName, methodName);
    }"," public Optional<EntityDetail> findSchemaTypeEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        final String methodName = ""findSchemaTypeEntity"";
    
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateName(qualifiedName, QUALIFIED_NAME_PROPERTY_NAME, methodName);
    
        return schemaTypeHandler.findSchemaTypeByName(userId, qualifiedName, methodName);       
 }"," public Optional<EntityDetail> findSchemaTypeEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        final String methodName = ""findSchemaTypeEntity"";
    
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateName(qualifiedName, QUALIFIED_NAME_PROPERTY_NAME, methodName);
    
        return schemaTypeHandler.findSchemaTypeByName(userId, qualifiedName, QUALIFIED_NAME_PROPERTY_NAME, methodName);     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7563412771545781,  0.7563412771545781,  0.7350240810996475,  0.7563412771545781,29.0,0.48333333333333334,29.0,0.48333333333333334,31.0,0.5,29.0,0.48333333333333334,0.0,0.0,3.0,0.04838709677419355,1.0,0.016666666666666666,9.0,0.5294117647058824,3.0,0.21428571428571427,10.0,0.7692307692307693
476,cdk,"static Vector2d sum(final Tuple2d a, final Tuple2d b){
    return new Vector2d(a.x + b.x, a.y + b.y);
}",sum,org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,"/**
     * Sum the components of two vectors, the input is not modified.
     *
     * @param a first vector
     * @param b second vector
     * @return scaled vector
     */",148-157,"('sum', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,13.0,"Sum the components of two vectors, the input is not modified.","Without changing the input, sum the component of the two vectors",The input is not modified.,0.268696802976836,"Add the components of two vectors, the input is not modified.","static Vector2d sum(final Tuple2d a, final Tuple2d b){
        final Vector2d cpy = new Vector2d(a);
        cpy.add(b);
        return cpy;
    }","static Vector2d sum(final Tuple2d a, final Tuple2d b){
        final Vector2d cpy = new Vector2d(a);
        cpy.add(b);
        return cpy;
    }","static Vector2d sum(final Tuple2d a, final Tuple2d b){
        final Vector2d cpy = new Vector2d(a);
        cpy.add(b);
        return cpy;
    }","static Vector2d sum(final Tuple2d a, final Tuple2d b){
        final Vector2d cpy = new Vector2d(a);
        cpy.add(b);
        return cpy;
    }",PASS,PASS,PASS,PASS,  0.49734206818908944,  0.49734206818908944,  0.49734206818908944,  0.49734206818908944,18.0,0.5,18.0,0.5,18.0,0.5,18.0,0.5,0.0,0.0,0.0,0.0,0.0,0.0,11.0,0.9166666666666666,1.0,0.08333333333333333,7.0,0.5833333333333334
477,acs-aem-commons,"public void flushBuffer() throws IOException{
    if (isBuffered()) {
        log.debug(""Prevent committing the response, it will be committed deferred, i.e. once this buffered response is closed"");
        if (log.isDebugEnabled()) {
            Throwable t = new Throwable("""");
            log.debug(""Stacktrace which triggered ServletResponse.flushBuffer()"", t);
        }
        flushWrappedBuffer = true;
    } else {
        wrappedResponse.flushBuffer();
    }
}",flushBuffer,com/adobe/acs/commons/util/BufferedServletOutput.java,/bundle/src/main/java/com/adobe/acs/commons/util/BufferedServletOutput.java,"/**
     * Will not commit the response, but only make sure that the wrapped response's {@code flushBuffer()} is executed, once this {@link #close()} is called.
     * This only affects output which is buffered, i.e. for unbuffered output the flush is not deferred.
     * @throws IOException 
     */",204-220,"('flushBuffer', {'INSTRUCTION': {'covered': 23, 'missed': 3}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,38.0,"Will not commit the response, but only make sure that the wrapped response's {@code flushBuffer()} is executed, once this {@link #close()} is called.","Check that the flushBuffer of the response is executed, without committing the reponse. Finally, it calls the close() method.","Will not commit the response, but only make sure that the wrapped response's @code flushBuffer() is executed.",0.404709064475263,"Do not validate the response, but only make sure that {@code flushBuffer()} of the encapsulated response is executed, once this {@link #close()} is called."," public void flushBuffer() throws IOException{
        flushWrappedBuffer = true;
    }"," public void flushBuffer() throws IOException{
        flushWrappedBuffer = true;
        close();
    }"," public void flushBuffer() throws IOException{
        flushWrappedBuffer = true;
    }"," public void flushBuffer() throws IOException{
        flushWrappedBuffer = true;
    }",PASS,PASS,PASS,PASS,  0.09224001039606959,  0.1276196894635724,  0.09224001039606959,  0.09224001039606959,52.0,0.7878787878787878,49.0,0.7424242424242424,52.0,0.7878787878787878,52.0,0.7878787878787878,4.0,0.2222222222222222,0.0,0.0,0.0,0.0,22.0,0.9166666666666666,8.0,0.32,9.0,0.375
479,weblogic-kubernetes-operator,"public void updateLastKnownServerStatus(String serverName, String status){
    getSko(serverName).getLastKnownStatus().getAndUpdate(lastKnownStatus -> {
        LastKnownStatus updatedStatus = null;
        if (status != null) {
            updatedStatus = (lastKnownStatus != null && status.equals(lastKnownStatus.getStatus())) ? new LastKnownStatus(status, lastKnownStatus.getUnchangedCount() + 1) : new LastKnownStatus(status);
        }
        return updatedStatus;
    });
}",updateLastKnownServerStatus,oracle/kubernetes/operator/helpers/DomainPresenceInfo.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/DomainPresenceInfo.java,"/**
   * Updates the last status reported for the specified server.
   *
   * @param serverName the name of the server
   * @param status the new status
   */",346-366,"('updateLastKnownServerStatus', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,10.0,Updates the last status reported for the specified server.,"GIven a serverName, update the last status reported for the chosen server.",The last status for the server is updated.,0.198929150538017,Updates the last reported state for the specified server.," public void updateLastKnownServerStatus(String serverName, String status){
    getSko(serverName).getLastKnownStatus().set(new LastKnownStatus(status));
  }"," public void updateLastKnownServerStatus(String serverName, String status){
    getSko(serverName).getLastKnownStatus().set(new LastKnownStatus(status));
  }"," public void updateLastKnownServerStatus(String serverName, String status){
    getSko(serverName).getLastKnownStatus().set(new LastKnownStatus(status));
  }"," public void updateLastKnownServerStatus(String serverName, String status){
    getSko(serverName).getLastKnownStatus().set(new LastKnownStatus(status));
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.24265415313687888,  0.24265415313687888,  0.24265415313687888,  0.24265415313687888,55.0,0.6470588235294118,55.0,0.6470588235294118,55.0,0.6470588235294118,55.0,0.6470588235294118,0.0,0.0,0.0,0.0,0.0,0.0,5.0,0.38461538461538464,2.0,0.2,6.0,0.6
481,json-schema-validator,"public static boolean isNumber(JsonNode node, SchemaValidatorsConfig config){
    if (node.isNumber()) {
        return true;
    } else if (config.isTypeLoose()) {
        if (TypeFactory.getValueNodeType(node, config) == JsonType.STRING) {
            return isNumeric(node.textValue());
        }
    }
    return false;
}",isNumber,com/networknt/schema/TypeValidator.java,/src/main/java/com/networknt/schema/TypeValidator.java,"/**
     * Check if the type of the JsonNode's value is number based on the
     * status of typeLoose flag.
     *
     * @param node        the JsonNode to check
     * @param config      the SchemaValidatorsConfig to depend on
     * @return boolean to indicate if it is a number
     */",227-244,"('isNumber', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,19.0,Check if the type of the JsonNode's value is number based on the  status of typeLoose flag.,"Using the typeLoose flag's status, check if the JsonNode's value is a number.",The JsonNode's value is based on the status of the typeLoose flag.,1.02809596518892,Check if the type of the JsonNode value is numbered based on the status of the TypeLoose flag.," public static boolean isNumber(JsonNode node, SchemaValidatorsConfig config){
        if (node == null) {
            return false;
        }
        JsonType nodeType = TypeFactory.getValueNodeType(node, config);
        return nodeType == JsonType.NUMBER || nodeType == JsonType.INTEGER;
    }"," public static boolean isNumber(JsonNode node, SchemaValidatorsConfig config){
        if (node.isNumber()) {
            return true;
        }
        if (node.isTextual()) {
            return isNumeric(node.textValue());
        }
        if (node.isBoolean()) {
            return false;
        }
        if (node.isNull()) {
            return false;
        }
        if (node.isArray()) {
            return false;
        }
        if (node.isObject()) {
            return false;
        }
        if (node.isMissingNode()) {
            return false;
        }
        if (node.isPointer()) {
            return false;
        }
        if (node.isValueNode()) {
            return false;
        }
        if (node.isContainerNode()) {
            return false;
        }
        if (node.isMissing()) {
            return false;
        }
        if (node.isPojo()) {
            return false;
        }
        if (node.isBigInteger()) {
            return true;
        }
        if (node.isBigDecimal()) {
            return true;
        }
        if (node.isInt()) {
            return true;
        }
        if (node.isLong()) {
            return true;
        }
        if (node.isDouble()) {
            return true;
        }
        if (node.isFloat()) {
            return true;
        }
        if (node.isShort()) {
            return true;
        }
        if (node.isByte()) {
            return true;
        }
        if (node.isIntValue()) {
            return true;
        }
        if (node.isLongValue()) {
            return true;
        }
        if (node.isDoubleValue()) {
            return true;
        }
        if (node.isFloatValue()) {
            return true;
        }
        if (node.isShortValue()) {
            return true;
        }
        if (node.isByteValue()) {
            return true;
        }
        if (node.isBigInteger       
 }"," public static boolean isNumber(JsonNode node, SchemaValidatorsConfig config){
        if (node.isNumber()) {
            return true;
        }
        if (node.isTextual()) {
            String text = node.textValue();
            if (text == null || text.equals("""")) {
                return false;
            }
            if (config.isTypeLoose()) {
                return isNumeric(text);
            }
            return isInteger(text) || isNumeric(text);
        }
        return false;
    }"," public static boolean isNumber(JsonNode node, SchemaValidatorsConfig config){
        if (node.isNumber()) {
            return true;
        }
        if (node.isTextual()) {
            String text = node.textValue();
            if (text == null) {
                return false;
            }
            if (config.isTypeLoose()) {
                return isNumeric(text);
            }
            return isInteger(text) || isNumeric(text);
        }
        return false;
    }",PASS,Syntax Error,PASS,PASS,  0.4173376546702206,None,  0.6643816879908394,  0.6551473382805011,35.0,0.5147058823529411,None,None,38.0,0.4367816091954023,43.0,0.4574468085106383,None,None,57.0,0.6551724137931034,64.0,0.6808510638297872,15.0,0.8333333333333334,4.0,0.21052631578947367,8.0,0.4444444444444444
482,cdk,"static HydrogenPosition usingCardinalDirection(final Vector2d opposite){
    final double theta = Math.atan2(opposite.y, opposite.x);
    final int direction = (int) Math.round(theta / (Math.PI / 4));
    switch(direction) {
        case -4:
        case -3:
            return Right;
        case -2:
            return Above;
        case -1:
        case 0:
        case 1:
            return Left;
        case 2:
            return Below;
        case 3:
        case 4:
            return Right;
    }
    return Right;
}",usingCardinalDirection,org/openscience/cdk/renderer/generators/standard/HydrogenPosition.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/HydrogenPosition.java,"/**
     * By snapping to the cardinal direction (compass point) of the provided
     * vector, return the position opposite the 'snapped' coordinate.
     *
     * @param opposite position the hydrogen label opposite to this vector
     * @return the position
     */",238-267,"('usingCardinalDirection', {'INSTRUCTION': {'covered': 24, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",104.0,24.0,"By snapping to the cardinal direction (compass point) of the provided  vector, return the position opposite the 'snapped' coordinate.","Given a vector, it returns the position opposite the 'snapped' coordinate, obtained snapping the cardinal direction of the vector.","By snapping to the cardinal direction of the provided vector, you can return the position opposite the snapped coordinate.",1.04168763884289,"By clinging to the cardinal direction (cardinal point) of the vector provided, return the position opposite to the coordinate ""engaged"".","static HydrogenPosition usingCardinalDirection(final Vector2d opposite){
        if (opposite.x > VERTICAL_THRESHOLD) return Left;
        if (opposite.x < -VERTICAL_THRESHOLD) return Right;
        if (opposite.y > 0) return Above;
        return Below;
    }","static HydrogenPosition usingCardinalDirection(final Vector2d opposite){
        if (opposite.x > VERTICAL_THRESHOLD) return Left;
        else if (opposite.x < -VERTICAL_THRESHOLD) return Right;
        else if (opposite.y > 0) return Above;
        else return Below;
    }","static HydrogenPosition usingCardinalDirection(final Vector2d opposite){
        if (opposite.x > 0.5) return Right;
        if (opposite.x < -0.5) return Left;
        if (opposite.y > 0.5) return Above;
        if (opposite.y < -0.5) return Below;
        return usingDefaultPlacement(null);
    }","static HydrogenPosition usingCardinalDirection(final Vector2d opposite){
        if (opposite.x > 0.5) return Right;
        if (opposite.x < -0.5) return Left;
        if (opposite.y > 0.5) return Above;
        if (opposite.y < -0.5) return Below;
        return usingDefaultPlacement(null);     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2440987629525815,  0.20658369599595927,  0.23306154044458688,  0.23306154044458688,77.0,0.7333333333333333,77.0,0.7333333333333333,78.0,0.7428571428571429,78.0,0.7428571428571429,3.0,0.058823529411764705,20.0,0.31746031746031744,20.0,0.31746031746031744,18.0,0.9,7.0,0.3333333333333333,5.0,0.25
483,cdk,"public int[] transformPoint(double xCoord, double yCoord){
    double[] src = new double[] { xCoord, yCoord };
    double[] dest = new double[2];
    this.transform.transform(src, 0, dest, 0, 1);
    return new int[] { (int) dest[0], (int) dest[1] };
}",transformPoint,org/openscience/cdk/renderer/visitor/AbstractAWTDrawVisitor.java,/display/renderawt/src/main/java/org/openscience/cdk/renderer/visitor/AbstractAWTDrawVisitor.java,"/**
     * Transforms a point according to the current affine transformation,
     * converting a world coordinate into a screen coordinate.
     *
     * @param xCoord x-coordinate of the world point to transform
     * @param yCoord y-coordinate of the world point to transform
     * @return       the transformed screen coordinate
     */",45-58,"('transformPoint', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",80.0,19.0,"Transforms a point according to the current affine transformation,  converting a world coordinate into a screen coordinate.","Given the current affine transformation, change the point converting a world coordinate into a screen coordinate.",A world coordinate is converted into a screen coordinate by transforming a point.,0.648352057852984,"Transforms a point based on the current affine transformation, converting a world coordinate to screen coordinates.","public int[] transformPoint(double xCoord, double yCoord){
        int[] xy = new int[2];
        xy[0] = (int)Math.round(transform.getTranslateX() + transform.getScaleX() * xCoord);
        xy[1] = (int)Math.round(transform.getTranslateY() + transform.getScaleY() * yCoord);
        return xy;
    }","public int[] transformPoint(double xCoord, double yCoord){
        int[] xy = new int[2];
        xy[0] = (int)Math.round(transform.getTranslateX() + transform.getScaleX() * xCoord);
        xy[1] = (int)Math.round(transform.getTranslateY() + transform.getScaleY() * yCoord);
        return xy;
    }","public int[] transformPoint(double xCoord, double yCoord){
        int[] screenCoord = new int[2];
        Point p = new Point((int)xCoord, (int)yCoord);
        transform.transform(p, screenCoord);
        return screenCoord;     
 }","public int[] transformPoint(double xCoord, double yCoord){
        int[] xy = new int[2];
        if (transform != null) {
            double[] xy2 = new double[2];
            xy2[0] = xCoord;
            xy2[1] = yCoord;
            transform.transform(xy2, 0, xy2, 0, 1);
            xy[0] = (int) xy2[0];
            xy[1] = (int) xy2[1];
        } else {
            xy[0] = (int) xCoord;
            xy[1] = (int) yCoord;
        }
        return xy;      
 }",PASS,PASS,PASS,NOT PASS,  0.4258623649636558,  0.40663159573288665,  0.5110734474009276,  0.38034647660965576,54.0,0.6506024096385542,54.0,0.6506024096385542,65.0,0.5158730158730159,50.0,0.6172839506172839,0.0,0.0,74.0,0.5873015873015873,42.0,0.5060240963855421,8.0,0.4444444444444444,5.0,0.2777777777777778,15.0,0.8333333333333334
484,matsim-libs,"private boolean bothLinksAreShorterThanThreshold(Link linkA, Link linkB, double thresholdLength){
    boolean hasTwoShortLinks = false;
    if (linkA.getLength() < thresholdLength && linkB.getLength() < thresholdLength) {
        hasTwoShortLinks = true;
    }
    return hasTwoShortLinks;
}",bothLinksAreShorterThanThreshold,org/matsim/core/network/algorithms/NetworkSimplifier.java,/matsim/src/main/java/org/matsim/core/network/algorithms/NetworkSimplifier.java,"/**
	 * Quick check to see whether <i>both</i> the links are shorter than the 
	 * given threshold.
	 * @param linkA
	 * @param linkB
	 * @param thresholdLength
	 * @return true if <i>both</i> links are shorter than the given threshold, 
	 * false otherwise. 
	 */",293-308,"('bothLinksAreShorterThanThreshold', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,21.0,Quick check to see whether <i>both</i> the links are shorter than the   given threshold.,"Given a couple of links and a thresholdLength, check if both the links are shorted than the threshold.",Check to see if the links are shorter than the threshold.,0.27563263378842,Quickly check if <i>the two</i> links are shorter than the given threshold.," private boolean bothLinksAreShorterThanThreshold(Link linkA, Link linkB, double thresholdLength){
	 		return linkA.getLength() + linkB.getLength() < thresholdLength;
 	}		"," private boolean bothLinksAreShorterThanThreshold(Link linkA, Link linkB, double thresholdLength){
	 		if(linkA.getLength() < thresholdLength && linkB.getLength() < thresholdLength){
 			return true;
 		}
 		return false;		
 }"," private boolean bothLinksAreShorterThanThreshold(Link linkA, Link linkB, double thresholdLength){
	 	return (linkA.getLength() + linkB.getLength()) < thresholdLength;		
 }"," private boolean bothLinksAreShorterThanThreshold(Link linkA, Link linkB, double thresholdLength){
	 	return (linkA.getLength() + linkB.getLength()) < thresholdLength;		
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5761318718945032,  0.7547963186297784,  0.5623060469401506,  0.5623060469401506,19.0,0.3958333333333333,8.0,0.16666666666666666,19.0,0.3958333333333333,19.0,0.3958333333333333,13.0,0.30952380952380953,2.0,0.06060606060606061,2.0,0.06060606060606061,13.0,0.6842105263157895,6.0,0.4,5.0,0.3333333333333333
485,cdk,"static void label(final IAtomContainer container, final int index, final String label){
    final IAtom atom = container.getAtom(index);
    final IPseudoAtom pseudoAtom = atom instanceof IPseudoAtom ? (IPseudoAtom) atom : container.getBuilder().newInstance(IPseudoAtom.class);
    if (atom.equals(pseudoAtom)) {
        pseudoAtom.setLabel(label);
    } else {
        pseudoAtom.setSymbol(label);
        pseudoAtom.setAtomicNumber(atom.getAtomicNumber());
        pseudoAtom.setPoint2d(atom.getPoint2d());
        pseudoAtom.setPoint3d(atom.getPoint3d());
        pseudoAtom.setMassNumber(atom.getMassNumber());
        pseudoAtom.setFormalCharge(atom.getFormalCharge());
        pseudoAtom.setValency(atom.getValency());
        pseudoAtom.setLabel(label);
        AtomContainerManipulator.replaceAtomByAtom(container, atom, pseudoAtom);
    }
}",label,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Labels the atom at the specified index with the provide label. If the
     * atom was not already a pseudo atom then the original atom is replaced.
     *
     * @param container structure
     * @param index     atom index to replace
     * @param label     the label for the atom
     * @see IPseudoAtom#setLabel(String)
     */",1771-1798,"('label', {'INSTRUCTION': {'covered': 62, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",167.0,12.0,Labels the atom at the specified index with the provide label.,"Using the provided label, labels the atom at the passed index. In case of the atom was not already a pseudo atom, we replace the original atom.",The provide label should be used to label the atom.,0.295336520584664,Label the atom at the specified index with the provide label.," static void label(final IAtomContainer container, final int index, final String label){
        container.getAtom(index).setProperty(CDKConstants.ATOM_ATOM_LABEL, label);      
 }"," static void label(final IAtomContainer container, final int index, final String label){
        IAtom atom = container.getAtom(index);
        if(atom.getSymbol().equals(""X"")){
            atom.setSymbol(label);
        }
        else{
            IAtom newAtom = new Atom(label);
            container.replaceAtom(index, newAtom);
        }
    }"," static void label(final IAtomContainer container, final int index, final String label){
        container.getAtom(index).setID(label);      
 }"," static void label(final IAtomContainer container, final int index, final String label){
        container.getAtom(index).setID(label);      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.16447101202078285,  0.3362081856120034,  0.16083626486200914,  0.16083626486200914,137.0,0.8154761904761905,110.0,0.6547619047619048,138.0,0.8214285714285714,138.0,0.8214285714285714,41.0,0.5694444444444444,5.0,0.14285714285714285,5.0,0.14285714285714285,22.0,0.7857142857142857,1.0,0.08333333333333333,10.0,0.8333333333333334
486,cdk,"private static int[] indexElements(Map<IAtom, Integer> map, IStereoElement[] elements, Type[] types, IAtomContainer container){
    int[] indices = new int[container.getAtomCount()];
    int nElements = 0;
    for (IStereoElement element : container.stereoElements()) {
        if (element instanceof ITetrahedralChirality) {
            ITetrahedralChirality tc = (ITetrahedralChirality) element;
            int idx = map.get(tc.getChiralAtom());
            elements[idx] = element;
            types[idx] = Type.Tetrahedral;
            indices[nElements++] = idx;
        } else if (element instanceof IDoubleBondStereochemistry) {
            IDoubleBondStereochemistry dbs = (IDoubleBondStereochemistry) element;
            int idx1 = map.get(dbs.getStereoBond().getBegin());
            int idx2 = map.get(dbs.getStereoBond().getEnd());
            elements[idx2] = elements[idx1] = element;
            types[idx1] = types[idx2] = Type.Geometric;
            indices[nElements++] = idx1;
        }
    }
    return Arrays.copyOf(indices, nElements);
}",indexElements,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,"/**
     * Index the stereo elements of the {@code container} into the the {@code
     * elements} and {@code types} arrays. The {@code map} is used for looking
     * up the index of atoms.
     *
     * @param map       index of atoms
     * @param elements  array to fill with stereo elements
     * @param types     type of stereo element indexed
     * @param container the container to index the elements of
     * @return indices of atoms involved in stereo configurations
     */",351-383,"('indexElements', {'INSTRUCTION': {'covered': 92, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",214.0,27.0,Index the stereo elements of the {@code container} into the the {@code  elements} and {@code types} arrays.,"Set the index of a stereo element of the container into the array of elements and types. For looking up th index of the atoms, we use a map.",The @code container has stereo elements and the @code elements have code types.,1.02551738036246,Index the stereo elements of the {@code container} in the arrays {@code elements} and {@code types}.,"private static int[] indexElements(Map<IAtom, Integer> map, IStereoElement[] elements, Type[] types, IAtomContainer container){
        int[] indices = new int[elements.length];
        for (int i = 0; i < elements.length; i++) {
            IStereoElement element = elements[i];
            if (element instanceof IDoubleBondStereochemistry) {
                IDoubleBondStereochemistry dbs = (IDoubleBondStereochemistry) element;
                IBond bond = dbs.getStereoBond();
                IAtom a1 = bond.getBegin();
                IAtom a2 = bond.getEnd();
                IAtom a3 = bond.getOther(a1);
                IAtom a4 = bond.getOther(a2);
                int i1 = map.get(a1);
                int i2 = map.get(a2);
                int i3 = map.get(a3);
                int i4 = map.get(a4);
                indices[i] = i1 << 16 | i2 << 8 | i3 << 4 | i4;
            } else if (element instanceof ITetrahedralChirality) {
                ITetrahedralChirality chirality = (ITetrahedralChirality) element;
                IAtom[] atoms = chirality.getLigands();
                int[] vs = new int[atoms.length];
                for (int j = 0; j < atoms.length; j++)
                    vs[j] = map.get(atoms[j]);
                indices[i] = permutationParity(vs) * vs.length;
            } else {
                throw new IllegalArgumentException(""Unknown stereo element type: "" + element.getClass());
            }
        }
        return indices;     
 }","private static int[] indexElements(Map<IAtom, Integer> map, IStereoElement[] elements, Type[] types, IAtomContainer container){
        int[] indices = new int[elements.length];
        for (int i = 0; i < elements.length; i++) {
            IStereoElement element = elements[i];
            if (element instanceof ITetrahedralChirality) {
                ITetrahedralChirality chirality = (ITetrahedralChirality) element;
                IAtom[] atoms = chirality.getLigands();
                int[] vs = new int[atoms.length];
                for (int j = 0; j < atoms.length; j++)
                    vs[j] = map.get(atoms[j]);
                indices[i] = vs[0];
                types[i] = Type.Tetrahedral;
            } else if (element instanceof IDoubleBondStereochemistry) {
                IDoubleBondStereochemistry chirality = (IDoubleBondStereochemistry) element;
                IBond bond = chirality.getStereoBond();
                IAtom[] atoms = bond.getAtoms();
                int[] vs = new int[atoms.length];
                for (int j = 0; j < atoms.length; j++)
                    vs[j] = map.get(atoms[j]);
                indices[i] = vs[0];
                types[i] = Type.DoubleBond;
            } else {
                throw new IllegalArgumentException(""Unknown stereo element type: "" + element.getClass());
            }
        }
        return indices;     
 }","private static int[] indexElements(Map<IAtom, Integer> map, IStereoElement[] elements, Type[] types, IAtomContainer container){
        int[] indices = new int[elements.length];
        for (int i = 0; i < elements.length; i++) {
            IStereoElement element = elements[i];
            if (element instanceof ITetrahedralChirality) {
                ITetrahedralChirality chirality = (ITetrahedralChirality) element;
                IAtom[] atoms = chirality.getLigands();
                int[] vs = new int[atoms.length];
                for (int j = 0; j < atoms.length; j++)
                    vs[j] = map.get(atoms[j]);
                indices[i] = vs[0] << 16 | vs[1] << 8 | vs[2];
            } else if (element instanceof IDoubleBondStereochemistry) {
                IDoubleBondStereochemistry chirality = (IDoubleBondStereochemistry) element;
                IAtom[] atoms = chirality.getStereoBond().getAtoms();
                int[] vs = new int[atoms.length];
                for (int j = 0; j < atoms.length; j++)
                    vs[j] = map.get(atoms[j]);
                indices[i] = vs[0] << 16 | vs[1];
            } else if (element instanceof IStereoElement) {
                IAtom[] atoms = element.getAtoms();
                int[] vs = new int[atoms.length];
                for (int j = 0; j < atoms.length; j++)
                    vs[j] = map.get(atoms[j]);
                indices[i] = vs[0] << 16 | vs[1];
            } else {
                throw new IllegalArgumentException(""Unknown stereo element type: "" + element.getClass());
            }
        }
        return indices;     
 }","private static int[] indexElements(Map<IAtom, Integer> map, IStereoElement[] elements, Type[] types, IAtomContainer container){
        int[] indices = new int[elements.length];
        for (int i = 0; i < elements.length; i++) {
            IStereoElement element = elements[i];
            if (element instanceof ITetrahedralChirality) {
                ITetrahedralChirality chirality = (ITetrahedralChirality) element;
                int[] vs = new int[chirality.getLigands().length];
                for (int j = 0; j < vs.length; j++)
                    vs[j] = map.get(chirality.getLigands()[j]);
                Arrays.sort(vs);
                indices[i] = permutationParity(vs);
            } else if (element instanceof IDoubleBondStereochemistry) {
                IDoubleBondStereochemistry stereo = (IDoubleBondStereochemistry) element;
                int[] vs = new int[stereo.getStereoBond().getAtoms().length];
                for (int j = 0; j < vs.length; j++)
                    vs[j] = map.get(stereo.getStereoBond().getAtoms()[j]);
                Arrays.sort(vs);
                indices[i] = permutationParity(vs);
            } else {
                indices[i] = 0;
            }
            types[i] = Type.fromElement(element);
        }
        return indices;     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.47338971485894565,  0.4744155477474967,  0.475496682042004,  0.43597974710834475,191.0,0.6430976430976431,161.0,0.5770609318996416,150.0,0.5474452554744526,229.0,0.6396648044692738,112.0,0.3771043771043771,143.0,0.48148148148148145,153.0,0.4273743016759777,23.0,0.7666666666666667,4.0,0.2222222222222222,16.0,0.8888888888888888
487,tablesaw,"private void processNumberingFunctions(TableSlice slice){
    for (String toColumn : query.getArgumentList().getNumberingFunctions().keySet()) {
        if (rowComparator == null) {
            throw new IllegalArgumentException(""Cannot use Numbering Function without OrderBy"");
        }
        FunctionCall<NumberingFunctions> functionCall = query.getArgumentList().getNumberingFunctions().get(toColumn);
        NumberingFunctions numberingFunctions = functionCall.getFunction();
        NumberingFunction function = numberingFunctions.getImplementation();
        Column<Integer> destinationColumn = (Column<Integer>) destination.column(functionCall.getDestinationColumnName());
        int prevRowNumber = -1;
        for (Row row : slice) {
            if (row.getRowNumber() == 0) {
                function.addNextRow();
            } else {
                if (rowComparator.compare(slice.mappedRowNumber(prevRowNumber), slice.mappedRowNumber(row.getRowNumber())) == 0) {
                    function.addEqualRow();
                } else {
                    function.addNextRow();
                }
            }
            prevRowNumber = row.getRowNumber();
            destinationColumn.set(slice.mappedRowNumber(row.getRowNumber()), function.getValue());
        }
    }
}",processNumberingFunctions,tech/tablesaw/analytic/AnalyticQueryEngine.java,/core/src/main/java/tech/tablesaw/analytic/AnalyticQueryEngine.java,"/**
   * Execute all numbering functions for the given slice setting values in the appropriate
   * destination column.
   */",74-112,"('processNumberingFunctions', {'INSTRUCTION': {'covered': 88, 'missed': 5}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 21, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",217.0,16.0,Execute all numbering functions for the given slice setting values in the appropriate  destination column.,"Select the given slide and execute all numbering functions, setting the values in the correct destination columns.",The numbering functions for the slice setting values should be executed.,0.59140702152715,Perform all numbering functions for the slice parameter values given in the appropriate destination column.," private void processNumberingFunctions(TableSlice slice){
    for (String toColumn : query.getArgumentList().getNumberingFunctions().keySet()) {
      FunctionCall<NumberingFunctions> functionCall =
          query.getArgumentList().getNumberingFunctions().get(toColumn);
  
      NumberingFunctions numberingFunction = functionCall.getFunction();
      Column<?> sourceColumn = query.getTable().column(functionCall.getSourceColumnName());
      validateColumn(numberingFunction, sourceColumn);
  
      Column<?> destinationColumn = destination.column(functionCall.getDestinationColumnName());
      new WindowSlider(
              query.getWindowFrame(), numberingFunction, slice, sourceColumn, destinationColumn)
          .execute();
    }
  }"," private void processNumberingFunctions(TableSlice slice){
    for (String toColumn : query.getArgumentList().getNumberingFunctions().keySet()) {
      FunctionCall<NumberingFunctions> functionCall =
          query.getArgumentList().getNumberingFunctions().get(toColumn);
  
      NumberingFunctions numberingFunction = functionCall.getFunction();
      Column<?> sourceColumn = query.getTable().column(functionCall.getSourceColumnName());
      validateColumn(numberingFunction, sourceColumn);
  
      Column<?> destinationColumn = destination.column(functionCall.getDestinationColumnName());
      new WindowSlider(
              query.getWindowFrame(), numberingFunction, slice, sourceColumn, destinationColumn)
          .execute();
    }
  }"," private void processNumberingFunctions(TableSlice slice){
    for (String toColumn : query.getArgumentList().getNumberingFunctions().keySet()) {
      FunctionCall<NumberingFunctions> functionCall =
          query.getArgumentList().getNumberingFunctions().get(toColumn);
  
      NumberingFunctions numberingFunction = functionCall.getFunction();
      Column<?> sourceColumn = query.getTable().column(functionCall.getSourceColumnName());
      validateColumn(numberingFunction, sourceColumn);
  
      Column<?> destinationColumn = destination.column(functionCall.getDestinationColumnName());
      new WindowSlider(
              query.getWindowFrame(), numberingFunction, slice, sourceColumn, destinationColumn)
          .execute();
    }
  }"," private void processNumberingFunctions(TableSlice slice){
    for (String toColumn : query.getArgumentList().getNumberingFunctions().keySet()) {
      FunctionCall<NumberingFunctions> functionCall =
          query.getArgumentList().getNumberingFunctions().get(toColumn);
  
      NumberingFunctions numberingFunction = functionCall.getFunction();
      Column<?> sourceColumn = query.getTable().column(functionCall.getSourceColumnName());
      validateColumn(numberingFunction, sourceColumn);
  
      Column<?> destinationColumn = destination.column(functionCall.getDestinationColumnName());
      new WindowSlider(
              query.getWindowFrame(), numberingFunction, slice, sourceColumn, destinationColumn)
          .execute();
    }
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.40586377562087006,  0.40586377562087006,  0.40586377562087006,  0.40155343079328387,124.0,0.5688073394495413,124.0,0.5688073394495413,124.0,0.5688073394495413,124.0,0.5688073394495413,0.0,0.0,0.0,0.0,0.0,0.0,12.0,0.6666666666666666,4.0,0.25,8.0,0.5
488,matsim-libs,"Scenario loadScenario(){
    // String currentDir = new File(""tmp"").getAbsolutePath();
    // currentDir = currentDir.substring(0, currentDir.length() - 3);
    // log.info(""loading scenario from base directory: "" + currentDir);
    // the above is not used and thus only causing confusion in the log output.  kai, sep'18
    this.loadNetwork();
    this.loadActivityFacilities();
    this.loadPopulation();
    // tests internally if the file is there
    this.loadHouseholds();
    // tests internally if the file is there
    this.loadTransit();
    // tests internally if the file is there
    this.loadTransitVehicles();
    if (this.config.vehicles().getVehiclesFile() != null) {
        this.loadVehicles();
    }
    if (this.config.network().getLaneDefinitionsFile() != null) {
        this.loadLanes();
    }
    return this.scenario;
}",loadScenario,org/matsim/core/scenario/ScenarioLoaderImpl.java,/matsim/src/main/java/org/matsim/core/scenario/ScenarioLoaderImpl.java,"/**
	 * Loads all mandatory Scenario elements and
	 * if activated in config's scenario module/group
	 * optional elements.
	 * @return the Scenario
	 */",101-126,"('loadScenario', {'INSTRUCTION': {'covered': 27, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",95.0,16.0,Loads all mandatory Scenario elements and  if activated in config's scenario module/group  optional elements.,Return a scenario after loading all mandatory scenario elements and the one activated in config's scneario module and group.,"If activated in the scenario module, loads all mandatory Scenario elements.",0.57089295773783,"Loads all required scenario elements and, if enabled in the config scenario module/group, optional elements."," Scenario loadScenario(){
	 	loadNetwork();
 	loadPopulation();
 	loadFacilities();
 	loadTransitSchedule();
 	loadVehicles();
 	loadHouseholds();
 	loadNetworkChangeEvents();
 	loadLanes();
 	loadObjectAttributes();
 	return scenario;		
 }"," Scenario loadScenario(){
	 	loadNetwork();
 	loadPopulation();
 	loadFacilities();
 	loadTransitSchedule();
 	loadVehicles();
 	loadHouseholds();
 	loadLanes();
 	loadNetworkChangeEvents();
 	loadObjectAttributes();
 	return scenario;
 }"," Scenario loadScenario(){
	 	loadNetwork();
 	loadTransitSchedule();
 	loadPopulation();
 	loadHouseholds();
 	loadFacilities();
 	loadVehicles();
 	loadNetworkChangeEvents();
 	loadLanes();
 	return scenario;
 }"," Scenario loadScenario(){
	 	loadNetwork();
 	loadTransitSchedule();
 	loadPopulation();
 	loadHouseholds();
 	loadFacilities();
 	loadVehicles();
 	loadNetworkChangeEvents();
 	loadLanes();
 	return scenario;
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.16276059769373424,  0.16276059769373424,  0.15735401532655452,  0.15735401532655452,59.0,0.6145833333333334,59.0,0.6145833333333334,58.0,0.6041666666666666,58.0,0.6041666666666666,2.0,0.043478260869565216,9.0,0.1956521739130435,9.0,0.1956521739130435,12.0,0.6,7.0,0.4375,13.0,0.8666666666666667
489,cdk,"public static List<List<CDKRMap>> makeAtomsMapsOfBondsMaps(List<List<CDKRMap>> list, IAtomContainer sourceGraph, IAtomContainer targetGraph){
    if (list == null) {
        return list;
    }
    if (targetGraph.getAtomCount() == 1) {
        return list;
    }
    List<List<CDKRMap>> result = new ArrayList<List<CDKRMap>>();
    for (List<CDKRMap> l2 : list) {
        result.add(makeAtomsMapOfBondsMap(l2, sourceGraph, targetGraph));
    }
    return result;
}",makeAtomsMapsOfBondsMaps,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,"/**
     *  This makes maps of matching atoms out of atom maps of matching bonds as produced by the get(Subgraph|Ismorphism)Maps methods.
     *
     * @param  list   The list produced by the getMap method.
     * @param  sourceGraph  The first atom container. Must not be atom IQueryAtomContainer.
     * @param  targetGraph  The second one (first and second as in getMap). May be an QueryAtomContaienr.
     * @return     A Vector of Vectors of CDKRMap objects of matching Atoms.
     */",686-707,"('makeAtomsMapsOfBondsMaps', {'INSTRUCTION': {'covered': 32, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",103.0,24.0,This makes maps of matching atoms out of atom maps of matching bonds as produced by the get(Subgraph|Ismorphism)Maps methods.,Returns a vector of vectors of CDKRMap objects that are maps of matching atoms and bonds as produced by the get(Subgraph|Ismorphism)Maps methods.,Maps of matching atoms are created by using the get(Subgraph)IsmorphismMaps methods.,0.513923222556707,This makes maps of corresponding atoms from maps of atoms of corresponding bonds as produced by the get(Subgraph| Ismorphism)Mapping methods.," public static List<List<CDKRMap>> makeAtomsMapsOfBondsMaps(List<List<CDKRMap>> list, IAtomContainer sourceGraph, IAtomContainer targetGraph){
        List<List<CDKRMap>> newList = new ArrayList<List<CDKRMap>>();
        for (List<CDKRMap> l : list){
            List<CDKRMap> newL = new ArrayList<CDKRMap>();
            for (CDKRMap r : l){
                newL.add(new CDKRMap(sourceGraph.getAtom(r.getSource()), targetGraph.getAtom(r.getTarget())));
            }
            newList.add(newL);
        }
        return newList;
    }","public static List<List<CDKRMap>> makeAtomsMapsOfBondsMaps(List<List<CDKRMap>> list, IAtomContainer sourceGraph, IAtomContainer targetGraph){
        List<List<CDKRMap>> newList = new ArrayList<List<CDKRMap>>();
        for (List<CDKRMap> list1 : list) {
            List<CDKRMap> newList1 = new ArrayList<CDKRMap>();
            for (CDKRMap rMap : list1) {
                if (rMap.getAtomIndex() < sourceGraph.getAtomCount()) {
                    newList1.add(new CDKRMap(rMap.getAtomIndex(), rMap.getBondIndex()));
                } else {
                    newList1.add(new CDKRMap(rMap.getAtomIndex() - sourceGraph.getAtomCount(), rMap.getBondIndex()));
                }
            }
            newList.add(newList1);
        }
        return newList;
    }","public static List<List<CDKRMap>> makeAtomsMapsOfBondsMaps(List<List<CDKRMap>> list, IAtomContainer sourceGraph, IAtomContainer targetGraph){
        List<List<CDKRMap>> newList = new ArrayList<List<CDKRMap>>();
        for (List<CDKRMap> list1 : list) {
            List<CDKRMap> newList1 = new ArrayList<CDKRMap>();
            for (CDKRMap rMap : list1) {
                CDKRMap newRMap = new CDKRMap(rMap.getSource(), rMap.getTarget());
                newList1.add(newRMap);
            }
            newList.add(newList1);
        }
        return newList;
    }","public static List<List<CDKRMap>> makeAtomsMapsOfBondsMaps(List<List<CDKRMap>> list, IAtomContainer sourceGraph, IAtomContainer targetGraph){
        List<List<CDKRMap>> newList = new ArrayList<List<CDKRMap>>();
        for (List<CDKRMap> list1 : list) {
            List<CDKRMap> newList1 = new ArrayList<CDKRMap>();
            for (CDKRMap map : list1) {
                newList1.add(new CDKRMap(map.getAtomMap(sourceGraph), map.getAtomMap(targetGraph)));
            }
            newList.add(newList1);
        }
        return newList;     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6326871945278014,  0.5574831248744072,  0.6376446580084687,  0.5577631239943377,70.0,0.56,103.0,0.639751552795031,61.0,0.5213675213675214,68.0,0.5666666666666667,51.0,0.3167701863354037,20.0,0.16,25.0,0.2,11.0,0.4782608695652174,8.0,0.38095238095238093,14.0,0.7
490,acs-aem-commons,"private void checkValidity(ReplicationAction action, String path) throws ReplicationException{
    if (action.getType() != ReplicationActionType.ACTIVATE && action.getType() != ReplicationActionType.TEST) {
        logErrorMessage(""No re-fetch handling for replication action "" + action.getType().getName());
        throw new ReplicationException(""No re-fetch handling for replication action "" + action.getType().getName());
    }
    if (StringUtils.isEmpty(path)) {
        logErrorMessage(""No path found for re-fetch replication."");
        throw new ReplicationException(""No path found for re-fetch replication."");
    }
    if (!CONTENT_BUILDER_NAME.equals(action.getConfig().getSerializationType())) {
        String message = ""Serialization type '"" + action.getConfig().getSerializationType() + ""' not supported by Flush Re-Fetch Content Builder."";
        logErrorMessage(message);
        throw new ReplicationException(message);
    }
}",checkValidity,com/adobe/acs/commons/replication/dispatcher/impl/RefetchFlushContentBuilderImpl.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/impl/RefetchFlushContentBuilderImpl.java,"/**
     * Check the validity of the parameters received for this activation.
     *
     * @param action The replication action specifying properties of the activation.
     * @param path The path to the item to be activated.
     * @throws ReplicationException Throws a replication exception if invalid.
     */",274-299,"('checkValidity', {'INSTRUCTION': {'covered': 73, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",142.0,11.0,Check the validity of the parameters received for this activation.,"Given a parameter for the activation, check if it is valid.",The validity of the parameters received for this activation is checked.,0.468845264830202,Check the validity of the settings received for this activation.," private void checkValidity(ReplicationAction action, String path) throws ReplicationException{
        if (action == null) {
            throw new ReplicationException(""No replication action found on agent "" + CONTENT_BUILDER_NAME);
        }
    
        if (path == null) {
            throw new ReplicationException(""No path found on agent "" + CONTENT_BUILDER_NAME);
        }
    
        if (action.getType() != ReplicationAction.Type.REPLICATE) {
            throw new ReplicationException(""Invalid replication action type on agent "" + CONTENT_BUILDER_NAME);
        }
    
        if (action.getConfig() == null) {
            throw new ReplicationException(""No replication configuration found on agent "" + CONTENT_BUILDER_NAME);
        }
    
        if (action.getConfig().getSerializationType() != ReplicationAction.SerializationType.POST) {
            throw new ReplicationException(""Invalid serialization type on agent "" + CONTENT_BUILDER_NAME);
        }       
 }"," private void checkValidity(ReplicationAction action, String path) throws ReplicationException{
        if (action.getType() != ReplicationAction.Type.ACTIVATE) {
            throw new ReplicationException(""Content builder "" + CONTENT_BUILDER_NAME + "" can only be used with ""
                    + ""ACTIVATE actions."");
        }
    
        if (StringUtils.isEmpty(path)) {
            throw new ReplicationException(""Content builder "" + CONTENT_BUILDER_NAME + "" can only be used with ""
                    + ""ACTIVATE actions that have a path."");
        }       
 }"," private void checkValidity(ReplicationAction action, String path) throws ReplicationException{
        if (action == null) {
            throw new ReplicationException(""Replication action is null"");
        }
    
        if (path == null) {
            throw new ReplicationException(""Replication path is null"");
        }
    
        if (action.getType() == null) {
            throw new ReplicationException(""Replication action type is null"");
        }
    
        if (action.getConfig() == null) {
            throw new ReplicationException(""Replication action config is null"");
        }
    
        if (action.getConfig().getSerializationType() == null) {
            throw new ReplicationException(""Replication action serialization type is null"");
        }       
 }"," private void checkValidity(ReplicationAction action, String path) throws ReplicationException{
        if (action == null) {
            throw new ReplicationException(""Replication action is null"");
        }
    
        if (path == null) {
            throw new ReplicationException(""Replication path is null"");
        }
    
        if (path.isEmpty()) {
            throw new ReplicationException(""Replication path is empty"");
        }
    
        if (path.startsWith(""/"")) {
            throw new ReplicationException(""Replication path cannot start with /"");
        }
    
        if (path.endsWith(""/"")) {
            throw new ReplicationException(""Replication path cannot end with /"");
        }
    
        if (path.contains(""//"")) {
            throw new ReplicationException(""Replication path cannot contain //"");
        }
    
        if (path.contains("".."")) {
            throw new ReplicationException(""Replication path cannot contain .."");
        }
    
        if (path.contains(""*"")) {
            throw new ReplicationException(""Replication path cannot contain *"");
        }
    
        if (path.contains(""?"")) {
            throw new ReplicationException(""Replication path cannot contain ?"");
        }
    
        if (path.contains(""\"""")) {
            throw new ReplicationException(""Replication path cannot contain \"""");
        }",NOT PASS,NOT PASS,Syntax Error,NOT PASS,  0.4220339262880747,  0.2810912851558459,None,  0.3550794519973215,83.0,0.5804195804195804,88.0,0.6153846153846154,111.0,0.5935828877005348,78.0,0.5454545454545454,73.0,0.5887096774193549,106.0,0.5668449197860963,27.0,0.21774193548387097,10.0,0.8333333333333334,1.0,0.09090909090909091,5.0,0.4166666666666667
491,cdk,"public boolean isIdentity(){
    for (int i = 0; i < this.values.length; i++) {
        if (this.values[i] != i) {
            return false;
        }
    }
    return true;
}",isIdentity,org/openscience/cdk/group/Permutation.java,/tool/group/src/main/java/org/openscience/cdk/group/Permutation.java,"/**
     * Check to see if this permutation is the identity permutation.
     *
     * @return true if for all i, p[i] = i
     */",98-110,"('isIdentity', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,11.0,Check to see if this permutation is the identity permutation.,Check whether the permutation is the identity permutation.,"If this permutation is the identity permutation, you should check it.",0.725224532941888,Check if this swap is the identity swap.,"public boolean isIdentity(){
        for (int i = 0; i < values.length; i++) {
            if (values[i] != i) return false;
        }
        return true;
    }","public boolean isIdentity(){
        for (int i = 0; i < values.length; i++) {
            if (values[i] != i) return false;
        }
        return true;
    }","public boolean isIdentity(){
        for (int i = 0; i < values.length; i++) {
            if (values[i] != i) {
                return false;
            }
        }
        return true;
    }","public boolean isIdentity(){
        for (int i = 0; i < values.length; i++) {
            if (values[i] != i) {
                return false;
            }
        }
        return true;
    }",PASS,PASS,PASS,PASS,  0.730387585554588,  0.730387585554588,  0.7910815293007447,  0.7910815293007447,6.0,0.1276595744680851,6.0,0.1276595744680851,4.0,0.0851063829787234,4.0,0.0851063829787234,0.0,0.0,2.0,0.046511627906976744,2.0,0.046511627906976744,4.0,0.36363636363636365,4.0,0.36363636363636365,9.0,0.75
492,matsim-libs,"public boolean add(final E o, final double priority){
    if (o == null) {
        throw new NullPointerException();
    }
    PseudoEntry<E> entry = new PseudoEntry<E>(o, priority);
    if (this.lastEntry.containsKey(o)) {
        return false;
    }
    if (this.delegate.add(entry)) {
        this.lastEntry.put(o, entry);
        return true;
    }
    // this should never happen
    return false;
}",add,org/matsim/core/utils/collections/PseudoRemovePriorityQueue.java,/matsim/src/main/java/org/matsim/core/utils/collections/PseudoRemovePriorityQueue.java,"/**
	 * Adds the specified element to this priority queue, with the given priority.
	 * @param o
	 * @param priority
	 * @return <tt>true</tt> if the element was added to the collection.
	 */",59-79,"('add', {'INSTRUCTION': {'covered': 32, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,14.0,"Adds the specified element to this priority queue, with the given priority.","Given an element and a priority, add that element to the priority queue.",The specified element is added to the priority queue.,0.260794300237494,"Adds the specified item to this priority queue, with the priority given."," public boolean add(final E o, final double priority){
	 	if (this.lastEntry.containsKey(o)) {
 		throw new IllegalStateException(""Element "" + o + "" is already in the queue."");
 	}
 	final PseudoEntry<E> entry = new PseudoEntry<E>(o, priority);
 	this.lastEntry.put(o, entry);
 	this.delegate.add(entry);
 	return true;		
 }"," public boolean add(final E o, final double priority){
	 	if (this.lastEntry.containsKey(o)) {
 		throw new IllegalStateException(""Element "" + o + "" is already in the queue."");
 	}
 	final PseudoEntry<E> entry = new PseudoEntry<E>(o, priority);
 	this.lastEntry.put(o, entry);
 	this.delegate.add(entry);
 	return true;		
 }"," public boolean add(final E o, final double priority){
	 	if (this.lastEntry.containsKey(o)) {
 		return false;
 	}
 	final PseudoEntry<E> entry = new PseudoEntry<E>(o, priority);
 	this.lastEntry.put(o, entry);
 	this.delegate.add(entry);
 	return true;		
 }"," public boolean add(final E o, final double priority){
	 	if (this.lastEntry.containsKey(o)) {
 		return false;
 	}
 	final PseudoEntry<E> entry = new PseudoEntry<E>(o, priority);
 	this.lastEntry.put(o, entry);
 	this.delegate.add(entry);
 	return true;		
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6976751130287318,  0.6976751130287318,  0.7022447601867639,  0.7022447601867639,42.0,0.45652173913043476,42.0,0.45652173913043476,40.0,0.43478260869565216,40.0,0.43478260869565216,0.0,0.0,10.0,0.125,10.0,0.125,12.0,0.8571428571428571,3.0,0.23076923076923078,9.0,0.6923076923076923
493,acs-aem-commons,"public AdapterType adaptTo(Class<AdapterType> type){
    AdapterType result = null;
    synchronized (this) {
        result = (AdapterType) this.adaptersCache.get(type);
        if (result == null) {
            AdapterManager mgr = Activator.getAdapterManager();
            if (mgr == null) {
                LOG.warn(""Unable to adapt request for path {} to {} because AdapterManager is null"", this.resource.getPath(), type);
            } else {
                result = mgr.getAdapter(this, type);
            }
            if (result != null) {
                this.adaptersCache.put(type, result);
            }
        }
        return result;
    }
}",adaptTo,com/adobe/acs/commons/util/OverridePathSlingRequestWrapper.java,/bundle/src/main/java/com/adobe/acs/commons/util/OverridePathSlingRequestWrapper.java,"/**
     * Overriding `adaptTo` to avoid using the original request as the adaptable.
     */",129-152,"('adaptTo', {'INSTRUCTION': {'covered': 34, 'missed': 8}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 10, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",115.0,14.0,Overriding `adaptTo` to avoid using the original request as the adaptable.,"In order to avoid the use of the orignal request as the adaptable, override the 'adaptTo' method.",To avoid using the original request as an adapted one.,0.436788666735597,Replace 'adaptTo' to avoid using the original query as adaptable.," public AdapterType adaptTo(Class<AdapterType> type){
        if (adaptersCache.containsKey(type)) {
            return (AdapterType) adaptersCache.get(type);
        }
    
        AdapterType adapter = null;
        AdapterManager adapterManager = getSlingRequest().getResourceResolver().adaptTo(AdapterManager.class);
        if (adapterManager != null) {
            adapter = adapterManager.getAdapter(this, type);
        }
    
        if (adapter != null) {
            adaptersCache.put(type, adapter);
        }
    
        return adapter;
    }"," public AdapterType adaptTo(Class<AdapterType> type){
        if (type == null) {
            return null;
        }
    
        if (this.adaptersCache.containsKey(type)) {
            return (AdapterType) this.adaptersCache.get(type);
        }
    
        AdapterType adapter = null;
        if (type.isInstance(this)) {
            adapter = (AdapterType) this;
        } else {
            adapter = this.resource.adaptTo(type);
        }
    
        if (adapter != null) {
            this.adaptersCache.put(type, adapter);
        }
    
        return adapter;
    }"," public AdapterType adaptTo(Class<AdapterType> type){
        return null;        
 }"," public AdapterType adaptTo(Class<AdapterType> type){
        if (type == null) {
            return null;
        }
        if (this.adaptersCache.containsKey(type)) {
            return (AdapterType) this.adaptersCache.get(type);
        }
        AdapterType adapter = null;
        if (type.isInterface()) {
            adapter = getSlingRequest().adaptTo(type);
        } else {
            adapter = getSlingRequest().getResourceResolver().adaptTo(type);
        }
        if (adapter != null) {
            this.adaptersCache.put(type, adapter);
        }
        return adapter;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.39310198509501393,  0.4351228205933953,  0.4617440966700777,  0.05955681430725865,52.0,0.4482758620689655,59.0,0.5086206896551724,61.0,0.5258620689655172,101.0,0.8706896551724138,42.0,0.3853211009174312,44.0,0.3793103448275862,81.0,0.8350515463917526,11.0,0.6111111111111112,4.0,0.3333333333333333,6.0,0.5
494,weblogic-kubernetes-operator," static boolean mapEquals(Map<K, V> first, Map<K, V> second){
    return Objects.equals(first, second) || (isNullOrEmpty(first) && isNullOrEmpty(second));
}",mapEquals,oracle/kubernetes/operator/helpers/KubernetesUtils.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/KubernetesUtils.java,"/**
   * Returns true if the two maps of values match. A null map is considered to match an empty map.
   *
   * @param first  the first map to compare
   * @param second the second map to compare
   * @return true if the maps match.
   */",28-37,"('mapEquals', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,10.0,Returns true if the two maps of values match.,Returns true if the two maps match; if the map is null we consider a match with an empty map.,"If the two maps of values match, this is true.",1.18640110256941,Returns true if the two value cards match.,"  static boolean mapEquals(Map<K, V> first, Map<K, V> second){
    if (first == second) {
      return true;
    }
    if (first == null || second == null) {
      return false;
    }
    if (first.size() != second.size()) {
      return false;
    }
    for (Map.Entry<K, V> entry : first.entrySet()) {
      if (!second.containsKey(entry.getKey())) {
        return false;
      }
      if (!Objects.equals(entry.getValue(), second.get(entry.getKey()))) {
        return false;
      }
    }
    return true;      
  }","  static boolean mapEquals(Map<K, V> first, Map<K, V> second){
    if (first == null) {
      return second == null || second.isEmpty();
    }
    if (second == null) {
      return first.isEmpty();
    }
    return first.equals(second);      
  }","  static boolean mapEquals(Map<K, V> first, Map<K, V> second){
    if (first == second) {
      return true;
    }
    if (first == null || second == null) {
      return false;
    }
    if (first.size() != second.size()) {
      return false;
    }
    for (Map.Entry<K, V> entry : first.entrySet()) {
      if (!second.containsKey(entry.getKey())) {
        return false;
      }
      if (!Objects.equals(entry.getValue(), second.get(entry.getKey()))) {
        return false;
      }
    }
    return true;      
  }","  static boolean mapEquals(Map<K, V> first, Map<K, V> second){
    if (first == null && second == null) {
      return true;
    }
    if (first == null || second == null) {
      return false;
    }
    if (first.size() != second.size()) {
      return false;
    }
    for (Map.Entry<K, V> entry : first.entrySet()) {
      if (!second.containsKey(entry.getKey())) {
        return false;
      }
      if (!Objects.equals(entry.getValue(), second.get(entry.getKey()))) {
        return false;
      }
    }
    return true;      
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5791065044367023,  0.6486624193143722,  0.5743440707737328,  0.5791065044367023,103.0,0.7357142857142858,33.0,0.5076923076923077,107.0,0.7430555555555556,103.0,0.7357142857142858,86.0,0.6142857142857143,4.0,0.027777777777777776,0.0,0.0,14.0,0.6666666666666666,3.0,0.3,7.0,0.6363636363636364
495,acs-aem-commons,"private List<Pattern> compileToPatterns(final List<String> regexes){
    final List<Pattern> patterns = new ArrayList<Pattern>();
    for (String regex : regexes) {
        if (StringUtils.isNotBlank(regex)) {
            patterns.add(Pattern.compile(regex));
        }
    }
    return patterns;
}",compileToPatterns,com/adobe/acs/commons/httpcache/config/impl/HttpCacheConfigImpl.java,/bundle/src/main/java/com/adobe/acs/commons/httpcache/config/impl/HttpCacheConfigImpl.java,"/**
     * Converts an array of Regex strings into compiled Patterns.
     *
     * @param regexes the regex strings to compile into Patterns
     * @return the list of compiled Patterns
     */",313-329,"('compileToPatterns', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,10.0,Converts an array of Regex strings into compiled Patterns.,"Given a list of regexes, converst these regexes into compiled patterns adding the result in a new patterns list.",A string is converted into a pattern.,0.302821686216636,Converts an array of Regex strings to compiled templates.," private List<Pattern> compileToPatterns(final List<String> regexes){
        List<Pattern> patterns = new ArrayList<Pattern>();
        for (String regex : regexes) {
            patterns.add(Pattern.compile(regex));
        }
        return patterns;
    }"," private List<Pattern> compileToPatterns(final List<String> regexes){
        List<Pattern> patterns = new ArrayList<Pattern>();
        for (String regex : regexes) {
            patterns.add(Pattern.compile(regex));
        }
        return patterns;
    }"," private List<Pattern> compileToPatterns(final List<String> regexes){
        List<Pattern> patterns = new ArrayList<Pattern>();
        for (String regex : regexes) {
            patterns.add(Pattern.compile(regex));
        }
        return patterns;
    }"," private List<Pattern> compileToPatterns(final List<String> regexes){
        List<Pattern> patterns = new ArrayList<Pattern>();
        for (String regex : regexes) {
            patterns.add(Pattern.compile(regex));
        }
        return patterns;
    }",PASS,PASS,NOT PASS,PASS,  0.7817666827746774,  0.7817666827746774,  0.7817666827746774,  0.7817666827746774,12.0,0.1791044776119403,12.0,0.1791044776119403,12.0,0.1791044776119403,12.0,0.1791044776119403,0.0,0.0,0.0,0.0,0.0,0.0,16.0,0.8,2.0,0.2,8.0,0.8
496,cdk,"public static float calculate(Map<String, Integer> features1, Map<String, Integer> features2){
    TreeSet<String> keys = new TreeSet<String>(features1.keySet());
    keys.addAll(features2.keySet());
    float sum = 0.0f;
    for (String key : keys) {
        Integer c1 = features1.get(key);
        Integer c2 = features2.get(key);
        c1 = c1 == null ? 0 : c1;
        c2 = c2 == null ? 0 : c2;
        sum += 1.0 - Math.abs(c1 - c2) / (c1 + c2);
    }
    return sum / keys.size();
}",calculate,org/openscience/cdk/similarity/LingoSimilarity.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/similarity/LingoSimilarity.java,"/**
     * Evaluate the LINGO similarity between two key,value sty;e fingerprints.
     *
     * The value will range from 0.0 to 1.0.
     *
     * @param features1
     * @param features2
     * @return similarity
     */",45-69,"('calculate', {'INSTRUCTION': {'covered': 72, 'missed': 4}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",135.0,14.0,"Evaluate the LINGO similarity between two key,value sty;e fingerprints.","Compute the LINGO similarity between the (key,value) and the (style, fingerprint) The similiary will range from 0.0 to 1.0",Evaluate the similarity between two fingerprints.,0.584847087544318,"Assess the LINGO similarity between two key fingerprints, sty;e values.","public static float calculate(Map<String, Integer> features1, Map<String, Integer> features2){
      int intersection = 0;
      int union = 0;
      for (String key : features1.keySet()) {
          if (features2.containsKey(key)) {
              intersection += features1.get(key);
          }
          union += features1.get(key);
      }
      for (String key : features2.keySet()) {
          if (!features1.containsKey(key)) {
              union += features2.get(key);
          }
      }
      return (float)intersection / (float)union;  
 }","public static float calculate(Map<String, Integer> features1, Map<String, Integer> features2){
      float similarity = 0.0f;
      int total = 0;
      for (String key : features1.keySet()) {
          if (features2.containsKey(key)) {
              int value1 = features1.get(key);
              int value2 = features2.get(key);
              similarity += value1 * value2;
              total += value1 * value1;
          }
      }
      for (String key : features2.keySet()) {
          if (!features1.containsKey(key)) {
              int value2 = features2.get(key);
              total += value2 * value2;
          }
      }
      return similarity / (float) Math.sqrt(total); 
 }",Not Valid,"public static float calculate(Map<String, Integer> features1, Map<String, Integer> features2){
      int intersection = 0;
      int union = 0;
      for (String key : features1.keySet()) {
          if (features2.containsKey(key)) {
              intersection += features1.get(key);
              union += features2.get(key);
          }
      }
      for (String key : features2.keySet()) {
          if (!features1.containsKey(key)) {
              union += features2.get(key);
          }
      }
      return (float) intersection / (float) union;  
 }",NOT PASS,NOT PASS,NOT PASS,Not Valid,  0.358537830723782,  0.44449637727473335,  0.3644902116761629,None,81.0,0.5955882352941176,90.0,0.625,80.0,0.5882352941176471,None,None,40.0,0.2777777777777778,3.0,0.024793388429752067,None,None,15.0,0.75,4.0,0.36363636363636365,3.0,0.3
497,weblogic-kubernetes-operator,"public static String accessContinue(Object result){
    return Optional.ofNullable(result).filter(KubernetesListObject.class::isInstance).map(KubernetesListObject.class::cast).map(KubernetesListObject::getMetadata).map(V1ListMeta::getContinue).filter(Predicate.not(String::isEmpty)).orElse(null);
}",accessContinue,oracle/kubernetes/operator/calls/AsyncRequestStep.java,/operator/src/main/java/oracle/kubernetes/operator/calls/AsyncRequestStep.java,"/**
   * Access continue field, if any, from list metadata.
   * @param result Kubernetes list result
   * @return Continue value
   */",133-146,"('accessContinue', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,11.0,"Access continue field, if any, from list metadata.","From a list containing metadata, access the continue field.","If there is any access from the list scenography, the continue field is needed.",0.554546954704016,"Continue access, if any, from the list metadata field.","public static String accessContinue(Object result){
    if (result instanceof KubernetesListObject) {
      KubernetesListObject list = (KubernetesListObject) result;
      V1ListMeta meta = list.getMetadata();
      if (meta != null) {
        return meta.getContinue();
      }
    }
    return null;    
 }","public static String accessContinue(Object result){
    if (result instanceof KubernetesListObject) {
      KubernetesListObject list = (KubernetesListObject) result;
      V1ListMeta meta = list.getMetadata();
      if (meta != null) {
        return meta.getContinue();
      }
    }
    return null;    
 }","public static String accessContinue(Object result){
    if (result instanceof KubernetesListObject) {
      KubernetesListObject list = (KubernetesListObject) result;
      if (list.getMetadata() != null) {
        V1ListMeta meta = list.getMetadata();
        if (meta.getContinue() != null) {
          return meta.getContinue();
        }
      }
    }
    return null;    
 }"," public static String accessContinue(Object result){
    if (result instanceof KubernetesListObject) {
      return ((KubernetesListObject) result).getMetadata().getContinue();
    }
    return null;    
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2875004300779491,  0.2875004300779491,  0.18001372406911442,  0.33357616940241436,43.0,0.6323529411764706,43.0,0.6323529411764706,41.0,0.6029411764705882,49.0,0.7,0.0,0.0,19.0,0.35185185185185186,16.0,0.22857142857142856,9.0,0.9,6.0,0.6,12.0,0.8
498,cdk,"private boolean isCisTransEndPoint(int idx){
    IAtom atom = container.getAtom(idx);
    if (atom.getAtomicNumber() == null || atom.getFormalCharge() == null || atom.getImplicitHydrogenCount() == null)
        return false;
    final int chg = atom.getFormalCharge();
    final int btypes = getBondTypes(idx);
    switch(atom.getAtomicNumber()) {
        case 6:
        case 14:
        case 32:
            return chg == 0 && btypes == 0x0102;
        case 7:
            if (chg == 0)
                return btypes == 0x0101;
            if (chg == +1)
                return btypes == 0x0102;
        default:
            return false;
    }
}",isCisTransEndPoint,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,"/**
     * Checks if the atom can be involved in a double-bond.
     * @param idx atom idx
     * @return the atom at index (idx) is valid for a double bond
     * @see <a href=""http://www.inchi-trust.org/download/104/InChI_TechMan.pdf"">Double bond stereochemistry, InChI Technical Manual</a>
     */",1258-1287,"('isCisTransEndPoint', {'INSTRUCTION': {'covered': 57, 'missed': 1}, 'BRANCH': {'covered': 16, 'missed': 5}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",126.0,11.0,Checks if the atom can be involved in a double-bond.,Inspects if the atom can be involved in a double-bond operation,The atom is checked if it can be involved in a double-bond.,0.291031766943147,Checks whether the atom can be involved in a double bond.,"private boolean isCisTransEndPoint(int idx){
        if (idx == -1) return false;
        if (container.getAtom(idx).getFlag(CDKConstants.ISAROMATIC)) return true;
        if (container.getAtom(idx).getFlag(CDKConstants.ISINRING)) return true;
        return false;
    }","private boolean isCisTransEndPoint(int idx){
        if (idx == -1) return false;
        if (container.getAtom(idx).getFlag(CDKConstants.ISAROMATIC)) return true;
        if (container.getAtom(idx).getFlag(CDKConstants.ISINRING)) return true;
        return false;
    }","private boolean isCisTransEndPoint(int idx){
        if (atomToIndex.get(container.getAtom(idx)) == -1) return false;
        if (atomToIndex.get(container.getAtom(idx)) == -2) return true;
        return false;       
 }","private boolean isCisTransEndPoint(int idx){
        if (idx == -1) return false;
        if (atomToIndex.get(container.getAtom(idx)) == -1) return false;
        if (container.getAtom(idx).getPoint2d() == null) return false;
        if (container.getAtom(idx).getPoint2d().x == 0 && container.getAtom(idx).getPoint2d().y == 0) return false;
        return true;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.23425379321218454,  0.23425379321218454,  0.2860662819243194,  0.2170051585656994,91.0,0.7165354330708661,91.0,0.7165354330708661,87.0,0.6850393700787402,93.0,0.7322834645669292,0.0,0.0,44.0,0.4583333333333333,28.0,0.45901639344262296,3.0,0.25,3.0,0.25,6.0,0.46153846153846156
499,openapi-generator,"public static ValidationRule warn(String description, String failureMessage, Function<T, Result> fn){
    return new ValidationRule(Severity.WARNING, description, failureMessage, (Function<Object, Result>) fn);
}",warn,org/openapitools/codegen/validation/ValidationRule.java,/modules/openapi-generator-core/src/main/java/org/openapitools/codegen/validation/ValidationRule.java,"/**
     * Create an instance of a {@link ValidationRule} which should result in a warning should the evaluate of this rule fail.
     *
     * @param description A description to help differentiate this rule from others (not intended to be user-facing).
     * @param failureMessage The message to be displayed in the event of a test failure (intended to be user-facing).
     * @param fn The test condition to be applied as a part of this rule, when this function returns <code>true</code>,
     *             the evaluated instance will be considered ""valid"" according to this rule.
     * @param <T> The type of the object being evaluated.
     *
     * @return A new instance of a {@link ValidationRule}
     */",128-142,"('warn', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,24.0,Create an instance of a {@link ValidationRule} which should result in a warning should the evaluate of this rule fail.,"Constructs an instance of a {@link ValidationRule}. If the constraints are not satisfied, then such operation will fail the evaluation.","If the evaluate of this rule fails, create an instance of @link ValidationRule which should result in a warning.",1.25298247458377,Create an instance of a {@link ValidationRule} that should result in a warning if the evaluation of this rule fails.," public static ValidationRule warn(String description, String failureMessage, Function<T, Result> fn){
        return new ValidationRule(Severity.WARNING, description, failureMessage, (Function<Object, Result>) fn);
    }"," public static ValidationRule warn(String description, String failureMessage, Function<T, Result> fn){
        return new ValidationRule(Severity.WARNING, description, failureMessage, (Function<Object, Result>) fn);        
 }"," public static ValidationRule warn(String description, String failureMessage, Function<T, Result> fn){
        return new ValidationRule(Severity.WARNING, description, failureMessage, (Function<Object, Result>) fn);        
 }"," public static ValidationRule warn(String description, String failureMessage, Function<T, Result> fn){
        return new ValidationRule(Severity.WARNING, description, failureMessage, (Function<Object, Result>) fn);        
 }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,15.0,0.7142857142857143,4.0,0.19047619047619047,19.0,0.9047619047619048
500,cdk,"public synchronized void sortResultsByFragments(){
    Map<Integer, Map<Integer, Integer>> allFragmentMCS = new TreeMap<Integer, Map<Integer, Integer>>();
    Map<Integer, Map<IAtom, IAtom>> allFragmentAtomMCS = new TreeMap<Integer, Map<IAtom, IAtom>>();
    Map<Integer, Double> stereoScoreMap = new TreeMap<Integer, Double>();
    Map<Integer, Double> energyScoreMap = new TreeMap<Integer, Double>();
    Map<Integer, Integer> fragmentScoreMap = new TreeMap<Integer, Integer>();
    initializeMaps(allFragmentMCS, allFragmentAtomMCS, stereoScoreMap, fragmentScoreMap, energyScoreMap);
    int minFragmentScore = 9999;
    for (Integer key : allFragmentAtomMCS.keySet()) {
        Map<IAtom, IAtom> mcsAtom = allFragmentAtomMCS.get(key);
        int fragmentCount = getMappedMoleculeFragmentSize(mcsAtom);
        fragmentScoreMap.put(key, fragmentCount);
        if (minFragmentScore > fragmentCount) {
            minFragmentScore = fragmentCount;
        }
    }
    boolean flag = false;
    if (minFragmentScore < 9999) {
        flag = true;
        clear();
    }
    int counter = 0;
    for (Map.Entry<Integer, Integer> map : fragmentScoreMap.entrySet()) {
        if (minFragmentScore == map.getValue().intValue()) {
            addSolution(counter, map.getKey(), allFragmentAtomMCS, allFragmentMCS, stereoScoreMap, energyScoreMap, fragmentScoreMap);
            counter++;
        }
    }
    if (flag) {
        firstSolution.putAll(allMCS.get(0));
        firstAtomMCS.putAll(allAtomMCS.get(0));
        clear(allFragmentMCS, allFragmentAtomMCS, stereoScoreMap, fragmentScoreMap, energyScoreMap);
    }
}",sortResultsByFragments,org/openscience/cdk/smsd/filters/ChemicalFilters.java,/legacy/src/main/java/org/openscience/cdk/smsd/filters/ChemicalFilters.java,"/**
     * Sort solution by ascending order of the fragment count.
     */",257-304,"('sortResultsByFragments', {'INSTRUCTION': {'covered': 129, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 29, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",322.0,10.0,Sort solution by ascending order of the fragment count.,The solution is sorted by ascending order of the fragment count.,Sort solution by order of fragment count.,0.13402126514098,Sort the solution in ascending order of the number of fragments.,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,3.0,0.25,5.0,0.4166666666666667,2.0,0.2
501,metrics," Result execute(){
    long start = clock().getTick();
    Result result;
    try {
        result = check();
    } catch (Exception e) {
        result = Result.unhealthy(e);
    }
    result.setDuration(TimeUnit.MILLISECONDS.convert(clock().getTick() - start, TimeUnit.NANOSECONDS));
    return result;
}",execute,io/dropwizard/metrics5/health/HealthCheck.java,/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/HealthCheck.java,"/**
     * Executes the health check, catching and handling any exceptions raised by {@link #check()}.
     *
     * @return if the component is healthy, a healthy {@link Result}; otherwise, an unhealthy {@link
     * Result} with a descriptive error message or exception
     */",363-379,"('execute', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,21.0,"Executes the health check, catching and handling any exceptions raised by {@link #check()}.","Runs a sanity check. If excpetions are rised, those will be captuted by {@link #check}.",The health check is executed and handled by the @link #check,0.743220811595653,"Performs health checking, intercepts, and handles all exceptions raised by {@link #check()}.","  Result execute(){
    try {
      return check();
    } catch (Exception e) {
      return new ResultBuilder().unhealthy(e).build();
    }           
  }","  Result execute(){
    try {
      return check();
    } catch (Exception e) {
      return new ResultBuilder().unhealthy(e).build();
    }           
  }","  Result execute(){
    Result result = null;
    try {
      result = check();
    } catch (Exception e) {
      result = new ResultBuilder().unhealthy(e).build();
    }
    return result;          
  }","  Result execute(){
    Result result = null;
    try {
      result = check();
    } catch (Exception e) {
      result = new ResultBuilder().unhealthy(e).build();
    }
    return result;          
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.24859540226571766,  0.24859540226571766,  0.3882188143246806,  0.3882188143246806,46.0,0.6133333333333333,46.0,0.6133333333333333,38.0,0.5066666666666667,38.0,0.5066666666666667,0.0,0.0,12.0,0.2553191489361702,12.0,0.2553191489361702,13.0,0.8125,6.0,0.42857142857142855,12.0,0.8571428571428571
502,tablesaw,"private void addColumns(){
    this.destination.addColumns(query.getArgumentList().createEmptyDestinationColumns(query.getTable().rowCount()).toArray(new Column<?>[0]));
}",addColumns,tech/tablesaw/analytic/AnalyticQueryEngine.java,/core/src/main/java/tech/tablesaw/analytic/AnalyticQueryEngine.java,"/**
   * Creates empty columns that will be filled in when the analytic aggregate or numbering functions
   * are executed.
   */",128-138,"('addColumns', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,18.0,Creates empty columns that will be filled in when the analytic aggregate or numbering functions  are executed.,"Once the analytic aggregate or the numer functions are exectured, then create an empty column.","When the analytic aggregate or numbering functions are executed, the empty columns will be filled.",0.837655577360798,Creates empty columns that will be populated when performing the analytic aggregation or numbering functions.,Empty Method," private void addColumns(){
    for (String toColumn : query.getArgumentList().getAggregateFunctions().keySet()) {
      destination.addColumn(toColumn, Column.create(toColumn, destination.type()));
    }
    for (String toColumn : query.getArgumentList().getNumberingFunctions().keySet()) {
      destination.addColumn(toColumn, Column.create(toColumn, destination.type()));
    }
  }"," private void addColumns(){
    for (String toColumn : query.getArgumentList().getAggregateFunctions().keySet()) {
      destination.addColumn(toColumn, Integer.class);
    }
    for (String toColumn : query.getArgumentList().getNumberingFunctions().keySet()) {
      destination.addColumn(toColumn, Integer.class);
    }
  }",Empty Method,Empty Method,NOT PASS,Empty Method,NOT PASS,None,  0.3600627354935169,None,  0.3621923208161258,None,None,60.0,0.6666666666666666,None,None,46.0,0.6388888888888888,89.0,0.9888888888888889,None,None,71.0,0.9861111111111112,17.0,0.9444444444444444,7.0,0.3888888888888889,16.0,0.8888888888888888
503,cdk,"boolean assignLayout(IAtomContainer container){
    try {
        int n = container.getAtomCount();
        int[] ordering = new int[n];
        String smiles = cansmi(container, ordering);
        for (Point2d[] points : templateMap.getOrDefault(smiles, Collections.emptyList())) {
            for (int i = 0; i < n; i++) {
                container.getAtom(i).setPoint2d(new Point2d(points[ordering[i]]));
            }
            return true;
        }
    } catch (CDKException e) {
    }
    return false;
}",assignLayout,org/openscience/cdk/layout/IdentityTemplateLibrary.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/IdentityTemplateLibrary.java,"/**
     * Assign a 2D layout to the atom container using the contents of the library. If multiple
     * coordinates are available the first is choosen.
     *
     * @param container structure representation
     * @return a layout was assigned
     */",336-364,"('assignLayout', {'INSTRUCTION': {'covered': 50, 'missed': 1}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",114.0,15.0,Assign a 2D layout to the atom container using the contents of the library.,Allocates a 2D layout to the atom container using the external library. When multiple coordinates are available the pick the first one.,The contents of the library should be used to assign a 2D layout to the atom container.,0.587405600811485,Assign a 2D layout to the atom container using the contents of the library.,"boolean assignLayout(IAtomContainer container){
        if (container.getAtomCount() == 0) return false;
        Entry<String, Point2d[]> entry = createEntry(container);
        if (entry == null) return false;
        List<Point2d[]> templates = templateMap.get(entry.getKey());
        if (templates == null) return false;
        for (Point2d[] template : templates) {
            if (template.length == container.getAtomCount()) {
                for (int i = 0; i < template.length; i++) {
                    container.getAtom(i).setPoint2d(template[i]);
                }
                return true;
            }
        }
        return false;
    }","boolean assignLayout(IAtomContainer container){
        if (container.getAtomCount() == 0) return false;
        Entry<String, Point2d[]> entry = createEntry(container);
        if (entry == null) return false;
        List<Point2d[]> list = templateMap.get(entry.getKey());
        if (list == null || list.isEmpty()) return false;
        Point2d[] points = list.get(0);
        for (int i = 0; i < container.getAtomCount(); i++) {
            container.getAtom(i).setPoint2d(points[i]);
        }
        return true;
    }","boolean assignLayout(IAtomContainer container){
        if (container.getAtomCount() == 0) return false;
        Point2d[] points = getPoints(container);
        if (points == null) return false;
        for (int i = 0; i < container.getAtomCount(); i++) {
            container.getAtom(i).setPoint2d(points[i]);
        }
        return true;
    }","boolean assignLayout(IAtomContainer container){
        if (container.getAtomCount() == 0) return false;
        Entry<String, Point2d[]> entry = createEntry(container);
        if (entry == null) return false;
        List<Point2d[]> templates = templateMap.get(entry.getKey());
        if (templates == null) return false;
        for (Point2d[] template : templates) {
            if (template.length == container.getAtomCount()) {
                for (int i = 0; i < template.length; i++) {
                    container.getAtom(i).setPoint2d(template[i]);
                }
                return true;
            }
        }
        return false;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.43962839679824484,  0.41524040181157124,  0.43962839679824484,  0.3927365315502073,84.0,0.6086956521739131,89.0,0.6846153846153846,84.0,0.6086956521739131,62.0,0.5391304347826087,35.0,0.2536231884057971,0.0,0.0,69.0,0.5,12.0,0.5217391304347826,0.0,0.0,16.0,0.8888888888888888
505,acs-aem-commons,"protected final Layer transform(Layer layer, final ValueMap imageTransformersWithParams){
    for (final String type : imageTransformersWithParams.keySet()) {
        if (StringUtils.equals(TYPE_QUALITY, type)) {
            continue;
        }
        final ImageTransformer imageTransformer = this.imageTransformers.get(type);
        if (imageTransformer == null) {
            log.warn(""Skipping transform. Missing ImageTransformer for type: {}"", type);
            continue;
        }
        final ValueMap transformParams = imageTransformersWithParams.get(type, EMPTY_PARAMS);
        if (transformParams != null) {
            layer = imageTransformer.transform(layer, transformParams);
        }
    }
    return layer;
}",transform,com/adobe/acs/commons/images/impl/NamedTransformImageServlet.java,/bundle/src/main/java/com/adobe/acs/commons/images/impl/NamedTransformImageServlet.java,"/**
     * Execute the ImageTransformers as specified by the Request's suffix segments against the Image layer.
     *
     * @param layer the Image layer
     * @param imageTransformersWithParams the transforms and their params
     * @return the transformed Image layer
     */",246-274,"('transform', {'INSTRUCTION': {'covered': 39, 'missed': 6}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 9, 'missed': 3}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",110.0,16.0,Execute the ImageTransformers as specified by the Request's suffix segments against the Image layer.,Creates a new ImageTransformer object and run the imageTransformer operation.,The image transformer is executed as specified by the Request's suffix segments.,0.22958947816613,Run the ImageTransformers as specified by the suffix segments of the request relative to the Image layer.," protected final Layer transform(Layer layer, final ValueMap imageTransformersWithParams){
        for (final Map.Entry<String, ImageTransformer> entry : imageTransformersWithParams.entrySet()) {
            final ImageTransformer imageTransformer = entry.getValue();
            final String transformName = entry.getKey();
            final ValueMap params = imageTransformersWithParams.get(transformName, EMPTY_PARAMS);
            layer = imageTransformer.transform(layer, params);
        }
        return layer;
    }"," protected final Layer transform(Layer layer, final ValueMap imageTransformersWithParams){
        final ImageTransformer imageTransformer = getImageTransformer(imageTransformersWithParams);
        if (imageTransformer != null) {
            layer = imageTransformer.transform(layer, imageTransformersWithParams);
        }
        return layer;
    }"," protected final Layer transform(Layer layer, final ValueMap imageTransformersWithParams){
        for (final Map.Entry<String, Object> entry : imageTransformersWithParams.entrySet()) {
            final String transformName = entry.getKey();
            final ImageTransformer imageTransformer = this.imageTransformers.get(transformName);
            if (imageTransformer != null) {
                layer = imageTransformer.transform(layer, (ValueMap) entry.getValue());
            }
        }
        return layer;
    }"," protected final Layer transform(Layer layer, final ValueMap imageTransformersWithParams){
        for (final Map.Entry<String, ImageTransformer> entry : imageTransformersWithParams.entrySet()) {
            final String transformName = entry.getKey();
            final ImageTransformer imageTransformer = entry.getValue();
            final ValueMap params = imageTransformersWithParams.get(transformName, EMPTY_PARAMS);
            layer = imageTransformer.transform(layer, params);
        }
        return layer;
    }",NOT PASS,NOT PASS,NOT PASS,PASS,  0.44209955654133837,  0.3315567225917686,  0.4504328898746717,  0.4832591324297262,51.0,0.4594594594594595,68.0,0.6126126126126126,52.0,0.46846846846846846,57.0,0.5135135135135135,45.0,0.5421686746987951,6.0,0.07228915662650602,31.0,0.3522727272727273,13.0,0.8666666666666667,7.0,0.3888888888888889,10.0,0.6666666666666666
506,dcache,"private static Pattern toPattern(String name, String format){
    StringBuilder regex = new StringBuilder();
    Matcher matcher = ATTRIBUTE_PATTERN.matcher(format);
    int pos = 0;
    while (matcher.find()) {
        if (pos < matcher.start()) {
            regex.append(Pattern.quote(format.substring(pos, matcher.start())));
        }
        String expression = matcher.group(1);
        if (isIf(expression)) {
            regex.append(""(?:"");
        } else if (isElse(expression)) {
            regex.append(""|"");
        } else if (isEndIf(expression)) {
            regex.append("")"");
        } else {
            regex.append(""(?<"").append(toGroupName(expression)).append("">"");
            switch(expression) {
                case ""date"":
                    regex.append("".+?"");
                    break;
                case ""pnfsid"":
                    regex.append(""[0-9A-F]{24}(?:[0-9A-F]{12})?"");
                    break;
                case ""filesize"":
                case ""transferred"":
                case ""connectionTime"":
                case ""transactionTime"":
                case ""queuingTime"":
                case ""transferTime"":
                case ""rc"":
                case ""uid"":
                case ""gid"":
                    regex.append(""-?\\d+"");
                    break;
                case ""cached"":
                case ""created"":
                    regex.append(""(?:true|false)"");
                    break;
                case ""cellType"":
                    switch(name) {
                        case ""mover-info-message"":
                        case ""remove-file-info-message"":
                        case ""storage-info-message"":
                        case ""pool-hit-info-message"":
                            regex.append(""pool"");
                            break;
                        case ""door-request-info-message"":
                            regex.append(""door"");
                            break;
                        default:
                            regex.append(""\\w+"");
                            break;
                    }
                    break;
                case ""cellName"":
                    regex.append("".+?"");
                    break;
                case ""type"":
                    switch(name) {
                        case ""mover-info-message"":
                            regex.append(""transfer"");
                            break;
                        case ""remove-file-info-message"":
                            regex.append(""remove"");
                            break;
                        case ""storage-info-message"":
                            regex.append(""(?:re)?store"");
                            break;
                        case ""pool-hit-info-message"":
                            regex.append(""hit"");
                            break;
                        case ""warning-pnfs-file-info-message"":
                            regex.append(""warning"");
                            break;
                        default:
                            regex.append(""\\w+"");
                            break;
                    }
                    break;
                default:
                    regex.append("".*?"");
            }
            regex.append("")"");
        }
        pos = matcher.end();
    }
    if (pos < format.length()) {
        regex.append(Pattern.quote(format.substring(pos)));
    }
    return Pattern.compile(regex.toString(), Pattern.CASE_INSENSITIVE);
}",toPattern,org/dcache/services/billing/text/BillingParserBuilder.java,/modules/dcache/src/main/java/org/dcache/services/billing/text/BillingParserBuilder.java,"/**
     * Returns a Pattern for matching the provided billing format.
     * <p>
     * Attributes are turned into named capturing groups.
     */",153-250,"('toPattern', {'INSTRUCTION': {'covered': 171, 'missed': 14}, 'BRANCH': {'covered': 25, 'missed': 4}, 'LINE': {'covered': 47, 'missed': 5}, 'COMPLEXITY': {'covered': 17, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",463.0,10.0,Returns a Pattern for matching the provided billing format.,Builds and returns a pattern to march the provided billing format,The pattern is used to match the provided billing format.,0.234591062647353,Returns a template to match the billing format provided.,"private static Pattern toPattern(String name, String format){
        String regex = format.replaceAll(""\\$(.+?)\\$"", ""(?<$1>.*)"");
        return Pattern.compile(regex);      
 }","private static Pattern toPattern(String name, String format){
        String regex = format.replaceAll(""\\$(.+?)\\$"", ""(?<$1>.*)"");
        return Pattern.compile(regex);      
 }","private static Pattern toPattern(String name, String format){
        String regex = ATTRIBUTE_PATTERN.matcher(format).replaceAll(""(?<$1>.*)"");
        return Pattern.compile(""^"" + regex + ""$"");      
 }","private static Pattern toPattern(String name, String format){
        StringBuilder pattern = new StringBuilder();
        pattern.append(""^"");
        Matcher matcher = ATTRIBUTE_PATTERN.matcher(format);
        while (matcher.find()) {
            String attribute = matcher.group(1);
            String groupName = toGroupName(attribute);
            pattern.append(""(?<"").append(groupName).append("">"");
            pattern.append(formats.get(attribute));
            pattern.append("")"");
        }
        pattern.append(""$"");
        return Pattern.compile(pattern.toString());     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.041207714830286665,  0.038603548163619994,  0.22690724502925613,  0.0717219095176293,434.0,0.9353448275862069,434.0,0.9353448275862069,370.0,0.7974137931034483,431.0,0.9288793103448276,0.0,0.0,95.0,0.7786885245901639,11.0,0.2682926829268293,7.0,0.5833333333333334,6.0,0.6,6.0,0.5454545454545454
507,weblogic-kubernetes-operator," static boolean isMissingValues(Map<String, String> current, Map<String, String> required){
    if (!hasAllRequiredNames(current, required)) {
        return true;
    }
    for (String name : required.keySet()) {
        if (!Objects.equals(current.get(name), required.get(name))) {
            return true;
        }
    }
    return false;
}",isMissingValues,oracle/kubernetes/operator/helpers/KubernetesUtils.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/KubernetesUtils.java,"/**
   * Returns true if the current map is missing values from the required map. This method is
   * typically used to compare labels and annotations against specifications derived from the
   * domain.
   *
   * @param current  a map of the values found in a Kubernetes resource
   * @param required a map of the values specified for the resource by the domain
   * @return true if there is a problem that must be fixed by patching
   */",39-59,"('isMissingValues', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",80.0,14.0,Returns true if the current map is missing values from the required map.,"If the required map misses the current object, return true, false otherwise.","If the current map is missing values, this is true.",0.65390968752412,Returns true if the current adapter lacks values from the required adapter.,"  static boolean isMissingValues(Map<String, String> current, Map<String, String> required){
    if(isNullOrEmpty(current)){
      return false;
    }
    if(isNullOrEmpty(required)){
      return true;
    }
    for(Map.Entry<String, String> entry : required.entrySet()){
      if(!current.containsKey(entry.getKey())){
        return true;
      }
      if(!current.get(entry.getKey()).equals(entry.getValue())){
        return true;
      }
    }
    return false;     
  }","  static boolean isMissingValues(Map<String, String> current, Map<String, String> required){
    if(isNullOrEmpty(required)){
      return false;
    }
    for(Map.Entry<String, String> entry : required.entrySet()){
      if(!current.containsKey(entry.getKey())){
        return true;
      }
      if(!current.get(entry.getKey()).equals(entry.getValue())){
        return true;
      }
    }
    return false;     
  }","  static boolean isMissingValues(Map<String, String> current, Map<String, String> required){
    if (current == null) {
      return true;
    }
    for (Map.Entry<String, String> entry : required.entrySet()) {
      if (!current.containsKey(entry.getKey()) || !current.get(entry.getKey()).equals(entry.getValue())) {
        return true;
      }
    }
    return false;
  }","  static boolean isMissingValues(Map<String, String> current, Map<String, String> required){
    if(current == null || required == null) {
      return false;
    }
    for(Map.Entry<String, String> entry : required.entrySet()){
      if(!current.containsKey(entry.getKey()) || !current.get(entry.getKey()).equals(entry.getValue())){
        return true;
      }
    }
    return false;     
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6315593840639397,  0.6422603237222597,  0.6263608636864029,  0.6304650437667003,50.0,0.42735042735042733,42.0,0.4,38.0,0.37623762376237624,36.0,0.3711340206185567,13.0,0.1111111111111111,24.0,0.20512820512820512,23.0,0.19658119658119658,12.0,0.8571428571428571,4.0,0.2857142857142857,8.0,0.5714285714285714
509,cdk,"public boolean contains(IAtom atom){
    if (atoms == null)
        return false;
    for (IAtom localAtom : atoms) {
        if (localAtom.equals(atom))
            return true;
    }
    return false;
}",contains,org/openscience/cdk/silent/Bond.java,/base/silent/src/main/java/org/openscience/cdk/silent/Bond.java,"/**
     * Returns true if the given atom participates in this bond.
     *
     * @param atom The atom to be tested if it participates in this bond
     * @return true if the atom participates in this bond
     */",305-318,"('contains', {'INSTRUCTION': {'covered': 28, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",42.0,11.0,Returns true if the given atom participates in this bond.,"If the bond is participated by the given atom, then returns true, false otherwise.","If the atom participates in the bond, it is true.",0.513135507233505,Returns true if the given atom participates in this bond.,"public boolean contains(IAtom atom){
        for (int i = 0; i < atomCount; i++) {
            if (atoms[i].equals(atom))
                return true;
        }
        return false;
    }","public boolean contains(IAtom atom){
        for (int i = 0; i < atomCount; i++) {
            if (atoms[i].equals(atom))
                return true;
        }
        return false;
    }","public boolean contains(IAtom atom){
        for (int i = 0; i < atomCount; i++) {
            if (atoms[i].equals(atom))
                return true;
        }
        return false;
    }","public boolean contains(IAtom atom){
        for (int i = 0; i < atomCount; i++) {
            if (atoms[i].equals(atom))
                return true;
        }
        return false;
    }",PASS,PASS,PASS,PASS,  0.5858823513447663,  0.5858823513447663,  0.5858823513447663,  0.5858823513447663,17.0,0.38636363636363635,17.0,0.38636363636363635,17.0,0.38636363636363635,17.0,0.38636363636363635,0.0,0.0,0.0,0.0,0.0,0.0,12.0,0.8,0.0,0.0,9.0,0.8181818181818182
510,tablesaw,"C mapInto(Function<? super T, ? extends R> fun, C into){
    for (int i = 0; i < size(); i++) {
        if (isMissing(i)) {
            into.setMissing(i);
        } else {
            into.set(i, fun.apply(get(i)));
        }
    }
    return into;
}",mapInto,tech/tablesaw/columns/Column.java,/core/src/main/java/tech/tablesaw/columns/Column.java,"/**
   * Maps the function across all rows, storing the results into the provided Column.
   *
   * <p>The target column must have at least the same number of rows.
   *
   * @param fun function to map
   * @param into Column into which results are set
   * @return the provided Column
   */",355-373,"('mapInto', {'INSTRUCTION': {'covered': 23, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,15.0,"Maps the function across all rows, storing the results into the provided Column.",For each row applies the function get and keep track of the results into the provided column.,The function is mapped across all rows and the results are in the Column.,0.401187256055389,"Maps the function to all rows, storing the results in the provided column.","C mapInto(Function<? super T, ? extends R> fun, C into){
    for (int i = 0; i < size(); i++) {
      into.set(i, fun.apply(get(i)));
    }
    return into;
  }","C mapInto(Function<? super T, ? extends R> fun, C into){
    for (int i = 0; i < size(); i++) {
      into.add(fun.apply(get(i)));
    }
    return into;
  }","C mapInto(Function<? super T, ? extends R> fun, C into){
    for (int i = 0; i < size(); i++) {
      into.add(fun.apply(get(i)));
    }
    return into;
  }","C mapInto(Function<? super T, ? extends R> fun, C into){
    for (int i = 0; i < size(); i++) {
      into.set(i, fun.apply(get(i)));
    }
    return into;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7381470781294512,  0.6634486071058028,  0.7381470781294512,  0.6634486071058028,19.0,0.24358974358974358,22.0,0.28205128205128205,19.0,0.24358974358974358,22.0,0.28205128205128205,3.0,0.05084745762711865,0.0,0.0,3.0,0.05084745762711865,10.0,0.5555555555555556,3.0,0.21428571428571427,9.0,0.6
511,dcache,"private static Set<T> extractAttributes(NamingEnumeration<SearchResult> sre, String attr, Function<String, T> mapper) throws NamingException{
    Set<T> attrs = new HashSet<>();
    while (sre.hasMore()) {
        T v = mapper.apply((String) sre.next().getAttributes().get(attr).get());
        attrs.add(v);
    }
    if (attrs.isEmpty()) {
        throw new NoSuchElementException();
    }
    return attrs;
}",extractAttributes,org/dcache/gplazma/plugins/Ldap.java,/modules/gplazma2-ldap/src/main/java/org/dcache/gplazma/plugins/Ldap.java,"/**
     * Get set of attributes extracted from the search result.
     *
     * @param <T>    type of extracted type.
     * @param sre    ldap search result.
     * @param attr   search result attribute.
     * @param mapper mapping function to apply to each result element.
     * @return set of attributes.
     * @throws NamingException
     */",632-656,"('extractAttributes', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",108.0,10.0,Get set of attributes extracted from the search result.,Returns a new HashSet object contining the set of attributes that have been extracted.,Get the set of attributes from the search result.,0.0617870595327414,Get a set of attributes extracted from the search result.," private static Set<T> extractAttributes(NamingEnumeration<SearchResult> sre, String attr, Function<String, T> mapper) throws NamingException{
        Set<T> result = new HashSet<>();
        while (sre.hasMore()) {
            SearchResult rs = sre.next();
            result.add(mapper.apply(extractAttribute(rs, attr)));
        }
        return result;
    }"," private static Set<T> extractAttributes(NamingEnumeration<SearchResult> sre, String attr, Function<String, T> mapper) throws NamingException{
        Set<T> result = new HashSet<>();
        while (sre.hasMore()) {
            SearchResult rs = sre.next();
            result.add(mapper.apply(extractAttribute(rs, attr)));
        }
        return result;
    }"," private static Set<T> extractAttributes(NamingEnumeration<SearchResult> sre, String attr, Function<String, T> mapper) throws NamingException{
        Set<T> result = new HashSet<>();
        while (sre.hasMore()) {
            SearchResult rs = sre.next();
            Attributes attrs = rs.getAttributes();
            if (attrs != null) {
                Attribute attrValue = attrs.get(attr);
                if (attrValue != null) {
                    for (NamingEnumeration<?> ne = attrValue.getAll(); ne.hasMore(); ) {
                        result.add(mapper.apply((String) ne.next()));
                    }
                }
            }
        }
        return result;
    }"," private static Set<T> extractAttributes(NamingEnumeration<SearchResult> sre, String attr, Function<String, T> mapper) throws NamingException{
        Set<T> result = new HashSet<>();
        while (sre.hasMore()) {
            SearchResult rs = sre.next();
            Attributes attrs = rs.getAttributes();
            if (attrs != null) {
                Attribute attrValue = attrs.get(attr);
                if (attrValue != null) {
                    for (NamingEnumeration<?> ne = attrValue.getAll(); ne.hasMore();) {
                        result.add(mapper.apply((String) ne.next()));
                    }
                }
            }
        }
        return result;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6103410737298816,  0.6103410737298816,  0.6726708437719836,  0.68403448013562,40.0,0.3669724770642202,40.0,0.3669724770642202,62.0,0.43661971830985913,62.0,0.43661971830985913,0.0,0.0,65.0,0.45774647887323944,65.0,0.45774647887323944,12.0,0.8,1.0,0.09090909090909091,2.0,0.2
513,cdk,"public Partition refine(Partition coarser){
    Partition finer = new Partition(coarser);
    blocksToRefine = new LinkedList<Set<Integer>>();
    for (int i = 0; i < finer.size(); i++) {
        blocksToRefine.add(finer.copyBlock(i));
    }
    int numberOfVertices = refinable.getVertexCount();
    while (!blocksToRefine.isEmpty()) {
        Set<Integer> t = blocksToRefine.remove();
        currentBlockIndex = 0;
        while (currentBlockIndex < finer.size() && finer.size() < numberOfVertices) {
            if (!finer.isDiscreteCell(currentBlockIndex)) {
                Map<Invariant, SortedSet<Integer>> invariants = getInvariants(finer, t);
                split(invariants, finer);
            }
            currentBlockIndex++;
        }
        if (finer.size() == numberOfVertices) {
            return finer;
        }
    }
    return finer;
}",refine,org/openscience/cdk/group/EquitablePartitionRefiner.java,/tool/group/src/main/java/org/openscience/cdk/group/EquitablePartitionRefiner.java,"/**
     * Refines the coarse partition <code>a</code> into a finer one.
     *
     * @param coarser the partition to refine
     * @return a finer partition
     */",89-126,"('refine', {'INSTRUCTION': {'covered': 80, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",177.0,16.0,Refines the coarse partition <code>a</code> into a finer one.,Converts a coarse partition into a superior one,The partition is refined into a fine one.,0.175356290126768,Refines the coarse partition <code>has</code> into a thinner partition.,"public Partition refine(Partition coarser){
        Partition finer = new Partition(coarser.getSize());
        for (int i = 0; i < coarser.getSize(); i++) {
            finer.addBlock(coarser.getBlock(i));
        }
        this.blocksToRefine = new LinkedList<Set<Integer>>();
        for (int i = 0; i < finer.getSize(); i++) {
            blocksToRefine.add(finer.getBlock(i));
        }
        this.currentBlockIndex = 0;
        while (!blocksToRefine.isEmpty()) {
            refineBlock(finer);
        }
        return finer;
    }","public Partition refine(Partition coarser){
        Partition finer = new Partition(coarser.getSize());
        for (int i = 0; i < coarser.getSize(); i++) {
            finer.setCell(i, coarser.getCell(i));
        }
        this.blocksToRefine = new LinkedList<Set<Integer>>();
        for (int i = 0; i < coarser.getSize(); i++) {
            blocksToRefine.add(Collections.singleton(i));
        }
        this.currentBlockIndex = 0;
        while (!blocksToRefine.isEmpty()) {
            refineBlock(finer);
        }
        return finer;
    }","public Partition refine(Partition coarser){
        Partition finer = new Partition(coarser.getSize());
        for (int i = 0; i < coarser.getSize(); i++) {
            finer.addBlock(coarser.getBlock(i));
        }
        refine(finer);
        return finer;
    }","public Partition refine(Partition coarser){
        Partition finer = new Partition(coarser.getSize());
        for (int i = 0; i < coarser.getSize(); i++) {
            finer.addBlock(coarser.getBlock(i));
        }
        this.blocksToRefine = new LinkedList<Set<Integer>>();
        for (int i = 0; i < finer.getSize(); i++) {
            blocksToRefine.add(finer.getBlock(i));
        }
        this.currentBlockIndex = 0;
        while (!blocksToRefine.isEmpty()) {
            refineBlock(finer);
        }
        return finer;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4002515368788848,  0.3958872390849169,  0.4002515368788848,  0.23537590255173577,99.0,0.5561797752808989,103.0,0.5786516853932584,99.0,0.5561797752808989,126.0,0.7078651685393258,7.0,0.05426356589147287,0.0,0.0,65.0,0.5118110236220472,5.0,0.5,3.0,0.3,6.0,0.6
514,cdk,"private IChemFile readChemFile(IChemFile oFile){
    IChemSequence oSeq = oFile.getBuilder().newInstance(IChemSequence.class);
    IChemModel oModel = oFile.getBuilder().newInstance(IChemModel.class);
    IAtomContainerSet oSet = oFile.getBuilder().newInstance(IAtomContainerSet.class);
    String cCol;
    PDBAtom oAtom;
    PDBPolymer oBP = new PDBPolymer();
    IAtomContainer molecularStructure = oFile.getBuilder().newInstance(IAtomContainer.class);
    StringBuffer cResidue;
    String oObj;
    IMonomer oMonomer;
    String cRead = """";
    char chain = 'A';
    IStrand oStrand;
    int lineLength = 0;
    boolean isProteinStructure = false;
    atomNumberMap = new Hashtable<Integer, IAtom>();
    if (readConnect.isSet()) {
        bondsFromConnectRecords = new ArrayList<IBond>();
    }
    try {
        do {
            cRead = _oInput.readLine();
            logger.debug(""Read line: "", cRead);
            if (cRead != null) {
                lineLength = cRead.length();
                if (lineLength < 6) {
                    cRead = cRead + ""      "";
                }
                cCol = cRead.substring(0, 6);
                if (""SEQRES"".equalsIgnoreCase(cCol)) {
                    isProteinStructure = true;
                } else if (""ATOM  "".equalsIgnoreCase(cCol)) {
                    oAtom = readAtom(cRead, lineLength);
                    if (isProteinStructure) {
                        cResidue = new StringBuffer(8);
                        oObj = oAtom.getResName();
                        if (oObj != null) {
                            cResidue = cResidue.append(oObj.trim());
                        }
                        oObj = oAtom.getChainID();
                        if (oObj != null) {
                            cResidue = cResidue.append(String.valueOf(chain));
                        }
                        oObj = oAtom.getResSeq();
                        if (oObj != null) {
                            cResidue = cResidue.append(oObj.trim());
                        }
                        String strandName = oAtom.getChainID();
                        if (strandName == null || strandName.length() == 0) {
                            strandName = String.valueOf(chain);
                        }
                        oStrand = oBP.getStrand(strandName);
                        if (oStrand == null) {
                            oStrand = new PDBStrand();
                            oStrand.setStrandName(strandName);
                            oStrand.setID(String.valueOf(chain));
                        }
                        oMonomer = oBP.getMonomer(cResidue.toString(), String.valueOf(chain));
                        if (oMonomer == null) {
                            PDBMonomer monomer = new PDBMonomer();
                            monomer.setMonomerName(cResidue.toString());
                            monomer.setMonomerType(oAtom.getResName());
                            monomer.setChainID(oAtom.getChainID());
                            monomer.setICode(oAtom.getICode());
                            monomer.setResSeq(oAtom.getResSeq());
                            oMonomer = monomer;
                        }
                        oBP.addAtom(oAtom, oMonomer, oStrand);
                    } else {
                        molecularStructure.addAtom(oAtom);
                    }
                    if (readConnect.isSet() && atomNumberMap.put(oAtom.getSerial(), oAtom) != null) {
                        logger.warn(""Duplicate serial ID found for atom: "", oAtom);
                    }
                    logger.debug(""Added ATOM: "", oAtom);
                } else if (""HETATM"".equalsIgnoreCase(cCol)) {
                    oAtom = readAtom(cRead, lineLength);
                    oAtom.setHetAtom(true);
                    if (isProteinStructure) {
                        oBP.addAtom(oAtom);
                    } else {
                        molecularStructure.addAtom(oAtom);
                    }
                    if (atomNumberMap.put(oAtom.getSerial(), oAtom) != null) {
                        logger.warn(""Duplicate serial ID found for atom: "", oAtom);
                    }
                    logger.debug(""Added HETATM: "", oAtom);
                } else if (""TER   "".equalsIgnoreCase(cCol)) {
                    chain++;
                    oStrand = new PDBStrand();
                    oStrand.setStrandName(String.valueOf(chain));
                    logger.debug(""Added new STRAND"");
                } else if (""END   "".equalsIgnoreCase(cCol)) {
                    atomNumberMap.clear();
                    if (isProteinStructure) {
                        oSet.addAtomContainer(oBP);
                        if (useRebondTool.isSet()) {
                            try {
                                if (!createBondsWithRebondTool(oBP)) {
                                    logger.info(""Bonds could not be created using the RebondTool when PDB file was read."");
                                    oBP.removeAllBonds();
                                }
                            } catch (Exception exception) {
                                logger.info(""Bonds could not be created when PDB file was read."");
                                logger.debug(exception);
                            }
                        }
                    } else {
                        if (useRebondTool.isSet())
                            createBondsWithRebondTool(molecularStructure);
                        oSet.addAtomContainer(molecularStructure);
                    }
                } else if (cCol.equals(""MODEL "")) {
                    if (isProteinStructure) {
                        if (oBP.getAtomCount() > 0) {
                            oSet.addAtomContainer(oBP);
                            oModel.setMoleculeSet(oSet);
                            oSeq.addChemModel(oModel);
                            oBP = new PDBPolymer();
                            oModel = oFile.getBuilder().newInstance(IChemModel.class);
                            oSet = oFile.getBuilder().newInstance(IAtomContainerSet.class);
                            atomNumberMap.clear();
                        }
                    } else {
                        if (molecularStructure.getAtomCount() > 0) {
                            oSet.addAtomContainer(molecularStructure);
                            oModel.setMoleculeSet(oSet);
                            oSeq.addChemModel(oModel);
                            molecularStructure = oFile.getBuilder().newInstance(IAtomContainer.class);
                            oModel = oFile.getBuilder().newInstance(IChemModel.class);
                            oSet = oFile.getBuilder().newInstance(IAtomContainerSet.class);
                        }
                    }
                } else if (""REMARK"".equalsIgnoreCase(cCol)) {
                    Object comment = oFile.getProperty(CDKConstants.COMMENT);
                    if (comment == null) {
                        comment = """";
                    }
                    if (lineLength > 12) {
                        comment = comment.toString() + cRead.substring(11).trim() + ""\n"";
                        oFile.setProperty(CDKConstants.COMMENT, comment);
                    } else {
                        logger.warn(""REMARK line found without any comment!"");
                    }
                } else if (""COMPND"".equalsIgnoreCase(cCol)) {
                    String title = cRead.substring(10).trim();
                    oFile.setProperty(CDKConstants.TITLE, title);
                } else if (readConnect.isSet() && ""CONECT"".equalsIgnoreCase(cCol)) {
                    cRead.trim();
                    if (cRead.length() < 16) {
                        logger.debug(""Skipping unexpected empty CONECT line! : "", cRead);
                    } else {
                        int lineIndex = 6;
                        int atomFromNumber = -1;
                        int atomToNumber = -1;
                        IAtomContainer molecule = (isProteinStructure) ? oBP : molecularStructure;
                        while (lineIndex + 5 <= cRead.length()) {
                            String part = cRead.substring(lineIndex, lineIndex + 5).trim();
                            if (atomFromNumber == -1) {
                                try {
                                    atomFromNumber = Integer.parseInt(part);
                                } catch (NumberFormatException nfe) {
                                }
                            } else {
                                try {
                                    atomToNumber = Integer.parseInt(part);
                                } catch (NumberFormatException nfe) {
                                    atomToNumber = -1;
                                }
                                if (atomFromNumber != -1 && atomToNumber != -1) {
                                    addBond(molecule, atomFromNumber, atomToNumber);
                                    logger.debug(""Bonded "" + atomFromNumber + "" with "" + atomToNumber);
                                }
                            }
                            lineIndex += 5;
                        }
                    }
                } else if (""HELIX "".equalsIgnoreCase(cCol)) {
                    PDBStructure structure = new PDBStructure();
                    structure.setStructureType(PDBStructure.HELIX);
                    structure.setStartChainID(cRead.charAt(19));
                    structure.setStartSequenceNumber(Integer.parseInt(cRead.substring(21, 25).trim()));
                    structure.setStartInsertionCode(cRead.charAt(25));
                    structure.setEndChainID(cRead.charAt(31));
                    structure.setEndSequenceNumber(Integer.parseInt(cRead.substring(33, 37).trim()));
                    structure.setEndInsertionCode(cRead.charAt(37));
                    oBP.addStructure(structure);
                } else if (""SHEET "".equalsIgnoreCase(cCol)) {
                    PDBStructure structure = new PDBStructure();
                    structure.setStructureType(PDBStructure.SHEET);
                    structure.setStartChainID(cRead.charAt(21));
                    structure.setStartSequenceNumber(Integer.parseInt(cRead.substring(22, 26).trim()));
                    structure.setStartInsertionCode(cRead.charAt(26));
                    structure.setEndChainID(cRead.charAt(32));
                    structure.setEndSequenceNumber(Integer.parseInt(cRead.substring(33, 37).trim()));
                    structure.setEndInsertionCode(cRead.charAt(37));
                    oBP.addStructure(structure);
                } else if (""TURN  "".equalsIgnoreCase(cCol)) {
                    PDBStructure structure = new PDBStructure();
                    structure.setStructureType(PDBStructure.TURN);
                    structure.setStartChainID(cRead.charAt(19));
                    structure.setStartSequenceNumber(Integer.parseInt(cRead.substring(20, 24).trim()));
                    structure.setStartInsertionCode(cRead.charAt(24));
                    structure.setEndChainID(cRead.charAt(30));
                    structure.setEndSequenceNumber(Integer.parseInt(cRead.substring(31, 35).trim()));
                    structure.setEndInsertionCode(cRead.charAt(35));
                    oBP.addStructure(structure);
                }
            }
        } while (_oInput.ready() && (cRead != null));
    } catch (IOException | IllegalArgumentException | CDKException e) {
        logger.error(""Found a problem at line:"");
        logger.error(cRead);
        logger.error(""01234567890123456789012345678901234567890123456789012345678901234567890123456789"");
        logger.error(""          1         2         3         4         5         6         7         "");
        logger.error(""  error: "" + e.getMessage());
        logger.debug(e);
        e.printStackTrace();
    }
    try {
        _oInput.close();
    } catch (Exception e) {
        logger.debug(e);
    }
    oModel.setMoleculeSet(oSet);
    oSeq.addChemModel(oModel);
    oFile.addChemSequence(oSeq);
    return oFile;
}",readChemFile,org/openscience/cdk/io/PDBReader.java,/storage/pdb/src/main/java/org/openscience/cdk/io/PDBReader.java,"/**
     * Read a <code>ChemFile</code> from a file in PDB format. The molecules
     * in the file are stored as <code>BioPolymer</code>s in the
     * <code>ChemFile</code>. The residues are the monomers of the
     * <code>BioPolymer</code>, and their names are the concatenation of the
     * residue, chain id, and the sequence number. Separate chains (denoted by
     * TER records) are stored as separate <code>BioPolymer</code> molecules.
     *
     * <p>Connectivity information is not currently read.
     *
     * @return The ChemFile that was read from the PDB file.
     */",204-498,"('readChemFile', {'INSTRUCTION': {'covered': 656, 'missed': 159}, 'BRANCH': {'covered': 68, 'missed': 22}, 'LINE': {'covered': 148, 'missed': 38}, 'COMPLEXITY': {'covered': 28, 'missed': 18}, 'METHOD': {'covered': 1, 'missed': 0}})",1847.0,16.0,Read a <code>ChemFile</code> from a file in PDB format.,Reads and returns a ChemFile object in PDB format.,You can read the code from a file.,0.329927416817301,Read a <code>ChemFile</code> from a file in PDB format.," private IChemFile readChemFile(IChemFile oFile){
        IChemSequence oSequence = oFile.getBuilder().newInstance(IChemSequence.class);
        oFile.addChemSequence(oSequence);
        IAtomContainer oMolecule = oFile.getBuilder().newInstance(IAtomContainer.class);
        oSequence.addChemModel(oFile.getBuilder().newInstance(IChemModel.class, oMolecule));
        readMolecule(oMolecule);
        return oFile;
    }"," private IChemFile readChemFile(IChemFile oFile){
        IChemSequence oSequence = oFile.getBuilder().newInstance(IChemSequence.class);
        oFile.addChemSequence(oSequence);
        IAtomContainer oMolecule = oFile.getBuilder().newInstance(IAtomContainer.class);
        oSequence.addChemModel(oFile.getBuilder().newInstance(IChemModel.class, oMolecule));
        readMolecule(oMolecule);
        return oFile;
    }"," private IChemFile readChemFile(IChemFile oFile){
        IChemSequence oSequence = oFile.getBuilder().newInstance(IChemSequence.class);
        oFile.addChemSequence(oSequence);
        IAtomContainer oMolecule = oFile.getBuilder().newInstance(IAtomContainer.class);
        oSequence.addChemModel(oFile.getBuilder().newInstance(IChemModel.class, oMolecule));
        readMolecule(oMolecule);
        return oFile;
    }"," private IChemFile readChemFile(IChemFile oFile){
        IChemSequence oSequence = oFile.getBuilder().newInstance(IChemSequence.class);
        oFile.addChemSequence(oSequence);
        IAtomContainer oMolecule = oFile.getBuilder().newInstance(IAtomContainer.class);
        oSequence.addChemModel(oFile.getBuilder().newInstance(IChemModel.class, oMolecule));
        readMolecule(oMolecule);
        return oFile;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.09798754898475408,  0.09798754898475408,  0.09798754898475408,  0.09798754898475408,1779.0,0.9626623376623377,1779.0,0.9626623376623377,1779.0,0.9626623376623377,1779.0,0.9626623376623377,0.0,0.0,0.0,0.0,0.0,0.0,6.0,0.6,0.0,0.0,9.0,0.9
515,cdk,"public DescriptorValue calculate(IAtomContainer mol){
    try {
        mol = mol.clone();
    } catch (CloneNotSupportedException ex) {
    }
    double polar = 0, weight = 0;
    try {
        IChemObjectBuilder builder = mol.getBuilder();
        CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.getInstance(builder);
        for (IAtom atom : mol.atoms()) {
            IAtomType type = matcher.findMatchingAtomType(mol, atom);
            AtomTypeManipulator.configure(atom, type);
        }
        CDKHydrogenAdder adder = CDKHydrogenAdder.getInstance(builder);
        adder.addImplicitHydrogens(mol);
        TPSADescriptor tpsa = new TPSADescriptor();
        DescriptorValue value = tpsa.calculate(mol);
        polar = ((DoubleResult) value.getValue()).doubleValue();
        for (IAtom atom : mol.atoms()) {
            weight += Isotopes.getInstance().getMajorIsotope(atom.getSymbol()).getExactMass();
            Integer hcount = atom.getImplicitHydrogenCount();
            if (hcount != CDKConstants.UNSET)
                weight += hcount * 1.00782504;
        }
    } catch (CDKException | IOException exception) {
        return getDummyDescriptorValue(exception);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(weight == 0 ? 0 : polar / weight), getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/FractionalPSADescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/FractionalPSADescriptor.java,"/**
     * Calculates the topological polar surface area and expresses it as a ratio to molecule size.
     *
     * @param mol The {@link IAtomContainer} whose volume is to be calculated
     * @return descriptor(s) retaining to polar surface area
     */",104-145,"('calculate', {'INSTRUCTION': {'covered': 111, 'missed': 8}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 22, 'missed': 3}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",251.0,16.0,Calculates the topological polar surface area and expresses it as a ratio to molecule size.,"First computes the topological polar surface area, ultimately express this value as a ratio to molecule size.",The ratio to molecule size is calculated by summing the topological polar surface area.,0.346235219269334,Calculates the topological polar surface and expresses it as a ratio to the size of the molecule.," public DescriptorValue calculate(IAtomContainer mol){
        try {
            double tpsa = calculateTPSA(mol);
            double molWeight = calculateMolecularWeight(mol);
            double tpsaEfficiency = tpsa / molWeight;
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(
                    tpsaEfficiency), getDescriptorNames());
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }"," public DescriptorValue calculate(IAtomContainer mol){
        try {
            double tpsa = calculateTPSA(mol);
            double molWeight = calculateMolecularWeight(mol);
            double tpsaEfficiency = tpsa / molWeight;
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(
                    tpsaEfficiency), getDescriptorNames());
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }",Not Valid," public DescriptorValue calculate(IAtomContainer mol){
        try {
            double tpsa = calculateTPSA(mol);
            double mw = calculateMolecularWeight(mol);
            double tpsaEfficiency = tpsa / mw;
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(
                    tpsaEfficiency), getDescriptorNames());
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }",NOT PASS,NOT PASS,NOT PASS,Not Valid,  0.170621876783798,  0.170621876783798,  0.170621876783798,None,202.0,0.8015873015873016,202.0,0.8015873015873016,202.0,0.8015873015873016,None,None,0.0,0.0,2.0,0.02631578947368421,None,None,7.0,0.3888888888888889,6.0,0.3333333333333333,15.0,0.9375
516,cdk,"public static List<IElement> elements(IMolecularFormula formula){
    List<IElement> elementList = new ArrayList<IElement>();
    List<String> stringList = new ArrayList<String>();
    for (IIsotope isotope : formula.isotopes()) {
        if (!stringList.contains(isotope.getSymbol())) {
            elementList.add(isotope);
            stringList.add(isotope.getSymbol());
        }
    }
    return elementList;
}",elements,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     *  Get a list of all Elements which are contained
     *  molecular.
     *
     *@param   formula The MolecularFormula to check
     *@return          The list with the IElements in this molecular formula
     */",169-188,"('elements', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,11.0,Get a list of all Elements which are contained  molecular.,Retrieves and returns a list of all the Elements which are contained into molecular.,Get a list of elements that are contained in a molecule.,0.192648846638216,Get a list of all the elements that are molecular contents.," public static List<IElement> elements(IMolecularFormula formula){
        List<IElement> elementList = new ArrayList<IElement>();
        for (IIsotope isotope : formula.isotopes()) {
            elementList.add(isotope.getElement());
        }
        return elementList;
    }"," public static List<IElement> elements(IMolecularFormula formula){
        List<IElement> elements = new ArrayList<IElement>();
        for (IIsotope isotope : formula.isotopes()) {
            elements.add(isotope.getElement());
        }
        return elements;
    }"," public static List<IElement> elements(IMolecularFormula formula){
        List<IElement> elements = new ArrayList<IElement>();
        for (IIsotope isotope : formula.isotopes()) {
            if (!elements.contains(isotope.getElement())) elements.add(isotope.getElement());
        }
        return elements;
    }"," public static List<IElement> elements(IMolecularFormula formula){
        List<IElement> elements = new ArrayList<IElement>();
        for (IIsotope isotope : formula.isotopes()) {
            if (!elements.contains(isotope.getElement())) elements.add(isotope.getElement());
        }
        return elements;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5622366327868488,  0.5245744428952491,  0.6291267196847544,  0.6291267196847544,38.0,0.41304347826086957,41.0,0.44565217391304346,29.0,0.31521739130434784,29.0,0.31521739130434784,3.0,0.05454545454545454,17.0,0.2463768115942029,17.0,0.2463768115942029,5.0,0.3333333333333333,5.0,0.4166666666666667,6.0,0.5
517,matsim-libs,"public static void addCarrierVehicle(Carrier carrier, CarrierVehicle carrierVehicle){
    carrier.getCarrierCapabilities().getCarrierVehicles().put(carrierVehicle.getId(), carrierVehicle);
}",addCarrierVehicle,org/matsim/contrib/freight/carrier/CarrierUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/carrier/CarrierUtils.java,"/**
	 * Adds an carrierVehicle to the CarrierCapabilites of the Carrier.
	 * @param carrier
	 * @param carrierVehicle
	 */",19-26,"('addCarrierVehicle', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,10.0,Adds an carrierVehicle to the CarrierCapabilites of the Carrier.,Adds a carrierVehicle object to the CarrierCapabilities of the Carrirer.,The CarrierCapabilites are added to the carrier vehicle.,0.379942985479416,Adds a carrier vehicle to the Carrier's CarrierCapabilites.," public static void addCarrierVehicle(Carrier carrier, CarrierVehicle carrierVehicle){
	 		CarrierCapabilities carrierCapabilities = carrier.getCarrierCapabilities();
 		carrierCapabilities.addCarrierVehicle(carrierVehicle);
 	}		"," public static void addCarrierVehicle(Carrier carrier, CarrierVehicle carrierVehicle){
	 	CarrierCapabilities carrierCapabilities = carrier.getCarrierCapabilities();
 	carrierCapabilities.addCarrierVehicle(carrierVehicle);		
 }"," public static void addCarrierVehicle(Carrier carrier, CarrierVehicle carrierVehicle){
	 		if (carrier.getCarrierCapabilities().getCarrierVehicles().containsKey(carrierVehicle.getVehicle().getId())){
 			log.warn(""CarrierVehicle with id "" + carrierVehicle.getVehicle().getId() + "" already exists. Not added."");
 		} else {
 			carrier.getCarrierCapabilities().getCarrierVehicles().put(carrierVehicle.getVehicle().getId(), carrierVehicle);
 		}
 	}		"," public static void addCarrierVehicle(Carrier carrier, CarrierVehicle carrierVehicle){
	 		CarrierCapabilities.Builder builder = CarrierCapabilities.Builder.newInstance();
 		builder.addType(carrierVehicle.getType());
 		builder.addVehicle(carrierVehicle);
 		carrier.setCarrierCapabilities(builder.build());
 	}		",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6276525043810017,  0.6276525043810017,  0.617704975534489,  0.7516575525347355,13.0,0.37142857142857144,13.0,0.37142857142857144,29.0,0.5178571428571429,53.0,0.6022727272727273,0.0,0.0,31.0,0.5535714285714286,64.0,0.7272727272727273,4.0,0.36363636363636365,7.0,0.7,8.0,0.8
518,weblogic-kubernetes-operator," boolean containsServer(@Nonnull String serverName){
    return getServerConfigs().stream().anyMatch(c -> serverName.equals(c.getName()));
}",containsServer,oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,"/**
   * Whether this cluster contains a server with the given server name,
   * including servers that are both configured and dynamic servers.
   *
   * @param serverName server name to be checked
   * @return True if the cluster contains a server with the given server name
   */",365-374,"('containsServer', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,22.0,"Whether this cluster contains a server with the given server name,  including servers that are both configured and dynamic servers.","Returns true if the cluster contains a server with the given server name, otherwise false.","Whether this cluster contains a server with a given name, or one that is configured and dynamic.",0.553052511352453,"If this cluster contains a server with the given server name, including servers that are both configured and dynamic servers.","  boolean containsServer(@Nonnull String serverName){
    return servers.stream().anyMatch(server -> server.getName().equals(serverName)) ||
        (dynamicServersConfig != null && dynamicServersConfig.containsServer(serverName));      
  }","  boolean containsServer(@Nonnull String serverName){
    return servers.stream().anyMatch(server -> server.getName().equals(serverName));      
  }","  boolean containsServer(@Nonnull String serverName){
    return servers.stream().anyMatch(server -> server.getName().equals(serverName)) ||
        (dynamicServersConfig != null && dynamicServersConfig.containsServer(serverName));      
  }","  boolean containsServer(@Nonnull String serverName){
    return servers.stream().anyMatch(server -> server.getName().equals(serverName)) ||
        (dynamicServersConfig != null && dynamicServersConfig.getDynamicServers().stream().anyMatch(server -> server.getName().equals(serverName)));      
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6575482770584611,  0.6889570658031614,  0.6439311637618511,  0.6575482770584611,21.0,0.44680851063829785,9.0,0.25,36.0,0.5454545454545454,21.0,0.44680851063829785,13.0,0.2765957446808511,20.0,0.30303030303030304,0.0,0.0,13.0,0.6190476190476191,1.0,0.047619047619047616,8.0,0.38095238095238093
519,cdk,"private PDBAtom readAtom(String cLine, int lineLength) throws CDKException{
    if (lineLength < 59) {
        throw new RuntimeException(""PDBReader error during readAtom(): line too short"");
    }
    boolean isHetatm = cLine.startsWith(""HETATM"");
    String atomName = cLine.substring(12, 16).trim();
    String resName = cLine.substring(17, 20).trim();
    String symbol = parseAtomSymbol(cLine);
    if (symbol == null)
        handleError(""Cannot parse symbol from "" + atomName);
    PDBAtom oAtom = new PDBAtom(symbol, new Point3d(Double.parseDouble(cLine.substring(30, 38)), Double.parseDouble(cLine.substring(38, 46)), Double.parseDouble(cLine.substring(46, 54))));
    if (useHetDictionary.isSet() && isHetatm) {
        String cdkType = typeHetatm(resName, atomName);
        oAtom.setAtomTypeName(cdkType);
        if (cdkType != null) {
            try {
                cdkAtomTypeFactory.configure(oAtom);
            } catch (CDKException cdke) {
                logger.warn(""Could not configure"", resName, "" "", atomName);
            }
        }
    }
    oAtom.setRecord(cLine);
    oAtom.setSerial(Integer.parseInt(cLine.substring(6, 11).trim()));
    oAtom.setName(atomName.trim());
    oAtom.setAltLoc(cLine.substring(16, 17).trim());
    oAtom.setResName(resName);
    oAtom.setChainID(cLine.substring(21, 22).trim());
    oAtom.setResSeq(cLine.substring(22, 26).trim());
    oAtom.setICode(cLine.substring(26, 27).trim());
    if (useHetDictionary.isSet() && isHetatm) {
        oAtom.setID(oAtom.getResName() + ""."" + atomName);
    } else {
        oAtom.setAtomTypeName(oAtom.getResName() + ""."" + atomName);
    }
    if (lineLength >= 59) {
        String frag = cLine.substring(54, Math.min(lineLength, 60)).trim();
        if (frag.length() > 0) {
            oAtom.setOccupancy(Double.parseDouble(frag));
        }
    }
    if (lineLength >= 65) {
        String frag = cLine.substring(60, Math.min(lineLength, 66)).trim();
        if (frag.length() > 0) {
            oAtom.setTempFactor(Double.parseDouble(frag));
        }
    }
    if (lineLength >= 75) {
        oAtom.setSegID(cLine.substring(72, Math.min(lineLength, 76)).trim());
    }
    if (lineLength >= 79) {
        String frag;
        if (lineLength >= 80) {
            frag = cLine.substring(78, 80).trim();
        } else {
            frag = cLine.substring(78);
        }
        if (frag.length() > 0) {
            if (frag.endsWith(""-"") || frag.endsWith(""+"")) {
                oAtom.setCharge(Double.parseDouble(new StringBuilder(frag).reverse().toString()));
            } else {
                oAtom.setCharge(Double.parseDouble(frag));
            }
        }
    }
    String oxt = cLine.substring(13, 16).trim();
    if (oxt.equals(""OXT"")) {
        oAtom.setOxt(true);
    } else {
        oAtom.setOxt(false);
    }
    return oAtom;
}",readAtom,org/openscience/cdk/io/PDBReader.java,/storage/pdb/src/main/java/org/openscience/cdk/io/PDBReader.java,"/**
     * Creates an <code>Atom</code> and sets properties to their values from
     * the ATOM or HETATM record. If the line is shorter than 80 characters, the
     * information past 59 characters is treated as optional. If the line is
     * shorter than 59 characters, a <code>RuntimeException</code> is thrown.
     *
     * @param cLine  the PDB ATOM or HEATATM record.
     * @return the <code>Atom</code> created from the record.
     * @throws RuntimeException if the line is too short (less than 59 characters).
     */",610-723,"('readAtom', {'INSTRUCTION': {'covered': 250, 'missed': 48}, 'BRANCH': {'covered': 27, 'missed': 9}, 'LINE': {'covered': 46, 'missed': 6}, 'COMPLEXITY': {'covered': 10, 'missed': 9}, 'METHOD': {'covered': 1, 'missed': 0}})",684.0,22.0,Creates an <code>Atom</code> and sets properties to their values from  the ATOM or HETATM record.,"Uses the ATOM or HETAM record of creating and setting their properties. For all those lines containing less than 80 characters,  the information longer than 50 is treated as optional. If the line contains less than 59 characters, then a RuntimeExcpetion is thrown.",The Atom or HETAm record is used to set the properties to their values.,0.311175817068947,Creates an <code>atom</code> and sets properties to their values from the ATOM or HETATM record.,"private PDBAtom readAtom(String cLine, int lineLength) throws CDKException{
        PDBAtom atom = new PDBAtom();
        StringTokenizer st = new StringTokenizer(cLine);
        String token = st.nextToken();
        if (token.length() != 6)
            throw new CDKException(""PDBReader: Invalid ATOM/HETATM record: "" + cLine);
        atom.setRecordName(token);
        atom.setSerial(Integer.parseInt(st.nextToken()));
        atom.setName(st.nextToken());
        atom.setAltLoc(st.nextToken().charAt(0));
        atom.setResName(st.nextToken());
        atom.setChainID(st.nextToken().charAt(0));
        atom.setResSeq(Integer.parseInt(st.nextToken()));
        atom.setiCode(st.nextToken().charAt(0));
        atom.setX(Double.parseDouble(st.nextToken()));
        atom.setY(Double.parseDouble(st.nextToken()));
        atom.setZ(Double.parseDouble(st.nextToken()));
        atom.setOccupancy(Double.parseDouble(st.nextToken()));
        atom.setTempFactor(Double.parseDouble(st.nextToken()));
        atom.setElement(st.nextToken());
        atom.setCharge(st.nextToken());
        return atom;
    }","private PDBAtom readAtom(String cLine, int lineLength) throws CDKException{
        PDBAtom atom = new PDBAtom();
        if (lineLength < 59) {
            throw new CDKException(""PDBReader: line too short to be an ATOM record"");
        }
        atom.setAtomName(cLine.substring(12, 16).trim());
        atom.setAtomNumber(Integer.parseInt(cLine.substring(6, 11).trim()));
        atom.setX(Double.parseDouble(cLine.substring(30, 38).trim()));
        atom.setY(Double.parseDouble(cLine.substring(38, 46).trim()));
        atom.setZ(Double.parseDouble(cLine.substring(46, 54).trim()));
        atom.setOccupancy(Double.parseDouble(cLine.substring(54, 60).trim()));
        atom.setTempFactor(Double.parseDouble(cLine.substring(60, 66).trim()));
        atom.setElement(cLine.substring(76, 78).trim());
        return atom;        
 }","private PDBAtom readAtom(String cLine, int lineLength) throws CDKException{
        PDBAtom atom = new PDBAtom();
        StringTokenizer st = new StringTokenizer(cLine);
        String token = st.nextToken();
        if (token.length() != 4)
            throw new CDKException(""PDB file error: ATOM record must have 4 characters in serial number field."");
        atom.setSerial(Integer.parseInt(token));
        token = st.nextToken();
        if (token.length() != 4)
            throw new CDKException(""PDB file error: ATOM record must have 4 characters in name field."");
        atom.setName(token);
        token = st.nextToken();
        if (token.length() != 1)
            throw new CDKException(""PDB file error: ATOM record must have 1 character in altLoc field."");
        atom.setAltLoc(token.charAt(0));
        token = st.nextToken();
        if (token.length() != 4)
            throw new CDKException(""PDB file error: ATOM record must have 4 characters in resName field."");
        atom.setResName(token);
        token = st.nextToken();
        if (token.length() != 1)
            throw new CDKException(""PDB file error: ATOM record must have 1 character in chainID field."");
        atom.setChainID(token.charAt(0));
        token = st.nextToken();
        if (token.length() != 4)
            throw new CDKException(""PDB file error: ATOM record must have 4 characters in resSeq field."");
        atom.setResSeq(Integer.parseInt(token));
        token = st.nextToken();
        if (token.length() != 1)
            throw new CDKException(""PDB file error: ATOM record must have 1 character in iCode field."");
        atom.setiCode(token.charAt(0));
        token = st.nextToken();
        if (token.length() != 8)
            throw new CDKException(""PDB file error: ATOM record must have 8 characters in x field."");
        atom.setX(Double.       
 }","private PDBAtom readAtom(String cLine, int lineLength) throws CDKException{
        PDBAtom atom = new PDBAtom();
        int atomSerial = 0;
        int atomName = 0;
        int altLoc = 0;
        int resName = 0;
        int chainID = 0;
        int resSeq = 0;
        int iCode = 0;
        int x = 0;
        int y = 0;
        int z = 0;
        int occupancy = 0;
        int tempFactor = 0;
        int element = 0;
        int charge = 0;
        int atomType = 0;
        int isotope = 0;
        int chargeGroup = 0;
        int pdbx_PDB_model_num = 0;
        int pdbx_alt_atom_id = 0;
        int pdbx_PDB_ins_code = 0;
        int pdbx_formal_charge = 0;
        int pdbx_partial_charge = 0;
        int pdbx_formal_charge_flag = 0;
        int pdbx_partial_charge_flag = 0;
        int pdbx_aromatic_flag = 0;
        int pdbx_aromatic_ring_size = 0;
        int pdbx_secondary_structure = 0;
        int pdbx_secondary_structure_key = 0;
        int pdbx_ter_flag = 0;
        int pdbx_ter_asn = 0;
        int pdbx_ter_asn_seq_id = 0;
        int pdbx_ter_asn_icode = 0;
        int pdbx_ter_asn_atom_id = 0;
        int pdbx_ter_asn_comp_id = 0;
        int pdbx_ter_asn_seq_id_2 = 0;
        int pdbx_ter_asn_icode_2 = 0;
        int pdbx_ter_asn_atom_id_2 = 0;
        int pdbx_ter_asn_comp_id_2 = 0;
        int pdbx_ter_asn_seq        
 }",NOT PASS,NOT PASS,Syntax Error,Syntax Error,  0.14282548111386667,  0.19817928406059937,None,None,503.0,0.7343065693430657,520.0,0.7591240875912408,617.0,0.9007299270072993,510.0,0.7445255474452555,143.0,0.5218978102189781,228.0,0.8321167883211679,163.0,0.5207667731629393,41.0,0.9318181818181818,1.0,0.0625,14.0,0.875
520,dcache,"public boolean hasExpired(){
    Date now = new Date();
    return _whenIShouldExpire != null ? !now.before(_whenIShouldExpire) : false;
}",hasExpired,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,"/**
     * This function checks whether our parent should expunge us.
     */",175-183,"('hasExpired', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,10.0,This function checks whether our parent should expunge us.,Checks the cases in which the parent can destroy us.,The function checks if our parent should expunge us.,2.24886654103452,This function checks if our parent should write us off.," public boolean hasExpired(){
        if (_whenIShouldExpire == null) {
            return false;
        }
    
        return _whenIShouldExpire.before(new Date());
    }"," public boolean hasExpired(){
        if (_whenIShouldExpire == null) {
            return false;
        }
        return _whenIShouldExpire.before(new Date());
    }"," public boolean hasExpired(){
        if (_whenIShouldExpire == null) {
            return false;
        }
    
        if (_whenIShouldExpire.before(new Date())) {
            return true;
        }
    
        return false;
    }"," public boolean hasExpired(){
        if (_whenIShouldExpire == null) {
            return false;
        }
        return _whenIShouldExpire.before(new Date());
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3484335415227601,  0.3484335415227601,  0.3484335415227601,  0.3231295665131397,18.0,0.5806451612903226,18.0,0.5806451612903226,18.0,0.5806451612903226,24.0,0.6153846153846154,0.0,0.0,0.0,0.0,10.0,0.2564102564102564,8.0,0.7272727272727273,4.0,0.36363636363636365,2.0,0.2
521,acs-aem-commons,"private boolean isChecksumable(Node node, ChecksumGeneratorOptions options) throws RepositoryException{
    final Set<String> nodeTypeIncludes = options.getIncludedNodeTypes();
    final Set<String> nodeTypeExcludes = options.getExcludedNodeTypes();
    final String primaryNodeType = node.getPrimaryNodeType().getName();
    return nodeTypeIncludes.contains(primaryNodeType) && !nodeTypeExcludes.contains(primaryNodeType);
}",isChecksumable,com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,"/**
     * Ensures the node's primary type is included in the Included Node Types and NOT in the Excluded Node Types and NOT in the Excluded Node Names.
     *
     * @param node    the candidate node
     * @param options the checksum options containing the included and excluded none types
     * @return true if the node represents a checksum-able node system
     * @throws RepositoryException
     */",142-157,"('isChecksumable', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",70.0,28.0,Ensures the node's primary type is included in the Included Node Types and NOT in the Excluded Node Types and NOT in the Excluded Node Names.,"Makes sure the node's primary type is included in the included node types, not included in the Excluded Node Types and not included in the Excluded Node Names.",The included and excluded types of the primary type of the node should be included.,1.43477965344178,Ensures that the primary node type is included in the included node types and NOT in the excluded node types and NOT in the excluded node names.," private boolean isChecksumable(Node node, ChecksumGeneratorOptions options) throws RepositoryException{
        return options.getIncludedNodeTypes().contains(node.getPrimaryNodeType().getName()) &&
                !options.getExcludedNodeTypes().contains(node.getPrimaryNodeType().getName()) &&
                !options.getExcludedNodeNames().contains(node.getName());       
 }"," private boolean isChecksumable(Node node, ChecksumGeneratorOptions options) throws RepositoryException{
        return options.getIncludedNodeTypes().contains(node.getPrimaryNodeType().getName()) &&
                !options.getExcludedNodeTypes().contains(node.getPrimaryNodeType().getName()) &&
                !options.getExcludedNodeNames().contains(node.getName());       
 }"," private boolean isChecksumable(Node node, ChecksumGeneratorOptions options) throws RepositoryException{
        return options.getIncludedTypes().contains(node.getPrimaryNodeType().getName());        
 }"," private boolean isChecksumable(Node node, ChecksumGeneratorOptions options) throws RepositoryException{
        return options.getIncludedNodeTypes().contains(node.getPrimaryNodeType().getName()) &&
                !options.getExcludedNodeTypes().contains(node.getPrimaryNodeType().getName()) &&
                !options.getExcludedNodeNames().contains(node.getName());       
 }",NOT PASS,PASS,PASS,NOT PASS,  0.4571288019798629,  0.4571288019798629,  0.4571288019798629,  0.323081999163097,36.0,0.5070422535211268,36.0,0.5070422535211268,36.0,0.5070422535211268,39.0,0.5492957746478874,0.0,0.0,0.0,0.0,37.0,0.5211267605633803,9.0,0.3103448275862069,12.0,0.42857142857142855,24.0,0.8888888888888888
522,dcache,"public boolean equalsOrHasChild(StatePath otherPath){
    if (otherPath == null) {
        return false;
    }
    if (_elements.size() > otherPath._elements.size()) {
        return false;
    }
    for (int i = 0; i < _elements.size(); i++) {
        if (_elements.get(i) != otherPath._elements.get(i)) {
            return false;
        }
    }
    return true;
}",equalsOrHasChild,org/dcache/services/info/base/StatePath.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StatePath.java,"/**
     * Check whether otherPath points to the same location, or is a child of this path.  This is
     * true iff each element of this path is identical to the corresponding element in otherPath.
     * <pre>
     *  StatePath p1 = new StatePath(""foo.bar"");
     *  StatePath p2 = new StatePath(""foo.bar.baz"");
     *
     *  p1.equalsOrHasChild(p1) // true
     *  p2.equalsOrHasChild(p2) // true
     *  p1.equalsOrHasChild(p2) // true
     *  p2.equalsOrHasChild(p1) // false
     * </pre>
     *
     * @param otherPath the potential child path
     * @return true if otherPath is a child of this path.
     */",181-227,"('equalsOrHasChild', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,17.0,"Check whether otherPath points to the same location, or is a child of this path.",Implements the control needed to check whether otherPath is of the current path or a child. Returns true iff each element of the current path matches the corresponding element in otherPath.,"If otherpath points to the same location, it's a child of this path.",0.37755884263397,Check if otherPath points to the same location or if it is a child of that path.,"public boolean equalsOrHasChild(StatePath otherPath){
        if (equals(otherPath)) {
            return true;
        }
    
        if (otherPath._elements.size() < _elements.size()) {
            return false;
        }
    
        for (int i = 0; i < _elements.size(); i++) {
            if (otherPath._elements.get(i) != _elements.get(i)) {
                return false;
            }
        }
    
        return true;
    }","public boolean equalsOrHasChild(StatePath otherPath){
        if(otherPath.size() < size()){
            return false;
        }
        for(int i = 0; i < size(); i++){
            if(!otherPath.get(i).equals(get(i))){
                return false;
            }
        }
        return true;
    }","public boolean equalsOrHasChild(StatePath otherPath){
        if(equals(otherPath)){
            return true;
        }
    
        if(otherPath._elements.size() < _elements.size()){
            return false;
        }
    
        for(int i = 0; i < _elements.size(); i++){
            if(!otherPath._elements.get(i).equals(_elements.get(i))){
                return false;
            }
        }
    
        return true;
    }","public boolean equalsOrHasChild(StatePath otherPath){
        if(equals(otherPath)){
            return true;
        }
    
        if(otherPath._elements.size() < _elements.size()){
            return false;
        }
    
        for(int i = 0; i < _elements.size(); i++){
            if(!otherPath._elements.get(i).equals(_elements.get(i))){
                return false;
            }
        }
    
        return true;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8443551806695231,  0.5870172184718552,  0.730780869651431,  0.730780869651431,14.0,0.15730337078651685,25.0,0.2840909090909091,17.0,0.1827956989247312,17.0,0.1827956989247312,25.0,0.2808988764044944,5.0,0.053763440860215055,5.0,0.053763440860215055,26.0,0.8125,5.0,0.2777777777777778,5.0,0.3125
523,jackson-databind,"public static T[] insertInListNoDup(T[] array, T element){
    final int len = array.length;
    for (int ix = 0; ix < len; ++ix) {
        if (array[ix] == element) {
            if (ix == 0) {
                return array;
            }
            T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len);
            System.arraycopy(array, 0, result, 1, ix);
            result[0] = element;
            ++ix;
            int left = len - ix;
            if (left > 0) {
                System.arraycopy(array, ix, result, ix, left);
            }
            return result;
        }
    }
    T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len + 1);
    if (len > 0) {
        System.arraycopy(array, 0, result, 1, len);
    }
    result[0] = element;
    return result;
}",insertInListNoDup,com/fasterxml/jackson/databind/util/ArrayBuilders.java,/src/main/java/com/fasterxml/jackson/databind/util/ArrayBuilders.java,"/**
     * Helper method for constructing a new array that contains specified
     * element followed by contents of the given array but never contains
     * duplicates.
     * If element already existed, one of two things happens: if the element
     * was already the first one in array, array is returned as is; but
     * if not, a new copy is created in which element has moved as the head.
     */",198-238,"('insertInListNoDup', {'INSTRUCTION': {'covered': 74, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",210.0,23.0,Helper method for constructing a new array that contains specified  element followed by contents of the given array but never contains  duplicates.,"Constructs a new array containing the specified elements (non-duplicated) followed by the content of the array given as input. If the element already exists, then it is returned as is if it belongs to the first position of the array. If not, a new copy is created, and the element is moved as the head.",The method for constructing a new array that contains specified element followed by contents of the given array but never contains duplicate elements is called the helpers method.,0.521407435142276,"A helper method for constructing a new array that contains a specified element followed by the contents of the given array, but never contains duplicates.","public static T[] insertInListNoDup(T[] array, T element){
        if (array == null) {
            return new T[] { element };
        }
        int len = array.length;
        T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len + 1);
        result[0] = element;
        System.arraycopy(array, 0, result, 1, len);
        return result;
    }","public static T[] insertInListNoDup(T[] array, T element){
        if(array == null){
            return new T[]{element};
        }
        int len = array.length;
        for(int i = 0; i < len; i++){
            if(array[i].equals(element)){
                return array;
            }
        }
        T[] newArray = (T[]) Array.newInstance(array.getClass().getComponentType(), len + 1);
        newArray[0] = element;
        System.arraycopy(array, 0, newArray, 1, len);
        return newArray;
    }","public static T[] insertInListNoDup(T[] array, T element){
        if(array == null){
            return new T[]{element};
        }
        int len = array.length;
        T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len + 1);
        result[0] = element;
        System.arraycopy(array, 0, result, 1, len);
        return result;      
 }","public static T[] insertInListNoDup(T[] array, T element){
        if (array == null) {
            return new T[] { element };
        }
        int len = array.length;
        T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len + 1);
        result[0] = element;
        System.arraycopy(array, 0, result, 1, len);
        return result;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.376762022071917,  0.468483810259342,  0.376762022071917,  0.376762022071917,131.0,0.6208530805687204,122.0,0.5781990521327014,131.0,0.6208530805687204,131.0,0.6208530805687204,37.0,0.2868217054263566,0.0,0.0,0.0,0.0,49.0,0.875,5.0,0.19230769230769232,8.0,0.27586206896551724
524,dataverse,"public static void checkForDuplicateFileNamesFinal(DatasetVersion version, List<DataFile> newFiles, DataFile fileToReplace){
    // Step 1: create list of existing path names from all FileMetadata in the DatasetVersion
    // unique path name: directoryLabel + file separator + fileLabel
    Set<String> pathNamesExisting = existingPathNamesAsSet(version, ((fileToReplace == null) ? null : fileToReplace.getFileMetadata()));
    // Step 2: check each new DataFile against the list of path names, if a duplicate create a new unique file name
    for (Iterator<DataFile> dfIt = newFiles.iterator(); dfIt.hasNext(); ) {
        FileMetadata fm = dfIt.next().getFileMetadata();
        fm.setLabel(duplicateFilenameCheck(fm, pathNamesExisting));
    }
}",checkForDuplicateFileNamesFinal,edu/harvard/iq/dataverse/ingest/IngestUtil.java,/src/main/java/edu/harvard/iq/dataverse/ingest/IngestUtil.java,"/**
     * Checks a list of new data files for duplicate names, renaming any
     * duplicates to ensure that they are unique.
     *
     * @param version the dataset version
     * @param newFiles the list of new data files to add to it
     * @param fileToReplace
     */",54-74,"('checkForDuplicateFileNamesFinal', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",94.0,21.0,"Checks a list of new data files for duplicate names, renaming any  duplicates to ensure that they are unique.",Renames duplicate names after those have been fetched from a list of new data files.,Checks a list of new data files for duplicate names and renames any duplicate files that are not unique.,0.257551523809955,"Checks a list of new data files for duplicate names, renaming all duplicates to make sure they are unique."," public static void checkForDuplicateFileNamesFinal(DatasetVersion version, List<DataFile> newFiles, DataFile fileToReplace){
        // check for duplicate file names
        Set<String> fileNames = new HashSet<>();
        for (DataFile dataFile : newFiles) {
            if (dataFile.getFileMetadataId() == null) {
                String fileName = dataFile.getFileName();
                if (fileNames.contains(fileName)) {
                    String newFileName = FileUtil.getUniqueFileName(fileName, fileNames);
                    dataFile.setFileName(newFileName);
                }
                fileNames.add(dataFile.getFileName());
            }
        }       
 }","public static void checkForDuplicateFileNamesFinal(DatasetVersion version, List<DataFile> newFiles, DataFile fileToReplace){
        if (newFiles.size() > 0) {
            Set<String> fileNames = new HashSet<>();
            for (DataFile newFile : newFiles) {
                if (fileNames.contains(newFile.getFileName())) {
                    newFile.setFileName(FileUtil.getUniqueFileName(newFile.getFileName()));
                }
                fileNames.add(newFile.getFileName());
            }
        }       
 }",Not Valid,"public static void checkForDuplicateFileNamesFinal(DatasetVersion version, List<DataFile> newFiles, DataFile fileToReplace){
        Set<String> fileNames = new HashSet<>();
        for (DataFile dataFile : newFiles) {
            if (dataFile.getFileMetadataId() == fileToReplace.getFileMetadataId()) {
                continue;
            }
            String fileName = dataFile.getFileMetadata().getLabel();
            if (fileNames.contains(fileName)) {
                String newFileName = fileName + "" (1)"";
                dataFile.getFileMetadata().setLabel(newFileName);
                fileNames.add(newFileName);
            } else {
                fileNames.add(fileName);
            }
        }       
 }",NOT PASS,NOT PASS,NOT PASS,Not Valid,  0.44776694466821526,  0.4105891301297546,  0.4779694983930645,None,55.0,0.5288461538461539,58.0,0.6041666666666666,64.0,0.5378151260504201,None,None,45.0,0.4326923076923077,33.0,0.2773109243697479,None,None,19.0,0.95,3.0,0.15,8.0,0.4
525,shardingsphere-elasticjob,"public static boolean isExtraction(final String appURL){
    for (String each : EXTRACTION_TYPES) {
        if (appURL.endsWith(each)) {
            return true;
        }
    }
    return false;
}",isExtraction,org/apache/shardingsphere/elasticjob/cloud/scheduler/mesos/SupportedExtractionType.java,/elasticjob-cloud/elasticjob-cloud-scheduler/src/main/java/org/apache/shardingsphere/elasticjob/cloud/scheduler/mesos/SupportedExtractionType.java,"/**
     * Check whether the url is supported to extract or not.
     *
     * @param appURL app url
     * @return true is the url supported, otherwise not
     */",45-58,"('isExtraction', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,11.0,Check whether the url is supported to extract or not.,Checks whether for each extraction type the URL supports the extraction or not.,Check if the url is supported to extract.,0.0865203559077897,Check if the URL is supported for fetching or not.," public static boolean isExtraction(final String appURL){
        for (String extractionType : EXTRACTION_TYPES) {
            if (appURL.endsWith(extractionType)) {
                return true;
            }
        }
        return false;
    }       "," public static boolean isExtraction(final String appURL){
        for (String extractionType : EXTRACTION_TYPES) {
            if (appURL.endsWith(extractionType)) {
                return true;
            }
        }
        return false;
    }       "," public static boolean isExtraction(final String appURL){
        for (String extractionType : EXTRACTION_TYPES) {
            if (appURL.endsWith(extractionType)) {
                return true;
            }
        }
        return false;
    }       "," public static boolean isExtraction(final String appURL){
        for (String extractionType : EXTRACTION_TYPES) {
            if (appURL.endsWith(extractionType)) {
                return true;
            }
        }
        return false;
    }       ",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.9285749617868381,  0.9285749617868381,  0.9285749617868381,  0.9285749617868381,2.0,0.05263157894736842,2.0,0.05263157894736842,2.0,0.05263157894736842,2.0,0.05263157894736842,0.0,0.0,0.0,0.0,0.0,0.0,10.0,0.7142857142857143,4.0,0.36363636363636365,4.0,0.36363636363636365
526,dcache,"private void addComponent(String childName, StateComponent newChild){
    StateComponent existingChild = _children.get(childName);
    if (newChild instanceof StateComposite) {
        StateComposite newComposite = (StateComposite) newChild;
        if (existingChild instanceof StateComposite) {
            StateComposite existingComposite = (StateComposite) existingChild;
            for (Map.Entry<String, StateComponent> entry : existingComposite._children.entrySet()) {
                if (!newComposite._children.containsKey(entry.getKey())) {
                    newComposite._children.put(entry.getKey(), entry.getValue());
                }
            }
            newComposite.updateEarliestChildExpiryDate(existingComposite.getEarliestChildExpiryDate());
            newComposite.updateWhenIShouldExpireDate(existingComposite.getExpiryDate());
        }
    }
    _children.put(childName, newChild);
    LOGGER.trace(""Child {} now {}"", childName, newChild);
}",addComponent,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,"/**
     * Add a new component to our list of children.
     * <p>
     *
     * @param childName the name under which this item should be recorded
     * @param newChild  the StateComponent to be stored.
     */",441-482,"('addComponent', {'INSTRUCTION': {'covered': 67, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",155.0,10.0,Add a new component to our list of children.,Expand our list of children by adding to it a new component.,We need to add a new component to our list.,0.552740472916092,Add a new component to our children's list.," private void addComponent(String childName, StateComponent newChild){
        _children.put(childName, newChild);
    }"," private void addComponent(String childName, StateComponent newChild){
        _children.put(childName, newChild);
    }"," private void addComponent(String childName, StateComponent newChild){
        _children.put(childName, newChild);     
 }"," private void addComponent(String childName, StateComponent newChild){
        _children.put(childName, newChild);     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.09163631147181628,  0.09163631147181628,  0.09163631147181628,  0.09163631147181628,134.0,0.8589743589743589,134.0,0.8589743589743589,134.0,0.8589743589743589,134.0,0.8589743589743589,0.0,0.0,0.0,0.0,0.0,0.0,11.0,0.8461538461538461,3.0,0.3,7.0,0.6363636363636364
527,cdk,"public IMolecularFormulaSet generate(double mass){
    if (mass <= 0.0) {
        logger.error(""Proposed mass is not valid: "", mass);
        return null;
    }
    IMolecularFormula minimalMF = MolecularFormulaRangeManipulator.getMinimalFormula(mfRange, builder);
    IMolecularFormula maximalMF = MolecularFormulaRangeManipulator.getMaximalFormula(mfRange, builder);
    double massMim = MolecularFormulaManipulator.getTotalExactMass(minimalMF) - tolerance;
    double massMap = MolecularFormulaManipulator.getTotalExactMass(maximalMF) + tolerance;
    if (massMim > mass || massMap < mass) {
        logger.error(""Proposed mass is out of the range: "", mass);
        return null;
    }
    IMolecularFormulaSet molecularFormulaSet = builder.newInstance(IMolecularFormulaSet.class);
    int[][] matrix = this.matrix_Base;
    int numberElements = mfRange.getIsotopeCount();
    List<IIsotope> isotopes_TO = new ArrayList<IIsotope>();
    Iterator<IIsotope> isIt = mfRange.isotopes().iterator();
    while (isIt.hasNext()) isotopes_TO.add(isIt.next());
    isotopes_TO = orderList(isotopes_TO);
    for (int i = 0; i < matrix.length; i++) {
        int[] value_In = new int[numberElements];
        for (int j = 0; j < numberElements; j++) {
            if (matrix[i][j] == 0)
                value_In[j] = 0;
            else
                value_In[j] = 1;
        }
        int count_E = 0;
        ArrayList<Integer> elem_Pos = new ArrayList<Integer>();
        for (int j = 0; j < matrix[1].length; j++) if (value_In[j] != 0) {
            count_E++;
            elem_Pos.add(j);
        }
        boolean flag = true;
        int possChan = 0;
        String lastMFString = """";
        while (flag) {
            boolean flagBreak = false;
            for (int j = 0; j < matrix[1].length; j++) {
                int min = mfRange.getIsotopeCountMin(isotopes_TO.get(j));
                if (value_In[j] == 0)
                    if (min != 0)
                        flagBreak = true;
            }
            if (flagBreak)
                break;
            int occurence = getMaxOccurence(mass, elem_Pos.get(possChan).intValue(), value_In, isotopes_TO);
            if (occurence == 0)
                break;
            int maxx = mfRange.getIsotopeCountMax(isotopes_TO.get(elem_Pos.get(possChan).intValue()));
            int minn = mfRange.getIsotopeCountMin(isotopes_TO.get(elem_Pos.get(possChan).intValue()));
            if (occurence < minn | maxx < occurence) {
                if (possChan < elem_Pos.size() - 1) {
                    if (maxx < occurence)
                        value_In[elem_Pos.get(possChan).intValue()] = maxx;
                    possChan++;
                } else {
                    boolean foundZ = false;
                    for (int z = possChan - 1; z >= 0; z--) {
                        if (value_In[elem_Pos.get(z).intValue()] != 1) {
                            possChan = z;
                            foundZ = true;
                            int newValue = value_In[elem_Pos.get(possChan).intValue()] - 1;
                            value_In[elem_Pos.get(possChan).intValue()] = newValue;
                            for (int j = possChan + 1; j < elem_Pos.size(); j++) {
                                int p = elem_Pos.get(j).intValue();
                                value_In[p] = 1;
                            }
                            possChan++;
                            break;
                        }
                    }
                    if (!foundZ)
                        break;
                }
                continue;
            }
            value_In[elem_Pos.get(possChan).intValue()] = occurence;
            double massT = calculateMassT(isotopes_TO, value_In);
            double diff_new = Math.abs(mass - (massT));
            if (diff_new < tolerance) {
                IMolecularFormula myMF = getFormula(isotopes_TO, value_In);
                String newMFString = MolecularFormulaManipulator.getString(myMF);
                if (!newMFString.equals(lastMFString)) {
                    molecularFormulaSet.addMolecularFormula(myMF);
                    lastMFString = newMFString;
                }
            }
            if (count_E == 1)
                break;
            if (possChan < elem_Pos.size() - 1) {
                possChan++;
            } else {
                boolean foundZ = false;
                for (int z = possChan - 1; z >= 0; z--) {
                    if (value_In[elem_Pos.get(z).intValue()] != 1) {
                        possChan = z;
                        foundZ = true;
                        int newValue = value_In[elem_Pos.get(possChan).intValue()] - 1;
                        value_In[elem_Pos.get(possChan).intValue()] = newValue;
                        for (int j = possChan + 1; j < elem_Pos.size(); j++) {
                            int p = elem_Pos.get(j).intValue();
                            value_In[p] = 1;
                        }
                        possChan++;
                        break;
                    }
                }
                if (!foundZ)
                    break;
            }
        }
    }
    return returnOrdered(mass, molecularFormulaSet);
}",generate,org/openscience/cdk/formula/MassToFormulaTool.java,/legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java,"/**
     * Method that actually does the work of extracting the molecular formula.
     *
     * @param  mass            molecular formula to create from the mass
     * @return                 the filled molecular formulas as IMolecularFormulaSet
     */",242-415,"('generate', {'INSTRUCTION': {'covered': 462, 'missed': 1}, 'BRANCH': {'covered': 61, 'missed': 3}, 'LINE': {'covered': 89, 'missed': 0}, 'COMPLEXITY': {'covered': 30, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",951.0,12.0,Method that actually does the work of extracting the molecular formula.,Extracts the molecur formula.,The method actually does the work of getting the formula.,0.427849231626354,Method that actually does the work of extracting the molecular formula.," public IMolecularFormulaSet generate(double mass){
        IMolecularFormulaSet formulaSet = new MolecularFormulaSet();
        IMolecularFormula formula = generateFormula(mass);
        formulaSet.addMolecularFormula(formula);
        return formulaSet;
    }"," public IMolecularFormulaSet generate(double mass){
        return generate(mass, null);        
 }"," public IMolecularFormulaSet generate(double mass){
        IMolecularFormulaSet mfSet = new MolecularFormulaSet();
        IMolecularFormula mf = new MolecularFormula();
        mf.setCharge(charge);
        mfSet.addMolecularFormula(mf);
        mfSet = generate(mfSet, mass);
        return mfSet;
    }"," public IMolecularFormulaSet generate(double mass){
        IMolecularFormulaSet mfSet = new MolecularFormulaSet();
        IMolecularFormula mf = new MolecularFormula();
        mfSet.addMolecularFormula(mf);
        mf.setMass(mass);
        mf.setCharge(charge);
        mf.setTolerance(tolerance);
        mf.setBuilder(builder);
        mf.setIsotopePattern(getIsotopePattern(mass));
        mf.setMatrix(matrix_Base);
        mf.setRestrictions(rules);
        mf.setMolecularFormulaRange(mfRange);
        return mfSet;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.052873490582122734,  0.012184622857316913,  0.05979459384710078,  0.06037562321712729,924.0,0.9705882352941176,935.0,0.9821428571428571,889.0,0.9338235294117647,915.0,0.9611344537815126,22.0,0.6111111111111112,66.0,0.6947368421052632,23.0,0.4423076923076923,9.0,0.75,0.0,0.0,4.0,0.3333333333333333
528,cdk,"public void removeStrand(String name){
    if (strands.containsKey(name)) {
        Strand strand = (Strand) strands.get(name);
        this.remove(strand);
        strands.remove(name);
    }
}",removeStrand,org/openscience/cdk/silent/BioPolymer.java,/base/silent/src/main/java/org/openscience/cdk/silent/BioPolymer.java,"/**
     * Removes a particular strand, specified by its name.
     *
     * @param name name of the strand to remove
     */",241-253,"('removeStrand', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,10.0,"Removes a particular strand, specified by its name.",This method takes a String name as input and removes it from a paricular strand.,A strand is removed by its name.,0.755635781624249,"Deletes a particular strand, specified by its name."," public void removeStrand(String name){
        strands.remove(name);
    }"," public void removeStrand(String name){
        strands.remove(name);       
 }"," public void removeStrand(String name){
        strands.remove(name);       
 }"," public void removeStrand(String name){
        strands.remove(name);       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.28857594648680074,  0.28857594648680074,  0.28857594648680074,  0.28857594648680074,31.0,0.6458333333333334,31.0,0.6458333333333334,31.0,0.6458333333333334,31.0,0.6458333333333334,0.0,0.0,0.0,0.0,0.0,0.0,14.0,0.875,1.0,0.1111111111111111,5.0,0.5555555555555556
529,cdk,"public boolean matches(IBond bond){
    bond = BondRef.deref(bond);
    if (bond instanceof PharmacophoreBond) {
        PharmacophoreBond pbond = (PharmacophoreBond) bond;
        double bondLength = round(pbond.getBondLength(), 2);
        return bondLength >= lower && bondLength <= upper;
    } else
        return false;
}",matches,org/openscience/cdk/pharmacophore/PharmacophoreQueryBond.java,/tool/pcore/src/main/java/org/openscience/cdk/pharmacophore/PharmacophoreQueryBond.java,"/**
     * Checks whether the query distance constraint matches a target distance.
     * 
     * This method checks whether a query constraint is satisfied by an observed
     * distance (represented by a {@link PharmacophoreBond} in the target molecule.
     * Note that distance are compared upto 2 decimal places.
     *
     * @param bond The distance relationship in a target molecule
     * @return true if the target distance lies within the range of the query constraint
     */",82-101,"('matches', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,11.0,Checks whether the query distance constraint matches a target distance.,"Returns true if the query distance constraint matches a target distance, false otherwise.",The query distance constraint is checked to see if it matches the target distance.,0.277198099299571,Checks whether the query distance constraint matches a target distance.," public boolean matches(IBond bond){
        if (bond instanceof BondRef) {
            bond = ((BondRef) bond).getBond();
        }
        if (bond instanceof PharmacophoreQueryBond) {
            PharmacophoreQueryBond queryBond = (PharmacophoreQueryBond) bond;
            double distance = getDistance();
            return (distance >= queryBond.lower && distance <= queryBond.upper);
        }
        return false;
    }"," public boolean matches(IBond bond){
        if (bond instanceof BondRef) {
            bond = ((BondRef)bond).getBond();
        }
        if (bond instanceof PharmacophoreQueryBond) {
            PharmacophoreQueryBond qbond = (PharmacophoreQueryBond)bond;
            double dist = getDistance();
            return (dist >= qbond.lower && dist <= qbond.upper);
        }
        return false;
    }","public boolean matches(IBond bond){
        if(!(bond instanceof Bond)) return false;
        if(!(bond.getAtom(0) instanceof PharmacophoreQueryAtom)) return false;
        if(!(bond.getAtom(1) instanceof PharmacophoreQueryAtom)) return false;
        PharmacophoreQueryAtom atom1 = (PharmacophoreQueryAtom)bond.getAtom(0);
        PharmacophoreQueryAtom atom2 = (PharmacophoreQueryAtom)bond.getAtom(1);
        double distance = atom1.getPoint3d().distance(atom2.getPoint3d());
        return distance >= lower && distance <= upper;
    }"," public boolean matches(IBond bond){
        if(bond instanceof BondRef) {
            return matches((BondRef)bond);
        }
        return matches(new BondRef(bond));
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4459050795832089,  0.4302800795832089,  0.251159238283363,  0.41540939126644233,37.0,0.5138888888888888,37.0,0.5138888888888888,39.0,0.6290322580645161,75.0,0.6880733944954128,6.0,0.08333333333333333,42.0,0.5833333333333334,70.0,0.6422018348623854,6.0,0.42857142857142855,0.0,0.0,10.0,0.6666666666666666
531,cdk,"public void distributePartners(IAtom atom, IAtomContainer placedNeighbours, Point2d sharedAtomsCenter, IAtomContainer unplacedNeighbours, double bondLength){
    double occupiedAngle = 0;
    IAtom[] sortedAtoms = null;
    double startAngle = 0.0;
    double addAngle = 0.0;
    double radius = 0.0;
    double remainingAngle = 0.0;
    Vector2d sharedAtomsCenterVector = new Vector2d(sharedAtomsCenter);
    Vector2d newDirection = new Vector2d(atom.getPoint2d());
    Vector2d occupiedDirection = new Vector2d(sharedAtomsCenter);
    occupiedDirection.sub(newDirection);
    if (Math.abs(occupiedDirection.length()) < 0.001)
        occupiedDirection = new Vector2d(0, 1);
    logger.debug(""distributePartners->occupiedDirection.lenght(): "" + occupiedDirection.length());
    List<IAtom> atomsToDraw = new ArrayList<IAtom>();
    logger.debug(""Number of shared atoms: "", placedNeighbours.getAtomCount());
    if (placedNeighbours.getAtomCount() == 1) {
        logger.debug(""Only one neighbour..."");
        for (int f = 0; f < unplacedNeighbours.getAtomCount(); f++) {
            atomsToDraw.add(unplacedNeighbours.getAtom(f));
        }
        addAngle = Math.PI * 2 / (unplacedNeighbours.getAtomCount() + placedNeighbours.getAtomCount());
        IAtom placedAtom = placedNeighbours.getAtom(0);
        double xDiff = placedAtom.getPoint2d().x - atom.getPoint2d().x;
        double yDiff = placedAtom.getPoint2d().y - atom.getPoint2d().y;
        logger.debug(""distributePartners->xdiff: "" + Math.toDegrees(xDiff));
        logger.debug(""distributePartners->ydiff: "" + Math.toDegrees(yDiff));
        startAngle = GeometryUtil.getAngle(xDiff, yDiff);
        logger.debug(""distributePartners->angle: "" + Math.toDegrees(startAngle));
        populatePolygonCorners(atomsToDraw, new Point2d(atom.getPoint2d()), startAngle, addAngle, bondLength);
        return;
    } else if (placedNeighbours.getAtomCount() == 0) {
        logger.debug(""First atom..."");
        for (int f = 0; f < unplacedNeighbours.getAtomCount(); f++) {
            atomsToDraw.add(unplacedNeighbours.getAtom(f));
        }
        addAngle = Math.PI * 2.0 / unplacedNeighbours.getAtomCount();
        startAngle = 0.0;
        populatePolygonCorners(atomsToDraw, new Point2d(atom.getPoint2d()), startAngle, addAngle, bondLength);
        return;
    }
    if (doAngleSnap(atom, placedNeighbours)) {
        int numTerminal = 0;
        for (IAtom unplaced : unplacedNeighbours.atoms()) if (molecule.getConnectedBondsCount(unplaced) == 1)
            numTerminal++;
        if (numTerminal == unplacedNeighbours.getAtomCount()) {
            final Vector2d a = newVector(placedNeighbours.getAtom(0).getPoint2d(), atom.getPoint2d());
            final Vector2d b = newVector(placedNeighbours.getAtom(1).getPoint2d(), atom.getPoint2d());
            final double d1 = GeometryUtil.getAngle(a.x, a.y);
            final double d2 = GeometryUtil.getAngle(b.x, b.y);
            double sweep = a.angle(b);
            if (sweep < Math.PI) {
                sweep = 2 * Math.PI - sweep;
            }
            startAngle = d2;
            if (d1 > d2 && d1 - d2 < Math.PI || d2 - d1 >= Math.PI) {
                startAngle = d1;
            }
            sweep /= (1 + unplacedNeighbours.getAtomCount());
            populatePolygonCorners(StreamSupport.stream(unplacedNeighbours.atoms().spliterator(), false).collect(Collectors.toList()), atom.getPoint2d(), startAngle, sweep, bondLength);
            markPlaced(unplacedNeighbours);
            return;
        } else {
            atom.removeProperty(MacroCycleLayout.MACROCYCLE_ATOM_HINT);
        }
    }
    sharedAtomsCenterVector.sub(newDirection);
    newDirection = sharedAtomsCenterVector;
    newDirection.normalize();
    newDirection.scale(bondLength);
    newDirection.negate();
    logger.debug(""distributePartners->newDirection.lenght(): "" + newDirection.length());
    Point2d distanceMeasure = new Point2d(atom.getPoint2d());
    distanceMeasure.add(newDirection);
    sortedAtoms = AtomContainerManipulator.getAtomArray(placedNeighbours);
    GeometryUtil.sortBy2DDistance(sortedAtoms, distanceMeasure);
    Vector2d closestPoint1 = new Vector2d(sortedAtoms[0].getPoint2d());
    Vector2d closestPoint2 = new Vector2d(sortedAtoms[1].getPoint2d());
    closestPoint1.sub(new Vector2d(atom.getPoint2d()));
    closestPoint2.sub(new Vector2d(atom.getPoint2d()));
    occupiedAngle = closestPoint1.angle(occupiedDirection);
    occupiedAngle += closestPoint2.angle(occupiedDirection);
    double angle1 = GeometryUtil.getAngle(sortedAtoms[0].getPoint2d().x - atom.getPoint2d().x, sortedAtoms[0].getPoint2d().y - atom.getPoint2d().y);
    double angle2 = GeometryUtil.getAngle(sortedAtoms[1].getPoint2d().x - atom.getPoint2d().x, sortedAtoms[1].getPoint2d().y - atom.getPoint2d().y);
    double angle3 = GeometryUtil.getAngle(distanceMeasure.x - atom.getPoint2d().x, distanceMeasure.y - atom.getPoint2d().y);
    if (debug) {
        try {
            logger.debug(""distributePartners->sortedAtoms[0]: "", (molecule.indexOf(sortedAtoms[0]) + 1));
            logger.debug(""distributePartners->sortedAtoms[1]: "", (molecule.indexOf(sortedAtoms[1]) + 1));
            logger.debug(""distributePartners->angle1: "", Math.toDegrees(angle1));
            logger.debug(""distributePartners->angle2: "", Math.toDegrees(angle2));
        } catch (Exception exc) {
            logger.debug(exc);
        }
    }
    IAtom startAtom = null;
    if (angle1 > angle3) {
        if (angle1 - angle3 < Math.PI) {
            startAtom = sortedAtoms[1];
        } else {
            startAtom = sortedAtoms[0];
        }
    } else {
        if (angle3 - angle1 < Math.PI) {
            startAtom = sortedAtoms[0];
        } else {
            startAtom = sortedAtoms[1];
        }
    }
    remainingAngle = (2 * Math.PI) - occupiedAngle;
    addAngle = remainingAngle / (unplacedNeighbours.getAtomCount() + 1);
    if (debug) {
        try {
            logger.debug(""distributePartners->startAtom: "" + (molecule.indexOf(startAtom) + 1));
            logger.debug(""distributePartners->remainingAngle: "" + Math.toDegrees(remainingAngle));
            logger.debug(""distributePartners->addAngle: "" + Math.toDegrees(addAngle));
            logger.debug(""distributePartners-> partners.getAtomCount(): "" + unplacedNeighbours.getAtomCount());
        } catch (Exception exc) {
            logger.debug(exc);
        }
    }
    for (int f = 0; f < unplacedNeighbours.getAtomCount(); f++) {
        atomsToDraw.add(unplacedNeighbours.getAtom(f));
    }
    radius = bondLength;
    startAngle = GeometryUtil.getAngle(startAtom.getPoint2d().x - atom.getPoint2d().x, startAtom.getPoint2d().y - atom.getPoint2d().y);
    logger.debug(""Before check: distributePartners->startAngle: "" + startAngle);
    logger.debug(""After check: distributePartners->startAngle: "" + startAngle);
    populatePolygonCorners(atomsToDraw, new Point2d(atom.getPoint2d()), startAngle, addAngle, radius);
}",distributePartners,org/openscience/cdk/layout/AtomPlacer.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/AtomPlacer.java,"/**
     *  Distribute the bonded atoms (neighbours) of an atom such that they fill the
     *  remaining space around an atom in a geometrically nice way.
     *  IMPORTANT: This method is not supposed to handle the
     *  case of one or no place neighbor. In the case of
     *  one placed neigbor, the chain placement methods
     *  should be used.
     *
     *@param  atom                The atom whose partners are to be placed
     *@param  placedNeighbours    The atoms which are already placed
     *@param  unplacedNeighbours  The partners to be placed
     *@param  bondLength          The standared bond length for the newly placed
     *      Atoms
     *@param  sharedAtomsCenter   The 2D centre of the placed Atoms
     */",97-306,"('distributePartners', {'INSTRUCTION': {'covered': 670, 'missed': 16}, 'BRANCH': {'covered': 32, 'missed': 2}, 'LINE': {'covered': 110, 'missed': 5}, 'COMPLEXITY': {'covered': 16, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",1389.0,26.0,Distribute the bonded atoms (neighbours) of an atom such that they fill the  remaining space around an atom in a geometrically nice way.,Fills the geometric missing space around an atom after having distributed the bonded atoms of an atom.,The atoms should be distributed in a way that they fill the remaining space around the atom in a nice way.,0.284689444054282,Distribute the bonded (neighboring) atoms of an atom so that they fill the remaining space around an atom in a geometrically pleasing way.,"public void distributePartners(IAtom atom, IAtomContainer placedNeighbours, Point2d sharedAtomsCenter, IAtomContainer unplacedNeighbours, double bondLength){
        double angle = 0;
        double angleIncrement = Math.PI / 2;
        double angleIncrementStep = Math.PI / 8;
        double angleIncrementStep2 = Math.PI / 16;
        double angleIncrementStep3 = Math.PI / 32;
        double angleIncrementStep4 = Math.PI / 64;
        double angleIncrementStep5 = Math.PI / 128;
        double angleIncrementStep6 = Math.PI / 256;
        double angleIncrementStep7 = Math.PI / 512;
        double angleIncrementStep8 = Math.PI / 1024;
        double angleIncrementStep9 = Math.PI / 2048;
        double angleIncrementStep10 = Math.PI / 4096;
        double angleIncrementStep11 = Math.PI / 8192;
        double angleIncrementStep12 = Math.PI / 16384;
        double angleIncrementStep13 = Math.PI / 32768;
        double angleIncrementStep14 = Math.PI / 65536;
        double angleIncrementStep15 = Math.PI / 131072;
        double angleIncrementStep16 = Math.PI / 262144;
        double angleIncrementStep17 = Math.PI / 524288;
        double angleIncrementStep18 = Math.PI / 1048576;
        double angleIncrementStep19 = Math.PI / 2097152;
        double angleIncrementStep20 = Math.PI / 4194304;
        double angleIncrementStep21 = Math.PI / 8388608;
        double angleIncrementStep22 = Math.PI / 16777216;
        double angleIncrementStep23 = Math.PI / 33554432;
        double angleIncrementStep24 = Math.PI / 67108864;
        double angleIncrementStep25 = Math.PI / 134217728;
        double angleIncrementStep26 = Math.PI / 268435456;
        double angleIncrementStep27 = Math.PI / 536870912;
        double angleIncrementStep28 = Math.PI / 1073741824;
        double angleIncrementStep29 = Math.PI / 2147483648;
        double angle        
 }","public void distributePartners(IAtom atom, IAtomContainer placedNeighbours, Point2d sharedAtomsCenter, IAtomContainer unplacedNeighbours, double bondLength){
        // get the neighbours of the atom
        List<IAtom> neighbours = new ArrayList<IAtom>();
        for (IBond bond : atom.getBonds()) {
            if (bond.getBegin().equals(atom)) {
                neighbours.add(bond.getEnd());
            } else {
                neighbours.add(bond.getBegin());
            }
        }
        // get the neighbours of the atom that are not yet placed
        List<IAtom> unplacedNeighboursList = new ArrayList<IAtom>();
        for (IAtom neighbour : neighbours) {
            if (!placedNeighbours.contains(neighbour)) {
                unplacedNeighboursList.add(neighbour);
            }
        }
        // get the neighbours of the atom that are already placed
        List<IAtom> placedNeighboursList = new ArrayList<IAtom>();
        for (IAtom neighbour : neighbours) {
            if (placedNeighbours.contains(neighbour)) {
                placedNeighboursList.add(neighbour);
            }
        }
        // get the neighbours of the atom that are already placed and are not yet bonded to the atom
        List<IAtom> unbondedNeighboursList = new ArrayList<IAtom>();
        for (IAtom neighbour : placedNeighboursList) {
            if (!neighbour.getBonds().contains(atom)) {
                unbondedNeighboursList.add(neighbour);
            }
        }
        // get the neighbours of the atom that are already placed and are bonded to the atom
        List<IAtom> bondedNeighboursList = new ArrayList<IAtom>();
        for (IAtom neighbour : placedNeighboursList) {
            if (neighbour.getBonds().contains(atom)) {
                bondedNeighboursList.add(neighbour);
            }
        }
        // get the neighbours of the atom that are not yet placed and are bonded to the atom
        List<IAtom> bondedUnplacedNeighbours        
 }","public void distributePartners(IAtom atom, IAtomContainer placedNeighbours, Point2d sharedAtomsCenter, IAtomContainer unplacedNeighbours, double bondLength){
        // get the neighbours of the atom
        List<IAtom> neighbours = new ArrayList<IAtom>(atom.getBonds().size());
        for (IBond bond : atom.getBonds()) {
            neighbours.add(bond.getOther(atom));
        }
        // get the neighbours of the neighbours
        List<IAtom> neighboursOfNeighbours = new ArrayList<IAtom>(neighbours.size());
        for (IAtom neighbour : neighbours) {
            for (IBond bond : neighbour.getBonds()) {
                neighboursOfNeighbours.add(bond.getOther(neighbour));
            }
        }
        // get the neighbours of the neighbours of the neighbours
        List<IAtom> neighboursOfNeighboursOfNeighbours = new ArrayList<IAtom>(neighboursOfNeighbours.size());
        for (IAtom neighbourOfNeighbour : neighboursOfNeighbours) {
            for (IBond bond : neighbourOfNeighbour.getBonds()) {
                neighboursOfNeighboursOfNeighbours.add(bond.getOther(neighbourOfNeighbour));
            }
        }
        // get the neighbours of the neighbours of the neighbours of the neighbours
        List<IAtom> neighboursOfNeighboursOfNeighboursOfNeighbours = new ArrayList<IAtom>(neighboursOfNeighboursOfNeighbours.size());
        for (IAtom neighbourOfNeighbourOfNeighbour : neighboursOfNeighboursOfNeighbours) {
            for (IBond bond : neighbourOfNeighbourOfNeighbour.getBonds()) {
                neighboursOfNeighboursOfNeighboursOfNeighbours.add(bond.getOther(neighbourOfNeighbourOfNeighbour));
            }
        }
        // get the neighbours of the neighbours of the neighbours of the neighbours of the neighbours
        List<IAtom> neighboursOfNeighboursOfNeighboursOfNeighboursOfNeighbours = new ArrayList<IAtom>(neighboursOfNeighboursOfNeighboursOfNeighbours.size());
        for (I      
 }",Not Valid,Syntax Error,Syntax Error,Not Valid,Syntax Error,None,None,None,None,None,None,None,None,None,None,1242.0,0.8935251798561151,None,None,None,None,259.0,0.8662207357859532,18.0,0.75,4.0,0.16666666666666666,11.0,0.4583333333333333
533,weblogic-kubernetes-operator,"public static boolean isDns1123Required(String fieldName){
    if (fieldName != null) {
        for (String dns1123Field : getDns1123Fields()) {
            if (dns1123Field.equalsIgnoreCase(fieldName)) {
                return true;
            }
        }
    }
    return false;
}",isDns1123Required,oracle/kubernetes/operator/helpers/LegalNames.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/LegalNames.java,"/**
   * Returns true if the value in the field is required to be DNS-1123 legal.
   *
   * @param fieldName Name of the field to be checked
   * @return true if the value needs to be DNS1123 legal, false otherwise
   */",195-210,"('isDns1123Required', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,15.0,Returns true if the value in the field is required to be DNS-1123 legal.,"Cheks whether the value in the field is required to be DNS-1123 legal. If that is the case, then return true, false otherwise.","If the field is required to be legal, this is true.",0.266453992110066,Returns true if the value of the field should be LEGAL DNS-1123.,"public static boolean isDns1123Required(String fieldName){
    return Arrays.asList(getDns1123Fields()).contains(fieldName);
  }","public static boolean isDns1123Required(String fieldName){
    String[] dns1123Fields = getDns1123Fields();
    if (dns1123Fields == null) {
      return false;
    }
    for (String dns1123Field : dns1123Fields) {
      if (dns1123Field.equals(fieldName)) {
        return true;
      }
    }
    return false;
  }","public static boolean isDns1123Required(String fieldName){
    return Arrays.asList(getDns1123Fields()).contains(fieldName);
  }","public static boolean isDns1123Required(String fieldName){
    return Arrays.asList(getDns1123Fields()).contains(fieldName);
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.29744169593563297,  0.652815729149951,  0.29744169593563297,  0.29744169593563297,26.0,0.5531914893617021,20.0,0.3508771929824561,26.0,0.5531914893617021,26.0,0.5531914893617021,37.0,0.6491228070175439,0.0,0.0,0.0,0.0,13.0,0.5416666666666666,6.0,0.4,10.0,0.6666666666666666
534,tablesaw,"public static String removeZeroDecimal(final String str){
    if (Strings.isNullOrEmpty(str)) {
        return str;
    }
    return ZERO_DECIMAL_PATTERN.matcher(str).replaceFirst(EMPTY);
}",removeZeroDecimal,tech/tablesaw/util/StringUtils.java,/core/src/main/java/tech/tablesaw/util/StringUtils.java,"/**
   * Removes all trailing zero decimals from the given String, assuming all decimals are zero and
   * any zero decimals actually exist.
   *
   * <p>A {@code null} input String returns {@code null}.
   *
   * @param str the String to handle, may be null
   * @return string without trailing zero decimals
   */",526-540,"('removeZeroDecimal', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,22.0,"Removes all trailing zero decimals from the given String, assuming all decimals are zero and  any zero decimals actually exist.",Strips all the trailing zero decimals from the given string.,"If all decimals are zero and any zero decimals actually exist, then the trailing zero decimals are removed from the given string.",0.276878010133622,"Removes all end null decimals from the given string, assuming that all decimals are zero and all null decimals actually exist.","public static String removeZeroDecimal(final String str){
    if(Strings.isNullOrEmpty(str)){
      return str;
    }
    final int index = str.indexOf('.');
    if(index == -1){
      return str;
    }
    final int length = str.length();
    for(int i = length - 1; i >= index + 1; i--){
      if(str.charAt(i) != '0'){
        return str.substring(0, i + 1);
      }
    }
    return str.substring(0, index);
  }","public static String removeZeroDecimal(final String str){
    if(Strings.isNullOrEmpty(str)){
      return str;
    }
    int i = str.indexOf(""."");
    if(i == -1){
      return str;
    }
    int j = str.length() - 1;
    while(j > i && str.charAt(j) == '0'){
      j--;
    }
    if(str.charAt(j) == '.'){
      j--;
    }
    return str.substring(0, j + 1);
  }","public static String removeZeroDecimal(final String str){
    if(Strings.isNullOrEmpty(str)){
      return str;
    }
    StringBuilder sb = new StringBuilder(str);
    int i = sb.length()-1;
    while(i>=0){
      if(sb.charAt(i)=='0'){
        sb.deleteCharAt(i);
      }else{
        break;
      }
      i--;
    }
    return sb.toString();
  }","public static String removeZeroDecimal(final String str){
    if(Strings.isNullOrEmpty(str)){
      return str;
    }
    final StringBuilder sb = new StringBuilder(str);
    for(int i = sb.length()-1; i >= 0; i--){
      if(sb.charAt(i) == '0'){
        sb.deleteCharAt(i);
      }else{
        break;
      }
    }
    if(sb.charAt(sb.length()-1) == '.'){
      sb.deleteCharAt(sb.length()-1);
    }
    return sb.toString();   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6866674800240453,  0.6931167792925608,  0.6898681860754898,  0.7110933255987892,79.0,0.6929824561403509,72.0,0.6728971962616822,89.0,0.7295081967213115,56.0,0.6292134831460674,43.0,0.37719298245614036,72.0,0.5901639344262295,57.0,0.5,14.0,0.6666666666666666,6.0,0.2727272727272727,19.0,0.8260869565217391
535,weblogic-kubernetes-operator,"public Map<String, Object> toTopology(){
    Map<String, Object> topology = new HashMap<>();
    topology.put(""domainValid"", ""true"");
    topology.put(""domain"", createDomainTopology());
    return topology;
}",toTopology,oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,"/**
   * Returns the topology equivalent of the domain configuration, as a map. It may be converted to
   * YAML or JSON via an object mapper.
   *
   * @return a map containing the topology
   */",434-445,"('toTopology', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",50.0,13.0,"Returns the topology equivalent of the domain configuration, as a map.",Returns a new Topology Map equivalent to the domain configuration.,The map is the equivalent of the domain configuration.,0.193336111920752,"Returns the topological equivalent of the domain configuration, as a mapping."," public Map<String, Object> toTopology(){
    Map<String, Object> topology = new HashMap<>();
    topology.put(""adminServerName"", getAdminServerName());
    topology.put(""servers"", getServers());
    topology.put(""clusters"", getClusterConfigs());
    topology.put(""machineConfigs"", getMachineConfigs());
    return topology;
  }"," public Map<String, Object> toTopology(){
    Map<String, Object> topology = new HashMap<>();
    topology.put(""adminServerName"", getAdminServerName());
    topology.put(""servers"", getServers());
    topology.put(""clusters"", getClusterConfigs());
    topology.put(""machineConfigs"", getMachineConfigs());
    return topology;
  }"," public Map<String, Object> toTopology(){
    Map<String, Object> topology = new HashMap<>();
    topology.put(""domain"", getDomainName());
    topology.put(""adminServerName"", getAdminServerName());
    topology.put(""servers"", getServers());
    topology.put(""clusters"", getClusterConfigs());
    topology.put(""machineConfigs"", getMachineConfigs());
    return topology;
  }"," public Map<String, Object> toTopology(){
    Map<String, Object> topology = new HashMap<>();
    topology.put(""adminServerName"", getAdminServerName());
    topology.put(""servers"", getServers());
    topology.put(""clusters"", getClusterConfigs());
    topology.put(""machineConfigs"", getMachineConfigs());
    return topology;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7952205339458804,  0.7952205339458804,  0.7952205339458804,  0.7915279357463276,28.0,0.37333333333333335,28.0,0.37333333333333335,28.0,0.37333333333333335,39.0,0.45348837209302323,0.0,0.0,0.0,0.0,11.0,0.12790697674418605,9.0,0.75,2.0,0.16666666666666666,8.0,0.6666666666666666
536,jooby,"public OpenAPI generate(@Nonnull String classname){
    ClassLoader classLoader = Optional.ofNullable(this.classLoader).orElseGet(getClass()::getClassLoader);
    ClassSource source = new ClassSource(classLoader);
    RouteParser routes = new RouteParser(metaInf);
    ParserContext ctx = new ParserContext(source, TypeFactory.fromJavaName(classname), debug);
    List<OperationExt> operations = routes.parse(ctx);
    String contextPath = ContextPathParser.parse(ctx);
    OpenAPIExt openapi = new OpenAPIExt();
    openapi.setSource(Optional.ofNullable(ctx.getMainClass()).orElse(classname));
    OpenAPIParser.parse(ctx, openapi);
    OpenAPIExt.fromTemplate(basedir, classLoader, templateName).ifPresent(template -> merge(openapi, template));
    defaults(classname, contextPath, openapi);
    ctx.schemas().forEach(schema -> openapi.schema(schema.getName(), schema));
    Map<String, Tag> globalTags = new LinkedHashMap<>();
    Paths paths = new Paths();
    for (OperationExt operation : operations) {
        String pattern = operation.getPattern();
        if (!includes(pattern) || excludes(pattern)) {
            log.debug(""skipping {}"", pattern);
            continue;
        }
        Map<String, String> regexMap = new HashMap<>();
        Router.pathKeys(pattern, (key, value) -> Optional.ofNullable(value).ifPresent(v -> regexMap.put(key, v)));
        if (regexMap.size() > 0) {
            for (Map.Entry<String, String> e : regexMap.entrySet()) {
                String name = e.getKey();
                String regex = e.getValue();
                operation.getParameter(name).ifPresent(parameter -> parameter.getSchema().setPattern(regex));
                if (regex.equals(""\\.*"")) {
                    if (name.equals(""*"")) {
                        pattern = pattern.substring(0, pattern.length() - 1) + ""{*}"";
                    } else {
                        pattern = pattern.replace(""*"" + name, ""{"" + name + ""}"");
                    }
                } else {
                    pattern = pattern.replace(name + "":"" + regex, name);
                }
            }
        }
        PathItem pathItem = paths.computeIfAbsent(pattern, k -> new PathItem());
        pathItem.operation(PathItem.HttpMethod.valueOf(operation.getMethod()), operation);
        Optional.ofNullable(operation.getPathSummary()).ifPresent(pathItem::setSummary);
        Optional.ofNullable(operation.getPathDescription()).ifPresent(pathItem::setDescription);
        operation.getGlobalTags().forEach(tag -> globalTags.put(tag.getName(), tag));
    }
    globalTags.values().forEach(tag -> {
        if (tag.getDescription() != null || tag.getExtensions() != null) {
            openapi.addTagsItem(tag);
        }
    });
    openapi.setOperations(operations);
    openapi.setPaths(paths);
    return openapi;
}",generate,io/jooby/openapi/OpenAPIGenerator.java,/modules/jooby-openapi/src/main/java/io/jooby/openapi/OpenAPIGenerator.java,"/**
   * Generate an {@link OpenAPI} model from Jooby class. This method parses class byte code and
   * generates an open api model from it. Compilation must be done with debug information and
   * parameters name available.
   *
   * Optionally, the <code>conf/openapi.yaml</code> is used as template and get merged into the
   * final model.
   *
   * @param classname Application class name.
   * @return Model.
   */",165-247,"('generate', {'INSTRUCTION': {'covered': 256, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 44, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",608.0,12.0,Generate an {@link OpenAPI} model from Jooby class.,Returns an OpenAPI object from Jooby Class by parsing the class byte code.,The model is from the class.,0.349624626329339,Generate an {@link OpenAPI} template from the Jooby class.," public OpenAPI generate(@Nonnull String classname){
    ClassSource source = new ClassSource(classname, classLoader);
    return generate(source);    
 }"," public OpenAPI generate(@Nonnull String classname){
    ClassSource source = new ClassSource(classname, classLoader);
    ParserContext context = new ParserContext(source, debug);
    OpenAPIParser parser = new OpenAPIParser(context);
    OpenAPI result = parser.parse();
    return result;
  }"," public OpenAPI generate(@Nonnull String classname){
    return generate(classname, null);   
 }"," public OpenAPI generate(@Nonnull String classname){
    return generate(classname, null);   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.041475566259317496,  0.10146395674565767,  0.016685869118397856,  0.016685869118397856,583.0,0.9573070607553367,566.0,0.9293924466338259,591.0,0.9704433497536946,591.0,0.9704433497536946,28.0,0.509090909090909,12.0,0.41379310344827586,12.0,0.41379310344827586,11.0,0.7857142857142857,2.0,0.2,6.0,0.6666666666666666
537,anserini,"public static float computeQueryDocumentScoreWithSimilarityAndAnalyzer(IndexReader reader, String docid, String q, Similarity similarity, Analyzer analyzer) throws IOException{
    IndexSearcher searcher = new IndexSearcher(reader);
    searcher.setSimilarity(similarity);
    Query query = new BagOfWordsQueryGenerator().buildQuery(IndexArgs.CONTENTS, analyzer, q);
    Query filterQuery = new ConstantScoreQuery(new TermQuery(new Term(IndexArgs.ID, docid)));
    BooleanQuery.Builder builder = new BooleanQuery.Builder();
    builder.add(filterQuery, BooleanClause.Occur.MUST);
    builder.add(query, BooleanClause.Occur.MUST);
    Query finalQuery = builder.build();
    TopDocs rs = searcher.search(finalQuery, 1);
    return rs.scoreDocs.length == 0 ? 0 : rs.scoreDocs[0].score - 1;
}",computeQueryDocumentScoreWithSimilarityAndAnalyzer,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,"/**
   * Computes the score of a document with respect to a query given a scoring function and an analyzer.
   *
   * @param reader index reader
   * @param docid docid of the document to score
   * @param q query
   * @param similarity scoring function
   * @param analyzer analyzer to use
   * @return the score of the document with respect to the query
   * @throws IOException if error encountered during query
   */",691-727,"('computeQueryDocumentScoreWithSimilarityAndAnalyzer', {'INSTRUCTION': {'covered': 64, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",161.0,19.0,Computes the score of a document with respect to a query given a scoring function and an analyzer.,Returns the score of a document wrt to a query given an analyzer and a scoring function.,The score of a document is computed by using a scoring function and an analyzer.,0.16578216515917,Calculates the score of a document against a query using a scoring function and a parser.,"public static float computeQueryDocumentScoreWithSimilarityAndAnalyzer(IndexReader reader, String docid, String q, Similarity similarity, Analyzer analyzer) throws IOException{
    IndexSearcher searcher = new IndexSearcher(reader);
    searcher.setSimilarity(similarity);
    Query query = new QueryParser(IndexArgs.CONTENTS, analyzer).parse(q);
    TopDocs rs = searcher.search(query, 1);
    return rs.scoreDocs.length == 0 ? 0 : rs.scoreDocs[0].score;
  }","public static float computeQueryDocumentScoreWithSimilarityAndAnalyzer(IndexReader reader, String docid, String q, Similarity similarity, Analyzer analyzer) throws IOException{
    IndexSearcher searcher = new IndexSearcher(reader);
    searcher.setSimilarity(similarity);
  
    Query query = new QueryParser(IndexArgs.CONTENTS, analyzer).parse(q);
    TopDocs rs = searcher.search(query, 1);
  
    // The BM25 weight is the score of the first (and only) hit, but remember to remove 1 for the ConstantScoreQuery.
    // If we get zero results, indicates that term isn't found in the document.
    return rs.scoreDocs.length == 0 ? 0 : rs.scoreDocs[0].score - 1;
  }","public static float computeQueryDocumentScoreWithSimilarityAndAnalyzer(IndexReader reader, String docid, String q, Similarity similarity, Analyzer analyzer) throws IOException{
    IndexSearcher searcher = new IndexSearcher(reader);
    searcher.setSimilarity(similarity);
  
    Query query = new QueryParser(IndexArgs.CONTENTS, analyzer).parse(q);
    TopDocs rs = searcher.search(query, 1);
  
    // The score of the document is the score of the first (and only) hit, but remember to remove 1 for the ConstantScoreQuery.
    // If we get zero results, indicates that term isn't found in the document.
    return rs.scoreDocs.length == 0 ? 0 : rs.scoreDocs[0].score - 1;
  }","public static float computeQueryDocumentScoreWithSimilarityAndAnalyzer(IndexReader reader, String docid, String q, Similarity similarity, Analyzer analyzer) throws IOException{
    IndexSearcher searcher = new IndexSearcher(reader);
    searcher.setSimilarity(similarity);
  
    QueryParser parser = new QueryParser(IndexArgs.CONTENTS, analyzer);
    Query query = parser.parse(q);
    TopDocs rs = searcher.search(query, 1);
  
    // The BM25 weight is the score of the first (and only) hit, but remember to remove 1 for the ConstantScoreQuery.
    // If we get zero results, indicates that term isn't found in the document.
    return rs.scoreDocs.length == 0 ? 0 : rs.scoreDocs[0].score - 1;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4229977382971798,  0.44496933110280634,  0.45744770425158404,  0.44496933110280634,75.0,0.46296296296296297,73.0,0.4506172839506173,72.0,0.4444444444444444,73.0,0.4506172839506173,2.0,0.021505376344086023,9.0,0.09183673469387756,2.0,0.021505376344086023,9.0,0.47368421052631576,7.0,0.3684210526315789,8.0,0.42105263157894735
538,cdk,"private boolean refine(int row){
    int marking = -(row + 1);
    boolean changed;
    do {
        changed = false;
        for (int n = row + 1; n < matrix.nRows; n++) {
            for (int m = 0; m < matrix.mCols; m++) {
                if (matrix.get(n, m) && !verify(n, m)) {
                    matrix.mark(n, m, marking);
                    changed = true;
                    if (!hasCandidate(n))
                        return false;
                }
            }
        }
    } while (changed);
    return true;
}",refine,org/openscience/cdk/isomorphism/UllmannState.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/UllmannState.java,"/**
     * Refines the compatibility removing any mappings which have now become
     * invalid (since the last mapping). The matrix is refined from the row
     * after the current {@code row} - all previous rows are fixed. If when
     * refined we find a query vertex has no more candidates left in the target
     * we can never reach a feasible matching and refinement is aborted (false
     * is returned).
     *
     * @param row refine from here
     * @return match is still feasible
     */",161-194,"('refine', {'INSTRUCTION': {'covered': 56, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",122.0,18.0,Refines the compatibility removing any mappings which have now become  invalid (since the last mapping).,All those mappings that became invalid are removed and thus refined the compatibility.,"Since the last mapping, any mappings that have become invalid have been removed.",0.469509381829421,Refines compatibility by removing all mappings that have now become invalid (since the last mapping).,"private boolean refine(int row){
        for (int i = 0; i < g2.length; i++) {
            if (matrix.get(row, i)) {
                if (bondMatcher.matches(bond1.get(row), bonds2.get(i))) {
                    if (m2[i] == UNMAPPED) {
                        return true;
                    } else {
                        matrix.markRow(row, -(row + 1));
                        matrix.markCol(i, -(i + 1));
                    }
                }
            }
        }
        return false;
    }","private boolean refine(int row){
        for (int i = 0; i < g2.length; i++) {
            if (matrix.get(row, i)) {
                if (refine(row, i)) return true;
            }
        }
        return false;       
 }","private boolean refine(int row){
        for (int i = 0; i < g2.length; i++) {
            if (matrix.get(row, i)) {
                if (refine(row, i)) {
                    return true;
                }
            }
        }
        return false;       
 }","private boolean refine(int row){
        // remove all mappings that are incompatible with the current mapping
        for (int i = 0; i < g2.length; i++) {
            if (m2[i] == UNMAPPED && matrix.get(row, i)) {
                matrix.reset(row, i);
            }
        }
        return matrix.get(row, row);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.39369852071029743,  0.2792387327428304,  0.28373050202361866,  0.2839614144157623,92.0,0.7479674796747967,81.0,0.6585365853658537,84.0,0.6829268292682927,80.0,0.6504065040650406,57.0,0.5089285714285714,62.0,0.5535714285714286,55.0,0.49107142857142855,14.0,0.875,4.0,0.25,9.0,0.5625
539,cdk,"private void searchAndPlaceBranches(IAtomContainer molecule, IAtomContainer chain, AtomPlacer3D ap3d, AtomTetrahedralLigandPlacer3D atlp3d, AtomPlacer atomPlacer) throws CDKException{
    List atoms = null;
    IAtomContainer branchAtoms = molecule.getBuilder().newInstance(IAtomContainer.class);
    IAtomContainer connectedAtoms = molecule.getBuilder().newInstance(IAtomContainer.class);
    for (int i = 0; i < chain.getAtomCount(); i++) {
        atoms = molecule.getConnectedAtomsList(chain.getAtom(i));
        for (int j = 0; j < atoms.size(); j++) {
            IAtom atom = (IAtom) atoms.get(j);
            if (!(atom.getSymbol()).equals(""H"") & !(atom.getFlag(CDKConstants.ISPLACED)) & !(atom.getFlag(CDKConstants.ISINRING))) {
                connectedAtoms.add(ap3d.getPlacedHeavyAtoms(molecule, chain.getAtom(i)));
                try {
                    setBranchAtom(molecule, atom, chain.getAtom(i), connectedAtoms, ap3d, atlp3d);
                } catch (CDKException ex2) {
                    logger.error(""SearchAndPlaceBranchERROR: Cannot find enough neighbour atoms due to"" + ex2.toString());
                    throw new CDKException(""SearchAndPlaceBranchERROR: Cannot find enough neighbour atoms: "" + ex2.getMessage(), ex2);
                }
                branchAtoms.addAtom(atom);
                connectedAtoms.removeAllElements();
            }
        }
    }
    placeLinearChains3D(molecule, branchAtoms, ap3d, atlp3d, atomPlacer);
}",searchAndPlaceBranches,org/openscience/cdk/modeling/builder3d/ModelBuilder3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/ModelBuilder3D.java,"/**
     * Search and place branches of a chain or ring.
     *
     *@param  chain          AtomContainer if atoms in an aliphatic chain or ring system
     */",454-491,"('searchAndPlaceBranches', {'INSTRUCTION': {'covered': 102, 'missed': 26}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 16, 'missed': 5}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",272.0,10.0,Search and place branches of a chain or ring.,For each chain or ring it searches and places branches.,Place branches of a chain.,0.0427948733839801,Find and place the branches of a chain or ring.,"private void searchAndPlaceBranches(IAtomContainer molecule, IAtomContainer chain, AtomPlacer3D ap3d, AtomTetrahedralLigandPlacer3D atlp3d, AtomPlacer atomPlacer) throws CDKException{
        IAtomContainer noCoords = molecule.getBuilder().newInstance(IAtomContainer.class);
        noCoords.add(chain);
        Point3d centerPlacedMolecule = ap3d.geometricCenterAllPlacedAtoms(molecule);
        for (int i = 0; i < chain.getAtomCount(); i++) {
            if (!(chain.getAtom(i).getFlag(CDKConstants.ISPLACED))) {
                IAtom atomA = chain.getAtom(i);
                IAtomContainer atomNeighbours = ap3d.getPlacedNeighbours(molecule, atomA);
                if (atomNeighbours.getAtomCount() > 0) {
                    setBranchAtom(molecule, atomA, atomA, atomNeighbours, ap3d, atlp3d);
                }
            }
        }       
 }","private void searchAndPlaceBranches(IAtomContainer molecule, IAtomContainer chain, AtomPlacer3D ap3d, AtomTetrahedralLigandPlacer3D atlp3d, AtomPlacer atomPlacer) throws CDKException{
        for (int i = 0; i < chain.getAtomCount(); i++) {
            if (!(chain.getAtom(i).getFlag(CDKConstants.ISPLACED))) {
                IAtomContainer atomNeighbours = ap3d.getPlacedNeighbours(molecule, chain.getAtom(i));
                if (atomNeighbours.getAtomCount() > 0) {
                    setBranchAtom(molecule, chain.getAtom(i), chain.getAtom(i), atomNeighbours, ap3d, atlp3d);
                }
            }
        }       
 }","private void searchAndPlaceBranches(IAtomContainer molecule, IAtomContainer chain, AtomPlacer3D ap3d, AtomTetrahedralLigandPlacer3D atlp3d, AtomPlacer atomPlacer) throws CDKException{
        IAtomContainer noCoords = molecule.getBuilder().newInstance(IAtomContainer.class);
        IAtomContainer placedMolecule = molecule.getBuilder().newInstance(IAtomContainer.class);
        IAtomContainer placedChain = molecule.getBuilder().newInstance(IAtomContainer.class);
        IAtomContainer placedRing = molecule.getBuilder().newInstance(IAtomContainer.class);
        IAtomContainer placedChainNeighbours = molecule.getBuilder().newInstance(IAtomContainer.class);
        IAtomContainer placedRingNeighbours = molecule.getBuilder().newInstance(IAtomContainer.class);
        IAtomContainer placedChainNeighbours2 = molecule.getBuilder().newInstance(IAtomContainer.class);
        IAtomContainer placedRingNeighbours2 = molecule.getBuilder().newInstance(IAtomContainer.class);
        IAtomContainer placedChainNeighbours3 = molecule.getBuilder().newInstance(IAtomContainer.class);
        IAtomContainer placedRingNeighbours3 = molecule.getBuilder().newInstance(IAtomContainer.class);
        IAtomContainer placedChainNeighbours4 = molecule.getBuilder().newInstance(IAtomContainer.class);
        IAtomContainer placedRingNeighbours4 = molecule.getBuilder().newInstance(IAtomContainer.class);
        IAtomContainer placedChainNeighbours5 = molecule.getBuilder().newInstance(IAtomContainer.class);
        IAtomContainer placedRingNeighbours5 = molecule.getBuilder().newInstance(IAtomContainer.class);
        IAtomContainer placedChainNeighbours6 = molecule.getBuilder().newInstance(IAtomContainer.class);
        IAtomContainer placedRingNeighbours6 = molecule.getBuilder().newInstance(IAtomContainer.class);
        IAtomContainer placedChainNeighbours7 = molecule.getBuilder().newInstance(IAtomContainer.class);
        IAtomContainer placedRingNeighbours7 = molecule.getBuilder().newInstance(IAtomContainer.class);
        IAtomContainer placedChainNeighbours        
 }","private void searchAndPlaceBranches(IAtomContainer molecule, IAtomContainer chain, AtomPlacer3D ap3d, AtomTetrahedralLigandPlacer3D atlp3d, AtomPlacer atomPlacer) throws CDKException{
        IAtomContainer ac = molecule.getBuilder().newInstance(IAtomContainer.class);
        ac.add(chain);
        IAtomContainer atomNeighbours = ap3d.getPlacedNeighbours(molecule, chain);
        IAtom atomA = null;
        IAtom atomB = null;
        IAtom atomC = null;
        IAtom atomD = null;
        IAtom atomE = null;
        IAtom atomF = null;
        IAtom atomG = null;
        IAtom atomH = null;
        IAtom atomI = null;
        IAtom atomJ = null;
        IAtom atomK = null;
        IAtom atomL = null;
        IAtom atomM = null;
        IAtom atomN = null;
        IAtom atomO = null;
        IAtom atomP = null;
        IAtom atomQ = null;
        IAtom atomR = null;
        IAtom atomS = null;
        IAtom atomT = null;
        IAtom atomU = null;
        IAtom atomV = null;
        IAtom atomW = null;
        IAtom atomX = null;
        IAtom atomY = null;
        IAtom atomZ = null;
        IAtom atomAA = null;
        IAtom atomBB = null;
        IAtom atomCC = null;
        IAtom atomDD = null;
        IAtom atomEE = null;
        IAtom atomFF = null;
        IAtom atomGG = null;
        IAtom atomHH = null;
        IAtom atomII = null;
        IAtom atomJJ = null;
        IAtom atomKK = null;
        IAtom atomLL = null;
        IAtom atomMM = null;
        IAtom atomNN = null;
        IAtom atomOO = null;
        IAtom atomPP = null;
        IAtom atomQQ = null;
        IAtom atomRR = null;        
 }",NOT PASS,NOT PASS,NOT PASS,Syntax Error,  0.37348712526679284,  0.30791847906311265,  0.23322635926272112,None,170.0,0.6227106227106227,179.0,0.6556776556776557,228.0,0.8172043010752689,201.0,0.6401273885350318,60.0,0.40816326530612246,218.0,0.7813620071684588,224.0,0.7133757961783439,10.0,0.9090909090909091,2.0,0.18181818181818182,6.0,0.6
540,liquibase,"public boolean isSafeToRunUpdate() throws DatabaseException{
    DatabaseConnection connection = getConnection();
    if (connection == null) {
        return true;
    }
    String url = connection.getURL();
    if (url == null) {
        return false;
    }
    return (url.contains(""localhost"")) || (url.contains(""127.0.0.1""));
}",isSafeToRunUpdate,liquibase/database/AbstractJdbcDatabase.java,/liquibase-core/src/main/java/liquibase/database/AbstractJdbcDatabase.java,"/**
     * Default implementation, just look for ""local"" IPs. If the database returns a null URL we return false since we don't know it's safe to run the update.
     *
     * @throws liquibase.exception.DatabaseException
     *
     */",1238-1255,"('isSafeToRunUpdate', {'INSTRUCTION': {'covered': 22, 'missed': 4}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,11.0,"Default implementation, just look for ""local"" IPs.",Checks whether or not it is safe to run an update query on the database.,"Just look for ""local"" IPs.",0.503077154559152,"By default implementation, just look for ""local"" IP addresses.","public boolean isSafeToRunUpdate() throws DatabaseException{
        try {
            String ip = getConnection().getMetaData().getURL().replaceFirst(""^jdbc:.*://"", """");
            return !ip.matches(""^(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|localhost)$"");
        } catch (SQLException e) {
            throw new DatabaseException(e);
        }
    }"," public boolean isSafeToRunUpdate() throws DatabaseException{
        return true;
    }",Not Valid,"public boolean isSafeToRunUpdate() throws DatabaseException{
        try {
            String host = getConnection().getHost();
            if (host == null) {
                return true;
            }
            return !host.matches(""(?i).*\\b(?:(?:0\\.0\\.0\\.0)|(?:127\\.0\\.0\\.1)|(?:10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})|(?:192\\.168\\.\\d{1,3}\\.\\d{1,3})|(?:172\\.(?:1[6-9]|2\\d|3[0-1])\\.\\d{1,3}\\.\\d{1,3}))\\b.*"");
        } catch (DatabaseException e) {
            throw new DatabaseException(e);
        }
    }",NOT PASS,PASS,NOT PASS,Not Valid,  0.2817226681849098,  0.1028113067086588,  0.46061940002451973,None,43.0,0.6417910447761194,54.0,0.8059701492537313,39.0,0.582089552238806,None,None,46.0,0.7931034482758621,16.0,0.27586206896551724,None,None,15.0,0.9375,4.0,0.4,3.0,0.375
541,acs-aem-commons,"protected String generatePropertyChecksums(final String aggregateNodePath, final Node node, final ChecksumGeneratorOptions options) throws RepositoryException, IOException{
    SortedMap<String, String> propertyChecksums = new TreeMap<>();
    PropertyIterator properties = node.getProperties();
    while (properties.hasNext()) {
        final Property property = properties.nextProperty();
        if (options.getExcludedProperties().contains(property.getName())) {
            log.debug(""Excluding property: {}"", node.getPath() + ""/@"" + property.getName());
            continue;
        }
        final List<String> checksums = new ArrayList<String>();
        final List<Value> values = getPropertyValues(property);
        for (final Value value : values) {
            if (value.getType() == PropertyType.BINARY) {
                checksums.add(getBinaryChecksum(value));
            } else {
                checksums.add(getStringChecksum(value));
            }
        }
        if (!options.getSortedProperties().contains(property.getName())) {
            Collections.sort(checksums);
        }
        if (log.isDebugEnabled()) {
            log.debug(""Property: {} ~> {}"", getChecksumKey(aggregateNodePath, property.getPath()), StringUtils.join(checksums, "",""));
        }
        propertyChecksums.put(getChecksumKey(aggregateNodePath, property.getPath()), StringUtils.join(checksums, "",""));
    }
    return aggregateChecksums(propertyChecksums);
}",generatePropertyChecksums,com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,"/**
     * Returns a lexicographically sorted map of the [PROPERTY PATH] : [CHECKSUM OF PROPERTIES].
     * @param aggregateNodePath the absolute path of the node being aggregated into a checksum
     * @param node  the node to collect and checksum the properties for
     * @param options the checksum generator options
     * @return the map of the properties and their checksums
     * @throws RepositoryException
     */",232-286,"('generatePropertyChecksums', {'INSTRUCTION': {'covered': 108, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",277.0,18.0,Returns a lexicographically sorted map of the [PROPERTY PATH] : [CHECKSUM OF PROPERTIES].,"Generates and returns a sorted lexicographically map of (PROPERTY PATH, CHECKSUM OF PROPERTIES).",A map of the [property PATH] is returned.,0.562213409274922,Returns a lexicographically sorted map of [PROPERTY PATH]: [PROPERTY CHECKSUM].," protected String generatePropertyChecksums(final String aggregateNodePath, final Node node, final ChecksumGeneratorOptions options) throws RepositoryException, IOException{
        final Map<String, String> checksums = new LinkedHashMap<>();
    
        final PropertyIterator properties = node.getProperties();
    
        while (properties.hasNext()) {
            final Property property = properties.nextProperty();
    
            if (!isExcludedProperty(property, options)) {
                final String checksum = generatePropertyChecksum(aggregateNodePath, node, property, options);
                if (checksum != null) {
                    checksums.put(getChecksumKey(aggregateNodePath, property.getPath()), checksum);
                }
            }
        }
    
        final String propertyChecksum = aggregateChecksums(checksums);
        log.debug(""Node [ {} ] has a aggregated property checksum of [ {} ]"", getChecksumKey(aggregateNodePath, node.getPath()), propertyChecksum);
    
        return propertyChecksum;        
 }"," protected String generatePropertyChecksums(final String aggregateNodePath, final Node node, final ChecksumGeneratorOptions options) throws RepositoryException, IOException{
        final Map<String, String> checksums = new LinkedHashMap<>();
    
        final PropertyIterator properties = node.getProperties();
    
        while (properties.hasNext()) {
            final Property property = properties.nextProperty();
    
            if (!isExcludedProperty(property, options)) {
                final String checksum = generatePropertyChecksum(aggregateNodePath, node, property, options);
                if (checksum != null) {
                    checksums.put(getChecksumKey(aggregateNodePath, property.getPath()), checksum);
                }
            }
        }
    
        final String propertyChecksum = aggregateChecksums(checksums);
        log.debug(""Node [ {} ] has a aggregated property checksum of [ {} ]"", getChecksumKey(aggregateNodePath, node.getPath()), propertyChecksum);
    
        return propertyChecksum;        
 }"," protected String generatePropertyChecksums(final String aggregateNodePath, final Node node, final ChecksumGeneratorOptions options) throws RepositoryException, IOException{
        final Map<String, String> checksums = new LinkedHashMap<>();
    
        final PropertyIterator properties = node.getProperties();
    
        while (properties.hasNext()) {
            final Property property = properties.nextProperty();
    
            if (!isExcludedProperty(property, options)) {
                final String checksum = generatePropertyChecksum(aggregateNodePath, property, options);
                if (checksum != null) {
                    checksums.put(getChecksumKey(aggregateNodePath, property.getPath()), checksum);
                }
            }
        }
    
        final String propertyChecksum = aggregateChecksums(checksums);
        log.debug(""Node [ {} ] has a aggregated property checksum of [ {} ]"", getChecksumKey(aggregateNodePath, node.getPath()), propertyChecksum);
    
        return propertyChecksum;
    }"," protected String generatePropertyChecksums(final String aggregateNodePath, final Node node, final ChecksumGeneratorOptions options) throws RepositoryException, IOException{
        final Map<String, String> checksums = new LinkedHashMap<>();
    
        final PropertyIterator properties = node.getProperties();
    
        while (properties.hasNext()) {
            final Property property = properties.nextProperty();
    
            if (!isExcludedProperty(property, options)) {
                final String checksum = generatePropertyChecksum(aggregateNodePath, property, options);
                if (checksum != null) {
                    checksums.put(getChecksumKey(aggregateNodePath, property.getPath()), checksum);
                }
            }
        }
    
        final String propertyChecksum = aggregateChecksums(checksums);
        log.debug(""Node [ {} ] has a aggregated property checksum of [ {} ]"", getChecksumKey(aggregateNodePath, node.getPath()), propertyChecksum);
    
        return propertyChecksum;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.40896404140480014,  0.40896404140480014,  0.4093400079985987,  0.4093400079985987,167.0,0.6007194244604317,167.0,0.6007194244604317,167.0,0.6007194244604317,167.0,0.6007194244604317,0.0,0.0,2.0,0.012987012987012988,2.0,0.012987012987012988,11.0,0.7857142857142857,6.0,0.42857142857142855,9.0,0.6428571428571429
542,liquibase,"public boolean isRequiredFor(Database database){
    return getRequiredForDatabase().contains(ALL) || getRequiredForDatabase().contains(database.getShortName());
}",isRequiredFor,liquibase/change/ChangeParameterMetaData.java,/liquibase-core/src/main/java/liquibase/change/ChangeParameterMetaData.java,"/**
     * A convenience method for testing the value returned by {@link #getRequiredForDatabase()} against a given database.
     * Returns true if the {@link Database#getShortName()} method is contained in the required databases or the
     * required database list contains the string ""all""
     */",262-269,"('isRequiredFor', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,22.0,A convenience method for testing the value returned by {@link #getRequiredForDatabase()} against a given database.,"Return true whether the database contains the string ""all"" or the getShortName method is contained within it.",A convenience method for testing the value returned by @link #getRequiredForDatabase,0.686188281034788,A convenient method for testing the value returned by {@link #getRequiredForDatabase()} against a given database.," public boolean isRequiredFor(Database database){
        return getRequiredForDatabase().contains(database.getShortName());      
 }"," public boolean isRequiredFor(Database database){
        if (getRequiredForDatabase().contains(ALL)) {
            return true;
        }
        if (getRequiredForDatabase().contains(database.getShortName())) {
            return true;
        }
        return false;       
 }"," public boolean isRequiredFor(Database database){
        return getRequiredForDatabase().contains(database.getShortName());      
 }"," public boolean isRequiredFor(Database database){
        return getRequiredForDatabase().contains(database.getShortName());      
 }",NOT PASS,PASS,NOT PASS,NOT PASS,  0.6080076338823789,  0.7844109385640778,  0.6080076338823789,  0.6080076338823789,9.0,0.2727272727272727,18.0,0.3673469387755102,9.0,0.2727272727272727,9.0,0.2727272727272727,25.0,0.5102040816326531,0.0,0.0,0.0,0.0,16.0,0.8888888888888888,1.0,0.0625,6.0,0.375
543,cdk,"public void changeBase(Permutation newBase){
    PermutationGroup h = new PermutationGroup(newBase);
    int firstDiffIndex = base.firstIndexOfDifference(newBase);
    for (int j = firstDiffIndex; j < size; j++) {
        for (int a = 0; a < size; a++) {
            Permutation g = permutations[j][a];
            if (g != null) {
                h.enter(g);
            }
        }
    }
    for (int j = 0; j < firstDiffIndex; j++) {
        for (int a = 0; a < size; a++) {
            Permutation g = permutations[j][a];
            if (g != null) {
                int hj = h.base.get(j);
                int x = g.get(hj);
                h.permutations[j][x] = new Permutation(g);
            }
        }
    }
    this.base = new Permutation(h.base);
    this.permutations = h.permutations.clone();
}",changeBase,org/openscience/cdk/group/PermutationGroup.java,/tool/group/src/main/java/org/openscience/cdk/group/PermutationGroup.java,"/**
     * Change the base of the group to the new base <code>newBase</code>.
     *
     * @param newBase the new base for the group
     */",326-357,"('changeBase', {'INSTRUCTION': {'covered': 95, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",199.0,18.0,Change the base of the group to the new base <code>newBase</code>.,"Given the newBase object for the group, it changes the current base of the group with the newBase object.",The base of the group should be changed to the new base.,0.353520151664309,Replace the group database with the new <code>newBase</code>.,"public void changeBase(Permutation newBase){
        for(int i = 0; i < size; i++){
            for(int j = 0; j < size; j++){
                if(permutations[i][j] != null){
                    permutations[i][j] = permutations[i][j].changeBase(newBase);
                }
            }
        }
    }"," public void changeBase(Permutation newBase){
        this.base = newBase;
    }","public void changeBase(Permutation newBase){
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                if (permutations[i][j] != null) {
                    permutations[i][j] = permutations[i][j].changeBase(newBase);
                }
            }
        }
    }"," public void changeBase(Permutation newBase){
        this.base = newBase;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2195124811971389,  0.041801265760538886,  0.041801265760538886,  0.2195124811971389,141.0,0.705,185.0,0.925,185.0,0.925,141.0,0.705,64.0,0.8311688311688312,64.0,0.8311688311688312,0.0,0.0,14.0,0.7,7.0,0.5833333333333334,7.0,0.5384615384615384
544,acs-aem-commons,"public static List<Pattern> toPatterns(String[] values){
    List<Pattern> patterns = new ArrayList<Pattern>();
    if (values == null) {
        return patterns;
    }
    for (String value : values) {
        if (StringUtils.isNotBlank(value)) {
            patterns.add(Pattern.compile(value));
        }
    }
    return patterns;
}",toPatterns,com/adobe/acs/commons/util/ParameterUtil.java,/bundle/src/main/java/com/adobe/acs/commons/util/ParameterUtil.java,"/**
     * Util for converting a String[] into a List of compiled Patterns. Empty/blank strings will be skipped.
     * @param values the Strings to convert to patterns.
     * @return a List of Patterns
     */",204-223,"('toPatterns', {'INSTRUCTION': {'covered': 32, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,14.0,Util for converting a String[] into a List of compiled Patterns.,This method converts and returns an array of String into a list of Compiled Patterns. ,TheUtil is used to convert a string into a list of patterns.,0.324022219444801,Utility to convert a String[] into a list of compiled templates.," public static List<Pattern> toPatterns(String[] values){
        final List<Pattern> patterns = new ArrayList<Pattern>();
        if(values != null){
            for(String value : values){
                patterns.add(Pattern.compile(value));
            }
        }
        return patterns;        
 }"," public static List<Pattern> toPatterns(String[] values){
        List<Pattern> patterns = new ArrayList<Pattern>();
        for(String value : values){
            patterns.add(Pattern.compile(value));
        }
        return patterns;        
 }"," public static List<Pattern> toPatterns(String[] values){
        List<Pattern> patterns = new ArrayList<Pattern>();
        for (String value : values) {
            patterns.add(Pattern.compile(value));
        }
        return patterns;        
 }"," public static List<Pattern> toPatterns(String[] values){
        List<Pattern> patterns = new ArrayList<Pattern>();
        for (String value : values) {
            patterns.add(Pattern.compile(value));
        }
        return patterns;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7426039713648496,  0.6822146700647584,  0.6822146700647584,  0.6822146700647584,16.0,0.21052631578947367,22.0,0.2894736842105263,22.0,0.2894736842105263,22.0,0.2894736842105263,9.0,0.14285714285714285,9.0,0.14285714285714285,9.0,0.14285714285714285,11.0,0.6875,5.0,0.4166666666666667,9.0,0.6923076923076923
545,dataverse,"public boolean structuralContains(RoleAssignee ra){
    if (ra instanceof AuthenticatedUser) {
        if (containedAuthenticatedUsers.contains((AuthenticatedUser) ra)) {
            return true;
        }
    } else if (ra instanceof ExplicitGroup) {
        if (containedExplicitGroups.contains((ExplicitGroup) ra)) {
            return true;
        }
    } else {
        if (containedRoleAssignees.contains(ra.getIdentifier())) {
            return true;
        }
    }
    for (ExplicitGroup eg : containedExplicitGroups) {
        if (eg.structuralContains(ra)) {
            return true;
        }
    }
    return false;
}",structuralContains,edu/harvard/iq/dataverse/authorization/groups/impl/explicit/ExplicitGroup.java,/src/main/java/edu/harvard/iq/dataverse/authorization/groups/impl/explicit/ExplicitGroup.java,"/**
     * Looks at structural containment: whether {@code ra} is part of the
     * group's structure. It mostly the same as {@link #contains(edu.harvard.iq.dataverse.engine.command.DataverseRequest)},
     * except for logical containment. So if an ExplicitGroup contains {@link AuthenticatedUsers} but not
     * a specific {@link AuthenticatedUser} {@code u}, {@code structuralContains(u)}
     * would return {@code false} while {@code contains( request(u, ...) )} would return true;
     * 
     * @param ra
     * @return {@code true} iff the role assignee is structurally a part of the group.
     */",276-313,"('structuralContains', {'INSTRUCTION': {'covered': 50, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",107.0,19.0,Looks at structural containment: whether {@code ra} is part of the  group's structure.,"Determines whether or not the structural containment is a part of the groups's strucutre. Returns true if so, false otherwise.",Structural containment is the question of whether @codera is part of the group's structure.,0.710234688191095,Examines structural containment: if {@code ra} is part of the group structure.," public boolean structuralContains(RoleAssignee ra){
        if ( ra instanceof ExplicitGroup ) {
            ExplicitGroup eg = (ExplicitGroup)ra;
            if ( eg.owner.equals(owner) ) {
                return true;
            }
        }
        return false;
    }"," public boolean structuralContains(RoleAssignee ra){
        if ( ra instanceof ExplicitGroup ) {
            ExplicitGroup eg = (ExplicitGroup)ra;
            if ( eg.getOwner().equals(owner) ) {
                return true;
            }
        }
        return false;
    }"," public boolean structuralContains(RoleAssignee ra){
        if ( ra instanceof User ) {
            return containedAuthenticatedUsers.contains( (AuthenticatedUser)ra );
        } else {
            return containedExplicitGroups.contains( (ExplicitGroup)ra );
        }
    }"," public boolean structuralContains(RoleAssignee ra){
        if ( ra instanceof ExplicitGroup ) {
            ExplicitGroup eg = (ExplicitGroup) ra;
            if ( eg.owner.equals(owner) ) {
                return containedExplicitGroups.contains(eg);
            }
        }
        return false;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.32375266032860783,  0.31948563215141057,  0.29126165196003917,  0.2325333635659769,70.0,0.6481481481481481,68.0,0.6296296296296297,67.0,0.6203703703703703,68.0,0.6296296296296297,3.0,0.06382978723404255,6.0,0.12,23.0,0.5111111111111111,16.0,0.7619047619047619,4.0,0.2857142857142857,8.0,0.5333333333333333
546,cdk,"public static int[][] aaBondInfo(){
    if (aminoAcids == null) {
        createAAs();
    }
    int[][] info = new int[153][4];
    int counter = 0;
    int total = 0;
    for (int aa = 0; aa < aminoAcids.length; aa++) {
        AminoAcid acid = aminoAcids[aa];
        LOGGER.debug(""#bonds for "", acid.getProperty(RESIDUE_NAME).toString(), "" = "" + acid.getBondCount());
        total += acid.getBondCount();
        LOGGER.debug(""total #bonds: "", total);
        Iterator<IBond> bonds = acid.bonds().iterator();
        while (bonds.hasNext()) {
            IBond bond = (IBond) bonds.next();
            info[counter][0] = counter;
            info[counter][1] = acid.indexOf(bond.getBegin());
            info[counter][2] = acid.indexOf(bond.getEnd());
            info[counter][3] = bond.getOrder().numeric();
            counter++;
        }
    }
    if (counter > 153) {
        LOGGER.error(""Error while creating AA info! Bond count is too large: "", counter);
        return null;
    }
    return info;
}",aaBondInfo,org/openscience/cdk/templates/AminoAcids.java,/storage/pdb/src/main/java/org/openscience/cdk/templates/AminoAcids.java,"/**
     * Creates matrix with info about the bonds in the amino acids.
     * 0 = bond id, 1 = atom1 in bond, 2 = atom2 in bond, 3 = bond order.
     * @return info
     */",60-99,"('aaBondInfo', {'INSTRUCTION': {'covered': 112, 'missed': 14}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 20, 'missed': 3}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",249.0,12.0,Creates matrix with info about the bonds in the amino acids.,Using the information conveyed in the bonds creates and returns a matrix.,The matrix has information about the bonds in the amino acids.,0.231513824231473,Creates a matrix with information about the bonds in the amino acids.,Empty Method,"public static int[][] aaBondInfo(){
        int[][] bondInfo = new int[20][20];
        bondInfo[0][0] = 0;
        bondInfo[0][1] = 0;
        bondInfo[0][2] = 0;
        bondInfo[0][3] = 0;
        bondInfo[0][4] = 0;
        bondInfo[0][5] = 0;
        bondInfo[0][6] = 0;
        bondInfo[0][7] = 0;
        bondInfo[0][8] = 0;
        bondInfo[0][9] = 0;
        bondInfo[0][10] = 0;
        bondInfo[0][11] = 0;
        bondInfo[0][12] = 0;
        bondInfo[0][13] = 0;
        bondInfo[0][14] = 0;
        bondInfo[0][15] = 0;
        bondInfo[0][16] = 0;
        bondInfo[0][17] = 0;
        bondInfo[0][18] = 0;
        bondInfo[0][19] = 0;
        bondInfo[1][0] = 0;
        bondInfo[1][1] = 0;
        bondInfo[1][2] = 0;
        bondInfo[1][3] = 0;
        bondInfo[1][4] = 0;
        bondInfo[1][5] = 0;
        bondInfo[1][6] = 0;
        bondInfo[1][7] = 0;
        bondInfo[1][8] = 0;
        bondInfo[1][9] = 0;
        bondInfo[1][10] = 0;
        bondInfo[1][11] = 0;
        bondInfo[1][12] = 0;
        bondInfo[1][13] = 0;
        bondInfo[1][14] = 0;
        bondInfo[1][15] = 0;
        bondInfo[1][16] = 0;
        bondInfo[1][17] = 0;
        bondInfo[1][18] = 0;
        bondInfo[1][19] = 0;
        bondInfo        
 }",Empty Method,Empty Method,Empty Method,Syntax Error,Empty Method,Empty Method,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,10.0,0.7692307692307693,2.0,0.15384615384615385,3.0,0.25
548,cdk,"AtomSymbol center(double x, double y){
    Point2D center = getAlignmentCenter();
    return translate(x - center.getX(), y - center.getY());
}",center,org/openscience/cdk/renderer/generators/standard/AtomSymbol.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AtomSymbol.java,"/**
     * Convenience function to center an atom symbol on a specified point. The
     * centering depends on the symbol alignment.
     *
     * @param x x-axis location
     * @param y y-axis location
     * @return the centered symbol (new instance)
     */",233-244,"('center', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,12.0,Convenience function to center an atom symbol on a specified point.,Centers the atom's symbol on a specified point.,The convenience function centers an atom symbol.,0.710941404153197,Convenience function to center an atom symbol on a specified point.,"AtomSymbol center(double x, double y){
        Point2D center = element.getCenter();
        AffineTransform transform = new AffineTransform();
        transform.translate(x - center.getX(), y - center.getY());
        return transform(transform);
    }","AtomSymbol center(double x, double y){
        Point2D center = element.getCenter();
        AffineTransform transform = new AffineTransform();
        transform.translate(x - center.getX(), y - center.getY());
        return transform(transform);
    }","AtomSymbol center(double x, double y){
        Point2D center = element.getCenter();
        AffineTransform transform = new AffineTransform();
        transform.translate(x - center.getX(), y - center.getY());
        return transform(transform);
    }","AtomSymbol center(double x, double y){
        Point2D center = element.getCenter();
        AffineTransform transform = new AffineTransform();
        transform.translate(x - center.getX(), y - center.getY());
        return transform(transform);
    }",PASS,PASS,PASS,PASS,  0.6962775580953601,  0.6962775580953601,  0.6962775580953601,  0.6962775580953601,19.0,0.3392857142857143,19.0,0.3392857142857143,19.0,0.3392857142857143,19.0,0.3392857142857143,0.0,0.0,0.0,0.0,0.0,0.0,6.0,0.5,0.0,0.0,9.0,0.75
549,cdk,"public boolean inSameCell(int elementI, int elementJ){
    for (int cellIndex = 0; cellIndex < size(); cellIndex++) {
        SortedSet<Integer> cell = getCell(cellIndex);
        if (cell.contains(elementI) && cell.contains(elementJ)) {
            return true;
        }
    }
    return false;
}",inSameCell,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,"/**
     * Check that two elements are in the same cell of the partition.
     *
     * @param elementI an element in the partition
     * @param elementJ an element in the partition
     * @return true if both elements are in the same cell
     */",400-415,"('inSameCell', {'INSTRUCTION': {'covered': 24, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,13.0,Check that two elements are in the same cell of the partition.,"Returns true if the two-element given as input are in the same cell of the partition; otherwise, false.",The partition has two elements in the same cell.,0.254367786245717,Verify that two items are in the same cell in the partition.," public boolean inSameCell(int elementI, int elementJ){
        for (SortedSet<Integer> cell : cells) {
            if (cell.contains(elementI) && cell.contains(elementJ)) {
                return true;
            }
        }
        return false;
    }"," public boolean inSameCell(int elementI, int elementJ){
        for (SortedSet<Integer> cell : cells) {
            if (cell.contains(elementI) && cell.contains(elementJ)) {
                return true;
            }
        }
        return false;
    }"," public boolean inSameCell(int elementI, int elementJ){
        for (SortedSet<Integer> cell : cells) {
            if (cell.contains(elementI) && cell.contains(elementJ)) {
                return true;
            }
        }
        return false;
    }"," public boolean inSameCell(int elementI, int elementJ){
        for (SortedSet<Integer> cell : cells){
            if (cell.contains(elementI) && cell.contains(elementJ)){
                return true;
            }
        }
        return false;
    }",PASS,PASS,PASS,PASS,  0.5813288246454466,  0.5813288246454466,  0.5813288246454466,  0.5813288246454466,20.0,0.30303030303030304,20.0,0.30303030303030304,20.0,0.30303030303030304,20.0,0.30303030303030304,0.0,0.0,0.0,0.0,0.0,0.0,11.0,0.5789473684210527,3.0,0.23076923076923078,8.0,0.6153846153846154
551,egeria,"public Map<String, RelationshipsContext> buildSchemaElementContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
    final String methodName = ""buildSchemaElementContext"";
    handlerHelper.validateAsset(entityDetail, methodName, supportedZones);
    Map<String, RelationshipsContext> context = new HashMap<>();
    final String typeDefName = entityDetail.getType().getTypeDefName();
    Set<GraphContext> columnContext = new HashSet<>();
    switch(typeDefName) {
        case TABULAR_COLUMN:
            if (!isInternalTabularColumn(userId, entityDetail)) {
                columnContext = buildTabularColumnContext(userId, entityDetail);
            }
            break;
        case TABULAR_FILE_COLUMN:
            columnContext = buildTabularColumnContext(userId, entityDetail);
            break;
        case RELATIONAL_COLUMN:
            columnContext = buildRelationalColumnContext(userId, entityDetail);
            break;
        case EVENT_SCHEMA_ATTRIBUTE:
            columnContext = buildEventSchemaAttributeContext(userId, entityDetail);
            break;
        default:
            return context;
    }
    context.put(AssetLineageEventType.COLUMN_CONTEXT_EVENT.getEventTypeName(), new RelationshipsContext(entityDetail.getGUID(), columnContext));
    return context;
}",buildSchemaElementContext,org/odpi/openmetadata/accessservices/assetlineage/handlers/AssetContextHandler.java,/open-metadata-implementation/access-services/asset-lineage/asset-lineage-server/src/main/java/org/odpi/openmetadata/accessservices/assetlineage/handlers/AssetContextHandler.java,"/**
     * Builds the context for a schema element without the asset context.
     *
     * @param userId       the unique identifier for the user
     * @param entityDetail the entity for which the context is build
     *
     * @return the context of the schema element
     *
     * @throws OCFCheckedExceptionBase checked exception for reporting errors found when using OCF connectors
     */",67-105,"('buildSchemaElementContext', {'INSTRUCTION': {'covered': 71, 'missed': 2}, 'BRANCH': {'covered': 6, 'missed': 1}, 'LINE': {'covered': 16, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",185.0,12.0,Builds the context for a schema element without the asset context.,Generates the context for a schema element having no asset context.,The asset context is built for a schema element.,0.411760121160342,Generates the context of a schema element without the context of the resource.,"public Map<String, RelationshipsContext> buildSchemaElementContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
        Map<String, RelationshipsContext> schemaElementContext = new HashMap<>();
        String schemaType = entityDetail.getClassifications().get(0).getName();
        String schemaAttribute = entityDetail.getClassifications().get(0).getProperties().get(ATTRIBUTE_FOR_SCHEMA);
        String schemaAttributeValue = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_ATTRIBUTE);
        String schemaAttributeValueOption = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue2 = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue3 = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue4 = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue5 = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue6 = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue7 = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue8 = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue9 = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue10 = entityDetail.getClassifications().get(0).get     
 }","public Map<String, RelationshipsContext> buildSchemaElementContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
        Map<String, RelationshipsContext> context = new HashMap<>();
        String guid = entityDetail.getGUID();
        String type = entityDetail.getType().getTypeDefName();
        String name = entityDetail.getName();
        String description = entityDetail.getDescription();
        String assetSchemaType = getAssetSchemaType(type);
        String schemaTypeOption = getSchemaTypeOption(type);
        String schemaAttribute = getSchemaAttribute(type);
        String schemaAttributeValue = getSchemaAttributeValue(entityDetail);
        String schemaAttributeValue2 = getSchemaAttributeValue2(entityDetail);
        String schemaAttributeValue3 = getSchemaAttributeValue3(entityDetail);
        String schemaAttributeValue4 = getSchemaAttributeValue4(entityDetail);
        String schemaAttributeValue5 = getSchemaAttributeValue5(entityDetail);
        String schemaAttributeValue6 = getSchemaAttributeValue6(entityDetail);
        String schemaAttributeValue7 = getSchemaAttributeValue7(entityDetail);
        String schemaAttributeValue8 = getSchemaAttributeValue8(entityDetail);
        String schemaAttributeValue9 = getSchemaAttributeValue9(entityDetail);
        String schemaAttributeValue10 = getSchemaAttributeValue10(entityDetail);
        String schemaAttributeValue11 = getSchemaAttributeValue11(entityDetail);
        String schemaAttributeValue12 = getSchemaAttributeValue12(entityDetail);
        String schemaAttributeValue13 = getSchemaAttributeValue13(entityDetail);
        String schemaAttributeValue14 = getSchemaAttributeValue14(entityDetail);
        String schemaAttributeValue15 = getSchemaAttributeValue15(entityDetail);
        String schemaAttributeValue16 = getSchemaAttributeValue16(entityDetail);
        String schemaAttributeValue17 = getSchemaAttributeValue17(entityDetail);
        String schemaAttributeValue18 = getSchemaAttributeValue18(entityDetail);
        String schemaAttributeValue19 = getSchemaAttributeValue19(entityDetail);
        String schemaAttributeValue20 = getSchemaAttributeValue20(entityDetail);
        String schemaAttributeValue     
 }","public Map<String, RelationshipsContext> buildSchemaElementContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
        Map<String, RelationshipsContext> schemaElementContext = new HashMap<>();
        String schemaType = entityDetail.getClassifications().get(0).getName();
        String schemaAttribute = entityDetail.getClassifications().get(0).getProperties().get(ATTRIBUTE_FOR_SCHEMA);
        String schemaAttributeValue = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_ATTRIBUTE);
        String schemaAttributeValueOption = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue2 = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue3 = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue4 = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue5 = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue6 = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue7 = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue8 = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue9 = entityDetail.getClassifications().get(0).getProperties().get(SCHEMA_TYPE_OPTION);
        String schemaAttributeValueOptionValue10 = entityDetail.getClassifications().get(0).get     
 }"," public Map<String, RelationshipsContext> buildSchemaElementContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
        Map<String, RelationshipsContext> schemaElementContext = new HashMap<>();
        String entityGuid = entityDetail.getGUID();
        String entityType = entityDetail.getType().getTypeDefName();
        String entityName = entityDetail.getName();
        String entityDescription = entityDetail.getDescription();
        String entityZone = entityDetail.getZoneName();
        String entityClassification = entityDetail.getClassification();
        String entityStatus = entityDetail.getStatus();
        String entityProperties = entityDetail.getProperties();
        String entityExternalSource = entityDetail.getExternalSource();
        String entityExternalSourceId = entityDetail.getExternalId();
        String entityExternalSourceType = entityDetail.getExternalType();
        String entityExternalSourceOrigin = entityDetail.getExternalOrigin();
        String entityExternalSourceOriginId = entityDetail.getExternalOriginId();
        String entityExternalSourceOriginType = entityDetail.getExternalOriginType();
        String entityExternalSourceOriginZone = entityDetail.getExternalOriginZone();
        String entityExternalSourceOriginStatus = entityDetail.getExternalOriginStatus();
        String entityExternalSourceOriginProperties = entityDetail.getExternalOriginProperties();
        String entityExternalSourceOriginClassification = entityDetail.getExternalOriginClassification();
        String entityExternalSourceOriginDescription = entityDetail.getExternalOriginDescription();
        String entityExternalSourceOriginName = entityDetail.getExternalOriginName();
        String entityExternalSourceOriginGuid = entityDetail.getExternalOriginGUID();
        String entityExternalSourceOriginExternalSource = entityDetail.getExternalOriginExternalSource();
        String entityExternalSourceOriginExternalSourceId = entityDetail.getExternalOriginExternalSourceId();
        String entityExternalSourceOriginExternalSourceType = entityDetail.getExternalOriginExternalSourceType();
        String entityExternalSourceOriginExternalSourceOrigin = entityDetail.getExternalOriginExternalSourceOrigin();
        String entityExternalSourceOriginExternalSourceOriginId = entityDetail.getExternalOriginExternalSourceOriginId();
        String entityExternalSourceOriginExternalSourceOriginType = entityDetail.getExternalOriginExternalSourceOriginType      
 }",Syntax Error,Syntax Error,Syntax Error,Syntax Error,None,None,None,None,None,None,None,None,202.0,0.7240143369175627,269.0,0.7819767441860465,None,None,173.0,0.502906976744186,0.0,0.0,3.0,0.25,6.0,0.42857142857142855,9.0,0.75
552,matsim-libs,"protected boolean addToPendingNodes(final Link l, final Node n, final RouterPriorityQueue<Node> pendingNodes, final double currTime, final double currCost, final Node toNode){
    final double travelTime = this.timeFunction.getLinkTravelTime(l, currTime, this.person, this.vehicle);
    final double travelCost = this.costFunction.getLinkTravelDisutility(l, currTime, this.person, this.vehicle);
    final DijkstraNodeData data = getData(n);
    if (!data.isVisited(getIterationId())) {
        visitNode(n, data, pendingNodes, currTime + travelTime, currCost + travelCost, l);
        return true;
    }
    final double nCost = data.getCost();
    final double totalCost = currCost + travelCost;
    if (totalCost < nCost) {
        revisitNode(n, data, pendingNodes, currTime + travelTime, totalCost, l);
        return true;
    } else if (totalCost == nCost) {
        Link prevLink = data.getPrevLink();
        if (prevLink != null && prevLink.getId().compareTo(l.getId()) > 0) {
            revisitNode(n, data, pendingNodes, currTime + travelTime, totalCost, l);
            return true;
        }
    }
    return false;
}",addToPendingNodes,org/matsim/core/router/Dijkstra.java,/matsim/src/main/java/org/matsim/core/router/Dijkstra.java,"/**
	 * Adds some parameters to the given Node then adds it to the set of pending
	 * nodes.
	 *
	 * @param l
	 *            The link from which we came to this Node.
	 * @param n
	 *            The Node to add to the pending nodes.
	 * @param pendingNodes
	 *            The set of pending nodes.
	 * @param currTime
	 *            The time at which we started to traverse l.
	 * @param currCost
	 *            The cost at the time we started to traverse l.
	 * @param toNode
	 *            The target Node of the route.
	 * @return true if the node was added to the pending nodes, false otherwise
	 * 		(e.g. when the same node already has an earlier visiting time).
	 */",430-476,"('addToPendingNodes', {'INSTRUCTION': {'covered': 95, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",236.0,17.0,Adds some parameters to the given Node then adds it to the set of pending  nodes.,New parameters are added to the node given as input.  Such a node is later added to the set of pending nodes.,Adds parameters to the given Node and adds them to the pending nodes.,0.196833692845059,Adds some parameters to the given node and then adds it to the set of pending nodes.," protected boolean addToPendingNodes(final Link l, final Node n, final RouterPriorityQueue<Node> pendingNodes, final double currTime, final double currCost, final Node toNode){
	 		DijkstraNodeData data = getData(n);
 		double newTime = currTime + l.getLength();
 		double newCost = currCost + l.getLength();
 		if (newTime < data.getTime()) {
 			data.setTime(newTime);
 			data.setCost(newCost);
 			data.setPrevLink(l);
 			pendingNodes.add(n);
 			return true;
 		}
 		return false;
 	}"," protected boolean addToPendingNodes(final Link l, final Node n, final RouterPriorityQueue<Node> pendingNodes, final double currTime, final double currCost, final Node toNode){
		DijkstraNodeData data = getData(n);
		double newTime = currTime + l.getLength();
		double newCost = currCost + l.getLength();
		if (newTime < data.getTime()) {
			data.setTime(newTime);
			data.setCost(newCost);
			data.setPrevLink(l);
			pendingNodes.add(n);
			return true;
		} else {
			return false;
		}
	}"," protected boolean addToPendingNodes(final Link l, final Node n, final RouterPriorityQueue<Node> pendingNodes, final double currTime, final double currCost, final Node toNode){
	 	DijkstraNodeData data = getData(n);
 	double newTime = currTime + l.getLength();
 	double newCost = currCost + l.getLength();
 	if (newTime < data.getTime()) {
 		data.setTime(newTime);
 		data.setCost(newCost);
 		data.setPrevLink(l);
 		pendingNodes.add(n, newTime);
 		return true;
 	}
 	return false;
 }"," protected boolean addToPendingNodes(final Link l, final Node n, final RouterPriorityQueue<Node> pendingNodes, final double currTime, final double currCost, final Node toNode){
	 	DijkstraNodeData data = getData(n);
 	double newTime = currTime + l.getLength();
 	double newCost = currCost + l.getLength();
 	if (newTime < data.getTime()) {
 		data.setTime(newTime);
 		data.setCost(newCost);
 		data.setPrevLink(l);
 		data.setPrevNode(n);
 		pendingNodes.add(n);
 		return true;
 	}
 	return false;
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2859556407608891,  0.2933200930569704,  0.2991495295652418,  0.2880418454216646,157.0,0.6624472573839663,159.0,0.6708860759493671,156.0,0.6582278481012658,156.0,0.6582278481012658,3.0,0.02654867256637168,7.0,0.05982905982905983,2.0,0.017857142857142856,13.0,0.5652173913043478,2.0,0.1111111111111111,5.0,0.29411764705882354
553,dcache,"public static EnumSet<LoA> withImpliedLoA(Optional<EntityDefinition> entity, Collection<LoA> asserted){
    Map<LoA, LoA> mapping = entity.filter(PERSON::equals).map(e -> PERSONAL_EQUIVALENT_LOA).orElse(GENERIC_EQUIVALENT_LOA);
    EnumSet<LoA> result = EnumSet.copyOf(asserted);
    Collection<LoA> considered = asserted;
    do {
        EnumSet<LoA> additional = considered.stream().map(mapping::get).filter(Objects::nonNull).collect(Collectors.toCollection(() -> EnumSet.noneOf(LoA.class)));
        result.addAll(additional);
        considered = additional;
    } while (!considered.isEmpty());
    return result;
}",withImpliedLoA,org/dcache/auth/LoAs.java,/modules/common/src/main/java/org/dcache/auth/LoAs.java,"/**
     * Convert a set of asserted LoAs so it includes all equivalent LoAs.
     *
     * @param entity   the kind of identity asserted, if known.
     * @param asserted a collection of LoA asserted by some external agent.
     * @return all LoAs for this identity.
     */",68-94,"('withImpliedLoA', {'INSTRUCTION': {'covered': 44, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",145.0,13.0,Convert a set of asserted LoAs so it includes all equivalent LoAs.,Translates a set of asserted LoAs in such a way to include all the equivalent LoAs.,All equivalent loAs can be converted so it includes a set of asserted loAs.,0.930003353639261,Convert a set of asserted LoAs so that it includes all equivalent LoAs.," public static EnumSet<LoA> withImpliedLoA(Optional<EntityDefinition> entity, Collection<LoA> asserted){
      if (entity.isPresent() && entity.get() == PERSON) {
          return asserted.stream()
                  .map(LoAs::withImpliedLoA)
                  .flatMap(Collection::stream)
                  .collect(Collectors.toCollection(EnumSet::copyOf));
      } else {
          return EnumSet.copyOf(asserted);
      }                 
 }"," public static EnumSet<LoA> withImpliedLoA(Optional<EntityDefinition> entity, Collection<LoA> asserted){
      if (entity.isPresent() && entity.get() == PERSON) {
          return asserted.stream()
                  .map(LoAs::withImpliedLoA)
                  .flatMap(Collection::stream)
                  .collect(Collectors.toCollection(EnumSet::copyOf));
      } else {
          return EnumSet.copyOf(asserted);
      }                 
 }"," public static EnumSet<LoA> withImpliedLoA(Optional<EntityDefinition> entity, Collection<LoA> asserted){
      Objects.requireNonNull(entity);
      Objects.requireNonNull(asserted);
      if (entity.isPresent() && entity.get() == PERSON) {
          return EnumSet.copyOf(asserted).addAll(PERSONAL_EQUIVALENT_LOA.values());
      } else {
          return EnumSet.copyOf(asserted).addAll(GENERIC_EQUIVALENT_LOA.values());
      }                 
 }"," public static EnumSet<LoA> withImpliedLoA(Optional<EntityDefinition> entity, Collection<LoA> asserted){
      Objects.requireNonNull(asserted);
      if (entity.isPresent() && entity.get() == PERSON) {
          return asserted.stream()
                  .map(LoAs::personalEquivalent)
                  .flatMap(Collection::stream)
                  .collect(Collectors.toCollection(() -> EnumSet.copyOf(asserted)));
      } else {
          return asserted.stream()
                  .map(LoAs::genericEquivalent)
                  .flatMap(Collection::stream)
                  .collect(Collectors.toCollection(() -> EnumSet.copyOf(asserted)));
      }                 
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.32145748544424363,  0.32145748544424363,  0.36145582668803783,  0.27012275166796246,85.0,0.5821917808219178,85.0,0.5821917808219178,91.0,0.6232876712328768,92.0,0.6301369863013698,0.0,0.0,46.0,0.35658914728682173,44.0,0.4782608695652174,8.0,0.47058823529411764,1.0,0.07142857142857142,11.0,0.7333333333333333
554,cdk,"static void readNonStructuralData(final BufferedReader input, final IAtomContainer container) throws IOException{
    String line, header = null;
    boolean wrap = false;
    final StringBuilder data = new StringBuilder(80);
    while (!endOfRecord(line = input.readLine())) {
        final String newHeader = dataHeader(line);
        if (newHeader != null) {
            if (header != null)
                container.setProperty(header, data.toString());
            header = newHeader;
            wrap = false;
            data.setLength(0);
        } else {
            if (data.length() > 0 || !line.equals("" ""))
                line = line.trim();
            if (line.isEmpty())
                continue;
            if (!wrap && data.length() > 0)
                data.append('\n');
            data.append(line);
            wrap = line.length() == 80;
        }
    }
    if (header != null)
        container.setProperty(header, data.toString());
}",readNonStructuralData,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Read non-structural data from input and store as properties the provided
     * 'container'. Non-structural data appears in a structure data file (SDF)
     * after an Molfile and before the record deliminator ('$$$$'). The data
     * consists of one or more Data Header and Data blocks, an example is seen
     * below.
     *
     * <pre>{@code
     * > 29 <DENSITY>
     * 0.9132 - 20.0
     *
     * > 29 <BOILING.POINT>
     * 63.0 (737 MM)
     * 79.0 (42 MM)
     *
     * > 29 <ALTERNATE.NAMES>
     * SYLVAN
     *
     * > 29 <DATE>
     * 09-23-1980
     *
     * > 29 <CRC.NUMBER>
     * F-0213
     *
     * }</pre>
     *
     *
     * @param input     input source
     * @param container the container
     * @throws IOException an error occur whilst reading the input
     */",2226-2290,"('readNonStructuralData', {'INSTRUCTION': {'covered': 79, 'missed': 0}, 'BRANCH': {'covered': 20, 'missed': 0}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 11, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",200.0,14.0,Read non-structural data from input and store as properties the provided  'container'.,Stores non-structural data as a proporties into the provided container. ,Read non-structural data from input and store it as a container.,0.475639248930798,"Read the non-structural data from the input and store the provided ""container"" as properties.",Not Valid,"static void readNonStructuralData(final BufferedReader input, final IAtomContainer container) throws IOException{
        String line = input.readLine();
        while (line != null && !line.startsWith(""M  END"")) {
            if (line.startsWith(""V  "")) {
                Integer atomNumber = Integer.valueOf(line.substring(3, 6).trim());
                IAtom atomWithComment = container.getAtom(atomNumber - 1);
                atomWithComment.setProperty(CDKConstants.COMMENT, line.substring(7));
            }
            line = input.readLine();
        }
    }",Not Valid,Not Valid,Not Valid,NOT PASS,Not Valid,Not Valid,None,  0.2974300835161728,None,None,None,None,139.0,0.6915422885572139,None,None,None,None,109.0,0.990909090909091,None,None,None,None,8.0,0.6153846153846154,7.0,0.4666666666666667,5.0,0.38461538461538464
555,matsim-libs,"public static List<PlanElement> insertTrip(final Plan plan, final Activity origin, final List<? extends PlanElement> trip, final Activity destination){
    return insertTrip(plan.getPlanElements(), origin, trip, destination);
}",insertTrip,org/matsim/core/router/TripRouter.java,/matsim/src/main/java/org/matsim/core/router/TripRouter.java,"/**
	 * Inserts a trip between two activities in the sequence of plan elements
	 * returned by the {@link Plan#getPlanElements()} method of a plan. Note
	 * that the plan will be modified only if the returned list is the internal
	 * reference!
	 * <p></p>
	 * Note that this methods returns a unique solution because it expects the activity object references as arguments, which are unique.
	 *
	 * @param plan the plan to modify
	 * @param origin the activity to use as origin. It must be a member of the list of plan elements.
	 * @param trip the trip to insert
	 * @param destination the destination activity. It must be a member of the list.
	 * @return the ""old trip"": the sequence of plan elements originally existing between the origin and the destination
	 */",226-250,"('insertTrip', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,29.0,Inserts a trip between two activities in the sequence of plan elements  returned by the {@link Plan#getPlanElements()} method of a plan.,Inserts and returns an old trip which includes a new trip destination.,The trip between the two activities is included in the plan elements returned by the @link Plan#getPlanElements,0.622542748187535,Inserts a path between two activities into the sequence of plan elements returned by the {@link Plan#getPlanElements()} method of a plan.,"public static List<PlanElement> insertTrip(final Plan plan, final Activity origin, final List<? extends PlanElement> trip, final Activity destination){
		List<PlanElement> newPlanElements = new ArrayList<PlanElement>();
		int index = plan.getPlanElements().indexOf(origin);
		if (index < 0) {
			throw new IllegalArgumentException(""origin activity not found in plan"");
		}
		newPlanElements.addAll(plan.getPlanElements().subList(0, index));
		newPlanElements.addAll(trip);
		newPlanElements.addAll(plan.getPlanElements().subList(index, plan.getPlanElements().size()));
		newPlanElements.add(destination);
		return newPlanElements;
	}"," public static List<PlanElement> insertTrip(final Plan plan, final Activity origin, final List<? extends PlanElement> trip, final Activity destination){
		List<PlanElement> newPlan = new ArrayList<PlanElement>();
		newPlan.add(origin);
		newPlan.addAll(trip);
		newPlan.add(destination);
		return newPlan;
	}","public static List<PlanElement> insertTrip(final Plan plan, final Activity origin, final List<? extends PlanElement> trip, final Activity destination){
		List<PlanElement> planElements = plan.getPlanElements();
		int index = planElements.indexOf(origin);
		if (index == -1) {
			throw new RuntimeException(""origin activity not found in plan"");
		}
		planElements.addAll(index + 1, trip);
		index = planElements.indexOf(destination);
		if (index == -1) {
			throw new RuntimeException(""destination activity not found in plan"");
		}
		planElements.addAll(index + 1, trip);
		return planElements;
	}","public static List<PlanElement> insertTrip(final Plan plan, final Activity origin, final List<? extends PlanElement> trip, final Activity destination){
		List<PlanElement> planElements = plan.getPlanElements();
		int index = planElements.indexOf(origin);
		if (index == -1) {
			throw new IllegalArgumentException(""origin activity not found in plan"");
		}
		planElements.addAll(index + 1, trip);
		index = planElements.indexOf(destination);
		if (index == -1) {
			throw new IllegalArgumentException(""destination activity not found in plan"");
		}
		planElements.addAll(index + 1, trip);
		return planElements;
	}",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6894609803639339,  0.6877257880724823,  0.6908127565311594,  0.6908127565311594,91.0,0.6691176470588235,30.0,0.42857142857142855,77.0,0.6416666666666667,77.0,0.6416666666666667,72.0,0.5294117647058824,59.0,0.4338235294117647,60.0,0.4411764705882353,20.0,0.9090909090909091,2.0,0.09090909090909091,13.0,0.5909090909090909
556,matsim-libs,"public static double calculateWeightFromLine(final Coordinate from, final Coordinate to, final Coordinate cellCentroid, final double smoothingRadius){
    if (smoothingRadius <= 0)
        throw new IllegalArgumentException(""smoothing radius must be greater 0"");
    double a = from.distance(cellCentroid) * from.distance(cellCentroid);
    double b = (to.x - from.x) * (from.x - cellCentroid.x) + (to.y - from.y) * (from.y - cellCentroid.y);
    double linkLength = from.distance(to);
    double c = (smoothingRadius * Math.sqrt(Math.PI) / (linkLength * 2)) * Math.exp(-(a - (b * b / (linkLength * linkLength))) / (smoothingRadius * smoothingRadius));
    double upperLimit = linkLength + b / linkLength;
    double lowerLimit = b / linkLength;
    double integrationUpperLimit = Erf.erf(upperLimit / smoothingRadius);
    double integrationLowerLimit = Erf.erf(lowerLimit / smoothingRadius);
    double weight = c * (integrationUpperLimit - integrationLowerLimit);
    if (weight < 0)
        throw new RuntimeException(""Weight may not be negative! Value: "" + weight);
    return weight;
}",calculateWeightFromLine,org/matsim/contrib/analysis/spatial/SpatialInterpolation.java,/contribs/analysis/src/main/java/org/matsim/contrib/analysis/spatial/SpatialInterpolation.java,"/**
     * This uses a gaussian distance weighting to calculate the impact of link based emissions onto the centroid of a
     * grid cell. The level of emission is assumed to be linear over the link. The calculation is described in Argawal's
     * PhD thesis https://depositonce.tu-berlin.de/handle/11303/6266 in Appendix A.2
     *
     * @param from         Link from coordinate
     * @param to           Link to coordinate
     * @param cellCentroid centroid of the impacted cell
     * @return weight factor by which the emission value should be multiplied to calculate the impact of the cell
     */",8-39,"('calculateWeightFromLine', {'INSTRUCTION': {'covered': 102, 'missed': 6}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",225.0,22.0,This uses a gaussian distance weighting to calculate the impact of link based emissions onto the centroid of a  grid cell.,"Computes and returns the distance weighting concerning the impact of the link, based emission onto the centroid of a grid cell.",The impact of link based emissions onto the centroid of a grid cell is calculated using a gaussian distance weighting.,0.190869346323013,This uses Gaussian distance weighting to calculate the impact of emissions based on the bond on the centroid of a grid cell.,"public static double calculateWeightFromLine(final Coordinate from, final Coordinate to, final Coordinate cellCentroid, final double smoothingRadius){
     	double weight = 0.0;
     	double distance = from.distance(to);
     	double distanceFromCellCentroid = cellCentroid.distance(from);
     	double distanceToCellCentroid = cellCentroid.distance(to);
     	double distanceFromTo = distanceFromCellCentroid + distanceToCellCentroid;
     	double distanceFromToSquared = distanceFromTo * distanceFromTo;
     	double distanceFromToCubed = distanceFromToSquared * distanceFromTo;
     	double distanceFromToQuart = distanceFromToCubed * distanceFromTo;
     	double distanceFromToQuint = distanceFromToQuart * distanceFromTo;
     	double distanceFromToSext = distanceFromToQuint * distanceFromTo;
     	double distanceFromToSept = distanceFromToSext * distanceFromTo;
     	double distanceFromToOct = distanceFromToSept * distanceFromTo;
     	double distanceFromToNov = distanceFromToOct * distanceFromTo;
     	double distanceFromToDec = distanceFromToNov * distanceFromTo;
     	double distanceFromToJan = distanceFromToDec * distanceFromTo;
     	double distanceFromToFeb = distanceFromToJan * distanceFromTo;
     	double distanceFromToMar = distanceFromToFeb * distanceFromTo;
     	double distanceFromToApr = distanceFromToMar * distanceFromTo;
     	double distanceFromToMay = distanceFromToApr * distanceFromTo;
     	double distanceFromToJun = distanceFromToMay * distanceFromTo;
     	double distanceFromToJul = distanceFromToJun * distanceFromTo;
     	double distanceFromToAug = distanceFromToJul * distanceFromTo;
     	double distanceFromToSep = distanceFromToAug * distanceFromTo;
     	double distanceFromToOct2 = distanceFromToSep * distanceFromTo;
     	double distanceFromToNov2 = distanceFromToOct2 * distanceFromTo;
     	double distanceFromToDec2 = distanceFromToNov2 * distanceFromTo;
     	double distanceFromToJan2 = distanceFromToDec2 * distanceFromTo;
     	double distanceFromToFeb2 =     
 }","public static double calculateWeightFromLine(final Coordinate from, final Coordinate to, final Coordinate cellCentroid, final double smoothingRadius){
     	double distance = from.distance(to);
     	double distanceToCell = from.distance(cellCentroid);
     	double weight = 1.0 - (distanceToCell / distance);
     	weight = Math.max(0.0, weight);
     	weight = Math.min(1.0, weight);
     	weight = 1.0 - weight;
     	weight = Math.pow(weight, 2.0);
     	weight = Math.min(1.0, weight);
     	weight = Math.max(0.0, weight);
     	weight = 1.0 - weight;
     	weight = Math.pow(weight, 2.0);
     	weight = Math.min(1.0, weight);
     	weight = Math.max(0.0, weight);
     	weight = 1.0 - weight;
     	weight = Math.pow(weight, 2.0);
     	weight = Math.min(1.0, weight);
     	weight = Math.max(0.0, weight);
     	weight = 1.0 - weight;
     	weight = Math.pow(weight, 2.0);
     	weight = Math.min(1.0, weight);
     	weight = Math.max(0.0, weight);
     	weight = 1.0 - weight;
     	weight = Math.pow(weight, 2.0);
     	weight = Math.min(1.0, weight);
     	weight = Math.max(0.0, weight);
     	weight = 1.0 - weight;
     	weight = Math.pow(weight, 2.0);
     	weight = Math.min(1.0, weight);
     	weight = Math.max(0.0, weight);
     	weight = 1.0 - weight;
     	weight = Math.pow(weight, 2.0);
     	weight = Math.min(1.0, weight);
     	weight = Math.max(0.0, weight);
     	weight = 1.0 - weight;
     	weight = Math.pow(weight, 2.0       
 }","public static double calculateWeightFromLine(final Coordinate from, final Coordinate to, final Coordinate cellCentroid, final double smoothingRadius){
     	double weight = 0.0;
     	double distance = from.distance(to);
     	double distanceToCentroid = from.distance(cellCentroid);
     	if (distanceToCentroid < smoothingRadius){
     		weight = 1.0 - (distanceToCentroid / smoothingRadius);
     	}
     	else{
     		weight = 0.0;
     	}
     	return weight;      
 }","public static double calculateWeightFromLine(final Coordinate from, final Coordinate to, final Coordinate cellCentroid, final double smoothingRadius){
     	double weight = 0.0;
     	double distance = cellCentroid.distance(from);
     	if (distance < smoothingRadius){
     		weight = 1.0 - Erf.erf(Math.sqrt(2.0) * (distance / smoothingRadius));
     	}
     	distance = cellCentroid.distance(to);
     	if (distance < smoothingRadius){
     		weight += 1.0 - Erf.erf(Math.sqrt(2.0) * (distance / smoothingRadius));
     	}
     	return weight;      
 }",Syntax Error,Syntax Error,NOT PASS,NOT PASS,None,None,  0.2725653053000471,  0.21712961227149152,None,None,None,None,158.0,0.6991150442477876,168.0,0.7433628318584071,None,None,174.0,0.7802690582959642,171.0,0.7668161434977578,9.0,0.4090909090909091,7.0,0.30434782608695654,17.0,0.7727272727272727
557,cdk,"public DescriptorValue calculate(IAtomContainer atomContainer){
    double volume;
    try {
        volume = VABCVolume.calculate(clone(atomContainer));
    } catch (CDKException exception) {
        return getDummyDescriptorValue(exception);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(volume), getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/VABCDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/VABCDescriptor.java,"/**
     * Calculates the descriptor value using the {@link VABCVolume} class.
     *
     * @param atomContainer The {@link IAtomContainer} whose volume is to be calculated
     * @return A double containing the volume
     */",78-96,"('calculate', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,13.0,Calculates the descriptor value using the {@link VABCVolume} class.,Computs the descriptor value using the link VABCVolumne class.,The @link VABCVolume class is used to calculate the descriptor value.,0.782103403836211,Calculates the value of the descriptor using the {@link VABCVolume} class.," public DescriptorValue calculate(IAtomContainer atomContainer){
        try {
            DoubleResult result = new DoubleResult(VABCVolume.getVolume(atomContainer));
            result.setResultType(DoubleResultType.ABSOLUTE);
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), result, getDescriptorNames());
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }",Empty Method,Empty Method,Empty Method,NOT PASS,Empty Method,Empty Method,Empty Method,  0.6552608840017324,None,None,None,38.0,0.5277777777777778,None,None,None,None,None,None,None,None,None,None,None,None,3.0,0.3,4.0,0.3333333333333333,11.0,0.9166666666666666
558,cdk,"public void writeMolecule(IAtomContainer container) throws Exception{
    final int dim = getNumberOfDimensions(container);
    StringBuilder line = new StringBuilder();
    Map<Integer, Integer> rgroups = null;
    Map<Integer, String> aliases = null;
    String title = container.getTitle();
    if (title == null)
        title = """";
    if (title.length() > 80)
        title = title.substring(0, 80);
    writer.write(title);
    writer.write('\n');
    writer.write(""  "");
    writer.write(getProgName());
    writer.write(new SimpleDateFormat(""MMddyyHHmm"").format(System.currentTimeMillis()));
    if (dim != 0) {
        writer.write(Integer.toString(dim));
        writer.write('D');
    }
    writer.write('\n');
    String comment = (String) container.getProperty(CDKConstants.REMARK);
    if (comment == null)
        comment = """";
    if (comment.length() > 80)
        comment = comment.substring(0, 80);
    writer.write(comment);
    writer.write('\n');
    Map<IAtom, ITetrahedralChirality> atomstereo = new HashMap<>();
    Map<IAtom, Integer> atomindex = new HashMap<>();
    for (IStereoElement element : container.stereoElements()) if (element instanceof ITetrahedralChirality)
        atomstereo.put(((ITetrahedralChirality) element).getChiralAtom(), (ITetrahedralChirality) element);
    for (IAtom atom : container.atoms()) atomindex.put(atom, atomindex.size());
    line.append(formatMDLInt(container.getAtomCount(), 3));
    line.append(formatMDLInt(container.getBondCount(), 3));
    Map<Integer, IAtom> atomLists = new LinkedHashMap<>();
    for (int f = 0; f < container.getAtomCount(); f++) {
        if (container.getAtom(f) instanceof IQueryAtom) {
            QueryAtom queryAtom = (QueryAtom) AtomRef.deref(container.getAtom(f));
            Expr expr = queryAtom.getExpression();
            if (isValidAtomListExpression(expr)) {
                atomLists.put(f, container.getAtom(f));
            }
        }
    }
    line.append(formatMDLInt(atomLists.size(), 3));
    line.append(""  0"");
    line.append(getChiralFlag(atomstereo.values()) ? ""  1"" : ""  0"");
    line.append(""  0  0  0  0  0999 V2000"");
    writer.write(line.toString());
    writer.write('\n');
    for (int f = 0; f < container.getAtomCount(); f++) {
        IAtom atom = container.getAtom(f);
        line.setLength(0);
        switch(dim) {
            case 0:
                line.append(""    0.0000    0.0000    0.0000 "");
                break;
            case 2:
                if (atom.getPoint2d() != null) {
                    line.append(formatMDLFloat((float) atom.getPoint2d().x));
                    line.append(formatMDLFloat((float) atom.getPoint2d().y));
                    line.append(""    0.0000 "");
                } else {
                    line.append(""    0.0000    0.0000    0.0000 "");
                }
                break;
            case 3:
                if (atom.getPoint3d() != null) {
                    line.append(formatMDLFloat((float) atom.getPoint3d().x));
                    line.append(formatMDLFloat((float) atom.getPoint3d().y));
                    line.append(formatMDLFloat((float) atom.getPoint3d().z)).append("" "");
                } else {
                    line.append(""    0.0000    0.0000    0.0000 "");
                }
                break;
        }
        if (container.getAtom(f) instanceof IPseudoAtom) {
            IPseudoAtom pseudoAtom = (IPseudoAtom) container.getAtom(f);
            String label = pseudoAtom.getLabel();
            if (label == null)
                label = """";
            Matcher matcher = NUMERED_R_GROUP.matcher(label);
            if (""R"".equals(pseudoAtom.getSymbol()) && !label.isEmpty() && matcher.matches()) {
                line.append(""R# "");
                if (rgroups == null) {
                    rgroups = new TreeMap<Integer, Integer>();
                }
                rgroups.put(f + 1, Integer.parseInt(matcher.group(1)));
            } else {
                if (label.length() > 3) {
                    if (aliases == null)
                        aliases = new TreeMap<Integer, String>();
                    aliases.put(f + 1, label);
                    line.append(formatMDLString(atom.getSymbol(), 3));
                } else {
                    if (!label.isEmpty())
                        line.append(formatMDLString(label, 3));
                    else
                        line.append(formatMDLString(atom.getSymbol(), 3));
                }
            }
        } else if (atomLists.containsKey(f)) {
            line.append(formatMDLString(""L"", 3));
        } else {
            line.append(formatMDLString(container.getAtom(f).getSymbol(), 3));
        }
        int[] atomprops = new int[12];
        atomprops[0] = determineIsotope(atom);
        atomprops[1] = determineCharge(container, atom);
        atomprops[2] = determineStereoParity(container, atomstereo, atomindex, atom);
        atomprops[5] = determineValence(container, atom);
        atomprops[9] = determineAtomMap(atom);
        line.append(formatMDLInt(atomprops[0], 2));
        line.append(formatMDLInt(atomprops[1], 3));
        int last = atomprops.length - 1;
        if (!writeDefaultProps.isSet()) {
            while (last >= 0) {
                if (atomprops[last] != 0)
                    break;
                last--;
            }
            if (last >= 2 && last < 5)
                last = 5;
        }
        for (int i = 2; i <= last; i++) line.append(formatMDLInt(atomprops[i], 3));
        line.append('\n');
        writer.write(line.toString());
    }
    for (IBond bond : container.bonds()) {
        line.setLength(0);
        if (bond.getAtomCount() != 2) {
            logger.warn(""Skipping bond with more/less than two atoms: "" + bond);
        } else {
            if (bond.getStereo() == IBond.Stereo.UP_INVERTED || bond.getStereo() == IBond.Stereo.DOWN_INVERTED || bond.getStereo() == IBond.Stereo.UP_OR_DOWN_INVERTED) {
                line.append(formatMDLInt(atomindex.get(bond.getEnd()) + 1, 3));
                line.append(formatMDLInt(atomindex.get(bond.getBegin()) + 1, 3));
            } else {
                line.append(formatMDLInt(atomindex.get(bond.getBegin()) + 1, 3));
                line.append(formatMDLInt(atomindex.get(bond.getEnd()) + 1, 3));
            }
            int bondType = 0;
            if (bond instanceof QueryBond) {
                QueryBond qbond = ((QueryBond) bond);
                Expr e = qbond.getExpression();
                switch(e.type()) {
                    case ALIPHATIC_ORDER:
                    case ORDER:
                        bondType = e.value();
                        break;
                    case IS_AROMATIC:
                        bondType = 4;
                        break;
                    case SINGLE_OR_DOUBLE:
                        bondType = 5;
                        break;
                    case SINGLE_OR_AROMATIC:
                        bondType = 6;
                        break;
                    case DOUBLE_OR_AROMATIC:
                        bondType = 7;
                        break;
                    case TRUE:
                        bondType = 8;
                        break;
                    case OR:
                        if (e.equals(new Expr(Expr.Type.ALIPHATIC_ORDER, 1).or(new Expr(Expr.Type.ALIPHATIC_ORDER, 2))) || e.equals(new Expr(Expr.Type.ALIPHATIC_ORDER, 2).or(new Expr(Expr.Type.ALIPHATIC_ORDER, 1))))
                            bondType = 5;
                        else if (e.equals(new Expr(Expr.Type.ALIPHATIC_ORDER, 1).or(new Expr(Expr.Type.IS_AROMATIC))) || e.equals(new Expr(Expr.Type.IS_AROMATIC).or(new Expr(Expr.Type.ALIPHATIC_ORDER, 1))))
                            bondType = 6;
                        else if (e.equals(new Expr(Expr.Type.ALIPHATIC_ORDER, 2).or(new Expr(Expr.Type.IS_AROMATIC))) || e.equals(new Expr(Expr.Type.IS_AROMATIC).or(new Expr(Expr.Type.ALIPHATIC_ORDER, 2))))
                            bondType = 6;
                        break;
                    default:
                        throw new IllegalArgumentException(""Unsupported bond type!"");
                }
            } else {
                if (bond.getOrder() != null) {
                    switch(bond.getOrder()) {
                        case SINGLE:
                        case DOUBLE:
                        case TRIPLE:
                            if (writeAromaticBondTypes.isSet() && bond.isAromatic())
                                bondType = 4;
                            else
                                bondType = bond.getOrder().numeric();
                            break;
                        case UNSET:
                            if (bond.isAromatic()) {
                                if (!writeAromaticBondTypes.isSet())
                                    throw new CDKException(""Bond at idx "" + container.indexOf(bond) + "" was an unspecific aromatic bond which should only be used for queries in Molfiles. These can be written if desired by enabling the option 'WriteAromaticBondTypes'."");
                                bondType = 4;
                            }
                            break;
                    }
                }
            }
            if (bondType == 0)
                throw new CDKException(""Bond at idx="" + container.indexOf(bond) + "" is not supported by Molfile, bond="" + bond.getOrder());
            line.append(formatMDLInt(bondType, 3));
            line.append(""  "");
            switch(bond.getStereo()) {
                case UP:
                    line.append(""1"");
                    break;
                case UP_INVERTED:
                    line.append(""1"");
                    break;
                case DOWN:
                    line.append(""6"");
                    break;
                case DOWN_INVERTED:
                    line.append(""6"");
                    break;
                case UP_OR_DOWN:
                    line.append(""4"");
                    break;
                case UP_OR_DOWN_INVERTED:
                    line.append(""4"");
                    break;
                case E_OR_Z:
                    line.append(""3"");
                    break;
                default:
                    line.append(""0"");
            }
            if (writeDefaultProps.isSet())
                line.append(""  0  0  0"");
            line.append('\n');
            writer.write(line.toString());
        }
    }
    for (int i = 0; i < container.getAtomCount(); i++) {
        IAtom atom = container.getAtom(i);
        if (atom.getProperty(CDKConstants.COMMENT) != null && atom.getProperty(CDKConstants.COMMENT) instanceof String && !((String) atom.getProperty(CDKConstants.COMMENT)).trim().equals("""")) {
            writer.write(""V  "");
            writer.write(formatMDLInt(i + 1, 3));
            writer.write("" "");
            writer.write((String) atom.getProperty(CDKConstants.COMMENT));
            writer.write('\n');
        }
    }
    for (int i = 0; i < container.getAtomCount(); i++) {
        IAtom atom = container.getAtom(i);
        Integer charge = atom.getFormalCharge();
        if (charge != null && charge != 0) {
            writer.write(""M  CHG  1 "");
            writer.write(formatMDLInt(i + 1, 3));
            writer.write("" "");
            writer.write(formatMDLInt(charge, 3));
            writer.write('\n');
        }
    }
    if (container.getSingleElectronCount() > 0) {
        Map<Integer, SPIN_MULTIPLICITY> atomIndexSpinMap = new LinkedHashMap<Integer, SPIN_MULTIPLICITY>();
        for (int i = 0; i < container.getAtomCount(); i++) {
            IAtom atom = container.getAtom(i);
            int eCount = container.getConnectedSingleElectronsCount(atom);
            switch(eCount) {
                case 0:
                    continue;
                case 1:
                    atomIndexSpinMap.put(i, SPIN_MULTIPLICITY.Monovalent);
                    break;
                case 2:
                    SPIN_MULTIPLICITY multiplicity = atom.getProperty(CDKConstants.SPIN_MULTIPLICITY);
                    if (multiplicity != null)
                        atomIndexSpinMap.put(i, multiplicity);
                    else {
                        atomIndexSpinMap.put(i, SPIN_MULTIPLICITY.DivalentSinglet);
                    }
                    break;
                default:
                    logger.debug(""Invalid number of radicals found: "" + eCount);
                    break;
            }
        }
        Iterator<Map.Entry<Integer, SPIN_MULTIPLICITY>> iterator = atomIndexSpinMap.entrySet().iterator();
        for (int i = 0; i < atomIndexSpinMap.size(); i += NN8) {
            if (atomIndexSpinMap.size() - i <= NN8) {
                writer.write(""M  RAD"" + formatMDLInt(atomIndexSpinMap.size() - i, WIDTH));
                writeRadicalPattern(iterator, 0);
            } else {
                writer.write(""M  RAD"" + formatMDLInt(NN8, WIDTH));
                writeRadicalPattern(iterator, 0);
            }
            writer.write('\n');
        }
    }
    for (int i = 0; i < container.getAtomCount(); i++) {
        IAtom atom = container.getAtom(i);
        if (!(atom instanceof IPseudoAtom)) {
            Integer atomicMass = atom.getMassNumber();
            if (!writeMajorIsotopes.isSet() && isMajorIsotope(atom))
                atomicMass = null;
            if (atomicMass != null) {
                writer.write(""M  ISO  1 "");
                writer.write(formatMDLInt(i + 1, 3));
                writer.write("" "");
                writer.write(formatMDLInt(atomicMass, 3));
                writer.write('\n');
            }
        }
    }
    if (rgroups != null) {
        StringBuilder rgpLine = new StringBuilder();
        int cnt = 0;
        for (Map.Entry<Integer, Integer> e : rgroups.entrySet()) {
            rgpLine.append(formatMDLInt(e.getKey(), 4));
            rgpLine.append(formatMDLInt(e.getValue(), 4));
            cnt++;
            if (cnt == 8) {
                rgpLine.insert(0, ""M  RGP"" + formatMDLInt(cnt, 3));
                writer.write(rgpLine.toString());
                writer.write('\n');
                rgpLine = new StringBuilder();
                cnt = 0;
            }
        }
        if (cnt != 0) {
            rgpLine.insert(0, ""M  RGP"" + formatMDLInt(cnt, 3));
            writer.write(rgpLine.toString());
            writer.write('\n');
        }
    }
    if (aliases != null) {
        for (Map.Entry<Integer, String> e : aliases.entrySet()) {
            writer.write(""A"" + formatMDLInt(e.getKey(), 5));
            writer.write('\n');
            String label = e.getValue();
            if (label.length() > 70)
                label = label.substring(0, 70);
            writer.write(label);
            writer.write('\n');
        }
    }
    writeAtomLists(atomLists, writer);
    writeSgroups(container, writer, atomindex);
    writer.write(""M  END"");
    writer.write('\n');
    writer.flush();
}",writeMolecule,org/openscience/cdk/io/MDLV2000Writer.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Writer.java,"/**
     * Writes a Molecule to an OutputStream in MDL sdf format.
     *
     * @param container Molecule that is written to an OutputStream
     */",361-803,"('writeMolecule', {'INSTRUCTION': {'covered': 1172, 'missed': 195}, 'BRANCH': {'covered': 130, 'missed': 45}, 'LINE': {'covered': 229, 'missed': 33}, 'COMPLEXITY': {'covered': 58, 'missed': 39}, 'METHOD': {'covered': 1, 'missed': 0}})",2943.0,11.0,Writes a Molecule to an OutputStream in MDL sdf format.,A new molecule is written into an OutputStream using the MDL sdf format.,A molecule is written to an output stream.,0.297034688823565,Writes a molecule in an OutputStream in MDL sdf format.,Not Valid,Not Valid,Not Valid,"public void writeMolecule(IAtomContainer container) throws Exception{
        if (container.getAtomCount() == 0) return;
        writer.write(""$MDL"");
        writer.write(""\n"");
        writer.write(""  "");
        writer.write(getProgName());
        writer.write(""\n"");
        writer.write(""  "");
        writer.write(getDate());
        writer.write(""\n"");
        writer.write(""  "");
        writer.write(getRemark());
        writer.write(""\n"");
        writer.write(""  "");
        writer.write(getTitle());
        writer.write(""\n"");
        writer.write(""  "");
        writer.write(getFormula(container));
        writer.write(""\n"");
        writer.write(""  "");
        writer.write(getCharge(container));
        writer.write(""\n"");
        writer.write(""  "");
        writer.write(getMolWeight(container));
        writer.write(""\n"");
        writer.write(""  "");
        writer.write(getAtomList(container));
        writer.write(""\n"");
        writer.write(""  "");
        writer.write(getBondList(container));
        writer.write(""\n"");
        writer.write(""  "");
        writer.write(getAtomProps(container));
        writer.write(""\n"");
        writer.write(""  "");
        writer.write(getBondProps(container));
        writer.write(""\n"");
        writer.write(""  "");
        writer.write(getValencies(container));
        writer.write(""\n"");
        writer.write(""  "");
        writer.write(getQueryFormatValencies(container));
        writer.write(""\n"");
        writer.write(""  "");
        writer.write(getDefaultProps(container));
        writer.write(""\n"");
        writer.write(""M  END"");
        writer.write(""\n"");     
 }",Not Valid,Not Valid,NOT PASS,Not Valid,None,None,  0.08206180258875806,None,None,None,None,None,2625.0,0.8916440217391305,None,None,None,None,383.0,0.9973958333333334,None,None,8.0,0.5714285714285714,2.0,0.18181818181818182,9.0,0.8181818181818182
560,acs-aem-commons,"private boolean accept(final Resource resource) throws RepositoryException{
    if (resource == null || ResourceUtil.isNonExistingResource(resource)) {
        return false;
    }
    for (final Map.Entry<String, Pattern> nodeTypeAndPathRestriction : this.pathRestrictionByNodeType.entrySet()) {
        final String[] hierarchyNodeTypes = StringUtils.split(nodeTypeAndPathRestriction.getKey(), ""/"");
        boolean match = true;
        Resource walkingResource = resource;
        for (int i = (hierarchyNodeTypes.length - 1); i >= 0; i--) {
            if (walkingResource == null) {
                match = false;
                break;
            } else {
                final Node node = walkingResource.adaptTo(Node.class);
                if (node == null || !node.isNodeType(hierarchyNodeTypes[i])) {
                    match = false;
                    break;
                }
                walkingResource = walkingResource.getParent();
            }
        }
        if (match) {
            Pattern pathRestriction = nodeTypeAndPathRestriction.getValue();
            if (pathRestriction != null && !pathRestriction.matcher(resource.getPath()).matches()) {
                log.debug(""Path restriction '{}' prevents the resource at '{}' from getting its replication status updated!"", pathRestriction, resource.getPath());
                return false;
            }
            return true;
        }
    }
    return false;
}",accept,com/adobe/acs/commons/replication/status/impl/JcrPackageReplicationStatusEventHandler.java,/bundle/src/main/java/com/adobe/acs/commons/replication/status/impl/JcrPackageReplicationStatusEventHandler.java,"/**
     * Checks if the ReplicationStatusManager should make the provides resource w replication status.
     *
     * @param resource the return
     * @return true is the resource is markable resource
     * @throws RepositoryException
     */",397-445,"('accept', {'INSTRUCTION': {'covered': 74, 'missed': 15}, 'BRANCH': {'covered': 14, 'missed': 6}, 'LINE': {'covered': 17, 'missed': 6}, 'COMPLEXITY': {'covered': 5, 'missed': 6}, 'METHOD': {'covered': 1, 'missed': 0}})",230.0,13.0,Checks if the ReplicationStatusManager should make the provides resource w replication status.,"Returns true if the ReplicationStatusManager makes the provides resource with the replication status, otherwise false.",If the ReplicationStatusManager should make the provides resource.,0.208039910707078,Checks whether ReplicationStatusManager should set the replication status of the provided resource.," private boolean accept(final Resource resource) throws RepositoryException{
        if (resource == null) {
            return false;
        }
    
        final String path = resource.getPath();
        if (StringUtils.isBlank(path)) {
            return false;
        }
    
        if (containsJcrPackagePath(path)) {
            return true;
        }
    
        if (resource.getResourceType().equals(JcrConstants.NT_FILE)) {
            return true;
        }
    
        return false;
    }"," private boolean accept(final Resource resource) throws RepositoryException{
        if (resource == null) {
            return false;
        }
        final String path = resource.getPath();
        if (StringUtils.isBlank(path)) {
            return false;
        }
        if (containsJcrPackagePath(path)) {
            return true;
        }
        return false;
    }"," private boolean accept(final Resource resource) throws RepositoryException{
        if (resource == null) {
            return false;
        }
    
        final String path = resource.getPath();
        if (StringUtils.isBlank(path)) {
            return false;
        }
    
        if (containsJcrPackagePath(path)) {
            return true;
        }
    
        if (resource.getResourceType().equals(JcrConstants.NT_FILE)) {
            return true;
        }
    
        return false;
    }"," private boolean accept(final Resource resource) throws RepositoryException{
        if (resource == null) {
            return false;
        }
    
        final String path = resource.getPath();
        if (StringUtils.isBlank(path)) {
            return false;
        }
    
        if (containsJcrPackagePath(path)) {
            return true;
        }
    
        if (resource.getResourceType().equals(JcrConstants.NT_FILE)) {
            return true;
        }
    
        return false;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.18315152805670518,  0.155816440360808,  0.18315152805670518,  0.18315152805670518,166.0,0.7186147186147186,176.0,0.7619047619047619,166.0,0.7186147186147186,166.0,0.7186147186147186,20.0,0.24096385542168675,0.0,0.0,0.0,0.0,9.0,0.5625,9.0,0.6923076923076923,6.0,0.46153846153846156
562,matsim-libs,"public final void createIterationDirectory(final int iteration){
    File dir = new File(getIterationPath(iteration));
    if (!dir.mkdir()) {
        if (this.overwriteFiles == OverwriteFileSetting.overwriteExistingFiles && dir.exists()) {
            log.info(""Iteration directory "" + getIterationPath(iteration) + "" exists already."");
        } else {
            log.warn(""Could not create iteration directory "" + getIterationPath(iteration) + ""."");
        }
    }
}",createIterationDirectory,org/matsim/core/controler/OutputDirectoryHierarchy.java,/matsim/src/main/java/org/matsim/core/controler/OutputDirectoryHierarchy.java,"/**
	 * Creates the path where all iteration-related data should be stored.
	 */",187-202,"('createIterationDirectory', {'INSTRUCTION': {'covered': 25, 'missed': 6}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 6, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",83.0,11.0,Creates the path where all iteration-related data should be stored.,Defines a new dedicated path for all the iteration-related data.,The path where all iteration-related data should be stored is created.,0.311819445209746,Creates the path where all iteration-related data should be stored.," public final void createIterationDirectory(final int iteration){
	 		String path = getIterationPath(iteration);
 		File f = new File(path);
 		if (!f.exists()){
 			f.mkdir();
 		}
 	}"," public final void createIterationDirectory(final int iteration){
	 		createDirectory(getIterationPath(iteration));
 	}",Not Valid,Not Valid,NOT PASS,NOT PASS,Not Valid,Not Valid,  0.3031429475102397,  0.17558739975507126,None,None,51.0,0.6071428571428571,65.0,0.7738095238095238,None,None,None,None,28.0,0.6086956521739131,None,None,None,None,10.0,0.9090909090909091,0.0,0.0,5.0,0.4166666666666667
563,incubator-shenyu,"public static LocalDateTime formatLocalDateTimeFromTimestampBySystemTimezone(final Long timestamp){
    return LocalDateTime.ofEpochSecond(timestamp / 1000, 0, OffsetDateTime.now().getOffset());
}",formatLocalDateTimeFromTimestampBySystemTimezone,org/apache/shenyu/common/utils/DateUtils.java,/shenyu-common/src/main/java/org/apache/shenyu/common/utils/DateUtils.java,"/**
     * Format local date time from timestamp by system time zone.
     *
     * @param timestamp the timestamp
     * @return the local date time
     */",91-99,"('formatLocalDateTimeFromTimestampBySystemTimezone', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,11.0,Format local date time from timestamp by system time zone.,"From a system time zone, it formats the local date and time.",Local date time from timestamp by system time zone,0.260007770078217,Format the local date and time from the timestamp by system time zone.,"public static LocalDateTime formatLocalDateTimeFromTimestampBySystemTimezone(final Long timestamp){
        return LocalDateTime.ofEpochSecond(timestamp / 1000, 0, ZoneOffset.systemDefault());
    }","public static LocalDateTime formatLocalDateTimeFromTimestampBySystemTimezone(final Long timestamp){
        return LocalDateTime.ofEpochSecond(timestamp / 1000, 0, ZoneOffset.systemDefault());
    }","public static LocalDateTime formatLocalDateTimeFromTimestampBySystemTimezone(final Long timestamp){
        return LocalDateTime.ofEpochSecond(timestamp / 1000, 0, ZoneOffset.systemDefault());
    }","public static LocalDateTime formatLocalDateTimeFromTimestampBySystemTimezone(final Long timestamp){
        return LocalDateTime.ofEpochSecond(timestamp / 1000, 0, ZoneOffset.systemDefault());
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7816728774858751,  0.7816728774858751,  0.7816728774858751,  0.7816728774858751,6.0,0.17647058823529413,6.0,0.17647058823529413,6.0,0.17647058823529413,6.0,0.17647058823529413,0.0,0.0,0.0,0.0,0.0,0.0,11.0,0.8461538461538461,3.0,0.21428571428571427,3.0,0.2727272727272727
564,jackson-databind,"protected JsonNode _readTreeAndClose(JsonParser p0) throws IOException{
    try (JsonParser p = p0) {
        final JavaType valueType = constructType(JsonNode.class);
        DeserializationConfig cfg = getDeserializationConfig();
        cfg.initialize(p);
        JsonToken t = p.currentToken();
        if (t == null) {
            t = p.nextToken();
            if (t == null) {
                return cfg.getNodeFactory().missingNode();
            }
        }
        final JsonNode resultNode;
        final DefaultDeserializationContext ctxt = createDeserializationContext(p, cfg);
        if (t == JsonToken.VALUE_NULL) {
            resultNode = cfg.getNodeFactory().nullNode();
        } else {
            resultNode = (JsonNode) ctxt.readRootValue(p, valueType, _findRootDeserializer(ctxt, valueType), null);
        }
        if (cfg.isEnabled(DeserializationFeature.FAIL_ON_TRAILING_TOKENS)) {
            _verifyNoTrailingTokens(p, ctxt, valueType);
        }
        return resultNode;
    }
}",_readTreeAndClose,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Similar to {@link #_readMapAndClose} but specialized for <code>JsonNode</code>
     * reading.
     *
     * @since 2.9
     */",4685-4726,"('_readTreeAndClose', {'INSTRUCTION': {'covered': 70, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",177.0,20.0,Similar to {@link #_readMapAndClose} but specialized for <code>JsonNode</code>  reading.,Specialized method for JsonNode similar to readMapAndClose method.,It is similar to @link #_readMapAndClose but specialized for code reading.,0.789055260848287,Similar to {@link #_readMapAndClose} but specialized for <code>JsonNode</code> playback.,"protected JsonNode _readTreeAndClose(JsonParser p0) throws IOException{
        try (JsonParser p = p0) {
            final JsonNode result;
            final DeserializationConfig cfg = getDeserializationConfig();
            final DefaultDeserializationContext ctxt = createDeserializationContext(p, cfg);
            JsonToken t = _initForReading(p, TypeFactory.defaultInstance().constructType(JsonNode.class));
            if (t == JsonToken.VALUE_NULL) {
                // Ask JsonDeserializer what 'null value' to use:
                result = _findRootDeserializer(ctxt, TypeFactory.defaultInstance().constructType(JsonNode.class)).getNullValue(ctxt);
            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
                result = null;
            } else {
                result = ctxt.readTree(p);
                ctxt.checkUnresolvedObjectId();
            }
            if (cfg.isEnabled(DeserializationFeature.FAIL_ON_TRAILING_TOKENS)) {
                _verifyNoTrailingTokens(p, ctxt, TypeFactory.defaultInstance().constructType(JsonNode.class));
            }
            return result;
        }       
 }","protected JsonNode _readTreeAndClose(JsonParser p0) throws IOException{
        try (JsonParser p = p0) {
            final JsonNode result;
            final DeserializationConfig cfg = getDeserializationConfig();
            final DefaultDeserializationContext ctxt = createDeserializationContext(p, cfg);
            JsonToken t = _initForReading(p, null);
            if (t == JsonToken.VALUE_NULL) {
                // Ask JsonDeserializer what 'null value' to use:
                result = _findRootDeserializer(ctxt, null).getNullValue(ctxt);
            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
                result = null;
            } else {
                result = ctxt.readTree(p);
                ctxt.checkUnresolvedObjectId();
            }
            if (cfg.isEnabled(DeserializationFeature.FAIL_ON_TRAILING_TOKENS)) {
                _verifyNoTrailingTokens(p, ctxt, null);
            }
            return result;
        }
    }","protected JsonNode _readTreeAndClose(JsonParser p0) throws IOException{
        try (JsonParser p = p0) {
            final DeserializationConfig cfg = getDeserializationConfig();
            final DefaultDeserializationContext ctxt = createDeserializationContext(p, cfg);
            JsonToken t = _initForReading(p, null);
            if (t == JsonToken.VALUE_NULL) {
                // Ask JsonDeserializer what 'null value' to use:
                return _findRootDeserializer(ctxt, null).getNullValue(ctxt);
            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
                return null;
            } else {
                return ctxt.readTree(p);
            }
        }
    }","protected JsonNode _readTreeAndClose(JsonParser p0) throws IOException{
        try (JsonParser p = p0) {
            final DeserializationConfig cfg = getDeserializationConfig();
            final DefaultDeserializationContext ctxt = createDeserializationContext(p, cfg);
            JsonToken t = _initForReading(p, null);
            if (t == JsonToken.VALUE_NULL) {
                return JsonNodeFactory.instance.nullNode();
            }
            if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
                return null;
            }
            JsonNode result = ctxt.readTree(p);
            ctxt.checkUnresolvedObjectId();
            if (cfg.isEnabled(DeserializationFeature.FAIL_ON_TRAILING_TOKENS)) {
                _verifyNoTrailingTokens(p, ctxt, null);
            }
            return result;
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5268749188847056,  0.49098885612286985,  0.4622816390514031,  0.35201666268125126,99.0,0.5561797752808989,87.0,0.4887640449438202,89.0,0.5,111.0,0.6235955056179775,36.0,0.2057142857142857,54.0,0.30857142857142855,76.0,0.4342857142857143,9.0,0.9,1.0,0.1,6.0,0.5
565,weblogic-kubernetes-operator,"public String formatMessage(String msgId, Object... params){
    if (params == null || params.length == 0) {
        return getResourceBundle().getString(msgId);
    }
    String msg = getResourceBundle().getString(msgId);
    MessageFormat formatter = new MessageFormat(msg);
    return formatter.format(params);
}",formatMessage,oracle/kubernetes/operator/logging/LoggingFacade.java,/operator/src/main/java/oracle/kubernetes/operator/logging/LoggingFacade.java,"/**
   * Formats message based on string loaded from the resource bundle backing this logger.
   * @param msgId Message id
   * @param params Parameters to message formatting
   * @return Formatted message
   */",608-622,"('formatMessage', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,14.0,Formats message based on string loaded from the resource bundle backing this logger.,Returns a formatted message based on a string loaded from the resource bundle backing.,The message is formatted based on the string in the resource bundle.,0.424212059667707,Formats the message based on the string loaded from the resource bundle supporting this recorder.," public String formatMessage(String msgId, Object... params){
    ResourceBundle rb = getResourceBundle();
    String msg = rb.getString(msgId);
    return MessageFormat.format(msg, params);
  }",Empty Method,Empty Method," public String formatMessage(String msgId, Object... params){
    ResourceBundle rb = getResourceBundle();
    String msg = rb.getString(msgId);
    return MessageFormat.format(msg, params);
  }",NOT PASS,Empty Method,NOT PASS,Empty Method,  0.3847983787372395,None,  0.3847983787372395,None,35.0,0.5223880597014925,None,None,35.0,0.5223880597014925,None,None,None,None,0.0,0.0,None,None,7.0,0.4666666666666667,4.0,0.25,10.0,0.7142857142857143
566,cucumber-reporting,"private void fillMissingSteps(){
    passedFeatures = fillMissingArray(passedFeatures);
    passedScenarios = fillMissingArray(passedScenarios);
    passedSteps = fillMissingArray(passedSteps);
    skippedSteps = fillMissingArray(skippedSteps);
    pendingSteps = fillMissingArray(pendingSteps);
    undefinedSteps = fillMissingArray(undefinedSteps);
}",fillMissingSteps,net/masterthought/cucumber/Trends.java,/src/main/java/net/masterthought/cucumber/Trends.java,"/**
     * Since pending and undefined steps were added later
     * there is need to fill missing data for those statuses.
     */",206-219,"('fillMissingSteps', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",49.0,19.0,Since pending and undefined steps were added later  there is need to fill missing data for those statuses.,"passedFeatures, passedScenarios, passedSteps, skippedSteps, pendingStep and undefinedStep are filled with  the function fillMissingArray. ",There is need to fill in missing data for the statuses since the pending and undefined steps were added later.,0.250017431661361,"Since the pending and undefined steps were added later, it is necessary to fill in the missing data for these statuses.","private void fillMissingSteps(){
        for (int i = pendingSteps.length; i < buildNumbers.length; i++) {
            pendingSteps = ArrayUtils.add(pendingSteps, 0);
            undefinedSteps = ArrayUtils.add(undefinedSteps, 0);
        }       
 }","private void fillMissingSteps(){
        int[] missingArray = new int[buildNumbers.length - passedSteps.length];
        Arrays.fill(missingArray, 0);
        passedSteps = ArrayUtils.add(passedSteps, missingArray);
        failedSteps = ArrayUtils.add(failedSteps, missingArray);
        skippedSteps = ArrayUtils.add(skippedSteps, missingArray);
        pendingSteps = ArrayUtils.add(pendingSteps, missingArray);
        undefinedSteps = ArrayUtils.add(undefinedSteps, missingArray);
        totalSteps = ArrayUtils.add(totalSteps, missingArray);      
 }","private void fillMissingSteps(){
        int[] missingSteps = new int[buildNumbers.length];
        for (int i = 0; i < missingSteps.length; i++) {
            missingSteps[i] = 0;
        }
        passedSteps = ArrayUtils.addAll(passedSteps, missingSteps);
        failedSteps = ArrayUtils.addAll(failedSteps, missingSteps);
        skippedSteps = ArrayUtils.addAll(skippedSteps, missingSteps);
        pendingSteps = ArrayUtils.addAll(pendingSteps, missingSteps);
        undefinedSteps = ArrayUtils.addAll(undefinedSteps, missingSteps);
        totalSteps = ArrayUtils.addAll(totalSteps, missingSteps);       
 }","private void fillMissingSteps(){
        for (int i = pendingSteps.length; i < buildNumbers.length; i++) {
            pendingSteps = ArrayUtils.add(pendingSteps, 0);
            undefinedSteps = ArrayUtils.add(undefinedSteps, 0);
        }       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.1994389783750156,  0.272088833680376,  0.1994389783750156,  0.2421203069610467,34.0,0.68,62.0,0.62,34.0,0.68,74.0,0.6607142857142857,65.0,0.65,0.0,0.0,73.0,0.6517857142857143,18.0,0.9473684210526315,7.0,0.3181818181818182,20.0,0.9523809523809523
568,cdk,"private IMolecularFormula putInOrder(IMolecularFormula formula){
    IMolecularFormula new_formula = formula.getBuilder().newInstance(IMolecularFormula.class);
    for (int i = 0; i < orderElements.length; i++) {
        IElement element = builder.newInstance(IElement.class, orderElements[i]);
        if (MolecularFormulaManipulator.containsElement(formula, element)) {
            Iterator<IIsotope> isotopes = MolecularFormulaManipulator.getIsotopes(formula, element).iterator();
            while (isotopes.hasNext()) {
                IIsotope isotope = isotopes.next();
                new_formula.addIsotope(isotope, formula.getIsotopeCount(isotope));
            }
        }
    }
    return new_formula;
}",putInOrder,org/openscience/cdk/formula/MassToFormulaTool.java,/legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java,"/**
     * Put in order the elements of the molecular formula.
     *
     * @param formula The IMolecularFormula to put in order
     * @return        IMolecularFormula object
     */",499-519,"('putInOrder', {'INSTRUCTION': {'covered': 58, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",128.0,10.0,Put in order the elements of the molecular formula.,Sorts the elements of the molecular formula.,Put the elements in order.,0.302762126507745,Put the elements of the molecular formula in order.,"private IMolecularFormula putInOrder(IMolecularFormula formula){
        List<IIsotope> isotopes = formula.getIsotopes();
        List<IIsotope> newIsotopes = new ArrayList<IIsotope>();
        for (int i = 0; i < orderElements.length; i++) {
            String symbol = orderElements[i];
            for (int j = 0; j < isotopes.size(); j++) {
                IIsotope isotope = isotopes.get(j);
                if (isotope.getSymbol().equals(symbol)) {
                    newIsotopes.add(isotope);
                }
            }
        }
        formula.setIsotopes(newIsotopes);
        return formula;
    }","private IMolecularFormula putInOrder(IMolecularFormula formula){
        List<IIsotope> isotopes = formula.getIsotopes();
        List<IIsotope> isotopes_new = new ArrayList<IIsotope>();
        for (int i = 0; i < orderElements.length; i++) {
            String symbol = orderElements[i];
            for (int j = 0; j < isotopes.size(); j++) {
                IIsotope isotope = isotopes.get(j);
                if (isotope.getSymbol().equals(symbol)) {
                    isotopes_new.add(isotope);
                }
            }
        }
        formula.setIsotopes(isotopes_new);
        return formula;
    }","private IMolecularFormula putInOrder(IMolecularFormula formula){
        List<IIsotope> isotopes = formula.getIsotopes();
        List<IIsotope> newIsotopes = new ArrayList<IIsotope>();
        for (int i = 0; i < orderElements.length; i++) {
            String symbol = orderElements[i];
            for (int j = 0; j < isotopes.size(); j++) {
                IIsotope isotope = isotopes.get(j);
                if (isotope.getSymbol().equals(symbol)) {
                    newIsotopes.add(isotope);
                }
            }
        }
        formula.setIsotopes(newIsotopes);
        return formula;
    }","private IMolecularFormula putInOrder(IMolecularFormula formula){
        List<IIsotope> isotopes = formula.getIsotopes();
        List<IIsotope> newIsotopes = new ArrayList<IIsotope>();
        for (int i = 0; i < orderElements.length; i++) {
            String symbol = orderElements[i];
            for (int j = 0; j < isotopes.size(); j++) {
                IIsotope isotope = isotopes.get(j);
                if (isotope.getSymbol().equals(symbol)) {
                    newIsotopes.add(isotope);
                }
            }
        }
        formula.setIsotopes(newIsotopes);
        return formula;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.47691294797617334,  0.47691294797617334,  0.47691294797617334,  0.47691294797617334,78.0,0.6046511627906976,78.0,0.6046511627906976,78.0,0.6046511627906976,78.0,0.6046511627906976,3.0,0.024193548387096774,0.0,0.0,0.0,0.0,3.0,0.3,5.0,0.5,6.0,0.6
569,tablesaw,"private Selection createMultiColSelection(Table table, int ri, List<Index> indexes, int selectionSize, List<Integer> joinColumnIndexes){
    Selection multiColSelection = Selection.withRange(0, selectionSize);
    int i = 0;
    for (Integer joinColumnIndex : joinColumnIndexes) {
        Column<?> col = table.column(joinColumnIndex);
        Selection oneColSelection = selectionForColumn(col, ri, indexes.get(i));
        multiColSelection = multiColSelection.and(oneColSelection);
        i++;
    }
    return multiColSelection;
}",createMultiColSelection,tech/tablesaw/joining/DataFrameJoiner.java,/core/src/main/java/tech/tablesaw/joining/DataFrameJoiner.java,"/**
   * Create a big multicolumn selection for all join columns in the given table. Joins two tables.
   *
   * @param table the table that used to generate Selection.
   * @param ri row number of row in table.
   * @param indexes a reverse index for every join column in the table.
   * @param selectionSize max size in table .
   * @param joinColumnIndexes the column index of join key in tables
   * @return selection created
   */",435-461,"('createMultiColSelection', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",98.0,14.0,Create a big multicolumn selection for all join columns in the given table.,"From a table given as input, it creates a multicolumn selection joining two tables.",A big multicolumn selection is needed for all the columns.,0.335703345899372,Create a large multi-column selection for all join columns in the given table.,"private Selection createMultiColSelection(Table table, int ri, List<Index> indexes, int selectionSize, List<Integer> joinColumnIndexes){
    Selection selection = new Selection(selectionSize);
    for (int i = 0; i < joinColumnIndexes.size(); i++) {
      int colIndex = joinColumnIndexes.get(i);
      Column<?> column = table.column(colIndex);
      Index index = indexes.get(i);
      selection.add(index.get(column.getIntInternal(ri)));
    }
    return selection;
  }","private Selection createMultiColSelection(Table table, int ri, List<Index> indexes, int selectionSize, List<Integer> joinColumnIndexes){
    Selection selection = new Selection(selectionSize);
    for (int i = 0; i < selectionSize; i++) {
      selection.set(i, createRow(table, ri, indexes, joinColumnIndexes));
      ri++;
    }
    return selection;   
 }","private Selection createMultiColSelection(Table table, int ri, List<Index> indexes, int selectionSize, List<Integer> joinColumnIndexes){
    Selection selection = new Selection(selectionSize);
    for (int i = 0; i < indexes.size(); i++) {
      Index index = indexes.get(i);
      Column<?> column = table.column(joinColumnIndexes.get(i));
      selection.add(index.get(column.getIntInternal(ri)));
    }
    return selection;   
 }","private Selection createMultiColSelection(Table table, int ri, List<Index> indexes, int selectionSize, List<Integer> joinColumnIndexes){
    Selection selection = new Selection(selectionSize);
    for (int i = 0; i < joinColumnIndexes.size(); i++) {
      int colIndex = joinColumnIndexes.get(i);
      Column<?> column = table.column(colIndex);
      Index index = indexes.get(i);
      selection.add(index.get(column.getIntInternal(ri)));
    }
    return selection;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5811921929176915,  0.47551996423490717,  0.5890046929176915,  0.5782135237878506,53.0,0.4818181818181818,45.0,0.45454545454545453,53.0,0.4818181818181818,50.0,0.47619047619047616,46.0,0.41818181818181815,0.0,0.0,12.0,0.10909090909090909,13.0,0.8666666666666667,2.0,0.14285714285714285,9.0,0.6428571428571429
570,jackson-databind,"public BeanPropertyMap withProperty(SettableBeanProperty newProp){
    String key = getPropertyName(newProp);
    for (int i = 1, end = _hashArea.length; i < end; i += 2) {
        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];
        if ((prop != null) && prop.getName().equals(key)) {
            return new BeanPropertyMap(this, newProp, i, _findFromOrdered(prop));
        }
    }
    final int slot = _hashCode(key);
    return new BeanPropertyMap(this, newProp, key, slot);
}",withProperty,com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java,/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java,"/**
     * Fluent copy method that creates a new instance that is a copy
     * of this instance except for one additional property that is
     * passed as the argument.
     * Note that method does not modify this instance but constructs
     * and returns a new one.
     */",307-329,"('withProperty', {'INSTRUCTION': {'covered': 50, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",110.0,27.0,Fluent copy method that creates a new instance that is a copy  of this instance except for one additional property that is  passed as the argument.,Creates a new instance representing a copy of the instance but for one additional property that is passed as a parameter to the method.,A fluent copy method creates a new instance that is a copy of this instance except for one property that is passed as the argument.,1.58590582873613,"Fluent copy method that creates a new instance that is a copy of that instance, except for an additional property that is passed as an argument.",Not Valid,"public BeanPropertyMap withProperty(SettableBeanProperty newProp){
        if (_size == 0) {
            return new BeanPropertyMap(newProp);
        }
        if (_size == 1) {
            return new BeanPropertyMap(_propsInOrder[0], newProp);
        }
        return new BeanPropertyMap(this, newProp);
    }",Not Valid,"public BeanPropertyMap withProperty(SettableBeanProperty newProp){
        if (_size == 0) {
            return new BeanPropertyMap(newProp);
        }
        if (_size == 1) {
            return new BeanPropertyMap(_propsInOrder[0], newProp);
        }
        return new BeanPropertyMap(this, newProp);
    }",Not Valid,NOT PASS,NOT PASS,Not Valid,None,  0.18915956756407604,  0.18915956756407604,None,None,None,75.0,0.6756756756756757,75.0,0.6756756756756757,None,None,53.0,0.9814814814814815,53.0,0.9814814814814815,None,None,13.0,0.48148148148148145,4.0,0.14814814814814814,4.0,0.14814814814814814
573,dcache,"public static void putLong(byte[] bytes, int offset, long value) throws IllegalArgumentException{
    if (bytes.length - offset < 8) {
        throw new IllegalArgumentException(""not enough space to store long"");
    }
    bytes[offset] = (byte) (value >> 56);
    bytes[offset + 1] = (byte) (value >> 48);
    bytes[offset + 2] = (byte) (value >> 40);
    bytes[offset + 3] = (byte) (value >> 32);
    bytes[offset + 4] = (byte) (value >> 24);
    bytes[offset + 5] = (byte) (value >> 16);
    bytes[offset + 6] = (byte) (value >> 8);
    bytes[offset + 7] = (byte) value;
}",putLong,org/dcache/util/Bytes.java,/modules/common/src/main/java/org/dcache/util/Bytes.java,"/**
     * Puts a big-endian representation of {@code value} into <code>bytes</code> staring from
     * <code>offset</code>.
     *
     * @param bytes
     * @param offset
     * @param value
     * @throws IllegalArgumentException there is no enough room for 8 bytes.
     */",27-51,"('putLong', {'INSTRUCTION': {'covered': 88, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",168.0,28.0,Puts a big-endian representation of {@code value} into <code>bytes</code> staring from  <code>offset</code>.,Add big-endian representation of value into bytes starting from offset.,Puts a big-endian representation of @code value into code>bytes/code>.,0.658991034431953,Places a big-endian representation of {@code value} in <code>bytes</code> from the <code>offset</code>.,"public static void putLong(byte[] bytes, int offset, long value) throws IllegalArgumentException{
        if (bytes == null) {
            throw new IllegalArgumentException(""bytes is null"");
        }
        if (offset < 0) {
            throw new IllegalArgumentException(""offset is negative"");
        }
        if (offset + 8 > bytes.length) {
            throw new IllegalArgumentException(""offset + 8 > bytes.length"");
        }
        bytes[offset] = (byte) (value >>> 56);
        bytes[offset + 1] = (byte) (value >>> 48);
        bytes[offset + 2] = (byte) (value >>> 40);
        bytes[offset + 3] = (byte) (value >>> 32);
        bytes[offset + 4] = (byte) (value >>> 24);
        bytes[offset + 5] = (byte) (value >>> 16);
        bytes[offset + 6] = (byte) (value >>> 8);
        bytes[offset + 7] = (byte) value;       
 }","public static void putLong(byte[] bytes, int offset, long value) throws IllegalArgumentException{
        if (bytes.length < offset + 8) {
            throw new IllegalArgumentException(""Not enough space in bytes array"");
        }
        bytes[offset] = (byte) (value >> 56);
        bytes[offset + 1] = (byte) (value >> 48);
        bytes[offset + 2] = (byte) (value >> 40);
        bytes[offset + 3] = (byte) (value >> 32);
        bytes[offset + 4] = (byte) (value >> 24);
        bytes[offset + 5] = (byte) (value >> 16);
        bytes[offset + 6] = (byte) (value >> 8);
        bytes[offset + 7] = (byte) value;       
 }","public static void putLong(byte[] bytes, int offset, long value) throws IllegalArgumentException{
        if (bytes == null) {
            throw new IllegalArgumentException(""bytes == null"");
        }
        if (offset < 0) {
            throw new IllegalArgumentException(""offset < 0"");
        }
        if (offset + 8 > bytes.length) {
            throw new IllegalArgumentException(""offset + 8 > bytes.length"");
        }
        bytes[offset] = (byte) (value >>> 56);
        bytes[offset + 1] = (byte) (value >>> 48);
        bytes[offset + 2] = (byte) (value >>> 40);
        bytes[offset + 3] = (byte) (value >>> 32);
        bytes[offset + 4] = (byte) (value >>> 24);
        bytes[offset + 5] = (byte) (value >>> 16);
        bytes[offset + 6] = (byte) (value >>> 8);
        bytes[offset + 7] = (byte) value;       
 }","public static void putLong(byte[] bytes, int offset, long value) throws IllegalArgumentException{
        if (bytes == null) {
            throw new IllegalArgumentException(""bytes == null"");
        }
        if (offset < 0) {
            throw new IllegalArgumentException(""offset < 0"");
        }
        if (offset + 8 > bytes.length) {
            throw new IllegalArgumentException(""offset + 8 > bytes.length"");
        }
        bytes[offset] = (byte) (value >>> 56);
        bytes[offset + 1] = (byte) (value >>> 48);
        bytes[offset + 2] = (byte) (value >>> 40);
        bytes[offset + 3] = (byte) (value >>> 32);
        bytes[offset + 4] = (byte) (value >>> 24);
        bytes[offset + 5] = (byte) (value >>> 16);
        bytes[offset + 6] = (byte) (value >>> 8);
        bytes[offset + 7] = (byte) value;       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.9010496987082218,  0.95537907192096,  0.9010496987082218,  0.9010496987082218,41.0,0.19902912621359223,3.0,0.01775147928994083,41.0,0.19902912621359223,41.0,0.19902912621359223,40.0,0.1941747572815534,2.0,0.009708737864077669,2.0,0.009708737864077669,7.0,0.5384615384615384,4.0,0.3076923076923077,6.0,0.46153846153846156
574,cdk,"long next(int[][] graph, int v, long[] current, long[] unique, long[] included, Suppressed suppressed){
    if (suppressed.contains(v))
        return current[v];
    long invariant = distribute(current[v]);
    int nUnique = 0;
    for (int w : graph[v]) {
        if (suppressed.contains(w))
            continue;
        long adjInv = current[w];
        int i = 0;
        while (i < nUnique && unique[i] != adjInv) {
            ++i;
        }
        included[i] = (i == nUnique) ? unique[nUnique++] = adjInv : rotate(included[i]);
        invariant ^= included[i];
    }
    return invariant;
}",next,org/openscience/cdk/hash/SuppressedAtomHashGenerator.java,/tool/hash/src/main/java/org/openscience/cdk/hash/SuppressedAtomHashGenerator.java,"/**
     * Determine the next value of the atom at index <i>v</i>. The value is
     * calculated by combining the current values of adjacent atoms. When a
     * duplicate value is found it can not be directly included and is
     * <i>rotated</i> the number of times it has previously been seen.
     *
     * @param graph      adjacency list representation of connected atoms
     * @param v          the atom to calculate the next value for
     * @param current    the current values
     * @param unique     buffer for working out which adjacent values are unique
     * @param included   buffer for storing the rotated <i>unique</i> value, this
     *                   value is <i>rotated</i> each time the same value is
     *                   found.
     * @param suppressed bit set indicates which atoms are 'suppressed'
     * @return the next value for <i>v</i>
     */",174-218,"('next', {'INSTRUCTION': {'covered': 82, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",155.0,17.0,Determine the next value of the atom at index <i>v</i>.,Computes and returns the subsequent value of the atom at index v.,The next value of the atom is determined by the index.,0.42398567281191,Determine the next value of the atom at index <i>v</i>.,Empty Method,"long next(int[][] graph, int v, long[] current, long[] unique, long[] included, Suppressed suppressed){
        long next = 0;
        int n = graph.length;
        for (int u = 0; u < n; u++) {
            if (u == v) continue;
            if (suppressed.isSuppressed(u)) continue;
            if (graph[v][u] == 0) continue;
            long value = current[u];
            if (value == Long.MAX_VALUE) continue;
            if (unique[u] == 0) {
                unique[u] = value;
            } else if (unique[u] != value) {
                unique[u] = 0;
            }
            next += unique[u];
        }
        for (int u = 0; u < n; u++) {
            if (u == v) continue;
            if (suppressed.isSuppressed(u)) continue;
            if (graph[v][u] == 0) continue;
            long value = current[u];
            if (value == Long.MAX_VALUE) continue;
            if (included[u] == 0) {
                included[u] = value;
            } else if (included[u] != value) {
                included[u] = 0;
            }
            next += included[u];
        }
        return next;
    }",Empty Method,Empty Method,Empty Method,NOT PASS,Empty Method,Empty Method,None,  0.5099029054524249,None,None,None,None,181.0,0.6678966789667896,None,None,None,None,270.0,0.996309963099631,None,None,None,None,5.0,0.38461538461538464,0.0,0.0,7.0,0.5833333333333334
575,glowstone,"public void sendItemChange(int slot, ItemStack item){
    if (invMonitor != null) {
        session.send(new SetWindowSlotMessage(invMonitor.getId(), slot, item));
    }
}",sendItemChange,net/glowstone/entity/GlowPlayer.java,/src/main/java/net/glowstone/entity/GlowPlayer.java,"/**
     * Sends a {@link SetWindowSlotMessage} to update the contents of an inventory slot.
     *
     * @param slot the slot ID
     * @param item the new contents
     */",3121-3131,"('sendItemChange', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,16.0,Sends a {@link SetWindowSlotMessage} to update the contents of an inventory slot.,Delivers a setWindowSlotMessage message to update the contents of an invetory set.,The contents of an inventory slot are updated by sending a @link SetWindowSlotMessage.,1.11979614170087,Sends a {@link SetWindowSlotMessage} to update the contents of an inventory location.," public void sendItemChange(int slot, ItemStack item){
        session.send(new SetWindowSlotMessage(invMonitor.getId(), slot, item));
    }"," public void sendItemChange(int slot, ItemStack item){
        session.send(new SetWindowSlotMessage(invMonitor.getId(), slot, item));
    }"," public void sendItemChange(int slot, ItemStack item){
        session.send(new SetWindowSlotMessage(invMonitor.getId(), slot, item));
    }"," public void sendItemChange(int slot, ItemStack item){
        session.send(new SetWindowSlotMessage(invMonitor.getId(), slot, item));
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.743470873425318,  0.743470873425318,  0.743470873425318,  0.743470873425318,8.0,0.2,8.0,0.2,8.0,0.2,8.0,0.2,0.0,0.0,0.0,0.0,0.0,0.0,5.0,0.38461538461538464,1.0,0.07692307692307693,13.0,0.9285714285714286
576,tablesaw,"public Row row(int rowIndex){
    Row row = new Row(Table.this);
    row.at(rowIndex);
    return row;
}",row,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,/** Returns a new Row object with its position set to the given zero-based row index. */,712-717,"('row', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,16.0,Returns a new Row object with its position set to the given zero-based row index.,"From a rowIndex given as input, return a new Row object based on that position.",A new Row object is returned with its position set to the zero-based row index.,0.268187710901695,Returns a new Row object whose position is set to the given zero baseline index.," public Row row(int rowIndex){
    return new Row(this, rowIndex);
  }","public Row row(int rowIndex){
    Row row = new Row(this);
    for (int i = 0; i < columnCount(); i++) {
      row.set(i, column(i).get(rowIndex));
    }
    return row;
  }"," public Row row(int rowIndex){
    return new Row(this, rowIndex);
  }"," public Row row(int rowIndex){
    return new Row(this, rowIndex);
  }",NOT PASS,NOT PASS,PASS,PASS,  0.33194866392944256,  0.48117735606868584,  0.33194866392944256,  0.33194866392944256,14.0,0.45161290322580644,30.0,0.5263157894736842,14.0,0.45161290322580644,14.0,0.45161290322580644,39.0,0.6842105263157895,0.0,0.0,0.0,0.0,14.0,0.875,5.0,0.3125,5.0,0.3125
577,liquibase,"public String escapeObjectName(String objectName, Class<? extends DatabaseObject> objectType){
    if ((quotingStrategy == ObjectQuotingStrategy.LEGACY) && hasMixedCase(objectName)) {
        return ""\"""" + objectName + ""\"""";
    } else if (objectType != null && LiquibaseColumn.class.isAssignableFrom(objectType)) {
        return (objectName != null && !objectName.isEmpty()) ? objectName.trim() : objectName;
    }
    return super.escapeObjectName(objectName, objectType);
}",escapeObjectName,liquibase/database/core/PostgresDatabase.java,/liquibase-core/src/main/java/liquibase/database/core/PostgresDatabase.java,"/**
     * This has special case logic to handle NOT quoting column names if they are
     * of type 'LiquibaseColumn' - columns in the DATABASECHANGELOG or DATABASECHANGELOGLOCK
     * tables.
     */",276-290,"('escapeObjectName', {'INSTRUCTION': {'covered': 39, 'missed': 1}, 'BRANCH': {'covered': 9, 'missed': 3}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,27.0,This has special case logic to handle NOT quoting column names if they are  of type 'LiquibaseColumn' - columns in the DATABASECHANGELOG or DATABASECHANGELOGLOCK  tables.,"Skips quoting the columns name of type ""LiquibaseColumn""",This has special case logic to not quote column names if they are in the DATABASECHANGELOG or DATABASECHANGELOGLOCK tables.,1.00962141269968,This has a special case logic to handle DO NOT quote column names if they are of type 'LiquibaseColumn' - columns in the DATABASECHANGELOG or DATABASECHANGELOGLOCK tables.," public String escapeObjectName(String objectName, Class<? extends DatabaseObject> objectType){
        if (objectType == Column.class) {
            if (objectName.startsWith(""LiquibaseColumn"")) {
                return objectName;
            }
        }
        return super.escapeObjectName(objectName, objectType);
    }"," public String escapeObjectName(String objectName, Class<? extends DatabaseObject> objectType){
        if (LiquibaseColumn.class.isAssignableFrom(objectType)) {
            return objectName;
        }
        return super.escapeObjectName(objectName, objectType);
    }"," public String escapeObjectName(String objectName, Class<? extends DatabaseObject> objectType){
        if (objectType == null) {
            return objectName;
        }
    
        if (objectType.equals(Table.class)) {
            if (objectName.equalsIgnoreCase(getDatabaseChangeLogTableName()) || objectName.equalsIgnoreCase(getDatabaseChangeLogLockTableName())) {
                return objectName;
            }
        }
    
        return super.escapeObjectName(objectName, objectType);
    }"," public String escapeObjectName(String objectName, Class<? extends DatabaseObject> objectType){
        if (objectType == Column.class) {
            if (objectName.startsWith(""liquibase_"")) {
                return objectName;
            }
        }
        return super.escapeObjectName(objectName, objectType);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.43427660333571116,  0.42942797324258525,  0.43427660333571116,  0.543762521454958,48.0,0.5217391304347826,48.0,0.5217391304347826,48.0,0.5217391304347826,41.0,0.44565217391304346,11.0,0.21153846153846154,1.0,0.019230769230769232,28.0,0.36363636363636365,22.0,0.8461538461538461,3.0,0.10714285714285714,8.0,0.3076923076923077
578,matsim-libs,"public void clusterInput(double radius, int minimumPoints){
    if (this.inputPoints.size() == 0) {
        log.warn(""DJCluster.clusterInput() called, but no points to cluster."");
    } else {
        if (!silent) {
            log.info(""Clustering input points. This may take a while."");
        }
        int clusterIndex = 0;
        int pointMultiplier = 1;
        int uPointCounter = 0;
        int cPointCounter = 0;
        /*
			 * Determine the extent of the QuadTree. 
			 */
        double xMin = Double.POSITIVE_INFINITY;
        double yMin = Double.POSITIVE_INFINITY;
        double xMax = Double.NEGATIVE_INFINITY;
        double yMax = Double.NEGATIVE_INFINITY;
        for (Node node : this.inputPoints) {
            Coord c = node.getCoord();
            /* TODO Remove if no NullPointerExceptions are thrown. */
            if (c == null) {
                log.warn(""Coord is null. Number of points in list: "" + inputPoints.size());
            } else {
                xMin = Math.min(xMin, c.getX());
                yMin = Math.min(yMin, c.getY());
                xMax = Math.max(xMax, c.getX());
                yMax = Math.max(yMax, c.getY());
            }
        }
        /*
			 * Build a new QuadTree, and place each point in the QuadTree as a ClusterActivity.
			 * The geographic coordinates of each point is used as the keys in the QuadTree.
			 * Initially all ClusterPoints will have a NULL reference to its DigicoreCluster. An 
			 * ArrayList of Points is also kept as iterator for unclustered points.
			 */
        if (!silent) {
            log.info(""Place points in QuadTree."");
        }
        quadTree = new QuadTree<ClusterActivity>(xMin - 1, yMin - 1, xMax + 1, yMax + 1);
        List<ClusterActivity> listOfPoints = new ArrayList<ClusterActivity>();
        for (int i = 0; i < this.inputPoints.size(); i++) {
            double x = inputPoints.get(i).getCoord().getX();
            double y = inputPoints.get(i).getCoord().getY();
            ClusterActivity cp = new ClusterActivity(Id.create(i, Coord.class), inputPoints.get(i), null);
            quadTree.put(x, y, cp);
            listOfPoints.add(cp);
        }
        if (!silent) {
            log.info(""Done placing activities."");
        }
        int pointCounter = 0;
        while (pointCounter < listOfPoints.size()) {
            // Get next point.
            ClusterActivity p = listOfPoints.get(pointCounter);
            if (p.getCluster() == null) {
                // Compute the density-based neighbourhood, N(p), of the point p
                Collection<ClusterActivity> neighbourhood = quadTree.getDisk(p.getCoord().getX(), p.getCoord().getY(), radius);
                List<ClusterActivity> uN = new ArrayList<ClusterActivity>(neighbourhood.size());
                List<ClusterActivity> cN = new ArrayList<ClusterActivity>(neighbourhood.size());
                for (ClusterActivity cp : neighbourhood) {
                    if (cp.getCluster() == null) {
                        uN.add(cp);
                    } else {
                        cN.add(cp);
                    }
                }
                if (neighbourhood.size() < minimumPoints) {
                    /* Point is considered to be noise.
						 * FIXME Not quite true... it may be incorporated into
						 * another cluster later! (JWJ - Mar '14)
						 */
                    lostPoints.put(p.getId(), p);
                    uPointCounter++;
                } else if (cN.size() > 0) {
                    /* 
						 * Merge all the clusters. Use the DigicoreCluster with the smallest clusterId
						 * value as the remaining DigicoreCluster.
						 */
                    List<Cluster> localClusters = new ArrayList<Cluster>();
                    Cluster smallestCluster = cN.get(0).getCluster();
                    for (int i = 1; i < cN.size(); i++) {
                        if (Integer.parseInt(cN.get(i).getCluster().getId().toString()) < Integer.parseInt(smallestCluster.getId().toString())) {
                            smallestCluster = cN.get(i).getCluster();
                        }
                        if (!localClusters.contains(cN.get(i).getCluster())) {
                            localClusters.add(cN.get(i).getCluster());
                        }
                    }
                    for (Cluster DigicoreCluster : localClusters) {
                        if (!DigicoreCluster.equals(smallestCluster)) {
                            List<ClusterActivity> thisClusterList = DigicoreCluster.getPoints();
                            for (int j = 0; j < thisClusterList.size(); j++) {
                                // Change the DigicoreCluster reference of the ClusterActivity.
                                thisClusterList.get(j).setCluster(smallestCluster);
                                // Add the ClusterActivity to the new DigicoreCluster.
                                smallestCluster.getPoints().add(thisClusterList.get(j));
                                // Remove the ClusterActivity from old DigicoreCluster.
                                /* 
									 * 20091009 - I've commented this out... this seems
									 * both dangerous and unnecessary. 
									 */
                                // DigicoreCluster.getPoints().remove(thisClusterList.get(j));
                            }
                        }
                    }
                    // Add unclustered points in the neighborhood.
                    for (ClusterActivity cp : uN) {
                        smallestCluster.getPoints().add(cp);
                        cp.setCluster(smallestCluster);
                        cPointCounter++;
                        if (lostPoints.containsKey(cp.getId())) {
                            lostPoints.remove(cp.getId());
                            uPointCounter--;
                        }
                    }
                } else {
                    // Create new DigicoreCluster and add all the points.
                    Cluster newCluster = new Cluster(Id.create(clusterIndex, Cluster.class));
                    clusterIndex++;
                    for (ClusterActivity cp : uN) {
                        cp.setCluster(newCluster);
                        newCluster.getPoints().add(cp);
                        cPointCounter++;
                        if (lostPoints.containsKey(cp.getId())) {
                            lostPoints.remove(cp.getId());
                            uPointCounter--;
                        }
                    }
                }
            }
            pointCounter++;
            // Report progress
            if (!silent) {
                if (pointCounter == pointMultiplier) {
                    log.info(""   Points clustered: "" + pointCounter);
                    pointMultiplier = (int) Math.max(pointCounter, pointMultiplier) * 2;
                }
            }
        }
        if (!silent) {
            log.info(""   Points clustered: "" + pointCounter + "" (Done)"");
            int sum = cPointCounter + uPointCounter;
            log.info(""Sum should add up: "" + cPointCounter + "" (clustered) + "" + uPointCounter + "" (unclustered) = "" + sum);
            /* Code added for Joubert & Meintjes paper (2014). */
            log.info(""Unclustered points: "");
            for (ClusterActivity ca : lostPoints.values()) {
                log.info(String.format(""   %.6f,%.6f"", ca.getCoord().getX(), ca.getCoord().getY()));
            }
            log.info(""New way of unclustered points:"");
            log.info(""   Number: "" + lostPoints.size());
        }
        /* 
			 * Build the DigicoreCluster list. Once built, I rename the clusterId field so as to
			 * start at '0', and increment accordingly. This allows me to directly use
			 * the clusterId field as 'row' and 'column' reference in the 2D matrices
			 * when determining adjacency in Social Network Analysis.
			 */
        if (!silent) {
            log.info(""Building the DigicoreCluster list (2 steps)"");
        }
        Map<Cluster, List<ClusterActivity>> clusterMap = new HashMap<Cluster, List<ClusterActivity>>();
        if (!silent) {
            log.info(""Step 1 of 2:"");
            log.info(""Number of ClusterPoints to process: "" + listOfPoints.size());
        }
        int cpCounter = 0;
        int cpMultiplier = 1;
        for (ClusterActivity ca : listOfPoints) {
            Cluster theCluster = ca.getCluster();
            if (theCluster != null) {
                // Removed 7/12/2011 (JWJ): Seems unnecessary computation.
                // theCluster.setCenterOfGravity();
                if (!clusterMap.containsKey(theCluster)) {
                    List<ClusterActivity> newList = new ArrayList<ClusterActivity>();
                    clusterMap.put(theCluster, newList);
                }
                clusterMap.get(theCluster).add(ca);
            }
            if (!silent) {
                if (++cpCounter == cpMultiplier) {
                    log.info(""   ClusterPoints processed: "" + cpCounter + "" ("" + String.format(""%3.2f"", ((double) cpCounter / (double) listOfPoints.size()) * 100) + ""%)"");
                    cpMultiplier *= 2;
                }
            }
        }
        if (!silent) {
            log.info(""   ClusterPoints processed: "" + cpCounter + "" (Done)"");
        }
        if (!silent) {
            log.info(""Step 2 of 2:"");
            log.info(""Number of clusters to process: "" + clusterMap.keySet().size());
        }
        int clusterCounter = 0;
        int clusterMultiplier = 1;
        int clusterNumber = 0;
        for (Map.Entry<Cluster, List<ClusterActivity>> e : clusterMap.entrySet()) {
            Cluster digicoreCluster = e.getKey();
            List<ClusterActivity> listOfClusterPoints = e.getValue();
            if (listOfClusterPoints.size() >= minimumPoints) {
                digicoreCluster.setClusterId(Id.create(clusterNumber++, Cluster.class));
                clusterNumber++;
                digicoreCluster.setCenterOfGravity();
                clusterList.add(digicoreCluster);
            } else if (!silent) {
                log.warn("" ... why do we HAVE a cluster with too few points?..."");
            }
            if (!silent) {
                if (++clusterCounter == clusterMultiplier) {
                    log.info(""   Clusters processed: "" + clusterCounter + "" ("" + String.format(""%3.2f"", ((double) clusterCounter / (double) clusterMap.keySet().size()) * 100) + ""%)"");
                    clusterMultiplier *= 2;
                }
            }
        }
        if (!silent) {
            log.info(""   Clusters processed: "" + clusterCounter + "" (Done)"");
            log.info(""DigicoreCluster list built."");
        }
    }
    // lost list must be made up of clusters without Id.
}",clusterInput,org/matsim/core/network/algorithms/intersectionSimplifier/DensityCluster.java,/matsim/src/main/java/org/matsim/core/network/algorithms/intersectionSimplifier/DensityCluster.java,"/**
	 * Building an <code>ArrayList</code> of <code>DigicoreCluster</code>s. The DJ-Clustering
	 * procedure of Zhou <i>et al</i> (2004) is followed. If there are no points to cluster, a
	 * warning message is logged, and the procedure bypassed.
	 */",97-341,"('clusterInput', {'INSTRUCTION': {'covered': 626, 'missed': 62}, 'BRANCH': {'covered': 72, 'missed': 12}, 'LINE': {'covered': 133, 'missed': 13}, 'COMPLEXITY': {'covered': 33, 'missed': 10}, 'METHOD': {'covered': 1, 'missed': 0}})",1543.0,19.0,Building an <code>ArrayList</code> of <code>DigicoreCluster</code>s.,Constructs an ArrayList of DigicoreCluster if present; otherwise log a warning message.,A code ofDigicoreCluster is built with code>ArrayList/code>.,0.822797363507703,Creation of an <code>ArrayList</code> of <code>DigicoreCluster</code>s.,"public void clusterInput(double radius, int minimumPoints){
	 		this.quadTree = new QuadTree<ClusterActivity>(0.0, 0.0, 1.0, 1.0);
 		for(Node node : inputPoints){
 			ClusterActivity activity = new ClusterActivity(node.getId(), node.getCoord());
 			this.quadTree.put(activity.getX(), activity.getY(), activity);
 		}
 		
 		for(ClusterActivity activity : this.quadTree.getAll()){
 			if(activity.getCluster() == null){
 				Cluster cluster = new Cluster(activity);
 				clusterList.add(cluster);
 				cluster.expand(quadTree, radius, minimumPoints);
 			}
 		}
 	}","public void clusterInput(double radius, int minimumPoints){
	 		if(!silent){
 			log.info(""Clustering input points..."");
 		}
 		this.quadTree = new QuadTree<ClusterActivity>(0.0, 0.0, 1.0, 1.0);
 		for(Node node : inputPoints){
 			ClusterActivity activity = new ClusterActivity(node.getId(), node.getCoord());
 			quadTree.put(activity.getX(), activity.getY(), activity);
 		}
 		if(!silent){
 			log.info(""Clustering input points... done."");
 		}
 		cluster(radius, minimumPoints);
 	}","public void clusterInput(double radius, int minimumPoints){
	 		if(!silent){
 			log.info(""Clustering input points..."");
 		}
 		
 		/* Create the quadtree. */
 		quadTree = new QuadTree<ClusterActivity>(new Coord(0,0), 100000, 100000);
 		
 		/* Add all input points to the quadtree. */
 		for(Node node : inputPoints){
 			ClusterActivity ca = new ClusterActivity(node.getId(), node.getCoord());
 			quadTree.put(ca.getCoord(), ca);
 		}
 		
 		/* Create the clusters. */
 		for(ClusterActivity ca : quadTree.values()){
 			if(ca.getCluster() == null){
 				Cluster cluster = new Cluster(ca);
 				clusterList.add(cluster);
 				
 				/* Find the neighborhood. */
 				Collection<ClusterActivity> neighborhood = quadTree.getDisk(ca.getCoord(), radius);
 				
 				/* If the neighborhood is large enough, add the neighborhood to the cluster. */
 				if(neighborhood.size() >= minimumPoints){
 					for(ClusterActivity ca2 : neighborhood){
 						if(ca2.getCluster() == null){
 							cluster.add(ca2);
 						}
 					}
 				}
 			}
 		}
 		
 		/* Remove the points that are not in a cluster. */
 		for(ClusterActivity ca : quadTree.values()){
 			if(ca.getCluster() == null){
 				lostPoints.put(ca.getId(), ca);
 			}
 		}		
 }",Not Valid,NOT PASS,NOT PASS,Not Valid,NOT PASS,  0.10795390087061059,  0.11169162946850249,None,  0.1476932341006515,1441.0,0.9332901554404145,1449.0,0.9384715025906736,None,None,1375.0,0.8905440414507773,56.0,0.4148148148148148,None,None,129.0,0.5682819383259912,10.0,0.7692307692307693,2.0,0.2857142857142857,7.0,0.875
579,dcache,"public void buildTransition(StatePath ourPath, StatePath newComponentPath, StateComponent newComponent, StateTransition transition) throws MetricStatePathException{
    String childName = newComponentPath.getFirstElement();
    StateChangeSet changeSet = transition.getOrCreateChangeSet(ourPath);
    if (this.isMortal() && newComponent.isMortal()) {
        Date newComponentExpiryDate = newComponent.getExpiryDate();
        changeSet.recordNewWhenIShouldExpireDate(newComponentExpiryDate);
    }
    if (newComponent.isImmortal()) {
        changeSet.recordChildIsImmortal();
    }
    changeSet.ensureChildNotRemoved(childName);
    if (newComponentPath.isSimplePath()) {
        if (_children.containsKey(childName)) {
            changeSet.recordUpdatedChild(childName, newComponent);
        } else {
            changeSet.recordNewChild(childName, newComponent);
        }
        if (newComponent instanceof StateComposite) {
            StateComposite newComposite = (StateComposite) newComponent;
            newComposite._metadataRef = getChildMetadata(childName);
        }
        return;
    }
    StateComponent child = _children.get(childName);
    if (child == null) {
        child = changeSet.getNewChildValue(childName);
        if (child == null) {
            child = new StateComposite(getChildMetadata(childName), DEFAULT_LIFETIME);
            changeSet.recordNewChild(childName, child);
        }
    }
    changeSet.recordChildItr(childName);
    child.buildTransition(buildChildPath(ourPath, childName), newComponentPath.childPath(), newComponent, transition);
}",buildTransition,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,"/**
     * Update a StateTransition object so a new StateComponent will be added to dCache's state.  The
     * changes are recorded in StateTransition so they can be applied later.
     *
     * @param ourPath          the StatePath to this StateComposite.
     * @param newComponentPath the StatePath to this StateComponent, relative to this
     *                         StateComposition
     * @param newComponent     the StateComponent to add.
     * @param transition       the StateTransition in which we will record these changes
     */",485-557,"('buildTransition', {'INSTRUCTION': {'covered': 96, 'missed': 0}, 'BRANCH': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 25, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",249.0,16.0,Update a StateTransition object so a new StateComponent will be added to dCache's state.,Stores the changes of an update StateTransition operation in the object transition.,A new StateComponent will be added to dCache's state if a StateTransition object is updated.,0.720138607788848,Update a StateTransition object so that a new StateComponent is added to the dCache state.,Not Valid,Not Valid," public void buildTransition(StatePath ourPath, StatePath newComponentPath, StateComponent newComponent, StateTransition transition) throws MetricStatePathException{
        StatePath childPath = buildChildPath(ourPath, newComponentPath.getLastComponent());
        StateComponent child = _children.get(newComponentPath.getLastComponent());
    
        if (child == null) {
            addComponent(newComponentPath.getLastComponent(), newComponent);
        } else {
            child.buildTransition(childPath, newComponentPath, newComponent, transition);
        }
    }",Not Valid,Not Valid,Not Valid,Not Valid,NOT PASS,None,None,None,  0.20318303857368403,None,None,None,None,None,None,184.0,0.736,None,None,None,None,83.0,0.9880952380952381,14.0,0.9333333333333333,5.0,0.3125,13.0,0.8125
580,cdk,"private double calculateMassT(List<IIsotope> isoToCond_new, int[] value_In){
    double result = 0;
    for (int i = 0; i < isoToCond_new.size(); i++) {
        if (value_In[i] != 0) {
            result += isoToCond_new.get(i).getExactMass() * value_In[i];
        }
    }
    return result;
}",calculateMassT,org/openscience/cdk/formula/MassToFormulaTool.java,/legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java,"/**
     * Calculate the mass total given the elements and their respective occurrences.
     *
     * @param elemToCond_new  The IIsotope to calculate
     * @param value_In        Array matrix with occurrences
     * @return                The sum total
     */",521-536,"('calculateMassT', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,12.0,Calculate the mass total given the elements and their respective occurrences.,Computes the total mass from the elements and their related occurences.,The mass total is calculated by taking the elements and their occurrences.,0.707994339436549,Calculate the total mass according to the elements and their respective occurrences.,"private double calculateMassT(List<IIsotope> isoToCond_new, int[] value_In){
        double massT = 0;
        for (int i = 0; i < isoToCond_new.size(); i++) {
            if (value_In[i] != 0) {
                massT += isoToCond_new.get(i).getExactMass() * value_In[i];
            }
        }
        return massT;
    }","private double calculateMassT(List<IIsotope> isoToCond_new, int[] value_In){
        double massT = 0;
        for (int i = 0; i < isoToCond_new.size(); i++) {
            if (value_In[i] != 0) {
                massT += isoToCond_new.get(i).getExactMass() * value_In[i];
            }
        }
        return massT;
    }","private double calculateMassT(List<IIsotope> isoToCond_new, int[] value_In){
        double massT = 0;
        for (int i = 0; i < isoToCond_new.size(); i++) {
            if (value_In[i] != 0) {
                for (int j = 0; j < value_In[i]; j++)
                    massT += isoToCond_new.get(i).getExactMass();
            }
        }
        return massT;
    }","private double calculateMassT(List<IIsotope> isoToCond_new, int[] value_In){
        double massT = 0;
        for (int i = 0; i < isoToCond_new.size(); i++) {
            if (value_In[i] != 0) {
                for (int j = 0; j < value_In[i]; j++)
                    massT += isoToCond_new.get(i).getExactMass();
            }
        }
        return massT;
    }",PASS,PASS,PASS,PASS,  0.9498611843756356,  0.9498611843756356,  0.8289046036356671,  0.8289046036356671,3.0,0.04,3.0,0.04,25.0,0.28735632183908044,25.0,0.28735632183908044,0.0,0.0,22.0,0.25287356321839083,22.0,0.25287356321839083,6.0,0.5,3.0,0.23076923076923078,7.0,0.5384615384615384
581,mybatis-3,"protected void addIfMatching(Test test, String fqn){
    try {
        String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');
        ClassLoader loader = getClassLoader();
        if (log.isDebugEnabled()) {
            log.debug(""Checking to see if class "" + externalName + "" matches criteria ["" + test + ""]"");
        }
        Class<?> type = loader.loadClass(externalName);
        if (test.matches(type)) {
            matches.add((Class<T>) type);
        }
    } catch (Throwable t) {
        log.warn(""Could not examine class '"" + fqn + ""'"" + "" due to a "" + t.getClass().getName() + "" with message: "" + t.getMessage());
    }
}",addIfMatching,org/apache/ibatis/io/ResolverUtil.java,/src/main/java/org/apache/ibatis/io/ResolverUtil.java,"/**
   * Add the class designated by the fully qualified class name provided to the set of
   * resolved classes if and only if it is approved by the Test supplied.
   *
   * @param test the test used to determine if the class matches
   * @param fqn the fully qualified name of a class
   */",274-298,"('addIfMatching', {'INSTRUCTION': {'covered': 53, 'missed': 16}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 11, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",146.0,29.0,Add the class designated by the fully qualified class name provided to the set of  resolved classes if and only if it is approved by the Test supplied.,Adds the class to the matches object using its fully qualified name iff has been approved by the Test supplied.,"If the class is approved by the test, add it to the set of resolved classes.",0.353967886663301,Add the class designated by the supplied display class name to the set of resolved classes if and only if it is approved by the supplied test.," protected void addIfMatching(Test test, String fqn){
    try {
      Class<?> clazz = getClassLoader().loadClass(fqn);
      if (test.matches(clazz)) {
        matches.add(clazz);
      }
    } catch (ClassNotFoundException cnfe) {
      log.error(""Could not load class: "" + fqn, cnfe);
    }
  }"," protected void addIfMatching(Test test, String fqn){
    try {
      Class<?> clazz = getClassLoader().loadClass(fqn);
      if (test.matches(clazz)) {
        matches.add(clazz);
      }
    } catch (ClassNotFoundException cnfe) {
      log.error(""Could not load class: "" + fqn, cnfe);
    }
  }","protected void addIfMatching(Test test, String fqn){
    try {
      Class<?> clazz = getClassLoader().loadClass(fqn.substring(0, fqn.length() - 6));
      if (test.matches(clazz)) {
        matches.add(clazz);
      }
    } catch (ClassNotFoundException cnfe) {
      log.error(""Could not load class: "" + fqn, cnfe);
    }
  }"," protected void addIfMatching(Test test, String fqn){
    try {
      Class<?> clazz = getClassLoader().loadClass(fqn.replace("".class"", """").replace('/', '.'));
      if (test.matches(clazz)) {
        matches.add(clazz);
      }
    } catch (ClassNotFoundException e) {
      log.error(""Could not load class: "" + fqn, e);
    }
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.26014477244425993,  0.26014477244425993,  0.3320357622439526,  0.35322212313666673,94.0,0.6394557823129252,94.0,0.6394557823129252,91.0,0.6190476190476191,91.0,0.6190476190476191,0.0,0.0,16.0,0.19753086419753085,13.0,0.1625,19.0,0.6551724137931034,5.0,0.1724137931034483,20.0,0.6896551724137931
582,cdk,"public Object clone() throws CloneNotSupportedException{
    ChemObject clone = (ChemObject) super.clone();
    clone.flags = getFlagValue().shortValue();
    if (properties != null)
        clone.properties = new HashMap<Object, Object>(getProperties());
    clone.chemObjectListeners = null;
    return clone;
}",clone,org/openscience/cdk/ChemObject.java,/base/data/src/main/java/org/openscience/cdk/ChemObject.java,"/**
     *  Clones this <code>IChemObject</code>. It clones the identifier, flags,
     *  properties and pointer vectors. The ChemObjectListeners are not cloned, and
     *  neither is the content of the pointer vectors.
     *
     *@return    The cloned object
     */",301-323,"('clone', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,10.0,Clones this <code>IChemObject</code>.,"Clones the identifiers, flags, properties and point vectors while discarding the ChemObjectListeners.",This is a clone of this code>IChemObject/code>.,0.545224491856714,Clone this <code>IChemObject</code>.," public Object clone() throws CloneNotSupportedException{
        IChemObject clone = (IChemObject) super.clone();
        if (chemObjectListeners != null) {
            clone.chemObjectListeners = new ArrayList<IChemObjectListener>(chemObjectListeners);
        }
        if (properties != null) {
            clone.properties = new LinkedHashMap<>(properties);
        }
        return clone;
    }","public Object clone() throws CloneNotSupportedException{
        IChemObject newObject = (IChemObject) super.clone();
        newObject.chemObjectListeners = null;
        newObject.properties = null;
        newObject.identifiers = null;
        newObject.flags = null;
        newObject.point2D = null;
        newObject.point3D = null;
        return newObject;
    }"," public Object clone() throws CloneNotSupportedException{
        IChemObject newObject = (IChemObject) super.clone();
        newObject.properties = properties == null ? null : new LinkedHashMap<>(properties);
        newObject.chemObjectListeners = chemObjectListeners == null ? null : new LinkedHashSet<>(chemObjectListeners);
        return newObject;
    }"," public Object clone() throws CloneNotSupportedException{
        IChemObject newObject = (IChemObject) super.clone();
        if (chemObjectListeners != null) {
            newObject.chemObjectListeners = new ArrayList<IChemObjectListener>(chemObjectListeners);
        }
        if (properties != null) {
            newObject.properties = new LinkedHashMap<Object, Object>(properties);
        }
        return newObject;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4970879700324017,  0.35582600168414447,  0.4730322681585271,  0.37336757815246047,31.0,0.4696969696969697,33.0,0.5,32.0,0.463768115942029,38.0,0.5757575757575758,34.0,0.5151515151515151,7.0,0.10144927536231885,31.0,0.4696969696969697,11.0,0.8461538461538461,1.0,0.25,6.0,0.75
583,glowstone,"public boolean readBooleanNegated(@NonNls String key, Consumer<? super Boolean> consumer){
    return readTag(key, ByteTag.class, byteVal -> consumer.accept(byteVal == 0));
}",readBooleanNegated,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to a byte subtag if it is present, converting it to boolean and
     * negating it first.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */",524-536,"('readBooleanNegated', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,22.0,"Applies the given function to a byte subtag if it is present, converting it to boolean and  negating it first.",Returns the negation of a byte subtag that have been processed according to the function given as input.,"If the function is present, convert it to a byte subtag and then negating it.",0.284090532576447,"Applies the given function to a byte subtag if it is present, converting it to Boolean and denying it first.","public boolean readBooleanNegated(@NonNls String key, Consumer<? super Boolean> consumer){
        return readTag(key, ByteTag.class, byteVal -> consumer.accept(byteVal == 0));
    }","public boolean readBooleanNegated(@NonNls String key, Consumer<? super Boolean> consumer){
        return readTag(key, ByteTag.class, byteVal -> consumer.accept(byteVal == 0));
    }","public boolean readBooleanNegated(@NonNls String key, Consumer<? super Boolean> consumer){
        return readTag(key, ByteTag.class, byteVal -> consumer.accept(byteVal == 0));
    }","public boolean readBooleanNegated(@NonNls String key, Consumer<? super Boolean> consumer){
        return readTag(key, ByteTag.class, byteVal -> consumer.accept(byteVal == 0));
    }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,15.0,0.7142857142857143,2.0,0.09523809523809523,15.0,0.7142857142857143
584,cactoos,"private int copyPartial(final byte[] buffer, final byte[] response, final int num, final int read){
    final int result;
    if (num > 0) {
        System.arraycopy(response, read, response, 0, this.count - read);
        System.arraycopy(buffer, 0, response, this.count - read, read);
        result = this.count;
    } else {
        System.arraycopy(buffer, 0, response, 0, read);
        result = read;
    }
    return result;
}",copyPartial,org/cactoos/io/TailOf.java,/src/main/java/org/cactoos/io/TailOf.java,"/**
     * Copy buffer to response for read count smaller then buffer size.
     * @param buffer The buffer array
     * @param response The response array
     * @param num Number of bytes in response array from previous read
     * @param read Number of bytes read in the buffer
     * @return New count of bytes in the response array
     * @checkstyle ParameterNumberCheck (3 lines)
     */",117-140,"('copyPartial', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",107.0,12.0,Copy buffer to response for read count smaller then buffer size.,Copies buffer to response for reading count having a smaller size than the buffer size.,The buffer size should be copied to the response for read count.,0.232393394174537,Copy the buffer into the response for a read number that is less than the size of the buffer.,"private int copyPartial(final byte[] buffer, final byte[] response, final int num, final int read){
        System.arraycopy(
            buffer, 0, response, num, read
        );
        return num + read;
    }","private int copyPartial(final byte[] buffer, final byte[] response, final int num, final int read){
        System.arraycopy(
            buffer, 0, response, num, read
        );
        return num + read;
    }","private int copyPartial(final byte[] buffer, final byte[] response, final int num, final int read){
        System.arraycopy(
            buffer, 0, response, num, read
        );
        return num + read;
    }","private int copyPartial(final byte[] buffer, final byte[] response, final int num, final int read){
        System.arraycopy(
            buffer, 0, response, num, read
        );
        return num + read;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.34941596362629374,  0.34941596362629374,  0.34941596362629374,  0.34941596362629374,65.0,0.6018518518518519,65.0,0.6018518518518519,65.0,0.6018518518518519,65.0,0.6018518518518519,0.0,0.0,0.0,0.0,0.0,0.0,7.0,0.4375,14.0,0.7,11.0,0.8461538461538461
585,weblogic-kubernetes-operator,"CallerDetails inferCaller(){
    CallerDetails details = new CallerDetails();
    Throwable t = new Throwable();
    StackTraceElement[] stack = t.getStackTrace();
    int i = 0;
    while (i < stack.length) {
        StackTraceElement frame = stack[i];
        String cname = frame.getClassName();
        if (!cname.equals(CLASS)) {
            details.clazz = cname;
            details.method = frame.getMethodName();
            break;
        }
        i++;
    }
    return details;
}",inferCaller,oracle/kubernetes/operator/logging/LoggingFacade.java,/operator/src/main/java/oracle/kubernetes/operator/logging/LoggingFacade.java,"/**
   * Obtains caller details, class name and method, to be provided to the actual Logger. This code
   * is adapted from ODLLogRecord, which should yield consistency in reporting using PlatformLogger
   * versus a raw (ODL) Logger. JDK Logger does something similar but utilizes native methods
   * directly.
   */",624-649,"('inferCaller', {'INSTRUCTION': {'covered': 40, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",101.0,17.0,"Obtains caller details, class name and method, to be provided to the actual Logger.","Fetches all the caller details, class name, and method to be fed to the actual logger.","The actual Logger will get caller details, class name and method.",0.773724788143001,"Gets the caller details, class name, and method to provide to the actual recorder.","CallerDetails inferCaller(){
    StackTraceElement[] stack = new Throwable().getStackTrace();
    StackTraceElement caller = stack[2];
    return new CallerDetails(caller.getClassName(), caller.getMethodName());
  }","CallerDetails inferCaller(){
    StackTraceElement[] stack = new Throwable().getStackTrace();
    StackTraceElement caller = stack[2];
    return new CallerDetails(caller.getClassName(), caller.getMethodName());
  }","CallerDetails inferCaller(){
    StackTraceElement[] stack = new Throwable().getStackTrace();
    StackTraceElement caller = stack[2];
    return new CallerDetails(caller.getClassName(), caller.getMethodName());
  }","CallerDetails inferCaller(){
    StackTraceElement[] stack = new Throwable().getStackTrace();
    StackTraceElement caller = stack[2];
    return new CallerDetails(caller.getClassName(), caller.getMethodName());
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.1800991432134931,  0.1800991432134931,  0.1800991432134931,  0.1800991432134931,70.0,0.6862745098039216,70.0,0.6862745098039216,70.0,0.6862745098039216,70.0,0.6862745098039216,0.0,0.0,0.0,0.0,0.0,0.0,7.0,0.4117647058823529,7.0,0.4666666666666667,13.0,0.8666666666666667
586,acs-aem-commons,"public static Session useBestWrapper(final Session session){
    if (session instanceof JackrabbitWrapper || session instanceof JcrWrapper) {
        return session;
    } else if (session instanceof JackrabbitSession) {
        return new JackrabbitWrapper((JackrabbitSession) session);
    } else if (session != null) {
        return new JcrWrapper(session);
    }
    return null;
}",useBestWrapper,com/adobe/acs/commons/wrap/impl/SessionLogoutGuardFactory.java,/bundle/src/main/java/com/adobe/acs/commons/wrap/impl/SessionLogoutGuardFactory.java,"/**
     * Return the best wrapped version of the provided session.
     *
     * @param session the session to wrap
     * @return a wrapped session
     */",82-97,"('useBestWrapper', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",64.0,10.0,Return the best wrapped version of the provided session.,"Given a session object as input, it returns the best-wrapped version of such object.",The best wrapped version of the session should be returned.,0.811648243329184,Return the best encapsulated version of the provided session.," public static Session useBestWrapper(final Session session){
        if(session instanceof JackrabbitSession){
            return new JackrabbitWrapper((JackrabbitSession)session);
        }
        return new JcrWrapper(session);
    }"," public static Session useBestWrapper(final Session session){
        if(session instanceof JackrabbitSession){
            return new JackrabbitWrapper((JackrabbitSession)session);
        }
        return new JcrWrapper(session);
    }"," public static Session useBestWrapper(final Session session){
        if(session instanceof JackrabbitSession){
            return new JackrabbitWrapper((JackrabbitSession)session);
        }
        return new JcrWrapper(session);
    }       "," public static Session useBestWrapper(final Session session){
        if (session instanceof JackrabbitSession) {
            return new JackrabbitWrapper((JackrabbitSession) session);
        } else {
            return new JcrWrapper(session);
        }
    }       ",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.519439257797432,  0.519439257797432,  0.5447751196157355,  0.519439257797432,28.0,0.4307692307692308,28.0,0.4307692307692308,25.0,0.38461538461538464,28.0,0.4307692307692308,0.0,0.0,3.0,0.075,0.0,0.0,13.0,0.8666666666666667,1.0,0.1,6.0,0.5454545454545454
587,zxing,"private void extractParameters(ResultPoint[] bullsEyeCorners) throws NotFoundException{
    if (!isValid(bullsEyeCorners[0]) || !isValid(bullsEyeCorners[1]) || !isValid(bullsEyeCorners[2]) || !isValid(bullsEyeCorners[3])) {
        throw NotFoundException.getNotFoundInstance();
    }
    int length = 2 * nbCenterLayers;
    int[] sides = { sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length), sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length), sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length), sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) };
    shift = getRotation(sides, length);
    long parameterData = 0;
    for (int i = 0; i < 4; i++) {
        int side = sides[(shift + i) % 4];
        if (compact) {
            parameterData <<= 7;
            parameterData += (side >> 1) & 0x7F;
        } else {
            parameterData <<= 10;
            parameterData += ((side >> 2) & (0x1f << 5)) + ((side >> 1) & 0x1F);
        }
    }
    int correctedData = getCorrectedParameterData(parameterData, compact);
    if (compact) {
        nbLayers = (correctedData >> 6) + 1;
        nbDataBlocks = (correctedData & 0x3F) + 1;
    } else {
        nbLayers = (correctedData >> 11) + 1;
        nbDataBlocks = (correctedData & 0x7FF) + 1;
    }
}",extractParameters,com/google/zxing/aztec/detector/Detector.java,/core/src/main/java/com/google/zxing/aztec/detector/Detector.java,"/**
   * Extracts the number of data layers and data blocks from the layer around the bull's eye.
   *
   * @param bullsEyeCorners the array of bull's eye corners
   * @throws NotFoundException in case of too many errors or invalid parameters
   */",100-154,"('extractParameters', {'INSTRUCTION': {'covered': 177, 'missed': 2}, 'BRANCH': {'covered': 10, 'missed': 4}, 'LINE': {'covered': 24, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",295.0,18.0,Extracts the number of data layers and data blocks from the layer around the bull's eye.,It Retrieves the number of data layers and blocks from the layer featuring the bull's eye.,The data layers and data blocks are taken from the bull's eye.,0.313825970076292,Gets the number of data layers and data blocks from the layer around the bull's eye.,"private void extractParameters(ResultPoint[] bullsEyeCorners) throws NotFoundException{
    // 1. Get the number of layers and data blocks from the bull's eye
    int[] cornerBits = new int[4];
    for (int i = 0; i < 4; i++) {
      cornerBits[i] = image.get(Math.round(bullsEyeCorners[i].getX()), Math.round(bullsEyeCorners[i].getY()));
    }
  
    int nbBits = 0;
    for (int i = 0; i < 4; i++) {
      for (int j = 0; j < 4; j++) {
        nbBits += (cornerBits[i] ^ cornerBits[j]) == 0 ? 1 : 0;
      }
    }
  
    if (nbBits != 8) {
      throw NotFoundException.getNotFoundInstance();
    }
  
    int nbLayers = 0;
    int nbDataBlocks = 0;
    for (int i = 0; i < 4; i++) {
      if (cornerBits[i] == 1) {
        nbLayers++;
      } else {
        nbDataBlocks++;
      }
    }
  
    this.nbLayers = nbLayers;
    this.nbDataBlocks = nbDataBlocks;
    this.nbCenterLayers = nbLayers - nbDataBlocks;
  
    // 2. Get the rotation of the grid
    int[] bits = new int[4];
    for (int i = 0; i < 4; i++) {
      bits[i] = cornerBits[(i + shift) % 4];
    }
  
    int rotation = 0;
    for (int i = 0; i < 4; i++) {
      if (bits[i] == 1) {
        rotation = i;
        break;
      }
    }
  
    this.shift = (rotation + 2) % 4;    
 }","private void extractParameters(ResultPoint[] bullsEyeCorners) throws NotFoundException{
    // 1. Get the number of layers and data blocks from the bull's eye
    int[] cornerBits = new int[4];
    for (int i = 0; i < 4; i++) {
      cornerBits[i] = image.get(MathUtils.round(bullsEyeCorners[i].getX()), MathUtils.round(bullsEyeCorners[i].getY()));
    }
  
    int nbBits = 0;
    for (int i = 0; i < 4; i++) {
      for (int j = 0; j < 4; j++) {
        if ((cornerBits[i] ^ cornerBits[j]) == 0) {
          nbBits++;
        }
      }
    }
  
    if (nbBits != 4) {
      throw NotFoundException.getNotFoundInstance();
    }
  
    int[] bits = new int[4];
    for (int i = 0; i < 4; i++) {
      for (int j = 0; j < 4; j++) {
        if ((cornerBits[i] ^ cornerBits[j]) == 0) {
          bits[i] = j;
        }
      }
    }
  
    nbLayers = bits[0];
    nbDataBlocks = bits[1];
    nbCenterLayers = bits[2];
    shift = bits[3];
  
    // 2. Get the compact data representation
    compact = (nbLayers < 4);   
 }","private void extractParameters(ResultPoint[] bullsEyeCorners) throws NotFoundException{
    // Get the bits around the bull's eye
    int size = getMatrixSize(compact, nbLayers);
    BitMatrix bits = sampleGrid(image, bullsEyeCorners[shift % 4],
                                bullsEyeCorners[(shift + 1) % 4],
                                bullsEyeCorners[(shift + 2) % 4],
                                bullsEyeCorners[(shift + 3) % 4],
                                size);
  
    // Get the corners of the matrix.
    ResultPoint[] cornerPoints = getMatrixCornerPoints(bullsEyeCorners);
  
    // Get the bits around the bull's eye
    extractDataBits(bits, cornerPoints);    
 }","private void extractParameters(ResultPoint[] bullsEyeCorners) throws NotFoundException{
    // Get the size of the matrix
    int size = computeDimension(bullsEyeCorners);
  
    // Get the corners of the matrix
    ResultPoint[] cornerPoints = getMatrixCornerPoints(bullsEyeCorners);
  
    // Get the bits around the bull's eye
    int[] cornerValues = new int[4];
    for (int i = 0; i < 4; i++) {
      cornerValues[i] = image.get(
          (int) cornerPoints[i].getX(),
          (int) cornerPoints[i].getY());
    }
  
    // Get the bits around the bull's eye
    int[] sideValues = new int[4];
    sideValues[0] = image.get(
        (int) cornerPoints[0].getX(),
        (int) cornerPoints[3].getY());
    sideValues[1] = image.get(
        (int) cornerPoints[1].getX(),
        (int) cornerPoints[2].getY());
    sideValues[2] = image.get(
        (int) cornerPoints[2].getX(),
        (int) cornerPoints[1].getY());
    sideValues[3] = image.get(
        (int) cornerPoints[3].getX(),
        (int) cornerPoints[0].getY());
  
    // Get the bits in the middle
    int[] middleValues = new int[2];
    middleValues[0] = image.get(
        (int) (cornerPoints[0].getX() + cornerPoints[1].getX()) / 2,
        (int) (cornerPoints[0].getY() + cornerPoints[3].getY()) / 2);
    middleValues[1] = image.get(
        (int) (cornerPoints[2].getX() + cornerPoints[1].getX()) / 2,
        (int) (cornerPoints[2].getY() + cornerPoints[3].getY()) / 2);
  
    // Get the bits in the cross
    int[] crossValues = new int[2];
    crossValues[0] =    
 }",NOT PASS,NOT PASS,Syntax Error,NOT PASS,  0.22450340745311573,  0.23889157151751614,None,  0.11727099583739661,242.0,0.7806451612903226,234.0,0.7905405405405406,301.0,0.7777777777777778,243.0,0.8209459459459459,125.0,0.4032258064516129,280.0,0.7235142118863049,261.0,0.8419354838709677,4.0,0.23529411764705882,1.0,0.058823529411764705,8.0,0.47058823529411764
588,openapi-generator,"private static ValidationRule.Result checkOneOfWithProperties(SchemaWrapper schemaWrapper){
    Schema schema = schemaWrapper.getSchema();
    ValidationRule.Result result = ValidationRule.Pass.empty();
    if (schema instanceof ComposedSchema) {
        final ComposedSchema composed = (ComposedSchema) schema;
        // check for loosely defined oneOf extension requirements.
        // This is a recommendation because the 3.0.x spec is not clear enough on usage of oneOf.
        // see https://json-schema.org/draft/2019-09/json-schema-core.html#rfc.section.9.2.1.3 and the OAS section on 'Composition and Inheritance'.
        if (composed.getOneOf() != null && composed.getOneOf().size() > 0) {
            if (composed.getProperties() != null && composed.getProperties().size() >= 1 && composed.getProperties().get(""discriminator"") == null) {
                // not necessarily ""invalid"" here, but we trigger the recommendation which requires the method to return false.
                result = ValidationRule.Fail.empty();
            }
        }
    }
    return result;
}",checkOneOfWithProperties,org/openapitools/codegen/validations/oas/OpenApiSchemaValidations.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/validations/oas/OpenApiSchemaValidations.java,"/**
     * JSON Schema defines oneOf as a validation property which can be applied to any schema.
     * <p>
     * OpenAPI Specification is a variant of JSON Schema for which oneOf is defined as:
     * ""Inline or referenced schema MUST be of a Schema Object and not a standard JSON Schema.""
     * <p>
     * Where the only examples of oneOf in OpenAPI Specification are used to define either/or type structures rather than validations.
     * Because of this ambiguity in the spec about what is non-standard about oneOf support, we'll warn as a recommendation that
     * properties on the schema defining oneOf relationships may not be intentional in the OpenAPI Specification.
     *
     * @param schemaWrapper An input schema, regardless of the type of schema
     * @return {@link ValidationRule.Pass} if the check succeeds, otherwise {@link ValidationRule.Fail}
     */",55-85,"('checkOneOfWithProperties', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 3}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",125.0,16.0,JSON Schema defines oneOf as a validation property which can be applied to any schema.,"If the schema is an instance of ComposedSchema, it returns {@link ValidationRule.pass}, otherwise {@link ValidationRule.fail}.",OneOf is a validation property which can be applied to any other database.,0.436173249497343,JSON Schema defines oneOf as a validation property that can be applied to any schema.," private static ValidationRule.Result checkOneOfWithProperties(SchemaWrapper schemaWrapper){
        Schema schema = schemaWrapper.getSchema();
        if (schema instanceof ComposedSchema) {
            ComposedSchema composedSchema = (ComposedSchema) schema;
            if (composedSchema.getOneOf() != null && !composedSchema.getOneOf().isEmpty()) {
                if (composedSchema.getProperties() != null && !composedSchema.getProperties().isEmpty()) {
                    return ValidationRule.Result.warning(
                            ""Schema defines properties alongside oneOf."",
                            ""Schemas defining properties and oneOf are not clearly defined in the OpenAPI Specification. While our tooling supports this, it may cause issues with other tools.""
                    );
                }
            }
        }
        return ValidationRule.Result.pass();        
 }"," private static ValidationRule.Result checkOneOfWithProperties(SchemaWrapper schemaWrapper){
        if (schemaWrapper.getSchema() instanceof ComposedSchema) {
            return ValidationRule.pass();
        }
        return ValidationRule.fail();       
 }"," private static ValidationRule.Result checkOneOfWithProperties(SchemaWrapper schemaWrapper){
        Schema schema = schemaWrapper.getSchema();
        if (schema instanceof ComposedSchema) {
            ComposedSchema composedSchema = (ComposedSchema) schema;
            if (composedSchema.getOneOf() != null && !composedSchema.getOneOf().isEmpty()) {
                if (composedSchema.getProperties() != null && !composedSchema.getProperties().isEmpty()) {
                    return ValidationRule.Result.warning(""Schema defines properties alongside oneOf."");
                }
            }
        }
        return ValidationRule.Result.pass();        
 }"," private static ValidationRule.Result checkOneOfWithProperties(SchemaWrapper schemaWrapper){
        Schema schema = schemaWrapper.getSchema();
        if (schema.getOneOf() != null && schema.getProperties() != null) {
            return ValidationRule.Result.failure(""Schema defines properties alongside oneOf."");
        }
        return ValidationRule.Result.success();     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5245619732173834,  0.18795813424723457,  0.3520082756508002,  0.5338142126350559,50.0,0.3968253968253968,96.0,0.7619047619047619,77.0,0.6111111111111112,48.0,0.38095238095238093,70.0,0.6666666666666666,47.0,0.44761904761904764,2.0,0.01904761904761905,15.0,0.9375,1.0,0.0625,7.0,0.4375
590,egeria,"private Optional<EntityDetail> findDatabaseEntity(String userId, String qualifiedName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, DATABASE_TYPE_NAME);
}",findDatabaseEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineRelationalDataHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineRelationalDataHandler.java,"/**
     * Find out if the Database object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the database to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",148-164,"('findDatabaseEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,13.0,Find out if the Database object is already stored in the repository.,Finds whether the database object has been previously stored in the repository using the fully qualified name.,"If the database object is already in the repository, you should find it.",0.0991593969483187,Check if the Database object is already stored in the repository.," private Optional<EntityDetail> findDatabaseEntity(String userId, String qualifiedName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
        final String methodName = ""findDatabaseEntity"";
        invalidParameterHandler.validateName(qualifiedName, DATABASE_NAME_MAX_LENGTH, false, methodName);
    
        return relationalDataHandler.findEntityByName(userId, qualifiedName, DATABASE_TYPE_NAME, methodName);       
 }"," private Optional<EntityDetail> findDatabaseEntity(String userId, String qualifiedName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
        final String methodName = ""findDatabaseEntity"";
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateName(qualifiedName, DATABASE_NAME, methodName);
    
        return relationalDataHandler.findEntityByGUID(userId, qualifiedName, DATABASE_TYPE_NAME, methodName);       
 }"," private Optional<EntityDetail> findDatabaseEntity(String userId, String qualifiedName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
        final String methodName = ""findDatabaseEntity"";
        validateParameters(userId, methodName, qualifiedName);
    
        return relationalDataHandler.findEntityByGUID(userId, qualifiedName, DATABASE_TYPE_NAME, methodName);       
 }"," private Optional<EntityDetail> findDatabaseEntity(String userId, String qualifiedName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
        final String methodName = ""findDatabaseEntity"";
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateName(qualifiedName, DATABASE_NAME, methodName);
    
        return relationalDataHandler.findEntityByGUID(userId, qualifiedName, DATABASE_TYPE_NAME, methodName);       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7250468573590254,  0.7469287554097351,  0.7469287554097351,  0.7526022376930944,23.0,0.41818181818181815,30.0,0.4838709677419355,30.0,0.4838709677419355,19.0,0.37254901960784315,12.0,0.1935483870967742,12.0,0.1935483870967742,9.0,0.16363636363636364,13.0,0.7222222222222222,2.0,0.15384615384615385,10.0,0.7142857142857143
591,cdk,"static List<Vector2d> newUnitVectors(final IAtom fromAtom, final List<IAtom> toAtoms){
    final List<Vector2d> unitVectors = new ArrayList<Vector2d>(toAtoms.size());
    for (final IAtom toAtom : toAtoms) {
        unitVectors.add(newUnitVector(fromAtom.getPoint2d(), toAtom.getPoint2d()));
    }
    return unitVectors;
}",newUnitVectors,org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,"/**
     * Create unit vectors from one atom to all other provided atoms.
     *
     * @param fromAtom reference atom (will become 0,0)
     * @param toAtoms list of to atoms
     * @return unit vectors
     */",97-110,"('newUnitVectors', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",73.0,12.0,Create unit vectors from one atom to all other provided atoms.,"Given a list of Atoms, it builds and returns unit vectors.",The unit is created from one atom to all the other atoms.,0.26408745386545,Create unit vectors from one atom to all the other atoms supplied.,"static List<Vector2d> newUnitVectors(final IAtom fromAtom, final List<IAtom> toAtoms){
        final List<Vector2d> vectors = new ArrayList<Vector2d>(toAtoms.size());
        for (IAtom toAtom : toAtoms) {
            vectors.add(newUnitVector(fromAtom, toAtom));
        }
        return vectors;
    }","static List<Vector2d> newUnitVectors(final IAtom fromAtom, final List<IAtom> toAtoms){
        final List<Vector2d> vectors = new ArrayList<Vector2d>();
        for (IAtom toAtom : toAtoms) {
            vectors.add(newUnitVector(fromAtom, toAtom));
        }
        return vectors;
    }","static List<Vector2d> newUnitVectors(final IAtom fromAtom, final List<IAtom> toAtoms){
        final List<Vector2d> vectors = new ArrayList<Vector2d>(toAtoms.size());
        for (final IAtom toAtom : toAtoms) {
            vectors.add(newUnitVector(fromAtom, toAtom));
        }
        return vectors;
    }","static List<Vector2d> newUnitVectors(final IAtom fromAtom, final List<IAtom> toAtoms){
        final List<Vector2d> vectors = new ArrayList<Vector2d>(toAtoms.size());
        for (final IAtom toAtom : toAtoms) {
            vectors.add(newUnitVector(fromAtom, toAtom));
        }
        return vectors;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7656311899663072,  0.5858662461551141,  0.7863325037724284,  0.7863325037724284,12.0,0.16216216216216217,17.0,0.22972972972972974,11.0,0.14864864864864866,11.0,0.14864864864864866,5.0,0.07692307692307693,1.0,0.015151515151515152,1.0,0.015151515151515152,11.0,0.9166666666666666,3.0,0.23076923076923078,5.0,0.38461538461538464
592,acs-aem-commons,"void close() throws IOException{
    if (flushBufferOnClose) {
        if (ResponseWriteMethod.OUTPUTSTREAM.equals(this.writeMethod) && outputStream != null && getBufferedBytes().length > 0) {
            wrappedResponse.getOutputStream().write(getBufferedBytes());
        } else if (ResponseWriteMethod.WRITER.equals(this.writeMethod) && writer != null && getBufferedString().length() > 0) {
            wrappedResponse.getWriter().write(getBufferedString());
        }
    }
    if (flushWrappedBuffer) {
        wrappedResponse.flushBuffer();
    }
}",close,com/adobe/acs/commons/util/BufferedServletOutput.java,/bundle/src/main/java/com/adobe/acs/commons/util/BufferedServletOutput.java,"/** 
     * Closing leads to flushing the buffered output stream or writer to the underlying/wrapped response but only in case {@link #flushBufferOnClose} is set to {@code true}.
     * Also this will automatically commit the response in case {@link #flushBuffer} has been called previously!
     * 
     * @throws IOException */",186-202,"('close', {'INSTRUCTION': {'covered': 40, 'missed': 7}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",109.0,33.0,Closing leads to flushing the buffered output stream or writer to the underlying/wrapped response but only in case {@link #flushBufferOnClose} is set to {@code true}.,"Checks whether flushBufferOnClose is set to true. If that's the case, it closes the buffered output stream or the writer to the underlying/wrapped response.","If the code is true, closing will cause the buffer to be flushed to the underlying/wrapped response.",1.89990170100804,"Closing causes the buffered output stream or recorder to be flushed to the underlying/encapsulated response, but only if {@link #flushBufferOnClose} is set to {@code true}."," void close() throws IOException{
        if (flushBufferOnClose) {
            if (ResponseWriteMethod.WRITER.equals(this.writeMethod)) {
                printWriter.flush();
            } else if (ResponseWriteMethod.OUTPUTSTREAM.equals(this.writeMethod)) {
                servletOutputStream.flush();
            }
            wrappedResponse.flushBuffer();
        }
    }"," void close() throws IOException{
        if (flushBufferOnClose) {
            if (writer != null) {
                writer.flush();
                writer.close();
            }
            if (outputStream != null) {
                outputStream.flush();
                outputStream.close();
            }
        }
        wrappedResponse.flushBuffer();
    }"," void close() throws IOException{
        if (flushBufferOnClose) {
            flush();
        }
        wrappedResponse.flushBuffer();
    }"," void close() throws IOException{
        if (flushBufferOnClose) {
            flush();
        }
        wrappedResponse.flushBuffer();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3278758158929516,  0.4243559247686113,  0.14542680753898654,  0.14542680753898654,52.0,0.4727272727272727,63.0,0.5727272727272728,86.0,0.7818181818181819,86.0,0.7818181818181819,27.0,0.421875,39.0,0.609375,39.0,0.609375,24.0,0.9230769230769231,11.0,0.4230769230769231,23.0,0.8846153846153846
593,glowstone,"protected boolean tryFeed(Material type, GlowPlayer player){
    if (!getBreedingFoods().contains(type)) {
        return false;
    }
    if (canBreed() && getInLove() <= 0) {
        // TODO get the correct duration
        setInLove(1000);
        player.incrementStatistic(Statistic.ANIMALS_BRED);
        return true;
    }
    int growth = computeGrowthAmount(type);
    if (growth > 0) {
        grow(growth);
        return true;
    }
    return false;
}",tryFeed,net/glowstone/entity/GlowAnimal.java,/src/main/java/net/glowstone/entity/GlowAnimal.java,"/**
     * Determines whether this entity can eat an item while healthy, and if so, applies the effects
     * of eating it.
     *
     * @param player the player feeding the entity, for statistical purposes
     * @param type an item that may be food
     * @return true if the item should be consumed; false otherwise
     */",53-76,"('tryFeed', {'INSTRUCTION': {'covered': 29, 'missed': 5}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 2}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,22.0,"Determines whether this entity can eat an item while healthy, and if so, applies the effects  of eating it.","Returns true if the current entity can eat an item. If so, applies the effects of eating it, otherwise returns false.","If this entity can eat an item while healthy, and if so, how it effects the environment.",0.304613622848156,"Determines whether this entity can eat a healthy item and, if so, applies the effects of its consumption.","protected boolean tryFeed(Material type, GlowPlayer player){
        if (type == Material.WHEAT) {
            player.getWorld().playSound(player.getLocation(), ""random.eat"", 1.0F, 1.0F);
            player.setSaturation(player.getSaturation() + 1.0F);
            return true;
        } else if (type == Material.CARROT) {
            player.getWorld().playSound(player.getLocation(), ""random.eat"", 1.0F, 1.0F);
            player.setSaturation(player.getSaturation() + 1.0F);
            return true;
        } else if (type == Material.POTATO) {
            player.getWorld().playSound(player.getLocation(), ""random.eat"", 1.0F, 1.0F);
            player.setSaturation(player.getSaturation() + 1.0F);
            return true;
        } else if (type == Material.BEETROOT) {
            player.getWorld().playSound(player.getLocation(), ""random.eat"", 1.0F, 1.0F);
            player.setSaturation(player.getSaturation() + 1.0F);
            return true;
        } else if (type == Material.MELON_SLICE) {
            player.getWorld().playSound(player.getLocation(), ""random.eat"", 1.0F, 1.0F);
            player.setSaturation(player.getSaturation() + 1.0F);
            return true;
        } else if (type == Material.PUMPKIN_PIE) {
            player.getWorld().playSound(player.getLocation(), ""random.eat"", 1.0F, 1.0F);
            player.setSaturation(player.getSaturation() + 1.0F);
            return true;
        } else if (type == Material.COOKIE) {
            player.getWorld().playSound(player.getLocation(), ""random.eat"", 1.0F, 1.0F);
            player.setSaturation(player.getSaturation() + 1.0F);
            return true;
        }       
 }"," protected boolean tryFeed(Material type, GlowPlayer player){
        if (DEFAULT_BREEDING_FOODS.contains(type)) {
            if (player.getGameMode() == GameMode.SURVIVAL) {
                player.getStatistic(Statistic.ANIMALS_BRED);
            }
            return true;
        }
        return false;
    }","protected boolean tryFeed(Material type, GlowPlayer player){
        if (type == Material.WHEAT) {
            if (getHealth() < getMaxHealth()) {
                setHealth(getHealth() + 1);
                player.getWorld().playSound(getLocation(), ""random.eat"", 1, 1);
                return true;
            }
        }
        return false;
    }",Not Valid,NOT PASS,NOT PASS,Not Valid,NOT PASS,  0.3198404166103711,  0.38573464208559866,None,  0.39465671603558805,286.0,0.8218390804597702,45.0,0.5113636363636364,None,None,48.0,0.5454545454545454,304.0,0.8735632183908046,None,None,288.0,0.8275862068965517,14.0,0.6363636363636364,7.0,0.35,7.0,0.35
594,matsim-libs,"public void addNetworkChangeEvent(final NetworkChangeEvent event){
    this.networkChangeEvents.add(event);
    for (Link link : event.getLinks()) {
        if (link instanceof TimeVariantLinkImpl) {
            ((TimeVariantLinkImpl) link).applyEvent(event);
        } else {
            throw new IllegalArgumentException(""Link "" + link.getId().toString() + "" is not timeVariant. "" + ""Did you make the network factory time variant?  The easiest way to achieve this is "" + ""either in the config file, or syntax of the type\n"" + ""config.network().setTimeVariantNetwork(true);\n"" + ""Scenario scenario = ScenarioUtils.load/createScenario(config);\n"" + ""Note that the scenario needs to be created _after_ the config option is set, otherwise"" + ""the factory will already be there."");
        }
    }
}",addNetworkChangeEvent,org/matsim/core/network/NetworkImpl.java,/matsim/src/main/java/org/matsim/core/network/NetworkImpl.java,"/**
	 * Adds a single network change event and applies it to the corresponding
	 * links.
	 *
	 * @param event
	 *            a network change event.
	 */",299-322,"('addNetworkChangeEvent', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",86.0,14.0,Adds a single network change event and applies it to the corresponding  links.,Adds a new network change event by applying it to the corresponding links.,A single network change event is added and applied to the links.,0.172891680252344,Adds a single network change event and applies it to the corresponding links.," public void addNetworkChangeEvent(final NetworkChangeEvent event){
	 	testForLocked() ;
 	this.networkChangeEvents.add(event);
 	for (Link link : event.getLinks()) {
 		if (link instanceof TimeVariantLinkImpl) {
 			((TimeVariantLinkImpl)link).addEvent(event);
 		}
 	}
 }"," public void addNetworkChangeEvent(final NetworkChangeEvent event){
	 	testForLocked() ;
 	this.networkChangeEvents.add(event);
 	for (Link link : event.getLinks()) {
 		if (link instanceof TimeVariantLinkImpl) {
 			((TimeVariantLinkImpl)link).addEvent(event);
 		}
 	}
 }"," public void addNetworkChangeEvent(final NetworkChangeEvent event){
	 	testForLocked() ;
 	this.networkChangeEvents.add(event);
 	for (Link link : this.getLinks().values()) {
 		if (link instanceof TimeVariantLinkImpl) {
 			((TimeVariantLinkImpl)link).addEvent(event);
 		}
 	}
 }"," public void addNetworkChangeEvent(final NetworkChangeEvent event){
	 	testForLocked() ;
 	this.networkChangeEvents.add(event);
 	for (Link link : event.getLinks()) {
 		if (link instanceof TimeVariantLinkImpl) {
 			((TimeVariantLinkImpl)link).addEvent(event);
 		}
 	}
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4724926824799538,  0.4724926824799538,  0.4724926824799538,  0.4202164901023948,39.0,0.4482758620689655,39.0,0.4482758620689655,39.0,0.4482758620689655,44.0,0.5057471264367817,0.0,0.0,0.0,0.0,5.0,0.08196721311475409,3.0,0.21428571428571427,0.0,0.0,7.0,0.5
595,cron-utils,"public int mapTo(final int dayOfWeek, final WeekDay targetWeekDayDefinition){
    if (firstDayZero && targetWeekDayDefinition.isFirstDayZero()) {
        return bothSameStartOfRange(0, 6, this, targetWeekDayDefinition).apply(dayOfWeek);
    }
    if (!firstDayZero && !targetWeekDayDefinition.isFirstDayZero()) {
        return bothSameStartOfRange(1, 7, this, targetWeekDayDefinition).apply(dayOfWeek);
    }
    // start range is different for each case. We need to normalize ranges
    if (targetWeekDayDefinition.isFirstDayZero()) {
        // my range is 1-7. I normalize ranges, get the ""zero"" mapping and turn result into original scale
        return mapTo(dayOfWeek, new WeekDay(targetWeekDayDefinition.getMondayDoWValue() + 1, false)) - 1;
    } else {
        // my range is 0-6. I normalize ranges, get the ""one"" mapping and turn result into original scale
        return mapTo(dayOfWeek, new WeekDay(targetWeekDayDefinition.getMondayDoWValue() - 1, true)) + 1;
    }
}",mapTo,com/cronutils/mapper/WeekDay.java,/src/main/java/com/cronutils/mapper/WeekDay.java,"/**
     * Maps given WeekDay to representation hold by this instance.
     *
     * @param targetWeekDayDefinition - referred weekDay
     * @param dayOfWeek               - day of week to be mapped.
     *                                Value corresponds to this instance mapping.
     * @return - int result
     */",43-66,"('mapTo', {'INSTRUCTION': {'covered': 67, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",131.0,10.0,Maps given WeekDay to representation hold by this instance.,Maps the given WeekDay to a representation suitable for this instance.,Maps given WeekDay to representation hold this instance.,0.412562000397123,Cards given WeekDay to the representation held by this body.,"public int mapTo(final int dayOfWeek, final WeekDay targetWeekDayDefinition){
        if (this.equals(targetWeekDayDefinition)) {
            return dayOfWeek;
        }
        if (this.isFirstDayZero()) {
            return targetWeekDayDefinition.getMondayDoWValue() + dayOfWeek;
        } else {
            return targetWeekDayDefinition.getMondayDoWValue() + dayOfWeek - 1;
        }       
 }",Not Valid,Not Valid," public int mapTo(final int dayOfWeek, final WeekDay targetWeekDayDefinition){
        final int targetMondayDoWValue = targetWeekDayDefinition.getMondayDoWValue();
        final boolean targetFirstDayZero = targetWeekDayDefinition.isFirstDayZero();
        final int targetDayOfWeek = mapTo(dayOfWeek, targetMondayDoWValue, targetFirstDayZero);
        return targetDayOfWeek;     
 }",NOT PASS,Not Valid,NOT PASS,Not Valid,  0.29955350854076046,None,  0.26380763473084823,None,76.0,0.5757575757575758,None,None,97.0,0.7348484848484849,None,None,None,None,38.0,0.6129032258064516,None,None,4.0,0.3333333333333333,4.0,0.36363636363636365,1.0,0.1
596,cdk,"private static StereoEncoder axial2DEncoder(IAtomContainer container, IAtom start, List<IBond> startBonds, IAtom end, List<IBond> endBonds){
    Point2d[] ps = new Point2d[4];
    int[] es = new int[4];
    PermutationParity perm = new CombinedPermutationParity(fill2DCoordinates(container, start, startBonds, ps, es, 0), fill2DCoordinates(container, end, endBonds, ps, es, 2));
    GeometricParity geom = new Tetrahedral2DParity(ps, es);
    int u = container.indexOf(start);
    int v = container.indexOf(end);
    return new GeometryEncoder(new int[] { u, v }, perm, geom);
}",axial2DEncoder,org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,"/**
     * Create an encoder for axial 2D stereochemistry for the given start and
     * end atoms.
     *
     * @param container  the molecule
     * @param start      start of the cumulated system
     * @param startBonds bonds connected to the start
     * @param end        end of the cumulated system
     * @param endBonds   bonds connected to the end
     * @return an encoder
     */",160-186,"('axial2DEncoder', {'INSTRUCTION': {'covered': 54, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",137.0,15.0,Create an encoder for axial 2D stereochemistry for the given start and  end atoms.,"Given the start and end atoms, builds an encoder for axial 2D stereochemistry.",An Encoder is needed for the given start and end atoms.,0.459935271921157,Create an encoder for 2D axial stereochemistry for the given start and end atoms.,"private static StereoEncoder axial2DEncoder(IAtomContainer container, IAtom start, List<IBond> startBonds, IAtom end, List<IBond> endBonds){
     
      // find the bonds which are not in the cumulated system
      List<IBond> bonds = new ArrayList<IBond>(startBonds);
      bonds.removeAll(endBonds);
     
      // find the bonds which are in the cumulated system
      List<IBond> cumulated = new ArrayList<IBond>(endBonds);
      cumulated.removeAll(startBonds);
     
      // find the bonds which are in the cumulated system but not in the
      // non-cumulated system
      List<IBond> common = new ArrayList<IBond>(cumulated);
      common.removeAll(bonds);
     
      // find the bonds which are in the non-cumulated system but not in the
      // cumulated system
      List<IBond> uncommon = new ArrayList<IBond>(bonds);
      uncommon.removeAll(cumulated);
     
      // find the bonds which are in the non-cumulated system but not in the
      // non-cumulated system
      List<IBond> other = new ArrayList<IBond>(bonds);
      other.removeAll(uncommon);
     
      // find the bonds which are in the cumulated system but not in the
      // non-cumulated system
      List<IBond> otherCumulated = new ArrayList<IBond>(cumulated);
      otherCumulated.removeAll(uncommon);
     
      // find the bonds which are in the non-cumulated system but not in the
      // cumulated system
      List<IBond> otherUncommon = new ArrayList<IBond>(uncommon);
      otherUncommon.removeAll(cumulated);
     
      // find the bonds which are in the non-cumulated system but not in the
      // non-cumulated system
      List<IBond> otherOther = new ArrayList<IBond>(uncommon);
      otherOther.removeAll(uncommon);
     
      // find the bonds which are in the cumulated system but not in the
      // non-cumulated system
      List<IBond> otherOtherCumulated = new ArrayList<IBond>(cumulated);
      other         
 }","private static StereoEncoder axial2DEncoder(IAtomContainer container, IAtom start, List<IBond> startBonds, IAtom end, List<IBond> endBonds){
     
      // find the bonds which are not in the cumulated system
      List<IBond> bonds = new ArrayList<IBond>(startBonds);
      bonds.removeAll(endBonds);
     
      // find the bonds which are in the cumulated system
      List<IBond> cumulated = new ArrayList<IBond>(endBonds);
      cumulated.removeAll(startBonds);
     
      // find the bonds which are in the cumulated system but not in the
      // non-cumulated system
      List<IBond> common = new ArrayList<IBond>(cumulated);
      common.removeAll(bonds);
     
      // find the bonds which are in the non-cumulated system but not in the
      // cumulated system
      List<IBond> uncommon = new ArrayList<IBond>(bonds);
      uncommon.removeAll(cumulated);
     
      // find the bonds which are in the non-cumulated system but not in the
      // non-cumulated system
      List<IBond> other = new ArrayList<IBond>(bonds);
      other.removeAll(uncommon);
     
      // find the bonds which are in the cumulated system but not in the
      // non-cumulated system
      List<IBond> other2 = new ArrayList<IBond>(cumulated);
      other2.removeAll(uncommon);
     
      // find the bonds which are in the non-cumulated system but not in the
      // cumulated system
      List<IBond> other3 = new ArrayList<IBond>(bonds);
      other3.removeAll(cumulated);
     
      // find the bonds which are in the cumulated system but not in the
      // non-cumulated system
      List<IBond> other4 = new ArrayList<IBond>(cumulated);
      other4.removeAll(bonds);
     
      // find the bonds which are in the non-cumulated system but not in the
      // cumulated system
      List<IBond> other5 = new ArrayList<IBond>(bonds);
      other5.removeAll(cumulated);          
 }",Not Valid,"private static StereoEncoder axial2DEncoder(IAtomContainer container, IAtom start, List<IBond> startBonds, IAtom end, List<IBond> endBonds){
     
      // find the bonds which are not in the cumulated system
      List<IBond> bonds = new ArrayList<IBond>(startBonds.size() + endBonds.size());
      bonds.addAll(startBonds);
      bonds.addAll(endBonds);
     
      List<IBond> nonCumulated = new ArrayList<IBond>(bonds.size());
      for (IBond bond : bonds) {
            if (!bond.getFlag(CDKConstants.ISINRING)) {
                 nonCumulated.add(bond);
            }
      }
     
      // find the bonds which are in the cumulated system
      List<IBond> cumulated = new ArrayList<IBond>(bonds.size());
      for (IBond bond : bonds) {
            if (bond.getFlag(CDKConstants.ISINRING)) {
                 cumulated.add(bond);
            }
      }
     
      // find the atoms which are not in the cumulated system
      List<IAtom> atoms = new ArrayList<IAtom>(container.getAtomCount());
      atoms.addAll(container.atoms());
     
      List<IAtom> nonCumulatedAtoms = new ArrayList<IAtom>(atoms.size());
      for (IAtom atom : atoms) {
            if (!atom.getFlag(CDKConstants.ISINRING)) {
                 nonCumulatedAtoms.add(atom);
            }
      }
     
      // find the atoms which are in the cumulated system
      List<IAtom> cumulatedAtoms = new ArrayList<IAtom>(atoms.size());
      for (IAtom atom : atoms) {
            if (atom.getFlag(CDKConstants.ISINRING)) {
                 cumulatedAtoms.add(atom);
            }
      }
     
      // find the bonds which are not in the cumulated system
      List<IBond> nonCumulatedBonds = new ArrayList<IBond>(nonCumulated.size());
      for (         
 }",Syntax Error,NOT PASS,Syntax Error,Not Valid,None,  0.275288349038783,None,None,None,None,165.0,0.7268722466960352,249.0,0.7955271565495208,None,None,18.0,0.07929515418502203,166.0,0.5303514376996805,None,None,14.0,0.9333333333333333,2.0,0.13333333333333333,7.0,0.4666666666666667
597,dcache,"private static ImmutableSetMultimap<Pattern, String> toPatterns(Map<String, String> formats){
    ImmutableSetMultimap.Builder<Pattern, String> builder = ImmutableSetMultimap.builder();
    for (Map.Entry<String, String> format : formats.entrySet()) {
        builder.putAll(toPattern(format.getKey(), format.getValue()), toAttributes(format.getValue()));
    }
    return builder.build();
}",toPatterns,org/dcache/services/billing/text/BillingParserBuilder.java,/modules/dcache/src/main/java/org/dcache/services/billing/text/BillingParserBuilder.java,"/**
     * Returns Patterns for the provided billing formats, as a Multimap mapping the Pattern to the
     * attributes contained in the pattern.
     */",140-151,"('toPatterns', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,22.0,"Returns Patterns for the provided billing formats, as a Multimap mapping the Pattern to the  attributes contained in the pattern.",Builds and returns a new multimap mapping the pattern to the attributes featuring the pattern.,The pattern is returned as a Multimap mapping the attributes contained in the pattern.,0.492086920732272,"Returns templates for the provided billing formats, in the form of a multi-card that maps the template to the attributes contained in the template."," private static ImmutableSetMultimap<Pattern, String> toPatterns(Map<String, String> formats){
        ImmutableSetMultimap.Builder<Pattern, String> builder = ImmutableSetMultimap.builder();
        for (Map.Entry<String, String> entry : formats.entrySet()) {
            String format = entry.getValue();
            String attribute = entry.getKey();
            String groupName = toGroupName(attribute);
            Pattern pattern = Pattern.compile(format.replace(""$"", ""\\$""));
            builder.put(pattern, attribute);
        }
        return builder.build();     
 }"," private static ImmutableSetMultimap<Pattern, String> toPatterns(Map<String, String> formats){
        ImmutableSetMultimap.Builder<Pattern, String> builder = ImmutableSetMultimap.builder();
        for (Map.Entry<String, String> entry : formats.entrySet()) {
            String format = entry.getValue();
            String attribute = entry.getKey();
            Pattern pattern = Pattern.compile(format);
            builder.put(pattern, attribute);
        }
        return builder.build();     
 }"," private static ImmutableSetMultimap<Pattern, String> toPatterns(Map<String, String> formats){
        ImmutableSetMultimap.Builder<Pattern, String> builder = ImmutableSetMultimap.builder();
        for (Map.Entry<String, String> entry : formats.entrySet()) {
            String format = entry.getValue();
            String attribute = entry.getKey();
            builder.put(toPattern(format), attribute);
        }
        return builder.build();     
 }"," private static ImmutableSetMultimap<Pattern, String> toPatterns(Map<String, String> formats){
        ImmutableSetMultimap.Builder<Pattern, String> builder = ImmutableSetMultimap.builder();
        for (Map.Entry<String, String> entry : formats.entrySet()) {
            String format = entry.getValue();
            String[] attributes = format.split("" "");
            for (String attribute : attributes) {
                builder.put(Pattern.compile(attribute), entry.getKey());
            }
        }
        return builder.build();     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7622428594716033,  0.7610502381144479,  0.7402034373486787,  0.7825137935448373,37.0,0.31896551724137934,27.0,0.26732673267326734,35.0,0.3125,24.0,0.2553191489361702,15.0,0.12931034482758622,31.0,0.2672413793103448,26.0,0.22413793103448276,13.0,0.6190476190476191,10.0,0.4,10.0,0.47619047619047616
598,dataverse,"protected void tidyUpFields(DatasetVersion dsv){
    Iterator<DatasetField> dsfIt = dsv.getDatasetFields().iterator();
    while (dsfIt.hasNext()) {
        if (dsfIt.next().removeBlankDatasetFieldValues()) {
            dsfIt.remove();
        }
    }
    Iterator<DatasetField> dsfItSort = dsv.getDatasetFields().iterator();
    while (dsfItSort.hasNext()) {
        dsfItSort.next().setValueDisplayOrder();
    }
    Iterator<DatasetField> dsfItTrim = dsv.getDatasetFields().iterator();
    while (dsfItTrim.hasNext()) {
        dsfItTrim.next().trimTrailingSpaces();
    }
}",tidyUpFields,edu/harvard/iq/dataverse/engine/command/impl/AbstractDatasetCommand.java,/src/main/java/edu/harvard/iq/dataverse/engine/command/impl/AbstractDatasetCommand.java,"/**
     * Removed empty fields, sets field value display order.
     *
     * @param dsv the dataset version show fields we want to tidy up.
     */",118-138,"('tidyUpFields', {'INSTRUCTION': {'covered': 30, 'missed': 10}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 9, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",127.0,10.0,"Removed empty fields, sets field value display order.",Updates fields by setting the field value display order and removing those that are empty.,The field value display order is set.,0.259218386415795,"Deleting empty fields, setting the order in which field values are displayed."," protected void tidyUpFields(DatasetVersion dsv){
        dsv.getDatasetFields().stream()
            .filter(f -> f.getSingleValue().isEmpty())
            .forEach(f -> f.setSingleValue(DatasetField.NA_VALUE));
        dsv.getDatasetFields().stream()
            .forEach(f -> f.setDisplayOrder(dsv.getDatasetFields().indexOf(f)));
    }"," protected void tidyUpFields(DatasetVersion dsv){
        for (DatasetField field : dsv.getDatasetFields()) {
            if (field.getSingleValue().isEmpty()) {
                dsv.removeDatasetField(field);
            } else {
                field.setDisplayOrder(dsv.getDatasetFields().indexOf(field));
            }
        }       
 }",Empty Method," protected void tidyUpFields(DatasetVersion dsv){
        // Delete empty fields
        Iterator<DatasetField> it = dsv.getDatasetFields().iterator();
        while (it.hasNext()) {
            DatasetField field = it.next();
            if (field.getSingleValue().equals(DatasetField.NA_VALUE)) {
                it.remove();
            }
        }
        // Set the order in which field values are displayed
        dsv.getDatasetFields().stream().forEach(field -> {
            field.setDisplayOrder(dsv.getDatasetFields().indexOf(field));
        });     
 }",NOT PASS,NOT PASS,NOT PASS,Empty Method,  0.35686189681629904,  0.348518079143452,  0.5871851801559826,None,75.0,0.5859375,82.0,0.640625,64.0,0.5,None,None,43.0,0.5375,43.0,0.4215686274509804,None,None,12.0,0.75,9.0,0.6923076923076923,7.0,0.7777777777777778
599,acs-aem-commons,"private void populateHeaders() throws RepositoryException{
    final Node headers = getOrCreateByPath(entryNode, JCRHttpCacheStoreConstants.PATH_HEADERS, OAK_UNSTRUCTURED, OAK_UNSTRUCTURED);
    for (Iterator<Map.Entry<String, List<String>>> entryIterator = cacheContent.getHeaders().entrySet().iterator(); entryIterator.hasNext(); ) {
        Map.Entry<String, List<String>> entry = entryIterator.next();
        final String key = entry.getKey();
        final List<String> values = entry.getValue();
        headers.setProperty(key, values.toArray(new String[values.size()]));
    }
}",populateHeaders,com/adobe/acs/commons/httpcache/store/jcr/impl/writer/EntryNodeWriter.java,/bundle/src/main/java/com/adobe/acs/commons/httpcache/store/jcr/impl/writer/EntryNodeWriter.java,"/**
     * Save the headers into a headers node under the cache entry node.
     * @throws RepositoryException
     */",114-128,"('populateHeaders', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",131.0,13.0,Save the headers into a headers node under the cache entry node.,"If the headers node is not null, save the new headers under the cache entry node.","Under the cache entry node, save the headers.",0.859167571442819,Save the headers to a header node under the cache input node.," private void populateHeaders() throws RepositoryException{
        final Node headers = getOrCreateByPath(entryNode, JCRHttpCacheStoreConstants.PATH_HEADERS, JcrConstants.NT_UNSTRUCTURED, OAK_UNSTRUCTURED);
        final Map<String, List<String>> headersMap = cacheContent.getHeaders();
        for(Map.Entry<String, List<String>> entry : headersMap.entrySet()) {
            final String headerName = entry.getKey();
            final List<String> headerValues = entry.getValue();
            for(String headerValue : headerValues) {
                final Node headerNode = getOrCreateByPath(headers, headerName, JcrConstants.NT_UNSTRUCTURED, OAK_UNSTRUCTURED);
                headerNode.setProperty(JCRHttpCacheStoreConstants.PN_HEADER_VALUE, headerValue);
            }
        }
    }"," private void populateHeaders() throws RepositoryException{
        final Node headers = getOrCreateByPath(entryNode, JCRHttpCacheStoreConstants.PATH_HEADERS, JcrConstants.NT_UNSTRUCTURED, OAK_UNSTRUCTURED);
        final Map<String, List<String>> headersMap = cacheContent.getHeaders();
        if(headersMap != null) {
            for(Map.Entry<String, List<String>> entry : headersMap.entrySet()) {
                final String headerName = entry.getKey();
                final List<String> headerValues = entry.getValue();
                for(String headerValue : headerValues) {
                    final Node headerNode = getOrCreateByPath(headers, headerName, JcrConstants.NT_UNSTRUCTURED, OAK_UNSTRUCTURED);
                    headerNode.setProperty(JCRHttpCacheStoreConstants.PN_HEADER_VALUE, headerValue);
                }
            }
        }
    }"," private void populateHeaders() throws RepositoryException{
        final Node headers = getOrCreateByPath(entryNode, JCRHttpCacheStoreConstants.PATH_HEADERS, JcrConstants.NT_UNSTRUCTURED, OAK_UNSTRUCTURED);
    
        final Map<String, List<String>> headerMap = cacheContent.getHeaders();
        for(final Map.Entry<String, List<String>> entry : headerMap.entrySet()) {
            final String headerName = entry.getKey();
            final List<String> headerValues = entry.getValue();
            final Node headerNode = getOrCreateByPath(headers, headerName, JcrConstants.NT_UNSTRUCTURED, OAK_UNSTRUCTURED);
            for(final String headerValue : headerValues) {
                headerNode.setProperty(JCRHttpCacheStoreConstants.PN_HEADER_VALUE, headerValue);
            }
        }       
 }"," private void populateHeaders() throws RepositoryException{
        final Node headers = getOrCreateByPath(entryNode, JCRHttpCacheStoreConstants.PATH_HEADERS, JcrConstants.NT_UNSTRUCTURED, OAK_UNSTRUCTURED);
    
        final Iterator<Map.Entry<String, List<String>>> headerIterator = cacheContent.getHeaders().entrySet().iterator();
        while(headerIterator.hasNext()) {
            final Map.Entry<String, List<String>> header = headerIterator.next();
            final String headerName = header.getKey();
            final List<String> headerValues = header.getValue();
    
            final Node headerNode = getOrCreateByPath(headers, headerName, JcrConstants.NT_UNSTRUCTURED, OAK_UNSTRUCTURED);
            headerNode.setProperty(JCRHttpCacheStoreConstants.PN_HEADER_NAME, headerName);
    
            final Iterator<String> headerValueIterator = headerValues.iterator();
            while(headerValueIterator.hasNext()) {
                final String headerValue = headerValueIterator.next();
                headerNode.setProperty(JCRHttpCacheStoreConstants.PN_HEADER_VALUE, headerValue);
            }
        }       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6144408605241825,  0.609507658073646,  0.6429279639150813,  0.6171064027511564,63.0,0.4772727272727273,63.0,0.45652173913043476,76.0,0.41081081081081083,62.0,0.4696969696969697,8.0,0.057971014492753624,82.0,0.44324324324324327,20.0,0.15151515151515152,9.0,0.5294117647058824,3.0,0.23076923076923078,10.0,0.7692307692307693
600,cdk,"public DescriptorValue calculate(IAtomContainer ac){
    ac = clone(ac);
    int rotatableBondsCount = 0;
    int degree0;
    int degree1;
    IRingSet ringSet;
    try {
        ringSet = new SpanningTree(ac).getBasicRings();
    } catch (NoSuchAtomException e) {
        return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult((int) Double.NaN), getDescriptorNames(), e);
    }
    for (IBond bond : ac.bonds()) {
        if (ringSet.getRings(bond).getAtomContainerCount() > 0) {
            bond.setFlag(CDKConstants.ISINRING, true);
        }
    }
    for (IBond bond : ac.bonds()) {
        IAtom atom0 = bond.getBegin();
        IAtom atom1 = bond.getEnd();
        if (atom0.getAtomicNumber() == IElement.H || atom1.getAtomicNumber() == IElement.H)
            continue;
        if (bond.getOrder() == Order.SINGLE) {
            if ((BondManipulator.isLowerOrder(ac.getMaximumBondOrder(atom0), IBond.Order.TRIPLE)) && (BondManipulator.isLowerOrder(ac.getMaximumBondOrder(atom1), IBond.Order.TRIPLE))) {
                if (!bond.getFlag(CDKConstants.ISINRING)) {
                    if (excludeAmides && (isAmide(atom0, atom1, ac) || isAmide(atom1, atom0, ac))) {
                        continue;
                    }
                    degree0 = ac.getConnectedBondsCount(atom0) - getConnectedHCount(ac, atom0);
                    degree1 = ac.getConnectedBondsCount(atom1) - getConnectedHCount(ac, atom1);
                    if ((degree0 == 1) || (degree1 == 1)) {
                        if (includeTerminals) {
                            rotatableBondsCount += 1;
                        }
                    } else {
                        rotatableBondsCount += 1;
                    }
                }
            }
        }
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(rotatableBondsCount), getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/RotatableBondsCountDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/RotatableBondsCountDescriptor.java,"/**
     *  The method calculates the number of rotatable bonds of an atom container.
     *  If the boolean parameter is set to true, terminal bonds are included.
     *
     *@param  ac                AtomContainer
     *@return                   number of rotatable bonds
     */",135-190,"('calculate', {'INSTRUCTION': {'covered': 144, 'missed': 18}, 'BRANCH': {'covered': 26, 'missed': 4}, 'LINE': {'covered': 27, 'missed': 3}, 'COMPLEXITY': {'covered': 12, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",374.0,13.0,The method calculates the number of rotatable bonds of an atom container.,Computes the number of rotable bonds of an atom container.,The method calculates the number of bonds in the atom container.,0.383834125718478,The method calculates the number of rotating bonds of an atom container.,"public DescriptorValue calculate(IAtomContainer ac){
        int nRotB = 0;
        int nRotBt = 0;
        int nRotBt2 = 0;
        int nRotBt3 = 0;
        int nRotBt4 = 0;
        int nRotBt5 = 0;
        int nRotBt6 = 0;
        int nRotBt7 = 0;
        int nRotBt8 = 0;
        int nRotBt9 = 0;
        int nRotBt10 = 0;
        int nRotBt11 = 0;
        int nRotBt12 = 0;
        int nRotBt13 = 0;
        int nRotBt14 = 0;
        int nRotBt15 = 0;
        int nRotBt16 = 0;
        int nRotBt17 = 0;
        int nRotBt18 = 0;
        int nRotBt19 = 0;
        int nRotBt20 = 0;
        int nRotBt21 = 0;
        int nRotBt22 = 0;
        int nRotBt23 = 0;
        int nRotBt24 = 0;
        int nRotBt25 = 0;
        int nRotBt26 = 0;
        int nRotBt27 = 0;
        int nRotBt28 = 0;
        int nRotBt29 = 0;
        int nRotBt30 = 0;
        int nRotBt31 = 0;
        int nRotBt32 = 0;
        int nRotBt33 = 0;
        int nRotBt34 = 0;
        int nRotBt35 = 0;
        int nRotBt36 = 0;
        int nRotBt37 = 0;
        int nRotBt38 = 0;
        int nRotBt39 = 0;
        int nRotBt40 = 0;
        int nRotBt41 = 0;
        int nRotBt42 = 0;
        int nRotBt43 = 0;
        int nRotBt44 = 0;
        int nRotBt45        
 }",Not Valid,"public DescriptorValue calculate(IAtomContainer ac){
        int nRotBonds = 0;
        int nBonds = ac.getBondCount();
        for (int i = 0; i < nBonds; i++) {
            IBond bond = ac.getBond(i);
            if (bond.getOrder() == Order.SINGLE) {
                continue;
            }
            if (bond.getOrder() == Order.DOUBLE) {
                nRotBonds++;
                continue;
            }
            if (bond.getOrder() == Order.TRIPLE) {
                nRotBonds += 2;
                continue;
            }
            if (bond.getOrder() == Order.QUADRUPLE) {
                nRotBonds += 3;
                continue;
            }
            if (bond.getOrder() == Order.AROMATIC) {
                nRotBonds++;
                continue;
            }
            if (bond.getOrder() == Order.SINGLE_OR_DOUBLE) {
                nRotBonds++;
                continue;
            }
            if (bond.getOrder() == Order.SINGLE_OR_AROMATIC) {
                nRotBonds++;
                continue;
            }
            if (bond.getOrder() == Order.DOUBLE_OR_AROMATIC) {
                nRotBonds += 2;
                continue;
            }
            if (bond.getOrder() == Order.ANY) {
                nRotBonds++;
                continue;
            }
        }
        if (includeTerminals) {
            nRotBonds += getTerminalBonds(ac);
        }
        if (excludeAmides) {
            nRotBonds -= getAmideBonds(ac);
        }
        return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(),
                new IntegerResult(nRotBonds), getDescriptorNames());        
 }",Not Valid,Syntax Error,Not Valid,Not Valid,NOT PASS,None,None,None,  0.291666437324338,None,None,None,None,None,None,249.0,0.664,None,None,None,None,240.0,0.8759124087591241,4.0,0.3076923076923077,1.0,0.07692307692307693,3.0,0.23076923076923078
601,glowstone,"public static CompatibilityBundle fromConfig(String configValue){
    if (configValue == null || CharMatcher.whitespace().matchesAllOf(configValue)) {
        return CompatibilityBundle.CRAFTBUKKIT;
    }
    try {
        return valueOf(configValue.toUpperCase());
    } catch (IllegalArgumentException e) {
        return null;
    }
}",fromConfig,net/glowstone/util/CompatibilityBundle.java,/src/main/java/net/glowstone/util/CompatibilityBundle.java,"/**
     * Converts the given config value into the appropriate bundle. If the given value is blank or
     * null, the default value is returned. If the given value does not match any preprogrammmed
     * bundles case insensitively, then null is returned.
     *
     * @param configValue The value from the config file.
     */",44-60,"('fromConfig', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",57.0,10.0,Converts the given config value into the appropriate bundle.,"Given a String object configValue, returns null if no matches are found with respect to the preprogrammed bundles. Othewise returns the default value.",The given config value is converted into the appropriate bundle.,0.203398611956606,Converts the given configuration value to the appropriate bundle.," public static CompatibilityBundle fromConfig(String configValue){
        return Stream.of(values())
            .filter(bundle -> bundle.name().equalsIgnoreCase(configValue))
            .findFirst()
            .orElse(NONE);      
 }"," public static CompatibilityBundle fromConfig(String configValue){
        if(configValue == null) return null;
        return Stream.of(values())
            .filter(bundle -> bundle.name().equalsIgnoreCase(configValue))
            .findFirst()
            .orElse(null);      
 }",Empty Method," public static CompatibilityBundle fromConfig(String configValue){
        return Stream.of(values())
            .filter(bundle -> bundle.name().equalsIgnoreCase(configValue))
            .findFirst()
            .orElse(NONE);      
 }",NOT PASS,NOT PASS,NOT PASS,Empty Method,  0.3516642185124579,  0.4876057414975399,  0.3516642185124579,None,35.0,0.603448275862069,32.0,0.5517241379310345,35.0,0.603448275862069,None,None,10.0,0.18181818181818182,0.0,0.0,None,None,21.0,0.875,2.0,0.2,4.0,0.36363636363636365
602,cdk,"public void placeAliphaticHeavyChain(IAtomContainer molecule, IAtomContainer chain) throws CDKException{
    int[] first = new int[2];
    int counter = 1;
    int nextAtomNr = 0;
    String id1 = """";
    String id2 = """";
    String id3 = """";
    first = findHeavyAtomsInChain(molecule, chain);
    distances = new double[first[1]];
    firstAtoms = new int[first[1]];
    angles = new double[first[1]];
    secondAtoms = new int[first[1]];
    dihedrals = new double[first[1]];
    thirdAtoms = new int[first[1]];
    firstAtoms[0] = first[0];
    molecule.getAtom(firstAtoms[0]).setFlag(CDKConstants.VISITED, true);
    int hybridisation = 0;
    for (int i = 0; i < chain.getAtomCount(); i++) {
        if (isHeavyAtom(chain.getAtom(i))) {
            if (!chain.getAtom(i).getFlag(CDKConstants.VISITED)) {
                nextAtomNr = molecule.indexOf(chain.getAtom(i));
                id2 = molecule.getAtom(firstAtoms[counter - 1]).getAtomTypeName();
                id1 = molecule.getAtom(nextAtomNr).getAtomTypeName();
                if (molecule.getBond(molecule.getAtom(firstAtoms[counter - 1]), molecule.getAtom(nextAtomNr)) == null)
                    throw new CDKException(""atoms do not form a chain, please use ModelBuilder3D"");
                distances[counter] = getBondLengthValue(id1, id2);
                firstAtoms[counter] = nextAtomNr;
                secondAtoms[counter] = firstAtoms[counter - 1];
                if (counter > 1) {
                    id3 = molecule.getAtom(firstAtoms[counter - 2]).getAtomTypeName();
                    hybridisation = getHybridisationState(molecule.getAtom(firstAtoms[counter - 1]));
                    angles[counter] = getAngleValue(id1, id2, id3);
                    if (angles[counter] == -1) {
                        if (hybridisation == 3) {
                            angles[counter] = DEFAULT_SP3_ANGLE;
                        } else if (hybridisation == 2) {
                            angles[counter] = DEFAULT_SP2_ANGLE;
                        } else if (hybridisation == 1) {
                            angles[counter] = DEFAULT_SP_ANGLE;
                        }
                    }
                    thirdAtoms[counter] = firstAtoms[counter - 2];
                } else {
                    angles[counter] = -1;
                    thirdAtoms[counter] = -1;
                }
                if (counter > 2) {
                    try {
                        if (getDoubleBondConfiguration2D(molecule.getBond(molecule.getAtom(firstAtoms[counter - 1]), molecule.getAtom(firstAtoms[counter - 2])), (molecule.getAtom(firstAtoms[counter])).getPoint2d(), (molecule.getAtom(firstAtoms[counter - 1])).getPoint2d(), (molecule.getAtom(firstAtoms[counter - 2])).getPoint2d(), (molecule.getAtom(firstAtoms[counter - 3])).getPoint2d()) == 5) {
                            dihedrals[counter] = DIHEDRAL_BRANCHED_CHAIN;
                        } else {
                            dihedrals[counter] = DIHEDRAL_EXTENDED_CHAIN;
                        }
                    } catch (CDKException ex1) {
                        dihedrals[counter] = DIHEDRAL_EXTENDED_CHAIN;
                    }
                } else {
                    dihedrals[counter] = -1;
                }
                counter++;
            }
        }
    }
}",placeAliphaticHeavyChain,org/openscience/cdk/modeling/builder3d/AtomPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomPlacer3D.java,"/**
     *  Method assigns 3D coordinates to the heavy atoms in an aliphatic chain.
     *
     * @param molecule        the reference molecule for the chain
     * @param  chain          the atoms to be assigned, must be connected
     * @throws CDKException the 'chain' was not a chain
     */",116-200,"('placeAliphaticHeavyChain', {'INSTRUCTION': {'covered': 297, 'missed': 30}, 'BRANCH': {'covered': 16, 'missed': 6}, 'LINE': {'covered': 50, 'missed': 7}, 'COMPLEXITY': {'covered': 8, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",634.0,13.0,Method assigns 3D coordinates to the heavy atoms in an aliphatic chain.,Attributes 3D coordinates to the heavy atoms in an alphatic chain.,The method assigns coordinates to the heavy atoms.,0.494898503283602,The method assigns 3D coordinates to heavy atoms in an aliphatic chain.,"public void placeAliphaticHeavyChain(IAtomContainer molecule, IAtomContainer chain) throws CDKException{
        int[] heavy = findHeavyAtomsInChain(molecule, chain);
        if (heavy[1] == 0) {
            logger.error(""No heavy atoms found in chain"");
            return;
        }
        if (heavy[1] == 1) {
            placeAliphaticHeavyChainSingle(molecule, chain, heavy[0]);
            return;
        }
        if (heavy[1] == 2) {
            placeAliphaticHeavyChainDouble(molecule, chain, heavy[0]);
            return;
        }
        if (heavy[1] == 3) {
            placeAliphaticHeavyChainTriple(molecule, chain, heavy[0]);
            return;
        }
        if (heavy[1] == 4) {
            placeAliphaticHeavyChainQuadruple(molecule, chain, heavy[0]);
            return;
        }
        if (heavy[1] == 5) {
            placeAliphaticHeavyChainQuintuple(molecule, chain, heavy[0]);
            return;
        }
        if (heavy[1] == 6) {
            placeAliphaticHeavyChainSextuple(molecule, chain, heavy[0]);
            return;
        }
        if (heavy[1] == 7) {
            placeAliphaticHeavyChainSeptuple(molecule, chain, heavy[0]);
            return;
        }
        if (heavy[1] == 8) {
            placeAliphaticHeavyChainOctuple(molecule, chain, heavy[0]);
            return;
        }
        if (heavy[1] == 9) {
            placeAliphaticHeavyChainNonuple(molecule, chain, heavy[0]);
            return;
        }
        if (heavy[1] == 10) {
            placeAliphaticHeavyChainDecuple(molecule, chain, heavy[0]);
            return;
        }
        if (heavy[1] == 11) {
            placeAliphaticHeavyChainUndecuple(molecule, chain, heavy[0]);
            return;
        }
        if (heavy[      
 }","public void placeAliphaticHeavyChain(IAtomContainer molecule, IAtomContainer chain) throws CDKException{
        int[] heavy = findHeavyAtomsInChain(molecule, chain);
        if (heavy[1] == 0) {
            logger.error(""No heavy atoms in chain"");
            return;
        }
        if (heavy[1] == 1) {
            placeAliphaticHeavyChainSingle(molecule, chain, heavy[0]);
            return;
        }
        placeAliphaticHeavyChainMultiple(molecule, chain, heavy);
    }",Not Valid,"public void placeAliphaticHeavyChain(IAtomContainer molecule, IAtomContainer chain) throws CDKException{
        int[] heavy = findHeavyAtomsInChain(molecule, chain);
        if (heavy[1] == 0) {
            return;
        }
        if (heavy[1] == 1) {
            placeAliphaticHeavyChainSingle(molecule, chain, heavy[0]);
            return;
        }
        placeAliphaticHeavyChainMultiple(molecule, chain, heavy);
    }",Syntax Error,NOT PASS,NOT PASS,Not Valid,None,  0.05570323188447471,  0.05450022862540126,None,None,None,573.0,0.9023622047244094,577.0,0.9086614173228347,None,None,247.0,0.7576687116564417,253.0,0.7760736196319018,None,None,3.0,0.23076923076923078,3.0,0.23076923076923078,8.0,0.6153846153846154
603,cdk,"public static double method1(ICountFingerprint fp1, ICountFingerprint fp2){
    long xy = 0, x = 0, y = 0;
    for (int i = 0; i < fp1.numOfPopulatedbins(); i++) {
        int hash = fp1.getHash(i);
        for (int j = 0; j < fp2.numOfPopulatedbins(); j++) {
            if (hash == fp2.getHash(j)) {
                xy += fp1.getCount(i) * fp2.getCount(j);
            }
        }
        x += fp1.getCount(i) * fp1.getCount(i);
    }
    for (int j = 0; j < fp2.numOfPopulatedbins(); j++) {
        y += fp2.getCount(j) * fp2.getCount(j);
    }
    return ((double) xy / (x + y - xy));
}",method1,org/openscience/cdk/similarity/Tanimoto.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/similarity/Tanimoto.java,"/**
     * Calculates Tanimoto distance for two count fingerprints using method 1.
     *
     * The feature/count type fingerprints may be of different length.
     * Uses Tanimoto method from {@cdk.cite Steffen09}.
     * 
     * @param fp1 count fingerprint 1
     * @param fp2 count fingerprint 2
     * @return a Tanimoto distance
     */",185-210,"('method1', {'INSTRUCTION': {'covered': 82, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",173.0,11.0,Calculates Tanimoto distance for two count fingerprints using method 1.,Computes the Tanimoto distance for two count fingerprints.,Method 1 calculates Tanimoto distance for two count fingerprints.,0.218860173233343,Calculates the Tanimoto distance for two counting fingerprints using Method 1.,"public static double method1(ICountFingerprint fp1, ICountFingerprint fp2){
        Set<String> common = new TreeSet<String>(fp1.getFeatures());
        common.retainAll(fp2.getFeatures());
        double xy = 0., x = 0., y = 0.;
        for (String s : common) {
            int c1 = fp1.getCount(s), c2 = fp2.getCount(s);
            xy += c1 * c2;
        }
        for (Integer c : fp1.getCounts()) {
            x += c * c;
        }
        for (Integer c : fp2.getCounts()) {
            y += c * c;
        }
        return (float) (xy / (x + y - xy));     
 }","public static double method1(ICountFingerprint fp1, ICountFingerprint fp2){
        Set<String> common = new TreeSet<String>(fp1.getFeatures());
        common.retainAll(fp2.getFeatures());
        double xy = 0., x = 0., y = 0.;
        for (String s : common) {
            int c1 = fp1.getCount(s), c2 = fp2.getCount(s);
            xy += c1 * c2;
        }
        for (Integer c : fp1.getCounts()) {
            x += c * c;
        }
        for (Integer c : fp2.getCounts()) {
            y += c * c;
        }
        return (float) (xy / (x + y - xy));     
 }","public static double method1(ICountFingerprint fp1, ICountFingerprint fp2){
        int n = fp1.size();
        if (n != fp2.size()) {
            throw new IllegalArgumentException(""Fingerprints must have the same size"");
        }
        double xy = 0., x = 0., y = 0.;
        for (int i = 0; i < n; i++) {
            int c1 = fp1.getCount(i), c2 = fp2.getCount(i);
            xy += c1 * c2;
        }
        for (int i = 0; i < n; i++) {
            int c1 = fp1.getCount(i);
            x += c1 * c1;
        }
        for (int i = 0; i < n; i++) {
            int c2 = fp2.getCount(i);
            y += c2 * c2;
        }
        return (float) (xy / (x + y - xy));     
 }","public static double method1(ICountFingerprint fp1, ICountFingerprint fp2){
        int n = fp1.size();
        if (n != fp2.size()) {
            throw new IllegalArgumentException(""Fingerprints must have the same size"");
        }
        double ab = 0.0;
        double a2 = 0.0;
        double b2 = 0.0;
        for (int i = 0; i < n; i++) {
            int c1 = fp1.getCount(i), c2 = fp2.getCount(i);
            ab += c1 * c2;
            a2 += c1 * c1;
            b2 += c2 * c2;
        }
        return (float) (ab / (a2 + b2 - ab));       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3383914140811491,  0.3383914140811491,  0.3828722796905031,  0.4849818739419848,109.0,0.6264367816091954,109.0,0.6264367816091954,118.0,0.6781609195402298,109.0,0.6193181818181818,0.0,0.0,84.0,0.5793103448275863,80.0,0.45454545454545453,6.0,0.5454545454545454,3.0,0.25,7.0,0.6363636363636364
605,shardingsphere-elasticjob,"public boolean isAllStarted(){
    return jobNodeStorage.isJobNodeExisted(GuaranteeNode.STARTED_ROOT) && configService.load(false).getShardingTotalCount() == jobNodeStorage.getJobNodeChildrenKeys(GuaranteeNode.STARTED_ROOT).size();
}",isAllStarted,org/apache/shardingsphere/elasticjob/lite/internal/guarantee/GuaranteeService.java,/elasticjob-lite/elasticjob-lite-core/src/main/java/org/apache/shardingsphere/elasticjob/lite/internal/guarantee/GuaranteeService.java,"/**
     * Judge whether job's sharding items are all started.
     *
     * @return job's sharding items are all started or not
     */",66-74,"('isAllStarted', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,10.0,Judge whether job's sharding items are all started.,Checks if the job's sharding items have been started.,"If the job's shards are all started, then you should judge it.",0.206966382240607,Judge whether the partitioning items of the task are all started.," public boolean isAllStarted(){
        return jobNodeStorage.isJobNodeExisted(GuaranteeNode.getAllStartedNode());
    }"," public boolean isAllStarted(){
        return jobNodeStorage.isJobNodeExisted(GuaranteeNode.getAllStartedNode());
    }"," public boolean isAllStarted(){
        return configService.getJobConfiguration().getJobType() == JobType.SHARDING_JOB &&
                configService.getJobConfiguration().getShardingTotalCount() == jobNodeStorage.getJobNodeChildrenKeys(GuaranteeNode.getStartedNode()).size();
    }"," public boolean isAllStarted(){
        return configService.getJobType() == ConfigurationService.JobType.PARTITIONED &&
                jobNodeStorage.isJobNodeExisted(GuaranteeNode.getAllStartedNode());     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.23039874951340306,  0.23039874951340306,  0.27438087127804556,  0.5482461576359555,23.0,0.5476190476190477,23.0,0.5476190476190477,21.0,0.5,14.0,0.2916666666666667,0.0,0.0,12.0,0.375,30.0,0.625,5.0,0.5,5.0,0.4166666666666667,10.0,0.7692307692307693
606,cdk,"private static T[] grow(T[] array, int required){
    int oldCapacity = array.length;
    int newCapacity = oldCapacity == 0 ? DEFAULT_CAPACITY : oldCapacity + (oldCapacity >> 1);
    if (newCapacity < required)
        newCapacity = required;
    return Arrays.copyOf(array, newCapacity);
}",grow,org/openscience/cdk/AtomContainer.java,/base/data/src/main/java/org/openscience/cdk/AtomContainer.java,"/**
     * Generic grow function, expand an array by a varried amount to have
     * enough (required) space.
     *
     * @param array    the array to expand
     * @param required the minimum required space
     * @param <T>      array type
     * @return the expanded array
     */",1415-1432,"('grow', {'INSTRUCTION': {'covered': 20, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",62.0,19.0,"Generic grow function, expand an array by a varried amount to have  enough (required) space.",Expand an array space by a fixed amount.,A generic grow function expands an array by a certain amount.,0.303764397091673,"Generic growth function, expand an array of varying amounts to have enough space (required).","private static T[] grow(T[] array, int required){
        if (array.length >= required) return array;
        T[] newArray = (T[]) Array.newInstance(array.getClass().getComponentType(), required);
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }","private static T[] grow(T[] array, int required){
        T[] newArray = (T[])Array.newInstance(array.getClass().getComponentType(), array.length + required);
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }","private static T[] grow(T[] array, int required){
        T[] newArray = (T[]) Array.newInstance(array.getClass().getComponentType(), array.length + required);
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }","private static T[] grow(T[] array, int required){
        if (array.length >= required) return array;
        T[] newArray = (T[]) Array.newInstance(array.getClass().getComponentType(), required);
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.40683611254821145,  0.3954850051709118,  0.40683611254821145,  0.4093738940598007,46.0,0.6052631578947368,45.0,0.6521739130434783,46.0,0.6052631578947368,45.0,0.6521739130434783,15.0,0.19736842105263158,0.0,0.0,15.0,0.19736842105263158,12.0,0.75,7.0,0.4375,11.0,0.6875
607,dcache,"public QualityValue<U> mapWith(Function<String, U> conversion){
    return new QualityValue(rawValue, conversion.apply(rawValue), quality);
}",mapWith,org/dcache/util/QualityValue.java,/modules/dcache/src/main/java/org/dcache/util/QualityValue.java,"/**
     * Provide a new QualityValue with the same quality but with the value mapped to a different
     * type.
     *
     * @param <U>        The new type of the value
     * @param conversion the method to convert to the new type
     * @return The mapped QualityValue.
     */",73-83,"('mapWith', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,18.0,Provide a new QualityValue with the same quality but with the value mapped to a different  type.,Returns a mapped QualityValue having the same quality but a different mapped type.,A new QualityValue with the same quality but with a different type is provided.,1.01792868897779,Provide a new QualitativeValue value with the same quality but with the value mapped to a different type.," public QualityValue<U> mapWith(Function<String, U> conversion){
        return new QualityValue<>(rawValue, conversion.apply(rawValue), quality);
    }"," public QualityValue<U> mapWith(Function<String, U> conversion){
        return new QualityValue<>(rawValue, conversion.apply(rawValue), quality);
    }"," public QualityValue<U> mapWith(Function<String, U> conversion){
        return new QualityValue<>(rawValue, conversion.apply(rawValue), quality);
    }"," public QualityValue<U> mapWith(Function<String, U> conversion){
        return new QualityValue<>(rawValue, conversion.apply(rawValue), quality);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.9021391913519002,  0.9021391913519002,  0.9021391913519002,  0.9021391913519002,2.0,0.05555555555555555,2.0,0.05555555555555555,2.0,0.05555555555555555,2.0,0.05555555555555555,0.0,0.0,0.0,0.0,0.0,0.0,9.0,0.5,2.0,0.10526315789473684,9.0,0.5
608,cdk,"private void breadthFirstSearch(IAtomContainer container, List<IAtom> sphere, List<IAtom> path) throws CDKException{
    IAtom nextAtom;
    List<IAtom> newSphere = new ArrayList<IAtom>();
    for (IAtom atom : sphere) {
        List bonds = container.getConnectedBondsList(atom);
        for (Object bond : bonds) {
            nextAtom = ((IBond) bond).getOther(atom);
            if ((container.getMaximumBondOrder(nextAtom) != IBond.Order.SINGLE || Math.abs(nextAtom.getFormalCharge()) >= 1 || nextAtom.getFlag(CDKConstants.ISAROMATIC) || nextAtom.getAtomicNumber() == IElement.N || nextAtom.getAtomicNumber() == IElement.O) & !nextAtom.getFlag(CDKConstants.VISITED)) {
                path.add(nextAtom);
                nextAtom.setFlag(CDKConstants.VISITED, true);
                if (container.getConnectedBondsCount(nextAtom) > 1) {
                    newSphere.add(nextAtom);
                }
            } else {
                nextAtom.setFlag(CDKConstants.VISITED, true);
            }
        }
    }
    if (newSphere.size() > 0) {
        breadthFirstSearch(container, newSphere, path);
    }
}",breadthFirstSearch,org/openscience/cdk/qsar/descriptors/molecular/LargestPiSystemDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/LargestPiSystemDescriptor.java,"/**
     * Performs a breadthFirstSearch in an AtomContainer starting with a
     * particular sphere, which usually consists of one start atom, and searches
     * for a pi system.
     *
     * @param container The AtomContainer to
     *                  be searched
     * @param sphere    A sphere of atoms to
     *                  start the search with
     * @param path      An array list which stores the atoms belonging to the pi system
     * @throws org.openscience.cdk.exception.CDKException
     *          Description of the
     *          Exception
     */",224-266,"('breadthFirstSearch', {'INSTRUCTION': {'covered': 102, 'missed': 0}, 'BRANCH': {'covered': 21, 'missed': 1}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 11, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",226.0,27.0,"Performs a breadthFirstSearch in an AtomContainer starting with a  particular sphere, which usually consists of one start atom, and searches  for a pi system.","Given a sphere of atoms and the AtomCointainer to be searched, performs a breadthFirstSearch in an AtomContainer.",A search for a pi system is performed in an atom container with a particular sphere and one start atom.,0.715066019209441,"Performs a breadthFirstSearch in an AtomContainer starting with a particular sphere, which usually consists of a starting atom, and looks for a pi system.",Not Valid,"private void breadthFirstSearch(IAtomContainer container, List<IAtom> sphere, List<IAtom> path) throws CDKException{
        //logger.debug(""BreadthFirstSearch"");
        if (sphere.size() == 0) {
            //logger.debug(""...... -> Sphere is empty"");
            return;
        }
        //logger.debug(""...... -> Sphere size:""+sphere.size());
        for (int i = 0; i < sphere.size(); i++) {
            //logger.debug(""...... -> Sphere atom:""+i+"" Flag:""+sphere.get(i).getFlag(CDKConstants.VISITED));
            if (!sphere.get(i).getFlag(CDKConstants.VISITED)) {
                //logger.debug(""...... -> Sphere atom:""+i+"" not visited"");
                sphere.get(i).setFlag(CDKConstants.VISITED, true);
                path.add(sphere.get(i));
                //logger.debug(""...... -> Sphere atom:""+i+"" added to path"");
                List<IAtom> newSphere = new ArrayList<IAtom>();
                for (int j = 0; j < container.getBondCount(); j++) {
                    IBond bond = container.getBond(j);
                    if (bond.contains(sphere.get(i))) {
                        for (int k = 0; k < bond.getAtomCount(); k++) {
                            if (!bond.getAtom(k).equals(sphere.get(i))) {
                                if (!bond.getAtom(k).getFlag(CDKConstants.VISITED)) {
                                    newSphere.add(bond.getAtom(k));
                                }
                            }
                        }
                    }
                }
                breadthFirstSearch(container, newSphere, path);
            }
        }       
 }",Not Valid,Not Valid,Not Valid,NOT PASS,Not Valid,Not Valid,None,  0.48833673732247085,None,None,None,None,167.0,0.6761133603238867,None,None,None,None,246.0,0.9959514170040485,None,None,None,None,23.0,0.92,3.0,0.12,21.0,0.84
609,jeromq,"public Object[] recvPicture(Socket socket, String picture){
    if (!FORMAT.matcher(picture).matches()) {
        throw new ZMQException(picture + "" is not in expected format "" + FORMAT.pattern(), ZError.EPROTO);
    }
    Object[] elements = new Object[picture.length()];
    for (int index = 0; index < picture.length(); index++) {
        char pattern = picture.charAt(index);
        switch(pattern) {
            case 'i':
                {
                    elements[index] = Integer.valueOf(socket.recvStr());
                    break;
                }
            case '1':
                {
                    elements[index] = (0xff) & Integer.valueOf(socket.recvStr());
                    break;
                }
            case '2':
                {
                    elements[index] = (0xffff) & Integer.valueOf(socket.recvStr());
                    break;
                }
            case '4':
                {
                    elements[index] = (0xffffffff) & Integer.valueOf(socket.recvStr());
                    break;
                }
            case '8':
                {
                    elements[index] = Long.valueOf(socket.recvStr());
                    break;
                }
            case 's':
                {
                    elements[index] = socket.recvStr();
                    break;
                }
            case 'b':
            case 'c':
                {
                    elements[index] = socket.recv();
                    break;
                }
            case 'f':
                {
                    elements[index] = ZFrame.recvFrame(socket);
                    break;
                }
            case 'm':
                {
                    elements[index] = ZMsg.recvMsg(socket);
                    break;
                }
            case 'z':
                {
                    ZFrame zeroFrame = ZFrame.recvFrame(socket);
                    if (zeroFrame == null || zeroFrame.size() > 0) {
                        throw new ZMQException(""zero frame is not empty"", ZError.EPROTO);
                    }
                    elements[index] = new ZFrame((byte[]) null);
                    break;
                }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    return elements;
}",recvPicture,org/zeromq/proto/ZPicture.java,/src/main/java/org/zeromq/proto/ZPicture.java,"/**
     * Receive a 'picture' message to the socket (or actor).
     *
     *
     * @param picture The picture is a string that defines the type of each frame.
     *                This makes it easy to recv a complex multiframe message in
     *                one call. The picture can contain any of these characters,
     *                each corresponding to zero or one elements in the result:
     *
     *                <table>
     *               <caption> </caption>
     *                <tr><td>i = int (stores signed integer)</td></tr>
     *                <tr><td>1 = int (stores 8-bit unsigned integer)</td></tr>
     *                <tr><td>2 = int (stores 16-bit unsigned integer)</td></tr>
     *                <tr><td>4 = long (stores 32-bit unsigned integer)</td></tr>
     *                <tr><td>8 = long (stores 64-bit unsigned integer)</td></tr>
     *                <tr><td>s = String</td></tr>
     *                <tr><td>b = byte[]</td></tr>
     *                <tr><td>f = ZFrame (creates zframe)</td></tr>
     *                <tr><td>m = ZMsg (creates a zmsg with the remaing frames)</td></tr>
     *                <tr><td>z = null, asserts empty frame (0 arguments)</td></tr>
     *                </table>
     *
     *                Also see {@link #sendPicture(Socket, String, Object...)} how to send a
     *                multiframe picture.
     *
     * @return the picture elements as object array
     */",341-430,"('recvPicture', {'INSTRUCTION': {'covered': 129, 'missed': 22}, 'BRANCH': {'covered': 16, 'missed': 5}, 'LINE': {'covered': 29, 'missed': 2}, 'COMPLEXITY': {'covered': 12, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",380.0,13.0,Receive a 'picture' message to the socket (or actor).,A picture is received through the socket. The picture is represented as a string that defines the type of each frame.,Receive a picture message to the actor.,0.150573398064978,"Receive an ""image"" message on the socket (or actor).","public Object[] recvPicture(Socket socket, String picture){
        if (!FORMAT.matcher(picture).matches()) {
            throw new ZMQException(picture + "" is not in expected format "" + FORMAT.pattern(), ZError.EPROTO);
        }
        ZMsg msg = ZMsg.recvMsg(socket);
        if (msg == null) {
            return null;
        }
        Object[] results = new Object[picture.length()];
        for (int index = 0; index < picture.length(); index++) {
            char pattern = picture.charAt(index);
            switch (pattern) {
            case 'i': {
                results[index] = msg.pop().toInt();
                break;
            }
            case '1': {
                results[index] = msg.pop().toByte();
                break;
            }
            case '2': {
                results[index] = msg.pop().toShort();
                break;
            }
            case '4': {
                results[index] = msg.pop().toInt();
                break;
            }
            case '8': {
                results[index] = msg.pop().toLong();
                break;
            }
            case 's': {
                results[index] = msg.pop().toString();
                break;
            }
            case 'b':
            case 'c': {
                results[index] = msg.pop().toByteArray();
                break;
            }
            case 'f': {
                results[index] = msg.pop();
                break;
            }
            case 'm': {
                results[index] = msg;
                break;
            }
            case 'z': {
                results[index] = null;
                break;
            }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
            }
        }
        return results;     
 }"," public Object[] recvPicture(Socket socket, String picture){
        return recvPicture(socket, picture, null);      
 }","public Object[] recvPicture(Socket socket, String picture){
        if (!FORMAT.matcher(picture).matches()) {
            throw new ZMQException(picture + "" is not in expected format "" + FORMAT.pattern(), ZError.EPROTO);
        }
        ZMsg msg = ZMsg.recvMsg(socket);
        if (msg == null) {
            return null;
        }
        Object[] results = new Object[picture.length()];
        for (int pictureIndex = 0, msgIndex = 0; pictureIndex < picture.length(); pictureIndex++, msgIndex++) {
            char pattern = picture.charAt(pictureIndex);
            switch (pattern) {
            case 'i': {
                results[pictureIndex] = Integer.parseInt(msg.popString());
                break;
            }
            case '1': {
                results[pictureIndex] = (byte) Integer.parseInt(msg.popString());
                break;
            }
            case '2': {
                results[pictureIndex] = (short) Integer.parseInt(msg.popString());
                break;
            }
            case '4': {
                results[pictureIndex] = Integer.parseInt(msg.popString());
                break;
            }
            case '8': {
                results[pictureIndex] = Long.parseLong(msg.popString());
                break;
            }
            case 's': {
                results[pictureIndex] = msg.popString();
                break;
            }
            case 'b':
            case 'c': {
                results[pictureIndex] = msg.pop();
                break;
            }
            case 'f': {
                results[pictureIndex] = ZFrame.recvFrame(socket);
                break;
            }
            case 'm': {
                results[pictureIndex] = ZMsg.recvMsg(socket);
                break;
            }
            case 'z': {
                results[pictureIndex] = null;
                msgIndex--;
                break;
            }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
            }
        }
        return results;     
 }","public Object[] recvPicture(Socket socket, String picture){
        if (!FORMAT.matcher(picture).matches()) {
            throw new ZMQException(picture + "" is not in expected format "" + FORMAT.pattern(), ZError.EPROTO);
        }
        ZMsg msg = ZMsg.recvMsg(socket);
        if (msg == null) {
            return null;
        }
        Object[] results = new Object[picture.length()];
        for (int index = 0; index < picture.length(); index++) {
            char pattern = picture.charAt(index);
            switch (pattern) {
            case 'i': {
                results[index] = Integer.parseInt(msg.popString());
                break;
            }
            case '1': {
                results[index] = (byte) Integer.parseInt(msg.popString());
                break;
            }
            case '2': {
                results[index] = (short) Integer.parseInt(msg.popString());
                break;
            }
            case '4': {
                results[index] = Integer.parseInt(msg.popString());
                break;
            }
            case '8': {
                results[index] = Long.parseLong(msg.popString());
                break;
            }
            case 's': {
                results[index] = msg.popString();
                break;
            }
            case 'b':
            case 'c': {
                results[index] = msg.pop();
                break;
            }
            case 'f': {
                results[index] = ZFrame.recvFrame(socket);
                break;
            }
            case 'm': {
                results[index] = ZMsg.recvMsg(socket);
                break;
            }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
            }
        }
        return results;     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5482847443457696,  0.043186587903839384,  0.6148937473166566,  0.5830182376259568,137.0,0.35958005249343833,359.0,0.9422572178477691,119.0,0.3123359580052493,128.0,0.3359580052493438,320.0,0.9384164222873901,58.0,0.17008797653958943,73.0,0.20277777777777778,19.0,0.8636363636363636,3.0,0.3,4.0,0.4
610,cdk,"private static boolean isIllPosed(double minMass, double maxMass, MolecularFormulaRange mfRange){
    // when the number of integers to decompose is incredible large
    // we have to adjust the internal settings (e.g. precision!)
    // instead we simply fallback to the full enumeration method
    if (maxMass - minMass >= 1)
        return true;
    if (maxMass > 400000)
        return true;
    // if the number of elements to decompose is very small
    // we fall back to the full enumeration methods as the
    // minimal decomposable mass of a certain residue class might
    // exceed the 32 bit integer space
    if (mfRange.getIsotopeCount() <= 2)
        return true;
    // if the mass of the smallest element in alphabet is large
    // it is more efficient to use the full enumeration method
    double smallestMass = Double.POSITIVE_INFINITY;
    for (IIsotope i : mfRange.isotopes()) {
        smallestMass = Math.min(smallestMass, i.getExactMass());
    }
    return smallestMass > 5;
}",isIllPosed,org/openscience/cdk/formula/MolecularFormulaGenerator.java,/tool/formula/src/main/java/org/openscience/cdk/formula/MolecularFormulaGenerator.java,"/**
     * Decides wheter to use the round robin algorithm or full enumeration algorithm.
     * The round robin implementation here is optimized for chemical elements in organic compounds. It gets slow
     * if
     * - the mass of the smallest element is very large (i.e. hydrogen is not allowed)
     * - the maximal mass to decompose is too large (round robin always decomposes integers. Therefore, the mass have
     *   to be small enough to be represented as 32 bit integer)
     * - the number of elements in the set is extremely small (in this case, however, the problem becomes trivial anyways)
     *
     * In theory we could handle these problems by optimizing the way DECOMP discretizes the masses. However, it's easier
     * to just fall back to the full enumeration method if a problem occurs (especially, because most of the problems
     * lead to trivial cases that are fast to compute).
     *
     * @return true if the problem is ill-posed (i.e. should be calculated by full enumeration method)
     */",79-114,"('isIllPosed', {'INSTRUCTION': {'covered': 46, 'missed': 2}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",89.0,13.0,Decides wheter to use the round robin algorithm or full enumeration algorithm.,"Return true if the number of elements to decompose is very small. In that case, the full enumeration algorithm will be used. Otherwise, returns false (the round robin algorithm will be used).",The round robin or full enumeration algorithm was the one that was decided on.,0.490103998132113,Decides to use the round robin algorithm or the full enumeration algorithm.,"private static boolean isIllPosed(double minMass, double maxMass, MolecularFormulaRange mfRange){
        if(mfRange.getIsotopes().size() == 1){
            return true;
        }
        if(minMass > maxMass){
            throw new IllegalArgumentException(""minMass > maxMass"");
        }
        if(minMass < 0){
            throw new IllegalArgumentException(""minMass < 0"");
        }
        if(maxMass < 0){
            throw new IllegalArgumentException(""maxMass < 0"");
        }
        if(mfRange.getIsotopes().isEmpty()){
            throw new IllegalArgumentException(""mfRange.getIsotopes().isEmpty()"");
        }
        for(IIsotope isotope : mfRange.getIsotopes()){
            if(isotope.getExactMass() == null){
                throw new IllegalArgumentException(""isotope.getExactMass() == null"");
            }
        }
        return false;
    }","private static boolean isIllPosed(double minMass, double maxMass, MolecularFormulaRange mfRange){
        int nrOfElements = 0;
        for (Isotope isotope : mfRange.getIsotopes()) {
            nrOfElements += isotope.getNrOfElements();
        }
        return nrOfElements < 5;
    }","private static boolean isIllPosed(double minMass, double maxMass, MolecularFormulaRange mfRange){
        return mfRange.getIsotopeCount() == 1 || minMass > maxMass;
    }","private static boolean isIllPosed(double minMass, double maxMass, MolecularFormulaRange mfRange){
        if(mfRange.getIsotopeCount() == 1) return false;
        if(mfRange.getIsotopeCount() == 2) return true;
        if(mfRange.getIsotopeCount() == 3) return true;
        if(mfRange.getIsotopeCount() == 4) return true;
        if(mfRange.getIsotopeCount() == 5) return true;
        if(mfRange.getIsotopeCount() == 6) return true;
        if(mfRange.getIsotopeCount() == 7) return true;
        if(mfRange.getIsotopeCount() == 8) return true;
        if(mfRange.getIsotopeCount() == 9) return true;
        if(mfRange.getIsotopeCount() == 10) return true;
        if(mfRange.getIsotopeCount() == 11) return true;
        if(mfRange.getIsotopeCount() == 12) return true;
        if(mfRange.getIsotopeCount() == 13) return true;
        if(mfRange.getIsotopeCount() == 14) return true;
        if(mfRange.getIsotopeCount() == 15) return true;
        if(mfRange.getIsotopeCount() == 16) return true;
        if(mfRange.getIsotopeCount() == 17) return true;
        if(mfRange.getIsotopeCount() == 18) return true;
        if(mfRange.getIsotopeCount() == 19) return true;
        if(mfRange.getIsotopeCount() == 20) return true;
        if(mfRange.getIsotopeCount() == 21) return true;
        if(mfRange.getIsotopeCount() == 22) return true;
        if(mfRange.getIsotopeCount() == 23) return true;
        if(mfRange.getIsotopeCount() == 24) return true;
        if(mfRange.getIsotopeCount() == 25) return true;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.41675744311000595,  0.30203956392274933,  0.334955309660062,  0.25540161304795617,84.0,0.6131386861313869,54.0,0.6,284.0,0.8304093567251462,65.0,0.7222222222222222,101.0,0.7372262773722628,262.0,0.7660818713450293,110.0,0.8029197080291971,28.0,0.8484848484848485,2.0,0.15384615384615385,14.0,0.9333333333333333
612,weblogic-kubernetes-operator,"public DomainStatus addCondition(DomainCondition newCondition){
    if (conditions.contains(newCondition)) {
        return this;
    }
    conditions = conditions.stream().filter(c -> preserve(c, newCondition.getType())).collect(Collectors.toList());
    conditions.add(newCondition);
    reason = newCondition.getStatusReason();
    message = newCondition.getStatusMessage();
    return this;
}",addCondition,oracle/kubernetes/weblogic/domain/model/DomainStatus.java,/operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainStatus.java,"/**
   * Adds a condition to the status, replacing any existing conditions with the same type, and removing other
   * conditions according to the domain rules.
   *
   * @param newCondition the condition to add.
   * @return this object.
   */",116-134,"('addCondition', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",82.0,26.0,"Adds a condition to the status, replacing any existing conditions with the same type, and removing other  conditions according to the domain rules.","Using the domain rules specification, adds a condition to the status and replaces any existing condition with the same  type while removing all the rest.","Adding a condition to the status, replacing any existing conditions with the same type, and removing other conditions according to the domain rules are all done this way.",0.500398196675479,"Adds a condition to the report, replaces all existing conditions with the same type, and removes other conditions based on domain rules."," public DomainStatus addCondition(DomainCondition newCondition){
    DomainCondition existingCondition = getCondition(newCondition.getType());
    if (existingCondition != null) {
      conditions.remove(existingCondition);
    }
    conditions.add(newCondition);
    return this;
  }"," public DomainStatus addCondition(DomainCondition newCondition){
    DomainCondition existingCondition = getCondition(newCondition.getType());
    if(existingCondition != null){
      removeCondition(existingCondition);
    }
    conditions.add(newCondition);
    return this;    
 }"," public DomainStatus addCondition(DomainCondition newCondition){
    DomainCondition existingCondition = getCondition(newCondition.getType());
    if (existingCondition != null) {
      conditions.remove(existingCondition);
    }
    conditions.add(newCondition);
    return this;
  }"," public DomainStatus addCondition(DomainCondition newCondition){
    if (newCondition == null) {
      return this;
    }
    DomainCondition existingCondition = getCondition(newCondition.getType());
    if (existingCondition != null) {
      if (existingCondition.equals(newCondition)) {
        return this;
      }
      conditions.remove(existingCondition);
    }
    conditions.add(newCondition);
    return this;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3545983802312676,  0.33878250591871956,  0.4670212142563727,  0.3654679454486589,50.0,0.6024096385542169,52.0,0.6265060240963856,47.0,0.5662650602409639,50.0,0.6024096385542169,3.0,0.06382978723404255,25.0,0.3472222222222222,0.0,0.0,18.0,0.6923076923076923,7.0,0.2916666666666667,7.0,0.2413793103448276
613,cdk,"public String toCycleString(){
    int n = this.values.length;
    boolean[] p = new boolean[n];
    Arrays.fill(p, true);
    StringBuilder sb = new StringBuilder();
    int j = 0;
    for (int i = 0; i < n; i++) {
        if (p[i]) {
            sb.append('(');
            sb.append(i);
            p[i] = false;
            j = i;
            while (p[values[j]]) {
                sb.append("", "");
                j = values[j];
                sb.append(j);
                p[j] = false;
            }
            sb.append(')');
        }
    }
    return sb.toString();
}",toCycleString,org/openscience/cdk/group/Permutation.java,/tool/group/src/main/java/org/openscience/cdk/group/Permutation.java,"/**
     * An easily-readable version of the permutation as a product of cycles.
     *
     * @return the cycle form of the permutation as a string
     */",225-253,"('toCycleString', {'INSTRUCTION': {'covered': 73, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",153.0,12.0,An easily-readable version of the permutation as a product of cycles.,This method represents an enhanced version (readability-wise) of the permutation as a product of cycles.,The permutation is a product of cycles.,0.196538138034416,An easily readable version of swapping as a product of cycles.,"public String toCycleString(){
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < values.length; i++) {
            if (values[i] != i) {
                sb.append(i).append(""->"").append(values[i]).append("" "");
            }
        }
        return sb.toString();
    }","public String toCycleString(){
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < values.length; i++) {
            if (values[i] != i) {
                sb.append(i);
                sb.append(""->"");
                sb.append(values[i]);
                sb.append("" "");
            }
        }
        return sb.toString();
    }","public String toCycleString(){
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < values.length; i++) {
            sb.append(i);
            sb.append(""->"");
            sb.append(values[i]);
            sb.append("" "");
        }
        return sb.toString();
    }","public String toCycleString(){
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < values.length; i++) {
            sb.append(i).append(""->"").append(values[i]).append("" "");
        }
        return sb.toString();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.31719828614811413,  0.34354975797495874,  0.27010065215807316,  0.3087499298601348,91.0,0.5909090909090909,85.0,0.551948051948052,97.0,0.6298701298701299,91.0,0.5909090909090909,6.0,0.07228915662650602,11.0,0.14285714285714285,17.0,0.22077922077922077,6.0,0.375,4.0,0.3333333333333333,6.0,0.5
614,matsim-libs,"public void applyConfiguration(Config config) throws ConfigurationException{
    List<String> configOptions = options.keySet().stream().filter(o -> o.startsWith(CONFIG_PREFIX + "":"")).collect(Collectors.toList());
    for (String option : configOptions) {
        processConfigOption(config, option, option.substring(CONFIG_PREFIX.length() + 1));
    }
}",applyConfiguration,org/matsim/core/config/CommandLine.java,/matsim/src/main/java/org/matsim/core/config/CommandLine.java,"/**
	 * Applies the command line configuration to a MATSim {@link Config} instance.
	 * See {@link CommandLine} for more information on the syntax.
	 * 
	 * @throws ConfigurationException
	 */",485-498,"('applyConfiguration', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",79.0,15.0,Applies the command line configuration to a MATSim {@link Config} instance.,The command line configuration is applied to the MATSim Instance.,The command line configuration can be applied to a MATSim.,0.76151875377528,Applies command-line configuration to a MATSim instance {@link Config}.," public void applyConfiguration(Config config) throws ConfigurationException{
	 		for (String option : options.keySet()) {
 			String value = options.get(option);
 
 			if (value.equals(FLAG_VALUE)) {
 				config.addParam(option, ""true"");
 			} else {
 				config.addParam(option, value);
 			}
 		}
 	}",Empty Method,"public void applyConfiguration(Config config) throws ConfigurationException{
	 		for (String option : options.keySet()) {
 			String[] parts = option.split("":"");
 
 			if (parts.length == 1) {
 				config.setParam(parts[0], options.get(option));
 			} else {
 				config.setParam(parts[0], parts[1], options.get(option));
 			}
 		}
 	}","public void applyConfiguration(Config config) throws ConfigurationException{
	 		for (String option : options.keySet()) {
 			String[] parts = option.split("":"");
 
 			if (parts.length == 1) {
 				config.setParam(parts[0], options.get(option));
 			} else {
 				config.setParam(parts[0], parts[1], options.get(option));
 			}
 		}
 	}",NOT PASS,Empty Method,NOT PASS,NOT PASS,  0.28536732160798023,None,  0.30300528447001945,  0.29213571925262816,48.0,0.6,None,None,58.0,0.651685393258427,58.0,0.651685393258427,None,None,38.0,0.42696629213483145,38.0,0.42696629213483145,8.0,0.6666666666666666,6.0,0.5,8.0,0.6666666666666666
615,cdk,"private static int[] labels(int flavour, final IAtomContainer molecule) throws CDKException{
    long[] labels = SmiFlavor.isSet(flavour, SmiFlavor.Isomeric) ? inchiNumbers(molecule) : Canon.label(molecule, GraphUtil.toAdjList(molecule), createComparator(molecule, flavour));
    int[] cpy = new int[labels.length];
    for (int i = 0; i < labels.length; i++) cpy[i] = (int) labels[i] - 1;
    return cpy;
}",labels,org/openscience/cdk/smiles/SmilesGenerator.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/SmilesGenerator.java,"/**
     * Given a molecule (possibly disconnected) compute the labels which
     * would order the atoms by increasing canonical labelling. If the SMILES
     * are isomeric (i.e. stereo and isotope specific) the InChI numbers are
     * used. These numbers are loaded via reflection and the 'cdk-inchi' module
     * should be present on the classpath.
     *
     * @param molecule the molecule to
     * @return the permutation
     * @see Canon
     */",668-689,"('labels', {'INSTRUCTION': {'covered': 35, 'missed': 3}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",107.0,20.0,Given a molecule (possibly disconnected) compute the labels which  would order the atoms by increasing canonical labelling.,Computes the label of a molecule.This will result in ordering the atoms by increasing canonical labeling.,"If a molecule is disconnected, you can use the labels to order the atoms.",0.267162395519844,"Given a molecule (possibly disconnected), calculate the labels that would order the atoms by increasing the canonical labeling.","private static int[] labels(int flavour, final IAtomContainer molecule) throws CDKException{
        int[] labels = new int[molecule.getAtomCount()];
        int[] tmp = new int[molecule.getAtomCount()];
        int[] tmp2 = new int[molecule.getAtomCount()];
        int[] tmp3 = new int[molecule.getAtomCount()];
        int[] tmp4 = new int[molecule.getAtomCount()];
        int[] tmp5 = new int[molecule.getAtomCount()];
        int[] tmp6 = new int[molecule.getAtomCount()];
        int[] tmp7 = new int[molecule.getAtomCount()];
        int[] tmp8 = new int[molecule.getAtomCount()];
        int[] tmp9 = new int[molecule.getAtomCount()];
        int[] tmp10 = new int[molecule.getAtomCount()];
        int[] tmp11 = new int[molecule.getAtomCount()];
        int[] tmp12 = new int[molecule.getAtomCount()];
        int[] tmp13 = new int[molecule.getAtomCount()];
        int[] tmp14 = new int[molecule.getAtomCount()];
        int[] tmp15 = new int[molecule.getAtomCount()];
        int[] tmp16 = new int[molecule.getAtomCount()];
        int[] tmp17 = new int[molecule.getAtomCount()];
        int[] tmp18 = new int[molecule.getAtomCount()];
        int[] tmp19 = new int[molecule.getAtomCount()];
        int[] tmp20 = new int[molecule.getAtomCount()];
        int[] tmp21 = new int[molecule.getAtomCount()];
        int[] tmp22 = new int[molecule.getAtomCount()];
        int[] tmp23 = new int[molecule.getAtomCount()];
        int[] tmp24 = new int[molecule.getAtomCount()];     
 }","private static int[] labels(int flavour, final IAtomContainer molecule) throws CDKException{
        int[] labels = new int[molecule.getAtomCount()];
        for (int i = 0; i < labels.length; i++)
            labels[i] = i;
        if (SmiFlavor.isSet(flavour, SmiFlavor.CxSmilesWithCoords)) {
            // we need to make sure we generate without the CXSMILES layers
            IAtomContainer tmp = molecule.getBuilder().newInstance(IAtomContainer.class);
            tmp.add(molecule);
            tmp.setProperty(CDKConstants.CTAB_SGROUPS, molecule.getProperty(CDKConstants.CTAB_SGROUPS));
            labels = new CanonicalRanker(tmp).getCanonicalRank();
        } else {
            labels = new CanonicalRanker(molecule).getCanonicalRank();
        }
        return labels;
    }","private static int[] labels(int flavour, final IAtomContainer molecule) throws CDKException{
        int[] labels = new int[molecule.getAtomCount()];
        if (SmiFlavor.isSet(flavour, SmiFlavor.CxSmilesWithCoords)) {
            for (int i = 0; i < labels.length; i++)
                labels[i] = i;
        } else {
            for (int i = 0; i < labels.length; i++)
                labels[i] = i;
        }
        return labels;
    }",Not Valid,NOT PASS,NOT PASS,Not Valid,NOT PASS,  0.2412057084913391,  0.5192927147172994,None,  0.46116200448376166,325.0,0.8248730964467005,100.0,0.6993006993006993,None,None,57.0,0.5277777777777778,303.0,0.7690355329949239,None,None,331.0,0.8401015228426396,12.0,0.6666666666666666,5.0,0.2631578947368421,13.0,0.7222222222222222
616,cdk,"private void addDoubleBondStereochemistry(Graph g, IAtomContainer ac){
    for (final Edge e : g.edges()) {
        if (e.bond() != Bond.DOUBLE)
            continue;
        int u = e.either();
        int v = e.other(u);
        Edge first = null;
        Edge second = null;
        if ((first = findDirectionalEdge(g, u)) != null) {
            if ((second = findDirectionalEdge(g, v)) != null) {
                Conformation conformation = first.bond(u) == second.bond(v) ? Conformation.TOGETHER : Conformation.OPPOSITE;
                IBond db = ac.getBond(ac.getAtom(u), ac.getAtom(v));
                IBond[] ligands = new IBond[] { ac.getBond(ac.getAtom(u), ac.getAtom(first.other(u))), ac.getBond(ac.getAtom(v), ac.getAtom(second.other(v))) };
                ac.addStereoElement(new DoubleBondStereochemistry(db, ligands, conformation));
            } else if (g.degree(v) == 2) {
                List<Edge> edges = new ArrayList<>();
                edges.add(e);
                Edge f = findCumulatedEdge(g, v, e);
                int beg = v;
                while (f != null) {
                    edges.add(f);
                    v = f.other(v);
                    f = findCumulatedEdge(g, v, f);
                    if (beg == v) {
                        beg = -1;
                        break;
                    }
                }
                if (beg < 0)
                    continue;
                if ((edges.size() & 0x1) == 0)
                    continue;
                second = findDirectionalEdge(g, v);
                if (second != null) {
                    int cfg = first.bond(u) == second.bond(v) ? IStereoElement.TOGETHER : IStereoElement.OPPOSITE;
                    Edge middleEdge = edges.get(edges.size() / 2);
                    IBond middleBond = ac.getBond(ac.getAtom(middleEdge.either()), ac.getAtom(middleEdge.other(middleEdge.either())));
                    IBond[] ligands = new IBond[] { ac.getBond(ac.getAtom(u), ac.getAtom(first.other(u))), ac.getBond(ac.getAtom(v), ac.getAtom(second.other(v))) };
                    ac.addStereoElement(new ExtendedCisTrans(middleBond, ligands, cfg));
                }
            }
        } else {
            Configuration uConf = g.configurationOf(u);
            Configuration vConf = g.configurationOf(v);
            if (uConf.type() == Configuration.Type.DoubleBond && vConf.type() == Configuration.Type.DoubleBond) {
                int[] nbrs = new int[6];
                int[] uNbrs = g.neighbors(u);
                int[] vNbrs = g.neighbors(v);
                if (uNbrs.length < 2 || uNbrs.length > 3)
                    continue;
                if (vNbrs.length < 2 || vNbrs.length > 3)
                    continue;
                int idx = 0;
                System.arraycopy(uNbrs, 0, nbrs, idx, uNbrs.length);
                idx += uNbrs.length;
                if (uNbrs.length == 2)
                    nbrs[idx++] = u;
                System.arraycopy(vNbrs, 0, nbrs, idx, vNbrs.length);
                idx += vNbrs.length;
                if (vNbrs.length == 2)
                    nbrs[idx] = v;
                Arrays.sort(nbrs, 0, 3);
                Arrays.sort(nbrs, 3, 6);
                int vPos = Arrays.binarySearch(nbrs, 0, 3, v);
                int uPos = Arrays.binarySearch(nbrs, 3, 6, u);
                int uhi = 0, ulo = 0;
                int vhi = 0, vlo = 0;
                uhi = nbrs[(vPos + 1) % 3];
                ulo = nbrs[(vPos + 2) % 3];
                vhi = nbrs[3 + ((uPos + 1) % 3)];
                vlo = nbrs[3 + ((uPos + 2) % 3)];
                if (uConf.shorthand() == Configuration.CLOCKWISE) {
                    int tmp = uhi;
                    uhi = ulo;
                    ulo = tmp;
                }
                if (vConf.shorthand() == Configuration.ANTI_CLOCKWISE) {
                    int tmp = vhi;
                    vhi = vlo;
                    vlo = tmp;
                }
                DoubleBondStereochemistry.Conformation conf = null;
                IBond[] bonds = new IBond[2];
                if (uhi != u) {
                    bonds[0] = ac.getBond(ac.getAtom(u), ac.getAtom(uhi));
                    if (vhi != v) {
                        conf = Conformation.TOGETHER;
                        bonds[1] = ac.getBond(ac.getAtom(v), ac.getAtom(vhi));
                    } else if (vlo != v) {
                        conf = Conformation.OPPOSITE;
                        bonds[1] = ac.getBond(ac.getAtom(v), ac.getAtom(vlo));
                    }
                } else if (ulo != u) {
                    bonds[0] = ac.getBond(ac.getAtom(u), ac.getAtom(ulo));
                    if (vhi != v) {
                        conf = Conformation.OPPOSITE;
                        bonds[1] = ac.getBond(ac.getAtom(v), ac.getAtom(vhi));
                    } else if (vlo != v) {
                        conf = Conformation.TOGETHER;
                        bonds[1] = ac.getBond(ac.getAtom(v), ac.getAtom(vlo));
                    }
                }
                ac.addStereoElement(new DoubleBondStereochemistry(ac.getBond(ac.getAtom(u), ac.getAtom(v)), bonds, conf));
            }
        }
    }
}",addDoubleBondStereochemistry,org/openscience/cdk/smiles/BeamToCDK.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/BeamToCDK.java,"/**
     * Adds double-bond conformations ({@link DoubleBondStereochemistry}) to the
     * atom-container.
     *
     * @param g  Beam graph object (for directional bonds)
     * @param ac The atom-container built from the Beam graph
     */",258-417,"('addDoubleBondStereochemistry', {'INSTRUCTION': {'covered': 515, 'missed': 2}, 'BRANCH': {'covered': 46, 'missed': 10}, 'LINE': {'covered': 99, 'missed': 2}, 'COMPLEXITY': {'covered': 19, 'missed': 10}, 'METHOD': {'covered': 1, 'missed': 0}})",1171.0,14.0,Adds double-bond conformations ({@link DoubleBondStereochemistry}) to the  atom-container.,The atom-container is enriched with double-bond conformations information.,Adds double-bonds to the atom-container.,0.533614233301549,Adds double-bonded conformations ({@link DoubleBondStereochemistry}) to the atom container.,"private void addDoubleBondStereochemistry(Graph g, IAtomContainer ac){
        for (int u = 0; u < g.order(); u++) {
            Edge e = findCumulatedEdge(g, u, null);
            if (e != null) {
                int v = e.other(u);
                IAtom au = ac.getAtom(u);
                IAtom av = ac.getAtom(v);
                IBond b = ac.getBond(au, av);
                if (b != null) {
                    b.setStereo(IBond.Stereo.UP);
                }
            }
        }
    }","private void addDoubleBondStereochemistry(Graph g, IAtomContainer ac){
        for (int u = 0; u < g.order(); u++) {
            Edge e = findCumulatedEdge(g, u, null);
            if (e != null) {
                IAtom a = ac.getAtom(u);
                IAtom b = ac.getAtom(e.other(u));
                IBond bond = ac.getBond(a, b);
                if (bond.getOrder() == IBond.Order.DOUBLE) {
                    IStereoElement se = newDoubleBondConformation(u, e, g, ac);
                    if (se != null) ac.addStereoElement(se);
                }
            }
        }
    }","private void addDoubleBondStereochemistry(Graph g, IAtomContainer ac){
        for (int u = 0; u < g.order(); u++) {
            Edge e = findCumulatedEdge(g, u, null);
            if (e != null) {
                IBond bond = ac.getBond(ac.getAtomNumber(g.atom(u)), ac.getAtomNumber(g.atom(e.other(u))));
                if (bond != null) {
                    bond.setStereo(IBond.Stereo.DOWN);
                }
            }
        }
    }","private void addDoubleBondStereochemistry(Graph g, IAtomContainer ac){
        for (int u = 0; u < g.order(); u++) {
            Edge e = findCumulatedEdge(g, u, null);
            if (e != null) {
                int v = e.other(u);
                IAtom atomU = ac.getAtom(u);
                IAtom atomV = ac.getAtom(v);
                IBond bond = ac.getBond(ac.getBondNumber(atomU, atomV));
                if (bond.getFlag(CDKConstants.ISAROMATIC)) {
                    DoubleBondStereochemistry dbs = new DoubleBondStereochemistry(bond);
                    if (g.configurationOf(u).type() == Configuration.Type.Tetrahedral) {
                        dbs.setStereo(DoubleBondStereochemistry.Stereo.ANTI_CLOCKWISE);
                    } else if (g.configurationOf(u).type() == Configuration.Type.ExtendedTetrahedral) {
                        dbs.setStereo(DoubleBondStereochemistry.Stereo.CLOCKWISE);
                    } else {
                        throw new IllegalArgumentException(""Unexpected configuration type: "" + g.configurationOf(u).type());
                    }
                    ac.addStereoElement(dbs);
                }
            }
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.11269694955736156,  0.12271187954293845,  0.14065378786435598,  0.11093796648648599,1080.0,0.9215017064846417,1069.0,0.9121160409556314,1019.0,0.8694539249146758,1084.0,0.9249146757679181,49.0,0.3684210526315789,112.0,0.5209302325581395,32.0,0.2807017543859649,8.0,0.8888888888888888,3.0,0.3,4.0,0.4444444444444444
617,cdk,"public void previsit(Collection<? extends IRenderingElement> elements){
    Deque<IRenderingElement> queue = new ArrayDeque<>(2 * elements.size());
    queue.addAll(elements);
    FreqMap<Color> strokeFreq = new FreqMap<>();
    FreqMap<Color> fillFreq = new FreqMap<>();
    FreqMap<Double> strokeWidthFreq = new FreqMap<>();
    while (!queue.isEmpty()) {
        IRenderingElement element = queue.poll();
        // wrappers first
        if (element instanceof Bounds) {
            queue.add(((Bounds) element).root());
        } else if (element instanceof MarkedElement) {
            queue.add(((MarkedElement) element).element());
        } else if (element instanceof ElementGroup) {
            for (IRenderingElement child : (ElementGroup) element) queue.add(child);
        } else if (element instanceof LineElement) {
            strokeFreq.add(((LineElement) element).color);
            strokeWidthFreq.add(scaled(((LineElement) element).width));
        } else if (element instanceof GeneralPath) {
            if (((GeneralPath) element).fill)
                fillFreq.add(((GeneralPath) element).color);
        } else {
            // ignored
        }
    }
    if (!defaultsWritten) {
        defaultFill = fillFreq.getMostFrequent();
        defaultStroke = strokeFreq.getMostFrequent();
        Double strokeWidth = strokeWidthFreq.getMostFrequent();
        if (strokeWidth != null)
            defaultStrokeWidth = toStr(strokeWidth);
    }
}",previsit,org/openscience/cdk/depict/SvgDrawVisitor.java,/app/depict/src/main/java/org/openscience/cdk/depict/SvgDrawVisitor.java,"/**
     * Pre-visit allows us to prepare the visitor for more optimal output.
     * Currently we
     * - find the most common stoke/fill/stroke-width values and set these as defaults
     *
     * @param elements elements to be visited
     */",215-258,"('previsit', {'INSTRUCTION': {'covered': 127, 'missed': 0}, 'BRANCH': {'covered': 16, 'missed': 4}, 'LINE': {'covered': 28, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",297.0,12.0,Pre-visit allows us to prepare the visitor for more optimal output.,Improves the output by implementing an ad-hoc previsit strategy for the visitor.,Pre-visit allows us to prepare the visitor for more.,0.543733127241395,The pre-visit allows us to prepare the visitor for a more optimal performance.," public void previsit(Collection<? extends IRenderingElement> elements){
        for (IRenderingElement element : elements) {
            element.accept(this);
        }
    }"," public void previsit(Collection<? extends IRenderingElement> elements){
        for (IRenderingElement element : elements) {
            if (element instanceof IRenderingElement) {
                previsit((IRenderingElement) element);
            }
        }
    }"," public void previsit(Collection<? extends IRenderingElement> elements){
        // nothing to do        
 }"," public void previsit(Collection<? extends IRenderingElement> elements){
        // nothing to do
    }",PASS,NOT PASS,PASS,PASS,  0.039296756553702065,  0.07746045900125786,  0.027878274698335426,  0.027878274698335426,271.0,0.9093959731543624,263.0,0.8825503355704698,283.0,0.9496644295302014,283.0,0.9496644295302014,12.0,0.3,16.0,0.5161290322580645,16.0,0.5161290322580645,12.0,0.9230769230769231,4.0,0.2857142857142857,3.0,0.25
618,matsim-libs,"private boolean eitherLinkIsShorterThanThreshold(Link linkA, Link linkB, double thresholdLength){
    boolean hasShortLink = false;
    if (linkA.getLength() < thresholdLength || linkB.getLength() < thresholdLength) {
        hasShortLink = true;
    }
    return hasShortLink;
}",eitherLinkIsShorterThanThreshold,org/matsim/core/network/algorithms/NetworkSimplifier.java,/matsim/src/main/java/org/matsim/core/network/algorithms/NetworkSimplifier.java,"/**
	 * Quick check to see whether <i>either</i> the links are shorter than the 
	 * given threshold.
	 * @param linkA
	 * @param linkB
	 * @param thresholdLength
	 * @return true if <i>either</i> links are shorter than the given threshold, 
	 * false otherwise. 
	 */",310-325,"('eitherLinkIsShorterThanThreshold', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,21.0,Quick check to see whether <i>either</i> the links are shorter than the   given threshold.,Checks the length of the <i> either </i> links by comparing these with a given threshold.,Check to see if the links are shorter than the threshold.,0.257368532855515,Quickly check <i>if the</i> links are shorter than the given threshold.," private boolean eitherLinkIsShorterThanThreshold(Link linkA, Link linkB, double thresholdLength){
	 		boolean hasOneShortLink = false;
 		if(linkA.getLength() < thresholdLength || linkB.getLength() < thresholdLength){
 			hasOneShortLink = true;
 		}
 		return hasOneShortLink;
 	}"," private boolean eitherLinkIsShorterThanThreshold(Link linkA, Link linkB, double thresholdLength){
	 		boolean hasOneShortLink = false;
 		if(linkA.getLength() < thresholdLength || linkB.getLength() < thresholdLength){
 			hasOneShortLink = true;
 		}
 		return hasOneShortLink;
 	}",Empty Method," private boolean eitherLinkIsShorterThanThreshold(Link linkA, Link linkB, double thresholdLength){
	 boolean hasOneShortLink = false;
	 if(linkA.getLength() < thresholdLength || linkB.getLength() < thresholdLength){
		 hasOneShortLink = true;
	 }
	 return hasOneShortLink;
 }",NOT PASS,NOT PASS,NOT PASS,Empty Method,  0.9191898817277393,  0.9191898817277393,  0.9191898817277393,None,3.0,0.0625,3.0,0.0625,3.0,0.0625,None,None,0.0,0.0,0.0,0.0,None,None,13.0,0.7647058823529411,6.0,0.4,5.0,0.3333333333333333
619,cdk,"private boolean map(){
    if ((n == state.nMax() || m == state.mMax()) && !stack.empty())
        state.remove(n = stack.popN(), m = stack.popM());
    while ((m = state.nextM(n, m)) < state.mMax()) {
        if (state.add(n, m)) {
            stack.push(n, m);
            n = state.nextN(-1);
            m = -1;
            return n < state.nMax();
        }
    }
    return state.size() > 0 || m < state.mMax();
}",map,org/openscience/cdk/isomorphism/StateStream.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StateStream.java,"/**
     * Progress the state-machine - the function return false when a mapping is
     * found on the mapping is done.
     *
     * @return the state is partial
     */",95-117,"('map', {'INSTRUCTION': {'covered': 93, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",141.0,19.0,Progress the state-machine - the function return false when a mapping is  found on the mapping is done.,Returns true whether the size of the state is greater than 0 or the state is completed.,"When a mapping is done, the function return false.",0.263734048420747,Advance the state machine - the function returns false when a mapping is found on the mapping is performed.,Empty Method,"private boolean map(){
        if (state.size() == 0) return false;
        if (state.isCompleted()) return false;
        if (state.size() == state.nMax()) return false;
        if (state.size() == state.mMax()) return false;
        if (state.size() == state.nMax() + state.mMax()) return false;
        if (state.size() == state.nMax() + state.mMax() + 1) return false;
        if (state.size() == state.nMax() + state.mMax() + 2) return false;
        if (state.size() == state.nMax() + state.mMax() + 3) return false;
        if (state.size() == state.nMax() + state.mMax() + 4) return false;
        if (state.size() == state.nMax() + state.mMax() + 5) return false;
        if (state.size() == state.nMax() + state.mMax() + 6) return false;
        if (state.size() == state.nMax() + state.mMax() + 7) return false;
        if (state.size() == state.nMax() + state.mMax() + 8) return false;
        if (state.size() == state.nMax() + state.mMax() + 9) return false;
        if (state.size() == state.nMax() + state.mMax() + 10) return false;
        if (state.size() == state.nMax() + state.mMax() + 11) return false;
        if (state.size() == state.nMax() + state.mMax() + 12) return false;
        if (state.size() == state.nMax() + state.mMax() + 13) return false;
        if (state.size() == state.nMax() + state.mMax() + 14) return false;
        if (state.size() == state.nMax() + state.mMax() + 15) return false;
        if (state.size() == state.nMax() + state.mMax() + 16) return false;     
 }",Not Valid,Not Valid,Empty Method,NOT PASS,Not Valid,Not Valid,None,  0.3051860297645047,None,None,None,None,401.0,0.820040899795501,None,None,None,None,488.0,0.9979550102249489,None,None,None,None,15.0,0.7894736842105263,5.0,0.25,14.0,0.7368421052631579
620,cdk,"private static boolean has3DCoordinates(List<IBond> bonds){
    for (IBond bond : bonds) {
        if (bond.getBegin().getPoint3d() == null || bond.getEnd().getPoint3d() == null)
            return false;
    }
    return true;
}",has3DCoordinates,org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,"/**
     * Check if all atoms in the bond list have 3D coordinates. There is some
     * redundant checking but the list will typically be short.
     *
     * @param bonds the bonds to check
     * @return whether all atoms have 2D coordinates
     */",306-318,"('has3DCoordinates', {'INSTRUCTION': {'covered': 21, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,12.0,Check if all atoms in the bond list have 3D coordinates.,Checks whether all the atoms in the bond list have 3D coordinates.,"If all the atoms in the bond list have 3D coordinates, you should check them.",0.245116276778342,Check if all the atoms in the list of bonds have 3D coordinates.,"private static boolean has3DCoordinates(List<IBond> bonds){
        for (IBond bond : bonds) {
            if (bond.getBegin().getPoint3d() == null || bond.getEnd().getPoint3d() == null) return false;
        }
        return true;
    }","private static boolean has3DCoordinates(List<IBond> bonds){
        for (IBond bond : bonds) {
            if (bond.getBegin().getPoint3d() == null || bond.getEnd().getPoint3d() == null) return false;
        }
        return true;
    }","private static boolean has3DCoordinates(List<IBond> bonds){
        for (IBond bond : bonds) {
            if (bond.getBegin().getPoint3d() == null || bond.getEnd().getPoint3d() == null) return false;
        }
        return true;
    }","private static boolean has3DCoordinates(List<IBond> bonds){
        for (IBond bond : bonds) {
            if (bond.getBegin().getPoint3d() == null || bond.getEnd().getPoint3d() == null) return false;
        }
        return true;
    }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.23076923076923078,4.0,0.2857142857142857,8.0,0.5
621,dcache,"private boolean hasAuthorisationSubsumedBy(Authorisation other){
    EnumSet<Activity> disallowedOtherActivities = EnumSet.complementOf(other.activities);
    return authorisations.stream().anyMatch(ap -> disallowedOtherActivities.containsAll(EnumSet.complementOf(ap.activities)) && other.getPath().hasPrefix(ap.getPath()));
}",hasAuthorisationSubsumedBy,org/dcache/auth/attributes/MultiTargetedRestriction.java,/modules/common/src/main/java/org/dcache/auth/attributes/MultiTargetedRestriction.java,"/**
     * Return true iff this restriction has an Authorisation that is subsumed by other.
     */",176-185,"('hasAuthorisationSubsumedBy', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,14.0,Return true iff this restriction has an Authorisation that is subsumed by other.,Returns false when the current restriction does not have Authorisation subsumed by others.,Return true if the restriction has an Authorisation subsumed by other.,1.0002962127686,Return true if this restriction has a permission that is subsumed by others.,"private boolean hasAuthorisationSubsumedBy(Authorisation other){
        return authorisations.stream()
            .anyMatch(ap -> ap.compareTo(other) <= 0);
    }"," private boolean hasAuthorisationSubsumedBy(Authorisation other){
        for (Authorisation authorisation : authorisations) {
            if (authorisation.equals(other)) {
                return true;
            }
        }
        return false;
    }"," private boolean hasAuthorisationSubsumedBy(Authorisation other){
        return authorisations.stream()
            .anyMatch(ap -> ap.getPath().equals(other.getPath())
                    && ap.getActivity().containsAll(other.getActivity()));
    }"," private boolean hasAuthorisationSubsumedBy(Authorisation other){
        return authorisations.stream()
            .anyMatch(ap -> ap.getPath().equals(other.getPath())
                    && ap.getActivity().containsAll(other.getActivity()));
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2807479420142793,  0.189458673506341,  0.5021466455126714,  0.5021466455126714,39.0,0.5909090909090909,47.0,0.7121212121212122,27.0,0.4090909090909091,27.0,0.4090909090909091,21.0,0.5833333333333334,24.0,0.46153846153846156,24.0,0.46153846153846156,11.0,0.7857142857142857,4.0,0.2857142857142857,4.0,0.2857142857142857
622,cdk,"private static List<String> extractInfo(String str){
    int beg = 0;
    int end = 0;
    int len = str.length();
    List<String> parts = new ArrayList<>();
    while (end < len && !Character.isSpaceChar(str.charAt(end))) end++;
    parts.add(str.substring(beg, end));
    while (end < len && Character.isSpaceChar(str.charAt(end))) end++;
    beg = end;
    while (end < len && !Character.isSpaceChar(str.charAt(end))) end++;
    parts.add(str.substring(beg, end));
    return parts;
}",extractInfo,org/openscience/cdk/qsar/descriptors/atomic/ProtonAffinityHOSEDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/ProtonAffinityHOSEDescriptor.java,"/**
     * Extract the information from a line which contains HOSE_ID & energy.
     *
     * @param str  String with the information
     * @return     List with String = HOSECode and String = energy
     */",307-328,"('extractInfo', {'INSTRUCTION': {'covered': 59, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",145.0,12.0,Extract the information from a line which contains HOSE_ID & energy.,Retrieve the needed information from all those lines containing HOSE_ID and energy.,The information is contained in a line.,0.172731220973627,Extract information from a line that contains HOSE_ID and energy.," private static List<String> extractInfo(String str){
        List<String> values = new ArrayList<>();
        StringTokenizer st = new StringTokenizer(str, "" "");
        while (st.hasMoreTokens()) {
            values.add(st.nextToken());
        }
        return values;
    }"," private static List<String> extractInfo(String str){
        List<String> values = new ArrayList<>();
        StringTokenizer st = new StringTokenizer(str, "" "");
        while (st.hasMoreTokens()) {
            values.add(st.nextToken());
        }
        return values;
    }"," private static List<String> extractInfo(String str){
        List<String> values = new ArrayList<>();
        StringTokenizer st = new StringTokenizer(str, "" "");
        while (st.hasMoreTokens()) {
            values.add(st.nextToken());
        }
        return values;
    }"," private static List<String> extractInfo(String str){
        List<String> values = new ArrayList<>();
        StringTokenizer st = new StringTokenizer(str, "" "");
        while (st.hasMoreTokens()) {
            values.add(st.nextToken());
        }
        return values;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.19785665934272473,  0.19785665934272473,  0.19785665934272473,  0.19785665934272473,100.0,0.684931506849315,100.0,0.684931506849315,100.0,0.684931506849315,100.0,0.684931506849315,0.0,0.0,0.0,0.0,0.0,0.0,7.0,0.5384615384615384,3.0,0.25,10.0,0.8333333333333334
623,mybatis-3,"public static void addImplClass(Class<? extends VFS> clazz){
    if (clazz != null) {
        USER_IMPLEMENTATIONS.add(clazz);
    }
}",addImplClass,org/apache/ibatis/io/VFS.java,/src/main/java/org/apache/ibatis/io/VFS.java,"/**
   * Adds the specified class to the list of {@link VFS} implementations. Classes added in this
   * manner are tried in the order they are added and before any of the built-in implementations.
   *
   * @param clazz The {@link VFS} implementation class to add.
   */",91-101,"('addImplClass', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,15.0,Adds the specified class to the list of {@link VFS} implementations.,A new class is added to the list of {@link VFS} implementations.,The specified class is added to the list of VFS implementations.,0.513934578911856,Adds the specified class to the list of implementations {@link VFS}.," public static void addImplClass(Class<? extends VFS> clazz){
    USER_IMPLEMENTATIONS.add(clazz);    
 }"," public static void addImplClass(Class<? extends VFS> clazz){
    USER_IMPLEMENTATIONS.add(clazz);    
 }"," public static void addImplClass(Class<? extends VFS> clazz){
    USER_IMPLEMENTATIONS.add(clazz);    
 }"," public static void addImplClass(Class<? extends VFS> clazz){
    USER_IMPLEMENTATIONS.add(clazz);    
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6975476135051996,  0.6975476135051996,  0.6975476135051996,  0.6975476135051996,8.0,0.25806451612903225,8.0,0.25806451612903225,8.0,0.25806451612903225,8.0,0.25806451612903225,0.0,0.0,0.0,0.0,0.0,0.0,5.0,0.38461538461538464,3.0,0.25,6.0,0.5
624,cdk,"public List<IAtomType> possibleAtomTypes(IAtomContainer atomContainer, IAtom atom) throws CDKException{
    if (factory == null) {
        try {
            factory = AtomTypeFactory.getInstance(""org/openscience/cdk/config/data/structgen_atomtypes.xml"", atom.getBuilder());
        } catch (Exception ex1) {
            logger.error(ex1.getMessage());
            logger.debug(ex1);
            throw new CDKException(""Could not instantiate the AtomType list!"", ex1);
        }
    }
    double bondOrderSum = atomContainer.getBondOrderSum(atom);
    IBond.Order maxBondOrder = atomContainer.getMaximumBondOrder(atom);
    int charge = atom.getFormalCharge();
    int hcount = atom.getImplicitHydrogenCount();
    List<IAtomType> matchingTypes = new ArrayList<IAtomType>();
    IAtomType[] types = factory.getAtomTypes(atom.getSymbol());
    for (IAtomType type : types) {
        logger.debug(""   ... matching atom "", atom, "" vs "", type);
        if (bondOrderSum - charge + hcount <= type.getBondOrderSum() && !BondManipulator.isHigherOrder(maxBondOrder, type.getMaxBondOrder())) {
            matchingTypes.add(type);
        }
    }
    logger.debug(""    No Match"");
    return matchingTypes;
}",possibleAtomTypes,org/openscience/cdk/atomtype/StructGenAtomTypeGuesser.java,/tool/structgen/src/main/java/org/openscience/cdk/atomtype/StructGenAtomTypeGuesser.java,"/**
     * Finds the AtomType matching the Atom's element symbol, formal charge and
     * hybridization state.
     *
     * @param  atomContainer  AtomContainer
     * @param  atom            the target atom
     * @exception CDKException Exception thrown if something goes wrong
     * @return                 the matching AtomType
     */",57-96,"('possibleAtomTypes', {'INSTRUCTION': {'covered': 92, 'missed': 14}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 17, 'missed': 4}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",216.0,16.0,"Finds the AtomType matching the Atom's element symbol, formal charge and  hybridization state.","Given an Atom as input, checks whether the AtomType matches the Atom's element symbol. Returns the matches AtomType","The Atom's element symbol, formal charge and hybridization state are found by this.",0.339592057858739,"Finds the AtomType corresponding to the element symbol, formal load, and hybridization state of the Atom.","public List<IAtomType> possibleAtomTypes(IAtomContainer atomContainer, IAtom atom) throws CDKException{
      List<IAtomType> atomTypes = new ArrayList<IAtomType>();
      String symbol = atom.getSymbol();
      int formalCharge = atom.getFormalCharge();
      int implicitHydrogenCount = atom.getImplicitHydrogenCount();
      int bondCount = atomContainer.getConnectedBondsCount(atom);
      int bondOrderSum = 0;
      for (IBond bond : atomContainer.getConnectedBondsList(atom)) {
          bondOrderSum += BondManipulator.getOrder(bond);
      }
      if (factory == null) {
          factory = AtomTypeFactory.getInstance();
      }
      IAtomType type = factory.getAtomType(symbol, formalCharge, implicitHydrogenCount, bondCount, bondOrderSum);
      if (type != null) {
          atomTypes.add(type);
      }
      return atomTypes; 
 }","public List<IAtomType> possibleAtomTypes(IAtomContainer atomContainer, IAtom atom) throws CDKException{
      List<IAtomType> atomTypes = new ArrayList<IAtomType>();
      IAtomType atomType = null;
      String symbol = atom.getSymbol();
      int formalCharge = atom.getFormalCharge();
      int implicitHydrogenCount = atom.getImplicitHydrogenCount();
      int bondCount = atomContainer.getConnectedBondsCount(atom);
      int bondOrderSum = 0;
      for (IBond bond : atomContainer.getConnectedBondsList(atom)) {
          bondOrderSum += BondManipulator.getOrder(bond);
      }
      if (factory == null) {
          factory = AtomTypeFactory.getInstance();
      }
      atomType = factory.getAtomType(symbol, formalCharge, implicitHydrogenCount, bondCount, bondOrderSum);
      if (atomType != null) {
          atomTypes.add(atomType);
      }
      return atomTypes; 
 }","public List<IAtomType> possibleAtomTypes(IAtomContainer atomContainer, IAtom atom) throws CDKException{
      List<IAtomType> atomTypes = new ArrayList<IAtomType>();
      String symbol = atom.getSymbol();
      int formalCharge = atom.getFormalCharge();
      int implicitHydrogenCount = atom.getImplicitHydrogenCount();
      int bondOrderSum = 0;
      for (IBond bond : atomContainer.getConnectedBondsList(atom)) {
          bondOrderSum += BondManipulator.order(bond);
      }
      if (factory == null) {
          factory = AtomTypeFactory.getInstance(StructGenAtomTypeGuesser.class);
      }
      IAtomType type = factory.getAtomType(symbol, formalCharge, implicitHydrogenCount, bondOrderSum);
      if (type != null) {
          atomTypes.add(type);
      }
      return atomTypes;
  }","public List<IAtomType> possibleAtomTypes(IAtomContainer atomContainer, IAtom atom) throws CDKException{
      List<IAtomType> atomTypes = new ArrayList<IAtomType>();
      String symbol = atom.getSymbol();
      int formalCharge = atom.getFormalCharge();
      int implicitHydrogenCount = atom.getImplicitHydrogenCount();
      int bondOrderSum = 0;
      for (IBond bond : atomContainer.getConnectedBondsList(atom)) {
          bondOrderSum += BondManipulator.order(bond);
      }
      if (factory == null) {
          factory = AtomTypeFactory.getInstance(StructGenAtomTypeGuesser.class);
      }
      IAtomType type = factory.getAtomType(symbol, formalCharge, implicitHydrogenCount, bondOrderSum);
      if (type != null) {
          atomTypes.add(type);
      }
      return atomTypes;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.39718779892509726,  0.38059731942529396,  0.3653193580631743,  0.3653193580631743,144.0,0.663594470046083,148.0,0.6820276497695853,144.0,0.663594470046083,144.0,0.663594470046083,9.0,0.058823529411764705,16.0,0.10738255033557047,16.0,0.10738255033557047,14.0,0.7368421052631579,8.0,0.47058823529411764,10.0,0.7142857142857143
625,cdk,"public double resolveOverlap(IAtomContainer ac, IRingSet sssr){
    Vector overlappingAtoms = new Vector();
    Vector overlappingBonds = new Vector();
    logger.debug(""Start of resolveOverlap"");
    double overlapScore = getOverlapScore(ac, overlappingAtoms, overlappingBonds);
    if (overlapScore > 0) {
        overlapScore = displace(ac, overlappingAtoms, overlappingBonds);
    }
    logger.debug(""overlapScore = "" + overlapScore);
    logger.debug(""End of resolveOverlap"");
    return overlapScore;
}",resolveOverlap,org/openscience/cdk/layout/OverlapResolver.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/OverlapResolver.java,"/**
     * Main method to be called to resolve overlap situations.
     *
     * @param  ac    The atomcontainer in which the atom or bond overlap exists
     * @param  sssr  A ring set for this atom container if one exists, otherwhise null
     */",63-81,"('resolveOverlap', {'INSTRUCTION': {'covered': 42, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",85.0,10.0,Main method to be called to resolve overlap situations.,"In case of overlap, call the main method to resolve such an overlap.",The main method to resolve overlap situations is called.,1.37656541704012,The primary method to call to resolve overlap situations.,"public double resolveOverlap(IAtomContainer ac, IRingSet sssr){
        double maxOverlap = 0.0;
        for (int i = 0; i < maxSteps; i++) {
            maxOverlap = resolveOverlapStep(ac, sssr);
            if (maxOverlap == 0.0) break;
        }
        return maxOverlap;      
 }","public double resolveOverlap(IAtomContainer ac, IRingSet sssr){
        double step = 0.1;
        double stepSize = 0.1;
        double maxDistance = 0.0;
        double distance = 0.0;
        double maxDistance2 = 0.0;
        double distance2 = 0.0;
        double maxDistance3 = 0.0;
        double distance3 = 0.0;
        double maxDistance4 = 0.0;
        double distance4 = 0.0;
        double maxDistance5 = 0.0;
        double distance5 = 0.0;
        double maxDistance6 = 0.0;
        double distance6 = 0.0;
        double maxDistance7 = 0.0;
        double distance7 = 0.0;
        double maxDistance8 = 0.0;
        double distance8 = 0.0;
        double maxDistance9 = 0.0;
        double distance9 = 0.0;
        double maxDistance10 = 0.0;
        double distance10 = 0.0;
        double maxDistance11 = 0.0;
        double distance11 = 0.0;
        double maxDistance12 = 0.0;
        double distance12 = 0.0;
        double maxDistance13 = 0.0;
        double distance13 = 0.0;
        double maxDistance14 = 0.0;
        double distance14 = 0.0;
        double maxDistance15 = 0.0;
        double distance15 = 0.0;
        double maxDistance16 = 0.0;
        double distance16 = 0.0;
        double maxDistance17 = 0.0;
        double distance17 = 0.0;
        double maxDistance18 = 0.0;
        double distance18 = 0.0;
        double maxDistance19 = 0.0;
        double distance19 = 0.0;
        double maxDistance20 = 0.0;
        double distance20 = 0.0;
        double maxDistance21 = 0.0;
        double distance21 = 0.0;
        double maxDistance22 = 0.0;
        double distance22 = 0.0;
        double maxDistance23 = 0.0;
        double distance23 = 0.0;        
 }","public double resolveOverlap(IAtomContainer ac, IRingSet sssr){
        double overlap = 0.0;
        double step = 0.0;
        double maxOverlap = 0.0;
        double maxStep = 0.0;
        double maxOverlapStep = 0.0;
        double maxOverlapStep2 = 0.0;
        double maxOverlapStep3 = 0.0;
        double maxOverlapStep4 = 0.0;
        double maxOverlapStep5 = 0.0;
        double maxOverlapStep6 = 0.0;
        double maxOverlapStep7 = 0.0;
        double maxOverlapStep8 = 0.0;
        double maxOverlapStep9 = 0.0;
        double maxOverlapStep10 = 0.0;
        double maxOverlapStep11 = 0.0;
        double maxOverlapStep12 = 0.0;
        double maxOverlapStep13 = 0.0;
        double maxOverlapStep14 = 0.0;
        double maxOverlapStep15 = 0.0;
        double maxOverlapStep16 = 0.0;
        double maxOverlapStep17 = 0.0;
        double maxOverlapStep18 = 0.0;
        double maxOverlapStep19 = 0.0;
        double maxOverlapStep20 = 0.0;
        double maxOverlapStep21 = 0.0;
        double maxOverlapStep22 = 0.0;
        double maxOverlapStep23 = 0.0;
        double maxOverlapStep24 = 0.0;
        double maxOverlapStep25 = 0.0;
        double maxOverlapStep26 = 0.0;
        double maxOverlapStep27 = 0.0;
        double maxOverlapStep28 = 0.0;
        double maxOverlapStep29 = 0.0;
        double maxOverlapStep30 = 0.0;
        double maxOverlapStep31 = 0.0;
        double maxOverlapStep32 = 0.0;
        double maxOverlapStep33 = 0.0;
        double maxOverlapStep34 = 0.0;
        double maxOverlapStep35 = 0.0;
        double maxOverlapStep       
 }","public double resolveOverlap(IAtomContainer ac, IRingSet sssr){
        double energy = 0.0;
        double step = 0.0;
        double delta = 0.0;
        double deltaMax = 0.0;
        double deltaMin = 0.0;
        double deltaOld = 0.0;
        double deltaNew = 0.0;
        double deltaSum = 0.0;
        double deltaAvg = 0.0;
        double deltaSqSum = 0.0;
        double deltaSqAvg = 0.0;
        double deltaSq = 0.0;
        double deltaSqOld = 0.0;
        double deltaSqNew = 0.0;
        double deltaSqSumOld = 0.0;
        double deltaSqSumNew = 0.0;
        double deltaSqAvgOld = 0.0;
        double deltaSqAvgNew = 0.0;
        double deltaSqAvgSum = 0.0;
        double deltaSqAvgSumOld = 0.0;
        double deltaSqAvgSumNew = 0.0;
        double deltaSqAvgSumAvg = 0.0;
        double deltaSqAvgSumAvgOld = 0.0;
        double deltaSqAvgSumAvgNew = 0.0;
        double deltaSqAvgSumAvgSum = 0.0;
        double deltaSqAvgSumAvgSumOld = 0.0;
        double deltaSqAvgSumAvgSumNew = 0.0;
        double deltaSqAvgSumAvgSumAvg = 0.0;
        double deltaSqAvgSumAvgSumAvgOld = 0.0;
        double deltaSqAvgSumAvgSumAvgNew = 0.0;
        double deltaSqAvgSumAvgSumAvgSum = 0.0;
        double deltaSqAvgSumAvgSumAvgSumOld = 0.0;
        double deltaSqAvgSumAvgSumAvgSumNew = 0.0;
        double deltaSqAvgSumAvgSumAvgSumAvg = 0.0;
        double deltaSqAvgSumAvgSumAvgSumAvgOld = 0.0;
        double deltaSqAvgSumAvgSumAvgSumAvgNew = 0.0;
        double deltaSqAvgSumAvgSumAvg       
 }",NOT PASS,NOT PASS,Syntax Error,Syntax Error,  0.22838135999067888,  0.11137037079586364,None,None,56.0,0.6511627906976745,227.0,0.8972332015810277,169.0,0.8666666666666667,184.0,0.8761904761904762,228.0,0.9011857707509882,170.0,0.8717948717948718,184.0,0.8761904761904762,11.0,0.7857142857142857,4.0,0.4,8.0,0.8
626,cdk,"private IsotopePattern cleanAbundance(IsotopePattern isopattern, double minIntensity){
    double intensity, biggestIntensity = 0.0f;
    for (IsotopeContainer sc : isopattern.getIsotopes()) {
        intensity = sc.getIntensity();
        if (intensity > biggestIntensity)
            biggestIntensity = intensity;
    }
    for (IsotopeContainer sc : isopattern.getIsotopes()) {
        intensity = sc.getIntensity();
        intensity /= biggestIntensity;
        if (intensity < 0)
            intensity = 0;
        sc.setIntensity(intensity);
    }
    IsotopePattern sortedIsoPattern = new IsotopePattern();
    sortedIsoPattern.setMonoIsotope(new IsotopeContainer(isopattern.getIsotopes().get(0)));
    for (int i = 1; i < isopattern.getNumberOfIsotopes(); i++) {
        if (isopattern.getIsotopes().get(i).getIntensity() >= (minIntensity)) {
            IsotopeContainer container = new IsotopeContainer(isopattern.getIsotopes().get(i));
            sortedIsoPattern.addIsotope(container);
        }
    }
    return sortedIsoPattern;
}",cleanAbundance,org/openscience/cdk/formula/IsotopePatternGenerator.java,/tool/formula/src/main/java/org/openscience/cdk/formula/IsotopePatternGenerator.java,"/**
     * Normalize the intensity (relative abundance) of all isotopes in relation
     * of the most abundant isotope.
     *
     * @param isopattern   The IsotopePattern object
     * @param minIntensity The minimum abundance
     * @return             The IsotopePattern cleaned
     */",254-292,"('cleanAbundance', {'INSTRUCTION': {'covered': 94, 'missed': 2}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",191.0,18.0,Normalize the intensity (relative abundance) of all isotopes in relation  of the most abundant isotope.,The most abundant isotope is used to normalize the intensity of all the isotopes.,Normalize the intensity of all the isotopes in relation to the most abundant.,1.13532177420255,Normalize the intensity (relative abundance) of all isotopes relative to the most abundant isotope.," private IsotopePattern cleanAbundance(IsotopePattern isopattern, double minIntensity){
        if (isopattern == null) return null;
        IsotopePattern isoPattern = new IsotopePattern();
        IsotopeContainer mostAbundant = null;
        for (IsotopeContainer container : isopattern.getIsotopes()) {
            if (mostAbundant == null || container.getIntensity() > mostAbundant.getIntensity())
                mostAbundant = container;
        }
        if (mostAbundant == null) return isoPattern;
        for (IsotopeContainer container : isopattern.getIsotopes()) {
            if (container.getIntensity() / mostAbundant.getIntensity() > minIntensity)
                isoPattern.addIsotope(container);
        }
        return isoPattern;
    }"," private IsotopePattern cleanAbundance(IsotopePattern isopattern, double minIntensity){
        if (isopattern == null) return null;
        IsotopePattern isoPattern = new IsotopePattern();
        for (IsotopeContainer container : isopattern.getIsotopes()) {
            if (container.getIntensity() > minIntensity) {
                isoPattern.addIsotope(container);
            }
        }
        return isoPattern;
    }"," private IsotopePattern cleanAbundance(IsotopePattern isopattern, double minIntensity){
        if (isopattern == null) return null;
        IsotopePattern isoPattern = new IsotopePattern();
        for (IsotopeContainer container : isopattern.getIsotopes()) {
            if (container.getIntensity() > minIntensity)
                isoPattern.addIsotope(container);
        }
        return isoPattern;
    }","private IsotopePattern cleanAbundance(IsotopePattern isopattern, double minIntensity){
        if (isopattern == null) return null;
        IsotopePattern isoPattern = new IsotopePattern();
        double maxIntensity = 0;
        for (IsotopeContainer container : isopattern.getIsotopes()) {
            if (container.getIntensity() > maxIntensity)
                maxIntensity = container.getIntensity();
        }
        for (IsotopeContainer container : isopattern.getIsotopes()) {
            if (container.getIntensity() / maxIntensity > minIntensity)
                isoPattern.addIsotope(container);
        }
        return isoPattern;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3412259410923681,  0.25249978163221104,  0.3381415863914682,  0.2474166947164717,122.0,0.6354166666666666,140.0,0.7291666666666666,126.0,0.65625,142.0,0.7395833333333334,56.0,0.4745762711864407,27.0,0.2288135593220339,55.0,0.4661016949152542,14.0,0.875,3.0,0.1875,6.0,0.375
627,cdk,"public static Model molecule2Model(IAtomContainer molecule){
    Model model = createCDKModel();
    Resource subject = model.createResource(createIdentifier(model, molecule));
    model.add(subject, RDF.type, CDK.MOLECULE);
    Map<IAtom, Resource> cdkToRDFAtomMap = new HashMap<IAtom, Resource>();
    for (IAtom atom : molecule.atoms()) {
        Resource rdfAtom = model.createResource(createIdentifier(model, atom));
        cdkToRDFAtomMap.put(atom, rdfAtom);
        model.add(subject, CDK.HASATOM, rdfAtom);
        if (atom instanceof IPseudoAtom) {
            model.add(rdfAtom, RDF.type, CDK.PSEUDOATOM);
            serializePseudoAtomFields(model, rdfAtom, (IPseudoAtom) atom);
        } else {
            model.add(rdfAtom, RDF.type, CDK.ATOM);
            serializeAtomFields(model, rdfAtom, atom);
        }
    }
    for (IBond bond : molecule.bonds()) {
        Resource rdfBond = model.createResource(createIdentifier(model, bond));
        model.add(rdfBond, RDF.type, CDK.BOND);
        for (IAtom atom : bond.atoms()) {
            model.add(rdfBond, CDK.BINDSATOM, cdkToRDFAtomMap.get(atom));
        }
        if (bond.getOrder() != null) {
            model.add(rdfBond, CDK.HASORDER, order2Resource(bond.getOrder()));
        }
        model.add(subject, CDK.HASBOND, rdfBond);
        serializeElectronContainerFields(model, rdfBond, bond);
    }
    return model;
}",molecule2Model,org/openscience/cdk/libio/jena/Convertor.java,/storage/iordf/src/main/java/org/openscience/cdk/libio/jena/Convertor.java,"/**
     * Converts a {@link IAtomContainer} into a {@link Model} representation using the CDK OWL.
     *
     * @param molecule {@link IAtomContainer} to serialize into a RDF graph.
     * @return the RDF graph representing the {@link IAtomContainer}.
     */",65-101,"('molecule2Model', {'INSTRUCTION': {'covered': 140, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 26, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",308.0,20.0,Converts a {@link IAtomContainer} into a {@link Model} representation using the CDK OWL.,"By using the CDK OWL representation, translates a {@link IAtomContainer} to a {@link Model}.",The CDK OWL is used to convert a @link IAtomContainer into a @link Model representation.,0.935437543989431,Converts an {@link IAtomContainer} to a {@link Model} representation using the OWL CDK.,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,13.0,0.8666666666666667,4.0,0.2857142857142857,14.0,0.875
628,dcache,"public P selectByAvailableSpace(List<P> pools, long filesize, Function<P, PoolCostInfo> getCost){
    int length = pools.size();
    double[] available = new double[length];
    double minLoad = Double.POSITIVE_INFINITY;
    for (int i = 0; i < length; i++) {
        PoolCostInfo info = getCost.apply(pools.get(i));
        double free = getAvailable(info.getSpaceInfo(), filesize);
        if (free > 0) {
            available[i] = free;
            minLoad = Math.min(minLoad, getLoad(info));
        }
    }
    if (minLoad == Double.POSITIVE_INFINITY) {
        return null;
    }
    double sum = 0.0;
    for (int i = 0; i < length; i++) {
        PoolCostInfo info = getCost.apply(pools.get(i));
        double normalizedLoad = getLoad(info) - minLoad;
        double weightedAvailable = getWeightedAvailable(info, available[i], normalizedLoad);
        sum += weightedAvailable;
        available[i] = sum;
    }
    double threshold = random() * sum;
    for (int i = 0; i < length; i++) {
        if (threshold < available[i]) {
            return pools.get(i);
        }
    }
    if (sum == Double.POSITIVE_INFINITY) {
        throw new IllegalStateException(""WASS overflow: Configured space cost factor ("" + spaceCostFactor + "") is too large."");
    }
    throw new RuntimeException(""Unreachable statement."");
}",selectByAvailableSpace,org/dcache/poolmanager/WeightedAvailableSpaceSelection.java,/modules/dcache/src/main/java/org/dcache/poolmanager/WeightedAvailableSpaceSelection.java,"/**
     * Selects a pool from a list using the WASS algorithm.
     * <p/>
     * Returns null if all pools are full.
     */",216-271,"('selectByAvailableSpace', {'INSTRUCTION': {'covered': 108, 'missed': 16}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 22, 'missed': 3}, 'COMPLEXITY': {'covered': 6, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",281.0,11.0,Selects a pool from a list using the WASS algorithm.,Uses the WASS algorithm to pick a pool from the list of pools given as input.,The WASS algorithm is used to select a pool.,0.726843314238114,Selects a pool from a list using the WASS algorithm.,"public P selectByAvailableSpace(List<P> pools, long filesize, Function<P, PoolCostInfo> getCost){
        double bestAvailable = 0;
        P bestPool = null;
        for (P pool : pools) {
            PoolCostInfo info = getCost.apply(pool);
            double available = getAvailable(info.getSpaceInfo(), filesize);
            if (available > bestAvailable) {
                bestAvailable = available;
                bestPool = pool;
            }
        }
        return bestPool;        
 }","public P selectByAvailableSpace(List<P> pools, long filesize, Function<P, PoolCostInfo> getCost){
        double bestAvailable = 0;
        P bestPool = null;
        for (P pool : pools) {
            PoolCostInfo info = getCost.apply(pool);
            double available = getAvailable(info.getSpaceInfo(), filesize);
            if (available > bestAvailable) {
                bestAvailable = available;
                bestPool = pool;
            }
        }
        return bestPool;        
 }","public P selectByAvailableSpace(List<P> pools, long filesize, Function<P, PoolCostInfo> getCost){
        double bestAvailable = 0;
        P bestPool = null;
        for (P pool : pools) {
            PoolCostInfo info = getCost.apply(pool);
            double available = getAvailable(info.getSpaceInfo(), filesize);
            double load = getLoad(info);
            double weightedAvailable = getWeightedAvailable(info, available, load);
            if (weightedAvailable > bestAvailable) {
                bestAvailable = weightedAvailable;
                bestPool = pool;
            }
        }
        return bestPool;        
 }","public P selectByAvailableSpace(List<P> pools, long filesize, Function<P, PoolCostInfo> getCost){
        double bestAvailable = 0;
        P bestPool = null;
        for (P pool : pools) {
            PoolCostInfo info = getCost.apply(pool);
            double available = getAvailable(info.getSpaceInfo(), filesize);
            double load = getLoad(info);
            double weightedAvailable = getWeightedAvailable(info, available, load);
            if (weightedAvailable > bestAvailable) {
                bestAvailable = weightedAvailable;
                bestPool = pool;
            }
        }
        return bestPool;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.1937357800199443,  0.1937357800199443,  0.23235127959272356,  0.23235127959272356,214.0,0.7588652482269503,214.0,0.7588652482269503,201.0,0.7127659574468085,201.0,0.7127659574468085,0.0,0.0,22.0,0.20754716981132076,22.0,0.20754716981132076,12.0,0.7058823529411765,0.0,0.0,10.0,0.9090909090909091
629,jeromq,"public long timeout(){
    final long now = now();
    for (Entry<Timer, Long> entry : entries()) {
        final Timer timer = entry.getKey();
        final Long expiration = entry.getValue();
        if (timer.alive) {
            if (expiration - now > 0) {
                return expiration - now;
            } else {
                return 0;
            }
        }
        timers.remove(expiration, timer);
    }
    return -1;
}",timeout,zmq/util/Timers.java,/src/main/java/zmq/util/Timers.java,"/**
     * Returns the time in millisecond until the next timer.
     * @return the time in millisecond until the next timer.
     */",173-199,"('timeout', {'INSTRUCTION': {'covered': 41, 'missed': 7}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 2}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",93.0,10.0,Returns the time in millisecond until the next timer.,The timeout duration is returned in millisecond.,The time is returned in a second.,0.214134626518953,Returns the time in milliseconds to the next timer.,"public long timeout(){
        final long now = now();
        final Entry<Long, Timer> entry = timers.firstEntry();
        if (entry == null) {
            return -1;
        }
        final long next = entry.getKey();
        return next - now;
    }"," public long timeout(){
        return now() - timers.firstKey();
    }","public long timeout(){
        return now() + 1000;
    }","public long timeout(){
        final long now = now();
        final Entry<Long, Timer> entry = timers.firstEntry();
        if (entry == null) {
            return -1;
        }
        final long next = entry.getKey();
        return next - now;      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.37412414402040906,  0.11909590755470065,  0.37412414402040906,  0.10311479539369746,54.0,0.574468085106383,77.0,0.8191489361702128,54.0,0.574468085106383,81.0,0.8617021276595744,42.0,0.7241379310344828,0.0,0.0,46.0,0.7931034482758621,9.0,0.9,2.0,0.2,8.0,0.8
630,dcache,"public boolean equals(Object otherObject){
    if (!(otherObject instanceof StatePath)) {
        return false;
    }
    if (otherObject == this) {
        return true;
    }
    StatePath otherPath = (StatePath) otherObject;
    if (otherPath._elements.size() != _elements.size()) {
        return false;
    }
    for (int i = 0; i < _elements.size(); i++) {
        if (otherPath._elements.get(i) != _elements.get(i)) {
            return false;
        }
    }
    return true;
}",equals,org/dcache/services/info/base/StatePath.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StatePath.java,"/**
     * Check whether another path points to the same location.
     *
     * @param otherPath: the other path to compare
     * @return: whether the other path point to the same location.
     */",135-165,"('equals', {'INSTRUCTION': {'covered': 44, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",109.0,10.0,Check whether another path points to the same location.,"Returns true if the path points to the same location, false otherwise.","If another path points to the same location, check it.",0.339326755688063,Check if another path points to the same location.," public boolean equals(Object otherObject){
        if (otherObject == null) {
            return false;
        }
    
        if (otherObject instanceof StatePath) {
            StatePath otherPath = (StatePath) otherObject;
            return _elements.equals(otherPath._elements);
        }
    
        return false;       
 }","public boolean equals(Object otherObject){
        if (otherObject == null) {
            return false;
        }
    
        if (otherObject instanceof StatePath) {
            StatePath otherPath = (StatePath) otherObject;
    
            if (otherPath._elements.size() != _elements.size()) {
                return false;
            }
    
            for (int i = 0; i < _elements.size(); i++) {
                if (!_elements.get(i).equals(otherPath._elements.get(i))) {
                    return false;
                }
            }
    
            return true;
        }
    
        return false;
    }","public boolean equals(Object otherObject){
        if (otherObject == null) {
            return false;
        }
    
        if (otherObject == this) {
            return true;
        }
    
        if (!(otherObject instanceof StatePath)) {
            return false;
        }
    
        StatePath otherPath = (StatePath) otherObject;
    
        if (otherPath._elements.size() != _elements.size()) {
            return false;
        }
    
        for (int i = 0; i < _elements.size(); i++) {
            if (!_elements.get(i).equals(otherPath._elements.get(i))) {
                return false;
            }
        }
    
        return true;        
 }","public boolean equals(Object otherObject){
        if (otherObject == null) {
            return false;
        }
    
        if (otherObject == this) {
            return true;
        }
    
        if (!(otherObject instanceof StatePath)) {
            return false;
        }
    
        StatePath otherPath = (StatePath) otherObject;
    
        if (otherPath._elements.size() != _elements.size()) {
            return false;
        }
    
        for (int i = 0; i < _elements.size(); i++) {
            if (!_elements.get(i).equals(otherPath._elements.get(i))) {
                return false;
            }
        }
    
        return true;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2833143226604614,  0.7334161010378052,  0.7844957403304049,  0.7844957403304049,66.0,0.6,23.0,0.2072072072072072,27.0,0.216,27.0,0.216,61.0,0.5495495495495496,76.0,0.608,76.0,0.608,7.0,0.5384615384615384,1.0,0.1,5.0,0.45454545454545453
631,cdk,"private static void arcConstructor(CDKRGraph graph, IAtomContainer ac1, IAtomContainer ac2) throws CDKException{
    for (int i = 0; i < graph.getGraph().size(); i++) {
        CDKRNode rNodeX = graph.getGraph().get(i);
        rNodeX.getForbidden().set(i);
    }
    IBond bondA1;
    IBond bondA2;
    IBond bondB1;
    IBond bondB2;
    graph.setFirstGraphSize(ac1.getBondCount());
    graph.setSecondGraphSize(ac2.getBondCount());
    for (int i = 0; i < graph.getGraph().size(); i++) {
        CDKRNode rNodeX = graph.getGraph().get(i);
        for (int j = i + 1; j < graph.getGraph().size(); j++) {
            CDKRNode rNodeY = graph.getGraph().get(j);
            bondA1 = ac1.getBond(graph.getGraph().get(i).getRMap().getId1());
            bondA2 = ac2.getBond(graph.getGraph().get(i).getRMap().getId2());
            bondB1 = ac1.getBond(graph.getGraph().get(j).getRMap().getId1());
            bondB2 = ac2.getBond(graph.getGraph().get(j).getRMap().getId2());
            if (bondA2 instanceof IQueryBond) {
                if (bondA1.equals(bondB1) || bondA2.equals(bondB2) || !queryAdjacencyAndOrder(bondA1, bondB1, bondA2, bondB2)) {
                    rNodeX.getForbidden().set(j);
                    rNodeY.getForbidden().set(i);
                } else if (hasCommonAtom(bondA1, bondB1)) {
                    rNodeX.getExtension().set(j);
                    rNodeY.getExtension().set(i);
                }
            } else {
                if (bondA1.equals(bondB1) || bondA2.equals(bondB2) || (!getCommonSymbol(bondA1, bondB1).equals(getCommonSymbol(bondA2, bondB2)))) {
                    rNodeX.getForbidden().set(j);
                    rNodeY.getForbidden().set(i);
                } else if (hasCommonAtom(bondA1, bondB1)) {
                    rNodeX.getExtension().set(j);
                    rNodeY.getExtension().set(i);
                }
            }
        }
    }
}",arcConstructor,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,"/**
     *  Build edges of the RGraphs
     *  This method create the edge of the CDKRGraph and
     *  calculates the incompatibility and neighbourhood
     *  relationships between CDKRGraph nodes.
     *
     * @param  graph   the rGraph
     * @param  ac1   first molecule. Must not be an IQueryAtomContainer.
     * @param  ac2   second molecule. May be an IQueryAtomContainer.
     * @throws org.openscience.cdk.exception.CDKException if it takes too long to get the overlaps
     */",837-898,"('arcConstructor', {'INSTRUCTION': {'covered': 176, 'missed': 0}, 'BRANCH': {'covered': 24, 'missed': 0}, 'LINE': {'covered': 29, 'missed': 0}, 'COMPLEXITY': {'covered': 13, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",474.0,24.0,Build edges of the RGraphs  This method create the edge of the CDKRGraph and  calculates the incompatibility and neighbourhood  relationships between CDKRGraph nodes.,Computes the incompatibility and neighborhood relationships between CDKRGraph nodes by creating a new edge  of type CDKRGraph.,The method builds the edges of the RGraphs and calculates the incompatibility and neighbourhood relationships between the CDKRGraph and the other RGraphs.,0.308610363987383,Construct RGraph edges This method creates the CDKRGraph edge and calculates the incompatibility and neighborhood relationships between the CDKRGraph nodes.,"private static void arcConstructor(CDKRGraph graph, IAtomContainer ac1, IAtomContainer ac2) throws CDKException{
        // for each node in the graph
        for (int i = 0; i < graph.getNodeCount(); i++) {
            CDKRNode node1 = graph.getNode(i);
            IBond bond1 = ac1.getBond(node1.getId1());
            IBond bond2 = ac2.getBond(node1.getId2());
            IAtom[] atom1 = BondManipulator.getAtomArray(bond1);
            IAtom[] atom2 = BondManipulator.getAtomArray(bond2);
            for (int j = 0; j < 2; j++) {
                List<IBond> bondsConnectedToAtom1j = ac1.getConnectedBondsList(atom1[j]);
                for (int k = 0; k < bondsConnectedToAtom1j.size(); k++) {
                    if (!bondsConnectedToAtom1j.get(k).equals(bond1)) {
                        IBond testBond = bondsConnectedToAtom1j.get(k);
                        for (int m = 0; m < graph.getNodeCount(); m++) {
                            CDKRNode node2 = graph.getNode(m);
                            IBond bond3 = ac2.getBond(node2.getId2());
                            IAtom[] atom3 = BondManipulator.getAtomArray(bond3);
                            for (int n = 0; n < 2; n++) {
                                List<IBond> bondsToTest = ac2.getConnectedBondsList(atom3[n]);
                                if (bondsToTest.contains(bond3)) {
                                    if (j == n) {
                                        graph.addArc(new CDKRArc(i, m, node1.getId1(), node2.getId2()));
                                    } else {
                                        graph.addArc(new CDKRArc(i, m, node1.getId1(), node2.getId2()));
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }       
 }","private static void arcConstructor(CDKRGraph graph, IAtomContainer ac1, IAtomContainer ac2) throws CDKException{
        for (int i = 0; i < graph.getNodeCount(); i++) {
            CDKRNode node1 = graph.getNode(i);
            IBond bond1 = ac1.getBond(node1.getId1());
            IBond bond2 = ac2.getBond(node1.getId2());
            IAtom[] atom1 = BondManipulator.getAtomArray(bond1);
            IAtom[] atom2 = BondManipulator.getAtomArray(bond2);
            for (int j = 0; j < 2; j++) {
                List<IBond> bondsConnectedToAtom1j = ac1.getConnectedBondsList(atom1[j]);
                for (int k = 0; k < bondsConnectedToAtom1j.size(); k++) {
                    if (!bondsConnectedToAtom1j.get(k).equals(bond1)) {
                        IBond testBond = bondsConnectedToAtom1j.get(k);
                        for (int m = 0; m < graph.getNodeCount(); m++) {
                            CDKRNode node2 = graph.getNode(m);
                            IBond testBond2 = ac2.getBond(node2.getId2());
                            IAtom[] atom3 = BondManipulator.getAtomArray(testBond2);
                            for (int n = 0; n < 2; n++) {
                                List<IBond> bondsToTest = ac2.getConnectedBondsList(atom3[n]);
                                if (bondsToTest.contains(testBond2)) {
                                    CDKRGraph.addEdge(node1, node2);
                                }
                            }
                        }
                    }
                }
            }
        }       
 }","private static void arcConstructor(CDKRGraph graph, IAtomContainer ac1, IAtomContainer ac2) throws CDKException{
        // for each node in the target graph
        for (int i = 0; i < graph.getNodeCount(); i++) {
            CDKRNode node = graph.getNode(i);
            IBond bondA1 = ac1.getBond(node.getId1());
            IBond bondA2 = ac2.getBond(node.getId2());
            // if the bond is a query bond
            if (bondA2 instanceof IQueryBond) {
                IQueryBond queryBond = (IQueryBond) bondA2;
                IQueryAtom atom1 = (IQueryAtom) (bondA2.getBegin());
                IQueryAtom atom2 = (IQueryAtom) (bondA2.getEnd());
                if (queryBond.matches(bondA1)) {
                    // ok, bonds match
                    if (atom1.matches(bondA1.getBegin()) && atom2.matches(bondA1.getEnd())
                            || atom1.matches(bondA1.getEnd()) && atom2.matches(bondA1.getBegin())) {
                        // ok, atoms match in either order
                        graph.addArc(new CDKRArc(i, i));
                    }
                }
            } else {
                // if both bonds are compatible then create an association node
                // in the resolution graph
                if (isMatchFeasible(ac1, bondA1, ac2, bondA2, true)) {
                    graph.addArc(new CDKRArc(i, i));
                }
            }
        }       
 }",Not Valid,NOT PASS,NOT PASS,Not Valid,NOT PASS,  0.36221183886665953,  0.33226878658766845,None,  0.31103144954057904,315.0,0.6631578947368421,330.0,0.6947368421052632,None,None,326.0,0.6863157894736842,57.0,0.1676470588235294,None,None,199.0,0.5852941176470589,21.0,0.875,12.0,0.5,14.0,0.5833333333333334
632,dataverse,"Optional<AbstractOAuth2AuthenticationProvider> parseStateFromRequest(@NotNull String state){
    if (state == null || state.trim().equals("""")) {
        logger.log(Level.INFO, ""No state present in request"");
        return Optional.empty();
    }
    String[] topFields = state.split(""~"", 2);
    if (topFields.length != 2) {
        logger.log(Level.INFO, ""Wrong number of fields in state string"", state);
        return Optional.empty();
    }
    AbstractOAuth2AuthenticationProvider idp = authenticationSvc.getOAuth2Provider(topFields[0]);
    if (idp == null) {
        logger.log(Level.INFO, ""Can''t find IDP ''{0}''"", topFields[0]);
        return Optional.empty();
    }
    String raw = StringUtil.decrypt(topFields[1], idp.clientSecret);
    String[] stateFields = raw.split(""~"", -1);
    if (idp.getId().equals(stateFields[0])) {
        long timeOrigin = Long.parseLong(stateFields[1]);
        long timeDifference = this.clock.millis() - timeOrigin;
        if (timeDifference > 0 && timeDifference < STATE_TIMEOUT) {
            if (stateFields.length > 3) {
                this.redirectPage = Optional.ofNullable(stateFields[3]);
            }
            return Optional.of(idp);
        } else {
            logger.info(""State timeout"");
            return Optional.empty();
        }
    } else {
        logger.log(Level.INFO, ""Invalid id field: ''{0}''"", stateFields[0]);
        return Optional.empty();
    }
}",parseStateFromRequest,edu/harvard/iq/dataverse/authorization/providers/oauth2/OAuth2LoginBackingBean.java,/src/main/java/edu/harvard/iq/dataverse/authorization/providers/oauth2/OAuth2LoginBackingBean.java,"/**
     * Parse and verify the state returned from the provider.
     *
     * As it contains the providers implementation ""id"" field when send by us,
     * we can return the corresponding provider object.
     *
     * This function is not side effect free: it will (if present) set {@link #redirectPage}
     * to the value received from the state.
     *
     * @param state The state string, created in  {@link #createState(AbstractOAuth2AuthenticationProvider, Optional)}, send and returned by provider
     * @return A corresponding provider object when state verification succeeded.
     */",156-204,"('parseStateFromRequest', {'INSTRUCTION': {'covered': 112, 'missed': 0}, 'BRANCH': {'covered': 15, 'missed': 1}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",301.0,10.0,Parse and verify the state returned from the provider.,"Checks, whether the state returned from the provider is parsable and sound.",Parse the state back from the provider.,0.112405884244875,Analyze and check the status returned by the provider.,Not Valid,"Optional<AbstractOAuth2AuthenticationProvider> parseStateFromRequest(@NotNull String state){
        try {
            String[] parts = state.split(""\\|"");
            if (parts.length != 3) {
                error = new OAuth2Exception(-1, """", ""Invalid state parameter."");
                logger.log(Level.INFO, ""OAuth2Exception getting state parameter. HTTP return code: {0}. Message: {1} Message body: {2}"", new Object[]{error.getHttpReturnCode(), error.getLocalizedMessage(), error.getMessageBody()});
                return Optional.empty();
            }
            String idpId = parts[0];
            String redirectPage = parts[1];
            String stateTime = parts[2];
            long time = Long.parseLong(stateTime);
            if (clock.getCurrentTimeMillis() - time > STATE_TIMEOUT) {
                error = new OAuth2Exception(-1, """", ""State parameter expired."");
                logger.log(Level.INFO, ""OAuth2Exception getting state parameter. HTTP return code: {0}. Message: {1} Message body: {2}"", new Object[]{error.getHttpReturnCode(), error.getLocalizedMessage(), error.getMessageBody()});
                return Optional.empty();
            }
            return Optional.of(authenticationSvc.getOAuth2Provider(idpId));
        } catch (NumberFormatException e) {
            error = new OAuth2Exception(-1, """", ""Invalid state parameter."");
            logger.log(Level.INFO, ""OAuth2Exception getting state parameter. HTTP return code: {0}. Message: {1} Message body: {2}"", new Object[]{error.getHttpReturnCode(), error.getLocalizedMessage(), error.getMessageBody()});
            return Optional.empty();
        }       
 }","Optional<AbstractOAuth2AuthenticationProvider> parseStateFromRequest(@NotNull String state){
        try {
            String[] parts = state.split(""\\|"");
            if (parts.length != 3) {
                error = new OAuth2Exception(-1, """", ""Could not parse OAuth2 state."");
                logger.log(Level.WARNING, ""OAuth2Exception parsing state. State: {0}"", state);
                return Optional.empty();
            }
            String idpId = parts[0];
            String redirectPage = parts[1];
            String stateTime = parts[2];
            long stateTimeLong = Long.parseLong(stateTime);
            if (clock.getCurrentTimeMillis() - stateTimeLong > STATE_TIMEOUT) {
                error = new OAuth2Exception(-1, """", ""OAuth2 state has expired."");
                logger.log(Level.WARNING, ""OAuth2Exception parsing state. State: {0}"", state);
                return Optional.empty();
            }
            return Optional.of(authenticationSvc.getOAuth2Provider(idpId));
        } catch (NumberFormatException ex) {
            error = new OAuth2Exception(-1, """", ""Could not parse OAuth2 state."");
            logger.log(Level.WARNING, ""OAuth2Exception parsing state. State: {0}"", state);
            return Optional.empty();
        }
    }","Optional<AbstractOAuth2AuthenticationProvider> parseStateFromRequest(@NotNull String state){
        try {
            String[] parts = state.split(""\\|"");
            if (parts.length != 3) {
                error = new OAuth2Exception(-1, """", ""Could not parse OAuth2 state."");
                logger.log(Level.WARNING, ""OAuth2Exception parsing state. State: {0}"", state);
                return Optional.empty();
            }
            String idpId = parts[0];
            String redirectPage = parts[1];
            String stateTime = parts[2];
            long stateTimeLong = Long.parseLong(stateTime);
            long now = clock.millis();
            if (now - stateTimeLong > STATE_TIMEOUT) {
                error = new OAuth2Exception(-1, """", ""OAuth2 state has expired."");
                logger.log(Level.WARNING, ""OAuth2Exception parsing state. State: {0}"", state);
                return Optional.empty();
            }
            return Optional.of(authenticationSvc.getOAuth2Provider(idpId));
        } catch (NumberFormatException ex) {
            error = new OAuth2Exception(-1, """", ""Could not parse OAuth2 state."");
            logger.log(Level.WARNING, ""OAuth2Exception parsing state. State: {0}"", state);
            return Optional.empty();
        }
    }",Not Valid,NOT PASS,NOT PASS,NOT PASS,None,  0.3711422948645007,  0.35435308140965116,  0.3460850941307261,None,None,221.0,0.7317880794701986,197.0,0.652317880794702,199.0,0.6589403973509934,271.0,0.9963235294117647,210.0,0.995260663507109,205.0,0.9951456310679612,8.0,0.6153846153846154,4.0,0.4,3.0,0.3
633,cdk,"public int parity(){
    // create three vectors, v->u, v->w and u->x
    double[] vu = toVector(v, u);
    double[] vw = toVector(v, w);
    double[] ux = toVector(u, x);
    // normal vector (to compare against), the normal vector (n) looks like:
    // x     n w
    // \    |/
    // u = v
    double[] normal = crossProduct(vu, crossProduct(vu, vw));
    // compare the dot products of v->w and u->x, if the signs are the same
    // they are both pointing the same direction. if a value is close to 0
    // then it is at pi/2 radians (i.e. unspecified) however 3D coordinates
    // are generally discrete and do not normally represent on unspecified
    // stereo configurations so we don't check this
    int parity = (int) Math.signum(dot(normal, vw)) * (int) Math.signum(dot(normal, ux));
    // invert sign, this then matches with Sp2 double bond parity
    return parity * -1;
}",parity,org/openscience/cdk/hash/stereo/DoubleBond3DParity.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/DoubleBond3DParity.java,"/**
     * Calculate the configuration of the double bond as a parity.
     *
     * @return opposite (+1), together (-1)
     */",63-91,"('parity', {'INSTRUCTION': {'covered': 40, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",99.0,11.0,Calculate the configuration of the double bond as a parity.,Computes the configuration of the double bond as a parity.,The double bond has a configuration.,0.482424056307313,Calculate the dual link configuration as parity.,Empty Method,Empty Method,"public int parity(){
        // the parity is the sign of the determinant of the 3x3 matrix
        //
        //  | u.x  u.y  u.z |
        //  | v.x  v.y  v.z |
        //  | x.x  x.y  x.z |
        //
        //  | w.x  w.y  w.z |
        //  | v.x  v.y  v.z |
        //  | u.x  u.y  u.z |
        //
        //  | x.x  x.y  x.z |
        //  | w.x  w.y  w.z |
        //  | v.x  v.y  v.z |
        //
        //  | u.x  u.y  u.z |
        //  | w.x  w.y  w.z |
        //  | x.x  x.y  x.z |
        //
        //  | v.x  v.y  v.z |
        //  | u.x  u.y  u.z |
        //  | w.x  w.y  w.z |
        //
        //  | x.x  x.y  x.z |
        //  | v.x  v.y  v.z |
        //  | w.x  w.y  w.z |
        //
        //  | w.x  w.y  w.z |
        //  | x.x  x.y  x.z |
        //  | u.x  u.y  u.z |
        //
        //  | v.x  v.y  v.z |
        //  | w.x  w.y  w.z |
        //  | u.x  u.y  u.z |
        //
        //  | x.x  x.y  x.z |
        //  | w.x  w.y  w.z |
        //  | v.x  v.y      
 }","public int parity(){
        // calculate the angle between the double bond and the substituent
        double angle = angle(u, v, x);
        double angle2 = angle(u, v, w);
    
        // if the angle is greater than 90 degrees then the substituents are on
        // opposite sides
        if (angle > Math.PI / 2 && angle2 > Math.PI / 2)
            return +1;
        // if the angle is less than 90 degrees then the substituents are on the
        // same side
        if (angle < Math.PI / 2 && angle2 < Math.PI / 2)
            return -1;
    
        // if the angle is greater than 90 degrees then the substituents are on
        // opposite sides
        if (angle > Math.PI / 2 && angle2 < Math.PI / 2)
            return -1;
        // if the angle is less than 90 degrees then the substituents are on the
        // same side
        if (angle < Math.PI / 2 && angle2 > Math.PI / 2)
            return +1;
    
        // if the angle is greater than 90 degrees then the substituents are on
        // opposite sides
        if (angle > Math.PI / 2 && angle2 > Math.PI / 2)
            return +1;
        // if the angle is less than 90 degrees then the substituents are on the
        // same side
        if (angle < Math.PI / 2 && angle2 < Math.PI / 2)
            return -1;
    
        // if the angle is greater than 90 degrees then the substituents are on
        // opposite sides
        if (angle > Math.PI / 2 && angle2 < Math.PI / 2)
            return -1;
        // if the angle is less than 90 degrees then the substituents are on the
        // same side
        if (angle < Math.PI / 2 && angle2 > Math.PI / 2)
            return +1;
    
        // if the angle is greater than 90 degrees then the substituents are on
        // opposite sides
        if (angle > Math.PI / 2 && angle2 > Math.PI / 2)        
 }",Empty Method,Empty Method,Syntax Error,NOT PASS,None,None,None,  0.052376768665946,None,None,None,None,190.0,0.8407079646017699,92.0,0.92,None,None,225.0,0.995575221238938,7.0,0.875,1.0,0.09090909090909091,6.0,0.5454545454545454,7.0,0.6363636363636364
634,cdk,"public static Partition fromString(String strForm){
    if (strForm == null || strForm.isEmpty())
        throw new IllegalArgumentException(""null or empty string provided"");
    Partition p = new Partition();
    int index = 0;
    if (strForm.charAt(0) == '[') {
        index++;
    }
    int endIndex;
    if (strForm.charAt(strForm.length() - 1) == ']') {
        endIndex = strForm.length() - 2;
    } else {
        endIndex = strForm.length() - 1;
    }
    int currentCell = -1;
    int numStart = -1;
    while (index <= endIndex) {
        char c = strForm.charAt(index);
        if (Character.isDigit(c)) {
            if (numStart == -1) {
                numStart = index;
            }
        } else if (c == ',') {
            int element = Integer.parseInt(strForm.substring(numStart, index));
            if (currentCell == -1) {
                p.addCell(element);
                currentCell = 0;
            } else {
                p.addToCell(currentCell, element);
            }
            numStart = -1;
        } else if (c == '|') {
            int element = Integer.parseInt(strForm.substring(numStart, index));
            if (currentCell == -1) {
                p.addCell(element);
                currentCell = 0;
            } else {
                p.addToCell(currentCell, element);
            }
            currentCell++;
            p.addCell();
            numStart = -1;
        }
        index++;
    }
    int lastElement = Integer.parseInt(strForm.substring(numStart, endIndex + 1));
    p.addToCell(currentCell, lastElement);
    return p;
}",fromString,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,"/**
     * Parse a string like ""[0,2|1,3]"" to form the partition; cells are
     * separated by '|' characters and elements within the cell by commas.
     *
     * @param strForm the partition in string form
     * @return the partition corresponding to the string
     * @throws IllegalArgumentException thrown if the provided strFrom is
     *         null or empty
     */",442-500,"('fromString', {'INSTRUCTION': {'covered': 136, 'missed': 5}, 'BRANCH': {'covered': 19, 'missed': 3}, 'LINE': {'covered': 36, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",326.0,29.0,"Parse a string like ""[0,2|1,3]"" to form the partition; cells are  separated by '|' characters and elements within the cell by commas.",Creates a new partition by parsing the string given as input.,"Cells are separated by characters and elements within the cell by commas if youParse a string like ""[0,2|1,3]"" to form the partition.",1.25154097049388,"Analyze a string like ""[0.2|1.3]"" to form the partition; cells are separated by ""|"" characters and elements in the cell by commas.","public static Partition fromString(String strForm){
        Partition p = new Partition();
        String[] cells = strForm.substring(1, strForm.length() - 1).split(""\\|"");
        for (String cell : cells) {
            p.addCell(Arrays.asList(cell.split("","")));
        }
        return p;
    }","public static Partition fromString(String strForm){
        Partition p = new Partition();
        String[] cells = strForm.substring(1, strForm.length() - 1).split(""\\|"");
        for (String cell : cells) {
            p.addCell(Arrays.asList(cell.split("","")));
        }
        return p;
    }","public static Partition fromString(String strForm){
        Partition p = new Partition();
        String[] cells = strForm.substring(1, strForm.length()-1).split(""\\|"");
        for (String cell : cells) {
            p.addCell(Arrays.asList(cell.split("","")));
        }
        return p;
    }","public static Partition fromString(String strForm){
        Partition p = new Partition();
        String[] cells = strForm.substring(1, strForm.length()-1).split(""\\|"");
        for (String cell : cells) {
            String[] elements = cell.split("","");
            SortedSet<Integer> cellSet = new TreeSet<Integer>();
            for (String element : elements) {
                cellSet.add(Integer.parseInt(element));
            }
            p.addCell(cellSet);
        }
        return p;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.10905932504523216,  0.10905932504523216,  0.15554902959578049,  0.10905932504523216,273.0,0.8348623853211009,273.0,0.8348623853211009,259.0,0.7920489296636085,273.0,0.8348623853211009,0.0,0.0,44.0,0.4,0.0,0.0,20.0,0.8695652173913043,4.0,0.17391304347826086,22.0,0.9565217391304348
635,glowstone,"public boolean readList(@NonNls String key, TagType type, Consumer<? super List<T>> consumer){
    if (isList(key, type)) {
        consumer.accept(getList(key, type));
        return true;
    }
    return false;
}",readList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to a list subtag if it is present, converting it to a list of
     * values first.
     *
     * @param <T> the type to convert the list entries to
     * @param key the key to look up
     * @param type the type that the list entries must be
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */",538-556,"('readList', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,22.0,"Applies the given function to a list subtag if it is present, converting it to a list of  values first.","Returns false is the subtag list cannot be converted into a list of values. Otherwise, transform the list and return true.","If the function is present, apply it to a list subtag and convert it to a list of values.",0.307965513719522,"Applies the given function to a list subtag if it is present, first converting it to a list of values."," public boolean readList(@NonNls String key, TagType type, Consumer<? super List<T>> consumer){
        return readTag(key, ListTag.class, tag -> consumer.accept(NbtSerialization.readList(tag, type)));
    }"," public boolean readList(@NonNls String key, TagType type, Consumer<? super List<T>> consumer){
        return readTag(key, ListTag.class, list -> {
            List<T> result = new ArrayList<>();
            for (Tag tag : list.getValue()) {
                if (tag.getType() != type) {
                    return false;
                }
                result.add(type.read(tag));
            }
            consumer.accept(result);
            return true;
        });
    }"," public boolean readList(@NonNls String key, TagType type, Consumer<? super List<T>> consumer){
        return readTag(key, ListTag.class, tag -> consumer.accept(NbtSerialization.readList(tag, type)));
    }",Empty Method,NOT PASS,NOT PASS,Empty Method,NOT PASS,  0.6243416750002545,  0.6386754620754203,None,  0.6243416750002545,20.0,0.36363636363636365,63.0,0.6057692307692307,None,None,20.0,0.36363636363636365,59.0,0.5673076923076923,None,None,0.0,0.0,20.0,0.9090909090909091,3.0,0.14285714285714285,13.0,0.6190476190476191
636,dcache,"public static boolean hasUid(Subject subject, long uid){
    Set<UidPrincipal> principals = subject.getPrincipals(UidPrincipal.class);
    for (UidPrincipal principal : principals) {
        if (principal.getUid() == uid) {
            return true;
        }
    }
    return false;
}",hasUid,org/dcache/auth/Subjects.java,/modules/common/src/main/java/org/dcache/auth/Subjects.java,"/**
     * Returns true if and only if the subject has the given user ID.
     */",100-112,"('hasUid', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,14.0,Returns true if and only if the subject has the given user ID.,"Return false when the subject does not have the given user ID, true otherwsie.","If the subject has a user ID, this is true.",0.983925259306236,Returns true if and only if the object has the given user ID.," public static boolean hasUid(Subject subject, long uid){
        return subject.getPrincipals().stream()
            .anyMatch(p -> p instanceof UidPrincipal && ((UidPrincipal) p).getUid() == uid);        
 }"," public static boolean hasUid(Subject subject, long uid){
        for (Principal principal : subject.getPrincipals()) {
            if (principal instanceof UidPrincipal && ((UidPrincipal) principal).getUid() == uid) {
                return true;
            }
        }
        return false;
    }"," public static boolean hasUid(Subject subject, long uid){
        for (Principal principal : subject.getPrincipals()) {
            if (principal instanceof UidPrincipal && ((UidPrincipal) principal).getUid() == uid) {
                return true;
            }
        }
        return false;       
 }"," public static boolean hasUid(Subject subject, long uid){
        return subject.getPrincipals().stream()
            .anyMatch(p -> p instanceof UidPrincipal && ((UidPrincipal) p).getUid() == uid);        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3958963962690864,  0.5206601067959231,  0.3958963962690864,  0.5206601067959231,30.0,0.5357142857142857,20.0,0.35714285714285715,30.0,0.5357142857142857,20.0,0.35714285714285715,22.0,0.4074074074074074,0.0,0.0,22.0,0.4074074074074074,12.0,0.8,1.0,0.07142857142857142,12.0,0.8571428571428571
638,cdk,"private static int nStereoBonds(List<IBond> bonds){
    int count = 0;
    for (IBond bond : bonds) {
        IBond.Stereo stereo = bond.getStereo();
        switch(stereo) {
            case E_OR_Z:
            case UP_OR_DOWN:
            case UP_OR_DOWN_INVERTED:
                return -1;
            case UP:
            case DOWN:
            case UP_INVERTED:
            case DOWN_INVERTED:
                count++;
                break;
        }
    }
    return count;
}",nStereoBonds,org/openscience/cdk/hash/stereo/GeometricTetrahedralEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricTetrahedralEncoderFactory.java,"/**
     * access the number of stereo bonds in the provided bond list.
     *
     * @param bonds input list
     * @return number of UP/DOWN bonds in the list, -1 if a query bond was
     *         found
     */",222-248,"('nStereoBonds', {'INSTRUCTION': {'covered': 24, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,12.0,access the number of stereo bonds in the provided bond list.,"If the given list of bonds does not have matching stereo bonds returns -1.  Otherwise, reports the number of such items provided within the list.",The number of stereo bonds is provided.,0.340851279237202,Access the number of stereo links in the provided link list.,"private static int nStereoBonds(List<IBond> bonds){
        int n = 0;
        for (IBond bond : bonds) {
            if (bond.getStereo() != IBond.Stereo.NONE) n++;
        }
        return n;
    }","private static int nStereoBonds(List<IBond> bonds){
        int n = 0;
        for (IBond bond : bonds) {
            if (bond.getStereo() != null) n++;
        }
        return n;
    }","private static int nStereoBonds(List<IBond> bonds){
        int nStereoBonds = 0;
        for (IBond bond : bonds) {
            if (bond.getStereo() != IBond.Stereo.NONE) nStereoBonds++;
        }
        return nStereoBonds;
    }","private static int nStereoBonds(List<IBond> bonds){
        int nStereoBonds = 0;
        for (IBond bond : bonds) {
            if (bond.getStereo() != IBond.Stereo.NONE) nStereoBonds++;
        }
        return nStereoBonds;        
 }",PASS,NOT PASS,PASS,PASS,  0.45244762763497903,  0.3991544236408172,  0.45244762763497903,  0.45244762763497903,42.0,0.5384615384615384,41.0,0.5256410256410257,42.0,0.5384615384615384,42.0,0.5384615384615384,5.0,0.10416666666666667,3.0,0.0625,3.0,0.0625,18.0,0.6923076923076923,3.0,0.25,7.0,0.5833333333333334
639,matsim-libs,"public void write(final String filename){
    try (OutputStream stream = IOUtils.getOutputStream(IOUtils.getFileUrl(filename), false)) {
        write(new PrintStream(stream));
    } catch (IOException e) {
        throw new UncheckedIOException(e);
    }
}",write,org/matsim/analysis/LegHistogram.java,/matsim/src/main/java/org/matsim/analysis/LegHistogram.java,"/**
	 * Writes the gathered data tab-separated into a text file.
	 *
	 * @param filename The name of a file where to write the gathered data.
	 */",132-143,"('write', {'INSTRUCTION': {'covered': 150, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 20, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,10.0,Writes the gathered data tab-separated into a text file.,Stores the retrieved data into a text file in a tab-separated form.,The data tab is written into a text file.,0.139714873757543,Writes the collected data separated by tabs to a text file.,"public void write(final String filename){
	 try {
		 OutputStream out = IOUtils.getOutputStream(filename);
		 PrintStream ps = new PrintStream(out);
		 ps.println(""# iteration: "" + this.iteration);
		 ps.println(""# binSize: "" + this.binSize);
		 ps.println(""# nofBins: "" + this.nofBins);
		 ps.println(""# mode\tdep\tarr\tstuck"");
		 for (String mode : this.data.keySet()) {
			 DataFrame dataFrame = this.data.get(mode);
			 ps.print(mode + ""\t"");
			 for (int i = 0; i < this.nofBins; i++) {
				 ps.print(dataFrame.countsDep[i] + ""\t"");
				 ps.print(dataFrame.countsArr[i] + ""\t"");
				 ps.print(dataFrame.countsStuck[i] + ""\t"");
			 }
			 ps.println();
		 }
		 ps.close();
	 } catch (IOException e) {
		 throw new UncheckedIOException(e);
	 }
 }","public void write(final String filename){
	 try {
		 OutputStream out = IOUtils.getOutputStream(filename);
		 PrintStream ps = new PrintStream(out);
		 ps.println(""# iteration: "" + this.iteration);
		 ps.println(""# binSize: "" + this.binSize);
		 ps.println(""# nofBins: "" + this.nofBins);
		 ps.println(""# mode\tdep\tarr\tstuck"");
		 for (String mode : this.data.keySet()) {
			 DataFrame dataFrame = this.data.get(mode);
			 ps.print(mode + ""\t"");
			 for (int i = 0; i < this.nofBins; i++) {
				 ps.print(dataFrame.countsDep[i] + ""\t"");
				 ps.print(dataFrame.countsArr[i] + ""\t"");
				 ps.print(dataFrame.countsStuck[i] + ""\t"");
			 }
			 ps.println();
		 }
		 ps.close();
	 } catch (IOException e) {
		 throw new UncheckedIOException(e);
	 }
 }","public void write(final String filename){
	 	try {
 		OutputStream out = IOUtils.getBufferedOutputStream(filename, false);
 		PrintStream ps = new PrintStream(out);
 		ps.println(""# iteration: "" + this.iteration);
 		ps.println(""# binSize: "" + this.binSize);
 		ps.println(""# nofBins: "" + this.nofBins);
 		ps.println(""# mode\tdep\tarr\tstuck"");
 		for (String mode : this.data.keySet()) {
 			DataFrame dataFrame = this.data.get(mode);
 			ps.print(mode + ""\t"");
 			ps.print(dataFrame.countsDep[0]);
 			for (int i = 1; i < this.nofBins; i++) {
 				ps.print(""\t"" + dataFrame.countsDep[i]);
 			}
 			ps.print(""\t"");
 			ps.print(dataFrame.countsArr[0]);
 			for (int i = 1; i < this.nofBins; i++) {
 				ps.print(""\t"" + dataFrame.countsArr[i]);
 			}
 			ps.print(""\t"");
 			ps.print(dataFrame.countsStuck[0]);
 			for (int i = 1; i < this.nofBins; i++) {
 				ps.print(""\t"" + dataFrame.countsStuck[i]);
 			}
 			ps.println();
 		}
 		ps.close();
 	} catch (IOException e) {
 		throw new UncheckedIOException(e);
 	}		
 }","public void write(final String filename){
	 	try {
 		OutputStream out = IOUtils.getBufferedOutputStream(filename, false);
 		PrintStream ps = new PrintStream(out);
 		ps.println(""# iteration\tbin\tmode\tcountsDep\tcountsArr\tcountsStuck"");
 		for (String mode : this.data.keySet()) {
 			DataFrame dataFrame = this.data.get(mode);
 			for (int i = 0; i < this.nofBins; i++) {
 				ps.println(this.iteration + ""\t"" + i + ""\t"" + mode + ""\t"" + dataFrame.countsDep[i] + ""\t"" + dataFrame.countsArr[i] + ""\t"" + dataFrame.countsStuck[i]);
 			}
 		}
 		ps.close();
 	} catch (IOException e) {
 		throw new UncheckedIOException(e);
 	}
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5071921405669741,  0.5071921405669741,  0.5035411518984899,  0.4779385386168751,151.0,0.7743589743589744,151.0,0.7743589743589744,108.0,0.7152317880794702,240.0,0.8480565371024735,0.0,0.0,75.0,0.38461538461538464,94.0,0.3321554770318021,8.0,0.6153846153846154,5.0,0.4166666666666667,5.0,0.5
640,acs-aem-commons,"private boolean containsJcrPackagePath(final String path){
    if (StringUtils.startsWith(path, ""/etc/packages/"") && StringUtils.endsWith(path, "".zip"")) {
        return true;
    }
    return false;
}",containsJcrPackagePath,com/adobe/acs/commons/replication/status/impl/JcrPackageReplicationStatusEventHandler.java,/bundle/src/main/java/com/adobe/acs/commons/replication/status/impl/JcrPackageReplicationStatusEventHandler.java,"/**
     * Checks if the given path looks like a Jcr Package path.
     *
     * Provides a very fast, String-based, in-memory check to weed out most false positives and avoid
     * resolving the path to a Jcr Package and ensure it is valid.
     *
     * @param path
     * @return true if at least one path looks like a Jcr Package path
     */",353-371,"('containsJcrPackagePath', {'INSTRUCTION': {'covered': 10, 'missed': 2}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,12.0,Checks if the given path looks like a Jcr Package path.,Controls whether the given path looks like a Jcr Package path.,"If the path looks like a Jcr Package path, it's time to check it.",0.399356720262175,Checks whether the given path resembles a Jcr package path.," private boolean containsJcrPackagePath(final String path){
        return path.startsWith(JCR_PACKAGE_PATH);       
 }"," private boolean containsJcrPackagePath(final String path){
        return path.contains(JCR_PACKAGE_PATH_PREFIX);      
 }"," private boolean containsJcrPackagePath(final String path){
        return path.startsWith(JCR_PACKAGE_PATH);       
 }"," private boolean containsJcrPackagePath(final String path){
        return path.startsWith(JCR_PACKAGE_PATH_PREFIX);        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.31664197347498135,  0.3064043844104203,  0.31664197347498135,  0.31664197347498135,23.0,0.5897435897435898,23.0,0.5897435897435898,23.0,0.5897435897435898,23.0,0.5897435897435898,2.0,0.10526315789473684,1.0,0.05263157894736842,0.0,0.0,2.0,0.16666666666666666,4.0,0.3333333333333333,9.0,0.6
641,cdk,"private void storeRingSystem(IAtomContainer mol, IRingSet ringSet){
    listOfRings = new ArrayList<Integer[]>();
    for (int r = 0; r < ringSet.getAtomContainerCount(); ++r) {
        IRing ring = (IRing) ringSet.getAtomContainer(r);
        Integer[] bondNumbers = new Integer[ring.getBondCount()];
        for (int i = 0; i < ring.getBondCount(); ++i) bondNumbers[i] = mol.indexOf(ring.getBond(i));
        listOfRings.add(bondNumbers);
    }
}",storeRingSystem,org/openscience/cdk/smiles/DeduceBondSystemTool.java,/legacy/src/main/java/org/openscience/cdk/smiles/DeduceBondSystemTool.java,"/**
     * Stores an IRingSet corresponding to a AtomContainer using the bond numbers.
     *
     * @param mol      The IAtomContainer for which to store the IRingSet.
     * @param ringSet  The IRingSet to store
     */",804-819,"('storeRingSystem', {'INSTRUCTION': {'covered': 45, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",114.0,12.0,Stores an IRingSet corresponding to a AtomContainer using the bond numbers.,Uses the bond numbers to keep track of an IRingSet corresponding to an AtomContainer.,Bond numbers are used to store an IRingSet that is related to a AtomContainer.,1.01612716575039,Stores an IRingSet corresponding to an AtomContainer using link numbers.,"private void storeRingSystem(IAtomContainer mol, IRingSet ringSet){
        IRingSet rs = Cycles.sssr(mol).toRingSet();
        for (int i = 0; i <= rs.getAtomContainerCount() - 1; i++) {
            IRing ring = (IRing) rs.getAtomContainer(i);
            for (int j = 0; j <= ring.getAtomCount() - 1; j++) {
                IAtom atom = ring.getAtom(j);
                atom.setProperty(CDKConstants.RING_SYSTEM, ringSet);
            }
        }
    }","private void storeRingSystem(IAtomContainer mol, IRingSet ringSet){
        for (int i = 0; i < ringSet.getAtomContainerCount(); i++) {
            IRing ring = (IRing) ringSet.getAtomContainer(i);
            mol.setProperty(CDKConstants.RINGLIST, ring);
        }
    }"," private void storeRingSystem(IAtomContainer mol, IRingSet ringSet){
        if (mol.getProperty(CDKConstants.RING_SYSTEM_KEY) == null) {
            mol.setProperty(CDKConstants.RING_SYSTEM_KEY, ringSet);
        } else {
            IRingSet rs = (IRingSet) mol.getProperty(CDKConstants.RING_SYSTEM_KEY);
            rs.add(ringSet);
        }
    }","private void storeRingSystem(IAtomContainer mol, IRingSet ringSet){
        for (int i = 0; i < ringSet.getAtomContainerCount(); i++) {
            IRing r = (IRing) ringSet.getAtomContainer(i);
            for (int j = 0; j < r.getAtomCount(); j++) {
                IAtom a = r.getAtom(j);
                a.setProperty(CDKConstants.LINK_NUMBER, new Integer(i));
            }
        }       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.44488564378406437,  0.36085523093178773,  0.43377703781635657,  0.19974361467608878,62.0,0.5391304347826087,67.0,0.5826086956521739,60.0,0.5217391304347826,77.0,0.6695652173913044,54.0,0.5142857142857142,33.0,0.3142857142857143,69.0,0.6571428571428571,13.0,0.8666666666666667,3.0,0.25,13.0,0.8666666666666667
642,cdk,"public void writeMolecule(IAtomContainer molecule) throws CDKException{
    try {
        writeHeader();
        int atomNumber = 1;
        String hetatmRecordName = (writeAsHET.isSet()) ? ""HETATM"" : ""ATOM  "";
        String id = molecule.getID();
        String residueName = (id == null || id.equals("""")) ? ""MOL"" : id;
        String terRecordName = ""TER"";
        // Loop through the atoms and write them out:
        StringBuffer buffer = new StringBuffer();
        Iterator<IAtom> atoms = molecule.atoms().iterator();
        FormatStringBuffer fsb = new FormatStringBuffer("""");
        String[] connectRecords = null;
        if (writeCONECTRecords.isSet()) {
            connectRecords = new String[molecule.getAtomCount()];
        }
        while (atoms.hasNext()) {
            buffer.setLength(0);
            buffer.append(hetatmRecordName);
            fsb.reset(SERIAL_FORMAT).format(atomNumber);
            buffer.append(fsb.toString());
            buffer.append(' ');
            IAtom atom = atoms.next();
            String name;
            if (useElementSymbolAsAtomName.isSet()) {
                name = atom.getSymbol();
            } else {
                if (atom.getID() == null || atom.getID().equals("""")) {
                    name = atom.getSymbol();
                } else {
                    name = atom.getID();
                }
            }
            fsb.reset(ATOM_NAME_FORMAT).format(name);
            buffer.append(fsb.toString());
            fsb.reset(RESIDUE_FORMAT).format(residueName);
            buffer.append(fsb).append(""     0    "");
            Point3d position = atom.getPoint3d();
            fsb.reset(POSITION_FORMAT).format(position.x);
            buffer.append(fsb.toString());
            fsb.reset(POSITION_FORMAT).format(position.y);
            buffer.append(fsb.toString());
            fsb.reset(POSITION_FORMAT).format(position.z);
            buffer.append(fsb.toString());
            // occupancy + temperature factor
            buffer.append(""  1.00  0.00           "").append(atom.getSymbol());
            Integer formalCharge = atom.getFormalCharge();
            if (formalCharge == CDKConstants.UNSET) {
                buffer.append(""+0"");
            } else {
                if (formalCharge < 0) {
                    buffer.append(formalCharge);
                } else {
                    buffer.append('+').append(formalCharge);
                }
            }
            if (connectRecords != null && writeCONECTRecords.isSet()) {
                List<IAtom> neighbours = molecule.getConnectedAtomsList(atom);
                if (neighbours.size() != 0) {
                    StringBuffer connectBuffer = new StringBuffer(""CONECT"");
                    connectBuffer.append(String.format(""%5d"", atomNumber));
                    for (IAtom neighbour : neighbours) {
                        int neighbourNumber = molecule.indexOf(neighbour) + 1;
                        connectBuffer.append(String.format(""%5d"", neighbourNumber));
                    }
                    connectRecords[atomNumber - 1] = connectBuffer.toString();
                } else {
                    connectRecords[atomNumber - 1] = null;
                }
            }
            writer.write(buffer.toString(), 0, buffer.length());
            writer.write('\n');
            ++atomNumber;
        }
        if (writeTERRecord.isSet()) {
            writer.write(terRecordName, 0, terRecordName.length());
            writer.write('\n');
        }
        if (connectRecords != null && writeCONECTRecords.isSet()) {
            for (String connectRecord : connectRecords) {
                if (connectRecord != null) {
                    writer.write(connectRecord);
                    writer.write('\n');
                }
            }
        }
        if (writeENDRecord.isSet()) {
            writer.write(""END   "");
            writer.write('\n');
        }
    } catch (IOException exception) {
        throw new CDKException(""Error while writing file: "" + exception.getMessage(), exception);
    }
}",writeMolecule,org/openscience/cdk/io/PDBWriter.java,/storage/pdb/src/main/java/org/openscience/cdk/io/PDBWriter.java,"/**
     * Writes a single frame in PDB format to the Writer.
     *
     * @param molecule the Molecule to write
     */",173-281,"('writeMolecule', {'INSTRUCTION': {'covered': 311, 'missed': 48}, 'BRANCH': {'covered': 27, 'missed': 13}, 'LINE': {'covered': 66, 'missed': 8}, 'COMPLEXITY': {'covered': 9, 'missed': 12}, 'METHOD': {'covered': 1, 'missed': 0}})",743.0,11.0,Writes a single frame in PDB format to the Writer.,Stores a single frame in PDB format into the Writer.,A single frame is written in PDB format.,0.317801571899294,Writes a single image in PDB format to the writer.," public void writeMolecule(IAtomContainer molecule) throws CDKException{
        try {
            writeHeader(molecule);
            writeAtoms(molecule);
            writeBonds(molecule);
            writeFooter(molecule);
        } catch (IOException e) {
            throw new CDKException(""IOException while writing PDB file"", e);
        }       
 }"," public void writeMolecule(IAtomContainer molecule) throws CDKException{
        try {
            writeHeader(molecule);
            writeAtoms(molecule);
            writeBonds(molecule);
            writeFooter(molecule);
        } catch (IOException e) {
            throw new CDKException(""Error while writing PDB file"", e);
        }       
 }",Not Valid,Not Valid,NOT PASS,NOT PASS,Not Valid,Not Valid,  0.039699553117190846,  0.040652253552705776,None,None,699.0,0.9395161290322581,699.0,0.9395161290322581,None,None,None,None,1.0,0.0196078431372549,None,None,None,None,2.0,0.18181818181818182,2.0,0.18181818181818182,8.0,0.7272727272727273
643,matsim-libs,"public static void addShipment(Carrier carrier, CarrierShipment carrierShipment){
    carrier.getShipments().put(carrierShipment.getId(), carrierShipment);
}",addShipment,org/matsim/contrib/freight/carrier/CarrierUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/carrier/CarrierUtils.java,"/**
	 * Adds an {@link CarrierShipment} to the {@link Carrier}.
	 * @param carrier
	 * @param carrierShipment
	 */",53-60,"('addShipment', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,15.0,Adds an {@link CarrierShipment} to the {@link Carrier}.,Appends an {@link CarrierShipment} to the {@link Carrier}.,The @link Carrier is now an @link CarrierShipment.,1.20709854382521,Adds a {@link CarrierShipment} to the {@link Carrier}.," public static void addShipment(Carrier carrier, CarrierShipment carrierShipment){
	 		carrier.getShipments().put(carrierShipment.getId(), carrierShipment);
 	}"," public static void addShipment(Carrier carrier, CarrierShipment carrierShipment){
	 		carrier.getShipments().put(carrierShipment.getId(), carrierShipment);
 	}"," public static void addShipment(Carrier carrier, CarrierShipment carrierShipment){
	 		carrier.getShipments().put(carrierShipment.getId(), carrierShipment);
 	}		"," public static void addShipment(Carrier carrier, CarrierShipment carrierShipment){
	 		carrier.getShipments().put(carrierShipment.getId(), carrierShipment);
 	}		",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.1111111111111111,1.0,0.1111111111111111,8.0,0.8888888888888888
644,matsim-libs,"private double calcDistanceIndicator(final double x, final double y){
    double distanceX;
    double distanceY;
    if (this.minX <= x && x <= this.maxX) {
        distanceX = 0;
    } else {
        distanceX = Math.min(Math.abs(this.minX - x), Math.abs(this.maxX - x));
    }
    if (this.minY <= y && y <= this.maxY) {
        distanceY = 0;
    } else {
        distanceY = Math.min(Math.abs(this.minY - y), Math.abs(this.maxY - y));
    }
    return distanceX * distanceX + distanceY * distanceY;
}",calcDistanceIndicator,org/matsim/core/network/LinkQuadTree.java,/matsim/src/main/java/org/matsim/core/network/LinkQuadTree.java,"/**
		 * Calculates the distance of a given point to the border of the
		 * rectangle. If the point lies within the rectangle, the distance
		 * is zero.
		 *
		 * @param x left-right location
		 * @param y up-down location
		 * @return distance to border, 0 if inside rectangle or on border
		 */",284-310,"('calcDistanceIndicator', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",133.0,14.0,Calculates the distance of a given point to the border of the  rectangle.,"Given a point expressed through (x,y) coordinates, compute the distance of such a point to the rectangle's border.",The distance is calculated from a point to the border.,0.263664508405957,Calculates the distance from a given point to the border of the rectangle.,"private double calcDistanceIndicator(final double x, final double y){
	 		double distance = 0;
 		if (x < minX) {
 			distance += minX - x;
 		} else if (x > maxX) {
 			distance += x - maxX;
 		}
 		if (y < minY) {
 			distance += minY - y;
 		} else if (y > maxY) {
 			distance += y - maxY;
 		}
 		return distance;
 	}","private double calcDistanceIndicator(final double x, final double y){
	 		double distance = 0;
 		if (x < minX) {
 			distance += minX - x;
 		} else if (x > maxX) {
 			distance += x - maxX;
 		}
 		if (y < minY) {
 			distance += minY - y;
 		} else if (y > maxY) {
 			distance += y - maxY;
 		}
 		return distance;
 	}","private double calcDistanceIndicator(final double x, final double y){
	 		double distance = 0;
 		if (x < minX) {
 			distance += minX - x;
 		} else if (x > maxX) {
 			distance += x - maxX;
 		}
 		if (y < minY) {
 			distance += minY - y;
 		} else if (y > maxY) {
 			distance += y - maxY;
 		}
 		return distance;
 	}","private double calcDistanceIndicator(final double x, final double y){
	 	double distanceIndicator = 0;
 	if (x < minX) {
 		distanceIndicator += minX - x;
 	} else if (x > maxX) {
 		distanceIndicator += x - maxX;
 	}
 	if (y < minY) {
 		distanceIndicator += minY - y;
 	} else if (y > maxY) {
 		distanceIndicator += y - maxY;
 	}
 	return distanceIndicator;
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.27642630701928994,  0.28300525438771096,  0.27642630701928994,  0.28300525438771096,93.0,0.6940298507462687,93.0,0.6940298507462687,93.0,0.6940298507462687,93.0,0.6940298507462687,0.0,0.0,6.0,0.07407407407407407,0.0,0.0,14.0,0.7368421052631579,1.0,0.07142857142857142,10.0,0.7142857142857143
645,activiti,"protected void makeProcessDefinitionsConsistentWithPersistedVersions(ParsedDeployment parsedDeployment){
    for (ProcessDefinitionEntity processDefinition : parsedDeployment.getAllProcessDefinitions()) {
        ProcessDefinitionEntity persistedProcessDefinition = bpmnDeploymentHelper.getPersistedInstanceOfProcessDefinition(processDefinition);
        if (persistedProcessDefinition != null) {
            processDefinition.setId(persistedProcessDefinition.getId());
            processDefinition.setVersion(persistedProcessDefinition.getVersion());
            processDefinition.setAppVersion(persistedProcessDefinition.getAppVersion());
            processDefinition.setSuspensionState(persistedProcessDefinition.getSuspensionState());
        }
    }
}",makeProcessDefinitionsConsistentWithPersistedVersions,org/activiti/engine/impl/bpmn/deployer/BpmnDeployer.java,/activiti-core/activiti-engine/src/main/java/org/activiti/engine/impl/bpmn/deployer/BpmnDeployer.java,"/**
     * Loads the persisted version of each process definition and set values on the in-memory
     * version to be consistent.
     */",268-284,"('makeProcessDefinitionsConsistentWithPersistedVersions', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,19.0,Loads the persisted version of each process definition and set values on the in-memory  version to be consistent.,Dispatches the persisted version of each process definition while setting the values on the in-memory version for consistency.,Set values on the in-memory version of the persisted version of the process definition to make sure it is consistent.,0.376543263106742,Loads the persistent version of each process definition and sets the values on the in-memory version so that they are consistent.,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,7.0,0.3684210526315789,7.0,0.3181818181818182,16.0,0.7619047619047619
646,cdk,"public String toString(){
    if (differences.size() == 0)
        return """";
    StringBuffer diffBuffer = new StringBuffer();
    diffBuffer.append(this.name).append('{');
    Iterator<IDifference> children = getChildren().iterator();
    while (children.hasNext()) {
        diffBuffer.append(children.next().toString());
        if (children.hasNext()) {
            diffBuffer.append("", "");
        }
    }
    diffBuffer.append('}');
    return diffBuffer.toString();
}",toString,org/openscience/cdk/tools/diff/tree/Point3dDifference.java,/misc/diff/src/main/java/org/openscience/cdk/tools/diff/tree/Point3dDifference.java,"/**
     * Returns a {@link String} representation for this {@link IDifference}.
     *
     * @return a {@link String}
     */",63-84,"('toString', {'INSTRUCTION': {'covered': 44, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",112.0,16.0,Returns a {@link String} representation for this {@link IDifference}.,Returns a String represention for the object IDifference.,This is a representation of the @link IDifference.,0.993309842181613,Returns a {@link String} representation for this {@link IDifference}.," public String toString(){
        return name;
    }"," public String toString(){
        return name;
    }"," public String toString(){
        return name;
    }"," public String toString(){
        return name;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.034575539968341236,  0.034575539968341236,  0.034575539968341236,  0.034575539968341236,102.0,0.9026548672566371,102.0,0.9026548672566371,102.0,0.9026548672566371,102.0,0.9026548672566371,0.0,0.0,0.0,0.0,0.0,0.0,6.0,0.6,0.0,0.0,8.0,0.8
647,liquibase,"private static boolean isCommand(String arg){
    return COMMANDS.MIGRATE.equals(arg) || COMMANDS.MIGRATE_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE.equalsIgnoreCase(arg) || COMMANDS.UPDATE_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE_COUNT.equalsIgnoreCase(arg) || COMMANDS.UPDATE_COUNT_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE_TO_TAG.equalsIgnoreCase(arg) || COMMANDS.UPDATE_TO_TAG_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_TO_DATE.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_COUNT.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_TO_DATE_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_COUNT_SQL.equalsIgnoreCase(arg) || COMMANDS.REGISTER_CHANGELOG.equalsIgnoreCase(arg) || COMMANDS.DEACTIVATE_CHANGELOG.equalsIgnoreCase(arg) || COMMANDS.FUTURE_ROLLBACK_SQL.equalsIgnoreCase(arg) || COMMANDS.FUTURE_ROLLBACK_COUNT_SQL.equalsIgnoreCase(arg) || COMMANDS.FUTURE_ROLLBACK_FROM_TAG_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE_TESTING_ROLLBACK.equalsIgnoreCase(arg) || COMMANDS.TAG.equalsIgnoreCase(arg) || COMMANDS.TAG_EXISTS.equalsIgnoreCase(arg) || COMMANDS.LIST_LOCKS.equalsIgnoreCase(arg) || COMMANDS.HISTORY.equalsIgnoreCase(arg) || COMMANDS.DROP_ALL.equalsIgnoreCase(arg) || COMMANDS.RELEASE_LOCKS.equalsIgnoreCase(arg) || COMMANDS.STATUS.equalsIgnoreCase(arg) || COMMANDS.UNEXPECTED_CHANGESETS.equalsIgnoreCase(arg) || COMMANDS.VALIDATE.equalsIgnoreCase(arg) || COMMANDS.HELP.equalsIgnoreCase(arg) || COMMANDS.DIFF.equalsIgnoreCase(arg) || COMMANDS.DIFF_CHANGELOG.equalsIgnoreCase(arg) || COMMANDS.GENERATE_CHANGELOG.equalsIgnoreCase(arg) || COMMANDS.SNAPSHOT.equalsIgnoreCase(arg) || COMMANDS.SNAPSHOT_REFERENCE.equalsIgnoreCase(arg) || COMMANDS.SYNC_HUB.equalsIgnoreCase(arg) || COMMANDS.EXECUTE_SQL.equalsIgnoreCase(arg) || COMMANDS.CALCULATE_CHECKSUM.equalsIgnoreCase(arg) || COMMANDS.CLEAR_CHECKSUMS.equalsIgnoreCase(arg) || COMMANDS.DB_DOC.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC_TO_TAG.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC_TO_TAG_SQL.equalsIgnoreCase(arg) || COMMANDS.MARK_NEXT_CHANGESET_RAN.equalsIgnoreCase(arg) || COMMANDS.MARK_NEXT_CHANGESET_RAN_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_ONE_CHANGE_SET.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_ONE_CHANGE_SET_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_ONE_UPDATE.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_ONE_UPDATE_SQL.equalsIgnoreCase(arg);
}",isCommand,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,"/**
     * Returns true if the given arg is a valid main command of Liquibase.
     *
     * @param arg the String to test
     * @return true if it is a valid main command, false if not
     */",621-678,"('isCommand', {'INSTRUCTION': {'covered': 204, 'missed': 0}, 'BRANCH': {'covered': 70, 'missed': 30}, 'LINE': {'covered': 50, 'missed': 0}, 'COMPLEXITY': {'covered': 21, 'missed': 30}, 'METHOD': {'covered': 1, 'missed': 0}})",461.0,14.0,Returns true if the given arg is a valid main command of Liquibase.,Checks whether the arg matches a valid main command or not.,"If the given arg is a valid main command, then this is true.",1.02144227788678,Returns true if the given arg is a valid Liquibase master command.," private static boolean isCommand(String arg){
        return COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_TO_TAG.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_TO_TAG_SQL.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE_COUNT.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE_COUNT_SQL.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE_TO_TAG.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE_TO_TAG_SQL.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE_SQL.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_SQL.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_TO_DATE.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_TO_DATE_SQL.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_COUNT.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_COUNT_SQL.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_ONE_CHANGE_SET.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_ONE_UPDATE.equalsIgnoreCase(arg)
                || COMMANDS.FUTURE_ROLLBACK.equalsIgnoreCase(arg)
                || COMMANDS.FUTURE_ROLLBACK_SQL.equalsIgnoreCase(arg)
                || COMMANDS.FUTURE_ROLLBACK_COUNT.equalsIgnoreCase(arg)
                || COMMANDS.FUTURE_ROLLBACK_        
 }"," private static boolean isCommand(String arg){
        return COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_TO_TAG.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_TO_TAG_SQL.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE_COUNT.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE_COUNT_SQL.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE_TO_TAG.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE_TO_TAG_SQL.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE_SQL.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_SQL.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_TO_DATE.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_TO_DATE_SQL.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_COUNT.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_COUNT_SQL.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_ONE_CHANGE_SET.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_ONE_UPDATE.equalsIgnoreCase(arg)
                || COMMANDS.FUTURE_ROLLBACK.equalsIgnoreCase(arg)
                || COMMANDS.FUTURE_ROLLBACK_SQL.equalsIgnoreCase(arg)
                || COMMANDS.FUTURE_ROLLBACK_COUNT.equalsIgnoreCase(arg)
                || COMMANDS.FUTURE_ROLLBACK_        
 }"," private static boolean isCommand(String arg){
        return COMMANDS.SNAPSHOT.equalsIgnoreCase(arg)
                || COMMANDS.SNAPSHOT_REFERENCE.equalsIgnoreCase(arg)
                || COMMANDS.REGISTER_CHANGELOG.equalsIgnoreCase(arg)
                || COMMANDS.DEACTIVATE_CHANGELOG.equalsIgnoreCase(arg)
                || COMMANDS.CALCULATE_CHECKSUM.equalsIgnoreCase(arg)
                || COMMANDS.STATUS.equalsIgnoreCase(arg)
                || COMMANDS.VALIDATE.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_TO_TAG.equalsIgnoreCase(arg)
                || COMMANDS.CHANGELOG_SYNC_TO_TAG_SQL.equalsIgnoreCase(arg)
                || COMMANDS.GENERATE_CHANGELOG.equalsIgnoreCase(arg)
                || COMMANDS.UNEXPECTED_CHANGESETS.equalsIgnoreCase(arg)
                || COMMANDS.DIFF_CHANGELOG.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE_COUNT.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE_TO_TAG.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_TO_DATE.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_COUNT.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_ONE_CHANGE_SET.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_ONE_UPDATE.equalsIgnoreCase(       
 }"," private static boolean isCommand(String arg){
        return COMMANDS.SNAPSHOT.equalsIgnoreCase(arg)
                || COMMANDS.SNAPSHOT_REFERENCE.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE_COUNT.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE_TO_TAG.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE_SQL.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE_COUNT_SQL.equalsIgnoreCase(arg)
                || COMMANDS.UPDATE_TO_TAG_SQL.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_TO_DATE.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_COUNT.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_SQL.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_TO_DATE_SQL.equalsIgnoreCase(arg)
                || COMMANDS.ROLLBACK_COUNT_SQL.equalsIgnoreCase(arg)
                || COMMANDS.FUTURE_ROLLBACK.equalsIgnoreCase(arg)
                || COMMANDS.FUTURE_ROLLBACK_COUNT.equalsIgnoreCase(arg)
                || COMMANDS.FUTURE_ROLLBACK_FROM_TAG.equalsIgnoreCase(arg)
                || COMMANDS.FUTURE_ROLLBACK_SQL.equalsIgnoreCase(arg)
                || COMMANDS.FUTURE_ROLLBACK_COUNT_SQL.equalsIgnoreCase(arg)
                || COMMANDS.FUTURE_ROLLBACK_FROM_TAG_SQL.equalsIgnoreCase(arg)
                || COMMANDS.DROP_ALL.equalsIgnoreCase(arg)
                || COMMANDS.REGISTER_CHANGELOG.equalsIgn        
 }",Syntax Error,Syntax Error,Syntax Error,Syntax Error,None,None,None,None,None,None,None,None,271.0,0.5865800865800865,271.0,0.5865800865800865,None,None,22.0,0.10679611650485436,25.0,0.12077294685990338,7.0,0.5,4.0,0.2857142857142857,8.0,0.5714285714285714
648,jooby," int intValue(){
    try {
        return Integer.parseInt(value());
    } catch (NumberFormatException x) {
        throw new TypeMismatchException(name(), int.class, x);
    }
}",intValue,io/jooby/Value.java,/jooby/src/main/java/io/jooby/Value.java,"/**
   * Convert this value to int (if possible).
   *
   * @return Int value.
   */",87-98,"('intValue', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,10.0,Convert this value to int (if possible).,Converts and returns an Integer value whenever possible.,"If possible, convert this value to int.",0.189182784632411,Convert this value to int (if possible).,"  int intValue(){
    return (int) longValue();     
  }","  int intValue(){
    return (int) longValue();     
  }","  int intValue(){
    try {
      return Integer.parseInt(value());
    } catch (NumberFormatException x) {
      throw new TypeMismatchException(name(), int.class, x);
    }     
  }","  int intValue(){
    try {
      return Integer.parseInt(value());
    } catch (NumberFormatException x) {
      throw new TypeMismatchException(name(), int.class, x);
    }     
  }",NOT PASS,NOT PASS,PASS,PASS,  0.150342907467695,  0.150342907467695,  1.0,  1.0,29.0,0.6904761904761905,29.0,0.6904761904761905,0.0,0.0,0.0,0.0,0.0,0.0,29.0,0.6904761904761905,29.0,0.6904761904761905,8.0,0.8888888888888888,0.0,0.0,6.0,0.75
649,cdk,"static int processCx(final String str, final CxSmilesState state){
    final CharIter iter = new CharIter(str);
    if (!iter.nextIf('|'))
        return -1;
    while (iter.hasNext()) {
        switch(iter.next()) {
            case '$':
                Map<Integer, String> dest;
                if (iter.nextIf(""_AV:""))
                    dest = state.atomValues = new TreeMap<>();
                else
                    dest = state.atomLabels = new TreeMap<>();
                if (!processAtomLabels(iter, dest))
                    return -1;
                break;
            case '(':
                if (!processCoords(iter, state))
                    return -1;
                break;
            case 'c':
            case 't':
                if (iter.nextIf(':')) {
                    if (!skipIntList(iter, COMMA_SEPARATOR))
                        return -1;
                } else if (iter.nextIf(""tu:"")) {
                    if (!skipIntList(iter, COMMA_SEPARATOR))
                        return -1;
                }
                break;
            case '&':
                if (!processStereoGrps(state, iter, IStereoElement.GRP_RAC))
                    return -1;
                break;
            case 'o':
                if (!processStereoGrps(state, iter, IStereoElement.GRP_REL))
                    return -1;
                break;
            case 'a':
                if (!processStereoGrps(state, iter, IStereoElement.GRP_ABS))
                    return -1;
                break;
            case 'r':
                if (iter.nextIf(':')) {
                    state.racemicFrags = new ArrayList<>();
                    if (!processIntList(iter, ',', state.racemicFrags))
                        return -1;
                } else {
                    state.racemic = true;
                    if (!iter.nextIf(',') && iter.curr() != '|')
                        return -1;
                }
                break;
            case 'l':
                if (!iter.nextIf(""p:""))
                    return -1;
                if (!skipIntMap(iter))
                    return -1;
                break;
            case 'f':
                if (!iter.nextIf(':'))
                    return -1;
                if (!processFragmentGrouping(iter, state))
                    return -1;
                break;
            case 'S':
                if (iter.nextIf(""g:"")) {
                    if (!processPolymerSgroups(iter, state))
                        return -1;
                } else if (iter.nextIf(""gD:"")) {
                    if (!processDataSgroups(iter, state))
                        return -1;
                    if (iter.nextIf(','))
                        break;
                } else if (iter.nextIf(""gH:"")) {
                    if (!processSgroupsHierarchy(iter, state))
                        return -1;
                } else {
                    return -1;
                }
                break;
            case 'm':
                if (!iter.nextIf(':'))
                    return -1;
                if (!processPositionalVariation(iter, state))
                    return -1;
                break;
            case '^':
                if (!processRadicals(iter, state))
                    return -1;
                break;
            case 'C':
            case 'H':
                if (!iter.nextIf(':'))
                    return -1;
                while (iter.hasNext() && isDigit(iter.curr())) {
                    if (!skipIntList(iter, DOT_SEPARATOR))
                        return -1;
                    iter.nextIf(',');
                }
                break;
            case '|':
                if (!iter.nextIf(' '))
                    iter.nextIf('\t');
                return iter.pos;
            case 'L':
                if (iter.nextIf('O')) {
                    if (!iter.nextIf(':'))
                        return -1;
                    if (!processLigandOrdering(iter, state))
                        return -1;
                } else {
                    return -1;
                }
                break;
            default:
                return -1;
        }
    }
    return -1;
}",processCx,org/openscience/cdk/smiles/CxSmilesParser.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/CxSmilesParser.java,"/**
     * Parse an string possibly containing CXSMILES into an intermediate state
     * ({@link CxSmilesState}) representation.
     *
     * @param str input character string (SMILES title field)
     * @param state output CXSMILES state
     * @return position where CXSMILES ends (below 0 means no CXSMILES)
     */",425-569,"('processCx', {'INSTRUCTION': {'covered': 206, 'missed': 48}, 'BRANCH': {'covered': 66, 'missed': 26}, 'LINE': {'covered': 49, 'missed': 24}, 'COMPLEXITY': {'covered': 28, 'missed': 26}, 'METHOD': {'covered': 1, 'missed': 0}})",708.0,19.0,Parse an string possibly containing CXSMILES into an intermediate state  ({@link CxSmilesState}) representation.,"Given a string as input, it converts such string into an intermediate state (CxSmileState) representation.",Parse a string containing a symbol into a representation.,0.615026040518977,Parse a string that may contain CXSMILES in an intermediate state representation ({@link CxSmilesState}).," static int processCx(final String str, final CxSmilesState state){
        final CharIter iter = new CharIter(str);
        while (iter.hasNext()) {
            switch (iter.curr()) {
                case 'A':
                    if (!processAtom(iter, state))
                        return CX_ERROR_ATOM;
                    break;
                case 'B':
                    if (!processBond(iter, state))
                        return CX_ERROR_BOND;
                    break;
                case 'R':
                    if (!processRgroup(iter, state))
                        return CX_ERROR_RGROUP;
                    break;
                case 'S':
                    if (!processSgroup(iter, state))
                        return CX_ERROR_SGROUP;
                    break;
                case 'P':
                    if (!processPolymerSgroups(iter, state))
                        return CX_ERROR_POLYMER;
                    break;
                case 'V':
                    if (!processPositionalVariation(iter, state))
                        return CX_ERROR_POSITION;
                    break;
                case 'L':
                    if (!processLigandOrdering(iter, state))
                        return CX_ERROR_LIGAND;
                    break;
                case 'X':
                    if (!processRadicals(iter, state))
                        return CX_ERROR_RADICAL;
                    break;
                default:
                    return CX_ERROR_UNKNOWN;
            }
        }
        return CX_OK;
    }","static int processCx(final String str, final CxSmilesState state){
        final CharIter iter = new CharIter(str);
        while (iter.hasNext()) {
            switch (iter.curr()) {
                case 'A':
                case 'a':
                    if (!processAtom(iter, state))
                        return -1;
                    break;
                case 'B':
                case 'b':
                    if (!processBond(iter, state))
                        return -1;
                    break;
                case 'R':
                case 'r':
                    if (!processRgroup(iter, state))
                        return -1;
                    break;
                case 'S':
                case 's':
                    if (!processSgroup(iter, state))
                        return -1;
                    break;
                case 'P':
                case 'p':
                    if (!processPolymerSgroups(iter, state))
                        return -1;
                    break;
                case 'V':
                case 'v':
                    if (!processPositionalVariation(iter, state))
                        return -1;
                    break;
                case 'L':
                case 'l':
                    if (!processLigandOrdering(iter, state))
                        return -1;
                    break;
                case 'X':
                case 'x':
                    if (!processRadicals(iter, state))
                        return -1;
                    break;
                default:
                    return -1;
            }
        }
        return 0;
    }",Not Valid,Not Valid,NOT PASS,NOT PASS,Not Valid,Not Valid,  0.22388824124151413,  0.2836865809666966,None,None,537.0,0.7574047954866009,506.0,0.7136812411847673,None,None,None,None,43.0,0.18695652173913044,None,None,None,None,10.0,0.625,8.0,0.5333333333333333,9.0,0.6428571428571429
650,matsim-libs,"public static Map<String, PreparedGeometry> createGridFromNetworkWithinServiceArea(Network network, double cellsize, List<PreparedGeometry> serviceAreaGeoms){
    Map<String, PreparedGeometry> grid = createGridFromNetwork(network, cellsize);
    log.info(""total number of created grid zones = "" + grid.size());
    log.info(""searching for grid zones within the drt service area..."");
    Counter counter = new Counter(""dealt with zone "");
    Map<String, PreparedGeometry> zonesWithinServiceArea = EntryStream.of(grid).peekKeys(id -> counter.incCounter()).filterValues(cell -> serviceAreaGeoms.stream().anyMatch(serviceArea -> serviceArea.intersects(cell.getGeometry()))).toMap();
    log.info(""number of remaining grid zones = "" + zonesWithinServiceArea.size());
    return zonesWithinServiceArea;
}",createGridFromNetworkWithinServiceArea,org/matsim/contrib/drt/analysis/zonal/DrtGridUtils.java,/contribs/drt/src/main/java/org/matsim/contrib/drt/analysis/zonal/DrtGridUtils.java,"/**
	 * First creates a grid based on the network bounding box. Then removes all zones that do not intersect the service area.
	 * Result may contain zones that are barely included in the service area. But as passengers may walk into the service area,
	 * it seems appropriate that the DrtZonalSystem, which is used for demand estimation, is larger than the service area.
	 * The {@code cellsize} indirectly determines, how much larger the DrtZonalSystem may get.
	 *
	 * @param network
	 * @param cellsize
	 * @param serviceAreaGeoms geometries that define the service area
	 * @return
	 */",75-101,"('createGridFromNetworkWithinServiceArea', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",141.0,11.0,First creates a grid based on the network bounding box.,Returns a Map representing a grid based on the network bounding boxes from which all the zones that do not  intersect the service area have been stripped away.,The network bounding box is used to create a grid.,0.381773038145617,"First, creates a grid based on the network bounding box.",Not Valid,Not Valid,"public static Map<String, PreparedGeometry> createGridFromNetworkWithinServiceArea(Network network, double cellsize, List<PreparedGeometry> serviceAreaGeoms){
	 log.info(""start creating grid from network"");
	 double[] boundingbox = NetworkUtils.getBoundingBox(network.getNodes().values());
	 double minX = (Math.floor(boundingbox[0] / cellsize) * cellsize);
	 double maxX = (Math.ceil(boundingbox[2] / cellsize) * cellsize);
	 double minY = (Math.floor(boundingbox[1] / cellsize) * cellsize);
	 double maxY = (Math.ceil(boundingbox[3] / cellsize) * cellsize);
	 GeometryFactory gf = new GeometryFactory();
	 PreparedGeometryFactory preparedGeometryFactory = new PreparedGeometryFactory();
	 Map<String, PreparedGeometry> grid = new HashMap<>();
	 int cell = 0;
	 for (double lx = minX; lx < maxX; lx += cellsize) {
		 for (double by = minY; by < maxY; by += cellsize) {
			 cell++;
			 Coordinate p1 = new Coordinate(lx, by);
			 Coordinate p2 = new Coordinate(lx + cellsize, by);
			 Coordinate p3 = new Coordinate(lx + cellsize, by + cellsize);
			 Coordinate p4 = new Coordinate(lx, by + cellsize);
			 Coordinate[] ca = { p1, p2, p3, p4, p1 };
			 Polygon polygon = new Polygon(gf.createLinearRing(ca), null, gf);
			 PreparedGeometry preparedGeometry = preparedGeometryFactory.create(polygon);
			 if(serviceAreaGeoms.stream().anyMatch(preparedGeometry::intersects)){
				 grid.put(cell + """", preparedGeometry);
			 }
		 }
	 }
	 log.info(""finished creating grid from network"");
	 return grid;			
 }","public static Map<String, PreparedGeometry> createGridFromNetworkWithinServiceArea(Network network, double cellsize, List<PreparedGeometry> serviceAreaGeoms){
	 log.info(""start creating grid from network"");
	 double[] boundingbox = NetworkUtils.getBoundingBox(network.getNodes().values());
	 double minX = (Math.floor(boundingbox[0] / cellsize) * cellsize);
	 double maxX = (Math.ceil(boundingbox[2] / cellsize) * cellsize);
	 double minY = (Math.floor(boundingbox[1] / cellsize) * cellsize);
	 double maxY = (Math.ceil(boundingbox[3] / cellsize) * cellsize);
	 GeometryFactory gf = new GeometryFactory();
	 PreparedGeometryFactory preparedGeometryFactory = new PreparedGeometryFactory();
	 Map<String, PreparedGeometry> grid = new HashMap<>();
	 int cell = 0;
	 for (double lx = minX; lx < maxX; lx += cellsize) {
		 for (double by = minY; by < maxY; by += cellsize) {
			 cell++;
			 Coordinate p1 = new Coordinate(lx, by);
			 Coordinate p2 = new Coordinate(lx + cellsize, by);
			 Coordinate p3 = new Coordinate(lx + cellsize, by + cellsize);
			 Coordinate p4 = new Coordinate(lx, by + cellsize);
			 Coordinate[] ca = { p1, p2, p3, p4, p1 };
			 Polygon polygon = new Polygon(gf.createLinearRing(ca), null, gf);
			 PreparedGeometry preparedGeometry = preparedGeometryFactory.create(polygon);
			 if(serviceAreaGeoms.stream().anyMatch(preparedGeometry::intersects)){
				 grid.put(cell + """", preparedGeometry);
			 }
		 }
	 }
	 log.info(""finished creating grid from network"");
	 return grid;			
 }",Not Valid,Not Valid,NOT PASS,NOT PASS,None,None,  0.41251256199182085,  0.4187625619918208,None,None,None,None,254.0,0.7559523809523809,254.0,0.7559523809523809,None,None,335.0,0.9970238095238095,335.0,0.9970238095238095,21.0,0.7241379310344828,1.0,0.09090909090909091,10.0,0.9090909090909091
651,egeria,"private List<FileFolder> extractFolders(String pathName, String externalSourceName, String methodName) throws InvalidParameterException{
    boolean fileSeparatorReversed = false;
    if (pathName.contains(""\\"")) {
        pathName = pathName.replace(""\\"", ""/"");
        fileSeparatorReversed = true;
    }
    Path path = Paths.get(pathName);
    File parentFile = path.toFile().getParentFile();
    invalidParameterHandler.validateObject(parentFile, ""pathName"", methodName);
    List<FileFolder> folders = new ArrayList<>();
    while (parentFile != null) {
        String parentFilePath = fileSeparatorReversed ? parentFile.getPath().replace(""/"", ""\\"") : parentFile.getPath();
        FileFolder folder = buildFileFolder(parentFilePath, externalSourceName);
        folders.add(folder);
        parentFile = parentFile.getParentFile();
    }
    return folders;
}",extractFolders,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineFolderHierarchyHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineFolderHierarchyHandler.java,"/**
     * Extracts each folder path and builds FileFolders, with the qualified name of the form
     * '<externalSourceName>::<path>'. The order is important, meaning the first folder is the one containing the file
     * and the last one the root, and used in creating the folder hierarchy structure al the way to the SoftwareServerCapability
     *
     * @param pathName           file path
     * @param externalSourceName name of SoftwareServerCapability
     * @param methodName         method name
     *
     * @return list of FileFolders
     */",163-197,"('extractFolders', {'INSTRUCTION': {'covered': 47, 'missed': 13}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 13, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",158.0,26.0,"Extracts each folder path and builds FileFolders, with the qualified name of the form  '<externalSourceName>::<path>'.",Returns a file folder list of FileFolders by extracting each folder path with the form's qualified name <externalSourceName>::path.,The form 'external SourceName>::path>' is used to build the file folder.,0.537247964039791,"Gets each folder path and generates FileFolders, with the qualified name of the form '<externalSourceName>::<path>'."," private List<FileFolder> extractFolders(String pathName, String externalSourceName, String methodName) throws InvalidParameterException{
        List<FileFolder> folders = new ArrayList<>();
        String[] folderNames = pathName.split(""/"");
        for (String folderName : folderNames) {
            FileFolder folder = new FileFolder(folderName, externalSourceName);
            folders.add(folder);
        }
        return folders;
    }",Empty Method,"private List<FileFolder> extractFolders(String pathName, String externalSourceName, String methodName) throws InvalidParameterException{
        List<FileFolder> folders = new ArrayList<>();
        String[] pathElements = pathName.split("">::"");
        if (pathElements.length < 2) {
            throw new InvalidParameterException(methodName, ""pathName"", pathName, ""The path name is invalid"");
        }
        String externalSource = pathElements[0];
        if (!externalSource.equals(externalSourceName)) {
            throw new InvalidParameterException(methodName, ""pathName"", pathName, ""The path name is invalid"");
        }
        for (int i = 1; i < pathElements.length; i++) {
            FileFolder folder = new FileFolder();
            folder.setQualifiedName(pathElements[i]);
            folder.setDisplayName(pathElements[i]);
            folder.setDescription(pathElements[i]);
            folder.setZoneMembership(new ArrayList<>());
            folder.setOwner(pathElements[i]);
            folder.setOwnerType(OwnerType.USER);
            folder.setOtherOriginValues(new HashMap<>());
            folder.setAdditionalProperties(new HashMap<>());
            folders.add(folder);
        }
        return folders;
    }"," private List<FileFolder> extractFolders(String pathName, String externalSourceName, String methodName) throws InvalidParameterException{
        List<FileFolder> folders = new ArrayList<>();
        String[] folderNames = pathName.split(""/"");
        for (String folderName : folderNames) {
            if (StringUtils.isNotEmpty(folderName)) {
                FileFolder folder = new FileFolder();
                folder.setQualifiedName(externalSourceName + ""::"" + folderName);
                folder.setDisplayName(folderName);
                folder.setDescription(folderName);
                folder.setZoneMembership(new ArrayList<>());
                folder.setOwner(externalSourceName);
                folder.setOwnerType(OwnerType.EXTERNAL_SOURCE);
                folder.setOtherOriginValues(new HashMap<>());
                folder.setAdditionalProperties(new HashMap<>());
                folders.add(folder);
            }
        }
        return folders;
    }",NOT PASS,Empty Method,NOT PASS,NOT PASS,  0.30103016380236125,None,  0.4189433753997386,  0.4353791230883737,101.0,0.6352201257861635,None,None,107.0,0.6645962732919255,150.0,0.672645739910314,None,None,86.0,0.5341614906832298,156.0,0.6995515695067265,16.0,0.8421052631578947,2.0,0.125,14.0,0.875
652,cdk,"public static IsotopePattern normalize(IsotopePattern isotopeP){
    IsotopeContainer isoHighest = null;
    double biggestAbundance = 0;
    /* Extraction of the isoContainer with the highest abundance */
    for (IsotopeContainer isoContainer : isotopeP.getIsotopes()) {
        double abundance = isoContainer.getIntensity();
        if (biggestAbundance < abundance) {
            biggestAbundance = abundance;
            isoHighest = isoContainer;
        }
    }
    /* Normalize */
    IsotopePattern isoNormalized = new IsotopePattern();
    for (IsotopeContainer isoContainer : isotopeP.getIsotopes()) {
        double inten = isoContainer.getIntensity() / isoHighest.getIntensity();
        IsotopeContainer icClone;
        try {
            icClone = (IsotopeContainer) isoContainer.clone();
            icClone.setIntensity(inten);
            if (isoHighest.equals(isoContainer))
                isoNormalized.setMonoIsotope(icClone);
            else
                isoNormalized.addIsotope(icClone);
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }
    isoNormalized.setCharge(isotopeP.getCharge());
    return isoNormalized;
}",normalize,org/openscience/cdk/formula/IsotopePatternManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/formula/IsotopePatternManipulator.java,"/**
     * Return the isotope pattern normalized to the highest abundance.
     *
     * @param isotopeP  The IsotopePattern object to normalize
     * @return          The IsotopePattern normalized
     */",17-55,"('normalize', {'INSTRUCTION': {'covered': 74, 'missed': 3}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 20, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",169.0,10.0,Return the isotope pattern normalized to the highest abundance.,"Given an IsotopePattern as input, it returns its normalized version to the highest abundance.",Return the pattern normalized to the highest amount.,0.119449781234633,Restore the standardized isotopic pattern to the highest abundance.,Empty Method,Not Valid,Not Valid,Empty Method,Empty Method,Not Valid,Empty Method,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,9.0,0.6,4.0,0.4,2.0,0.2
653,cdk,"public void replaceAtomContainer(int position, IAtomContainer container){
    IAtomContainer old = atomContainers[position];
    old.removeListener(this);
    atomContainers[position] = container;
    container.addListener(this);
    notifyChanged();
}",replaceAtomContainer,org/openscience/cdk/AtomContainerSet.java,/base/data/src/main/java/org/openscience/cdk/AtomContainerSet.java,"/**
     * Replace the AtomContainer at a specific position (array has to be large enough).
     *
     * @param position   position in array for AtomContainer
     * @param container  the replacement AtomContainer
     */",134-147,"('replaceAtomContainer', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,16.0,Replace the AtomContainer at a specific position (array has to be large enough).,The AtomContainer will be replaced at a specific given position.,Thearray has to be large enough to replace the AtomContainer.,0.33482061321682,Replace the AtomContainer at a specific position (the array must be large enough).," public void replaceAtomContainer(int position, IAtomContainer container){
        atomContainers[position] = container;
        notifyChanged();
    }"," public void replaceAtomContainer(int position, IAtomContainer container){
        atomContainers[position] = container;
        notifyChanged();
    }"," public void replaceAtomContainer(int position, IAtomContainer container){
        atomContainers[position] = container;
        atomContainers[position].addListener(this);
        notifyChanged();
    }"," public void replaceAtomContainer(int position, IAtomContainer container){
        atomContainers[position] = container;
        atomContainers[position].addListener(this);
        notifyChanged();
    }",PASS,PASS,PASS,PASS,  0.39570021266875127,  0.39570021266875127,  0.5552372058813397,  0.5552372058813397,22.0,0.4782608695652174,22.0,0.4782608695652174,14.0,0.30434782608695654,14.0,0.30434782608695654,0.0,0.0,10.0,0.29411764705882354,10.0,0.29411764705882354,12.0,0.8571428571428571,3.0,0.21428571428571427,12.0,0.8571428571428571
654,dataverse,"public static short[] allIndices(){
    short[] retVal = new short[64];
    for (short s = 0; s < 64; s++) retVal[s] = s;
    return retVal;
}",allIndices,edu/harvard/iq/dataverse/util/BitSet.java,/src/main/java/edu/harvard/iq/dataverse/util/BitSet.java,"/**
	 * Returns all the indices a bit set may have. Can be used for 
	 * cheap for-each loops (i.e. no boxing/unboxing).
	 * @return All the indices a BitSet has [0..63]
	 */",30-39,"('allIndices', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,10.0,Returns all the indices a bit set may have.,All the indiced featuring a bit set will be returned.,A bit set may have all the indices.,0.290372684467222,Returns all indexes that a bit set can have.,"public static short[] allIndices(){
	 short[] indices = new short[64];
	 for (int i = 0; i < 64; i++) {
		 indices[i] = (short)i;
	 }
	 return indices;
 }","public static short[] allIndices(){
	 short[] indices = new short[64];
	 for (short i = 0; i < 64; i++) {
		 indices[i] = i;
	 }
	 return indices;
 }",Not Valid,Not Valid,NOT PASS,NOT PASS,Not Valid,Not Valid,  0.71033947690861,  0.743776625383056,None,None,14.0,0.27450980392156865,10.0,0.20833333333333334,None,None,None,None,4.0,0.0784313725490196,None,None,None,None,7.0,0.6363636363636364,3.0,0.3,9.0,0.9
655,jackson-databind,"public void serialize(JsonGenerator g, SerializerProvider provider) throws IOException{
    @SuppressWarnings(""deprecation"")
    boolean trimEmptyArray = (provider != null) && !provider.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS);
    g.writeStartObject(this);
    for (Map.Entry<String, JsonNode> en : _children.entrySet()) {
        BaseJsonNode value = (BaseJsonNode) en.getValue();
        if (trimEmptyArray && value.isArray() && value.isEmpty(provider)) {
            continue;
        }
        g.writeFieldName(en.getKey());
        value.serialize(g, provider);
    }
    g.writeEndObject();
}",serialize,com/fasterxml/jackson/databind/node/ObjectNode.java,/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java,"/**
     * Method that can be called to serialize this node and
     * all of its descendants using specified JSON generator.
     */",301-331,"('serialize', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 3}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",124.0,19.0,Method that can be called to serialize this node and  all of its descendants using specified JSON generator.,Serialized the current node and all of its descendants using JSON generator.,This method can be used toserialize this and all of its descendants.,0.428614995217112,A method that can be called to serialize this node and all its descendants using a specified JSON generator.,"public void serialize(JsonGenerator g, SerializerProvider provider) throws IOException{
        if (_children.size() == 0) {
            g.writeStartObject();
            g.writeEndObject();
        } else {
            g.writeStartObject();
            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {
                g.writeFieldName(entry.getKey());
                entry.getValue().serialize(g, provider);
            }
            g.writeEndObject();
        }
    }","public void serialize(JsonGenerator g, SerializerProvider provider) throws IOException{
        if (_children.size() == 0) {
            g.writeStartObject();
            g.writeEndObject();
        } else {
            g.writeStartObject();
            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {
                g.writeFieldName(entry.getKey());
                entry.getValue().serialize(g, provider);
            }
            g.writeEndObject();
        }
    }","public void serialize(JsonGenerator g, SerializerProvider provider) throws IOException{
        if (_children.size() == 0) {
            g.writeStartObject();
            g.writeEndObject();
            return;
        }
        g.writeStartObject();
        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {
            String name = entry.getKey();
            JsonNode value = entry.getValue();
            if (value != null) {
                g.writeFieldName(name);
                value.serialize(g, provider);
            }
        }
        g.writeEndObject();
    }","public void serialize(JsonGenerator g, SerializerProvider provider) throws IOException{
        if (_children.size() == 0) {
            g.writeStartObject();
            g.writeEndObject();
            return;
        }
        g.writeStartObject();
        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {
            String name = entry.getKey();
            JsonNode value = entry.getValue();
            if (value != null) {
                g.writeFieldName(name);
                value.serialize(g, provider);
            }
        }
        g.writeEndObject();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.43419048643450214,  0.43419048643450214,  0.5180367299817044,  0.5180367299817044,60.0,0.48,60.0,0.48,53.0,0.424,53.0,0.424,0.0,0.0,28.0,0.24347826086956523,28.0,0.24347826086956523,9.0,0.47368421052631576,4.0,0.2,11.0,0.5789473684210527
656,openapi-generator,"public ValidationResult validate(TInput input){
    ValidationResult result = new ValidationResult();
    if (rules != null) {
        rules.forEach(it -> {
            ValidationRule.Result attempt = it.evaluate(input);
            if (attempt.passed()) {
                result.addResult(Validated.valid(it));
            } else {
                result.addResult(Validated.invalid(it, it.getFailureMessage(), attempt.getDetails()));
            }
        });
    }
    return result;
}",validate,org/openapitools/codegen/validation/GenericValidator.java,/modules/openapi-generator-core/src/main/java/org/openapitools/codegen/validation/GenericValidator.java,"/**
     * Validates input, resulting in a instance of {@link ValidationResult} which provides details on all validations performed (success, error, warning).
     *
     * @param input The object instance to be validated.
     *
     * @return A {@link ValidationResult} which details the success, error, and warning validation results.
     */",38-59,"('validate', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",99.0,28.0,"Validates input, resulting in a instance of {@link ValidationResult} which provides details on all validations performed (success, error, warning).","Once the input has been validated, it returns the resulting instance, which provides details on the validation status.","Validates input, resulting in a instance of @link ValidationResult which provides details on all validations.",0.99211923973508,"Validates the input, resulting in an instance of {@link ValidationResult} that provides details about all validations performed (success, error, warning).",Empty Method,Empty Method,Not Valid,Not Valid,Empty Method,Empty Method,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,17.0,0.85,4.0,0.19047619047619047,7.0,0.35
657,cdk,"public boolean partialCharges(IAtomContainer mol){
    int[][] adjList = mol.getProperty(MMFF_ADJLIST_CACHE);
    GraphUtil.EdgeToBondMap edgeMap = mol.getProperty(MMFF_EDGEMAP_CACHE);
    if (adjList == null || edgeMap == null)
        throw new IllegalArgumentException(""Invoke assignAtomTypes first."");
    effectiveCharges(mol);
    for (int v = 0; v < mol.getAtomCount(); v++) {
        IAtom atom = mol.getAtom(v);
        String symbType = atom.getAtomTypeName();
        final int thisType = mmffParamSet.intType(symbType);
        if (thisType == 0)
            continue;
        double pbci = mmffParamSet.getPartialBondChargeIncrement(thisType).doubleValue();
        for (int w : adjList[v]) {
            int otherType = mmffParamSet.intType(mol.getAtom(w).getAtomTypeName());
            if (otherType == 0)
                continue;
            IBond bond = edgeMap.get(v, w);
            int bondCls = mmffParamSet.getBondCls(thisType, otherType, bond.getOrder().numeric(), bond.getProperty(MMFF_AROM) != null);
            BigDecimal bci = mmffParamSet.getBondChargeIncrement(bondCls, thisType, otherType);
            if (bci != null) {
                atom.setCharge(atom.getCharge() - bci.doubleValue());
            } else {
                atom.setCharge(atom.getCharge() + (pbci - mmffParamSet.getPartialBondChargeIncrement(otherType).doubleValue()));
            }
        }
    }
    return true;
}",partialCharges,org/openscience/cdk/forcefield/mmff/Mmff.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/Mmff.java,"/**
     * Assign the partial charges, all existing charges are cleared.
     * Atom types must be assigned first. 
     *
     * @param mol molecule
     * @return charges were assigned
     * @see #effectiveCharges(IAtomContainer)
     * @see #assignAtomTypes(IAtomContainer)
     */",165-218,"('partialCharges', {'INSTRUCTION': {'covered': 119, 'missed': 19}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 21, 'missed': 2}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",282.0,11.0,"Assign the partial charges, all existing charges are cleared.","Clears all the existing charges, and it assigns those marked as partial.",All charges are cleared if the partial charges are assigned.,0.309121802584668,"Assign partial charges, all existing fees are erased."," public boolean partialCharges(IAtomContainer mol){
     
      int[][] adjList = mol.getProperty(MMFF_ADJLIST_CACHE);
      GraphUtil.EdgeToBondMap edgeMap = mol.getProperty(MMFF_EDGEMAP_CACHE);
     
      if (adjList == null || edgeMap == null)
            throw new IllegalArgumentException(""Invoke assignAtomTypes first."");
     
      primaryCharges(mol, adjList, edgeMap);
      partialCharges(mol, adjList);
     
      return true;
     }"," public boolean partialCharges(IAtomContainer mol){
     
      int[][] adjList = mol.getProperty(MMFF_ADJLIST_CACHE);
      GraphUtil.EdgeToBondMap edgeMap = mol.getProperty(MMFF_EDGEMAP_CACHE);
     
      if (adjList == null || edgeMap == null)
            throw new IllegalArgumentException(""Invoke assignAtomTypes first."");
     
      primaryCharges(mol, adjList, edgeMap);
      partialCharges(mol, adjList);
     
      return true;
     }"," public boolean partialCharges(IAtomContainer mol){
     
      int[][] adjList = mol.getProperty(MMFF_ADJLIST_CACHE);
      GraphUtil.EdgeToBondMap edgeMap = mol.getProperty(MMFF_EDGEMAP_CACHE);
     
      if (adjList == null || edgeMap == null)
            throw new IllegalArgumentException(""Invoke assignAtomTypes first."");
     
      primaryCharges(mol, adjList, edgeMap);
      partialCharges(mol, adjList);
     
      return true;
     }"," public boolean partialCharges(IAtomContainer mol){
     
      int[][] adjList = mol.getProperty(MMFF_ADJLIST_CACHE);
      GraphUtil.EdgeToBondMap edgeMap = mol.getProperty(MMFF_EDGEMAP_CACHE);
     
      if (adjList == null || edgeMap == null)
            throw new IllegalArgumentException(""Invoke assignAtomTypes first."");
     
      primaryCharges(mol, adjList, edgeMap);
      partialCharges(mol, adjList);
     
      return true;          
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.17755595451470227,  0.1804971309852905,  0.17755595451470227,  0.1804971309852905,217.0,0.7667844522968198,217.0,0.7667844522968198,217.0,0.7667844522968198,217.0,0.7667844522968198,0.0,0.0,0.0,0.0,0.0,0.0,10.0,0.7692307692307693,3.0,0.3,8.0,0.7272727272727273
658,shardingsphere-elasticjob,"public boolean isAllCompleted(){
    return jobNodeStorage.isJobNodeExisted(GuaranteeNode.COMPLETED_ROOT) && configService.load(false).getShardingTotalCount() <= jobNodeStorage.getJobNodeChildrenKeys(GuaranteeNode.COMPLETED_ROOT).size();
}",isAllCompleted,org/apache/shardingsphere/elasticjob/lite/internal/guarantee/GuaranteeService.java,/elasticjob-lite/elasticjob-lite-core/src/main/java/org/apache/shardingsphere/elasticjob/lite/internal/guarantee/GuaranteeService.java,"/**
     * Judge whether job's sharding items are all completed.
     *
     * @return job's sharding items are all completed or not
     */",109-117,"('isAllCompleted', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,10.0,Judge whether job's sharding items are all completed.,Checks if the job's sharding items have completed the task.,"If the job's shards are complete, judge.",0.189488081764545,Judge whether the partitioning items of the task are all complete.," public boolean isAllCompleted(){
        return jobNodeStorage.isJobNodeExisted(GuaranteeNode.COMPLETED_ROOT)
                && configService.load(false).getShardingTotalCount() == jobNodeStorage.getJobNodeChildrenKeys(GuaranteeNode.COMPLETED_ROOT).size();
    }"," public boolean isAllCompleted(){
        return jobNodeStorage.isJobNodeExisted(GuaranteeNode.COMPLETED_ROOT)
                && configService.load(false).getShardingTotalCount() == jobNodeStorage.getJobNodeChildrenKeys(GuaranteeNode.COMPLETED_ROOT).size();     
 }"," public boolean isAllCompleted(){
        return jobNodeStorage.isJobNodeExisted(GuaranteeNode.COMPLETED_ROOT)
                && configService.load(false).getShardingTotalCount() == jobNodeStorage.getJobNodeChildrenKeys(GuaranteeNode.COMPLETED_ROOT).size();     
 }"," public boolean isAllCompleted(){
        return jobNodeStorage.isJobNodeExisted(GuaranteeNode.COMPLETED_ROOT)
                && configService.load(false).getShardingTotalCount() == jobNodeStorage.getJobNodeChildrenKeys(GuaranteeNode.COMPLETED_ROOT).size();     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.9680149955071021,  0.9680149955071021,  0.9680149955071021,  0.9680149955071021,1.0,0.023809523809523808,1.0,0.023809523809523808,1.0,0.023809523809523808,1.0,0.023809523809523808,0.0,0.0,0.0,0.0,0.0,0.0,7.0,0.6363636363636364,6.0,0.5,6.0,0.6666666666666666
659,cdk,"private static boolean hasCommonAtom(IBond bondA, IBond bondB){
    return bondA.contains(bondB.getBegin()) || bondA.contains(bondB.getEnd());
}",hasCommonAtom,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,"/**
     * Determines if two bonds have at least one atom in common.
     *
     * @param  atom  first bondA1
     * @param  bondB  second bondA1
     * @return    the symbol of the common atom or """" if
     *            the 2 bonds have no common atom
     */",900-910,"('hasCommonAtom', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,12.0,Determines if two bonds have at least one atom in common.,Checks whether two bonds have at least one atom in common.,"If two bonds have the same atom, it's a sign that they are related.",1.06275679338011,Determines whether two bonds have at least one atom in common.," private static boolean hasCommonAtom(IBond bondA, IBond bondB){
        for (IAtom atomA : bondA.atoms()) {
            for (IAtom atomB : bondB.atoms()) {
                if (atomA.equals(atomB)) return true;
            }
        }
        return false;       
 }"," private static boolean hasCommonAtom(IBond bondA, IBond bondB){
        for (IAtom atomA : bondA.atoms()) {
            for (IAtom atomB : bondB.atoms()) {
                if (atomA.equals(atomB)) return true;
            }
        }
        return false;       
 }"," private static boolean hasCommonAtom(IBond bondA, IBond bondB){
        if (bondA.getBegin().equals(bondB.getBegin()) || bondA.getBegin().equals(bondB.getEnd())
                || bondA.getEnd().equals(bondB.getBegin()) || bondA.getEnd().equals(bondB.getEnd())) {
            return true;
        }
        return false;       
 }"," private static boolean hasCommonAtom(IBond bondA, IBond bondB){
        for (IAtom atomA : bondA.atoms()) {
            for (IAtom atomB : bondB.atoms()) {
                if (atomA.equals(atomB)) {
                    return true;
                }
            }
        }
        return false;       
 }",PASS,PASS,PASS,PASS,  0.4868381125650978,  0.4868381125650978,  0.4904128734991542,  0.6925357159378542,29.0,0.5272727272727272,29.0,0.5272727272727272,31.0,0.543859649122807,50.0,0.5952380952380952,0.0,0.0,2.0,0.03508771929824561,46.0,0.5476190476190477,2.0,0.16666666666666666,1.0,0.08333333333333333,12.0,0.8
660,jooby,"public static Config systemProperties(){
    return ConfigFactory.parseProperties(System.getProperties(), ConfigParseOptions.defaults().setOriginDescription(""system properties""));
}",systemProperties,io/jooby/Environment.java,/jooby/src/main/java/io/jooby/Environment.java,"/**
   * Creates a {@link Config} object from {@link System#getProperties()}.
   *
   * @return Configuration object.
   */",256-264,"('systemProperties', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,19.0,Creates a {@link Config} object from {@link System#getProperties()}.,A new Config object is created by calling the method getProperties().,The @link Config object is created from the @link System#getProperties,0.539425309075955,Creates a {@link Config} object from {@link System#getProperties()}.," public static Config systemProperties(){
    return ConfigFactory.parseProperties(System.getProperties());   
 }"," public static Config systemProperties(){
    return ConfigFactory.systemProperties();    
 }"," public static Config systemProperties(){
    return ConfigFactory.parseProperties(System.getProperties());   
 }"," public static Config systemProperties(){
    return ConfigFactory.parseProperties(System.getProperties());   
 }",NOT PASS,PASS,NOT PASS,NOT PASS, 0.5243581219839234, 0.2427314619958089, 0.5243581219839234, 0.5243581219839234,11.0,0.34375,17.0,0.53125,11.0,0.34375,11.0,0.34375,6.0,0.2857142857142857,0.0,0.0,0.0,0.0,11.0,0.9166666666666666,0.0,0.0,9.0,0.8181818181818182
661,cdk,"public boolean encode(long[] current, long[] next){
    int p = permutation.parity(current);
    // if is a permutation parity (all neighbors are different)
    if (p != 0) {
        // multiple with the geometric parity
        int q = geometric.parity() * p;
        // configure anticlockwise/clockwise
        if (q > 0) {
            for (int i : centres) {
                next[i] = current[i] * ANTICLOCKWISE;
            }
        } else if (q < 0) {
            for (int i : centres) {
                next[i] = current[i] * CLOCKWISE;
            }
        }
        // 0 parity ignored
        return true;
    }
    return false;
}",encode,org/openscience/cdk/hash/stereo/GeometryEncoder.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometryEncoder.java,"/**
     * Encodes the {@code centres[]} specified in the constructor as either
     * clockwise/anticlockwise or none. If there is a permutation parity but no
     * geometric parity then we can not encode the configuration and 'true' is
     * returned to indicate the perception is done. If there is no permutation
     * parity this may changed with the next {@code current[]} values and so
     * 'false' is returned.
     *
     *{@inheritDoc}
     */",82-119,"('encode', {'INSTRUCTION': {'covered': 72, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",110.0,19.0,Encodes the {@code centres[]} specified in the constructor as either  clockwise/anticlockwise or none.,"Returns true if the encoding of the centres[] as clockwise/anticlockwise has been successfull, false otherwise.",The @code centres[] specified in the constructor is either clockwise or anticlockwise.,1.22763530734978,Encodes the {@code centers[]} specified in the manufacturer clockwise/counterclockwise or counterclockwise or none.,"public boolean encode(long[] current, long[] next){
        long[] permuted = new long[centres.length];
        for (int i = 0; i < centres.length; i++) {
            permuted[i] = current[centres[i]];
        }
        long permutationParity = permutation.encode(permuted);
        long geometricParity = geometric.encode(current);
        long parity = permutationParity | geometricParity;
        for (int i = 0; i < centres.length; i++) {
            next[centres[i]] = parity;
        }
        return true;
    }","public boolean encode(long[] current, long[] next){
        long[] permuted = new long[centres.length];
        for (int i = 0; i < centres.length; i++) {
            permuted[i] = current[permutation.permute(centres[i])];
        }
        long parity = geometric.parity(permuted);
        for (int i = 0; i < centres.length; i++) {
            next[centres[i]] = parity;
        }
        return true;
    }","public boolean encode(long[] current, long[] next){
        int[] permutation = new int[centres.length];
        int[] geometric   = new int[centres.length];
    
        /*
        * calculate the permutation parity for the centres[]
        */
        for (int i = 0; i < centres.length; i++) {
            permutation[i] = permutation.get(centres[i]);
        }
    
        /*
        * calculate the geometric parity for the centres[]
        */
        for (int i = 0; i < centres.length; i++) {
            geometric[i] = geometric.get(centres[i]);
        }
    
        /*
        * calculate the parity for the permutation and geometric parity
        */
        long permutationParity = permutation.encode(permutation);
        long geometricParity   = geometric.encode(geometric);
    
        /*
        * calculate the parity for the clockwise and anticlockwise configuration
        */
        long clockwise = permutationParity | geometricParity;
        long anticlockwise = permutationParity | geometricParity;
    
        /*
        * encode the parity for the clockwise and anticlockwise configuration
        */
        current[0] = clockwise;
        next[0] = anticlockwise;
    
        return true;
    }","public boolean encode(long[] current, long[] next){
        int[] permutation = new int[centres.length];
        int[] geometric = new int[centres.length];
        for (int i = 0; i < centres.length; i++) {
            permutation[i] = centres[i];
            geometric[i] = centres[i];
        }
        Arrays.sort(permutation);
        Arrays.sort(geometric);
    
        long permutationParity = permutation.length % 2 == 0 ? CLOCKWISE : ANTICLOCKWISE;
        long geometricParity = geometric.length % 2 == 0 ? CLOCKWISE : ANTICLOCKWISE;
    
        for (int i = 0; i < permutation.length; i++) {
            permutationParity = permutationParity ^ permutation[i];
        }
        for (int i = 0; i < geometric.length; i++) {
            geometricParity = geometricParity ^ geometric[i];
        }
    
        current[0] = permutationParity;
        current[1] = geometricParity;
        return true;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.40441904768104975,  0.40981822235944043,  0.3754583472962775,  0.3916568641217075,87.0,0.7310924369747899,76.0,0.6846846846846847,143.0,0.7295918367346939,110.0,0.6875,25.0,0.21008403361344538,100.0,0.5102040816326531,78.0,0.4875,13.0,0.8125,5.0,0.35714285714285715,7.0,0.5
662,cdk,"private boolean checkGeometric(int u1, int u2, int[] mapping){
    int v1 = mapping[u1];
    int v2 = mapping[u2];
    if (targetTypes[v1] != Type.Geometric || targetTypes[v2] != Type.Geometric)
        return false;
    IDoubleBondStereochemistry queryElement = (IDoubleBondStereochemistry) queryElements[u1];
    IDoubleBondStereochemistry targetElement = (IDoubleBondStereochemistry) targetElements[v1];
    if (!targetElement.getStereoBond().contains(target.getAtom(v1)) || !targetElement.getStereoBond().contains(target.getAtom(v2)))
        return false;
    boolean swap = false;
    if (!targetElement.getStereoBond().getBegin().equals(target.getAtom(v1))) {
        int tmp = v1;
        v1 = v2;
        v2 = tmp;
        swap = true;
    }
    IBond[] queryBonds = queryElement.getBonds();
    IBond[] targetBonds = targetElement.getBonds();
    int p = parity(queryElement.getStereo());
    int q = parity(targetElement.getStereo());
    int uLeft = queryMap.get(queryBonds[0].getOther(query.getAtom(u1)));
    int uRight = queryMap.get(queryBonds[1].getOther(query.getAtom(u2)));
    int vLeft = targetMap.get(targetBonds[0].getOther(target.getAtom(v1)));
    int vRight = targetMap.get(targetBonds[1].getOther(target.getAtom(v2)));
    if (swap) {
        int tmp = vLeft;
        vLeft = vRight;
        vRight = tmp;
    }
    if (mapping[uLeft] != vLeft)
        p *= -1;
    if (mapping[uRight] != vRight)
        p *= -1;
    return p == q;
}",checkGeometric,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,"/**
     * Verify the geometric stereochemistry (cis/trans) of the double bond
     * {@code u1=u2} is preserved in the target when the {@code mapping} is
     * used.
     *
     * @param u1      one index of the double bond
     * @param u2      other index of the double bond
     * @param mapping mapping of vertices
     * @return the geometric configuration is preserved
     */",222-280,"('checkGeometric', {'INSTRUCTION': {'covered': 150, 'missed': 26}, 'BRANCH': {'covered': 10, 'missed': 8}, 'LINE': {'covered': 21, 'missed': 7}, 'COMPLEXITY': {'covered': 2, 'missed': 8}, 'METHOD': {'covered': 1, 'missed': 0}})",354.0,31.0,Verify the geometric stereochemistry (cis/trans) of the double bond  {@code u1=u2} is preserved in the target when the {@code mapping} is  used.,Checks whether the geometric stereochemistry configuration is preserved.,The double bond @codeu1 is preserved in the target when the @code mapping is used.,0.755641271847901,Verify that the geometric stereochemistry (cis/trans) of the double link {@code u1=u2} is retained in the target when the {@code mapping} is used.,Empty Method,"private boolean checkGeometric(int u1, int u2, int[] mapping){
        int v1 = mapping[u1];
        int v2 = mapping[u2];
        if (targetTypes[v1] != Type.Geometric) return false;
        if (targetTypes[v2] != Type.Geometric) return false;
    
        IGeometricChirality queryElement = (IGeometricChirality) queryElements[u1];
        IGeometricChirality targetElement = (IGeometricChirality) targetElements[v1];
    
        // access neighbors of each element, then map the query to the target
        int[] us = neighbors(queryElement, queryMap);
        int[] vs = neighbors(targetElement, targetMap);
        us = map(u1, v1, us, mapping);
        vs = map(u2, v2, vs, mapping);
    
        if (us == null || vs == null) return false;
    
        int p = permutationParity(us) * parity(queryElement.getStereo());
        int q = permutationParity(vs) * parity(targetElement.getStereo());
    
        return p == q;
    }",Not Valid,Empty Method,Empty Method,NOT PASS,Empty Method,Not Valid,None,  0.3506133445252368,None,None,None,None,241.0,0.6788732394366197,None,None,None,None,185.0,0.9946236559139785,None,None,None,None,19.0,0.8260869565217391,3.0,0.125,11.0,0.4782608695652174
663,cdk,"public static PermutationGroup makeSymN(int size){
    List<Permutation> generators = new ArrayList<Permutation>();
    // p1 is (0, 1)
    int[] p1 = new int[size];
    p1[0] = 1;
    p1[1] = 0;
    for (int i = 2; i < size; i++) {
        p1[i] = i;
    }
    // p2 is (1, 2, ...., n, 0)
    int[] p2 = new int[size];
    p2[0] = 1;
    for (int i = 1; i < size - 1; i++) {
        p2[i] = i + 1;
    }
    p2[size - 1] = 0;
    generators.add(new Permutation(p1));
    generators.add(new Permutation(p2));
    return new PermutationGroup(size, generators);
}",makeSymN,org/openscience/cdk/group/PermutationGroup.java,/tool/group/src/main/java/org/openscience/cdk/group/PermutationGroup.java,"/**
     * Make the symmetric group Sym(N) for N. That is, a group of permutations
     * that represents _all_ permutations of size N.
     *
     * @param size the size of the permutation
     * @return a group for all permutations of N
     */",152-182,"('makeSymN', {'INSTRUCTION': {'covered': 74, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",157.0,11.0,Make the symmetric group Sym(N) for N.,Returns a group of permutations representing all the permutations of size N.,Sym(N) is a group for N.,0.398552998573338,Create the symmetric group Sym(N) for N.,"public static PermutationGroup makeSymN(int size){
        List<Permutation> generators = new ArrayList<Permutation>();
        generators.add(new Permutation(size));
        for (int i = 0; i < size; i++) {
            generators.add(new Permutation(size));
            generators.get(i).set(i, i + 1);
            generators.get(i).set(i + 1, i);
        }
        return new PermutationGroup(size, generators);
    }","public static PermutationGroup makeSymN(int size){
        List<Permutation> generators = new ArrayList<Permutation>();
        for (int i = 0; i < size; i++) {
            generators.add(new Permutation(size));
            generators.get(i).set(i, i);
        }
        for (int i = 0; i < size; i++) {
            generators.get(i).set(i, i + 1);
        }
        return new PermutationGroup(size, generators);
    }","public static PermutationGroup makeSymN(int size){
        List<Permutation> generators = new ArrayList<Permutation>();
        generators.add(new Permutation(size));
        for (int i = 1; i < size; i++) {
            generators.add(new Permutation(size));
            generators.get(i).set(i, i - 1);
            generators.get(i).set(i - 1, i);
        }
        return new PermutationGroup(size, generators);
    }","public static PermutationGroup makeSymN(int size){
        List<Permutation> generators = new ArrayList<Permutation>();
        generators.add(new Permutation(size));
        for (int i = 1; i < size; i++) {
            generators.add(new Permutation(size));
            generators.get(i).set(i, i - 1);
            generators.get(i).set(i - 1, i);
        }
        return new PermutationGroup(size, generators);
    }",NOT PASS,NOT PASS,PASS,PASS,  0.41757805878541854,  0.4344264701645789,  0.4228595171251239,  0.4228595171251239,90.0,0.569620253164557,89.0,0.5632911392405063,90.0,0.569620253164557,90.0,0.569620253164557,32.0,0.29906542056074764,3.0,0.028846153846153848,3.0,0.028846153846153848,11.0,0.8461538461538461,1.0,0.125,4.0,0.5
664,acs-aem-commons,"private Map<String, String[]> formatExtensions(final Map<String, String> configuredExtensions){
    final Map<String, String[]> extensions = new LinkedHashMap<>();
    for (final Map.Entry<String, String> entry : configuredExtensions.entrySet()) {
        final String ext = entry.getKey().trim();
        extensions.put(ext, entry.getValue().trim().split(""&""));
    }
    return extensions;
}",formatExtensions,com/adobe/acs/commons/replication/dispatcher/impl/RefetchFlushContentBuilderImpl.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/impl/RefetchFlushContentBuilderImpl.java,"/**
     * Take the mapped extensions and organize them by individual extension.
     * @param configuredExtensions Map of extension mappings
     * @return Map with extension as keys
     */",126-140,"('formatExtensions', {'INSTRUCTION': {'covered': 33, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",100.0,11.0,Take the mapped extensions and organize them by individual extension.,"Given as input a configuredExtension object, unfold it by individual extension.",Take the mapped extensions and organize them by extension.,0.364883395267714,Take the mapped extensions and organize them by individual extension.," private Map<String, String[]> formatExtensions(final Map<String, String> configuredExtensions){
        Map<String, String[]> extensionPairs = new LinkedHashMap<>();
    
        if (MapUtils.isNotEmpty(configuredExtensions)) {
            for (Map.Entry<String, String> entry : configuredExtensions.entrySet()) {
                String key = entry.getKey();
                String value = entry.getValue();
    
                if (StringUtils.isNotEmpty(key) && StringUtils.isNotEmpty(value)) {
                    String[] extensions = value.split("","");
    
                    if (ArrayUtils.isNotEmpty(extensions)) {
                        extensionPairs.put(key, extensions);
                    }
                }
            }
        }
    
        return extensionPairs;
    }","private Map<String, String[]> formatExtensions(final Map<String, String> configuredExtensions){
        Map<String, String[]> extensionPairs = new LinkedHashMap<>();
    
        for (Map.Entry<String, String> entry : configuredExtensions.entrySet()) {
            String key = entry.getKey();
            String value = entry.getValue();
    
            if (StringUtils.isNotEmpty(key) && StringUtils.isNotEmpty(value)) {
                String[] values = value.split("","");
                if (values.length > 0) {
                    extensionPairs.put(key, values);
                }
            }
        }
    
        return extensionPairs;
    }"," private Map<String, String[]> formatExtensions(final Map<String, String> configuredExtensions){
        Map<String, String[]> extensionPairs = new LinkedHashMap<>();
    
        if (MapUtils.isNotEmpty(configuredExtensions)) {
            for (Map.Entry<String, String> entry : configuredExtensions.entrySet()) {
                String[] extensions = entry.getValue().split("","");
    
                if (ArrayUtils.isNotEmpty(extensions)) {
                    extensionPairs.put(entry.getKey(), extensions);
                }
            }
        }
    
        return extensionPairs;
    }"," private Map<String, String[]> formatExtensions(final Map<String, String> configuredExtensions){
        Map<String, String[]> extensionPairs = new LinkedHashMap<>();
    
        if (MapUtils.isNotEmpty(configuredExtensions)) {
            for (Map.Entry<String, String> entry : configuredExtensions.entrySet()) {
                String[] extensions = entry.getValue().split("","");
    
                if (ArrayUtils.isNotEmpty(extensions)) {
                    for (String extension : extensions) {
                        extensionPairs.put(extension, new String[]{entry.getKey()});
                    }
                }
            }
        }
    
        return extensionPairs;
    }",PASS,PASS,NOT PASS,NOT PASS,  0.6575120151486101,  0.6995542529652908,  0.6747459567397661,  0.6922609517942835,60.0,0.4225352112676056,49.0,0.3769230769230769,51.0,0.3953488372093023,40.0,0.3508771929824561,18.0,0.1267605633802817,44.0,0.30985915492957744,40.0,0.28169014084507044,8.0,0.6666666666666666,0.0,0.0,1.0,0.09090909090909091
665,tablesaw,"public IntColumn asIntColumn(){
    IntColumn result = IntColumn.create(name());
    for (double d : data) {
        if (DoubleColumnType.valueIsMissing(d)) {
            result.appendMissing();
        } else {
            result.append((int) d);
        }
    }
    return result;
}",asIntColumn,tech/tablesaw/api/DoubleColumn.java,/core/src/main/java/tech/tablesaw/api/DoubleColumn.java,"/**
   * Returns a new IntColumn containing a value for each value in this column, truncating if
   * necessary.
   *
   * <p>A narrowing primitive conversion such as this one may lose information about the overall
   * magnitude of a numeric value and may also lose precision and range. Specifically, if the value
   * is too small (a negative value of large magnitude or negative infinity), the result is the
   * smallest representable value of type int.
   *
   * <p>Similarly, if the value is too large (a positive value of large magnitude or positive
   * infinity), the result is the largest representable value of type int.
   *
   * <p>Despite the fact that overflow, underflow, or other loss of information may occur, a
   * narrowing primitive conversion never results in a run-time exception.
   *
   * <p>A missing value in the receiver is converted to a missing value in the result
   */",566-594,"('asIntColumn', {'INSTRUCTION': {'covered': 27, 'missed': 4}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,18.0,"Returns a new IntColumn containing a value for each value in this column, truncating if  necessary.","A new intColumn containing a value for each value in the column is returned. When needed, the truncate operation might be applied.","If necessary, returns a new IntColumn with a value for each value in it.",0.325515867148405,"Returns a new IntColumn containing a value for each value in this column, truncating if necessary."," public IntColumn asIntColumn(){
    IntColumn result = IntColumn.create(name());
    for (double d : data) {
      if (DoubleColumnType.valueIsMissing(d)) {
        result.appendMissing();
      } else {
        result.append((int) d);
      }
    }
    return result;
  }"," public IntColumn asIntColumn(){
    IntColumn result = IntColumn.create(name());
    for (double d : data) {
      if (DoubleColumnType.valueIsMissing(d)) {
        result.appendMissing();
      } else {
        result.append((int) d);
      }
    }
    return result;
  }"," public IntColumn asIntColumn(){
    IntColumn result = IntColumn.create(name());
    for (double d : data) {
      if (DoubleColumnType.valueIsMissing(d)) {
        result.appendMissing();
      } else {
        result.append((int) d);
      }
    }
    return result;
  }"," public IntColumn asIntColumn(){
    IntColumn result = IntColumn.create(name());
    for (double d : data) {
      if (DoubleColumnType.valueIsMissing(d)) {
        result.appendMissing();
      } else {
        result.append((int) d);
      }
    }
    return result;
  }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,15.0,0.6521739130434783,0.0,0.0,9.0,0.5294117647058824
666,cdk,"private static Trie insert(Trie trie, String str, int i){
    if (trie == null)
        trie = new Trie();
    if (i == str.length()) {
        trie.token = str;
    } else {
        final char c = str.charAt(i);
        trie.children[c] = insert(trie.children[c], str, i + 1);
    }
    return trie;
}",insert,org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,"/**
     * Insert a string (str) into the trie.
     *
     * @param trie trie node
     * @param str  the string to insert
     * @param i    index in the string
     * @return a created child node or null
     */",427-445,"('insert', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,10.0,Insert a string (str) into the trie.,Insert the string given as input into the trie and it returns a new child node.,A string is inserted into the trie.,0.269462279063584,Insert a string (str) into the sort.,Empty Method,Empty Method,"private static Trie insert(Trie trie, String str, int i){
        if (i == str.length())
            return trie;
        final char c = norm(str.charAt(i));
        if (c > 128)
            return trie;
        if (trie.children[c] == null)
            trie.children[c] = new Trie();
        return insert(trie.children[c], str, i + 1);
    }","private static Trie insert(Trie trie, String str, int i){
        if (trie == null) {
            trie = new Trie();
        }
        if (i == str.length()) {
            trie.token = str;
            return trie;
        }
        final char c = norm(str.charAt(i));
        if (c > 128)
            return trie;
        trie.children[c] = insert(trie.children[c], str, i + 1);
        return trie;
    }",Empty Method,Empty Method,PASS,NOT PASS,None,None,  0.8038014533206649,  0.6524074748261255,None,None,None,None,19.0,0.18627450980392157,48.0,0.5161290322580645,None,None,101.0,0.9901960784313726,92.0,0.989247311827957,12.0,0.7058823529411765,1.0,0.125,4.0,0.5
667,dcache,"public boolean isParentOf(StatePath otherPath){
    if (otherPath == null) {
        return false;
    }
    if ((_elements.size() + 1) != otherPath._elements.size()) {
        return false;
    }
    for (int i = 0; i < _elements.size(); i++) {
        if (_elements.get(i) != otherPath._elements.get(i)) {
            return false;
        }
    }
    return true;
}",isParentOf,org/dcache/services/info/base/StatePath.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StatePath.java,"/**
     * Check whether otherPath points to a location that is a child of this location.  This is true
     * iff each element of this path is identical to the corresponding element in otherPath and
     * otherPath has length precisely greater by one.
     * <pre>
     *  StatePath p1 = new StatePath(""foo.bar"");
     *  StatePath p2 = new StatePath(""foo.bar.baz"");
     *  StatePath p3 = new StatePath(""foo.bar.baz.other"");
     *
     *  p1.isParentOf(p1) // false
     *  p1.isParentOf(p2) // true
     *  p1.isParentOf(p3) // false
     *  p2.isParentOf(p1) // false
     *  p2.isParentOf(p2) // false
     *  p2.isParentOf(p3) // true
     * </pre>
     *
     * @param otherPath
     * @return
     */",229-266,"('isParentOf', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,15.0,Check whether otherPath points to a location that is a child of this location.,Returns true if the object otherPath points to a location that is a child of the current location; false otherwise.,"If otherpath points to a child of this location, you should check it.",0.292471395428758,Check if otherPath points to a location that is a child of that location.,"public boolean isParentOf(StatePath otherPath){
        if (otherPath == null) {
            return false;
        }
    
        if (otherPath._elements.size() < _elements.size()) {
            return false;
        }
    
        for (int i = 0; i < _elements.size(); i++) {
            if (_elements.get(i) != otherPath._elements.get(i)) {
                return false;
            }
        }
    
        return true;
    }","public boolean isParentOf(StatePath otherPath){
        if (otherPath == null) {
            return false;
        }
    
        if (otherPath._elements.size() < _elements.size()) {
            return false;
        }
    
        for (int i = 0; i < _elements.size(); i++) {
            if (_elements.get(i) != otherPath._elements.get(i)) {
                return false;
            }
        }
    
        return true;
    }","public boolean isParentOf(StatePath otherPath){
        if (otherPath == null) {
            return false;
        }
    
        if (otherPath._elements.size() <= _elements.size()) {
            return false;
        }
    
        for (int i = 0; i < _elements.size(); i++) {
            // We use intern()ed strings for this to work.
            if (_elements.get(i) != otherPath._elements.get(i)) {
                return false;
            }
        }
    
        return true;
    }","public boolean isParentOf(StatePath otherPath){
        if (otherPath == null) {
            return false;
        }
    
        if (otherPath._elements.size() <= _elements.size()) {
            return false;
        }
    
        for (int i = 0; i < _elements.size(); i++) {
            // We use intern()ed strings for this to work.
            if (_elements.get(i) != otherPath._elements.get(i)) {
                return false;
            }
        }
    
        return true;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.9170817367401729,  0.9170817367401729,  0.9170817367401729,  0.9170817367401729,8.0,0.08695652173913043,8.0,0.08695652173913043,8.0,0.08695652173913043,8.0,0.08695652173913043,0.0,0.0,1.0,0.011363636363636364,1.0,0.011363636363636364,10.0,0.47619047619047616,2.0,0.13333333333333333,11.0,0.7333333333333333
668,tablesaw,"LongColumn timeWindow(ChronoUnit unit, int n, LocalDateTime start){
    String newColumnName = """" + n + "" "" + unit.toString() + "" window ["" + name() + ""]"";
    long packedStartDate = pack(start);
    LongColumn numberColumn = LongColumn.create(newColumnName, size());
    for (int i = 0; i < size(); i++) {
        long packedDate = getLongInternal(i);
        long result;
        switch(unit) {
            case MINUTES:
                result = minutesUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case HOURS:
                result = hoursUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case DAYS:
                result = daysUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case WEEKS:
                result = weeksUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case MONTHS:
                result = monthsUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case YEARS:
                result = yearsUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            default:
                throw new UnsupportedTemporalTypeException(""The ChronoUnit "" + unit + "" is not supported for timeWindows on dates"");
        }
    }
    numberColumn.setPrintFormatter(NumberColumnFormatter.ints());
    return numberColumn;
}",timeWindow,tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,"/**
   * Returns a column containing integers representing the nth group (0-based) that a date falls
   * into.
   *
   * <p>Example: When Unit = ChronoUnit.DAY and n = 5, we form 5 day groups. a Date that is 2 days
   * after the start is assigned to the first (""0"") group. A day 7 days after the start is assigned
   * to the second (""1"") group.
   *
   * @param unit A ChronoUnit greater than or equal to a minute
   * @param n The number of units in each group.
   * @param start The starting point of the first group; group boundaries are offsets from this
   *     point
   */",378-430,"('timeWindow', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",271.0,18.0,Returns a column containing integers representing the nth group (0-based) that a date falls  into.,An integer value representing the number of the column will be returned according to the position the date falls into.,A column containing numbers representing the nth group that a date falls into.,0.403572245159453,Returns a column containing integers representing the nth group (based on 0) in which a date is located.,"LongColumn timeWindow(ChronoUnit unit, int n, LocalDateTime start){
    LongColumn newColumn = LongColumn.create(this.name() + "" time window "" + unit.name() + "" "" + n, this.size());
    for (int r = 0; r < this.size(); r++) {
      if (isMissing(r)) {
        newColumn.appendMissing();
      } else {
        long c1 = getLongInternal(r);
        newColumn.append(PackedLocalDateTime.timeWindow(c1, unit, n, start));
      }
    }
    return newColumn;
  }","LongColumn timeWindow(ChronoUnit unit, int n, LocalDateTime start){
    LongColumn newColumn = LongColumn.create(this.name() + "" time window"", this.size());
    for (int r = 0; r < this.size(); r++) {
      if (!isMissing(r)) {
        long c1 = this.getLongInternal(r);
        newColumn.set(r, (long) getTimeWindow(c1, unit, n, start));
      }
    }
    return newColumn;
  }",Empty Method,Empty Method,NOT PASS,NOT PASS,Empty Method,Empty Method,  0.17341288281976347,  0.1418649178125195,None,None,204.0,0.75,205.0,0.7536764705882353,None,None,None,None,30.0,0.2631578947368421,None,None,None,None,16.0,0.7619047619047619,7.0,0.3684210526315789,4.0,0.25
669,egeria,"private RelationshipsContext buildDataFileContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
    Set<GraphContext> context = new HashSet<>();
    addConnectionToAssetContext(userId, entityDetail, context);
    EntityDetail fileFolder = handlerHelper.addContextForRelationships(userId, entityDetail, NESTED_FILE, context);
    addContextForFileFolder(userId, fileFolder, context);
    return new RelationshipsContext(entityDetail.getGUID(), context);
}",buildDataFileContext,org/odpi/openmetadata/accessservices/assetlineage/handlers/AssetContextHandler.java,/open-metadata-implementation/access-services/asset-lineage/asset-lineage-server/src/main/java/org/odpi/openmetadata/accessservices/assetlineage/handlers/AssetContextHandler.java,"/**
     * Builds the data file context for a tabular column.
     *
     * @param userId       the unique identifier for the user
     * @param entityDetail the entity for which the context is build
     *
     * @return the data file context of the tabular column
     *
     * @throws OCFCheckedExceptionBase checked exception for reporting errors found when using OCF connectors
     */",305-325,"('buildDataFileContext', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,10.0,Builds the data file context for a tabular column.,Builds and returns the data file context for a tabular column.,The data file context is built.,0.0955800495017509,Generates the context of the data file for a tabular column.," private RelationshipsContext buildDataFileContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
        Set<GraphContext> context = new HashSet<>();
    
        EntityDetail schemaType = handlerHelper.addContextForRelationships(userId, entityDetail, ATTRIBUTE_FOR_SCHEMA, context);
    
        EntityDetail deployedSchemaType = handlerHelper.addContextForRelationships(userId, schemaType, ASSET_SCHEMA_TYPE, context);
    
        EntityDetail database = handlerHelper.addContextForRelationships(userId, deployedSchemaType, DATA_CONTENT_FOR_DATA_SET, context);
    
        if (database != null) {
            addConnectionToAssetContext(userId, database, context);
        }
    
        return new RelationshipsContext(entityDetail.getGUID(), context);
    }"," private RelationshipsContext buildDataFileContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
        Set<GraphContext> context = new HashSet<>();
    
        EntityDetail schemaType = handlerHelper.addContextForRelationships(userId, entityDetail, ATTRIBUTE_FOR_SCHEMA, context);
    
        EntityDetail deployedSchemaType = handlerHelper.addContextForRelationships(userId, schemaType, ASSET_SCHEMA_TYPE, context);
    
        EntityDetail database = handlerHelper.addContextForRelationships(userId, deployedSchemaType, DATA_CONTENT_FOR_DATA_SET, context);
    
        if (database != null) {
            addConnectionToAssetContext(userId, database, context);
        }
    
        return new RelationshipsContext(entityDetail.getGUID(), context);
    }"," private RelationshipsContext buildDataFileContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
        Set<GraphContext> context = new HashSet<>();
    
        EntityDetail schemaType = handlerHelper.addContextForRelationships(userId, entityDetail, ATTRIBUTE_FOR_SCHEMA, context);
    
        EntityDetail deployedSchemaType = handlerHelper.addContextForRelationships(userId, schemaType, ASSET_SCHEMA_TYPE, context);
    
        EntityDetail database = handlerHelper.addContextForRelationships(userId, deployedSchemaType, DATA_CONTENT_FOR_DATA_SET, context);
    
        if (database != null) {
            addConnectionToAssetContext(userId, database, context);
        }
    
        return new RelationshipsContext(entityDetail.getGUID(), context);
    }"," private RelationshipsContext buildDataFileContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
        Set<GraphContext> context = new HashSet<>();
    
        EntityDetail schemaType = handlerHelper.addContextForRelationships(userId, entityDetail, ATTRIBUTE_FOR_SCHEMA, context);
    
        EntityDetail deployedSchemaType = handlerHelper.addContextForRelationships(userId, schemaType, ASSET_SCHEMA_TYPE, context);
    
        EntityDetail database = handlerHelper.addContextForRelationships(userId, deployedSchemaType, DATA_CONTENT_FOR_DATA_SET, context);
    
        if (database != null) {
            addConnectionToAssetContext(userId, database, context);
        }
    
        return new RelationshipsContext(entityDetail.getGUID(), context);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7888928406735339,  0.7888928406735339,  0.7888928406735339,  0.802050735410376,37.0,0.3490566037735849,37.0,0.3490566037735849,37.0,0.3490566037735849,37.0,0.3490566037735849,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.16666666666666666,5.0,0.4166666666666667,6.0,0.6
674,jooby,"static List<String> expandOptionalVariables(@Nonnull String pattern){
    if (pattern == null || pattern.isEmpty() || pattern.equals(""/"")) {
        return Collections.singletonList(""/"");
    }
    int len = pattern.length();
    AtomicInteger key = new AtomicInteger();
    Map<Integer, StringBuilder> paths = new HashMap<>();
    BiConsumer<Integer, StringBuilder> pathAppender = (index, segment) -> {
        for (int i = index; i < index - 1; i++) {
            paths.get(i).append(segment);
        }
        paths.computeIfAbsent(index, current -> {
            StringBuilder value = new StringBuilder();
            if (current > 0) {
                StringBuilder previous = paths.get(current - 1);
                if (!previous.toString().equals(""/"")) {
                    value.append(previous);
                }
            }
            return value;
        }).append(segment);
    };
    StringBuilder segment = new StringBuilder();
    boolean isLastOptional = false;
    for (int i = 0; i < len; ) {
        char ch = pattern.charAt(i);
        if (ch == '/') {
            if (segment.length() > 0) {
                pathAppender.accept(key.get(), segment);
                segment.setLength(0);
            }
            segment.append(ch);
            i += 1;
        } else if (ch == '{') {
            segment.append(ch);
            int curly = 1;
            int j = i + 1;
            while (j < len) {
                char next = pattern.charAt(j++);
                segment.append(next);
                if (next == '{') {
                    curly += 1;
                } else if (next == '}') {
                    curly -= 1;
                    if (curly == 0) {
                        break;
                    }
                }
            }
            if (j < len && pattern.charAt(j) == '?') {
                j += 1;
                isLastOptional = true;
                if (paths.isEmpty()) {
                    paths.put(0, new StringBuilder(""/""));
                }
                pathAppender.accept(key.incrementAndGet(), segment);
            } else {
                isLastOptional = false;
                pathAppender.accept(key.get(), segment);
            }
            segment.setLength(0);
            i = j;
        } else {
            segment.append(ch);
            i += 1;
        }
    }
    if (paths.isEmpty()) {
        return Collections.singletonList(pattern);
    }
    if (segment.length() > 0) {
        pathAppender.accept(key.get(), segment);
        if (isLastOptional) {
            paths.put(key.incrementAndGet(), segment);
        }
    }
    return paths.values().stream().map(StringBuilder::toString).collect(Collectors.toList());
}",expandOptionalVariables,io/jooby/Router.java,/jooby/src/main/java/io/jooby/Router.java,"/**
   * Look for optional path parameter and expand the given pattern into multiple pattern.
   *
   * <pre>
   *   /path =&gt; [/path]
   *   /{id} =&gt; [/{id}]
   *   /path/{id} =&gt; [/path/{id}]
   *
   *   /{id}? =&gt; [/, /{id}]
   *   /path/{id}? =&gt; [/path, /path/{id}]
   *   /path/{id}/{start}?/{end}? =&gt; [/path/{id}, /path/{id}/{start}, /path/{id}/{start}/{end}]
   *   /path/{id}?/suffix =&gt; [/path, /path/{id}, /path/suffix]
   * </pre>
   *
   * @param pattern Pattern.
   * @return One or more patterns.
   */",1174-1270,"('expandOptionalVariables', {'INSTRUCTION': {'covered': 183, 'missed': 0}, 'BRANCH': {'covered': 33, 'missed': 1}, 'LINE': {'covered': 53, 'missed': 0}, 'COMPLEXITY': {'covered': 17, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",565.0,14.0,Look for optional path parameter and expand the given pattern into multiple pattern.,"Searches for optional path parameters, and it grows the given pattern into several of these.","If you want to expand the pattern into multiple patterns, look for optional path parameters.",0.420741924919468,Locate the optional path parameter and expand the given template into multiple templates.,"static List<String> expandOptionalVariables(@Nonnull String pattern){
    List<String> result = new ArrayList<>();
    int start = -1;
    int end = Integer.MAX_VALUE;
    int len = pattern.length();
    int curly = 0;
    for (int i = 0; i < len; i++) {
      char ch = pattern.charAt(i);
      if (ch == '{') {
        if (curly == 0) {
          start = i + 1;
          end = Integer.MAX_VALUE;
        }
        curly += 1;
      } else if (ch == ':') {
        end = i;
      } else if (ch == '}') {
        curly -= 1;
        if (curly == 0) {
          String id = pattern.substring(start, Math.min(i, end));
          String value;
          if (end == Integer.MAX_VALUE) {
            value = null;
          } else {
            value = pattern.substring(end + 1, i);
          }
          result.add(id);
          start = -1;
          end = Integer.MAX_VALUE;
        }
      } else if (ch == '*') {
        String id;
        if (i == len - 1) {
          id = ""*"";
        } else {
          id = pattern.substring(i + 1);
        }
        result.add(id);
        i = len;
      }
    }
    switch (result.size()) {
      case 0:
        return Collections.emptyList();
      case 1:
        return Collections.singletonList(result.get(0));
      default:
        return unmodifiableList(result);
    }   
 }","static List<String> expandOptionalVariables(@Nonnull String pattern){
    List<String> result = new ArrayList<>();
    int start = -1;
    int end = Integer.MAX_VALUE;
    int len = pattern.length();
    int curly = 0;
    for (int i = 0; i < len; i++) {
      char ch = pattern.charAt(i);
      if (ch == '{') {
        if (curly == 0) {
          start = i + 1;
          end = Integer.MAX_VALUE;
        }
        curly += 1;
      } else if (ch == ':') {
        end = i;
      } else if (ch == '}') {
        curly -= 1;
        if (curly == 0) {
          String id = pattern.substring(start, Math.min(i, end));
          String value;
          if (end == Integer.MAX_VALUE) {
            value = null;
          } else {
            value = pattern.substring(end + 1, i);
          }
          result.add(id);
          start = -1;
          end = Integer.MAX_VALUE;
        }
      } else if (ch == '*') {
        String id;
        if (i == len - 1) {
          id = ""*"";
        } else {
          id = pattern.substring(i + 1);
        }
        result.add(id);
        i = len;
      }
    }
    switch (result.size()) {
      case 0:
        return Collections.emptyList();
      case 1:
        return Collections.singletonList(result.get(0));
      default:
        return unmodifiableList(result);
    }   
 }","static List<String> expandOptionalVariables(@Nonnull String pattern){
    List<String> result = new ArrayList<>();
    int start = -1;
    int end = Integer.MAX_VALUE;
    int len = pattern.length();
    int curly = 0;
    for (int i = 0; i < len; i++) {
      char ch = pattern.charAt(i);
      if (ch == '{') {
        if (curly == 0) {
          start = i + 1;
          end = Integer.MAX_VALUE;
        }
        curly += 1;
      } else if (ch == ':') {
        end = i;
      } else if (ch == '}') {
        curly -= 1;
        if (curly == 0) {
          String id = pattern.substring(start, Math.min(i, end));
          String value;
          if (end == Integer.MAX_VALUE) {
            value = null;
          } else {
            value = pattern.substring(end + 1, i);
          }
          result.add(id);
          start = -1;
          end = Integer.MAX_VALUE;
        }
      } else if (ch == '*') {
        String id;
        if (i == len - 1) {
          id = ""*"";
        } else {
          id = pattern.substring(i + 1);
        }
        result.add(id);
        i = len;
      }
    }
    switch (result.size()) {
      case 0:
        return Collections.emptyList();
      case 1:
        return Collections.singletonList(result.get(0));
      default:
        return unmodifiableList(result);
    }   
 }","static List<String> expandOptionalVariables(@Nonnull String pattern){
    List<String> result = new ArrayList<>();
    int start = -1;
    int end = Integer.MAX_VALUE;
    int len = pattern.length();
    int curly = 0;
    for (int i = 0; i < len; i++) {
      char ch = pattern.charAt(i);
      if (ch == '{') {
        if (curly == 0) {
          start = i + 1;
          end = Integer.MAX_VALUE;
        }
        curly += 1;
      } else if (ch == ':') {
        end = i;
      } else if (ch == '}') {
        curly -= 1;
        if (curly == 0) {
          String id = pattern.substring(start, Math.min(i, end));
          String value;
          if (end == Integer.MAX_VALUE) {
            value = null;
          } else {
            value = pattern.substring(end + 1, i);
          }
          result.add(id);
          start = -1;
          end = Integer.MAX_VALUE;
        }
      } else if (ch == '*') {
        String id;
        if (i == len - 1) {
          id = ""*"";
        } else {
          id = pattern.substring(i + 1);
        }
        result.add(id);
        i = len;
      }
    }
    switch (result.size()) {
      case 0:
        return Collections.emptyList();
      case 1:
        return Collections.singletonList(result.get(0));
      default:
        return unmodifiableList(result);
    }   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.28684675951357724,  0.28522338289020066,  0.283600006266824,  0.283600006266824,413.0,0.7296819787985865,413.0,0.7296819787985865,413.0,0.7296819787985865,413.0,0.7296819787985865,0.0,0.0,0.0,0.0,0.0,0.0,7.0,0.4375,4.0,0.2857142857142857,13.0,0.8125
675,cdk,"public DescriptorValue calculate(IAtomContainer atomContainer){
    if (checkRingSystem)
        Cycles.markRingAtomsAndBonds(atomContainer);
    final Set<IAtom> included = new HashSet<>();
    for (IAtom atom : atomContainer.atoms()) {
        if (!atom.isInRing() && atom.getAtomicNumber() != 1)
            included.add(atom);
    }
    IAtomContainer subset = subsetMol(atomContainer, included);
    AllPairsShortestPaths apsp = new AllPairsShortestPaths(subset);
    int max = 0;
    int numAtoms = subset.getAtomCount();
    for (int i = 0; i < numAtoms; i++) {
        for (int j = i + 1; j < numAtoms; j++) {
            int len = apsp.from(i).pathTo(j).length;
            if (len > max)
                max = len;
        }
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(max), getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/LargestChainDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/LargestChainDescriptor.java,"/**
     * Calculate the count of atoms of the largest chain in the supplied {@link IAtomContainer}.
     *
     * @param atomContainer The {@link IAtomContainer} for which this descriptor is to be calculated
     * @return the number of atoms in the largest chain of this AtomContainer
     * @see #setParameters
     */",149-184,"('calculate', {'INSTRUCTION': {'covered': 92, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",192.0,18.0,Calculate the count of atoms of the largest chain in the supplied {@link IAtomContainer}.,Computes the count of largest atom's chain in the provided IAtomCointainer.,The supplied IAtomContainer has a count of the largest chain.,0.536082797090362,Calculate the number of atoms of the largest chain in the provided {@link IAtomContainer}.,"public DescriptorValue calculate(IAtomContainer atomContainer){
        try {
            int nAtomLC = 0;
            int nAtom = atomContainer.getAtomCount();
            int[][] adjacencyMatrix = new int[nAtom][nAtom];
            for (int i = 0; i < nAtom; i++) {
                for (int j = 0; j < nAtom; j++) {
                    adjacencyMatrix[i][j] = 0;
                }
            }
            for (IBond bond : atomContainer.bonds()) {
                int i = atomContainer.getAtomNumber(bond.getBegin());
                int j = atomContainer.getAtomNumber(bond.getEnd());
                adjacencyMatrix[i][j] = 1;
                adjacencyMatrix[j][i] = 1;
            }
            AllPairsShortestPaths allPairsShortestPaths = new AllPairsShortestPaths(adjacencyMatrix);
            int[][] shortestPaths = allPairsShortestPaths.getShortestPaths();
            for (int i = 0; i < nAtom; i++) {
                for (int j = 0; j < nAtom; j++) {
                    if (shortestPaths[i][j] > 1) {
                        nAtomLC++;
                    }
                }
            }
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(
                    nAtomLC), getDescriptorNames());
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }","public DescriptorValue calculate(IAtomContainer atomContainer){
        try {
            int nAtomLC = 0;
            int nAtom = atomContainer.getAtomCount();
            int[][] adjacencyMatrix = new int[nAtom][nAtom];
            for (int i = 0; i < nAtom; i++) {
                for (int j = 0; j < nAtom; j++) {
                    adjacencyMatrix[i][j] = 0;
                }
            }
            for (IBond bond : atomContainer.bonds()) {
                int i = atomContainer.getAtomNumber(bond.getBegin());
                int j = atomContainer.getAtomNumber(bond.getEnd());
                adjacencyMatrix[i][j] = 1;
                adjacencyMatrix[j][i] = 1;
            }
            AllPairsShortestPaths allPairsShortestPaths = new AllPairsShortestPaths(adjacencyMatrix);
            int[][] shortestPaths = allPairsShortestPaths.getShortestPaths();
            for (int i = 0; i < nAtom; i++) {
                for (int j = 0; j < nAtom; j++) {
                    if (shortestPaths[i][j] > 1) {
                        nAtomLC++;
                    }
                }
            }
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(
                    nAtomLC), getDescriptorNames());
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }",Not Valid,"public DescriptorValue calculate(IAtomContainer atomContainer){
        try {
            if (atomContainer == null) {
                return getDummyDescriptorValue(new CDKException(""Null molecule provided""));
            }
            if (atomContainer.getAtomCount() == 0) {
                return getDummyDescriptorValue(new CDKException(""Empty molecule provided""));
            }
            if (atomContainer.getBondCount() == 0) {
                return getDummyDescriptorValue(new CDKException(""Empty molecule provided""));
            }
            if (checkRingSystem) {
                if (!atomContainer.getFlag(CDKConstants.ISINRING)) {
                    return getDummyDescriptorValue(new CDKException(""The molecule is not in a ring system""));
                }
            }
            // get the largest chain
            int maxChain = 0;
            int maxChainSize = 0;
            int[] chainLengths = new int[atomContainer.getAtomCount()];
            for (int i = 0; i < atomContainer.getAtomCount(); i++) {
                chainLengths[i] = 0;
            }
            for (int i = 0; i < atomContainer.getAtomCount(); i++) {
                if (chainLengths[i] == 0) {
                    int chainLength = getChainLength(atomContainer, i, chainLengths);
                    if (chainLength > maxChainSize) {
                        maxChainSize = chainLength;
                        maxChain = i;
                    }
                }
            }
            // return the number of atoms in the largest chain
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(
                    maxChainSize), getDescriptorNames());
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }       
 }",NOT PASS,NOT PASS,NOT PASS,Not Valid,  0.42733439034629234,  0.42733439034629234,  0.3806557529120418,None,161.0,0.6264591439688716,161.0,0.6264591439688716,153.0,0.59765625,None,None,0.0,0.0,173.0,0.6731517509727627,None,None,8.0,0.5333333333333333,2.0,0.13333333333333333,12.0,0.8
676,jeromq,"public static boolean startsWith(Msg msg, String data, boolean includeLength){
    final int length = data.length();
    assert (length < 256);
    int start = includeLength ? 1 : 0;
    if (msg.size() < length + start) {
        return false;
    }
    boolean comparison = includeLength ? length == (msg.get(0) & 0xff) : true;
    if (comparison) {
        for (int idx = start; idx < length; ++idx) {
            comparison = (msg.get(idx) == data.charAt(idx - start));
            if (!comparison) {
                break;
            }
        }
    }
    return comparison;
}",startsWith,zmq/io/Msgs.java,/src/main/java/zmq/io/Msgs.java,"/**
     * Checks if the message starts with the given string.
     *
     * @param msg the message to check.
     * @param data the string to check the message with. Shall be shorter than 256 characters.
     * @param includeLength true if the string in the message is prefixed with the length, false if not.
     * @return true if the message starts with the given string, otherwise false.
     */",12-39,"('startsWith', {'INSTRUCTION': {'covered': 62, 'missed': 6}, 'BRANCH': {'covered': 17, 'missed': 3}, 'LINE': {'covered': 11, 'missed': 1}, 'COMPLEXITY': {'covered': 8, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",133.0,10.0,Checks if the message starts with the given string.,"Returns true if the message starts with the string provided as input, false otherwise","If the message starts with a string, it's checked.",0.0674189870349301,Checks whether the message starts with the given string.,"public static boolean startsWith(Msg msg, String data, boolean includeLength){
        if(includeLength){
            if(msg.size() < data.length()){
                return false;
            }
        }else{
            if(msg.size() < data.length() - 1){
                return false;
            }
        }
        for(int i = 0; i < data.length(); i++){
            if(msg.data()[i] != data.charAt(i)){
                return false;
            }
        }
        return true;        
 }","public static boolean startsWith(Msg msg, String data, boolean includeLength){
        if(includeLength){
            if(msg.size() < data.length()){
                return false;
            }
        }
        else{
            if(msg.size() < data.length() - 1){
                return false;
            }
        }
        for(int i = 0; i < data.length(); i++){
            if(msg.data()[i] != data.charAt(i)){
                return false;
            }
        }
        return true;        
 }",Not Valid,"public static boolean startsWith(Msg msg, String data, boolean includeLength){
        if (msg.size() < data.length())
            return false;
        for (int i = 0; i < data.length(); i++)
            if (msg.data()[i] != data.charAt(i))
                return false;
        if (includeLength)
            return true;
        return msg.size() == data.length();     
 }",NOT PASS,NOT PASS,NOT PASS,Not Valid,  0.3399115250685323,  0.3399115250685323,  0.33480410846724634,None,81.0,0.6044776119402985,81.0,0.6044776119402985,87.0,0.6492537313432836,None,None,0.0,0.0,51.0,0.45535714285714285,None,None,8.0,0.5333333333333333,1.0,0.1,6.0,0.6
679,cdk,"public static float[] generateMoments(IAtomContainer atomContainer) throws CDKException{
    // lets check if we have 3D coordinates
    Iterator<IAtom> atoms;
    int natom = atomContainer.getAtomCount();
    Point3d ctd = getGeometricCenter(atomContainer);
    Point3d cst = new Point3d();
    Point3d fct = new Point3d();
    Point3d ftf = new Point3d();
    double[] distCtd = new double[natom];
    double[] distCst = new double[natom];
    double[] distFct = new double[natom];
    double[] distFtf = new double[natom];
    atoms = atomContainer.atoms().iterator();
    int counter = 0;
    double min = Double.MAX_VALUE;
    double max = Double.MIN_VALUE;
    // eval dist to centroid
    while (atoms.hasNext()) {
        IAtom atom = atoms.next();
        Point3d p = atom.getPoint3d();
        double d = p.distance(ctd);
        distCtd[counter++] = d;
        if (d < min) {
            cst.x = p.x;
            cst.y = p.y;
            cst.z = p.z;
            min = d;
        }
        if (d > max) {
            fct.x = p.x;
            fct.y = p.y;
            fct.z = p.z;
            max = d;
        }
    }
    // eval dist to cst
    atoms = atomContainer.atoms().iterator();
    counter = 0;
    while (atoms.hasNext()) {
        IAtom atom = atoms.next();
        Point3d p = atom.getPoint3d();
        double d = p.distance(cst);
        distCst[counter++] = d;
    }
    // eval dist to fct
    atoms = atomContainer.atoms().iterator();
    counter = 0;
    max = Double.MIN_VALUE;
    while (atoms.hasNext()) {
        IAtom atom = atoms.next();
        Point3d p = atom.getPoint3d();
        double d = p.distance(fct);
        distFct[counter++] = d;
        if (d > max) {
            ftf.x = p.x;
            ftf.y = p.y;
            ftf.z = p.z;
            max = d;
        }
    }
    // eval dist to ftf
    atoms = atomContainer.atoms().iterator();
    counter = 0;
    while (atoms.hasNext()) {
        IAtom atom = atoms.next();
        Point3d p = atom.getPoint3d();
        double d = p.distance(ftf);
        distFtf[counter++] = d;
    }
    float[] moments = new float[12];
    float mean = mu1(distCtd);
    float sigma2 = mu2(distCtd, mean);
    float skewness = mu3(distCtd, mean, Math.sqrt(sigma2));
    moments[0] = mean;
    moments[1] = sigma2;
    moments[2] = skewness;
    mean = mu1(distCst);
    sigma2 = mu2(distCst, mean);
    skewness = mu3(distCst, mean, Math.sqrt(sigma2));
    moments[3] = mean;
    moments[4] = sigma2;
    moments[5] = skewness;
    mean = mu1(distFct);
    sigma2 = mu2(distFct, mean);
    skewness = mu3(distFct, mean, Math.sqrt(sigma2));
    moments[6] = mean;
    moments[7] = sigma2;
    moments[8] = skewness;
    mean = mu1(distFtf);
    sigma2 = mu2(distFtf, mean);
    skewness = mu3(distFtf, mean, Math.sqrt(sigma2));
    moments[9] = mean;
    moments[10] = sigma2;
    moments[11] = skewness;
    return moments;
}",generateMoments,org/openscience/cdk/similarity/DistanceMoment.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/similarity/DistanceMoment.java,"/**
     * Evaluate the 12 descriptors used to characterize the 3D shape of a molecule.
     *
     * @param atomContainer The molecule to consider, should have 3D coordinates
     * @return A 12 element array containing the descriptors.
     * @throws CDKException if there are no 3D coordinates
     */",81-199,"('generateMoments', {'INSTRUCTION': {'covered': 311, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 85, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",711.0,14.0,Evaluate the 12 descriptors used to characterize the 3D shape of a molecule.,The method helps in evaluating the 12 descriptors that are used to distinguish the 3D shape of a molecule.,Evaluate the 12 descriptors used to make a molecule.,0.481512051991809,Evaluate the 12 descriptors used to characterize the 3D shape of a molecule.,"public static float[] generateMoments(IAtomContainer atomContainer) throws CDKException{
        Point3d centroid = getGeometricCenter(atomContainer);
        double[] dists = new double[atomContainer.getAtomCount()];
        double[] dists2 = new double[atomContainer.getAtomCount()];
        double[] dists3 = new double[atomContainer.getAtomCount()];
        double[] dists4 = new double[atomContainer.getAtomCount()];
        double[] dists5 = new double[atomContainer.getAtomCount()];
        double[] dists6 = new double[atomContainer.getAtomCount()];
        double[] dists7 = new double[atomContainer.getAtomCount()];
        double[] dists8 = new double[atomContainer.getAtomCount()];
        double[] dists9 = new double[atomContainer.getAtomCount()];
        double[] dists10 = new double[atomContainer.getAtomCount()];
        double[] dists11 = new double[atomContainer.getAtomCount()];
        double[] dists12 = new double[atomContainer.getAtomCount()];
        double[] dists13 = new double[atomContainer.getAtomCount()];
        double[] dists14 = new double[atomContainer.getAtomCount()];
        double[] dists15 = new double[atomContainer.getAtomCount()];
        double[] dists16 = new double[atomContainer.getAtomCount()];
        double[] dists17 = new double[atomContainer.getAtomCount()];
        double[] dists18 = new double[atomContainer.getAtomCount()];
        double[] dists19 = new double[atomContainer.getAtomCount()];
        double[] dists20 = new double[atomContainer.getAtomCount()];
        double[] dists21 = new double[atomContainer.getAtomCount()];
        double[] dists22 = new double[atomContainer.getAtomCount()];
        double[] dists23 = new double[atomContainer.getAtomCount()];
        double[] dists24 = new double[atomContainer.getAtomCount()];
        double[] d      
 }","public static float[] generateMoments(IAtomContainer atomContainer) throws CDKException{
        Point3d centroid = getGeometricCenter(atomContainer);
        double[] x = new double[atomContainer.getAtomCount()];
        double[] y = new double[atomContainer.getAtomCount()];
        double[] z = new double[atomContainer.getAtomCount()];
        int i = 0;
        for (IAtom atom : atomContainer.atoms()) {
            Point3d p = atom.getPoint3d();
            if (p == null) throw new CDKException(""Molecule must have 3D coordinates"");
            x[i] = p.x - centroid.x;
            y[i] = p.y - centroid.y;
            z[i] = p.z - centroid.z;
            i++;
        }
        float[] moments = new float[12];
        moments[0] = mu1(x);
        moments[1] = mu1(y);
        moments[2] = mu1(z);
        moments[3] = mu2(x, moments[0]);
        moments[4] = mu2(y, moments[1]);
        moments[5] = mu2(z, moments[2]);
        moments[6] = mu3(x, moments[0], Math.sqrt(moments[3]));
        moments[7] = mu3(y, moments[1], Math.sqrt(moments[4]));
        moments[8] = mu3(z, moments[2], Math.sqrt(moments[5]));
        moments[9] = mu3(x, moments[0], moments[3]);
        moments[10] = mu3(y, moments[1], moments[4]);
        moments[11] = mu3(z, moments[2], moments[5]);
        return moments;     
 }","public static float[] generateMoments(IAtomContainer atomContainer) throws CDKException{
        double[] x = new double[atomContainer.getAtomCount()];
        double[] y = new double[atomContainer.getAtomCount()];
        double[] z = new double[atomContainer.getAtomCount()];
        double[] d = new double[atomContainer.getAtomCount()];
        double[] d2 = new double[atomContainer.getAtomCount()];
        double[] d3 = new double[atomContainer.getAtomCount()];
        double[] d4 = new double[atomContainer.getAtomCount()];
        double[] d5 = new double[atomContainer.getAtomCount()];
        double[] d6 = new double[atomContainer.getAtomCount()];
        double[] d7 = new double[atomContainer.getAtomCount()];
        double[] d8 = new double[atomContainer.getAtomCount()];
        double[] d9 = new double[atomContainer.getAtomCount()];
        double[] d10 = new double[atomContainer.getAtomCount()];
        double[] d11 = new double[atomContainer.getAtomCount()];
        double[] d12 = new double[atomContainer.getAtomCount()];
        double[] d13 = new double[atomContainer.getAtomCount()];
        double[] d14 = new double[atomContainer.getAtomCount()];
        double[] d15 = new double[atomContainer.getAtomCount()];
        double[] d16 = new double[atomContainer.getAtomCount()];
        double[] d17 = new double[atomContainer.getAtomCount()];
        double[] d18 = new double[atomContainer.getAtomCount()];
        double[] d19 = new double[atomContainer.getAtomCount()];
        double[] d20 = new double[atomContainer.getAtomCount()];
        double[] d21 = new double[atomContainer.getAtomCount()];
        double[] d22 = new double[atomContainer.getAtomCount()];
        double[] d23 = new double[atomContainer.getAtomCount()];
        double[] d24 = new double[      
 }","public static float[] generateMoments(IAtomContainer atomContainer) throws CDKException{
        Point3d centroid = getGeometricCenter(atomContainer);
        double[] x = new double[atomContainer.getAtomCount()];
        double[] y = new double[atomContainer.getAtomCount()];
        double[] z = new double[atomContainer.getAtomCount()];
        int i = 0;
        for (IAtom atom : atomContainer.atoms()) {
            Point3d p = atom.getPoint3d();
            x[i] = p.x - centroid.x;
            y[i] = p.y - centroid.y;
            z[i] = p.z - centroid.z;
            i++;
        }
        float[] moments = new float[12];
        moments[0] = mu1(x);
        moments[1] = mu1(y);
        moments[2] = mu1(z);
        moments[3] = mu2(x, moments[0]);
        moments[4] = mu2(y, moments[1]);
        moments[5] = mu2(z, moments[2]);
        moments[6] = mu3(x, moments[0], moments[3]);
        moments[7] = mu3(y, moments[1], moments[4]);
        moments[8] = mu3(z, moments[2], moments[5]);
        return moments;     
 }",Syntax Error,NOT PASS,NOT PASS,Syntax Error,None,  0.2619856239485773,  0.2212915641051852,None,None,None,520.0,0.7303370786516854,535.0,0.7514044943820225,544.0,0.7640449438202247,264.0,0.6821705426356589,248.0,0.6408268733850129,54.0,0.13075060532687652,8.0,0.4,0.0,0.0,5.0,0.35714285714285715
680,acs-aem-commons,"public static void write(Layer layer, double quality, OutputStream out) throws IOException{
    ImageWriter writer = null;
    ImageOutputStream imageOut = null;
    try {
        ImageWriteParam iwp = new JPEGImageWriteParam(null);
        iwp.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
        iwp.setProgressiveMode(ImageWriteParam.MODE_DEFAULT);
        iwp.setCompressionQuality((float) quality);
        writer = ImageIO.getImageWritersBySuffix(""jpeg"").next();
        imageOut = ImageIO.createImageOutputStream(out);
        writer.setOutput(imageOut);
        BufferedImage image = getRgbImage(layer);
        writer.write(null, new IIOImage(image, null, null), iwp);
    } finally {
        if (writer != null) {
            writer.dispose();
        }
        if (imageOut != null) {
            try {
                imageOut.close();
            } catch (IOException e) {
                // ignore
            }
        }
    }
}",write,com/adobe/acs/commons/images/impl/ProgressiveJpeg.java,/bundle/src/main/java/com/adobe/acs/commons/images/impl/ProgressiveJpeg.java,"/**
     * For JPEG images, this method behaves similar to {@link Layer#write(String, double, OutputStream)}. The major
     * difference is that it uses progressive encoding.
     *
     * @param layer   the layer with the image to write to the output stream
     * @param quality JPEG compression quality between 0 and 1
     * @param out     target output stream
     * @throws IOException if anything goes wrong
     */",43-80,"('write', {'INSTRUCTION': {'covered': 53, 'missed': 1}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 17, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",165.0,24.0,"For JPEG images, this method behaves similar to {@link Layer#write(String, double, OutputStream)}.",Writes a JPEG image using a progressive encoding.,"This method behaves similar to @link Layer#write(String, double, OutputStream) for JPEG images.",1.13257370480507,"For JPEG images, this method behaves in the same way as {@link Layer#write(String, double, OutputStream)}.",Empty Method," public static void write(Layer layer, double quality, OutputStream out) throws IOException{
        BufferedImage image = layer.getImage();
        if (image.getType() != BufferedImage.TYPE_INT_RGB) {
            image = new ColorConvertOp(null).filter(image, null);
        }
        ImageWriter writer = ImageIO.getImageWritersByFormatName(""jpeg"").next();
        ImageWriteParam param = new JPEGImageWriteParam(null);
        param.setProgressiveMode(ImageWriteParam.MODE_EXPLICIT);
        param.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
        param.setCompressionQuality((float) quality);
        writer.setOutput(ImageIO.createImageOutputStream(out));
        writer.write(null, new IIOImage(image, null, null), param);
        writer.dispose();
    }"," public static void write(Layer layer, double quality, OutputStream out) throws IOException{
        BufferedImage image = layer.getImage();
        BufferedImage convertedImage = new ColorConvertOp(null).filter(image, null);
        ImageWriter writer = ImageIO.getImageWritersByFormatName(""jpeg"").next();
        ImageWriteParam param = writer.getDefaultWriteParam();
        param.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
        param.setCompressionQuality((float) quality);
        ImageOutputStream ios = ImageIO.createImageOutputStream(out);
        writer.setOutput(ios);
        writer.write(null, new IIOImage(convertedImage, null, null), param);
        ios.close();
    }"," public static void write(Layer layer, double quality, OutputStream out) throws IOException{
        BufferedImage image = layer.getImage();
        if (image.getColorModel().hasAlpha()) {
            image = new ColorConvertOp(null, null).filter(image, null);
        }
        ImageWriter writer = ImageIO.getImageWritersByFormatName(""jpeg"").next();
        ImageWriteParam param = writer.getDefaultWriteParam();
        param.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
        param.setCompressionQuality(quality);
        ImageOutputStream ios = ImageIO.createImageOutputStream(out);
        writer.setOutput(ios);
        writer.write(null, new IIOImage(image, null, null), param);
        ios.close();
    }",Empty Method,NOT PASS,NOT PASS,NOT PASS,None,  0.5164016871650075,  0.4672193697151659,  0.4836303447984745,None,None,106.0,0.6385542168674698,103.0,0.6204819277108434,100.0,0.6024096385542169,144.0,0.993103448275862,139.0,0.9928571428571429,127.0,0.9921875,12.0,0.9230769230769231,5.0,0.3125,9.0,0.6923076923076923
681,cdk,"public double predict(IAtomContainer mol) throws CDKException{
    if (mol == null || mol.getAtomCount() == 0)
        throw new CDKException(""Molecule cannot be blank or null."");
    CircularFingerprinter circ = new CircularFingerprinter(classType);
    circ.setPerceiveStereo(optPerceiveStereo);
    circ.calculate(mol);
    final int AND_BITS = folding - 1;
    Set<Integer> hashset = new HashSet<Integer>();
    for (int n = circ.getFPCount() - 1; n >= 0; n--) {
        int code = circ.getFP(n).hashCode;
        if (folding > 0)
            code &= AND_BITS;
        hashset.add(code);
    }
    double val = 0;
    for (int h : hashset) {
        Double c = contribs.get(h);
        if (c != null)
            val += c;
    }
    return val;
}",predict,org/openscience/cdk/fingerprint/model/Bayesian.java,/tool/model/src/main/java/org/openscience/cdk/fingerprint/model/Bayesian.java,"/**
     * For a given molecule, determines its fingerprints and uses them to calculate a Bayesian prediction. Note that this
     * value is unscaled, and so it only has relative meaning within the confines of the model, i.e. higher is more likely to
     * be active.
     * 
     * @param mol molecular structure which cannot be blank or null
     * @return predictor value
     */",265-297,"('predict', {'INSTRUCTION': {'covered': 83, 'missed': 5}, 'BRANCH': {'covered': 8, 'missed': 4}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",165.0,17.0,"For a given molecule, determines its fingerprints and uses them to calculate a Bayesian prediction.",Using a Bayesian prediction schema computes the molecule's fingerprint.,A molecule's fingerprints are used to calculate a prediction.,0.296310049973236,"For a given molecule, determines its fingerprints and uses them to calculate a Bayesian prediction.",Empty Method,Empty Method,"public double predict(IAtomContainer mol) throws CDKException{
        if (mol == null || mol.getAtomCount() == 0) throw new CDKException(""Molecule cannot be blank or null."");
    
        CircularFingerprinter circ = new CircularFingerprinter(classType);
        circ.setPerceiveStereo(optPerceiveStereo);
        circ.calculate(mol);
    
        // gather all of the (folded) fingerprints into a sorted set
        final int AND_BITS = folding - 1; // e.g. 1024/0x400 -> 1023/0x3FF: chop off higher order bits
        Set<Integer> hashset = new TreeSet<Integer>();
        for (int n = circ.getFPCount() - 1; n >= 0; n--) {
            int code = circ.getFP(n).hashCode;
            if (folding > 0) code &= AND_BITS;
            hashset.add(code);
        }
    
        // convert the set into a sorted primitive array
        int[] hashes = new int[hashset.size()];
        int p = 0;
        for (Integer h : hashset)
            hashes[p++] = h;
    
        // calculate the prediction
        double pred = 0;
        for (int h : hashes)
            pred += contribs.get(h);
        return pred;        
 }","public double predict(IAtomContainer mol) throws CDKException{
        if (mol == null || mol.getAtomCount() == 0) throw new CDKException(""Molecule cannot be blank or null."");
    
        CircularFingerprinter circ = new CircularFingerprinter(classType);
        circ.setPerceiveStereo(optPerceiveStereo);
        circ.calculate(mol);
    
        // gather all of the (folded) fingerprints into a sorted set
        final int AND_BITS = folding - 1; // e.g. 1024/0x400 -> 1023/0x3FF: chop off higher order bits
        Set<Integer> hashset = new TreeSet<Integer>();
        for (int n = circ.getFPCount() - 1; n >= 0; n--) {
            int code = circ.getFP(n).hashCode;
            if (folding > 0) code &= AND_BITS;
            hashset.add(code);
        }
    
        // convert the set into a sorted primitive array
        int[] hashes = new int[hashset.size()];
        int p = 0;
        for (Integer h : hashset)
            hashes[p++] = h;
    
        // calculate the contribution of each fingerprint
        double val = 0;
        for (int hash : hashes)
            val += contribs.get(hash);
    
        // return the Bayesian prediction
        return val;     
 }",Empty Method,Empty Method,PASS,PASS,None,None,  0.8428465794971187,  0.8406900092201801,None,None,None,None,42.0,0.22340425531914893,44.0,0.23404255319148937,None,None,187.0,0.9946808510638298,187.0,0.9946808510638298,14.0,0.875,0.0,0.0,10.0,0.625
682,cdk,"private static int readMolfileInt(final String line, final int index){
    int sign = 1;
    int result = 0;
    char c;
    switch((c = line.charAt(index))) {
        case ' ':
            break;
        case '-':
            sign = -1;
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            result = (c - '0');
            break;
        default:
            return 0;
    }
    if (index + 1 == line.length())
        return sign * result;
    switch((c = line.charAt(index + 1))) {
        case ' ':
            if (result > 0)
                return sign * result;
            break;
        case '-':
            if (result > 0)
                return sign * result;
            sign = -1;
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            result = (result * 10) + (c - '0');
            break;
        default:
            return sign * result;
    }
    if (index + 2 == line.length())
        return sign * result;
    switch((c = line.charAt(index + 2))) {
        case ' ':
            if (result > 0)
                return sign * result;
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            result = (result * 10) + (c - '0');
            break;
        default:
            return sign * result;
    }
    return sign * result;
}",readMolfileInt,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Optimised method for reading a integer from 3 characters in a string at a
     * specified index. MDL V2000 Molfile make heavy use of the 3 character ints
     * in the atom/bond and property blocks. The integer may be signed and
     * pre/post padded with white space.
     *
     * @param line  input
     * @param index start index
     * @return the value specified in the string
     */",1687-1769,"('readMolfileInt', {'INSTRUCTION': {'covered': 89, 'missed': 19}, 'BRANCH': {'covered': 16, 'missed': 5}, 'LINE': {'covered': 22, 'missed': 5}, 'COMPLEXITY': {'covered': 9, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",335.0,17.0,Optimised method for reading a integer from 3 characters in a string at a  specified index.,Reads and returns an integer from the starting index position given as input down to its +3 characaters.,The method for reading a string from 3 characters is improved.,1.72061288905061,Optimized method to read an integer from 3 characters in a string at a specified index.,"private static int readMolfileInt(final String line, final int index){
        int result = 0;
        result += toInt(line.charAt(index));
        result += toInt(line.charAt(index+1)) * 10;
        result += toInt(line.charAt(index+2)) * 100;
        return result;
    }","private static int readMolfileInt(final String line, final int index){
        int result = 0;
        for (int i = index; i < index + 3; i++) {
            result = (result * 10) + toInt(line.charAt(i));
        }
        return result;
    }","private static int readMolfileInt(final String line, final int index){
        int result = 0;
        for (int i = 0; i < 3; i++) {
            result = (result * 10) + toInt(line.charAt(index + i));
        }
        return result;
    }","private static int readMolfileInt(final String line, final int index){
        int result = 0;
        result += toInt(line.charAt(index));
        result *= 10;
        result += toInt(line.charAt(index+1));
        result *= 10;
        result += toInt(line.charAt(index+2));
        return result;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.15270438011654439,  0.1392611298638473,  0.14982681555636024,  0.1333331142571284,276.0,0.8214285714285714,286.0,0.8511904761904762,274.0,0.8154761904761905,286.0,0.8511904761904762,32.0,0.47058823529411764,9.0,0.125,30.0,0.4411764705882353,17.0,0.8947368421052632,4.0,0.23529411764705882,9.0,0.5294117647058824
683,glowstone,"private void processArmorChanges(){
    GlowPlayer player = null;
    if (this instanceof GlowPlayer) {
        player = ((GlowPlayer) this);
    }
    boolean armorUpdate = false;
    List<EquipmentMonitor.Entry> armorChanges = getEquipmentMonitor().getArmorChanges();
    if (armorChanges.size() > 0) {
        for (EquipmentMonitor.Entry entry : armorChanges) {
            if (player != null && needsArmorUpdate) {
                player.getSession().send(new EntityEquipmentMessage(0, entry.slot, entry.item));
            }
            armorUpdate = true;
        }
    }
    if (armorUpdate) {
        getAttributeManager().setProperty(AttributeManager.Key.KEY_ARMOR, ArmorConstants.getDefense(getEquipment().getArmorContents()));
        getAttributeManager().setProperty(AttributeManager.Key.KEY_ARMOR_TOUGHNESS, ArmorConstants.getToughness(getEquipment().getArmorContents()));
    }
    needsArmorUpdate = true;
}",processArmorChanges,net/glowstone/entity/GlowHumanEntity.java,/src/main/java/net/glowstone/entity/GlowHumanEntity.java,"/**
     * Process changes to the human enitity's armor, and update the entity's armor attributes
     * accordingly.
     */",191-217,"('processArmorChanges', {'INSTRUCTION': {'covered': 70, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 4}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",172.0,18.0,"Process changes to the human enitity's armor, and update the entity's armor attributes  accordingly.",The method changes the human entity's armor and updates the entity's armor attributes.,"Process changes to the human enitity's armor, and update the entity's armor attributes accordingly.",0.584180218490568,Process changes to the human entity's armor and update the entity's armor attributes accordingly.," private void processArmorChanges(){
        if (needsArmorUpdate) {
            needsArmorUpdate = false;
            GlowPlayer player = (GlowPlayer) this;
            player.updateArmorAttributes();
        }
    }"," private void processArmorChanges(){
        if (needsArmorUpdate) {
            needsArmorUpdate = false;
            GlowPlayer player = (GlowPlayer) this;
            player.updateArmorAttributes();
        }
    }",Not Valid," private void processArmorChanges(){
        if (!needsArmorUpdate) {
            return;
        }
        needsArmorUpdate = false;       
 }",NOT PASS,NOT PASS,NOT PASS,Not Valid,  0.1031016064820602,  0.1031016064820602,  0.03184077102532281,None,148.0,0.8554913294797688,148.0,0.8554913294797688,155.0,0.8959537572254336,None,None,0.0,0.0,17.0,0.53125,None,None,8.0,0.5333333333333333,2.0,0.13333333333333333,0.0,0.0
684,cdk,"public Permutation multiply(Permutation other){
    Permutation newPermutation = new Permutation(values.length);
    for (int i = 0; i < values.length; i++) {
        newPermutation.values[i] = this.values[other.values[i]];
    }
    return newPermutation;
}",multiply,org/openscience/cdk/group/Permutation.java,/tool/group/src/main/java/org/openscience/cdk/group/Permutation.java,"/**
     * Multiply this permutation by another such that for all i,
     * this[i] = this[other[i]].
     *
     * @param other the other permutation to use
     * @return a new permutation with the result of multiplying the permutations
     */",197-210,"('multiply', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,24.0,"Multiply this permutation by another such that for all i,  this[i] = this[other[i]].",Returns a new permutation representing the results of multiplying such a permutation with the parameter given as input (other).,"If you add this permutation to another, you get this other.",0.477751690973469,"Multiply this permutation by another such that for any i, this[i] = this[other[i]].","public Permutation multiply(Permutation other){
        Permutation result = new Permutation(this.values.length);
        for (int i = 0; i < this.values.length; i++) {
            result.values[i] = other.values[this.values[i]];
        }
        return result;
    }","public Permutation multiply(Permutation other){
        int[] newValues = new int[this.values.length];
        for (int i = 0; i < this.values.length; i++) {
            newValues[i] = other.values[this.values[i]];
        }
        return new Permutation(newValues);      
 }","public Permutation multiply(Permutation other){
        Permutation result = new Permutation(this.values.length);
        for (int i = 0; i < this.values.length; i++) {
            result.values[i] = other.values[this.values[i]];
        }
        return result;      
 }","public Permutation multiply(Permutation other){
        Permutation result = new Permutation(this.values.length);
        for (int i = 0; i < this.values.length; i++) {
            result.values[i] = this.values[other.values[i]];
        }
        return result;      
 }",NOT PASS,NOT PASS,PASS,NOT PASS,  0.7682860959306349,  0.5420229002353204,  0.8298681084779091,  0.7682860959306349,9.0,0.13846153846153847,21.0,0.30434782608695654,7.0,0.1076923076923077,9.0,0.13846153846153847,15.0,0.21739130434782608,2.0,0.03076923076923077,0.0,0.0,17.0,0.85,1.0,0.07142857142857142,13.0,0.9285714285714286
685,egeria,"private RelationshipsContext buildRelationalTableContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
    Set<GraphContext> context = new HashSet<>();
    EntityDetail schemaType = handlerHelper.addContextForRelationships(userId, entityDetail, ATTRIBUTE_FOR_SCHEMA, context);
    EntityDetail deployedSchemaType = handlerHelper.addContextForRelationships(userId, schemaType, ASSET_SCHEMA_TYPE, context);
    EntityDetail database = handlerHelper.addContextForRelationships(userId, deployedSchemaType, DATA_CONTENT_FOR_DATA_SET, context);
    if (database != null) {
        addConnectionToAssetContext(userId, database, context);
    }
    return new RelationshipsContext(entityDetail.getGUID(), context);
}",buildRelationalTableContext,org/odpi/openmetadata/accessservices/assetlineage/handlers/AssetContextHandler.java,/open-metadata-implementation/access-services/asset-lineage/asset-lineage-server/src/main/java/org/odpi/openmetadata/accessservices/assetlineage/handlers/AssetContextHandler.java,"/**
     * Builds the relational table context for a relational column.
     *
     * @param userId       the unique identifier for the user
     * @param entityDetail the entity for which the context is build
     *
     * @return the relational table context of the relational column
     *
     * @throws OCFCheckedExceptionBase checked exception for reporting errors found when using OCF connectors
     */",264-288,"('buildRelationalTableContext', {'INSTRUCTION': {'covered': 42, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,10.0,Builds the relational table context for a relational column.,"Sets a new relational table context for a relational column. Than, return such a new table.",The context for a column in the table is built.,0.19475915921374,Generates the relational table context for a relational column.,Empty Method," private RelationshipsContext buildRelationalTableContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
        final String methodName = ""buildRelationalTableContext"";
        RelationshipsContext context = new RelationshipsContext();
        context.setEntityDetail(entityDetail);
        context.setEntityType(entityDetail.getType());
        context.setEntityGUID(entityDetail.getGUID());
        context.setEntityName(entityDetail.getName());
        context.setEntityTypeDefName(entityDetail.getType().getTypeDefName());
        context.setEntityTypeDefGUID(entityDetail.getType().getTypeDefGUID());
        context.setEntityTypeDefName(entityDetail.getType().getTypeDefName());
        context.setEntityTypeDefVersion(entityDetail.getType().getTypeDefVersion());
        context.setEntityTypeDefDescription(entityDetail.getType().getDescription());
        context.setEntityTypeDefDisplayName(entityDetail.getType().getDisplayName());
        context.setEntityTypeDefSteward(entityDetail.getType().getSteward());
        context.setEntityTypeDefAuthor(entityDetail.getType().getAuthor());
        context.setEntityTypeDefVersion(entityDetail.getType().getVersion());
        context.setEntityTypeDefCategory(entityDetail.getType().getCategory());
        context.setEntityTypeDefExtensions(entityDetail.getType().getExtensions());
        context.setEntityTypeDefProperties(entityDetail.getType().getProperties());
        context.setEntityTypeDefSuperTypes(entityDetail.getType().getSuperTypes());
        context.setEntityTypeDefSubTypes(entityDetail.getType().getSubTypes());
        context.setEntityTypeDefRelationships(entityDetail.getType().getRelationships());
        context.setEntityTypeDefAnchors(entityDetail.getType().getAnchors());
        context.setEntityTypeDefAnchor(entityDetail.getType().getAnchor());
        context.setEntityTypeDefAnchorGUID(entityDetail.getType().getAnchorGUID());
        context.setEntityTypeDefAnchorType(entity       
 }"," private RelationshipsContext buildRelationalTableContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
        RelationshipsContext context = new RelationshipsContext();
        context.setEntity(entityDetail);
        context.setRelationships(new ArrayList<>());
    
        List<Relationship> relationships = handlerHelper.getRelationshipsByType(userId, entityDetail.getGUID(), ATTRIBUTE_FOR_SCHEMA);
        for (Relationship relationship : relationships) {
            EntityDetail schemaType = handlerHelper.getEntityAtTheEnd(userId, entityDetail.getGUID(), relationship);
            Optional<Classification> anchorGUIDClassification = getAnchorsClassification(schemaType);
            if (anchorGUIDClassification.isEmpty()) {
                continue;
            }
            Optional<String> anchorGUID = getAnchorGUID(anchorGUIDClassification.get());
            if (anchorGUID.isEmpty()) {
                continue;
            }
    
            if (repositoryHandler.isEntityATypeOf(userId, anchorGUID.get(), ANCHOR_GUID, PORT_IMPLEMENTATION, ""buildRelationalTableContext"")) {
                context.getRelationships().add(relationship);
            }
        }
    
        return context;     
 }"," private RelationshipsContext buildRelationalTableContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
        RelationshipsContext context = new RelationshipsContext();
        context.setEntity(entityDetail);
        context.setRelationships(new ArrayList<>());
    
        List<Relationship> relationships = handlerHelper.getRelationshipsByType(userId, entityDetail.getGUID(), ATTRIBUTE_FOR_SCHEMA);
        for (Relationship relationship : relationships) {
            EntityDetail schemaType = handlerHelper.getEntityAtTheEnd(userId, entityDetail.getGUID(), relationship);
            Optional<Classification> anchorGUIDClassification = getAnchorsClassification(schemaType);
            if (anchorGUIDClassification.isEmpty()) {
                continue;
            }
            Optional<String> anchorGUID = getAnchorGUID(anchorGUIDClassification.get());
            if (anchorGUID.isEmpty()) {
                continue;
            }
    
            if (repositoryHandler.isEntityATypeOf(userId, anchorGUID.get(), ANCHOR_GUID, PORT_IMPLEMENTATION, ""buildRelationalTableContext"")) {
                context.getRelationships().add(relationship);
            }
        }
    
        return context;     
 }",Empty Method,Syntax Error,NOT PASS,NOT PASS,None,None,  0.40357181388491564,  0.40357181388491564,None,None,None,None,116.0,0.655367231638418,116.0,0.655367231638418,None,None,176.0,0.9943502824858758,176.0,0.9943502824858758,9.0,0.5294117647058824,1.0,0.1,10.0,0.9090909090909091
686,matsim-libs,"public boolean replanCurrentLegRoute(Leg leg, Person person, int currentLinkIndex, double time){
    Route route = leg.getRoute();
    if (!(route instanceof NetworkRoute)) {
        log.warn(""route not instance of NetworkRoute"");
        return false;
    }
    return relocateCurrentLegRoute(leg, person, currentLinkIndex, route.getEndLinkId(), time);
}",replanCurrentLegRoute,org/matsim/withinday/utils/EditRoutes.java,/matsim/src/main/java/org/matsim/withinday/utils/EditRoutes.java,"/**
	 * We create a new Plan which contains only the Leg that should be replanned and its previous and next
	 * Activities. By doing so the PlanAlgorithm will only change the Route of that Leg.
	 *
	 * Use currentNodeIndex from a DriverAgent if possible!
	 *
	 * Otherwise code it as following:
	 * startLink - Node1 - routeLink1 - Node2 - routeLink2 - Node3 - endLink
	 * The currentNodeIndex has to Point to the next Node
	 * (which is the endNode of the current Link)
	 */",352-376,"('replanCurrentLegRoute', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,21.0,We create a new Plan which contains only the Leg that should be replanned and its previous and next  Activities.,"Returns true if the newly created plan contains only the leg that should be replanned with all its previous and subsequent activities. False, otherwise.",We create a new plan that only has the Leg that should be replanned and its previous and next activities.,0.188782948125546,We create a new plan that contains only the leg that should be replanned and its previous and subsequent activities.," public boolean replanCurrentLegRoute(Leg leg, Person person, int currentLinkIndex, double time){
	 Route route = leg.getRoute();
	 
	 // if the route type is not supported (e.g. because it is a walking agent)
	 if (!(route instanceof NetworkRoute)) return false;
	 
	 // This is just a special case of relocateCurrentLegRoute where the end link of the route is not changed.
	 return relocateCurrentLegRoute(leg, person, currentLinkIndex, route.getEndLinkId(), time);			
 }"," public boolean replanCurrentLegRoute(Leg leg, Person person, int currentLinkIndex, double time){
	 Route route = leg.getRoute();
	 
	 // if the route type is not supported (e.g. because it is a walking agent)
	 if (!(route instanceof NetworkRoute)) return false;
	 
	 // This is just a special case of relocateCurrentLegRoute where the end link of the route is not changed.
	 return relocateCurrentLegRoute(leg, person, currentLinkIndex, route.getEndLinkId(), time);			
 }"," public boolean replanCurrentLegRoute(Leg leg, Person person, int currentLinkIndex, double time){
		
		Route route = leg.getRoute();
		
		// if the route type is not supported (e.g. because it is a walking agent)
		if (!(route instanceof NetworkRoute)) return false;
		
		// This is just a special case of relocateCurrentLegRoute where the end link of the route is not changed.
		return relocateCurrentLegRoute(leg, person, currentLinkIndex, route.getEndLinkId(), time);
		throw new RuntimeException(""currently not implemented: not consistent with access/egress legs"" ) ;
	}"," public boolean replanCurrentLegRoute(Leg leg, Person person, int currentLinkIndex, double time){
	 Route route = leg.getRoute();
	 
	 // if the route type is not supported (e.g. because it is a walking agent)
	 if (!(route instanceof NetworkRoute)) return false;
	 
	 // This is just a special case of relocateCurrentLegRoute where the end link of the route is not changed.
	 return relocateCurrentLegRoute(leg, person, currentLinkIndex, route.getEndLinkId(), time);			
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8295556468993301,  0.8295556468993301,  0.8295556468993301,  0.8430475531009907,9.0,0.13432835820895522,9.0,0.13432835820895522,9.0,0.13432835820895522,16.0,0.23880597014925373,0.0,0.0,0.0,0.0,7.0,0.1076923076923077,14.0,0.56,5.0,0.23809523809523808,5.0,0.23809523809523808
687,cdk,"static Vector2d scale(final Tuple2d vector, final double factor){
    final Vector2d cpy = new Vector2d(vector);
    cpy.scale(factor);
    return cpy;
}",scale,org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,"/**
     * Scale a vector by a given factor, the input vector is not modified.
     *
     * @param vector a vector to scale
     * @param factor how much the input vector should be scaled
     * @return scaled vector
     */",135-146,"('scale', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,15.0,"Scale a vector by a given factor, the input vector is not modified.",Creates and returns a new vector representing a scaled version of the one given as input.,The input is not modified when scales a vector by a factor.,0.362141942345613,"Scaling a vector by a given factor, the input vector is not modified.","static Vector2d scale(final Tuple2d vector, final double factor){
        final Vector2d scaled = new Vector2d(vector);
        scaled.scale(factor);
        return scaled;      
 }","static Vector2d scale(final Tuple2d vector, final double factor){
        final Vector2d scaled = new Vector2d(vector);
        scaled.scale(factor);
        return scaled;      
 }","static Vector2d scale(final Tuple2d vector, final double factor){
        return new Vector2d(vector.x * factor, vector.y * factor);      
 }","static Vector2d scale(final Tuple2d vector, final double factor){
        return new Vector2d(vector.x * factor, vector.y * factor);      
 }",PASS,PASS,PASS,PASS,  0.8855166114887929,  0.8855166114887929,  0.479119143445617,  0.479119143445617,3.0,0.08571428571428572,3.0,0.08571428571428572,15.0,0.42857142857142855,15.0,0.42857142857142855,0.0,0.0,15.0,0.42857142857142855,15.0,0.42857142857142855,13.0,0.7647058823529411,1.0,0.07142857142857142,12.0,0.8571428571428571
688,acs-aem-commons,"private Optional<Class> upgradeToArray(Optional<Class> a, Optional<Class> b){
    if (!a.isPresent()) {
        return b;
    }
    if (!b.isPresent()) {
        return a;
    }
    if (a.get().equals(b.get()) || b.get() == Object.class) {
        return getArrayType(a);
    } else {
        return getArrayType(b);
    }
}",upgradeToArray,com/adobe/acs/commons/data/Spreadsheet.java,/bundle/src/main/java/com/adobe/acs/commons/data/Spreadsheet.java,"/**
     * Consider if a column is seen twice then that column type should be
     * considered an array. Because String is a default assumption when no type
     * is specified, any redefinition of a column to a more specific type will
     * be then assumed for that property altogether.
     *
     * @param a
     * @param b
     * @return
     */",374-396,"('upgradeToArray', {'INSTRUCTION': {'covered': 20, 'missed': 7}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 4, 'missed': 3}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",93.0,17.0,Consider if a column is seen twice then that column type should be  considered an array.,"Checks whether a column is seen twice. If so, the column type should be considered as an array.","If a column is seen twice, then it should be considered an array.",0.167183413713482,"Consider if a column is viewed twice, this type of column should be considered a table."," private Optional<Class> upgradeToArray(Optional<Class> a, Optional<Class> b){
        if(a.isPresent() && b.isPresent()){
            if(a.get() == b.get()){
                return Optional.of(a.get());
            }else{
                return Optional.empty();
            }
        }else{
            return a.isPresent() ? a : b;
        }
    }"," private Optional<Class> upgradeToArray(Optional<Class> a, Optional<Class> b){
        if (a.isPresent() && b.isPresent() && a.get() != b.get()) {
            return getArrayType(a);
        } else {
            return a;
        }
    }","private Optional<Class> upgradeToArray(Optional<Class> a, Optional<Class> b){
        if (a.isPresent() && b.isPresent() && a.get() != b.get()) {
            return Optional.of(Array.newInstance(a.get(), 0).getClass());
        } else {
            return a;
        }
    }"," private Optional<Class> upgradeToArray(Optional<Class> a, Optional<Class> b){
        if (a.isPresent() && b.isPresent()) {
            if (a.get().equals(b.get())) {
                return Optional.of(a.get());
            } else {
                return Optional.empty();
            }
        } else if (a.isPresent()) {
            return a;
        } else {
            return b;
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6430471524685027,  0.6247112638111554,  0.7124438138432538,  0.6124699085098453,42.0,0.44680851063829785,36.0,0.3829787234042553,46.0,0.46464646464646464,41.0,0.43617021276595747,31.0,0.34444444444444444,14.0,0.1414141414141414,26.0,0.28888888888888886,7.0,0.3684210526315789,8.0,0.47058823529411764,6.0,0.35294117647058826
689,weblogic-kubernetes-operator," static WlsClusterConfig create(Map<String, Object> clusterConfigMap, Map<String, WlsServerConfig> serverTemplates, String domainName){
    String clusterName = (String) clusterConfigMap.get(""name"");
    WlsDynamicServersConfig dynamicServersConfig = WlsDynamicServersConfig.create((Map<String, Object>) clusterConfigMap.get(""dynamicServers""), serverTemplates, clusterName, domainName);
    // set dynamicServersConfig only if the cluster contains dynamic servers, i.e., its dynamic
    // servers configuration
    // contains non-null server template name
    if (dynamicServersConfig.getServerTemplate() == null) {
        dynamicServersConfig = null;
    }
    return new WlsClusterConfig(clusterName, dynamicServersConfig);
}",create,oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,"/**
   * Creates a WlsClusterConfig object using an ""clusters"" item parsed from JSON result from WLS
   * REST call.
   *
   * @param clusterConfigMap Map containing ""cluster"" item parsed from JSON result from WLS REST
   *     call
   * @param serverTemplates Map containing all server templates configuration read from the WLS
   *     domain
   * @param domainName Name of the WLS domain that this WLS cluster belongs to
   * @return A new WlsClusterConfig object created based on the JSON result
   */",53-83,"('create', {'INSTRUCTION': {'covered': 23, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,19.0,"Creates a WlsClusterConfig object using an ""clusters"" item parsed from JSON result from WLS  REST call.","Generates and returns a new WisClusterConfig object using a ""clusters"" item that has been previously parsed from JSON result from WLS REST call.","The object is created using a ""clusters"" item from the WLS call.",0.442807941150879,"Creates a WlsClusterConfig object using a crawled ""clusters"" element from the JSON result of the WLS REST call.","  static WlsClusterConfig create(Map<String, Object> clusterConfigMap, Map<String, WlsServerConfig> serverTemplates, String domainName){
    WlsClusterConfig clusterConfig = new WlsClusterConfig();
    clusterConfig.setName((String) clusterConfigMap.get(""name""));
    clusterConfig.setWlsDomainConfig(new WlsDomainConfig(domainName));
    List<Map<String, Object>> servers = (List<Map<String, Object>>) clusterConfigMap.get(""servers"");
    if (servers != null) {
      for (Map<String, Object> server : servers) {
        WlsServerConfig serverConfig = WlsServerConfig.create(server, serverTemplates);
        clusterConfig.addServer(serverConfig);
      }
    }
    return clusterConfig;     
  }","  static WlsClusterConfig create(Map<String, Object> clusterConfigMap, Map<String, WlsServerConfig> serverTemplates, String domainName){
    WlsClusterConfig clusterConfig = new WlsClusterConfig();
    clusterConfig.setName((String) clusterConfigMap.get(""name""));
    clusterConfig.setWlsDomainConfig(new WlsDomainConfig(domainName));
    List<Map<String, Object>> servers = (List<Map<String, Object>>) clusterConfigMap.get(""servers"");
    if (servers != null) {
      for (Map<String, Object> serverConfigMap : servers) {
        WlsServerConfig serverConfig = WlsServerConfig.create(serverConfigMap, serverTemplates);
        clusterConfig.addServer(serverConfig);
      }
    }
    return clusterConfig;     
  }","  static WlsClusterConfig create(Map<String, Object> clusterConfigMap, Map<String, WlsServerConfig> serverTemplates, String domainName){
    WlsClusterConfig clusterConfig = new WlsClusterConfig();
    clusterConfig.setName((String) clusterConfigMap.get(""name""));
    clusterConfig.setWlsDomainConfig(new WlsDomainConfig(domainName));
    List<Map<String, Object>> servers = (List<Map<String, Object>>) clusterConfigMap.get(""servers"");
    if (servers != null) {
      for (Map<String, Object> server : servers) {
        WlsServerConfig serverConfig = WlsServerConfig.create(server, serverTemplates);
        clusterConfig.addServer(serverConfig);
      }
    }
    return clusterConfig;     
  }","  static WlsClusterConfig create(Map<String, Object> clusterConfigMap, Map<String, WlsServerConfig> serverTemplates, String domainName){
    WlsClusterConfig clusterConfig = new WlsClusterConfig();
    clusterConfig.setName(OperatorUtils.getStringFromMap(clusterConfigMap, ""name""));
    clusterConfig.setWlsDomainConfig(new WlsDomainConfig(domainName));
    List<Map<String, Object>> serverConfigs = OperatorUtils.getListFromMap(clusterConfigMap, ""servers"");
    if (serverConfigs != null) {
      for (Map<String, Object> serverConfigMap : serverConfigs) {
        WlsServerConfig serverConfig = WlsServerConfig.create(serverConfigMap, serverTemplates);
        clusterConfig.addServer(serverConfig);
      }
    }
    return clusterConfig;     
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5520468353405354,  0.5520468353405354,  0.43085642394373846,  0.5520468353405354,75.0,0.5639097744360902,75.0,0.5639097744360902,73.0,0.5934959349593496,75.0,0.5639097744360902,2.0,0.015037593984962405,26.0,0.19548872180451127,0.0,0.0,10.0,0.4166666666666667,7.0,0.3684210526315789,10.0,0.5882352941176471
690,anserini,"public Map<String, Result[]> batchSearchFields(List<String> queries, List<String> qids, int k, int threads, Map<String, Float> fields){
    QueryGenerator generator = new BagOfWordsQueryGenerator();
    return batchSearchFields(generator, queries, qids, k, threads, fields);
}",batchSearchFields,io/anserini/search/SimpleSearcher.java,/src/main/java/io/anserini/search/SimpleSearcher.java,"/**
   * Searches the provided fields weighted by their boosts, using multiple threads.
   * Batch version of {@link #searchFields(String, Map, int)}.
   *
   * @param queries list of queries
   * @param qids list of unique query ids
   * @param k number of hits
   * @param threads number of threads
   * @param fields map of fields to search with weights
   * @return a map of query id to search results
   */",438-453,"('batchSearchFields', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",63.0,13.0,"Searches the provided fields weighted by their boosts, using multiple threads.",Returns a map of the query IDs matching the provided fields weighted by their boost.,The fields are weighted by their boost.,1.23640044776934,"Searches for the provided fields weighted by their boosts, using multiple threads."," public Map<String, Result[]> batchSearchFields(List<String> queries, List<String> qids, int k, int threads, Map<String, Float> fields){
    QueryGenerator generator = new FieldWeightedQueryGenerator(fields);
    return batchSearchFields(generator, queries, qids, k, threads, fields);
  }"," public Map<String, Result[]> batchSearchFields(List<String> queries, List<String> qids, int k, int threads, Map<String, Float> fields){
    QueryGenerator generator = new FieldQueryGenerator(fields);
    return batchSearchFields(generator, queries, qids, k, threads, fields);
  }"," public Map<String, Result[]> batchSearchFields(List<String> queries, List<String> qids, int k, int threads, Map<String, Float> fields){
    QueryGenerator generator = new BagOfWordsQueryGenerator();
    return batchSearchFields(generator, queries, qids, k, threads, fields);
  }"," public Map<String, Result[]> batchSearchFields(List<String> queries, List<String> qids, int k, int threads, Map<String, Float> fields){
    QueryGenerator generator = new BagOfWordsQueryGenerator();
    return batchSearchFields(generator, queries, qids, k, threads, fields);   
 }",NOT PASS,NOT PASS,PASS,PASS,  0.9045805857334417,  0.9045805857334417,  1.0,  1.0,2.0,0.03076923076923077,2.0,0.03076923076923077,0.0,0.0,0.0,0.0,1.0,0.015384615384615385,2.0,0.03076923076923077,2.0,0.03076923076923077,12.0,0.75,1.0,0.07692307692307693,8.0,0.6666666666666666
691,cdk,"public void removeListener(IChemObjectListener col){
    if (chemObjectListeners == null) {
        return;
    }
    List<IChemObjectListener> listeners = lazyChemObjectListeners();
    if (listeners.contains(col)) {
        listeners.remove(col);
    }
}",removeListener,org/openscience/cdk/ChemObject.java,/base/data/src/main/java/org/openscience/cdk/ChemObject.java,"/**
     *  Use this to remove a ChemObjectListener from the ListenerList of this
     *  IChemObject. It will then not be notified of change in this object anymore.
     *
     *@param  col  The ChemObjectListener to be removed
     *@see         #addListener
     */",150-167,"('removeListener', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,13.0,Use this to remove a ChemObjectListener from the ListenerList of this  IChemObject.,Remove an element from the ListenerList of the given object.,This can be used to remove a ChemObjectListener from the Listener List.,0.681545904504381,Use this option to remove a ChemObjectListener from the ListenerList of that IChemObject.," public void removeListener(IChemObjectListener col){
        if (chemObjectListeners == null) {
            return;
        }
        lazyChemObjectListeners().remove(col);
    }"," public void removeListener(IChemObjectListener col){
        if (chemObjectListeners == null) {
            return;
        }
        lazyChemObjectListeners().remove(col);
    }"," public void removeListener(IChemObjectListener col){
        if (chemObjectListeners != null) {
            chemObjectListeners.remove(col);
        }
    }"," public void removeListener(IChemObjectListener col){
        if (chemObjectListeners != null) {
            chemObjectListeners.remove(col);
        }
    }",PASS,PASS,PASS,PASS,  0.4527149258953389,  0.4527149258953389,  0.4063419750497284,  0.4063419750497284,19.0,0.3958333333333333,19.0,0.3958333333333333,25.0,0.5208333333333334,25.0,0.5208333333333334,0.0,0.0,8.0,0.27586206896551724,8.0,0.27586206896551724,9.0,0.6923076923076923,2.0,0.14285714285714285,8.0,0.6153846153846154
692,acs-aem-commons,"protected String generatedNodeChecksum(final String aggregateNodePath, final Node node, final ChecksumGeneratorOptions options) throws RepositoryException, IOException{
    if (isExcludedSubTree(node, options)) {
        return """";
    }
    final Map<String, String> checksums = new LinkedHashMap<>();
    if (!isExcludedNodeName(node, options)) {
        final String checksum = generatePropertyChecksums(aggregateNodePath, node, options);
        if (checksum != null) {
            checksums.put(getChecksumKey(aggregateNodePath, node.getPath()), checksum);
        }
    }
    final Map<String, String> lexicographicallySortedChecksums = new TreeMap<>();
    final boolean hasOrderedChildren = hasOrderedChildren(node);
    final NodeIterator children = node.getNodes();
    while (children.hasNext()) {
        final Node child = children.nextNode();
        if (isExcludedSubTree(child, options)) {
        } else if (!isExcludedNodeType(child, options)) {
            if (hasOrderedChildren) {
                final String checksum = generatedNodeChecksum(aggregateNodePath, child, options);
                if (checksum != null) {
                    checksums.put(getChecksumKey(aggregateNodePath, child.getPath()), checksum);
                    log.debug(""Aggregated Ordered Node: {} ~> {}"", getChecksumKey(aggregateNodePath, child.getPath()), checksum);
                }
            } else {
                final String checksum = generatedNodeChecksum(aggregateNodePath, child, options);
                if (checksum != null) {
                    lexicographicallySortedChecksums.put(getChecksumKey(aggregateNodePath, child.getPath()), checksum);
                    log.debug(""Aggregated Unordered Node: {} ~> {}"", getChecksumKey(aggregateNodePath, child.getPath()), checksum);
                }
            }
        }
    }
    if (!hasOrderedChildren && lexicographicallySortedChecksums.size() > 0) {
        checksums.putAll(lexicographicallySortedChecksums);
    }
    final String nodeChecksum = aggregateChecksums(checksums);
    log.debug(""Node [ {} ] has a aggregated checksum of [ {} ]"", getChecksumKey(aggregateNodePath, node.getPath()), nodeChecksum);
    return nodeChecksum;
}",generatedNodeChecksum,com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,"/**
     * Generates a checksum for a single node and its node sub-system, respecting the options.
     * @param aggregateNodePath the absolute path of the node being aggregated into a checksum
     * @param node the node whose subsystem to create a checksum for
     * @param options the {@link ChecksumGeneratorOptions} options
     * @return a map containing 1 entry in the form [ node.getPath() ] : [ CHECKSUM OF NODE SYSTEM ]
     * @throws RepositoryException
     * @throws IOException
     */",159-230,"('generatedNodeChecksum', {'INSTRUCTION': {'covered': 138, 'missed': 2}, 'BRANCH': {'covered': 19, 'missed': 3}, 'LINE': {'covered': 31, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",363.0,16.0,"Generates a checksum for a single node and its node sub-system, respecting the options.",Generate a checksum for a single node and its nested one,A single checksum is generated for a single system.,0.73595743179915,"Generates a checksum for a single node and its node subsystem, respecting the options.",Not Valid,Not Valid,"protected String generatedNodeChecksum(final String aggregateNodePath, final Node node, final ChecksumGeneratorOptions options) throws RepositoryException, IOException{
        final StringBuilder checksum = new StringBuilder();
    
        final String nodeName = node.getName();
        final String nodePath = node.getPath();
    
        final String nodeNameChecksum = generateNodeNameChecksum(nodeName, options);
        final String nodePathChecksum = generateNodePathChecksum(nodePath, options);
    
        final String nodeNameChecksumString = nodeNameChecksum != null ? nodeNameChecksum : """";
        final String nodePathChecksumString = nodePathChecksum != null ? nodePathChecksum : """";
    
        final String nodeNameChecksumStringTrimmed = nodeNameChecksumString.trim();
        final String nodePathChecksumStringTrimmed = nodePathChecksumString.trim();
    
        final String nodeNameChecksumStringTrimmedLength = nodeNameChecksumStringTrimmed.length();
        final String nodePathChecksumStringTrimmedLength = nodePathChecksumStringTrimmed.length();
    
        final String nodeNameChecksumStringTrimmedLengthString = String.valueOf(nodeNameChecksumStringTrimmedLength);
        final String nodePathChecksumStringTrimmedLengthString = String.valueOf(nodePathChecksumStringTrimmedLength);
    
        final String nodeNameChecksumStringTrimmedLengthStringPadded = StringUtils.leftPad(nodeNameChecksumStringTrimmedLengthString, 3, '0');
        final String nodePathChecksumStringTrimmedLengthStringPadded = StringUtils.leftPad(nodePathChecksumStringTrimmedLengthString, 3, '0');
    
        final String nodeNameChecksumStringTrimmedLengthStringPaddedAndNodeNameChecksumStringTrimmed = nodeNameChecksumStringTrimmedLengthStringPadded + nodeNameChecksumStringTrimmed;
        final String nodePathChecksumStringTrimmedLengthStringPaddedAndNodePathChecksumStringTrimmed = nodePathChecksumStringTrimmedLengthStringPadded + nodePathChecksumString     
 }","protected String generatedNodeChecksum(final String aggregateNodePath, final Node node, final ChecksumGeneratorOptions options) throws RepositoryException, IOException{
        final StringBuilder checksum = new StringBuilder();
    
        // Add the node's primary type
        checksum.append(node.getPrimaryNodeType().getName());
    
        // Add the node's mixin types
        final NodeType[] mixinNodeTypes = node.getMixinNodeTypes();
        for (NodeType mixinNodeType : mixinNodeTypes) {
            checksum.append(mixinNodeType.getName());
        }
    
        // Add the node's properties
        final PropertyIterator properties = node.getProperties();
        while (properties.hasNext()) {
            final Property property = properties.nextProperty();
            final String propertyName = property.getName();
            final int propertyType = property.getType();
    
            if (propertyType == PropertyType.BINARY) {
                // Binary properties are not included in the checksum
                continue;
            }
    
            // Add the property name
            checksum.append(propertyName);
    
            // Add the property value
            final Value[] values = property.getValues();
            for (Value value : values) {
                checksum.append(value.getString());
            }
        }
    
        // Add the node's child nodes
        final NodeIterator children = node.getNodes();
        while (children.hasNext()) {
            final Node child = children.nextNode();
            final String childNodeName = child.getName();
    
            if (isExcludedSubTree(child, options)) {
                continue;
            } else if (isExcludedNodeName(child, options)) {
                continue;
            } else if (isChecksumable(child, options)) {
                // Recursively call into this method to generate checksum for child node
                final String childNodeChecksum = generatedNodeChecksum(aggregateNodePath + ""/"" + childNodeName, child, options);
                if (childNodeChecksum != null) {
                    checksum.append(childNodeChecksum);
                }
            }
        }
    
        // Add the node's properties
        final PropertyIterator properties2 = node.get       
 }",Not Valid,Not Valid,Syntax Error,Syntax Error,None,None,None,None,None,None,None,None,256.0,0.7032967032967034,271.0,0.7445054945054945,None,None,297.0,0.9966442953020134,204.0,0.9951219512195122,6.0,0.4,1.0,0.06666666666666667,12.0,0.8
693,glowstone,"public boolean readFloat(@NonNls String key, FloatConsumer consumer){
    if (isFloat(key)) {
        consumer.accept(getFloat(key));
        return true;
    }
    return false;
}",readFloat,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to a float subtag if it is present.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */",372-386,"('readFloat', {'INSTRUCTION': {'covered': 11, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,13.0,Applies the given function to a float subtag if it is present.,Add a key to a float subtag if present,"If the function is present, apply it to the float subtag.",0.272370444749086,Applies the given function to a float subtag if it is present.," public boolean readFloat(@NonNls String key, FloatConsumer consumer){
        return readTag(key, FloatTag.class, consumer);      
 }"," public boolean readFloat(@NonNls String key, FloatConsumer consumer){
        return readTag(key, FloatTag.class, consumer);      
 }"," public boolean readFloat(@NonNls String key, FloatConsumer consumer){
        return readTag(key, FloatTag.class, consumer);      
 }"," public boolean readFloat(@NonNls String key, FloatConsumer consumer){
        return readTag(key, FloatTag.class, consumer);      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4742209755169855,  0.4742209755169855,  0.4742209755169855,  0.4742209755169855,20.0,0.5,20.0,0.5,20.0,0.5,20.0,0.5,0.0,0.0,0.0,0.0,0.0,0.0,7.0,0.5384615384615384,0.0,0.0,10.0,0.7692307692307693
694,matsim-libs,"public void finish(){
    if (iteration == -1) {
        throw new RuntimeException(""Please initialize me before the iteration starts."");
    }
    controlerListenerManager.fireControlerAfterMobsimEvent(iteration, isLastIteration);
    scoringFunctionsForPopulation.finishScoringFunctions();
    newScoreAssigner.assignNewScores(this.iteration, scoringFunctionsForPopulation, population);
    finished = true;
}",finish,org/matsim/core/scoring/EventsToScore.java,/matsim/src/main/java/org/matsim/core/scoring/EventsToScore.java,"/**
	 * Finishes the calculation of the plans' scores and assigns the new scores
	 * to the plans if desired.
	 */",116-128,"('finish', {'INSTRUCTION': {'covered': 27, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,19.0,Finishes the calculation of the plans' scores and assigns the new scores  to the plans if desired.,Complete the calculation of the plans' scores and prepare for the new iteration if requried,"If you want, assign the new scores to the plans.",0.213211098090783,Finish calculating the scores of the plans and assign the new scores to the plans if you wish.," public void finish(){
	 	if (finished) {
 		throw new IllegalStateException(""EventsToScore.finish() has already been called."");
 	}
 	finished = true;
 	this.controlerListenerManager.fireControlerIterationEndsEvent(iteration, isLastIteration);
 	this.newScoreAssigner.assignScoresToPlans(this.population);
 	this.scoringFunctionsForPopulation.reset();
 }"," public void finish(){
	 	if (finished) {
 		throw new IllegalStateException(""EventsToScore.finish() has already been called."");
 	}
 	finished = true;
 	this.controlerListenerManager.fireControlerIterationEndsEvent(iteration, isLastIteration);
 	this.newScoreAssigner.assignScores(this.population);
 	this.scoringFunctionsForPopulation.reset();
 }"," public void finish(){
	 	if (this.finished) {
 		throw new RuntimeException(""finish() was already called."");
 	}
 	this.finished = true;
 	this.controlerListenerManager.fireControlerIterationStartsEvent(iteration, isLastIteration);
 	this.controlerListenerManager.fireControlerIterationEndsEvent(iteration, isLastIteration);
 	this.controlerListenerManager.fireControlerShutdownEvent();
 	this.scoringFunctionsForPopulation.finish();
 	this.newScoreAssigner.finish();
 	for (Person person : this.population.getPersons().values()) {
 		this.newScoreAssigner.assignNewScores(person);
 	}
 }"," public void finish(){
	 	if (this.finished) {
 		throw new RuntimeException(""EventsToScore.finish() was already called."");
 	}
 	this.finished = true;
 	this.controlerListenerManager.fireControlerIterationStartsEvent(this.iteration, this.isLastIteration);
 	this.controlerListenerManager.fireControlerShutdownEvent();
 	this.controlerListenerManager.reset();
 	this.scoringFunctionsForPopulation.finish();
 	this.newScoreAssigner.finish();
 	this.controlerListenerManager.reset();
 	this.controlerListenerManager.fireControlerShutdownEvent();
 	this.controlerListenerManager.reset();
 	this.controlerListenerManager.fireControlerShutdownEvent();
 	this.controlerListenerManager.reset();
 	this.controlerListenerManager.fireControlerShutdownEvent();
 	this.controlerListenerManager.reset();
 	this.controlerListenerManager.fireControlerShutdownEvent();
 	this.controlerListenerManager.reset();
 	this.controlerListenerManager.fireControlerShutdownEvent();
 	this.controlerListenerManager.reset();
 	this.controlerListenerManager.fireControlerShutdownEvent();
 	this.controlerListenerManager.reset();
 	this.controlerListenerManager.fireControlerShutdownEvent();
 	this.controlerListenerManager.reset();
 	this.controlerListenerManager.fireControlerShutdownEvent();
 	this.controlerListenerManager.reset();
 	this.controlerListenerManager.fireControlerShutdownEvent();
 	this.controlerListenerManager.reset();
 	this.controlerListenerManager.fireControlerShutdownEvent();
 	this.controlerListenerManager.reset();
 	this.controlerListenerManager.fireControlerShutdownEvent();
 	this.controlerListenerManager.		
 }",NOT PASS,NOT PASS,Syntax Error,NOT PASS,  0.3158476907362907,  0.3158476907362907,None,  0.5339223818801202,29.0,0.5178571428571429,29.0,0.5178571428571429,217.0,0.84765625,65.0,0.6310679611650486,1.0,0.01818181818181818,207.0,0.80859375,54.0,0.5242718446601942,8.0,0.4444444444444444,8.0,0.42105263157894735,12.0,0.6666666666666666
696,jackson-databind,"public ObjectReader readerForListOf(Class<?> type){
    return _newReader(getDeserializationConfig(), _typeFactory.constructCollectionType(List.class, type), null, null, _injectableValues);
}",readerForListOf,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Factory method for constructing {@link ObjectReader} that will
     * read or update instances of a type {@code List<type>}.
     * Functionally same as:
     *<pre>
     *    readerFor(new TypeReference&lt;List&lt;type&gt;&gt;() { });
     *</pre>
     *
     * @since 2.11
     */",4161-4175,"('readerForListOf', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,27.0,Factory method for constructing {@link ObjectReader} that will  read or update instances of a type {@code List<type>}.,Factory constructor for object of type ObjectReader that will read or update instances of type List<type>,The method for constructing @link ObjectReader will read or update instances of a type.,1.04000551532831,A factory method for constructing {@link ObjectReader} that will read or update instances of a {@code List<type>} type.," public ObjectReader readerForListOf(Class<?> type){
    return _newReader(getDeserializationConfig(),
      _typeFactory.constructSpecializedType(_typeFactory.constructType(List.class), _typeFactory.constructType(type)), null,
      null, _injectableValues);
     }"," public ObjectReader readerForListOf(Class<?> type){
        return _newReader(getDeserializationConfig(),
                    _typeFactory.constructCollectionType(List.class, type), null,
                    null, _injectableValues);       
 }"," public ObjectReader readerForListOf(Class<?> type){
        return _newReader(getDeserializationConfig(),
                _typeFactory.constructCollectionType(ArrayList.class, type), null,
                null, _injectableValues);
    }"," public ObjectReader readerForListOf(Class<?> type){
        return _newReader(getDeserializationConfig(),
                _typeFactory.constructSpecializedType(Collection.class, type), null,
                null, _injectableValues);       
 }",NOT PASS,PASS,NOT PASS,PASS,  0.7840915906684665,  1.0,  0.9396292931951445,  0.9643426483530626,11.0,0.22916666666666666,0.0,0.0,2.0,0.05263157894736842,1.0,0.02631578947368421,11.0,0.22916666666666666,11.0,0.22916666666666666,12.0,0.25,8.0,0.4444444444444444,5.0,0.2631578947368421,7.0,0.3888888888888889
697,cdk,"public static List<Map<Integer, Integer>> filter(List<List<Integer>> mappings){
    FinalMappings finalMappings = FinalMappings.getInstance();
    if (mappings != null && !mappings.isEmpty()) {
        finalMappings.set(removeRedundantMapping(mappings));
        mappings.clear();
    } else {
        finalMappings.set(new ArrayList<Map<Integer, Integer>>());
    }
    return finalMappings.getFinalMapping();
}",filter,org/openscience/cdk/smsd/filters/PostFilter.java,/legacy/src/main/java/org/openscience/cdk/smsd/filters/PostFilter.java,"/**
     *
     * Creates a new instance of Post Filter and removes
     * redundant mapping(s).
     *
     * @param mappings
     * @return Filtered non-redundant mappings
     */",51-68,"('filter', {'INSTRUCTION': {'covered': 17, 'missed': 5}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 5, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,15.0,Creates a new instance of Post Filter and removes  redundant mapping(s).,Generate a new object of type PostFilter and remove reduntances,A new instance of Post Filter is created.,0.808242215916587,Creates an instance of Post Filter and removes the redundant mapping(s).," public static List<Map<Integer, Integer>> filter(List<List<Integer>> mappings){
        List<Map<Integer, Integer>> filteredMappings = new ArrayList<Map<Integer, Integer>>();
        for (List<Integer> mapping : mappings) {
            Map<Integer, Integer> filteredMapping = new TreeMap<Integer, Integer>();
            for (Integer key : mapping.keySet()) {
                if (filteredMapping.containsKey(key)) {
                    if (filteredMapping.get(key) != mapping.get(key)) {
                        continue;
                    }
                }
                filteredMapping.put(key, mapping.get(key));
            }
            filteredMappings.add(filteredMapping);
        }
        return filteredMappings;        
 }"," public static List<Map<Integer, Integer>> filter(List<List<Integer>> mappings){
        List<Map<Integer, Integer>> filteredMappings = new ArrayList<Map<Integer, Integer>>();
        for (List<Integer> mapping : mappings) {
            Map<Integer, Integer> filteredMapping = new TreeMap<Integer, Integer>();
            for (Integer key : mapping.keySet()) {
                if (filteredMapping.containsKey(key)) {
                    if (filteredMapping.get(key) != mapping.get(key)) {
                        continue;
                    }
                }
                filteredMapping.put(key, mapping.get(key));
            }
            filteredMappings.add(filteredMapping);
        }
        return filteredMappings;        
 }","public static List<Map<Integer, Integer>> filter(List<List<Integer>> mappings){
        List<Map<Integer, Integer>> finalMappings = new ArrayList<Map<Integer, Integer>>();
        for (List<Integer> mapping : mappings) {
            Map<Integer, Integer> finalMapping = new TreeMap<Integer, Integer>();
            for (int i = 0; i < mapping.size(); i++) {
                finalMapping.put(i, mapping.get(i));
            }
            finalMappings.add(finalMapping);
        }
        return finalMappings;       
 }","public static List<Map<Integer, Integer>> filter(List<List<Integer>> mappings){
        List<Map<Integer, Integer>> finalMappings = new ArrayList<Map<Integer, Integer>>();
        for (List<Integer> mapping : mappings) {
            Map<Integer, Integer> map = new TreeMap<Integer, Integer>();
            for (int i = 0; i < mapping.size(); i++) {
                map.put(i, mapping.get(i));
            }
            finalMappings.add(map);
        }
        return finalMappings;       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.44509385014240666,  0.44509385014240666,  0.4584933553783799,  0.4584933553783799,96.0,0.6530612244897959,96.0,0.6530612244897959,76.0,0.6178861788617886,76.0,0.6178861788617886,0.0,0.0,44.0,0.29931972789115646,44.0,0.29931972789115646,7.0,0.5833333333333334,3.0,0.25,6.0,0.5
698,jooby,"public Path export(@Nonnull OpenAPI openAPI, @Nonnull Format format) throws IOException{
    Path output;
    if (openAPI instanceof OpenAPIExt) {
        String source = ((OpenAPIExt) openAPI).getSource();
        String[] names = source.split(""\\."");
        output = Stream.of(names).limit(names.length - 1).reduce(outputDir, Path::resolve, Path::resolve);
        String appname = names[names.length - 1];
        if (appname.endsWith(""Kt"")) {
            appname = appname.substring(0, appname.length() - 2);
        }
        output = output.resolve(appname + ""."" + format.extension());
    } else {
        output = outputDir.resolve(""openapi."" + format.extension());
    }
    if (!Files.exists(output.getParent())) {
        Files.createDirectories(output.getParent());
    }
    String content = format.toString(this, openAPI);
    Files.write(output, Collections.singleton(content));
    return output;
}",export,io/jooby/openapi/OpenAPIGenerator.java,/modules/jooby-openapi/src/main/java/io/jooby/openapi/OpenAPIGenerator.java,"/**
   * Export an {@link OpenAPI} model to the given format.
   *
   * @param openAPI Model.
   * @param format Format.
   * @throws IOException
   * @return Output file.
   */",132-163,"('export', {'INSTRUCTION': {'covered': 78, 'missed': 21}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 14, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",217.0,13.0,Export an {@link OpenAPI} model to the given format.,Export an OpenAPI object in the required format,The model should be exported to the given format.,0.782738905185232,Export a {@link OpenAPI} template in the given format.," public Path export(@Nonnull OpenAPI openAPI, @Nonnull Format format) throws IOException{
    Path file = outputDir.resolve(format.extension() + "".json"");
    Files.write(file, format.toString(this, openAPI).getBytes());
    return file;
  }"," public Path export(@Nonnull OpenAPI openAPI, @Nonnull Format format) throws IOException{
    Path file = outputDir.resolve(format.extension() + "".json"");
    Files.write(file, format.toString(this, openAPI).getBytes());
    return file;
  }"," public Path export(@Nonnull OpenAPI openAPI, @Nonnull Format format) throws IOException{
    Path file = outputDir.resolve(openAPI.getInfo().getTitle() + ""."" + format.extension());
    Files.write(file, format.toString(this, openAPI).getBytes());
    return file;
  }"," public Path export(@Nonnull OpenAPI openAPI, @Nonnull Format format) throws IOException{
    Path file = outputDir.resolve(templateName);
    Files.write(file, format.toString(this, openAPI).getBytes());
    return file;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.15972174499711012,  0.15972174499711012,  0.14959956178255837,  0.19337360065279477,167.0,0.7660550458715596,167.0,0.7660550458715596,173.0,0.7935779816513762,160.0,0.7339449541284404,0.0,0.0,7.0,0.1206896551724138,13.0,0.19117647058823528,6.0,0.6,3.0,0.3,5.0,0.5
699,matsim-libs,"public static List<ModelLane> createLanes(Link link, LanesToLinkAssignment lanesToLinkAssignment){
    List<ModelLane> queueLanes = new ArrayList<>();
    List<Lane> sortedLanes = new ArrayList<>(lanesToLinkAssignment.getLanes().values());
    sortedLanes.sort(Comparator.comparingDouble(Lane::getStartsAtMeterFromLinkEnd).thenComparing((l1, l2) -> {
        boolean l1Outgoing = l1.getToLinkIds() != null && !l1.getToLinkIds().isEmpty();
        boolean l2Outgoing = l2.getToLinkIds() != null && !l2.getToLinkIds().isEmpty();
        if (l1Outgoing && !l2Outgoing)
            return -1;
        else if (l2Outgoing && !l1Outgoing)
            return 1;
        else
            return 0;
    }));
    Collections.reverse(sortedLanes);
    List<ModelLane> laneList = new LinkedList<>();
    Lane firstLane = sortedLanes.remove(0);
    if (firstLane.getStartsAtMeterFromLinkEnd() != link.getLength()) {
        throw new IllegalStateException(""First Lane Id "" + firstLane.getId() + "" on Link Id "" + link.getId() + ""isn't starting at the beginning of the link!"");
    }
    ModelLane firstQLane = new ModelLane(firstLane);
    laneList.add(firstQLane);
    Stack<ModelLane> laneStack = new Stack<>();
    while (!laneList.isEmpty()) {
        ModelLane lastQLane = laneList.remove(0);
        laneStack.push(lastQLane);
        queueLanes.add(lastQLane);
        List<Id<Lane>> toLaneIds = lastQLane.getLaneData().getToLaneIds();
        double nextMetersFromLinkEnd = 0.0;
        double laneLength = 0.0;
        if (toLaneIds != null && (!toLaneIds.isEmpty())) {
            for (Id<Lane> toLaneId : toLaneIds) {
                Lane currentLane = lanesToLinkAssignment.getLanes().get(toLaneId);
                nextMetersFromLinkEnd = currentLane.getStartsAtMeterFromLinkEnd();
                ModelLane currentQLane = new ModelLane(currentLane);
                laneList.add(currentQLane);
                lastQLane.addAToLane(currentQLane);
            }
            laneLength = lastQLane.getLaneData().getStartsAtMeterFromLinkEnd() - nextMetersFromLinkEnd;
            lastQLane.setEndsAtMetersFromLinkEnd(nextMetersFromLinkEnd);
        } else {
            laneLength = lastQLane.getLaneData().getStartsAtMeterFromLinkEnd();
            lastQLane.setEndsAtMetersFromLinkEnd(0.0);
        }
        lastQLane.setLength(laneLength);
    }
    while (!laneStack.isEmpty()) {
        ModelLane qLane = laneStack.pop();
        if (qLane.getToLanes() == null || (qLane.getToLanes().isEmpty())) {
            for (Id<Link> toLinkId : qLane.getLaneData().getToLinkIds()) {
                qLane.addDestinationLink(toLinkId);
            }
        } else {
            for (ModelLane subsequentLane : qLane.getToLanes()) {
                for (Id<Link> toLinkId : subsequentLane.getDestinationLinkIds()) {
                    qLane.addDestinationLink(toLinkId);
                }
            }
        }
    }
    Collections.sort(queueLanes, new Comparator<ModelLane>() {

        @Override
        public int compare(ModelLane o1, ModelLane o2) {
            if (o1.getEndsAtMeterFromLinkEnd() < o2.getEndsAtMeterFromLinkEnd()) {
                return -1;
            } else if (o1.getEndsAtMeterFromLinkEnd() > o2.getEndsAtMeterFromLinkEnd()) {
                return 1;
            } else {
                return 0;
            }
        }
    });
    return queueLanes;
}",createLanes,org/matsim/lanes/LanesUtils.java,/matsim/src/main/java/org/matsim/lanes/LanesUtils.java,"/**
	 * Creates a sorted list of lanes for a link. 
	 * @param link
	 * @param lanesToLinkAssignment
	 * @return sorted list with the most upstream lane at the first position. 
	 */",107-200,"('createLanes', {'INSTRUCTION': {'covered': 195, 'missed': 9}, 'BRANCH': {'covered': 19, 'missed': 3}, 'LINE': {'covered': 45, 'missed': 1}, 'COMPLEXITY': {'covered': 9, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",623.0,10.0,Creates a sorted list of lanes for a link.,Create a list of lanes sorted for links,A sorted list of lanes is created.,0.11067021796592,Creates a sorted list of channels for a link.," public static List<ModelLane> createLanes(Link link, LanesToLinkAssignment lanesToLinkAssignment){
	 List<ModelLane> lanes = new ArrayList<ModelLane>();
	 for (Lane lane : lanesToLinkAssignment.getLanes().values()){
		 if (lane.getLinkId().equals(link.getId())){
			 lanes.add(new ModelLane(lane));
		 }
	 }
	 Collections.sort(lanes);
	 return lanes;			
 }"," public static List<ModelLane> createLanes(Link link, LanesToLinkAssignment lanesToLinkAssignment){
	 List<ModelLane> lanes = new ArrayList<ModelLane>();
	 for (Lane lane : lanesToLinkAssignment.getLanes().values()){
		 if (lane.getToLinkIds().contains(link.getId())){
			 lanes.add(new ModelLane(lane));
		 }
	 }
	 return lanes;			
 }"," public static List<ModelLane> createLanes(Link link, LanesToLinkAssignment lanesToLinkAssignment){
	 List<ModelLane> lanes = new ArrayList<ModelLane>();
	 for (Lane lane : lanesToLinkAssignment.getLanes().values()){
		 if (lane.getToLinkIds().contains(link.getId())){
			 lanes.add(new ModelLane(lane));
		 }
	 }
	 Collections.sort(lanes);
	 return lanes;
 }"," public static List<ModelLane> createLanes(Link link, LanesToLinkAssignment lanesToLinkAssignment){
	 List<ModelLane> lanes = new ArrayList<ModelLane>();
	 for (Lane lane : lanesToLinkAssignment.getLanes().values()){
		 if (lane.getToLinkIds().contains(link.getId())){
			 lanes.add(new ModelLane(lane));
		 }
	 }
	 Collections.sort(lanes);
	 return lanes;			
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.15865672256163305,  0.14065960742418085,  0.15940619358783512,  0.15940619358783512,550.0,0.8814102564102564,554.0,0.8878205128205128,550.0,0.8814102564102564,550.0,0.8814102564102564,9.0,0.10227272727272728,2.0,0.022727272727272728,2.0,0.022727272727272728,5.0,0.5,1.0,0.1,5.0,0.5
700,cucumber-reporting,"public static List<Hook> eliminateEmptyHooks(Hook[] hooks){
    return Arrays.asList(hooks).stream().filter(Hook::hasContent).collect(Collectors.toList());
}",eliminateEmptyHooks,net/masterthought/cucumber/util/Util.java,/src/main/java/net/masterthought/cucumber/util/Util.java,"/**
     * Helper method that removes empty hooks from passed array and packs it into new collection.
     *
     * @param hooks hooks to be reduced
     * @return no empty hooks
     */",85-95,"('eliminateEmptyHooks', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",43.0,16.0,Helper method that removes empty hooks from passed array and packs it into new collection.,Remove empty hooks from the ginven array and pack it into a new collection,The method removes empty hooks from the array and puts them in a new collection.,0.349730014366683,A helper method that removes empty hooks from the past table and packages it into a new collection.," public static List<Hook> eliminateEmptyHooks(Hook[] hooks){
        return Arrays.stream(hooks)
                .filter(hook -> !hook.getName().isEmpty())
                .collect(Collectors.toList());
    }"," public static List<Hook> eliminateEmptyHooks(Hook[] hooks){
        return Arrays.stream(hooks).filter(h -> h.getName() != null).collect(Collectors.toList());
    }"," public static List<Hook> eliminateEmptyHooks(Hook[] hooks){
        return Arrays.stream(hooks).filter(h -> h.getName() != null).collect(Collectors.toList());
    }"," public static List<Hook> eliminateEmptyHooks(Hook[] hooks){
        return Arrays.stream(hooks)
                .filter(hook -> !hook.getName().isEmpty())
                .collect(Collectors.toList());
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7860716682856395,  0.7922896889271276,  0.7860716682856395,  0.7922896889271276,12.0,0.24489795918367346,9.0,0.1956521739130435,12.0,0.24489795918367346,9.0,0.1956521739130435,7.0,0.14285714285714285,0.0,0.0,7.0,0.14285714285714285,9.0,0.5625,7.0,0.3684210526315789,7.0,0.4375
701,jeromq,"public boolean containsPublicKey(byte[] publicKey){
    Utils.checkArgument(publicKey.length == 32, ""publickey needs to have a size of 32 bytes. got only "" + publicKey.length);
    return containsPublicKey(ZMQ.Curve.z85Encode(publicKey));
}",containsPublicKey,org/zeromq/ZCertStore.java,/src/main/java/org/zeromq/ZCertStore.java,"/**
     * Check if a public key is in the certificate store.
     * @param publicKey needs to be a 32 byte array representing the public key
     */",174-184,"('containsPublicKey', {'INSTRUCTION': {'covered': 24, 'missed': 1}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,11.0,Check if a public key is in the certificate store.,Verify if the public key is in the certificate container,"If the public key is in the store, you should check it.",0.0938031333959624,Check if a public key is in the certificate store.," public boolean containsPublicKey(byte[] publicKey){
        return publicKeys.containsKey(new String(publicKey));       
 }"," public boolean containsPublicKey(byte[] publicKey){
        for (ZMetadata key : publicKeys.values()) {
            if (Arrays.equals(key.publicKey(), publicKey)) {
                return true;
            }
        }
        return false;
    }"," public boolean containsPublicKey(byte[] publicKey){
        return publicKeys.containsKey(new String(publicKey));       
 }"," public boolean containsPublicKey(byte[] publicKey){
        return publicKeys.containsKey(new String(publicKey));       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.28288091066394183,  0.33907207448730814,  0.28288091066394183,  0.28288091066394183,23.0,0.5476190476190477,31.0,0.6458333333333334,23.0,0.5476190476190477,23.0,0.5476190476190477,28.0,0.5833333333333334,0.0,0.0,0.0,0.0,3.0,0.2727272727272727,0.0,0.0,8.0,0.6153846153846154
702,dcache,"private Class<? extends Callable<? extends Serializable>> cast(Class<?> clazz){
    if (EXPECTED_TYPE.isSupertypeOf(clazz)) {
        return (Class<? extends Callable<? extends Serializable>>) clazz.asSubclass(Callable.class);
    }
    throw new RuntimeException(""This is a bug. Please notify support@dcache.org ("" + clazz + "" does not implement Callable<? extends Serializable>)."");
}",cast,org/dcache/util/cli/AnnotatedCommandScanner.java,/modules/common-cli/src/main/java/org/dcache/util/cli/AnnotatedCommandScanner.java,"/**
     * Verifies that clazz implements Callable<? extends Serializable> and casts it to that type.
     *
     * @param clazz The clazz of the command object
     * @return clazz cast to Callable<? extends Serializable>
     */",24-38,"('cast', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,17.0,Verifies that clazz implements Callable<? extends Serializable> and casts it to that type.,Check if clazz implements Callable<? extends Serializable> and if possible cast it,Verifies that Callable is implemented by the clazz.,0.737343717807301,Verifies that clazz implements Callable<? extends Serializable> and throws it to that type.," private Class<? extends Callable<? extends Serializable>> cast(Class<?> clazz){
        if(!Callable.class.isAssignableFrom(clazz)){
            throw new IllegalArgumentException(""Class "" + clazz + "" does not implement Callable"");
        }
        if(!EXPECTED_TYPE.isAssignableFrom(TypeToken.of(clazz))){
            throw new IllegalArgumentException(""Class "" + clazz + "" does not implement Callable<? extends Serializable>"");
        }
        return (Class<? extends Callable<? extends Serializable>>)clazz;
    }"," private Class<? extends Callable<? extends Serializable>> cast(Class<?> clazz){
        if(!Callable.class.isAssignableFrom(clazz)){
            return null;
        }
        try{
            Constructor<? extends Callable<? extends Serializable>> constructor =
                    clazz.asSubclass(Callable.class).getConstructor(String.class);
            return constructor.newInstance("""").getClass();
        }catch(Exception e){
            return null;
        }
    }"," private Class<? extends Callable<? extends Serializable>> cast(Class<?> clazz){
        if(!Callable.class.isAssignableFrom(clazz)){
            throw new IllegalArgumentException(""Class ""+clazz.getName()+"" does not implement Callable"");
        }
        return clazz.asSubclass(Callable.class);        
 }"," private Class<? extends Callable<? extends Serializable>> cast(Class<?> clazz){
        if(!Callable.class.isAssignableFrom(clazz)){
            throw new IllegalArgumentException(""Class ""+clazz.getName()+"" does not implement Callable<? extends Serializable>"");
        }
        return clazz.asSubclass(Callable.class);        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7354742482863347,  0.6151718978840173,  0.6855165811780294,  0.6708298240287986,49.0,0.532608695652174,40.0,0.425531914893617,32.0,0.47058823529411764,32.0,0.47058823529411764,53.0,0.5638297872340425,37.0,0.40217391304347827,38.0,0.41304347826086957,7.0,0.5,1.0,0.07142857142857142,11.0,0.7857142857142857
703,egeria,"public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
        return false;
    }
    Annotation that = (Annotation) objectToCompare;
    return confidenceLevel == that.confidenceLevel && numAttachedAnnotations == that.numAttachedAnnotations && Objects.equals(annotationType, that.annotationType) && Objects.equals(summary, that.summary) && Objects.equals(expression, that.expression) && Objects.equals(explanation, that.explanation) && Objects.equals(analysisStep, that.analysisStep) && Objects.equals(jsonProperties, that.jsonProperties) && annotationStatus == that.annotationStatus && Objects.equals(reviewDate, that.reviewDate) && Objects.equals(steward, that.steward) && Objects.equals(reviewComment, that.reviewComment) && Objects.equals(additionalProperties, that.additionalProperties);
}",equals,org/odpi/openmetadata/frameworks/discovery/properties/Annotation.java,/open-metadata-implementation/frameworks/open-discovery-framework/src/main/java/org/odpi/openmetadata/frameworks/discovery/properties/Annotation.java,"/**
     * Compare the values of the supplied object with those stored in the current object.
     *
     * @param objectToCompare supplied object
     * @return boolean result of comparison
     */",412-443,"('equals', {'INSTRUCTION': {'covered': 96, 'missed': 0}, 'BRANCH': {'covered': 20, 'missed': 12}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 12}, 'METHOD': {'covered': 1, 'missed': 0}})",178.0,15.0,Compare the values of the supplied object with those stored in the current object.,Compare the values of the given object with the values store in itself,The values of the supplied object and the current object should be compared.,0.76530146755942,Compare the values of the supplied object with those stored in the current object.," public boolean equals(Object objectToCompare){
        if (this == objectToCompare) {
            return true;
        }
        if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
            return false;
        }
        Annotation annotation = (Annotation) objectToCompare;
        return Objects.equals(getAnnotationType(), annotation.getAnnotationType()) &&
                Objects.equals(getSummary(), annotation.getSummary()) &&
                Objects.equals(getConfidenceLevel(), annotation.getConfidenceLevel()) &&
                Objects.equals(getExpression(), annotation.getExpression()) &&
                Objects.equals(getExplanation(), annotation.getExplanation()) &&
                Objects.equals(getAnalysisStep(), annotation.getAnalysisStep()) &&
                Objects.equals(getJsonProperties(), annotation.getJsonProperties()) &&
                Objects.equals(getNumAttachedAnnotations(), annotation.getNumAttachedAnnotations()) &&
                Objects.equals(getAnnotationStatus(), annotation.getAnnotationStatus()) &&
                Objects.equals(getReviewDate(), annotation.getReviewDate()) &&
                Objects.equals(getSteward(), annotation.getSteward()) &&
                Objects.equals(getReviewComment(), annotation.getReviewComment()) &&
                Objects.equals(getAdditionalProperties(), annotation.getAdditionalProperties()) &&
                Objects.equals(getHeaderVersion(), annotation.getHeaderVersion()) &&
                Objects.equals(getElementHeader(), annotation.getElementHeader()) &&
                Objects.equals(getTypeName(), annotation.getTypeName()) &&
                Objects.equals(getExtendedProperties(), annotation.getExtendedProperties());        
 }"," public boolean equals(Object objectToCompare){
        if (this == objectToCompare) {
            return true;
        }
        if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
            return false;
        }
        Annotation annotation = (Annotation) objectToCompare;
        return Objects.equals(annotationType, annotation.annotationType) &&
                Objects.equals(summary, annotation.summary) &&
                confidenceLevel == annotation.confidenceLevel &&
                Objects.equals(expression, annotation.expression) &&
                Objects.equals(explanation, annotation.explanation) &&
                Objects.equals(analysisStep, annotation.analysisStep) &&
                Objects.equals(jsonProperties, annotation.jsonProperties) &&
                numAttachedAnnotations == annotation.numAttachedAnnotations &&
                annotationStatus == annotation.annotationStatus &&
                Objects.equals(reviewDate, annotation.reviewDate) &&
                Objects.equals(steward, annotation.steward) &&
                Objects.equals(reviewComment, annotation.reviewComment) &&
                Objects.equals(additionalProperties, annotation.additionalProperties) &&
                Objects.equals(headerVersion, annotation.headerVersion) &&
                Objects.equals(elementHeader, annotation.elementHeader) &&
                Objects.equals(typeName, annotation.typeName) &&
                Objects.equals(extendedProperties, annotation.extendedProperties);      
 }"," public boolean equals(Object objectToCompare){
     
      if (this == objectToCompare) {
            return true;
      }
     
      if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
            return false;
      }
     
      Annotation that = (Annotation) objectToCompare;
     
      return Objects.equals(getAnnotationType(), that.getAnnotationType()) &&
                 Objects.equals(getSummary(), that.getSummary()) &&
                 Objects.equals(getConfidenceLevel(), that.getConfidenceLevel()) &&
                 Objects.equals(getExpression(), that.getExpression()) &&
                 Objects.equals(getExplanation(), that.getExplanation()) &&
                 Objects.equals(getAnalysisStep(), that.getAnalysisStep()) &&
                 Objects.equals(getJsonProperties(), that.getJsonProperties()) &&
                 Objects.equals(getNumAttachedAnnotations(), that.getNumAttachedAnnotations()) &&
                 Objects.equals(getAnnotationStatus(), that.getAnnotationStatus()) &&
                 Objects.equals(getReviewDate(), that.getReviewDate()) &&
                 Objects.equals(getSteward(), that.getSteward()) &&
                 Objects.equals(getReviewComment(), that.getReviewComment()) &&
                 Objects.equals(getAdditionalProperties(), that.getAdditionalProperties());         
 }"," public boolean equals(Object objectToCompare){
        if (this == objectToCompare)
            return true;
        if (objectToCompare == null || getClass() != objectToCompare.getClass())
            return false;
        if (!super.equals(objectToCompare))
            return false;
        Annotation that = (Annotation) objectToCompare;
        return Objects.equals(annotationType, that.annotationType) &&
                Objects.equals(summary, that.summary) &&
                confidenceLevel == that.confidenceLevel &&
                Objects.equals(expression, that.expression) &&
                Objects.equals(explanation, that.explanation) &&
                Objects.equals(analysisStep, that.analysisStep) &&
                Objects.equals(jsonProperties, that.jsonProperties) &&
                numAttachedAnnotations == that.numAttachedAnnotations &&
                annotationStatus == that.annotationStatus &&
                Objects.equals(reviewDate, that.reviewDate) &&
                Objects.equals(steward, that.steward) &&
                Objects.equals(reviewComment, that.reviewComment) &&
                Objects.equals(additionalProperties, that.additionalProperties);        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.51404891388729,  0.7674519299160572,  0.8535386020235057,  0.5648029610369443,170.0,0.5555555555555556,80.0,0.35874439461883406,36.0,0.19148936170212766,96.0,0.3902439024390244,120.0,0.39215686274509803,174.0,0.5686274509803921,74.0,0.24183006535947713,7.0,0.4666666666666667,0.0,0.0,9.0,0.6
704,cdk,"public static boolean deAromatize(IRing ring){
    boolean allaromatic = true;
    for (int i = 0; i < ring.getBondCount(); i++) {
        if (!ring.getBond(i).getFlag(CDKConstants.ISAROMATIC))
            allaromatic = false;
    }
    if (!allaromatic)
        return false;
    for (int i = 0; i < ring.getBondCount(); i++) {
        if (ring.getBond(i).getFlag(CDKConstants.ISAROMATIC))
            ring.getBond(i).setOrder(IBond.Order.SINGLE);
    }
    boolean result = false;
    IMolecularFormula formula = MolecularFormulaManipulator.getMolecularFormula(ring);
    // Map elementCounts = new MFAnalyser(ring).getFormulaHashtable();
    if (ring.getRingSize() == 6) {
        if (MolecularFormulaManipulator.getElementCount(formula, new Element(""C"")) == 6) {
            result = DeAromatizationTool.deAromatizeBenzene(ring);
        } else if (MolecularFormulaManipulator.getElementCount(formula, new Element(""C"")) == 5 && MolecularFormulaManipulator.getElementCount(formula, new Element(""N"")) == 1) {
            result = DeAromatizationTool.deAromatizePyridine(ring);
        }
    }
    if (ring.getRingSize() == 5) {
        if (MolecularFormulaManipulator.getElementCount(formula, new Element(""C"")) == 4 && MolecularFormulaManipulator.getElementCount(formula, new Element(""N"")) == 1) {
            result = deAromatizePyrolle(ring);
        }
    }
    return result;
}",deAromatize,org/openscience/cdk/tools/DeAromatizationTool.java,/legacy/src/main/java/org/openscience/cdk/tools/DeAromatizationTool.java,"/**
     * Methods that takes a ring of which all bonds are aromatic, and assigns single
     * and double bonds. It does this in a non-general way by looking at the ring
     * size and take everything as a special case.
     *
     * @param ring Ring to dearomatize
     * @return  False if it could not convert the aromatic ring bond into single and double bonds
     */",58-93,"('deAromatize', {'INSTRUCTION': {'covered': 87, 'missed': 19}, 'BRANCH': {'covered': 15, 'missed': 9}, 'LINE': {'covered': 16, 'missed': 3}, 'COMPLEXITY': {'covered': 6, 'missed': 7}, 'METHOD': {'covered': 1, 'missed': 0}})",271.0,19.0,"Methods that takes a ring of which all bonds are aromatic, and assigns single  and double bonds.",This method receives a ring of aromatic bonds and assigns single and double bonds,A method that takes a ring of aromatic bonds and assigns single and double bonds.,0.220286136569859,"Methods that take a ring whose all bonds are aromatic, and assign single and double bonds.",Not Valid,Not Valid,Empty Method,Empty Method,Not Valid,Not Valid,Empty Method,Empty Method,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,8.0,0.4444444444444444,4.0,0.2222222222222222,6.0,0.3333333333333333
705,matsim-libs,"private String encodeAttributeValue(final String attributeValue){
    if (attributeValue == null) {
        return null;
    }
    int len = attributeValue.length();
    boolean encode = false;
    for (int pos = 0; pos < len; pos++) {
        char ch = attributeValue.charAt(pos);
        if (ch == '<') {
            encode = true;
            break;
        } else if (ch == '>') {
            encode = true;
            break;
        } else if (ch == '\""') {
            encode = true;
            break;
        } else if (ch == '&') {
            encode = true;
            break;
        }
    }
    if (encode) {
        StringBuilder bf = new StringBuilder(attributeValue.length() + 30);
        for (int pos = 0; pos < len; pos++) {
            char ch = attributeValue.charAt(pos);
            if (ch == '<') {
                bf.append(""&lt;"");
            } else if (ch == '>') {
                bf.append(""&gt;"");
            } else if (ch == '\""') {
                bf.append(""&quot;"");
            } else if (ch == '&') {
                bf.append(""&amp;"");
            } else {
                bf.append(ch);
            }
        }
        return bf.toString();
    }
    return attributeValue;
}",encodeAttributeValue,org/matsim/core/events/algorithms/EventWriterXML.java,/matsim/src/main/java/org/matsim/core/events/algorithms/EventWriterXML.java,"/**
	 * Encodes the given string in such a way that it no longer contains
	 * characters that have a special meaning in xml.
	 * 
	 * @see <a href=""http://www.w3.org/International/questions/qa-escapes#use"">http://www.w3.org/International/questions/qa-escapes#use</a>
	 * @param attributeValue
	 * @return String with some characters replaced by their xml-encoding.
	 */",98-149,"('encodeAttributeValue', {'INSTRUCTION': {'covered': 98, 'missed': 8}, 'BRANCH': {'covered': 22, 'missed': 2}, 'LINE': {'covered': 30, 'missed': 3}, 'COMPLEXITY': {'covered': 11, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",250.0,22.0,Encodes the given string in such a way that it no longer contains  characters that have a special meaning in xml.,Encodes the given string preventing XML collisions,The given string no longer contains characters that have a special meaning in the xml.,0.657877000963501,Encodes the given string so that it no longer contains characters that have a special meaning in xml.,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,17.0,0.7727272727272727,4.0,0.18181818181818182,9.0,0.4090909090909091
706,cdk,"public int lastIndexOf(Object o){
    IAtomContainer atomContainer = (IAtomContainer) o;
    if (!atomContainer.getTitle().equals(title))
        return -1;
    if (atomContainer.getAtomCount() != coordinates.get(0).length)
        return -1;
    boolean coordsMatch;
    for (int j = coordinates.size() - 1; j >= 0; j--) {
        Point3d[] coords = coordinates.get(j);
        coordsMatch = true;
        for (int i = 0; i < atomContainer.getAtomCount(); i++) {
            Point3d p = atomContainer.getAtom(i).getPoint3d();
            if (!(p.x == coords[i].x && p.y == coords[i].y && p.z == coords[i].z)) {
                coordsMatch = false;
                break;
            }
        }
        if (coordsMatch)
            return j;
    }
    return -1;
}",lastIndexOf,org/openscience/cdk/ConformerContainer.java,/base/data/src/main/java/org/openscience/cdk/ConformerContainer.java,"/**
     * Returns the highest index at which the specific IAtomContainer appears in the list or -1 if is not found.
     * 
     * A given IAtomContainer will occur in the list if the title matches the stored title for
     * the conformers in this container and if the coordinates for each atom in the specified molecule
     * are equal to the coordinates of the corresponding atoms in a conformer.
     *
     * @param o The IAtomContainer whose presence is being tested
     * @return The index where o was found
     */",400-431,"('lastIndexOf', {'INSTRUCTION': {'covered': 80, 'missed': 6}, 'BRANCH': {'covered': 11, 'missed': 5}, 'LINE': {'covered': 12, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",188.0,20.0,Returns the highest index at which the specific IAtomContainer appears in the list or -1 if is not found.,Get the highest index of the IAtomContainer in a list or -1 if it is not found,"If the IAtomContainer is not found, the highest index will be the one that it appears in.",0.265808058070117,Returns the highest index at which the specific IAtomContainer appears in the list or -1 if it cannot be found.,"public int lastIndexOf(Object o){
        IAtomContainer atomContainer = (IAtomContainer) o;
        if (!atomContainer.getTitle().equals(title)) return -1;
    
        if (atomContainer.getAtomCount() != this.atomContainer.getAtomCount()) return -1;
    
        boolean coordsMatch;
        int index = coordinates.size() - 1;
        for (int i = coordinates.size() - 1; i >= 0; i--) {
            coordsMatch = true;
            for (int j = 0; j < atomContainer.getAtomCount(); j++) {
                Point3d p = atomContainer.getAtom(j).getPoint3d();
                if (!(p.x == coordinates.get(i)[j].x && p.y == coordinates.get(i)[j].y && p.z == coordinates.get(i)[j].z)) {
                    coordsMatch = false;
                    break;
                }
            }
            if (coordsMatch) return index;
            index--;
        }
        return -1;
    }","public int lastIndexOf(Object o){
        IAtomContainer atomContainer = (IAtomContainer) o;
        if (!atomContainer.getTitle().equals(title)) return -1;
    
        if (atomContainer.getAtomCount() != this.atomContainer.getAtomCount()) return -1;
    
        boolean coordsMatch;
        int index = coordinates.size() - 1;
        for (int i = coordinates.size() - 1; i >= 0; i--) {
            coordsMatch = true;
            for (int j = 0; j < atomContainer.getAtomCount(); j++) {
                Point3d p = atomContainer.getAtom(j).getPoint3d();
                if (!(p.x == coordinates.get(i)[j].x && p.y == coordinates.get(i)[j].y && p.z == coordinates.get(i)[j].z)) {
                    coordsMatch = false;
                    break;
                }
            }
            if (coordsMatch) return index;
            index--;
        }
        return -1;
    }","public int lastIndexOf(Object o){
        IAtomContainer atomContainer = (IAtomContainer) o;
        if (!atomContainer.getTitle().equals(title)) return -1;
    
        if (atomContainer.getAtomCount() != this.atomContainer.getAtomCount()) return -1;
    
        boolean coordsMatch;
        int index = coordinates.size() - 1;
        for (int i = coordinates.size() - 1; i >= 0; i--) {
            coordsMatch = true;
            for (int j = 0; j < atomContainer.getAtomCount(); j++) {
                Point3d p = atomContainer.getAtom(j).getPoint3d();
                if (!(p.x == coordinates.get(i)[j].x && p.y == coordinates.get(i)[j].y && p.z == coordinates.get(i)[j].z)) {
                    coordsMatch = false;
                    break;
                }
            }
            if (coordsMatch) return index;
            index--;
        }
        return -1;
    }","public int lastIndexOf(Object o){
        IAtomContainer atomContainer = (IAtomContainer) o;
        if (!atomContainer.getTitle().equals(title)) return -1;
    
        if (atomContainer.getAtomCount() != this.atomContainer.getAtomCount()) return -1;
    
        boolean coordsMatch;
        int index = coordinates.size() - 1;
        for (int i = coordinates.size() - 1; i >= 0; i--) {
            coordsMatch = true;
            for (int j = 0; j < atomContainer.getAtomCount(); j++) {
                Point3d p = atomContainer.getAtom(j).getPoint3d();
                if (!(p.x == coordinates.get(i)[j].x && p.y == coordinates.get(i)[j].y && p.z == coordinates.get(i)[j].z)) {
                    coordsMatch = false;
                    break;
                }
            }
            if (coordsMatch) return index;
            index--;
        }
        return -1;
    }",PASS,PASS,PASS,PASS,  0.6963534905008624,  0.6963534905008624,  0.6963534905008624,  0.6963534905008624,59.0,0.28780487804878047,59.0,0.28780487804878047,59.0,0.28780487804878047,59.0,0.28780487804878047,0.0,0.0,0.0,0.0,0.0,0.0,8.0,0.4,3.0,0.14285714285714285,16.0,0.8
707,dataverse,"public boolean isInReview(){
    if (versionState != null && versionState.equals(VersionState.DRAFT)) {
        return getDataset().isLockedFor(DatasetLock.Reason.InReview);
    } else {
        return false;
    }
}",isInReview,edu/harvard/iq/dataverse/DatasetVersion.java,/src/main/java/edu/harvard/iq/dataverse/DatasetVersion.java,"/**
     * The only time a dataset can be in review is when it is in draft.
     * @return if the dataset is being reviewed
     */",279-289,"('isInReview', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,16.0,The only time a dataset can be in review is when it is in draft.,Check if the dataset can be reviewed because still in draft mode,When a dataset is in draft is the only time it can be reviewed.,0.280886913544161,The only time a dataset can be revised is when it is in draft.," public boolean isInReview(){
        return getStatus() == DatasetVersion.Status.DRAFT;
    }"," public boolean isInReview(){
        return this.getStatus() == DatasetVersion.Status.DRAFT;     
 }"," public boolean isInReview(){
        return getStatus() == DatasetVersion.Status.DRAFT;      
 }"," public boolean isInReview(){
        return getStatus() == DatasetVersion.Status.DRAFT;      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.168407745459621,  0.16211109024419348,  0.168407745459621,  0.168407745459621,31.0,0.6888888888888889,31.0,0.6888888888888889,31.0,0.6888888888888889,31.0,0.6888888888888889,2.0,0.09523809523809523,0.0,0.0,0.0,0.0,12.0,0.75,2.0,0.125,12.0,0.75
710,acs-aem-commons,"public static T toObjectType(String data, Class<T> klass){
    if (Double.class.equals(klass)) {
        try {
            return klass.cast(Double.parseDouble(data));
        } catch (NumberFormatException ex) {
            return null;
        }
    } else if (Long.class.equals(klass)) {
        try {
            return klass.cast(Long.parseLong(data));
        } catch (NumberFormatException ex) {
            return null;
        }
    } else if (Integer.class.equals(klass)) {
        try {
            return klass.cast(Long.parseLong(data));
        } catch (NumberFormatException ex) {
            return null;
        }
    } else if (StringUtils.equalsIgnoreCase(""true"", data)) {
        return klass.cast(Boolean.TRUE);
    } else if (StringUtils.equalsIgnoreCase(""false"", data)) {
        return klass.cast(Boolean.FALSE);
    } else if (JSON_DATE.matcher(data).matches()) {
        long epochSeconds = OffsetDateTime.parse(data).toInstant().toEpochMilli();
        return klass.cast(new Date(epochSeconds));
    } else {
        return klass.cast(data);
    }
}",toObjectType,com/adobe/acs/commons/util/TypeUtil.java,/bundle/src/main/java/com/adobe/acs/commons/util/TypeUtil.java,"/**
     * Converts a limited set of String representations to their corresponding Objects
     * <p/>
     * Supports
     * * Double
     * * Long
     * * Integer
     * * Boolean (true/false)
     * * Dates in string format of ISODateTimeFormat
     * <p/>
     * Else, null is returned.
     *
     * @param data  the String representation of the data
     * @param klass the target class type of the provided data
     * @param <T>   the target class type of the provided data
     * @return the derived object representing the data as specified by the klass
     */",120-166,"('toObjectType', {'INSTRUCTION': {'covered': 61, 'missed': 15}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 7}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",240.0,37.0,"Converts a limited set of String representations to their corresponding Objects  <p/>  Supports   Double   Long   Integer   Boolean (true/false)   Dates in string format of ISODateTimeFormat  <p/>  Else, null is returned.",Transforms a limited set of String representations to their corresponding Objects,The dates in the string are converted to the corresponding objects.,0.142416895467571,"Converts a limited set of String representations to their corresponding objects <p/> Supports long double integer (true/false) Boolean dates in ISODateTimeFormat <p/> Else string format, null is returned."," public static T toObjectType(String data, Class<T> klass){
        if(data == null) {
            return null;
        }
        if(klass == Double.class || klass == Double.TYPE) {
            return (T) Double.valueOf(data);
        } else if(klass == Long.class || klass == Long.TYPE) {
            return (T) Long.valueOf(data);
        } else if(klass == Integer.class || klass == Integer.TYPE) {
            return (T) Integer.valueOf(data);
        } else if(klass == Boolean.class || klass == Boolean.TYPE) {
            return (T) Boolean.valueOf(data);
        } else if(klass == Date.class) {
            return (T) DateUtil.parseISODateTime(data);
        } else if(klass == Calendar.class) {
            return (T) DateUtil.parseISODateTime(data).toGregorianCalendar();
        } else if(klass == OffsetDateTime.class) {
            return (T) DateUtil.parseISODateTime(data);
        } else if(klass == String.class) {
            return (T) data;
        } else {
            return null;
        }
    }",Not Valid,Not Valid," public static T toObjectType(String data, Class<T> klass){
        if(data == null) {
            return null;
        }
        if(klass == String.class) {
            return (T) data;
        }
        if(klass == Long.class || klass == Long.TYPE) {
            return (T) Long.valueOf(data);
        }
        if(klass == Double.class || klass == Double.TYPE) {
            return (T) Double.valueOf(data);
        }
        if(klass == Integer.class || klass == Integer.TYPE) {
            return (T) Integer.valueOf(data);
        }
        if(klass == Boolean.class || klass == Boolean.TYPE) {
            return (T) Boolean.valueOf(data);
        }
        if(klass == Date.class) {
            if(JSON_DATE.matcher(data).matches()) {
                return (T) OffsetDateTime.parse(data).toDate();
            }
            return (T) null;
        }
        if(klass == Calendar.class) {
            if(JSON_DATE.matcher(data).matches()) {
                return (T) OffsetDateTime.parse(data).toCalendar();
            }
            return (T) null;
        }
        return (T) data;
    }",NOT PASS,Not Valid,NOT PASS,Not Valid,  0.4765156692470348,None,  0.5004256877795008,None,165.0,0.6846473029045643,None,None,175.0,0.7,None,None,None,None,82.0,0.328,None,None,19.0,0.6333333333333333,13.0,0.43333333333333335,27.0,0.9
711,metrics,"public void report(){
    synchronized (this) {
        report(registry.getGauges(filter), registry.getCounters(filter), registry.getHistograms(filter), registry.getMeters(filter), registry.getTimers(filter));
    }
}",report,io/dropwizard/metrics5/ScheduledReporter.java,/metrics-core/src/main/java/io/dropwizard/metrics5/ScheduledReporter.java,"/**
     * Report the current values of all metrics in the registry.
     */",248-259,"('report', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,11.0,Report the current values of all metrics in the registry.,Reports the values of all metrics in the registry,The current values of all metrics should be reported.,0.565100616141404,Specify the current values for all measures in the registry.," public void report(){
        report(registry.getGauges(filter), registry.getCounters(filter), registry.getHistograms(filter), registry.getMeters(filter), registry.getTimers(filter));
    }"," public void report(){
        final SortedMap<String, Gauge> gauges = getGauges();
        final SortedMap<String, Counter> counters = getCounters();
        final SortedMap<String, Histogram> histograms = getHistograms();
        final SortedMap<String, Meter> meters = getMeters();
        final SortedMap<String, Timer> timers = getTimers();
    
        final StringBuilder buf = new StringBuilder();
        buf.append(getPrefix());
        buf.append(""{"");
        boolean first = true;
    
        for (Map.Entry<String, Gauge> entry : gauges.entrySet()) {
            if (first) {
                first = false;
            } else {
                buf.append("","");
            }
            buf.append(entry.getValue().getValue());
        }
    
        for (Map.Entry<String, Counter> entry : counters.entrySet()) {
            if (first) {
                first = false;
            } else {
                buf.append("","");
            }
            buf.append(entry.getValue().getCount());
        }
    
        for (Map.Entry<String, Histogram> entry : histograms.entrySet()) {
            if (first) {
                first = false;
            } else {
                buf.append("","");
            }
            buf.append(entry.getValue().getCount());
        }
    
        for (Map.Entry<String, Meter> entry : meters.entrySet()) {
            if (first) {
                first = false;
            } else {
                buf.append("","");
            }
            buf.append(entry.getValue().getCount());
        }
    
        for (Map.Entry<String, Timer> entry : timers.entrySet()) {
            if (first) {
                first = false;
            } else {
                buf.append("","");
            }
            buf.append(entry.getValue().getCount());
        }
    
        buf.append(""}"");
        LOG.info(buf.toString());       
 }"," public void report(){
        report(getGauges(), getCounters(), getHistograms(), getMeters(), getTimers());
    }",Not Valid,NOT PASS,NOT PASS,Not Valid,NOT PASS,  0.8864792888133639,  0.17621439148221374,None,  0.21109599015033412,6.0,0.11538461538461539,362.0,0.9141414141414141,None,None,21.0,0.40384615384615385,366.0,0.9242424242424242,None,None,15.0,0.32608695652173914,3.0,0.2727272727272727,3.0,0.2727272727272727,5.0,0.45454545454545453
712,cdk,"public static IDifference difference(IChemObject first, IChemObject second){
    if (!(first instanceof IAtomType && second instanceof IAtomType)) {
        return null;
    }
    IAtomType firstElem = (IAtomType) first;
    IAtomType secondElem = (IAtomType) second;
    ChemObjectDifference totalDiff = new ChemObjectDifference(""AtomTypeDiff"");
    totalDiff.addChild(StringDifference.construct(""N"", firstElem.getAtomTypeName(), secondElem.getAtomTypeName()));
    totalDiff.addChild(BondOrderDifference.construct(""MBO"", firstElem.getMaxBondOrder(), secondElem.getMaxBondOrder()));
    totalDiff.addChild(DoubleDifference.construct(""BOS"", firstElem.getBondOrderSum(), secondElem.getBondOrderSum()));
    totalDiff.addChild(IntegerDifference.construct(""FC"", firstElem.getFormalCharge(), secondElem.getFormalCharge()));
    totalDiff.addChild(AtomTypeHybridizationDifference.construct(""H"", firstElem.getHybridization(), secondElem.getHybridization()));
    totalDiff.addChild(IntegerDifference.construct(""NC"", firstElem.getFormalNeighbourCount(), secondElem.getFormalNeighbourCount()));
    totalDiff.addChild(DoubleDifference.construct(""CR"", firstElem.getCovalentRadius(), secondElem.getCovalentRadius()));
    totalDiff.addChild(IntegerDifference.construct(""V"", firstElem.getValency(), secondElem.getValency()));
    totalDiff.addChild(IsotopeDiff.difference(first, second));
    if (totalDiff.childCount() > 0) {
        return totalDiff;
    } else {
        return null;
    }
}",difference,org/openscience/cdk/tools/diff/AtomTypeDiff.java,/misc/diff/src/main/java/org/openscience/cdk/tools/diff/AtomTypeDiff.java,"/**
     * Compare two {@link IChemObject} classes and return the difference as an {@link IDifference}.
     *
     * @param first  the first of the two classes to compare
     * @param second the second of the two classes to compare
     * @return an {@link IDifference} representation of the difference between the first and second {@link IChemObject}.
     */",62-96,"('difference', {'INSTRUCTION': {'covered': 93, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 22, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",283.0,20.0,Compare two {@link IChemObject} classes and return the difference as an {@link IDifference}.,Return as a IDifference the differences between two objcts of type IChemObject,You can compare two classes and return a difference.,0.264099018806769,Compare two classes {@link IChemObject} and return the difference as a {@link IDifference}.," public static IDifference difference(IChemObject first, IChemObject second){
        if (first == null && second == null) {
            return null;
        } else if (first == null) {
            return new ChemObjectDifference(second);
        } else if (second == null) {
            return new ChemObjectDifference(first);
        } else if (first.getClass() != second.getClass()) {
            return new ChemObjectDifference(first, second);
        } else if (first instanceof IAtomType) {
            return AtomTypeDifference.difference((IAtomType)first, (IAtomType)second);
        } else {
            return null;
        }       
 }"," public static IDifference difference(IChemObject first, IChemObject second){
        if (first == null && second == null) return null;
        if (first == null) return new ChemObjectDifference(second);
        if (second == null) return new ChemObjectDifference(first);
        if (first instanceof IAtomType && second instanceof IAtomType) {
            return difference((IAtomType)first, (IAtomType)second);
        } else {
            return new ChemObjectDifference(first, second);
        }
    }"," public static IDifference difference(IChemObject first, IChemObject second){
        if (first == null && second == null) {
            return null;
        } else if (first == null) {
            return new ChemObjectDifference(second);
        } else if (second == null) {
            return new ChemObjectDifference(first);
        } else if (first instanceof IAtomType && second instanceof IAtomType) {
            return difference((IAtomType) first, (IAtomType) second);
        } else {
            return new ChemObjectDifference(first, second);
        }
    }"," public static IDifference difference(IChemObject first, IChemObject second){
        if (first == null && second == null) {
            return null;
        } else if (first == null) {
            return new ChemObjectDifference(second);
        } else if (second == null) {
            return new ChemObjectDifference(first);
        } else if (first.getClass() != second.getClass()) {
            return new ChemObjectDifference(first, second);
        } else if (first instanceof IAtomType) {
            return diff((IAtomType) first, (IAtomType) second);
        } else {
            return null;
        }       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.21022590032505198,  0.11921003536512623,  0.19912397425225867,  0.12886179103307152,215.0,0.7570422535211268,231.0,0.8133802816901409,216.0,0.7605633802816901,229.0,0.8063380281690141,43.0,0.3644067796610169,3.0,0.025423728813559324,34.0,0.288135593220339,13.0,0.9285714285714286,3.0,0.21428571428571427,10.0,0.7142857142857143
713,tablesaw,"public Table reorderColumns(String... columnNames){
    Preconditions.checkArgument(columnNames.length == columnCount());
    Table table = Table.create(name);
    for (String name : columnNames) {
        table.addColumns(column(name));
    }
    return table;
}",reorderColumns,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,"/**
   * Return a new table (shallow copy) that contains all the columns in this table, in the order
   * given in the argument. Throw an IllegalArgument exception if the number of names given does not
   * match the number of columns in this table. NOTE: This does not make a copy of the columns, so
   * they are shared between the two tables.
   *
   * @param columnNames a column name or array of names
   */",305-320,"('reorderColumns', {'INSTRUCTION': {'covered': 41, 'missed': 1}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,25.0,"Return a new table (shallow copy) that contains all the columns in this table, in the order  given in the argument.",This method get a new shallow copy of the table containing all the columns in this table,Return a new table that contains all the columns in the argument.,0.265904541084934,"Return a new table (superficial copy) that contains all the columns in that table, in the order specified in the argument."," public Table reorderColumns(String... columnNames){
    List<Column<?>> newColumns = new ArrayList<>();
    for (String name : columnNames) {
      newColumns.add(getColumn(name));
    }
    return new Table(name, newColumns);
  }"," public Table reorderColumns(String... columnNames){
    List<Column<?>> newColumnList = new ArrayList<>();
    for(String s : columnNames){
      newColumnList.add(getColumn(s));
    }
    return new Table(name, newColumnList);
  }"," public Table reorderColumns(String... columnNames){
    return reorderColumns(Arrays.asList(columnNames));    
 }"," public Table reorderColumns(String... columnNames){
    return reorderColumns(getSort(columnNames));    
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.504200622452208,  0.4570259834027188,  0.2325049876092572,  0.24798082528947557,30.0,0.5357142857142857,32.0,0.5714285714285714,39.0,0.6964285714285714,38.0,0.6785714285714286,5.0,0.09090909090909091,38.0,0.6909090909090909,38.0,0.6909090909090909,17.0,0.7727272727272727,3.0,0.13636363636363635,9.0,0.4090909090909091
714,logstash-logback-encoder,"public static WaitStrategy createWaitStrategyFromString(String waitStrategyType){
    if (waitStrategyType == null) {
        return null;
    }
    waitStrategyType = waitStrategyType.trim().toLowerCase();
    if (waitStrategyType.isEmpty()) {
        return null;
    }
    if (waitStrategyType.equals(""blocking"")) {
        return new BlockingWaitStrategy();
    }
    if (waitStrategyType.equals(""busyspin"")) {
        return new BusySpinWaitStrategy();
    }
    if (waitStrategyType.equals(""liteblocking"")) {
        return new LiteBlockingWaitStrategy();
    }
    if (waitStrategyType.startsWith(""sleeping"")) {
        if (waitStrategyType.equals(""sleeping"")) {
            return new SleepingWaitStrategy();
        } else {
            List<Object> params = parseParams(waitStrategyType, Integer.class, Long.class);
            return new SleepingWaitStrategy((Integer) params.get(0), (Long) params.get(1));
        }
    }
    if (waitStrategyType.equals(""yielding"")) {
        return new YieldingWaitStrategy();
    }
    if (waitStrategyType.startsWith(""phasedbackoff"")) {
        List<Object> params = parseParams(waitStrategyType, Long.class, Long.class, TimeUnit.class, WaitStrategy.class);
        return new PhasedBackoffWaitStrategy((Long) params.get(0), (Long) params.get(1), (TimeUnit) params.get(2), (WaitStrategy) params.get(3));
    }
    if (waitStrategyType.startsWith(""timeoutblocking"")) {
        List<Object> params = parseParams(waitStrategyType, Long.class, TimeUnit.class);
        return new TimeoutBlockingWaitStrategy((Long) params.get(0), (TimeUnit) params.get(1));
    }
    if (waitStrategyType.startsWith(""litetimeoutblocking"")) {
        List<Object> params = parseParams(waitStrategyType, Long.class, TimeUnit.class);
        return new LiteTimeoutBlockingWaitStrategy((Long) params.get(0), (TimeUnit) params.get(1));
    }
    throw new IllegalArgumentException(""Unknown wait strategy type: "" + waitStrategyType);
}",createWaitStrategyFromString,net/logstash/logback/appender/WaitStrategyFactory.java,/src/main/java/net/logstash/logback/appender/WaitStrategyFactory.java,"/**
     * Creates a {@link WaitStrategy} from a string.
     * <p>
     * The following strategies are supported:
     * <ul>
     * <li><code>blocking</code> - {@link BlockingWaitStrategy}</li>
     * <li><code>busySpin</code> - {@link BusySpinWaitStrategy}</li>
     * <li><code>liteBlocking</code> - {@link LiteBlockingWaitStrategy}</li>
     * <li><code>sleeping{retries,sleepTimeNs}</code> - {@link SleepingWaitStrategy}
     *         - <code>retries</code> an integer number of times to spin before sleeping. (default = 200)
     *           <code>sleepTimeNs</code> nanosecond time to sleep each iteration after spinning (default = 100)
     * </li>
     * <li><code>yielding</code> - {@link YieldingWaitStrategy}</li>
     * <li><code>phasedBackoff{spinTimeout,yieldTimeout,timeUnit,fallackStrategy}</code> - {@link PhasedBackoffWaitStrategy}
     *         - <code>spinTimeout</code> and <code>yieldTimeout</code> are long values.
     *           <code>timeUnit</code> is a string name of one of the {@link TimeUnit} values.
     *           <code>fallbackStrategy</code> is a wait strategy string (e.g. <code>blocking</code>).
     * </li>
     * <li><code>timeoutBlocking{timeout,timeUnit}</code> - {@link TimeoutBlockingWaitStrategy}
     *         - <code>timeout</code> is a long value.
     *           <code>timeUnit</code> is a string name of one of the {@link TimeUnit} values.
     * </li>
     * <li><code>liteTimeoutBlocking{timeout,timeUnit}</code> - {@link LiteTimeoutBlockingWaitStrategy}
     *         - <code>timeout</code> is a long value.
     *           <code>timeUnit</code> is a string name of one of the {@link TimeUnit} values.
     * </li>
     * </ul>
     *
     * @param waitStrategyType the name of the desired wait strategy
     * @return a {@link WaitStrategy} instance or {@code null} if the supplied name is {@code null} or empty
     * @throws IllegalArgumentException if an unknown wait strategy type is given, or the parameters are unable to be parsed.
     */",41-136,"('createWaitStrategyFromString', {'INSTRUCTION': {'covered': 191, 'missed': 12}, 'BRANCH': {'covered': 21, 'missed': 1}, 'LINE': {'covered': 37, 'missed': 1}, 'COMPLEXITY': {'covered': 11, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",391.0,11.0,Creates a {@link WaitStrategy} from a string.,Build a waiting strategy from the input string,A @link WaitStrategy is created from a string.,0.954793545975364,Creates a {waitStrategy} {@link from a string.," public static WaitStrategy createWaitStrategyFromString(String waitStrategyType){
        if(waitStrategyType == null){
            return new BusySpinWaitStrategy();
        }
        if(waitStrategyType.equals(""busySpin"")){
            return new BusySpinWaitStrategy();
        }
        if(waitStrategyType.equals(""liteBlocking"")){
            return new LiteBlockingWaitStrategy();
        }
        if(waitStrategyType.equals(""liteTimeoutBlocking"")){
            return new LiteTimeoutBlockingWaitStrategy();
        }
        if(waitStrategyType.equals(""phasedBackoff"")){
            return new PhasedBackoffWaitStrategy();
        }
        if(waitStrategyType.equals(""sleeping"")){
            return new SleepingWaitStrategy();
        }
        if(waitStrategyType.equals(""timeoutBlocking"")){
            return new TimeoutBlockingWaitStrategy();
        }
        if(waitStrategyType.equals(""yielding"")){
            return new YieldingWaitStrategy();
        }
        if(waitStrategyType.equals(""blocking"")){
            return new BlockingWaitStrategy();
        }
        throw new IllegalArgumentException(""Unknown wait strategy type: "" + waitStrategyType);      
 }"," public static WaitStrategy createWaitStrategyFromString(String waitStrategyType){
        if(waitStrategyType == null){
            return new BusySpinWaitStrategy();
        }
        if(waitStrategyType.equals(""busySpin"")){
            return new BusySpinWaitStrategy();
        }
        if(waitStrategyType.equals(""liteBlocking"")){
            return new LiteBlockingWaitStrategy();
        }
        if(waitStrategyType.equals(""liteTimeoutBlocking"")){
            return new LiteTimeoutBlockingWaitStrategy();
        }
        if(waitStrategyType.equals(""phasedBackoff"")){
            return new PhasedBackoffWaitStrategy();
        }
        if(waitStrategyType.equals(""sleeping"")){
            return new SleepingWaitStrategy();
        }
        if(waitStrategyType.equals(""timeoutBlocking"")){
            return new TimeoutBlockingWaitStrategy();
        }
        if(waitStrategyType.equals(""yielding"")){
            return new YieldingWaitStrategy();
        }
        if(waitStrategyType.equals(""blocking"")){
            return new BlockingWaitStrategy();
        }
        throw new IllegalArgumentException(""Unknown wait strategy type: "" + waitStrategyType);      
 }",Not Valid," public static WaitStrategy createWaitStrategyFromString(String waitStrategyType){
        if (waitStrategyType == null) {
            return new SleepingWaitStrategy();
        }
        if (waitStrategyType.equalsIgnoreCase(""busySpin"")) {
            return new BusySpinWaitStrategy();
        }
        if (waitStrategyType.equalsIgnoreCase(""liteBlocking"")) {
            return new LiteBlockingWaitStrategy();
        }
        if (waitStrategyType.equalsIgnoreCase(""liteTimeoutBlocking"")) {
            return new LiteTimeoutBlockingWaitStrategy();
        }
        if (waitStrategyType.equalsIgnoreCase(""timeoutBlocking"")) {
            return new TimeoutBlockingWaitStrategy();
        }
        if (waitStrategyType.equalsIgnoreCase(""yielding"")) {
            return new YieldingWaitStrategy();
        }
        if (waitStrategyType.equalsIgnoreCase(""phasedBackoff"")) {
            return new PhasedBackoffWaitStrategy();
        }
        if (waitStrategyType.equalsIgnoreCase(""sleeping"")) {
            return new SleepingWaitStrategy();
        }
        if (waitStrategyType.equalsIgnoreCase(""blocking"")) {
            return new BlockingWaitStrategy();
        }
        if (waitStrategyType.startsWith(""custom:"")) {
            String className = waitStrategyType.substring(""custom:"".length());
            try {
                return (WaitStrategy) Class.forName(className).newInstance();
            } catch (Exception e) {
                throw new IllegalArgumentException(""Could not create custom wait strategy "" + className, e);
            }
        }
        throw new IllegalArgumentException(""Unknown wait strategy "" + waitStrategyType);        
 }",NOT PASS,NOT PASS,NOT PASS,Not Valid,  0.28382024892010127,  0.28382024892010127,  0.32827851608813874,None,243.0,0.6198979591836735,243.0,0.6198979591836735,229.0,0.5841836734693877,None,None,0.0,0.0,79.0,0.341991341991342,None,None,6.0,0.6666666666666666,2.0,0.25,5.0,0.5555555555555556
715,cdk,"private static List<List<CDKRMap>> makeAtomsMapOfBondsMap(List<CDKRMap> rMapList, IAtomContainer graph1, IAtomContainer graph2){
    if (rMapList == null) {
        return (null);
    }
    List<List<CDKRMap>> result = null;
    if (rMapList.size() == 1) {
        result = makeAtomsMapOfBondsMapSingleBond(rMapList, graph1, graph2);
    } else {
        List<CDKRMap> resultLocal = new ArrayList<CDKRMap>();
        for (int i = 0; i < rMapList.size(); i++) {
            IBond qBond = graph1.getBond(rMapList.get(i).getId1());
            IBond tBond = graph2.getBond(rMapList.get(i).getId2());
            IAtom[] qAtoms = BondManipulator.getAtomArray(qBond);
            IAtom[] tAtoms = BondManipulator.getAtomArray(tBond);
            for (int j = 0; j < 2; j++) {
                List<IBond> bondsConnectedToAtom1j = graph1.getConnectedBondsList(qAtoms[j]);
                for (int k = 0; k < bondsConnectedToAtom1j.size(); k++) {
                    if (!bondsConnectedToAtom1j.get(k).equals(qBond)) {
                        IBond testBond = bondsConnectedToAtom1j.get(k);
                        for (int m = 0; m < rMapList.size(); m++) {
                            IBond testBond2;
                            if ((rMapList.get(m)).getId1() == graph1.indexOf(testBond)) {
                                testBond2 = graph2.getBond((rMapList.get(m)).getId2());
                                for (int n = 0; n < 2; n++) {
                                    List<IBond> bondsToTest = graph2.getConnectedBondsList(tAtoms[n]);
                                    if (bondsToTest.contains(testBond2)) {
                                        CDKRMap map;
                                        if (j == n) {
                                            map = new CDKRMap(graph1.indexOf(qAtoms[0]), graph2.indexOf(tAtoms[0]));
                                        } else {
                                            map = new CDKRMap(graph1.indexOf(qAtoms[1]), graph2.indexOf(tAtoms[0]));
                                        }
                                        if (!resultLocal.contains(map)) {
                                            resultLocal.add(map);
                                        }
                                        CDKRMap map2;
                                        if (j == n) {
                                            map2 = new CDKRMap(graph1.indexOf(qAtoms[1]), graph2.indexOf(tAtoms[1]));
                                        } else {
                                            map2 = new CDKRMap(graph1.indexOf(qAtoms[0]), graph2.indexOf(tAtoms[1]));
                                        }
                                        if (!resultLocal.contains(map2)) {
                                            resultLocal.add(map2);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        result = new ArrayList<List<CDKRMap>>();
        result.add(resultLocal);
    }
    return result;
}",makeAtomsMapOfBondsMap,org/openscience/cdk/smsd/algorithm/rgraph/CDKRMapHandler.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKRMapHandler.java,"/**
     *  This makes sourceAtom map of matching atoms out of sourceAtom map of matching bonds as produced by the get(Subgraph|Ismorphism)Map methods.
     *
     * @param  rMapList   The list produced by the getMap method.
     * @param  graph1  first molecule. Must not be an IQueryAtomContainer.
     * @param  graph2  second molecule. May be an IQueryAtomContainer.
     * @return     The mapping found projected on graph1. This is sourceAtom List of CDKRMap objects containing Ids of matching atoms.
     */",327-396,"('makeAtomsMapOfBondsMap', {'INSTRUCTION': {'covered': 213, 'missed': 2}, 'BRANCH': {'covered': 27, 'missed': 1}, 'LINE': {'covered': 38, 'missed': 1}, 'COMPLEXITY': {'covered': 14, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",553.0,25.0,This makes sourceAtom map of matching atoms out of sourceAtom map of matching bonds as produced by the get(Subgraph|Ismorphism)Map methods.,This method makes sourceAtom map of matching atoms out of sourceAtom map of matching bonds,This makes sourceAtom map of matching atoms out of sourceAtom map of matching bonds as produced by the get method.,1.22088264636658,This makes sourceAtom map of corresponding atoms out of sourceAtom map of corresponding bonds as produced by the get(Subgraph| Ismorphism)Cartographic methods.,"private static List<List<CDKRMap>> makeAtomsMapOfBondsMap(List<CDKRMap> rMapList, IAtomContainer graph1, IAtomContainer graph2){
        List<List<CDKRMap>> rMapListAtoms = new ArrayList<List<CDKRMap>>();
        for (CDKRMap rMap : rMapList) {
            List<CDKRMap> rMapAtoms = new ArrayList<CDKRMap>();
            for (int i = 0; i < rMap.getCount(); i++) {
                int sourceAtomIndex = rMap.getSourceAtomIndex(i);
                int targetAtomIndex = rMap.getTargetAtomIndex(i);
                IAtom sourceAtom = graph1.getAtom(sourceAtomIndex);
                IAtom targetAtom = graph2.getAtom(targetAtomIndex);
                CDKRMap rMapAtom = new CDKRMap(sourceAtom, targetAtom);
                rMapAtoms.add(rMapAtom);
            }
            rMapListAtoms.add(rMapAtoms);
        }
        return rMapListAtoms;
    }","private static List<List<CDKRMap>> makeAtomsMapOfBondsMap(List<CDKRMap> rMapList, IAtomContainer graph1, IAtomContainer graph2){
        List<List<CDKRMap>> rMapListAtoms = new ArrayList<List<CDKRMap>>();
        for (CDKRMap rMap : rMapList) {
            List<CDKRMap> rMapListAtomsTemp = new ArrayList<CDKRMap>();
            for (int i = 0; i < rMap.getCount(); i++) {
                int sourceAtomIndex = rMap.getSourceAtomIndex(i);
                int targetAtomIndex = rMap.getTargetAtomIndex(i);
                IAtom sourceAtom = graph1.getAtom(sourceAtomIndex);
                IAtom targetAtom = graph2.getAtom(targetAtomIndex);
                CDKRMap rMapAtom = new CDKRMap(sourceAtom, targetAtom);
                rMapListAtomsTemp.add(rMapAtom);
            }
            rMapListAtoms.add(rMapListAtomsTemp);
        }
        return rMapListAtoms;
    }","private static List<List<CDKRMap>> makeAtomsMapOfBondsMap(List<CDKRMap> rMapList, IAtomContainer graph1, IAtomContainer graph2){
        List<List<CDKRMap>> atomsMapList = new ArrayList<List<CDKRMap>>();
        for (CDKRMap rMap : rMapList) {
            List<CDKRMap> atomsMap = new ArrayList<CDKRMap>();
            for (int i = 0; i < rMap.getSize(); i++) {
                int sourceAtom = rMap.getSourceAtom(i);
                int targetAtom = rMap.getTargetAtom(i);
                atomsMap.add(new CDKRMap(sourceAtom, targetAtom));
            }
            atomsMapList.add(atomsMap);
        }
        return atomsMapList;
    }","private static List<List<CDKRMap>> makeAtomsMapOfBondsMap(List<CDKRMap> rMapList, IAtomContainer graph1, IAtomContainer graph2){
        List<List<CDKRMap>> atomsMapOfBondsMap = new ArrayList<List<CDKRMap>>();
        for (CDKRMap rMap : rMapList) {
            List<CDKRMap> atomsMapOfBonds = new ArrayList<CDKRMap>();
            for (int i = 0; i < rMap.getSize(); i++) {
                int sourceAtom = rMap.getSourceAtom(i);
                int targetAtom = rMap.getTargetAtom(i);
                int sourceBond = rMap.getSourceBond(i);
                int targetBond = rMap.getTargetBond(i);
                CDKRMap atomMap = new CDKRMap(graph1.getAtomCount(), graph2.getAtomCount());
                atomMap.put(sourceAtom, targetAtom);
                atomMap.put(sourceBond, targetBond);
                atomsMapOfBonds.add(atomMap);
            }
            atomsMapOfBondsMap.add(atomsMapOfBonds);
        }
        return atomsMapOfBondsMap;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2062134751777873,  0.2062134751777873,  0.22277069354772888,  0.1811915147016025,439.0,0.7924187725631769,439.0,0.7924187725631769,422.0,0.7617328519855595,455.0,0.8212996389891697,3.0,0.01910828025477707,49.0,0.2677595628415301,37.0,0.2356687898089172,7.0,0.3333333333333333,4.0,0.18181818181818182,2.0,0.09523809523809523
718,weblogic-kubernetes-operator,"public Watchable<V1Service> createServiceWatch(String namespace) throws ApiException{
    return FACTORY.createWatch(callParams, V1Service.class, new ListNamespacedServiceCall(namespace));
}",createServiceWatch,oracle/kubernetes/operator/builders/WatchBuilder.java,/operator/src/main/java/oracle/kubernetes/operator/builders/WatchBuilder.java,"/**
   * Creates a web hook object to track service calls.
   *
   * @param namespace the namespace
   * @return the active web hook
   * @throws ApiException if there is an error on the call that sets up the web hook.
   */",47-56,"('createServiceWatch', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,10.0,Creates a web hook object to track service calls.,This method build a web hook object to track service the calls,A web hook object is created to track service calls.,0.417658018832292,Creates a Web hook object to track service calls.,"public Watchable<V1Service> createServiceWatch(String namespace) throws ApiException{
    return FACTORY.createServiceWatch(namespace, callParams);   
 }","public Watchable<V1Service> createServiceWatch(String namespace) throws ApiException{
    return FACTORY.createServiceWatch(namespace, callParams);   
 }","public Watchable<V1Service> createServiceWatch(String namespace) throws ApiException{
    return FACTORY.createServiceWatch(namespace, callParams);   
 }","public Watchable<V1Service> createServiceWatch(String namespace) throws ApiException{
    return FACTORY.createServiceWatch(namespace, callParams);   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.645373232221043,  0.645373232221043,  0.645373232221043,  0.645373232221043,11.0,0.3333333333333333,11.0,0.3333333333333333,11.0,0.3333333333333333,11.0,0.3333333333333333,0.0,0.0,0.0,0.0,0.0,0.0,5.0,0.38461538461538464,1.0,0.1,4.0,0.36363636363636365
719,cdk,"public int numberOfElements(){
    int n = 0;
    for (SortedSet<Integer> cell : cells) {
        n += cell.size();
    }
    return n;
}",numberOfElements,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,"/**
     * Calculate the size of the partition as the sum of the sizes of the cells.
     *
     * @return the number of elements in the partition
     */",128-139,"('numberOfElements', {'INSTRUCTION': {'covered': 21, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,16.0,Calculate the size of the partition as the sum of the sizes of the cells.,Calculate the sum of the sizes of the partition in cells,The partition's size should be calculated as the sum of the cells' sizes.,0.217072358679807,Calculate the partition size as the sum of the cell sizes.,"public int numberOfElements(){
        int sum = 0;
        for (SortedSet<Integer> cell : cells) {
            sum += cell.size();
        }
        return sum;
    }","public int numberOfElements(){
        int sum = 0;
        for (SortedSet<Integer> cell : cells) {
            sum += cell.size();
        }
        return sum;
    }","public int numberOfElements(){
        int sum = 0;
        for (SortedSet<Integer> cell : cells) {
            sum += cell.size();
        }
        return sum;
    }","public int numberOfElements(){
        int sum = 0;
        for (SortedSet<Integer> cell : cells) {
            sum += cell.size();
        }
        return sum;
    }",PASS,PASS,PASS,PASS,  0.8887546294711398,  0.8887546294711398,  0.8887546294711398,  0.8887546294711398,3.0,0.08333333333333333,3.0,0.08333333333333333,3.0,0.08333333333333333,3.0,0.08333333333333333,0.0,0.0,0.0,0.0,0.0,0.0,9.0,0.5625,8.0,0.5,9.0,0.5625
720,dcache,"public static StringBuilder appendDuration(StringBuilder sb, Duration duration, TimeUnitFormat unitFormat){
    return appendDuration(sb, duration.toMillis(), MILLISECONDS, unitFormat);
}",appendDuration,org/dcache/util/TimeUtils.java,/modules/common/src/main/java/org/dcache/util/TimeUtils.java,"/**
     * Provide a short, simple human understandable string describing the supplied duration.  The
     * duration is a non-negative value.  The output is appended to the supplied StringBuilder and
     * has the form {@code <number> <space> <units>}, where {@code <number>} is an integer and
     * {@code <units>} is defined by the value of unitFormat.
     */",369-383,"('appendDuration', {'INSTRUCTION': {'covered': 31, 'missed': 2}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,13.0,"Provide a short, simple human understandable string describing the supplied duration.",Return a compact human understandable string describing the supplied duration,A short human understandable string describing the duration is what you should provide.,0.146690811795572,Provide a short and simple string that can be understood by man describing the duration provided.," public static StringBuilder appendDuration(StringBuilder sb, Duration duration, TimeUnitFormat unitFormat){
        return appendDuration(sb, duration.toNanos(), TimeUnit.NANOSECONDS, unitFormat);
    }"," public static StringBuilder appendDuration(StringBuilder sb, Duration duration, TimeUnitFormat unitFormat){
        return appendDuration(sb, duration.toNanos(), TimeUnit.NANOSECONDS, unitFormat);
    }"," public static StringBuilder appendDuration(StringBuilder sb, Duration duration, TimeUnitFormat unitFormat){
        return appendDuration(sb, duration.toNanos(), TimeUnit.NANOSECONDS, unitFormat);
    }",Empty Method,NOT PASS,NOT PASS,Empty Method,NOT PASS,  0.8194874121113389,  0.8194874121113389,None,  0.8194874121113389,4.0,0.11428571428571428,4.0,0.11428571428571428,None,None,4.0,0.11428571428571428,0.0,0.0,None,None,0.0,0.0,4.0,0.3333333333333333,11.0,0.6470588235294118,10.0,0.7142857142857143
721,jackson-databind,"private static int indexOfNonDigit(String string, int offset){
    for (int i = offset; i < string.length(); i++) {
        char c = string.charAt(i);
        if (c < '0' || c > '9')
            return i;
    }
    return string.length();
}",indexOfNonDigit,com/fasterxml/jackson/databind/util/ISO8601Utils.java,/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java,"/**
     * Returns the index of the first character in the string that is not a digit, starting at offset.
     */",311-320,"('indexOfNonDigit', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",63.0,20.0,"Returns the index of the first character in the string that is not a digit, starting at offset.","Get the index of the first character in the string that is not a digit, starting at the given offset",The first character in the string is not a digit.,0.432245904045886,"Returns the index of the first character in the string that is not a number, starting with offset."," private static int indexOfNonDigit(String string, int offset){
        int length = string.length();
        while (offset < length) {
            if (!Character.isDigit(string.charAt(offset))) {
                return offset;
            }
            offset++;
        }
        return offset;
    }"," private static int indexOfNonDigit(String string, int offset){
        int length = string.length();
        for (int i = offset; i < length; i++) {
            if (!Character.isDigit(string.charAt(i))) {
                return i;
            }
        }
        return length;
    }"," private static int indexOfNonDigit(String string, int offset){
        for (int i = offset; i < string.length(); i++) {
            if (!Character.isDigit(string.charAt(i))) {
                return i;
            }
        }
        return string.length();
    }"," private static int indexOfNonDigit(String string, int offset){
        int length = string.length();
        while (offset < length) {
            if (!Character.isDigit(string.charAt(offset))) {
                return offset;
            }
            offset++;
        }
        return offset;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.45874345369957426,  0.6053511267083497,  0.45874345369957426,  0.7526444147763541,36.0,0.5625,35.0,0.546875,36.0,0.5625,18.0,0.28125,15.0,0.24193548387096775,0.0,0.0,21.0,0.3442622950819672,4.0,0.19047619047619047,2.0,0.10526315789473684,10.0,0.5263157894736842
722,cdk,"public boolean isConnectedTo(IBond bond){
    for (IAtom atom : atoms) {
        if (bond.contains(atom))
            return true;
    }
    return false;
}",isConnectedTo,org/openscience/cdk/silent/Bond.java,/base/silent/src/main/java/org/openscience/cdk/silent/Bond.java,"/**
     * Checks whether a bond is connected to another one.
     * This can only be true if the bonds have an Atom in common.
     *
     * @param bond The bond which is checked to be connect with this one
     * @return true if the bonds share an atom, otherwise false
     */",506-519,"('isConnectedTo', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,10.0,Checks whether a bond is connected to another one.,Checks if a bond is connected to another one,Does it check if a bond is connected to another one.,0.641120125504382,Checks whether one link is connected to another.," public boolean isConnectedTo(IBond bond){
        for (IAtom atom : atoms) {
            if (bond.contains(atom)) return true;
        }
        return false;
    }"," public boolean isConnectedTo(IBond bond){
        for (IAtom atom : atoms) {
            if (bond.contains(atom)) return true;
        }
        return false;
    }"," public boolean isConnectedTo(IBond bond){
        for (IAtom atom : atoms) {
            if (bond.contains(atom)) return true;
        }
        return false;
    }"," public boolean isConnectedTo(IBond bond){
        for (IAtom atom : atoms) {
            for (IAtom connectedAtom : bond.atoms) {
                if (atom.equals(connectedAtom)) {
                    return true;
                }
            }
        }
        return false;
    }",PASS,PASS,NOT PASS,PASS,  1.0,  1.0,  0.7466879278017294,  1.0,0.0,0.0,0.0,0.0,15.0,0.3191489361702128,0.0,0.0,0.0,0.0,15.0,0.3191489361702128,0.0,0.0,2.0,0.2,4.0,0.4,4.0,0.3333333333333333
723,matsim-libs,"private double findMinimalAdditionalDistance(JobInsertionContext context, TourActivity newInvestigatedPickup, TourActivity nextAct){
    double minimalAdditionalDistance = 0;
    if (context.getAssociatedActivities().get(1) instanceof DeliverShipment) {
        TourActivity assignedDelivery = context.getAssociatedActivities().get(1);
        minimalAdditionalDistance = 0;
        int indexNextActicity = nextAct.getIndex();
        int tourPositionOfAcitivityBehindNewPickup = 0;
        int countIndex = 0;
        Vehicle newVehicle = context.getNewVehicle();
        VehicleRoute route = context.getRoute();
        a: for (TourActivity tourActivity : route.getTourActivities().getActivities()) {
            if (tourActivity.getIndex() == indexNextActicity) {
                while (countIndex < route.getTourActivities().getActivities().size()) {
                    if (route.getTourActivities().getActivities().get(countIndex).getIndex() == indexNextActicity) {
                        tourPositionOfAcitivityBehindNewPickup = countIndex;
                        break a;
                    }
                    countIndex++;
                }
            }
        }
        while ((tourPositionOfAcitivityBehindNewPickup + 1) < route.getTourActivities().getActivities().size()) {
            TourActivity activityBefore = route.getTourActivities().getActivities().get(tourPositionOfAcitivityBehindNewPickup);
            TourActivity activityAfter = route.getTourActivities().getActivities().get(tourPositionOfAcitivityBehindNewPickup + 1);
            double possibleAdditionalDistance = getDistance(activityBefore, assignedDelivery, newVehicle) + getDistance(assignedDelivery, activityAfter, newVehicle) - getDistance(activityBefore, activityAfter, newVehicle);
            minimalAdditionalDistance = findMinimalDistance(minimalAdditionalDistance, possibleAdditionalDistance);
            tourPositionOfAcitivityBehindNewPickup++;
        }
        if (route.getTourActivities().getActivities().size() > 0) {
            TourActivity activityLastDelivery = route.getTourActivities().getActivities().get(route.getTourActivities().getActivities().size() - 1);
            TourActivity activityEnd = route.getEnd();
            double possibleAdditionalDistance = getDistance(activityLastDelivery, assignedDelivery, newVehicle) + getDistance(assignedDelivery, activityEnd, newVehicle) - getDistance(activityLastDelivery, activityEnd, newVehicle);
            minimalAdditionalDistance = findMinimalDistance(minimalAdditionalDistance, possibleAdditionalDistance);
            TourActivity activityAfter = route.getTourActivities().getActivities().get(tourPositionOfAcitivityBehindNewPickup);
            possibleAdditionalDistance = getDistance(newInvestigatedPickup, assignedDelivery, newVehicle) + getDistance(assignedDelivery, activityAfter, newVehicle) - getDistance(newInvestigatedPickup, activityAfter, newVehicle);
            minimalAdditionalDistance = findMinimalDistance(minimalAdditionalDistance, possibleAdditionalDistance);
        }
    }
    return minimalAdditionalDistance;
}",findMinimalAdditionalDistance,org/matsim/contrib/freight/jsprit/DistanceConstraint.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/jsprit/DistanceConstraint.java,"/**
         * Finds a minimal additional distance for the tour, when a pickup is added to
         * the plan. The AssociatedActivities contains both activities of a job which
         * should be added to the existing tour. The TourActivities which are already in
         * the tour are found in context.getRoute().getTourActivities. In this method
         * the position of the new pickup is fixed and three options of the location of
         * the delivery activity will be checked: delivery between every other activity
         * after the pickup, delivery as the last activity before the end and delivery
         * directly behind the new pickup. This method gives back the minimal distance
         * of this three options.
         *
         * @param context
         * @param newInvestigatedPickup
         * @param nextAct
         * @return minimal distance of the associated delivery
         */",208-285,"('findMinimalAdditionalDistance', {'INSTRUCTION': {'covered': 170, 'missed': 20}, 'BRANCH': {'covered': 8, 'missed': 6}, 'LINE': {'covered': 38, 'missed': 5}, 'COMPLEXITY': {'covered': 4, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",441.0,18.0,"Finds a minimal additional distance for the tour, when a pickup is added to  the plan.","This method calculates the minimal additional distance for the tour, when a pickup is added to the plan","When a pickup is added to the plan, it adds a little more distance for the tour.",0.178772382734351,"Find a minimum additional distance for the tour, when pickup is added to the plan.",Not Valid,"private double findMinimalAdditionalDistance(JobInsertionContext context, TourActivity newInvestigatedPickup, TourActivity nextAct){
	 double minAdditionalDistance = 0;
	 double additionalDistance = 0;
	 double additionalDistance2 = 0;
	 double additionalDistance3 = 0;
	 double additionalDistance4 = 0;
	 double additionalDistance5 = 0;
	 double additionalDistance6 = 0;
	 double additionalDistance7 = 0;
	 double additionalDistance8 = 0;
	 double additionalDistance9 = 0;
	 double additionalDistance10 = 0;
	 double additionalDistance11 = 0;
	 double additionalDistance12 = 0;
	 double additionalDistance13 = 0;
	 double additionalDistance14 = 0;
	 double additionalDistance15 = 0;
	 double additionalDistance16 = 0;
	 double additionalDistance17 = 0;
	 double additionalDistance18 = 0;
	 double additionalDistance19 = 0;
	 double additionalDistance20 = 0;
	 double additionalDistance21 = 0;
	 double additionalDistance22 = 0;
	 double additionalDistance23 = 0;
	 double additionalDistance24 = 0;
	 double additionalDistance25 = 0;
	 double additionalDistance26 = 0;
	 double additionalDistance27 = 0;
	 double additionalDistance28 = 0;
	 double additionalDistance29 = 0;
	 double additionalDistance30 = 0;
	 double additionalDistance31 = 0;
	 double additionalDistance32 = 0;
	 double additionalDistance33 = 0;
	 double additionalDistance34 = 0;
	 double additionalDistance35 = 0;
	 double additionalDistance36 = 0;
	 double additionalDistance37 = 0;
	 double additionalDistance38 = 0;
	 double additionalDistance39 = 0;
	 double additionalDistance40 = 0;
	 double additionalDistance41 = 0;
	 double additionalDistance42 = 0;
	 double additionalDistance43 = 0;
	 double additionalDistance44 = 0;
	 double additionalDistance45 = 0;
	 double additionalDistance46 = 0;
	 double additionalDistance47 = 0;
	 double additionalDistance48 = 0;
	 double additionalDistance49 = 0;
	 double additionalDistance50 = 0;
	 double additionalDistance51 = 0;
	 double additionalDistance52 = 0;
	 double additionalDistance53 = 0;
	 double additionalDistance54 = 0;
	 double additionalDistance55			
 }","private double findMinimalAdditionalDistance(JobInsertionContext context, TourActivity newInvestigatedPickup, TourActivity nextAct){
	 double additionalDistance = 0;
	 if(context.getRoute().getTourActivities().getActivities().isEmpty()){
		 additionalDistance = getDistance(context.getRoute().getStart(), newInvestigatedPickup, context.getNewVehicle());
		 additionalDistance = additionalDistance + getDistance(newInvestigatedPickup, nextAct, context.getNewVehicle());
	 }else{
		 additionalDistance = getDistance(context.getRoute().getTourActivities().getActivities().get(0), newInvestigatedPickup, context.getNewVehicle());
		 additionalDistance = additionalDistance + getDistance(newInvestigatedPickup, nextAct, context.getNewVehicle());
	 }
	 return additionalDistance;
 }","private double findMinimalAdditionalDistance(JobInsertionContext context, TourActivity newInvestigatedPickup, TourActivity nextAct){
	 double minAdditionalDistance = Double.MAX_VALUE;
	 double additionalDistance = 0;
	 for (TourActivity act : context.getRoute().getTourActivities().getActivities()) {
		 if (act.getLocation() != null && act.getLocation().getCoord() != null) {
			 additionalDistance = getDistance(act, newInvestigatedPickup, context.getNewVehicle());
			 if (additionalDistance < minAdditionalDistance) {
				 minAdditionalDistance = additionalDistance;
			 }
		 }
	 }
	 additionalDistance = getDistance(nextAct, newInvestigatedPickup, context.getNewVehicle());
	 if (additionalDistance < minAdditionalDistance) {
		 minAdditionalDistance = additionalDistance;
	 }
	 return minAdditionalDistance;
 }",Not Valid,Syntax Error,NOT PASS,NOT PASS,None,None,  0.17859492659742743,  0.19382287624738162,None,None,None,None,357.0,0.8076923076923077,341.0,0.7714932126696833,None,None,129.0,0.9923076923076923,137.0,0.9927536231884058,5.0,0.2631578947368421,3.0,0.17647058823529413,13.0,0.7222222222222222
724,anserini,"public static String documentRaw(IndexReader reader, String docid){
    try {
        return reader.document(convertDocidToLuceneDocid(reader, docid)).get(IndexArgs.RAW);
    } catch (Exception e) {
        return null;
    }
}",documentRaw,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,"/**
   * Returns the ""raw"" field of a document based on a collection docid. The method is named to be consistent with
   * Lucene's {@link IndexReader#document(int)}, contra Java's standard method naming conventions.
   *
   * @param reader index reader
   * @param docid collection docid
   * @return the ""raw"" field the document
   */",538-553,"('documentRaw', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,15.0,"Returns the ""raw"" field of a document based on a collection docid.",Returns the raw document based on a collection docid.,"The document's ""raw"" field is returned.",0.707419521079904,"Returns the ""raw"" field of a document based on a collection docid."," public static String documentRaw(IndexReader reader, String docid){
    try {
      return reader.document(IndexReaderUtils.convertDocidToLuceneDocid(reader, docid)).get(IndexArgs.RAW);
    } catch (Exception e) {
      // Eat any exceptions and just return null.
      return null;
    }
  }"," public static String documentRaw(IndexReader reader, String docid){
    try {
      return reader.document(IndexReaderUtils.convertDocidToLuceneDocid(reader, docid)).get(""raw"");
    } catch (Exception e) {
      // Eat any exceptions and just return null.
      return null;
    }
  }"," public static String documentRaw(IndexReader reader, String docid){
    try {
      return reader.document(IndexReaderUtils.convertDocidToLuceneDocid(reader, docid)).get(""raw"");
    } catch (Exception e) {
      // Eat any exceptions and just return null.
      return null;
    }
  }"," public static String documentRaw(IndexReader reader, String docid){
    try {
      return reader.document(IndexReaderUtils.convertDocidToLuceneDocid(reader, docid)).get(IndexArgs.RAW);
    } catch (Exception e) {
      // Eat any exceptions and just return null.
      return null;
    }
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8785086036630272,  0.8198126261867807,  0.8785086036630272,  0.8198126261867807,2.0,0.04081632653061224,5.0,0.10638297872340426,2.0,0.04081632653061224,5.0,0.10638297872340426,3.0,0.061224489795918366,0.0,0.0,3.0,0.061224489795918366,4.0,0.3076923076923077,0.0,0.0,10.0,0.7692307692307693
725,liquibase,"public static CheckSum parse(String checksumValue){
    if (checksumValue == null) {
        return null;
    }
    // The general layout of a checksum is:
    // <1 digit: algorithm version number>:<1..n characters alphanumeric checksum>
    // Example: 7:2cdf9876e74347162401315d34b83746
    Matcher matcher = CHECKSUM_PATTERN.matcher(checksumValue);
    if (matcher.find()) {
        return new CheckSum(matcher.group(2), Integer.parseInt(matcher.group(1)));
    } else {
        // No version information found
        return new CheckSum(checksumValue, 1);
    }
}",parse,liquibase/change/CheckSum.java,/liquibase-core/src/main/java/liquibase/change/CheckSum.java,"/**
     * Parse the given storedCheckSum string value and return a new CheckSum object.
     */",41-58,"('parse', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,13.0,Parse the given storedCheckSum string value and return a new CheckSum object.,Process the given storedCheckSum string and return a new CheckSum object,Parse the string value and then return a new object.,0.309061826184427,Parse the given storedCheckSum string value and return a new CheckSum object.,"public static CheckSum parse(String checksumValue){
        if (checksumValue == null) {
            return null;
        }
    
        Matcher matcher = CHECKSUM_PATTERN.matcher(checksumValue);
        if (!matcher.matches()) {
            throw new IllegalArgumentException(""Invalid storedCheckSum value: "" + checksumValue);
        }
    
        int version = Integer.parseInt(matcher.group(1));
        String checksum = matcher.group(2);
    
        return new CheckSum(checksum, version);     
 }","public static CheckSum parse(String checksumValue){
        if (checksumValue == null) {
            return null;
        }
    
        Matcher matcher = CHECKSUM_PATTERN.matcher(checksumValue);
        if (!matcher.matches()) {
            throw new IllegalArgumentException(""Invalid storedCheckSum: "" + checksumValue);
        }
    
        int version = Integer.parseInt(matcher.group(1));
        String checksum = matcher.group(2);
    
        return new CheckSum(checksum, version);     
 }","public static CheckSum parse(String checksumValue){
        if (checksumValue == null) {
            return null;
        }
        Matcher matcher = CHECKSUM_PATTERN.matcher(checksumValue);
        if (matcher.matches()) {
            return new CheckSum(matcher.group(2), Integer.parseInt(matcher.group(1)));
        } else {
            throw new IllegalArgumentException(""Invalid checksum format: "" + checksumValue);
        }       
 }","public static CheckSum parse(String checksumValue){
        if (checksumValue == null) {
            return null;
        }
        Matcher matcher = CHECKSUM_PATTERN.matcher(checksumValue);
        if (matcher.matches()) {
            int version = Integer.parseInt(matcher.group(1));
            String checksum = matcher.group(2);
            return new CheckSum(checksum, version);
        } else {
            throw new IllegalArgumentException(""Invalid storedCheckSum value: "" + checksumValue);
        }       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7242857063651612,  0.7260983136664818,  0.7561942550031023,  0.8722488603272591,27.0,0.313953488372093,27.0,0.313953488372093,27.0,0.3068181818181818,6.0,0.07692307692307693,1.0,0.011627906976744186,24.0,0.2727272727272727,29.0,0.3372093023255814,3.0,0.23076923076923078,0.0,0.0,4.0,0.3076923076923077
726,cdk,"public void write(IChemObject object) throws CDKException{
    customizeJob();
    try {
        if (object instanceof IChemFile) {
            writeChemFile((IChemFile) object);
            return;
        } else if (object instanceof IChemModel) {
            IChemFile file = object.getBuilder().newInstance(IChemFile.class);
            IChemSequence sequence = object.getBuilder().newInstance(IChemSequence.class);
            sequence.addChemModel((IChemModel) object);
            file.addChemSequence(sequence);
            writeChemFile((IChemFile) file);
            return;
        } else if (object instanceof IAtomContainer) {
            writeMolecule((IAtomContainer) object);
            return;
        }
    } catch (Exception ex) {
        logger.error(ex.getMessage());
        logger.debug(ex);
        throw new CDKException(""Exception while writing MDL file: "" + ex.getMessage(), ex);
    }
    throw new CDKException(""Only supported is writing of IChemFile, "" + ""IChemModel, and IAtomContainer objects."");
}",write,org/openscience/cdk/io/MDLV2000Writer.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Writer.java,"/**
     * Writes a {@link IChemObject} to the MDL molfile formated output.
     * It can only output ChemObjects of type {@link IChemFile},
     * {@link IChemObject} and {@link IAtomContainer}.
     *
     * @param object {@link IChemObject} to write
     * @see #accepts(Class)
     */",294-326,"('write', {'INSTRUCTION': {'covered': 65, 'missed': 11}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 16, 'missed': 4}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",172.0,14.0,Writes a {@link IChemObject} to the MDL molfile formated output.,This method writes a IChemObject to the molfile formated output,The MDL molfile formated output is written in a @link IChemObject.,1.29306577608778,Writes an {@link IChemObject} in the output in molfile MDL format.," public void write(IChemObject object) throws CDKException{
        if (object instanceof IChemFile) {
            writeChemFile((IChemFile) object);
        } else if (object instanceof IChemModel) {
            writeChemModel((IChemModel) object);
        } else if (object instanceof IAtomContainer) {
            writeMolecule((IAtomContainer) object);
        } else {
            throw new CDKException(""Only supported is writing of ChemFile, ChemModel and AtomContainer objects."");
        }
    }"," public void write(IChemObject object) throws CDKException{
        if (object instanceof IChemFile) {
            writeChemFile((IChemFile) object);
        } else if (object instanceof IChemModel) {
            writeChemModel((IChemModel) object);
        } else if (object instanceof IAtomContainer) {
            writeMolecule((IAtomContainer) object);
        } else {
            throw new CDKException(""Only supported is writing of ChemFile, ChemModel and AtomContainer objects."");
        }
    }"," public void write(IChemObject object) throws CDKException{
        if (object instanceof IChemFile) {
            writeChemFile((IChemFile) object);
        } else if (object instanceof IChemModel) {
            writeChemModel((IChemModel) object);
        } else if (object instanceof IAtomContainer) {
            writeMolecule((IAtomContainer) object);
        } else {
            throw new CDKException(""Only supported is writing of ChemFile, ChemModel and AtomContainer objects."");
        }
    }"," public void write(IChemObject object) throws CDKException{
        if (object instanceof IChemFile) {
            writeChemFile((IChemFile) object);
        } else if (object instanceof IChemModel) {
            writeChemModel((IChemModel) object);
        } else if (object instanceof IAtomContainer) {
            writeMolecule((IAtomContainer) object);
        } else {
            throw new CDKException(""Only supported is writing of ChemFile, ChemModel and AtomContainer objects."");
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2849517868303821,  0.2849517868303821,  0.2849517868303821,  0.2849517868303821,104.0,0.6011560693641619,104.0,0.6011560693641619,104.0,0.6011560693641619,104.0,0.6011560693641619,0.0,0.0,0.0,0.0,0.0,0.0,7.0,0.6363636363636364,6.0,0.5,11.0,0.9166666666666666
727,logstash-logback-encoder,"public final T acquire(){
    Holder<T> holder = this.threadLocal.get();
    if (holder.leased) {
        throw new IllegalStateException(""ThreadLocal value is already in use and not yet released."");
    }
    if (holder.value == null) {
        holder.value = Objects.requireNonNull(createInstance());
    }
    holder.leased = true;
    return holder.value;
}",acquire,net/logstash/logback/util/ThreadLocalHolder.java,/src/main/java/net/logstash/logback/util/ThreadLocalHolder.java,"/**
     * Get the value assigned to the current thread, creating a new one if none is assigned yet or the
     * previous has been disposed.
     * 
     * The value must be {@link #release()} to ensure proper life cycle before it can be {@link #acquire()}
     * again.
     * 
     * @return the value assigned to this thread
     * @throws IllegalStateException if the value is already in use and {@link #release()} was not yet invoked.
     */",87-110,"('acquire', {'INSTRUCTION': {'covered': 24, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",71.0,25.0,"Get the value assigned to the current thread, creating a new one if none is assigned yet or the  previous has been disposed.",Return the value assigned to the current thread by creating a new one if none is assigned yet or the previous has been disposed,"If no one assigns the current value yet or the previous has been removed, create a new one.",0.562010510055811,"Get the value assigned to the current thread, creating a new one if none is yet assigned or if the previous one has been deleted."," public final T acquire(){
        Holder<T> holder = threadLocal.get();
        if (holder == null) {
            throw new IllegalStateException(""ThreadLocalHolder is closed"");
        }
        return holder.acquire();        
 }"," public final T acquire(){
        Holder<T> holder = threadLocal.get();
        if(holder == null) {
            throw new IllegalStateException(""ThreadLocalHolder is closed"");
        }
        return holder.acquire();        
 }"," public final T acquire(){
        Holder<T> holder = threadLocal.get();
        if (holder == null) {
            throw new IllegalStateException(""ThreadLocalHolder is closed"");
        }
        T value = holder.get();
        if (value == null) {
            value = factory.get();
            holder.set(value);
        }
        return value;       
 }"," public final T acquire(){
        Holder<T> holder = threadLocal.get();
        if (holder == null) {
            throw new IllegalStateException(""ThreadLocalHolder is closed"");
        }
        return holder.acquire();        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3004489940959505,  0.3004489940959505,  0.3004489940959505,  0.4510278197142831,34.0,0.4722222222222222,34.0,0.4722222222222222,34.0,0.4722222222222222,29.0,0.4027777777777778,0.0,0.0,0.0,0.0,30.0,0.4225352112676056,4.0,0.16,5.0,0.19230769230769232,19.0,0.7916666666666666
728,tablesaw,"private void crossProduct(Table destination, Table table1, Table table2, Selection table1Rows, Selection table2Rows, Set<Integer> ignoreColumns, boolean keepTable2JoinKeyColumns){
    for (int c = 0; c < table1.columnCount() + table2.columnCount(); c++) {
        if (!keepTable2JoinKeyColumns && ignoreColumns.contains(c)) {
            continue;
        }
        int table2Index = c - table1.columnCount();
        for (int r1 : table1Rows) {
            for (int r2 : table2Rows) {
                if (c < table1.columnCount()) {
                    Column t1Col = table1.column(c);
                    destination.column(c).append(t1Col, r1);
                } else {
                    Column t2Col = table2.column(table2Index);
                    destination.column(c).append(t2Col, r2);
                }
            }
        }
    }
}",crossProduct,tech/tablesaw/joining/DataFrameJoiner.java,/core/src/main/java/tech/tablesaw/joining/DataFrameJoiner.java,"/**
   * Creates cross product for the selection of two tables.
   *
   * @param destination the destination table.
   * @param table1 the table on left of join.
   * @param table2 the table on right of join.
   * @param table1Rows the selection of rows in table1.
   * @param table2Rows the selection of rows in table2.
   * @param ignoreColumns a set of column indexes in the result to ignore. They are redundant join
   *     columns.
   */",836-873,"('crossProduct', {'INSTRUCTION': {'covered': 76, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",164.0,10.0,Creates cross product for the selection of two tables.,This method builds a cross product for the selection of two tables,Cross product is created for the two tables.,0.459693205897626,Creates a crossover product for selecting two tables.,"private void crossProduct(Table destination, Table table1, Table table2, Selection table1Rows, Selection table2Rows, Set<Integer> ignoreColumns, boolean keepTable2JoinKeyColumns){
    // Create cross product of table1 and table2
    for (int r1 = 0; r1 < table1Rows.size(); r1++) {
      for (int r2 = 0; r2 < table2Rows.size(); r2++) {
        Row row = new Row();
        for (int c = 0; c < table1.columnCount(); c++) {
          if (!ignoreColumns.contains(c)) {
            row.add(table1.get(r1, c));
          }
        }
        for (int c = 0; c < table2.columnCount(); c++) {
          if (!ignoreColumns.contains(c + table1.columnCount())) {
            row.add(table2.get(r2, c));
          }
        }
        destination.add(row);
      }
    }   
 }",Empty Method,"private void crossProduct(Table destination, Table table1, Table table2, Selection table1Rows, Selection table2Rows, Set<Integer> ignoreColumns, boolean keepTable2JoinKeyColumns){
    for (int r = 0; r < table1Rows.size(); r++) {
      for (int c = 0; c < table2Rows.size(); c++) {
        Row row = new Row();
        for (int i = 0; i < table1.columnCount(); i++) {
          if (!ignoreColumns.contains(i)) {
            row.add(table1Rows.get(r).get(i));
          }
        }
        for (int i = 0; i < table2.columnCount(); i++) {
          if (!ignoreColumns.contains(i + table1.columnCount())) {
            row.add(table2Rows.get(c).get(i));
          }
        }
        destination.add(row);
      }
    }   
 }","private void crossProduct(Table destination, Table table1, Table table2, Selection table1Rows, Selection table2Rows, Set<Integer> ignoreColumns, boolean keepTable2JoinKeyColumns){
    // Create a crossover product for selecting two tables.
    // For inner join, left join and full outer join mark the join columns in table2 as
    // placeholders.
    // For right join mark the join columns in table1 as placeholders.
    // Keep track of which join columns are placeholders so they can be ignored.
    for (int c = 0; c < table1.columnCount(); c++) {
      if (ignoreColumns.contains(c)) {
        continue;
      }
      Column<?> col = table1.column(c);
      if (keepTable2JoinKeyColumns) {
        col = col.emptyCopy();
      }
      destination.addColumn(col);
    }
    for (int c = 0; c < table2.columnCount(); c++) {
      if (ignoreColumns.contains(c + table1.columnCount())) {
        continue;
      }
      Column<?> col = table2.column(c);
      if (keepTable2JoinKeyColumns) {
        col = col.emptyCopy();
      }
      destination.addColumn(col);
    }
    for (int r = 0; r < table1Rows.size(); r++) {
      destination.addRow(table1Rows.get(r));
    }
    for (int r = 0; r < table2Rows.size(); r++) {
      destination.addRow(table2Rows.get(r));
    }   
 }",NOT PASS,Empty Method,NOT PASS,NOT PASS,  0.5617128274359096,None,  0.61032857983054,  0.5211238577964248,104.0,0.5652173913043478,None,None,133.0,0.5659574468085107,112.0,0.5894736842105263,None,None,121.0,0.5148936170212766,28.0,0.14736842105263157,5.0,0.38461538461538464,5.0,0.5,6.0,0.6
729,jackson-databind,"public static String classNameOf(Object inst){
    if (inst == null) {
        return ""[null]"";
    }
    Class<?> raw = (inst instanceof Class<?>) ? (Class<?>) inst : inst.getClass();
    return nameOf(raw);
}",classNameOf,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * Helper method used to construct appropriate description
     * when passed either type (Class) or an instance; in latter
     * case, class of instance is to be used.
     *
     * @since 2.9
     */",703-716,"('classNameOf', {'INSTRUCTION': {'covered': 14, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",56.0,30.0,"Helper method used to construct appropriate description  when passed either type (Class) or an instance; in latter  case, class of instance is to be used.",Get the class name of the given object,"The class is used in the latter case, as the class is the one used in the Helper method.",0.772924977519198,"A helper method used to construct an appropriate description when passed to the type (Class) or instance; in the latter case, the instance class must be used."," public static String classNameOf(Object inst){
        if (inst == null) {
            return ""null"";
        }
        return inst.getClass().getName();
    }"," public static String classNameOf(Object inst){
        if (inst == null) {
            return ""null"";
        }
        return inst.getClass().getName();       
 }"," public static String classNameOf(Object inst){
        if (inst == null) {
            return ""null"";
        }
        return inst.getClass().getName();
    }"," public static String classNameOf(Object inst){
        if (inst == null) {
            return ""null"";
        }
        return inst.getClass().getName();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3596066147289803,  0.3596066147289803,  0.3596066147289803,  0.3596066147289803,28.0,0.49122807017543857,28.0,0.49122807017543857,28.0,0.49122807017543857,28.0,0.49122807017543857,0.0,0.0,0.0,0.0,0.0,0.0,24.0,0.9230769230769231,11.0,0.39285714285714285,24.0,0.9230769230769231
730,sonar-cxx,"public static void load(NewRepository repository, String languageKey, Iterable<Class> ruleClasses){
    new AnnotationBasedRulesDefinition(repository, languageKey).addRuleClasses(true, ruleClasses);
}",load,org/sonar/cxx/squidbridge/annotations/AnnotationBasedRulesDefinition.java,/cxx-squid-bridge/src/main/java/org/sonar/cxx/squidbridge/annotations/AnnotationBasedRulesDefinition.java,"/**
   * Adds annotated rule classes to an instance of NewRepository. Fails if one the classes has no SQALE annotation.
   */",69-74,"('load', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,10.0,Adds annotated rule classes to an instance of NewRepository.,This method adds annotated rule classes to the input instance,Adds annotated rule classes to a NewRepository instance.,0.412436340611489,Adds annotated rule classes to an instance of NewRepository.," public static void load(NewRepository repository, String languageKey, Iterable<Class> ruleClasses){
    AnnotationBasedRulesDefinition rulesDefinition = new AnnotationBasedRulesDefinition(repository, languageKey);
    rulesDefinition.load(ruleClasses);    
 }"," public static void load(NewRepository repository, String languageKey, Iterable<Class> ruleClasses){
    AnnotationBasedRulesDefinition rulesDefinition = new AnnotationBasedRulesDefinition(repository, languageKey);
    for (Class ruleClass : ruleClasses) {
      rulesDefinition.addRule(ruleClass);
    }   
 }"," public static void load(NewRepository repository, String languageKey, Iterable<Class> ruleClasses){
    AnnotationBasedRulesDefinition rulesDefinition = new AnnotationBasedRulesDefinition(repository, languageKey);
    for (Class ruleClass : ruleClasses) {
      rulesDefinition.addRule(ruleClass);
    }   
 }"," public static void load(NewRepository repository, String languageKey, Iterable<Class> ruleClasses){
    AnnotationBasedRulesDefinition rulesDefinition = new AnnotationBasedRulesDefinition(repository, languageKey);
    rulesDefinition.load(ruleClasses);    
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7917116898181862,  0.7487174496611474,  0.7917116898181862,  0.7487174496611474,8.0,0.21052631578947367,16.0,0.3404255319148936,8.0,0.21052631578947367,16.0,0.3404255319148936,11.0,0.23404255319148937,0.0,0.0,11.0,0.23404255319148937,7.0,0.6363636363636364,0.0,0.0,4.0,0.4
731,matsim-libs,"public static void reportNetworkStatistics(Network network){
    LOG.info(""--- Network statistics: ------------------------------------------------------"");
    LOG.info(""   Network description: "" + network.getName());
    LOG.info(""       Number of nodes: "" + network.getNodes().size());
    LOG.info(""       Number of links: "" + network.getLinks().size());
    LOG.info(""------------------------------------------------------------------------------"");
}",reportNetworkStatistics,org/matsim/core/network/algorithms/intersectionSimplifier/IntersectionSimplifier.java,/matsim/src/main/java/org/matsim/core/network/algorithms/intersectionSimplifier/IntersectionSimplifier.java,"/**
	 * Provides basic statistics of a given {@link Network}.  
	 * @param network
	 */",221-231,"('reportNetworkStatistics', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",71.0,12.0,Provides basic statistics of a given {@link Network}.,Get the statistics of a given input Network,Provides basic statistics of a network.,0.2167337197545,Provides basic statistics for a given {@link Network}.," public static void reportNetworkStatistics(Network network){
	 LOG.info(""Network statistics:"");
	 LOG.info(""  Number of nodes: "" + network.getNodes().size());
	 LOG.info(""  Number of links: "" + network.getLinks().size());
	 LOG.info(""  Number of links with at least one missing node: "" + network.getLinks().values().stream().filter(l -> l.getFromNode() == null || l.getToNode() == null).count());
	 LOG.info(""  Number of links with at least one missing node: "" + network.getLinks().values().stream().filter(l -> l.getFromNode() == null || l.getToNode() == null).count());
	 LOG.info(""  Number of links with at least one missing node: "" + network.getLinks().values().stream().filter(l -> l.getFromNode() == null || l.getToNode() == null).count());
	 LOG.info(""  Number of links with at least one missing node: "" + network.getLinks().values().stream().filter(l -> l.getFromNode() == null || l.getToNode() == null).count());
	 LOG.info(""  Number of links with at least one missing node: "" + network.getLinks().values().stream().filter(l -> l.getFromNode() == null || l.getToNode() == null).count());
	 LOG.info(""  Number of links with at least one missing node: "" + network.getLinks().values().stream().filter(l -> l.getFromNode() == null || l.getToNode() == null).count());
	 LOG.info(""  Number of links with at least one missing node: "" + network.getLinks().values().stream().filter(l -> l.getFromNode() == null || l.getToNode() == null).count());
	 LOG.info(""  Number of links with at least one missing node: "" + network.getLinks().values().stream().filter(l -> l.getFromNode() == null || l.getToNode() == null).count());
	 LOG.info(""  Number of links with at least one missing node: "" + network.getLinks().values().stream().filter(l -> l			
 }","public static void reportNetworkStatistics(Network network){
		int numberOfNodes = network.getNodes().size();
		int numberOfLinks = network.getLinks().size();
		int numberOfLinksWithLength = 0;
		double totalLength = 0;
		for(Link link : network.getLinks().values()){
			if(link.getLength() > 0){
				numberOfLinksWithLength++;
				totalLength += link.getLength();
			}
		}
		double averageLength = totalLength / numberOfLinksWithLength;
		LOG.info(""Network has "" + numberOfNodes + "" nodes and "" + numberOfLinks + "" links."");
		LOG.info(""Network has "" + numberOfLinksWithLength + "" links with length > 0."");
		LOG.info(""Average link length is "" + averageLength + ""."");
	}","public static void reportNetworkStatistics(Network network){
	 int nrOfNodes = network.getNodes().size();
	 int nrOfLinks = network.getLinks().size();
	 int nrOfLinksWithLength = 0;
	 double totalLength = 0.0;
	 for(Link link : network.getLinks().values()){
		 if(link.getLength() > 0.0){
			 nrOfLinksWithLength++;
			 totalLength += link.getLength();
		 }
	 }
	 LOG.info(""Network has "" + nrOfNodes + "" nodes and "" + nrOfLinks + "" links."");
	 LOG.info(""Of these, "" + nrOfLinksWithLength + "" links have a length > 0."");
	 LOG.info(""The total length of all links with length > 0 is "" + totalLength + ""."");
 }",Not Valid,Syntax Error,NOT PASS,Not Valid,NOT PASS,None,  0.4306275930188017,None,  0.42645885352472684,None,None,86.0,0.6564885496183206,None,None,79.0,0.6370967741935484,370.0,0.8314606741573034,None,None,371.0,0.8337078651685393,4.0,0.4444444444444444,1.0,0.1111111111111111,3.0,0.3333333333333333
732,cdk,"private ILigand[] order(ILigand[] ligands){
    ILigand[] newLigands = new ILigand[ligands.length];
    System.arraycopy(ligands, 0, newLigands, 0, ligands.length);
    Arrays.sort(newLigands, numberRule);
    ILigand[] reverseLigands = new ILigand[newLigands.length];
    for (int i = 0; i < newLigands.length; i++) {
        reverseLigands[(newLigands.length - 1) - i] = newLigands[i];
    }
    return reverseLigands;
}",order,org/openscience/cdk/geometry/cip/rules/CIPLigandRule.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/rules/CIPLigandRule.java,"/**
     * Order the ligands from high to low precedence according to atomic and mass numbers.
     */",84-98,"('order', {'INSTRUCTION': {'covered': 40, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",104.0,15.0,Order the ligands from high to low precedence according to atomic and mass numbers.,Order the ligands in ascendent precedence according to atomic and mass numbers,The ligands should be ordered from high to low precedence.,0.195606414689206,Order high to low priority ligands based on atomic and mass numbers.," private ILigand[] order(ILigand[] ligands){
        Arrays.sort(ligands, new LigandComparator());
        return ligands;
    }","private ILigand[] order(ILigand[] ligands){
        int[] atomicNumbers = new int[ligands.length];
        int[] massNumbers = new int[ligands.length];
        for (int i = 0; i < ligands.length; i++) {
            atomicNumbers[i] = ligands[i].getAtomicNumber();
            massNumbers[i] = ligands[i].getMassNumber();
        }
        Arrays.sort(atomicNumbers);
        Arrays.sort(massNumbers);
        ILigand[] orderedLigands = new ILigand[ligands.length];
        for (int i = 0; i < ligands.length; i++) {
            for (int j = 0; j < ligands.length; j++) {
                if (atomicNumbers[i] == ligands[j].getAtomicNumber() && massNumbers[i] == ligands[j].getMassNumber()) {
                    orderedLigands[i] = ligands[j];
                    break;
                }
            }
        }
        return orderedLigands;
    }"," private ILigand[] order(ILigand[] ligands){
        Arrays.sort(ligands, new ILigand.LigandPrecedenceComparator());
        return ligands;
    }","private ILigand[] order(ILigand[] ligands){
        int[] atomicNumbers = new int[ligands.length];
        int[] massNumbers = new int[ligands.length];
        for (int i = 0; i < ligands.length; i++) {
            atomicNumbers[i] = ligands[i].getAtomicNumber();
            massNumbers[i] = ligands[i].getMassNumber();
        }
        Arrays.sort(atomicNumbers);
        Arrays.sort(massNumbers);
        for (int i = 0; i < ligands.length; i++) {
            for (int j = 0; j < ligands.length; j++) {
                if (atomicNumbers[i] == ligands[j].getAtomicNumber() &&
                        massNumbers[i] == ligands[j].getMassNumber()) {
                    ILigand temp = ligands[i];
                    ligands[i] = ligands[j];
                    ligands[j] = temp;
                }
            }
        }
        return ligands;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.15195396673221187,  0.47061006743891254,  0.4183524253726434,  0.1552852524055604,79.0,0.7523809523809524,119.0,0.6071428571428571,130.0,0.6632653061224489,77.0,0.7333333333333333,171.0,0.8724489795918368,170.0,0.8673469387755102,3.0,0.0967741935483871,5.0,0.3333333333333333,7.0,0.4666666666666667,12.0,0.8
733,metrics,"private ByteBuffer signPacket(ByteBuffer packet){
    final byte[] signature = sign(password, (ByteBuffer) ByteBuffer.allocate(packet.remaining() + username.length).put(username).put(packet).flip());
    return (ByteBuffer) ByteBuffer.allocate(BUFFER_SIZE).putShort((short) TYPE_SIGN_SHA256).putShort((short) (username.length + SIGNATURE_LEN)).put(signature).put(username).put((ByteBuffer) packet.flip()).flip();
}",signPacket,io/dropwizard/metrics5/collectd/PacketWriter.java,/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/PacketWriter.java,"/**
     * Signs the provided packet, so a CollectD server can verify that its authenticity.
     * Wire format:
     * <pre>
     * +-------------------------------+-------------------------------+
     * ! Type (0x0200)                 ! Length                        !
     * +-------------------------------+-------------------------------+
     * ! Signature (SHA2(username + packet))                           \
     * +-------------------------------+-------------------------------+
     * ! Username                      ! Packet                        \
     * +---------------------------------------------------------------+
     * </pre>
     *
     * @see <a href=""https://collectd.org/wiki/index.php/Binary_protocol#Signature_part"">
     * Binary protocol - CollectD | Signature part</a>
     */",140-168,"('signPacket', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",111.0,15.0,"Signs the provided packet, so a CollectD server can verify that its authenticity.",This method signs the provided packet to allow that a CollectD server can verify that its authenticity.,A server can verify the authenticity of the packet if it is signs.,0.571408820282323,Signs the package provided so that a CollectD server can verify its authenticity.," private ByteBuffer signPacket(ByteBuffer packet){
        try {
            final byte[] signature = sign(packet.array());
            final ByteBuffer signedPacket = ByteBuffer.allocate(packet.capacity() + signature.length);
            signedPacket.put(packet);
            signedPacket.put(signature);
            signedPacket.flip();
            return signedPacket;
        } catch (NoSuchAlgorithmException | InvalidKeyException e) {
            throw new RuntimeException(e);
        }       
 }"," private ByteBuffer signPacket(ByteBuffer packet){
        try {
            final byte[] signature = sign(packet.array(), password);
            final ByteBuffer signedPacket = ByteBuffer.allocate(packet.capacity() + SIGNATURE_LEN);
            signedPacket.put(packet);
            signedPacket.put(signature);
            signedPacket.flip();
            return signedPacket;
        } catch (NoSuchAlgorithmException | InvalidKeyException e) {
            throw new RuntimeException(e);
        }       
 }"," private ByteBuffer signPacket(ByteBuffer packet){
        final byte[] signature = sign(packet.array());
        final ByteBuffer signedPacket = ByteBuffer.allocate(packet.capacity() + SIGNATURE_LEN);
        signedPacket.put(packet);
        signedPacket.put(signature);
        signedPacket.flip();
        return signedPacket;        
 }"," private ByteBuffer signPacket(ByteBuffer packet){
        try {
            final byte[] signature = sign(packet.array());
            final ByteBuffer signedPacket = ByteBuffer.allocate(packet.capacity() + SIGNATURE_LEN);
            signedPacket.put(packet);
            signedPacket.put(signature);
            signedPacket.flip();
            return signedPacket;
        } catch (NoSuchAlgorithmException | InvalidKeyException | InvalidParameterSpecException e) {
            throw new IllegalStateException(""Failed to sign packet"", e);
        }       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4092844026686815,  0.3895655441835496,  0.38768988307890334,  0.3533376729412221,72.0,0.6428571428571429,74.0,0.6607142857142857,74.0,0.6607142857142857,67.0,0.5982142857142857,5.0,0.05813953488372093,8.0,0.09090909090909091,22.0,0.2558139534883721,7.0,0.3888888888888889,4.0,0.2857142857142857,13.0,0.9285714285714286
735,cdk,"public void addMolecule(IAtomContainer mol, boolean active) throws CDKException{
    if (mol == null || mol.getAtomCount() == 0)
        throw new CDKException(""Molecule cannot be blank or null."");
    CircularFingerprinter circ = new CircularFingerprinter(classType);
    circ.setPerceiveStereo(optPerceiveStereo);
    circ.calculate(mol);
    final int AND_BITS = folding - 1;
    Set<Integer> hashset = new TreeSet<Integer>();
    for (int n = circ.getFPCount() - 1; n >= 0; n--) {
        int code = circ.getFP(n).hashCode;
        if (folding > 0)
            code &= AND_BITS;
        hashset.add(code);
    }
    int[] hashes = new int[hashset.size()];
    int p = 0;
    for (Integer h : hashset) hashes[p++] = h;
    if (active)
        numActive++;
    training.add(hashes);
    activity.add(active);
    for (int h : hashes) {
        int[] stash = inHash.get(h);
        if (stash == null)
            stash = new int[] { 0, 0 };
        if (active)
            stash[0]++;
        stash[1]++;
        inHash.put(h, stash);
    }
}",addMolecule,org/openscience/cdk/fingerprint/model/Bayesian.java,/tool/model/src/main/java/org/openscience/cdk/fingerprint/model/Bayesian.java,"/**
     * Appends a new row to the model source data, which consists of a molecule and whether or not it
     * is considered active.
     * 
     * @param mol molecular structure, which must be non-blank
     * @param active whether active or not
     */",181-221,"('addMolecule', {'INSTRUCTION': {'covered': 155, 'missed': 5}, 'BRANCH': {'covered': 16, 'missed': 2}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",251.0,24.0,"Appends a new row to the model source data, which consists of a molecule and whether or not it  is considered active.",This method appends a new row to the model source data,The row that wasAppended is a molecule and whether or not it is considered active.,0.695066251826251,"Adds a new row to the model source data, which consists of a molecule and whether it is considered active or not.","public void addMolecule(IAtomContainer mol, boolean active) throws CDKException{
        if (mol == null)
            throw new IllegalArgumentException(""Null molecule"");
        if (mol.getAtomCount() == 0)
            throw new IllegalArgumentException(""Empty molecule"");
        if (mol.getBondCount() == 0)
            throw new IllegalArgumentException(""Empty molecule"");
    
        // get the hash code for the molecule
        int hash = getHash(mol);
    
        // add the hash code to the model
        if (inHash.containsKey(hash)) {
            int[] counts = inHash.get(hash);
            counts[0]++;
            counts[1]++;
        } else {
            inHash.put(hash, new int[] { 1, 1 });
        }
    
        // add the molecule to the training set
        training.add(new int[] { hash, classType });
        activity.add(active);
    
        // update the model statistics
        if (active) {
            numActive++;
            trainingActives++;
        }
        trainingSize++;     
 }","public void addMolecule(IAtomContainer mol, boolean active) throws CDKException{
        if (mol == null)
            throw new IllegalArgumentException(""Null molecule"");
        if (mol.getAtomCount() == 0)
            throw new IllegalArgumentException(""Empty molecule"");
    
        // get the fingerprint
        int[] hash = getFingerprint(mol);
    
        // add the hash to the model
        training.add(hash);
        activity.add(active);
    
        // update the model stats
        numActive += active ? 1 : 0;
        trainingSize++;
        trainingActives += active ? 1 : 0;      
 }","public void addMolecule(IAtomContainer mol, boolean active) throws CDKException{
        if (mol == null) throw new CDKException(""Null molecule"");
        if (mol.getAtomCount() == 0) throw new CDKException(""Empty molecule"");
    
        // get the fingerprint
        int[] hash = getFingerprint(mol);
    
        // add the molecule to the training set
        training.add(hash);
        activity.add(active);
    
        // update the counts
        numActive += active ? 1 : 0;
        trainingSize++;
        trainingActives += active ? 1 : 0;      
 }","public void addMolecule(IAtomContainer mol, boolean active) throws CDKException{
        if (mol == null) throw new CDKException(""Null molecule"");
        if (mol.getAtomCount() == 0) throw new CDKException(""Empty molecule"");
    
        // get the fingerprint
        int[] hash = getFingerprint(mol);
    
        // add the hash to the training set
        training.add(hash);
        activity.add(active);
    
        // update the active/total counts
        if (active) numActive++;
        trainingSize++;     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3258859570198324,  0.23011767318766316,  0.24067111969024466,  0.2471145466496031,173.0,0.6865079365079365,190.0,0.753968253968254,187.0,0.7420634920634921,189.0,0.75,95.0,0.5864197530864198,88.0,0.5432098765432098,97.0,0.5987654320987654,17.0,0.7391304347826086,6.0,0.2608695652173913,11.0,0.4782608695652174
736,cdk,"private void solution(BitSet traversed) throws CDKException{
    boolean included = false;
    BitSet projG1 = projectG1(traversed);
    BitSet projG2 = projectG2(traversed);
    if (isContainedIn(getSourceBitSet(), projG1) && isContainedIn(getTargetBitSet(), projG2)) {
        for (Iterator<BitSet> i = getSolutionList().listIterator(); i.hasNext() && !included; ) {
            BitSet sol = i.next();
            checkTimeOut();
            if (!sol.equals(traversed)) {
                if (isFindAllMap() && (projG1.equals(projectG1(sol)) || projG2.equals(projectG2(sol)))) {
                } else if (isContainedIn(projG1, projectG1(sol)) || isContainedIn(projG2, projectG2(sol))) {
                    included = true;
                } else if (isContainedIn(projectG1(sol), projG1) || isContainedIn(projectG2(sol), projG2)) {
                    i.remove();
                }
            } else {
                included = true;
            }
        }
        if (included == false) {
            getSolutionList().add(traversed);
        }
        if (!isFindAllStructure()) {
            setStop(true);
        }
    }
}",solution,org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,"/**
     * Checks if a potential solution is a real one
     * (not included in a previous solution)
     *  and add this solution to the solution list
     * in case of success.
     *
     * @param  traversed  new potential solution
     */",322-375,"('solution', {'INSTRUCTION': {'covered': 107, 'missed': 2}, 'BRANCH': {'covered': 27, 'missed': 1}, 'LINE': {'covered': 19, 'missed': 1}, 'COMPLEXITY': {'covered': 14, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",235.0,30.0,Checks if a potential solution is a real one  (not included in a previous solution)  and add this solution to the solution list  in case of success.,This method verifies if a potential solution is a real one and add it to the solution list,"If a potential solution is a real one, it should be added to the solution list in case of success.",0.17503093579343,Checks whether a potential solution is real (not included in a previous solution) and adds that solution to the list of solutions if successful.," private void solution(BitSet traversed) throws CDKException{
        // check if the solution is a real one
        if (isRealSolution(traversed)) {
            // add the solution to the list
            getSolutionList().add(traversed);
        }
    }"," private void solution(BitSet traversed) throws CDKException{
        // if the solution is not a duplicate
        if (!isDuplicate(traversed)) {
            // if the solution is not too long
            if (getSolutionList().size() < getMaxSolution()) {
                // if the solution is not too short
                if (getSolutionList().size() >= getMinSolution()) {
                    // add the solution to the list
                    getSolutionList().add(traversed);
                }
            }
        }
    }"," private void solution(BitSet traversed) throws CDKException{
        // if the solution is not a duplicate
        if (!isDuplicate(traversed)) {
            // add the solution to the list
            getSolutionList().add(traversed);
            // if we want to find all solutions
            if (isAllStructure()) {
                // add the solution to the list
                getSolutionList().add(traversed);
            }
        }
    }"," private void solution(BitSet traversed) throws CDKException{
        // check if the solution is real
        if (isReal(traversed)) {
            // add the solution to the list of solutions
            getSolutionList().add(traversed);
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.1324265215060364,  0.1754765999930961,  0.1324265215060364,  0.16566041941125134,207.0,0.8771186440677966,183.0,0.7754237288135594,207.0,0.8771186440677966,193.0,0.8177966101694916,34.0,0.5396825396825397,1.0,0.03333333333333333,19.0,0.3958333333333333,15.0,0.5357142857142857,10.0,0.35714285714285715,13.0,0.4642857142857143
737,matsim-libs,"public T selectPlan(final HasPlansAndId<T, I> person){
    // current plan and random plan:
    T currentPlan = person.getSelectedPlan();
    T otherPlan = new RandomPlanSelector<T, I>().selectPlan(person);
    if (currentPlan == null) {
        // this case should only happen when the agent has no plans at all
        return null;
    }
    if ((currentPlan.getScore() == null) || (otherPlan.getScore() == null)) {
        /* With the previous behavior, Double.NaN was returned if no score was available.
			 * This resulted in weight=NaN below as well, and then ultimately in returning
			 * the currentPlan---what we're doing right now as well.
			 */
        if (currentPlan.getScore() != null && otherPlan.getScore() == null) {
            if (scoreWrnFlag) {
                log.error(""yyyyyy not switching to other plan although it needs to be explored.  "" + ""Possibly a serious bug; ask kai if you encounter this.  kai, sep'10"");
                scoreWrnFlag = false;
            }
        }
        return currentPlan;
    }
    // defending against NaN (which should not happen, but happens):
    if (currentPlan.getScore().isNaN()) {
        return otherPlan;
    }
    if (otherPlan.getScore().isNaN()) {
        return currentPlan;
    }
    double currentScore = currentPlan.getScore().doubleValue();
    double otherScore = otherPlan.getScore().doubleValue();
    if (betaWrnFlag) {
        log.warn(""Would make sense to revise this once more.  See comments in code.  kai, nov08"");
        /**
         * Gunnar says, rightly I think, that what is below hits the ""0.01*weight > 1"" threshold fairly quickly.
         *   An alternative might be to divide by exp(0.5*beta*oS)+exp(0.5*beta*cS), or the max of these two numbers.  But:
         *   (1) someone would need to go through the theory to make sure that we remain within what we have said before
         *       (convergence to logit and proba of jump between equal options = 0.01
         *   (2) someone would need to test if the ""traffic"" results are similar
         */
        betaWrnFlag = false;
    }
    double weight = Math.exp(0.5 * this.beta * (otherScore - currentScore));
    // (so far, this is >1 if otherScore>currentScore, and <=1 otherwise)
    // (beta is the slope (strength) of the operation: large beta means strong reaction)
    if (MatsimRandom.getRandom().nextDouble() < 0.01 * weight) {
        // as of now, 0.01 is hardcoded (proba to change when both
        // scores are the same)
        return otherPlan;
    }
    return currentPlan;
}",selectPlan,org/matsim/core/replanning/selectors/ExpBetaPlanChanger.java,/matsim/src/main/java/org/matsim/core/replanning/selectors/ExpBetaPlanChanger.java,"/**
         * Changes to another plan with a probability proportional to exp( Delta scores ).
         * Need to think through if this goes to Nash Equilibrium or to SUE !!!
         */",44-104,"('selectPlan', {'INSTRUCTION': {'covered': 78, 'missed': 4}, 'BRANCH': {'covered': 16, 'missed': 4}, 'LINE': {'covered': 21, 'missed': 2}, 'COMPLEXITY': {'covered': 7, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",240.0,15.0,Changes to another plan with a probability proportional to exp( Delta scores ).,This method changes to another plan with a probability proportional to exp scores,Changes to another plan with a probability that is proportional to exp.,0.30970305887481,Changes to another plane with probability proportional to exp( Delta) scores.,"public T selectPlan(final HasPlansAndId<T, I> person){
   	if (person.getPlans().size() < 2) {
 		log.error(""ExpBetaPlanChanger.selectPlan: person "" + person.getId() + "" has less than 2 plans. Cannot change plans."");
 		return null;
 	}
 	T bestPlan = null;
 	double bestScore = Double.NEGATIVE_INFINITY;
 	for (T plan : person.getPlans()) {
 		if (plan.getScore() > bestScore) {
 			bestPlan = plan;
 			bestScore = plan.getScore();
 		}
 	}
 	if (bestPlan == null) {
 		log.error(""ExpBetaPlanChanger.selectPlan: person "" + person.getId() + "" has no best plan. Cannot change plans."");
 		return null;
 	}
 	double bestScoreDiff = Double.NEGATIVE_INFINITY;
 	T otherPlan = null;
 	for (T plan : person.getPlans()) {
 		if (plan != bestPlan) {
 			double scoreDiff = plan.getScore() - bestScore;
 			if (scoreDiff > bestScoreDiff) {
 				bestScoreDiff = scoreDiff;
 				otherPlan = plan;
 			}
 		}
 	}
 	if (otherPlan == null) {
 		log.error(""ExpBetaPlanChanger.selectPlan: person "" + person.getId() + "" has no other plan. Cannot change plans."");
 		return null;
 	}
 	double prob = Math.exp(beta * bestScoreDiff);
 	if (MatsimRandom.getRandom().nextDouble() < prob) {
 		return otherPlan;
 	} else {
 		return bestPlan;
 	}   
 }","public T selectPlan(final HasPlansAndId<T, I> person){
   	T selectedPlan = null;
 	double maxScore = Double.NEGATIVE_INFINITY;
 	double minScore = Double.POSITIVE_INFINITY;
 	double sumScore = 0.0;
 	double sumExpScore = 0.0;
 	double sumExpScore2 = 0.0;
 	double expScore;
 	double expScore2;
 	double prob;
 	double random = MatsimRandom.getRandom().nextDouble();
 	double sumProb = 0.0;
 	double sumProb2 = 0.0;
 	double prob2;
 	double random2 = MatsimRandom.getRandom().nextDouble();
 	double sumProb3 = 0.0;
 	double sumProb4 = 0.0;
 	double prob3;
 	double prob4;
 	double random3 = MatsimRandom.getRandom().nextDouble();
 	double random4 = MatsimRandom.getRandom().nextDouble();
 	double sumProb5 = 0.0;
 	double sumProb6 = 0.0;
 	double prob5;
 	double prob6;
 	double random5 = MatsimRandom.getRandom().nextDouble();
 	double random6 = MatsimRandom.getRandom().nextDouble();
 	double sumProb7 = 0.0;
 	double sumProb8 = 0.0;
 	double prob7;
 	double prob8;
 	double random7 = MatsimRandom.getRandom().nextDouble();
 	double random8 = MatsimRandom.getRandom().nextDouble();
 	double sumProb9 = 0.0;
 	double sumProb10 = 0.0;
 	double prob9;
 	double prob10;
 	double random9 = MatsimRandom.getRandom().nextDouble();
 	double random10 = MatsimRandom.getRandom().nextDouble();
 	double sumProb11 = 0.0;
 	double sumProb12 = 0.0;
 	double prob11;
 	double prob12   
 }","public T selectPlan(final HasPlansAndId<T, I> person){
   	if (person.getPlans().size() < 2) {
 		return null;
 	}
 	double maxScore = Double.NEGATIVE_INFINITY;
 	T bestPlan = null;
 	for (T plan : person.getPlans()) {
 		if (plan.getScore() > maxScore) {
 			maxScore = plan.getScore();
 			bestPlan = plan;
 		}
 	}
 	if (bestPlan == null) {
 		return null;
 	}
 	double minScore = Double.POSITIVE_INFINITY;
 	T worstPlan = null;
 	for (T plan : person.getPlans()) {
 		if (plan.getScore() < minScore) {
 			minScore = plan.getScore();
 			worstPlan = plan;
 		}
 	}
 	if (worstPlan == null) {
 		return null;
 	}
 	double scoreDiff = maxScore - minScore;
 	if (scoreDiff == 0) {
 		return null;
 	}
 	double prob = Math.exp(beta * (bestPlan.getScore() - worstPlan.getScore()));
 	if (prob < MatsimRandom.getRandom().nextDouble()) {
 		return null;
 	}
 	return worstPlan;
 }","public T selectPlan(final HasPlansAndId<T, I> person){
   	T selectedPlan = null;
 	double maxScore = Double.NEGATIVE_INFINITY;
 	double minScore = Double.POSITIVE_INFINITY;
 	double scoreDiff = 0.0;
 	double expScoreDiff = 0.0;
 	double random = MatsimRandom.getRandom().nextDouble();
 	for (T plan : person.getPlans()) {
 		if (plan.getScore() > maxScore) {
 			maxScore = plan.getScore();
 		}
 		if (plan.getScore() < minScore) {
 			minScore = plan.getScore();
 		}
 	}
 	scoreDiff = maxScore - minScore;
 	expScoreDiff = Math.exp(beta * scoreDiff);
 	if (expScoreDiff < random) {
 		selectedPlan = person.getPlans().get(0);
 	} else {
 		for (T plan : person.getPlans()) {
 			expScoreDiff = Math.exp(beta * (plan.getScore() - minScore));
 			if (expScoreDiff > random) {
 				selectedPlan = plan;
 				break;
 			}
 		}
 	}
 	if (selectedPlan == null) {
 		if (betaWrnFlag) {
 			log.warn(""No plan selected. beta = "" + beta + "" scoreDiff = "" + scoreDiff + "" expScoreDiff = "" + expScoreDiff + "" random = "" + random);
 			betaWrnFlag = false;
 		}
 	}
 	return selectedPlan;
 }",NOT PASS,Syntax Error,NOT PASS,NOT PASS,  0.39248783571120693,None,  0.36291658056865106,  0.39916456138805934,160.0,0.6451612903225806,None,None,178.0,0.7385892116182573,152.0,0.6307053941908713,None,None,166.0,0.6693548387096774,115.0,0.4637096774193548,6.0,0.42857142857142855,5.0,0.35714285714285715,6.0,0.42857142857142855
738,cdk,"public Point3d rescaleBondLength(IAtom atom1, IAtom atom2, Point3d point2){
    Point3d point1 = atom1.getPoint3d();
    Double d1 = atom1.getCovalentRadius();
    Double d2 = atom2.getCovalentRadius();
    double distance = (d1 == null || d2 == null) ? 1.0 : d1 + d2;
    if (pSet != null) {
        distance = getDistanceValue(atom1.getAtomTypeName(), atom2.getAtomTypeName());
    }
    Vector3d vect = new Vector3d(point2);
    vect.sub(point1);
    vect.normalize();
    vect.scale(distance);
    Point3d newPoint = new Point3d(point1);
    newPoint.add(vect);
    return newPoint;
}",rescaleBondLength,org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,"/**
     *  Rescales Point2 so that length 1-2 is sum of covalent radii.
     *  If covalent radii cannot be found, use bond length of 1.0
     *
     *@param  atom1          stationary atom
     *@param  atom2          movable atom
     *@param  point2         coordinates for atom 2
     *@return                new coordinates for atom 2
     */",123-148,"('rescaleBondLength', {'INSTRUCTION': {'covered': 54, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",134.0,12.0,Rescales Point2 so that length 1-2 is sum of covalent radii.,This method rescales the input Point2 so that length 1-2 is sum of covalent radii,Point2 is the sum of covalent radii.,0.975162576490632,Resizes point2 so that length 1-2 is the sum of the covalent rays.,"public Point3d rescaleBondLength(IAtom atom1, IAtom atom2, Point3d point2){
        double bondLength = atom1.getCovalentRadius() + atom2.getCovalentRadius();
        double scale = bondLength / point2.distance(0,0,0);
        point2.scale(scale);
        return point2;
    }","public Point3d rescaleBondLength(IAtom atom1, IAtom atom2, Point3d point2){
        double bondLength = atom1.getCovalentRadius() + atom2.getCovalentRadius();
        double scale = bondLength / point2.distance(0,0,0);
        point2.scale(scale);
        return point2;
    }","public Point3d rescaleBondLength(IAtom atom1, IAtom atom2, Point3d point2){
        double bondLength = atom1.getCovalentRadius() + atom2.getCovalentRadius();
        double scale = bondLength / point2.distance(0, 0, 0);
        point2.scale(scale);
        return point2;
    }","public Point3d rescaleBondLength(IAtom atom1, IAtom atom2, Point3d point2){
        double bondLength = atom1.getCovalentRadius() + atom2.getCovalentRadius();
        double length = point2.distance(atom1.getPoint3d());
        double scale = bondLength / length;
        point2.scale(scale);
        return point2;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.28093012095460634,  0.28093012095460634,  0.3044802959898435,  0.28093012095460634,92.0,0.6814814814814815,92.0,0.6814814814814815,88.0,0.6518518518518519,92.0,0.6814814814814815,0.0,0.0,15.0,0.24193548387096775,0.0,0.0,6.0,0.375,5.0,0.35714285714285715,6.0,0.5
739,jackson-databind,"protected void _collectIgnorals(String name){
    if (!_forSerialization && (name != null)) {
        if (_ignoredPropertyNames == null) {
            _ignoredPropertyNames = new HashSet<String>();
        }
        _ignoredPropertyNames.add(name);
    }
}",_collectIgnorals,com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java,/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java,"/**
     * Helper method called to add explicitly ignored properties to a list
     * of known ignored properties; this helps in proper reporting of
     * errors.
     */",935-948,"('_collectIgnorals', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,24.0,Helper method called to add explicitly ignored properties to a list  of known ignored properties; this helps in proper reporting of  errors.,This method adds explicitly ignored properties to a list of known ignored properties,Adding explicitly ignored properties to a list helps in reporting errors.,0.200780945532397,A helper method called to add explicitly ignored properties to a list of known ignored properties; this helps to report errors correctly.," protected void _collectIgnorals(String name){
        if (_ignoredPropertyNames == null) {
            _ignoredPropertyNames = new HashSet<String>();
        }
        _ignoredPropertyNames.add(name);
    }"," protected void _collectIgnorals(String name){
        if(_ignoredPropertyNames == null){
            _ignoredPropertyNames = new HashSet<String>();
        }
        _ignoredPropertyNames.add(name);
    }"," protected void _collectIgnorals(String name){
        if (_ignoredPropertyNames == null) {
            _ignoredPropertyNames = new HashSet<String>();
        }
        _ignoredPropertyNames.add(name);
    }"," protected void _collectIgnorals(String name){
        if (_ignoredPropertyNames == null) {
            _ignoredPropertyNames = new HashSet<String>();
        }
        _ignoredPropertyNames.add(name);
    }",PASS,NOT PASS,PASS,PASS,  0.7611916312528201,  0.7611916312528201,  0.7611916312528201,  0.7611916312528201,13.0,0.2708333333333333,13.0,0.2708333333333333,13.0,0.2708333333333333,13.0,0.2708333333333333,0.0,0.0,0.0,0.0,0.0,0.0,12.0,0.5217391304347826,7.0,0.30434782608695654,12.0,0.5217391304347826
740,anserini,"public static int convertDocidToLuceneDocid(IndexReader reader, String docid){
    try {
        IndexSearcher searcher = new IndexSearcher(reader);
        Query q = new TermQuery(new Term(IndexArgs.ID, docid));
        TopDocs rs = searcher.search(q, 1);
        ScoreDoc[] hits = rs.scoreDocs;
        if (hits == null || hits.length == 0) {
            return -1;
        }
        return hits[0].doc;
    } catch (IOException e) {
        return -1;
    }
}",convertDocidToLuceneDocid,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,"/**
   * Converts a collection docid to a Lucene internal docid.
   *
   * @param reader index reader
   * @param docid collection docid
   * @return corresponding Lucene internal docid, or -1 if docid not found
   */",731-755,"('convertDocidToLuceneDocid', {'INSTRUCTION': {'covered': 34, 'missed': 3}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",100.0,10.0,Converts a collection docid to a Lucene internal docid.,This method converts a collection docid to a Lucene internal docid,A collection docid is converted to a Lucene internal docid.,0.709551861673088,Converts a collection docid to an internal Lucene docid.," public static int convertDocidToLuceneDocid(IndexReader reader, String docid){
    try {
      return reader.docFreq(new Term(IndexArgs.ID, docid));
    } catch (IOException e) {
      throw new RuntimeException(e);
    }   
 }","public static int convertDocidToLuceneDocid(IndexReader reader, String docid){
    try {
      return reader.docFreq(new Term(IndexArgs.ID, docid));
    } catch (IOException e) {
      e.printStackTrace();
      return -1;
    }   
 }"," public static int convertDocidToLuceneDocid(IndexReader reader, String docid){
    return reader.docFreq(new Term(IndexArgs.ID, docid));   
 }"," public static int convertDocidToLuceneDocid(IndexReader reader, String docid){
    return reader.docFreq(new Term(IndexArgs.ID, docid));   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.287827870738756,  0.3154921929822791,  0.1922268759163281,  0.1922268759163281,64.0,0.6336633663366337,61.0,0.6039603960396039,74.0,0.7326732673267327,74.0,0.7326732673267327,8.0,0.16,17.0,0.3617021276595745,17.0,0.3617021276595745,4.0,0.3333333333333333,3.0,0.3,4.0,0.36363636363636365
741,egeria,"public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
        return false;
    }
    if (!super.equals(objectToCompare)) {
        return false;
    }
    AssetResponse that = (AssetResponse) objectToCompare;
    return getCertificationCount() == that.getCertificationCount() && getCommentCount() == that.getCommentCount() && getConnectionCount() == that.getConnectionCount() && getExternalIdentifierCount() == that.getExternalIdentifierCount() && getExternalReferencesCount() == that.getExternalReferencesCount() && getInformalTagCount() == that.getInformalTagCount() && getLicenseCount() == that.getLicenseCount() && getLikeCount() == that.getLikeCount() && getKnownLocationsCount() == that.getKnownLocationsCount() && getNoteLogsCount() == that.getNoteLogsCount() && getRatingsCount() == that.getRatingsCount() && getRelatedAssetCount() == that.getRelatedAssetCount() && getRelatedMediaReferenceCount() == that.getRelatedMediaReferenceCount() && getSchemaType() == that.getSchemaType() && getLastAttachment() == that.getLastAttachment() && Objects.equals(getAsset(), that.getAsset());
}",equals,org/odpi/openmetadata/commonservices/ocf/metadatamanagement/rest/AssetResponse.java,/open-metadata-implementation/common-services/ocf-metadata-management/ocf-metadata-api/src/main/java/org/odpi/openmetadata/commonservices/ocf/metadatamanagement/rest/AssetResponse.java,"/**
     * Return comparison result based on the content of the properties.
     *
     * @param objectToCompare test object
     * @return result of comparison
     */",505-543,"('equals', {'INSTRUCTION': {'covered': 107, 'missed': 1}, 'BRANCH': {'covered': 24, 'missed': 16}, 'LINE': {'covered': 23, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 16}, 'METHOD': {'covered': 1, 'missed': 0}})",230.0,11.0,Return comparison result based on the content of the properties.,Implment an equals method for the given objectToCompare,The result is based on the properties.,0.0778393773816239,Return the result of the comparison based on the content of the properties.," public boolean equals(Object objectToCompare){
        if (this == objectToCompare) {
            return true;
        }
        if (objectToCompare == null) {
            return false;
        }
        if (getClass() != objectToCompare.getClass()) {
            return false;
        }
        if (!super.equals(objectToCompare)) {
            return false;
        }
        AssetResponse that = (AssetResponse) objectToCompare;
        return Objects.equals(asset, that.asset) &&
                certificationCount == that.certificationCount &&
                commentCount == that.commentCount &&
                connectionCount == that.connectionCount &&
                externalIdentifierCount == that.externalIdentifierCount &&
                externalReferencesCount == that.externalReferencesCount &&
                informalTagCount == that.informalTagCount &&
                licenseCount == that.licenseCount &&
                likeCount == that.likeCount &&
                knownLocationsCount == that.knownLocationsCount &&
                noteLogsCount == that.noteLogsCount &&
                ratingsCount == that.ratingsCount &&
                relatedAssetCount == that.relatedAssetCount &&
                relatedMediaReferenceCount == that.relatedMediaReferenceCount &&
                Objects.equals(schemaType, that.schemaType) &&
                Objects.equals(lastAttachment, that.lastAttachment);        
 }"," public boolean equals(Object objectToCompare){
        if (this == objectToCompare) {
            return true;
        }
        if (objectToCompare == null) {
            return false;
        }
        if (getClass() != objectToCompare.getClass()) {
            return false;
        }
        if (!super.equals(objectToCompare)) {
            return false;
        }
        AssetResponse other = (AssetResponse) objectToCompare;
        if (asset == null) {
            if (other.asset != null) {
                return false;
            }
        } else if (!asset.equals(other.asset)) {
            return false;
        }
        if (certificationCount != other.certificationCount) {
            return false;
        }
        if (commentCount != other.commentCount) {
            return false;
        }
        if (connectionCount != other.connectionCount) {
            return false;
        }
        if (externalIdentifierCount != other.externalIdentifierCount) {
            return false;
        }
        if (externalReferencesCount != other.externalReferencesCount) {
            return false;
        }
        if (informalTagCount != other.informalTagCount) {
            return false;
        }
        if (licenseCount != other.licenseCount) {
            return false;
        }
        if (likeCount != other.likeCount) {
            return false;
        }
        if (knownLocationsCount != other.knownLocationsCount) {
            return false;
        }
        if (noteLogsCount != other.noteLogsCount) {
            return false;
        }
        if (ratingsCount != other.ratingsCount) {
            return false;
        }
        if (relatedAssetCount != other.relatedAssetCount) {
            return false;
        }
        if (relatedMediaReferenceCount != other.relatedMediaReferenceCount) {
            return false;
        }
        if (schemaType == null) {
            if (other.schemaType != null) {
                return false;
            }
        } else if (!schemaType.equ      
 }"," public boolean equals(Object objectToCompare){
     
      if (this == objectToCompare)
            return true;
     
      if (objectToCompare == null)
            return false;
     
      if (getClass() != objectToCompare.getClass())
            return false;
     
      if (!super.equals(objectToCompare))
            return false;
     
      AssetResponse that = (AssetResponse) objectToCompare;
     
      return Objects.equals(asset, that.asset) &&
                 Objects.equals(certificationCount, that.certificationCount) &&
                 Objects.equals(commentCount, that.commentCount) &&
                 Objects.equals(connectionCount, that.connectionCount) &&
                 Objects.equals(externalIdentifierCount, that.externalIdentifierCount) &&
                 Objects.equals(externalReferencesCount, that.externalReferencesCount) &&
                 Objects.equals(informalTagCount, that.informalTagCount) &&
                 Objects.equals(licenseCount, that.licenseCount) &&
                 Objects.equals(likeCount, that.likeCount) &&
                 Objects.equals(knownLocationsCount, that.knownLocationsCount) &&
                 Objects.equals(noteLogsCount, that.noteLogsCount) &&
                 Objects.equals(ratingsCount, that.ratingsCount) &&
                 Objects.equals(relatedAssetCount, that.relatedAssetCount) &&
                 Objects.equals(relatedMediaReferenceCount, that.relatedMediaReferenceCount) &&
                 Objects.equals(schemaType, that.schemaType) &&
                 Objects.equals(lastAttachment, that.lastAttachment);
     }"," public boolean equals(Object objectToCompare){
        if (this == objectToCompare)
            return true;
        if (objectToCompare == null)
            return false;
        if (getClass() != objectToCompare.getClass())
            return false;
        if (!super.equals(objectToCompare))
            return false;
        AssetResponse other = (AssetResponse) objectToCompare;
        return Objects.equals(asset, other.asset) &&
                certificationCount == other.certificationCount &&
                commentCount == other.commentCount &&
                connectionCount == other.connectionCount &&
                externalIdentifierCount == other.externalIdentifierCount &&
                externalReferencesCount == other.externalReferencesCount &&
                informalTagCount == other.informalTagCount &&
                licenseCount == other.licenseCount &&
                likeCount == other.likeCount &&
                knownLocationsCount == other.knownLocationsCount &&
                noteLogsCount == other.noteLogsCount &&
                ratingsCount == other.ratingsCount &&
                relatedAssetCount == other.relatedAssetCount &&
                relatedMediaReferenceCount == other.relatedMediaReferenceCount &&
                Objects.equals(schemaType, other.schemaType) &&
                Objects.equals(lastAttachment, other.lastAttachment);       
 }",NOT PASS,Syntax Error,NOT PASS,NOT PASS,  0.6514245973579744,None,  0.5676870748324703,  0.5936485000302929,105.0,0.45454545454545453,None,None,126.0,0.5454545454545454,123.0,0.5103734439834025,None,None,25.0,0.1358695652173913,86.0,0.35684647302904565,9.0,0.8181818181818182,4.0,0.2857142857142857,6.0,0.5454545454545454
744,acs-aem-commons,"private int purgeExpiredEntries(){
    int result = 0;
    for (int i = 0; i < timestamps.length; i++) {
        long now = clock.instant().toEpochMilli();
        if (now - timestamps[i].toEpochMilli() > ONE_MINUTE) {
            timestamps[i] = Instant.EPOCH;
            result++;
        }
    }
    return result;
}",purgeExpiredEntries,com/adobe/acs/commons/throttling/ThrottlingState.java,/bundle/src/main/java/com/adobe/acs/commons/throttling/ThrottlingState.java,"/**
     * cleanup the timestamps array and replace all expired entries with
     * Instant.EPOCH;
     *
     * @return the number of emptied slots
     */",108-129,"('purgeExpiredEntries', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,12.0,cleanup the timestamps array and replace all expired entries with  Instant.,This method purges the timestamps array and replace all expired entries with Instant.EPOCH,All expired entries should be replaced with Instant.,0.268556484708331,Clean the timestamp table and replace all expired entries with Instant.,"private int purgeExpiredEntries(){
        int count = 0;
        for (int i = 0; i < timestamps.length; i++) {
            if (timestamps[i].isBefore(clock.instant())) {
                timestamps[i] = Instant.EPOCH;
                count++;
            }
        }
        return count;       
 }","private int purgeExpiredEntries(){
        int count = 0;
        for (int i = 0; i < timestamps.length; i++) {
            if (timestamps[i].isBefore(clock.instant())) {
                timestamps[i] = Instant.EPOCH;
                count++;
            }
        }
        return count;       
 }","private int purgeExpiredEntries(){
        int count = 0;
        for (int i = 0; i < timestamps.length; i++) {
            if (timestamps[i].isBefore(clock.instant())) {
                timestamps[i] = Instant.EPOCH;
                count++;
            }
        }
        return count;       
 }","private int purgeExpiredEntries(){
        int count = 0;
        Instant now = clock.instant();
        for (int i = 0; i < timestamps.length; i++) {
            if (timestamps[i].isAfter(now)) {
                count++;
            } else {
                timestamps[i] = Instant.EPOCH;
            }
        }
        return count;       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6680756734139177,  0.6680756734139177,  0.6280246221567677,  0.6680756734139177,25.0,0.32894736842105265,25.0,0.32894736842105265,38.0,0.5,25.0,0.32894736842105265,0.0,0.0,22.0,0.3055555555555556,0.0,0.0,4.0,0.2857142857142857,3.0,0.25,9.0,0.75
745,cdk,"public static boolean compare(IMolecularFormula formula1, IMolecularFormula formula2){
    if (!Objects.equals(formula1.getCharge(), formula2.getCharge()))
        return false;
    if (formula1.getIsotopeCount() != formula2.getIsotopeCount())
        return false;
    for (IIsotope isotope : formula1.isotopes()) {
        if (!formula2.contains(isotope))
            return false;
        if (formula1.getIsotopeCount(isotope) != formula2.getIsotopeCount(isotope))
            return false;
    }
    for (IIsotope isotope : formula2.isotopes()) {
        if (!formula1.contains(isotope))
            return false;
        if (formula2.getIsotopeCount(isotope) != formula1.getIsotopeCount(isotope))
            return false;
    }
    return true;
}",compare,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * Compare two IMolecularFormula looking at type and number of IIsotope and
     * charge of the formula.
     *
     * @param formula1   The first IMolecularFormula
     * @param formula2   The second IMolecularFormula
     * @return           True, if the both IMolecularFormula are the same
     */",1256-1283,"('compare', {'INSTRUCTION': {'covered': 67, 'missed': 4}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",146.0,16.0,Compare two IMolecularFormula looking at type and number of IIsotope and  charge of the formula.,This method compares two IMolecularFormula by looking at type and number of IIsotope and charge of the formula,Two IMolecularFormulas look at type and number of IIsotope and charge of the formula.,0.444083029451502,Compare two IMolecularFormula by looking at the type and number of IIsotope and the load of the formula.,"public static boolean compare(IMolecularFormula formula1, IMolecularFormula formula2){
        if (formula1.getIsotopeCount() != formula2.getIsotopeCount()){
            return false;
        }
        if (formula1.getCharge() != formula2.getCharge()){
            return false;
        }
        if (formula1.getType() != formula2.getType()){
            return false;
        }
        return true;        
 }","public static boolean compare(IMolecularFormula formula1, IMolecularFormula formula2){
        if(formula1.getIsotopeCount() != formula2.getIsotopeCount()){
            return false;
        }
        if(formula1.getCharge() != formula2.getCharge()){
            return false;
        }
        if(formula1.getType() != formula2.getType()){
            return false;
        }
        return true;        
 }","public static boolean compare(IMolecularFormula formula1, IMolecularFormula formula2){
        if(formula1.getIsotopeCount() != formula2.getIsotopeCount()){
            return false;
        }
        if(formula1.getCharge() != formula2.getCharge()){
            return false;
        }
        if(formula1.getType() != formula2.getType()){
            return false;
        }
        return true;        
 }","public static boolean compare(IMolecularFormula formula1, IMolecularFormula formula2){
        if(formula1.getIsotopeCount() != formula2.getIsotopeCount()){
            return false;
        }
        if(formula1.getCharge() != formula2.getCharge()){
            return false;
        }
        if(formula1.getAtomCount() != formula2.getAtomCount()){
            return false;
        }
        if(formula1.getBondCount() != formula2.getBondCount()){
            return false;
        }
        if(formula1.getAtom(0).getSymbol().equals(formula2.getAtom(0).getSymbol())){
            return false;
        }
        if(formula1.getAtom(1).getSymbol().equals(formula2.getAtom(1).getSymbol())){
            return false;
        }
        if(formula1.getAtom(2).getSymbol().equals(formula2.getAtom(2).getSymbol())){
            return false;
        }
        if(formula1.getAtom(3).getSymbol().equals(formula2.getAtom(3).getSymbol())){
            return false;
        }
        if(formula1.getAtom(4).getSymbol().equals(formula2.getAtom(4).getSymbol())){
            return false;
        }
        if(formula1.getAtom(5).getSymbol().equals(formula2.getAtom(5).getSymbol())){
            return false;
        }
        if(formula1.getAtom(6).getSymbol().equals(formula2.getAtom(6).getSymbol())){
            return false;
        }
        if(formula1.getAtom(7).getSymbol().equals(formula2.getAtom(7).getSymbol())){
            return false;
        }
        if(formula      
 }",NOT PASS,NOT PASS,Syntax Error,NOT PASS,  0.36438382808961617,  0.36438382808961617,None,  0.36438382808961617,83.0,0.564625850340136,83.0,0.564625850340136,237.0,0.6790830945558739,83.0,0.564625850340136,0.0,0.0,278.0,0.7965616045845272,0.0,0.0,5.0,0.2631578947368421,4.0,0.21052631578947367,4.0,0.25
747,cdk,"private static double[] toVector(Point3d src, Point3d dest){
    return new double[] { dest.x - src.x, dest.y - src.y, dest.z - src.z };
}",toVector,org/openscience/cdk/hash/stereo/DoubleBond3DParity.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/DoubleBond3DParity.java,"/**
     * Create a vector by specifying the source and destination coordinates.
     *
     * @param src  start point of the vector
     * @param dest end point of the vector
     * @return a new vector
     */",93-102,"('toVector', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,11.0,Create a vector by specifying the source and destination coordinates.,Get a subvector by specifying the source and destination indexes,You can create a vector by specifying the source and destination coordinates.,0.411465353300869,Create a vector by specifying the source and destination coordinates.,"private static double[] toVector(Point3d src, Point3d dest){
        double[] v = new double[3];
        v[0] = dest.x - src.x;
        v[1] = dest.y - src.y;
        v[2] = dest.z - src.z;
        return v;       
 }","private static double[] toVector(Point3d src, Point3d dest){
        double[] vector = new double[3];
        vector[0] = dest.x - src.x;
        vector[1] = dest.y - src.y;
        vector[2] = dest.z - src.z;
        return vector;      
 }","private static double[] toVector(Point3d src, Point3d dest){
        double[] v = new double[3];
        v[0] = dest.x - src.x;
        v[1] = dest.y - src.y;
        v[2] = dest.z - src.z;
        return v;       
 }","private static double[] toVector(Point3d src, Point3d dest){
        double[] v = new double[3];
        v[0] = dest.x - src.x;
        v[1] = dest.y - src.y;
        v[2] = dest.z - src.z;
        return v;       
 }",PASS,PASS,PASS,PASS,  0.7127891806948736,  0.7127891806948736,  0.7127891806948736,  0.7127891806948736,27.0,0.391304347826087,27.0,0.391304347826087,27.0,0.391304347826087,27.0,0.391304347826087,5.0,0.07246376811594203,0.0,0.0,0.0,0.0,3.0,0.2727272727272727,0.0,0.0,3.0,0.23076923076923078
748,jackson-databind,"public static Enum<?> findFirstAnnotatedEnumValue(Class<Enum<?>> enumClass, Class<T> annotationClass){
    Field[] fields = enumClass.getDeclaredFields();
    for (Field field : fields) {
        if (field.isEnumConstant()) {
            Annotation defaultValueAnnotation = field.getAnnotation(annotationClass);
            if (defaultValueAnnotation != null) {
                final String name = field.getName();
                for (Enum<?> enumValue : enumClass.getEnumConstants()) {
                    if (name.equals(enumValue.name())) {
                        return enumValue;
                    }
                }
            }
        }
    }
    return null;
}",findFirstAnnotatedEnumValue,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * A method that will look for the first Enum value annotated with the given Annotation.
     * <p>
     * If there's more than one value annotated, the first one found will be returned. Which one exactly is used is undetermined.
     *
     * @param enumClass The Enum class to scan for a value with the given annotation
     * @param annotationClass The annotation to look for.
     * @return the Enum value annotated with the given Annotation or {@code null} if none is found.
     * @throws IllegalArgumentException if there's a reflection issue accessing the Enum
     * @since 2.8
     */",1093-1121,"('findFirstAnnotatedEnumValue', {'INSTRUCTION': {'covered': 58, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",120.0,16.0,A method that will look for the first Enum value annotated with the given Annotation.,This method looks for the first Enum value annotated with the given Annotation,A method that will look for the first Enum value.,0.582890931189884,Method; looks for the first Enum value annotated with the given annotation.," public static Enum<?> findFirstAnnotatedEnumValue(Class<Enum<?>> enumClass, Class<T> annotationClass){
        for(Enum<?> enumValue : enumClass.getEnumConstants()){
            if(enumValue.getClass().isAnnotationPresent(annotationClass)){
                return enumValue;
            }
        }
        return null;
    }"," public static Enum<?> findFirstAnnotatedEnumValue(Class<Enum<?>> enumClass, Class<T> annotationClass){
        Enum<?>[] enumValues = enumClass.getEnumConstants();
        for (Enum<?> enumValue : enumValues) {
            if (enumValue.getClass().isAnnotationPresent(annotationClass)) {
                return enumValue;
            }
        }
        return null;
    }"," public static Enum<?> findFirstAnnotatedEnumValue(Class<Enum<?>> enumClass, Class<T> annotationClass){
        for (Enum<?> value : enumClass.getEnumConstants()) {
            if (value.getClass().isAnnotationPresent(annotationClass)) {
                return value;
            }
        }
        return null;
    }"," public static Enum<?> findFirstAnnotatedEnumValue(Class<Enum<?>> enumClass, Class<T> annotationClass){
        for (Enum<?> value : enumClass.getEnumConstants()) {
            if (value.getClass().isAnnotationPresent(annotationClass)) {
                return value;
            }
        }
        return null;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4063889345174985,  0.479835921435157,  0.3829391349079766,  0.3829391349079766,63.0,0.5206611570247934,63.0,0.5206611570247934,65.0,0.5371900826446281,65.0,0.5371900826446281,16.0,0.2191780821917808,3.0,0.047619047619047616,3.0,0.047619047619047616,5.0,0.3125,6.0,0.375,6.0,0.375
749,cdk,"public synchronized void sortResultsByStereoAndBondMatch() throws CDKException{
    // System.out.println(""\n\n\n\nSort By ResultsByStereoAndBondMatch"");
    Map<Integer, Map<Integer, Integer>> allStereoMCS = new HashMap<Integer, Map<Integer, Integer>>();
    Map<Integer, Map<IAtom, IAtom>> allStereoAtomMCS = new HashMap<Integer, Map<IAtom, IAtom>>();
    Map<Integer, Integer> fragmentScoreMap = new TreeMap<Integer, Integer>();
    Map<Integer, Double> energyScoreMap = new TreeMap<Integer, Double>();
    Map<Integer, Double> stereoScoreMap = new HashMap<Integer, Double>();
    initializeMaps(allStereoMCS, allStereoAtomMCS, stereoScoreMap, fragmentScoreMap, energyScoreMap);
    boolean stereoMatchFlag = getStereoBondChargeMatch(stereoScoreMap, allStereoMCS, allStereoAtomMCS);
    boolean flag = false;
    if (stereoMatchFlag) {
        // Higher Score is mapped preferred over lower
        stereoScoreMap = sortMapByValueInDecendingOrder(stereoScoreMap);
        double higestStereoScore = stereoScoreMap.isEmpty() ? 0 : stereoScoreMap.values().iterator().next();
        double secondhigestStereoScore = higestStereoScore;
        for (Integer key : stereoScoreMap.keySet()) {
            if (secondhigestStereoScore < higestStereoScore && stereoScoreMap.get(key) > secondhigestStereoScore) {
                secondhigestStereoScore = stereoScoreMap.get(key);
            } else if (secondhigestStereoScore == higestStereoScore && stereoScoreMap.get(key) < secondhigestStereoScore) {
                secondhigestStereoScore = stereoScoreMap.get(key);
            }
        }
        if (!stereoScoreMap.isEmpty()) {
            flag = true;
            clear();
        }
        /* Put back the sorted solutions */
        int counter = 0;
        for (Integer i : stereoScoreMap.keySet()) {
            // System.out.println(""Sorted Map key "" + I + "" Sorted Value: "" + stereoScoreMap.get(I));
            // System.out.println(""Stereo MCS "" + allStereoMCS.get(I) + "" Stereo Value: ""
            // + stereoScoreMap.get(I));
            if (higestStereoScore == stereoScoreMap.get(i).doubleValue()) {
                // || secondhigestStereoScore == stereoScoreMap.get(I).doubleValue()) {
                addSolution(counter, i, allStereoAtomMCS, allStereoMCS, stereoScoreMap, energyScoreMap, fragmentScoreMap);
                counter++;
                // System.out.println(""Sorted Map key "" + I + "" Sorted Value: "" + stereoScoreMap.get(I));
                // System.out.println(""Stereo MCS "" + allStereoMCS.get(I) + "" Stereo Value: ""
                // + stereoScoreMap.get(I));
            }
        }
        if (flag) {
            firstSolution.putAll(allMCS.get(0));
            firstAtomMCS.putAll(allAtomMCS.get(0));
            clear(allStereoMCS, allStereoAtomMCS, stereoScoreMap, fragmentScoreMap, energyScoreMap);
        }
    }
}",sortResultsByStereoAndBondMatch,org/openscience/cdk/smsd/filters/ChemicalFilters.java,/legacy/src/main/java/org/openscience/cdk/smsd/filters/ChemicalFilters.java,"/**
     * Sort MCS solution by stereo and bond type matches.
     * @throws CDKException
     */",190-255,"('sortResultsByStereoAndBondMatch', {'INSTRUCTION': {'covered': 160, 'missed': 9}, 'BRANCH': {'covered': 17, 'missed': 5}, 'LINE': {'covered': 32, 'missed': 1}, 'COMPLEXITY': {'covered': 7, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",376.0,10.0,Sort MCS solution by stereo and bond type matches.,This method sorts the MCS solution by stereo and bound type matches,Sort by stereo and bond type.,0.339482616459886,Sort the MCS solution by stereo correspondence and link type.,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,6.0,0.46153846153846156,5.0,0.45454545454545453,4.0,0.4
750,egeria,"public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
        return false;
    }
    TypeDefPatch that = (TypeDefPatch) objectToCompare;
    return applyToVersion == that.applyToVersion && updateToVersion == that.updateToVersion && Objects.equals(typeDefGUID, that.typeDefGUID) && Objects.equals(typeDefName, that.typeDefName) && typeDefStatus == that.typeDefStatus && Objects.equals(newVersionName, that.newVersionName) && Objects.equals(updatedBy, that.updatedBy) && Objects.equals(updateTime, that.updateTime) && Objects.equals(description, that.description) && Objects.equals(descriptionGUID, that.descriptionGUID) && Objects.equals(superType, that.superType) && Objects.equals(propertyDefinitions, that.propertyDefinitions) && Objects.equals(typeDefOptions, that.typeDefOptions) && Objects.equals(externalStandardMappings, that.externalStandardMappings) && Objects.equals(validInstanceStatusList, that.validInstanceStatusList) && initialStatus == that.initialStatus && Objects.equals(validEntityDefs, that.validEntityDefs) && Objects.equals(endDef1, that.endDef1) && Objects.equals(endDef2, that.endDef2);
}",equals,org/odpi/openmetadata/repositoryservices/connectors/stores/metadatacollectionstore/properties/typedefs/TypeDefPatch.java,/open-metadata-implementation/repository-services/repository-services-apis/src/main/java/org/odpi/openmetadata/repositoryservices/connectors/stores/metadatacollectionstore/properties/typedefs/TypeDefPatch.java,"/**
     * Validate that an object is equal depending on their stored values.
     *
     * @param objectToCompare object
     * @return boolean result
     */",615-652,"('equals', {'INSTRUCTION': {'covered': 133, 'missed': 0}, 'BRANCH': {'covered': 27, 'missed': 17}, 'LINE': {'covered': 21, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 17}, 'METHOD': {'covered': 1, 'missed': 0}})",239.0,12.0,Validate that an object is equal depending on their stored values.,Check if the given object is equal depending on their stored values,"If you can show that an object is equal, you have done your job.",1.3188804327794,Verify that an object is equal based on its stored values.,Not Valid," public boolean equals(Object objectToCompare){
        if (this == objectToCompare)
        {
            return true;
        }
    
        if (objectToCompare == null)
        {
            return false;
        }
    
        if (getClass() != objectToCompare.getClass())
        {
            return false;
        }
    
        TypeDefPatch that = (TypeDefPatch) objectToCompare;
    
        if (typeDefGUID == null)
        {
            if (that.typeDefGUID != null)
            {
                return false;
            }
        }
        else if (!typeDefGUID.equals(that.typeDefGUID))
        {
            return false;
        }
    
        if (typeDefName == null)
        {
            if (that.typeDefName != null)
            {
                return false;
            }
        }
        else if (!typeDefName.equals(that.typeDefName))
        {
            return false;
        }
    
        if (typeDefStatus == null)
        {
            if (that.typeDefStatus != null)
            {
                return false;
            }
        }
        else if (!typeDefStatus.equals(that.typeDefStatus))
        {
            return false;
        }
    
        if (applyToVersion == null)
        {
            if (that.applyToVersion != null)
            {
                return false;
            }
        }
        else if (!applyToVersion.equals(that.applyToVersion))
        {
            return false;
        }
    
        if (updateToVersion == null)
        {
            if (that.updateToVersion != null)
            {
                return false;
            }
        }
        else if (!updateToVersion.equals(that.updateToVersion))
        {
            return false;
        }
    
        if (newVersionName == null)
        {
            if (that.newVersionName != null)
            {
                return false;
            }
        }
        else if (!newVersionName.equals(that.new        
 }","public boolean equals(Object objectToCompare){
        if (this == objectToCompare)
        {
            return true;
        }
        if (objectToCompare == null || getClass() != objectToCompare.getClass())
        {
            return false;
        }
        TypeDefPatch that = (TypeDefPatch) objectToCompare;
        return Objects.equals(typeDefGUID, that.typeDefGUID) &&
                Objects.equals(typeDefName, that.typeDefName) &&
                Objects.equals(typeDefStatus, that.typeDefStatus) &&
                Objects.equals(applyToVersion, that.applyToVersion) &&
                Objects.equals(updateToVersion, that.updateToVersion) &&
                Objects.equals(newVersionName, that.newVersionName) &&
                Objects.equals(description, that.description) &&
                Objects.equals(descriptionGUID, that.descriptionGUID) &&
                Objects.equals(superType, that.superType) &&
                Objects.equals(propertyDefinitions, that.propertyDefinitions) &&
                Objects.equals(typeDefOptions, that.typeDefOptions) &&
                Objects.equals(externalStandardMappings, that.externalStandardMappings) &&
                Objects.equals(validInstanceStatusList, that.validInstanceStatusList) &&
                Objects.equals(initialStatus, that.initialStatus) &&
                Objects.equals(validEntityDefs, that.validEntityDefs) &&
                Objects.equals(endDef1, that.endDef1) &&
                Objects.equals(endDef2, that.endDef2);      
 }","public boolean equals(Object objectToCompare){
        if (this == objectToCompare)
        {
            return true;
        }
        if (objectToCompare == null || getClass() != objectToCompare.getClass())
        {
            return false;
        }
        TypeDefPatch that = (TypeDefPatch) objectToCompare;
        return Objects.equals(getTypeDefGUID(), that.getTypeDefGUID()) &&
                Objects.equals(getTypeDefName(), that.getTypeDefName()) &&
                Objects.equals(getTypeDefStatus(), that.getTypeDefStatus()) &&
                Objects.equals(getApplyToVersion(), that.getApplyToVersion()) &&
                Objects.equals(getUpdateToVersion(), that.getUpdateToVersion()) &&
                Objects.equals(getNewVersionName(), that.getNewVersionName()) &&
                Objects.equals(getDescription(), that.getDescription()) &&
                Objects.equals(getDescriptionGUID(), that.getDescriptionGUID()) &&
                Objects.equals(getSuperType(), that.getSuperType()) &&
                Objects.equals(getPropertyDefinitions(), that.getPropertyDefinitions()) &&
                Objects.equals(getTypeDefOptions(), that.getTypeDefOptions()) &&
                Objects.equals(getExternalStandardMappings(), that.getExternalStandardMappings()) &&
                Objects.equals(getValidInstanceStatusList(), that.getValidInstanceStatusList()) &&
                Objects.equals(getInitialStatus(), that.getInitialStatus()) &&
                Objects.equals(getValidEntityDefs(), that.getValidEntityDefs()) &&
                Objects.equals(getEndDef1(), that.getEndDef1()) &&
                Objects.equals(getEndDef2(), that.getEndDef2());        
 }",Not Valid,Syntax Error,NOT PASS,NOT PASS,None,None,  0.5156973047530508,  0.8246866546686615,None,None,None,None,119.0,0.3888888888888889,30.0,0.125,None,None,305.0,0.9967320261437909,237.0,0.9957983193277311,5.0,0.38461538461538464,3.0,0.25,10.0,0.6666666666666666
751,matsim-libs,"public static Coord orthogonalProjectionOnLineSegment(final Coord lineFrom, final Coord lineTo, final Coord point){
    if (!lineFrom.hasZ() && !lineTo.hasZ() && !point.hasZ()) {
        double lineDX = lineTo.getX() - lineFrom.getX();
        double lineDY = lineTo.getY() - lineFrom.getY();
        if ((lineDX == 0.0) && (lineDY == 0.0)) {
            return lineFrom;
        }
        double u = ((point.getX() - lineFrom.getX()) * lineDX + (point.getY() - lineFrom.getY()) * lineDY) / (lineDX * lineDX + lineDY * lineDY);
        if (u <= 0) {
            return lineFrom;
        }
        if (u >= 1) {
            return lineTo;
        }
        return new Coord(lineFrom.getX() + u * lineDX, lineFrom.getY() + u * lineDY);
    } else if (lineFrom.hasZ() && lineTo.hasZ() && point.hasZ()) {
        Coord direction = minus(lineTo, lineFrom);
        double t0 = dotProduct(direction, minus(point, lineFrom)) / dotProduct(direction, direction);
        Coord q = plus(lineFrom, scalarMult(t0, direction));
        return q;
    } else {
        if (!onlyOnceWarnGiven) {
            Logger.getLogger(CoordUtils.class).warn(""Mix of 2D / 3D coordinates. Assuming 2D only.\n"" + Gbl.ONLYONCE);
            onlyOnceWarnGiven = true;
        }
        return orthogonalProjectionOnLineSegment(new Coord(lineFrom.getX(), lineFrom.getY()), new Coord(lineTo.getX(), lineTo.getY()), new Coord(point.getX(), point.getY()));
    }
}",orthogonalProjectionOnLineSegment,org/matsim/core/utils/geometry/CoordUtils.java,/matsim/src/main/java/org/matsim/core/utils/geometry/CoordUtils.java,"/**
         * Calculates the coordinate of the intersection point of the orthogonal projection
         * of a given point on a line segment with that line segment. The line segment
         * is given by two points, <code>lineFrom</code> and <code>lineTo</code>. If the
         * projection point does not lie *on* the line segment (but only somewhere on
         * the extension of the line segment, i.e. the infinite line), the end point of
         * the line segment which is closest to the given point is returned.
         *
         * <br><br>
         * The 3D version was adapted from the documentation of 
         * <a href=""http://www.geometrictools.com/Documentation/DistancePointLine.pdf"">
         * David Eberly/a>. 
         *
         * @param lineFrom The start point of the line segment
         * @param lineTo The end point of the line segment
         * @param point The point whose distance to the line segment should be calculated
         * @return the <code>coordinate</code> of the intersection point of the orthogonal
         * projection of a given point on a line segment with that line segment
         *
         * @author dziemke, jwjoubert
         */",331-394,"('orthogonalProjectionOnLineSegment', {'INSTRUCTION': {'covered': 114, 'missed': 31}, 'BRANCH': {'covered': 15, 'missed': 7}, 'LINE': {'covered': 16, 'missed': 4}, 'COMPLEXITY': {'covered': 6, 'missed': 6}, 'METHOD': {'covered': 1, 'missed': 0}})",344.0,24.0,Calculates the coordinate of the intersection point of the orthogonal projection  of a given point on a line segment with that line segment.,Get the coordinate of the intersection point of the orthogonal projection of the given point on a line segment with that line segment,The coordinate of the intersection point of the two lines is calculated.,1.19948391220226,Calculates the coordinate of the intersection point of the orthogonal projection of a given point on a line segment with that line segment.,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,3.0,0.125,0.0,0.0,16.0,0.6666666666666666
752,cactoos,"private T fallback(final Throwable exp) throws Exception{
    final Iterator<Map.Entry<Fallback<T>, Integer>> candidates = new Sorted<>(Comparator.comparing(Map.Entry::getValue), new Filtered<>(new org.cactoos.func.Flattened<>(entry -> new Not(new Equals<Integer, Integer>(entry::getValue, new Constant<>(Integer.MIN_VALUE)))), new MapOf<>(fbk -> fbk, fbk -> fbk.support(exp), this.fallbacks).entrySet().iterator()));
    if (candidates.hasNext()) {
        return candidates.next().getKey().apply(exp);
    } else {
        throw new Exception(""No fallback found - throw the original exception"", exp);
    }
}",fallback,org/cactoos/scalar/ScalarWithFallback.java,/src/main/java/org/cactoos/scalar/ScalarWithFallback.java,"/**
     * Finds the best fallback for the given exception type and apply it to
     * the exception or throw the original error if no fallback found.
     * @param exp The original exception
     * @return Result of the most suitable fallback
     * @throws Exception The original exception if no fallback found
     */",99-135,"('fallback', {'INSTRUCTION': {'covered': 40, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",162.0,25.0,Finds the best fallback for the given exception type and apply it to  the exception or throw the original error if no fallback found.,This method finds the best fallback for the given exception type and applies it to the exception or throw the original error if no fallback found,"If no fallback is found, apply it to the exception or throw the original error.",0.600200248885917,Finds the best fallback for the given exception type and applies it to the exception or throws the original error if no fallback is found.,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,5.0,0.18518518518518517,3.0,0.11538461538461539,14.0,0.56
753,cdk,"private void handleFragmentGrouping(IReaction rxn, CxSmilesState cxstate){
    if (cxstate.fragGroups == null && cxstate.racemicFrags == null)
        return;
    final int reactant = 1;
    final int agent = 2;
    final int product = 3;
    List<IAtomContainer> fragMap = new ArrayList<>();
    Map<IAtomContainer, Integer> roleMap = new HashMap<>();
    for (IAtomContainer mol : rxn.getReactants().atomContainers()) {
        fragMap.add(mol);
        roleMap.put(mol, reactant);
    }
    for (IAtomContainer mol : rxn.getAgents().atomContainers()) {
        fragMap.add(mol);
        roleMap.put(mol, agent);
    }
    for (IAtomContainer mol : rxn.getProducts().atomContainers()) {
        fragMap.add(mol);
        roleMap.put(mol, product);
    }
    if (cxstate.racemicFrags != null) {
        for (Integer grp : cxstate.racemicFrags) {
            if (grp >= fragMap.size())
                continue;
            IAtomContainer mol = fragMap.get(grp);
            if (mol == null)
                continue;
            for (IStereoElement<?, ?> e : mol.stereoElements()) {
                if (e.getConfigClass() == IStereoElement.TH) {
                    e.setGroupInfo(IStereoElement.GRP_RAC1);
                }
            }
        }
    }
    if (cxstate.fragGroups != null) {
        boolean invalid = false;
        Set<Integer> visit = new HashSet<>();
        for (List<Integer> grouping : cxstate.fragGroups) {
            if (grouping.get(0) >= fragMap.size())
                continue;
            IAtomContainer dest = fragMap.get(grouping.get(0));
            if (dest == null)
                continue;
            if (!visit.add(grouping.get(0)))
                invalid = true;
            for (int i = 1; i < grouping.size(); i++) {
                if (!visit.add(grouping.get(i)))
                    invalid = true;
                if (grouping.get(i) >= fragMap.size())
                    continue;
                IAtomContainer src = fragMap.get(grouping.get(i));
                if (src != null) {
                    dest.add(src);
                    roleMap.put(src, 0);
                }
            }
        }
        if (!invalid) {
            rxn.getReactants().removeAllAtomContainers();
            rxn.getAgents().removeAllAtomContainers();
            rxn.getProducts().removeAllAtomContainers();
            for (IAtomContainer mol : fragMap) {
                switch(roleMap.get(mol)) {
                    case reactant:
                        rxn.getReactants().addAtomContainer(mol);
                        break;
                    case product:
                        rxn.getProducts().addAtomContainer(mol);
                        break;
                    case agent:
                        rxn.getAgents().addAtomContainer(mol);
                        break;
                }
            }
        }
    }
}",handleFragmentGrouping,org/openscience/cdk/smiles/SmilesParser.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/SmilesParser.java,"/**
     * Handle fragment grouping of a reaction that specifies certain disconnected components
     * are actually considered a single molecule. Normally used for salts, [Na+].[OH-].
     *
     * @param rxn     reaction
     * @param cxstate state
     */",379-474,"('handleFragmentGrouping', {'INSTRUCTION': {'covered': 272, 'missed': 7}, 'BRANCH': {'covered': 40, 'missed': 8}, 'LINE': {'covered': 59, 'missed': 6}, 'COMPLEXITY': {'covered': 18, 'missed': 8}, 'METHOD': {'covered': 1, 'missed': 0}})",566.0,18.0,Handle fragment grouping of a reaction that specifies certain disconnected components  are actually considered a single molecule.,This method handles fragment grouping of a reaction that specifies certain disconnected components are actually considered a single molecule,A single molecule is a reaction that specifies certain disconnected components.,0.253068547939175,Manipulate the grouping of fragments of a reaction that specifies that some disconnected components are actually considered a single molecule.,Not Valid,"private void handleFragmentGrouping(IReaction rxn, CxSmilesState cxstate){
        List<IAtomContainer> reactants = rxn.getReactants().atomContainers();
        List<IAtomContainer> products = rxn.getProducts().atomContainers();
        List<IAtomContainer> agents = rxn.getAgents().atomContainers();
        List<IAtomContainer> all = new ArrayList<>(reactants.size() + products.size() + agents.size());
        all.addAll(reactants);
        all.addAll(products);
        all.addAll(agents);
        for (IAtomContainer mol : all) {
            for (IAtom atom : mol.atoms()) {
                if (cxstate.fragmentMap.containsKey(atom)) {
                    int fragment = cxstate.fragmentMap.get(atom);
                    if (fragment > 0) {
                        IAtomContainer frag = new AtomContainer();
                        frag.setID(Integer.toString(fragment));
                        frag.addAtom(atom);
                        rxn.addAtomContainer(frag);
                        cxstate.fragmentMap.put(atom, 0);
                    }
                }
            }
        }       
 }","private void handleFragmentGrouping(IReaction rxn, CxSmilesState cxstate){
        List<IAtomContainer> reactants = rxn.getReactants().atomContainers();
        List<IAtomContainer> products = rxn.getProducts().atomContainers();
        List<IAtomContainer> agents = rxn.getAgents().atomContainers();
    
        // handle fragment grouping
        for (int i = 0; i < cxstate.fragmentGroups.size(); i++) {
            List<IAtomContainer> mols = new ArrayList<>();
            mols.addAll(reactants);
            mols.addAll(products);
            mols.addAll(agents);
            FragmentGroup group = cxstate.fragmentGroups.get(i);
            for (int j = 0; j < group.fragments.size(); j++) {
                int fragment = group.fragments.get(j);
                if (fragment < mols.size()) {
                    IAtomContainer mol = mols.get(fragment);
                    if (mol != null) {
                        mol.setProperty(CDKConstants.TITLE, ""Fragment "" + (i + 1) + ""."" + (j + 1));
                        mols.set(fragment, null);
                    }
                }
            }
        }       
 }","private void handleFragmentGrouping(IReaction rxn, CxSmilesState cxstate){
        // handle fragment grouping
        if (cxstate.fragmentGrouping != null) {
            for (int i = 0; i < cxstate.fragmentGrouping.length; i++) {
                int group = cxstate.fragmentGrouping[i];
                if (group > 0) {
                    IAtomContainer mol = rxn.getReactants().getAtomContainer(i);
                    if (mol != null) {
                        IAtomContainer newMol = rxn.getBuilder().newInstance(IAtomContainer.class, mol);
                        newMol.setProperty(CDKConstants.TITLE, mol.getProperty(CDKConstants.TITLE));
                        rxn.getReactants().removeAtomContainer(i);
                        rxn.getReactants().addAtomContainer(group - 1, newMol);
                    }
                }
            }
        }       
 }",Not Valid,NOT PASS,NOT PASS,NOT PASS,None,  0.2338490619325414,  0.1812571605652793,  0.25493230823596075,None,None,436.0,0.7689594356261023,472.0,0.8324514991181657,427.0,0.7530864197530864,211.0,0.9952830188679245,144.0,0.993103448275862,226.0,0.9955947136563876,4.0,0.2,6.0,0.2857142857142857,11.0,0.6111111111111112
754,matsim-libs,"public synchronized List<? extends PlanElement> calcRoute(final String mainMode, final Facility fromFacility, final Facility toFacility, final double departureTime, final Person person){
    Gbl.assertNotNull(fromFacility);
    Gbl.assertNotNull(toFacility);
    RoutingModule module = routingModules.get(mainMode);
    if (module != null) {
        List<? extends PlanElement> trip = module.calcRoute(fromFacility, toFacility, departureTime, person);
        if (trip == null) {
            trip = fallbackRoutingModule.calcRoute(fromFacility, toFacility, departureTime, person);
        }
        for (Leg leg : TripStructureUtils.getLegs(trip)) {
            TripStructureUtils.setRoutingMode(leg, mainMode);
        }
        return trip;
    }
    throw new UnknownModeException(""unregistered main mode |"" + mainMode + ""|: does not pertain to "" + routingModules.keySet());
}",calcRoute,org/matsim/core/router/TripRouter.java,/matsim/src/main/java/org/matsim/core/router/TripRouter.java,"/**
         * Routes a trip between the given O/D pair, with the given main mode.
         *
         * @param mainMode the main mode for the trip
         * @param fromFacility a {@link Facility} representing the departure location
         * @param toFacility a {@link Facility} representing the arrival location
         * @param departureTime the departure time
         * @param person the {@link Person} to route
         * @return a list of {@link PlanElement}, in proper order, representing the trip.
         *
         * @throws UnknownModeException if no RoutingModule is registered for the
         * given mode.
         */",145-190,"('calcRoute', {'INSTRUCTION': {'covered': 46, 'missed': 9}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 12, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",151.0,15.0,"Routes a trip between the given O/D pair, with the given main mode.",Calculate the route between the given inputs with the given main mode,The given main mode is used to route a trip between the O/D pair.,0.531367862154735,"Routes a path between the given O/D pair, with the given main mode."," public synchronized List<? extends PlanElement> calcRoute(final String mainMode, final Facility fromFacility, final Facility toFacility, final double departureTime, final Person person){
	 		Preconditions.checkNotNull(mainMode);
 		Preconditions.checkNotNull(fromFacility);
 		Preconditions.checkNotNull(toFacility);
 		Preconditions.checkNotNull(person);
 
 		RoutingModule routingModule = routingModules.get(mainMode);
 		if (routingModule == null) {
 			log.error(""No routing module for mode "" + mainMode + "" found. Using fallback routing module."");
 			routingModule = fallbackRoutingModule;
 		}
 
 		return routingModule.calcRoute(fromFacility, toFacility, departureTime, person);
 	}"," public synchronized List<? extends PlanElement> calcRoute(final String mainMode, final Facility fromFacility, final Facility toFacility, final double departureTime, final Person person){
	 		Preconditions.checkNotNull(mainMode);
 		Preconditions.checkNotNull(fromFacility);
 		Preconditions.checkNotNull(toFacility);
 		Preconditions.checkNotNull(person);
 
 		RoutingModule routingModule = routingModules.get(mainMode);
 		if (routingModule == null) {
 			log.error(""No routing module for mode "" + mainMode + "" found. Using fallback routing module."");
 			routingModule = fallbackRoutingModule;
 		}
 
 		return routingModule.calcRoute(fromFacility, toFacility, departureTime, person);
 	}"," public synchronized List<? extends PlanElement> calcRoute(final String mainMode, final Facility fromFacility, final Facility toFacility, final double departureTime, final Person person){
	 		Preconditions.checkNotNull(mainMode);
 		Preconditions.checkNotNull(fromFacility);
 		Preconditions.checkNotNull(toFacility);
 		Preconditions.checkNotNull(person);
 
 		RoutingModule routingModule = routingModules.get(mainMode);
 		if (routingModule == null) {
 			log.error(""No routing module found for mode "" + mainMode + ""."");
 			return fallbackRoutingModule.calcRoute(fromFacility, toFacility, departureTime, person);
 		}
 
 		return routingModule.calcRoute(fromFacility, toFacility, departureTime, person);
 	}"," public synchronized List<? extends PlanElement> calcRoute(final String mainMode, final Facility fromFacility, final Facility toFacility, final double departureTime, final Person person){
	 		Preconditions.checkNotNull(mainMode);
 		Preconditions.checkNotNull(fromFacility);
 		Preconditions.checkNotNull(toFacility);
 		Preconditions.checkNotNull(person);
 
 		RoutingModule routingModule = routingModules.get(mainMode);
 		if (routingModule == null) {
 			log.error(""No routing module for mode "" + mainMode + "" found. Using fallback routing module."");
 			routingModule = fallbackRoutingModule;
 		}
 
 		return routingModule.calcRoute(fromFacility, toFacility, departureTime, person);
 	}",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5253061617587824,  0.5253061617587824,  0.5253061617587824,  0.5821914865313357,85.0,0.5592105263157895,85.0,0.5592105263157895,85.0,0.5592105263157895,81.0,0.5328947368421053,0.0,0.0,0.0,0.0,15.0,0.1271186440677966,6.0,0.42857142857142855,1.0,0.07142857142857142,14.0,0.9333333333333333
755,acs-aem-commons,"private Optional<Class> detectTypeFromName(String name){
    boolean isArray = false;
    Class detectedClass = Object.class;
    if (name.contains(""@"")) {
        String typeStr = StringUtils.substringAfter(name, ""@"");
        if (typeStr.contains(""["")) {
            typeStr = StringUtils.substringBefore(typeStr, ""["");
        }
        detectedClass = getClassFromName(typeStr);
    }
    if (name.endsWith(""]"")) {
        isArray = true;
        String delimiter = StringUtils.substringBetween(name, ""["", ""]"");
        if (!StringUtils.isEmpty(delimiter)) {
            String colName = convertHeaderName(name);
            delimiters.put(colName, delimiter);
        }
    }
    if (isArray) {
        return getArrayType(Optional.of(detectedClass));
    } else {
        return Optional.of(detectedClass);
    }
}",detectTypeFromName,com/adobe/acs/commons/data/Spreadsheet.java,/bundle/src/main/java/com/adobe/acs/commons/data/Spreadsheet.java,"/**
     * Look for type hints in the name of a column to extract a usable type.
     * Also look for array hints as well. <br>
     * Possible formats:
     * <ul>
     * <li>column-name - A column named ""column-name"" </li>
     * <li>col@int - An integer column named ""col"" </li>
     * <li>col2@int[] - An integer array colum named ""col2"", assumes standard
     * delimiter (,) </li>
     * <li>col3@string[] or col3@[] - A String array named ""col3"", assumes
     * standard delimiter (,)</li>
     * <li>col4@string[||] - A string array where values are using a custom
     * delimiter (||)</li>
     * </ul>
     *
     * @param name
     * @return
     */",306-347,"('detectTypeFromName', {'INSTRUCTION': {'covered': 57, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",162.0,16.0,Look for type hints in the name of a column to extract a usable type.,Infer types from their column's names,The name of the column should give hints about the type.,0.352398113042188,Look for type hints in the name of a column to retrieve a usable type.,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,15.0,0.9375,1.0,0.0625,12.0,0.75
756,matsim-libs,"private Map<Id<Node>, Node> findCluster(final Node startNode, final Network network){
    final Map<Node, DoubleFlagRole> nodeRoles = new HashMap<>(network.getNodes().size());
    ArrayList<Node> pendingForward = new ArrayList<>();
    ArrayList<Node> pendingBackward = new ArrayList<>();
    TreeMap<Id<Node>, Node> clusterNodes = new TreeMap<>();
    clusterNodes.put(startNode.getId(), startNode);
    DoubleFlagRole r = getDoubleFlag(startNode, nodeRoles);
    r.forwardFlag = true;
    r.backwardFlag = true;
    pendingForward.add(startNode);
    pendingBackward.add(startNode);
    // step through the network in forward mode
    while (pendingForward.size() > 0) {
        int idx = pendingForward.size() - 1;
        // get the last element to prevent object shifting in the array
        Node currNode = pendingForward.remove(idx);
        for (Link link : currNode.getOutLinks().values()) {
            Node node = link.getToNode();
            r = getDoubleFlag(node, nodeRoles);
            if (!r.forwardFlag) {
                r.forwardFlag = true;
                pendingForward.add(node);
            }
        }
    }
    // now step through the network in backward mode
    while (pendingBackward.size() > 0) {
        int idx = pendingBackward.size() - 1;
        // get the last element to prevent object shifting in the array
        Node currNode = pendingBackward.remove(idx);
        for (Link link : currNode.getInLinks().values()) {
            Node node = link.getFromNode();
            r = getDoubleFlag(node, nodeRoles);
            if (!r.backwardFlag) {
                r.backwardFlag = true;
                pendingBackward.add(node);
                if (r.forwardFlag) {
                    // the node can be reached forward and backward, add it to the cluster
                    clusterNodes.put(node.getId(), node);
                }
            }
        }
    }
    return clusterNodes;
}",findCluster,org/matsim/core/network/algorithms/NetworkCleaner.java,/matsim/src/main/java/org/matsim/core/network/algorithms/NetworkCleaner.java,"/**
         * Finds the cluster of nodes of which <code>startNode</code> is part of. The cluster
         * contains all nodes which can be reached starting at <code>startNode</code>
         * and from where it is also possible to return again to <code>startNode</code>.
         *
         * @param startNode the node to start building the cluster
         * @param network the network the startNode is part of
         * @return cluster of nodes of which <code>startNode</code> is part of
         */",51-109,"('findCluster', {'INSTRUCTION': {'covered': 142, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 35, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",344.0,18.0,Finds the cluster of nodes of which <code>startNode</code> is part of.,Get the cluster of nodes in which the given input startNode is part of,The cluster of the startNode is found.,0.490835011860756,Finds the cluster of nodes of which <code>startNode</code> is a part.,"private Map<Id<Node>, Node> findCluster(final Node startNode, final Network network){
	 	Map<Id<Node>, Node> cluster = new HashMap<Id<Node>, Node>();
 	cluster.put(startNode.getId(), startNode);
 	List<Node> todo = new ArrayList<Node>();
 	todo.add(startNode);
 	while (!todo.isEmpty()){
 		Node current = todo.remove(0);
 		for (Link link : current.getOutLinks().values()){
 			Node to = link.getToNode();
 			if (!cluster.containsKey(to.getId())){
 				cluster.put(to.getId(), to);
 				todo.add(to);
 			}
 		}
 		for (Link link : current.getInLinks().values()){
 			Node from = link.getFromNode();
 			if (!cluster.containsKey(from.getId())){
 				cluster.put(from.getId(), from);
 				todo.add(from);
 			}
 		}
 	}
 	return cluster;		
 }","private Map<Id<Node>, Node> findCluster(final Node startNode, final Network network){
	 	Map<Id<Node>, Node> cluster = new HashMap<Id<Node>, Node>();
 	cluster.put(startNode.getId(), startNode);
 	List<Node> todo = new ArrayList<Node>();
 	todo.add(startNode);
 	while(todo.size() > 0){
 		Node current = todo.remove(0);
 		for(Link l : current.getOutLinks().values()){
 			Node to = l.getToNode();
 			if(!cluster.containsKey(to.getId())){
 				cluster.put(to.getId(), to);
 				todo.add(to);
 			}
 		}
 		for(Link l : current.getInLinks().values()){
 			Node from = l.getFromNode();
 			if(!cluster.containsKey(from.getId())){
 				cluster.put(from.getId(), from);
 				todo.add(from);
 			}
 		}
 	}
 	return cluster;		
 }","private Map<Id<Node>, Node> findCluster(final Node startNode, final Network network){
	 	Map<Id<Node>, Node> cluster = new HashMap<>();
 	cluster.put(startNode.getId(), startNode);
 	List<Node> nodesToCheck = new ArrayList<>();
 	nodesToCheck.add(startNode);
 	while (!nodesToCheck.isEmpty()){
 		Node currentNode = nodesToCheck.remove(0);
 		for (Link link : currentNode.getOutLinks().values()){
 			Node toNode = link.getToNode();
 			if (!cluster.containsKey(toNode.getId())){
 				cluster.put(toNode.getId(), toNode);
 				nodesToCheck.add(toNode);
 			}
 		}
 		for (Link link : currentNode.getInLinks().values()){
 			Node fromNode = link.getFromNode();
 			if (!cluster.containsKey(fromNode.getId())){
 				cluster.put(fromNode.getId(), fromNode);
 				nodesToCheck.add(fromNode);
 			}
 		}
 	}
 	return cluster;		
 }","private Map<Id<Node>, Node> findCluster(final Node startNode, final Network network){
	 	Map<Id<Node>, Node> cluster = new HashMap<Id<Node>, Node>();
 	cluster.put(startNode.getId(), startNode);
 	List<Node> todo = new ArrayList<Node>();
 	todo.add(startNode);
 	while (!todo.isEmpty()){
 		Node current = todo.remove(0);
 		for (Link link : current.getOutLinks().values()){
 			Node to = link.getToNode();
 			if (!cluster.containsKey(to.getId())){
 				cluster.put(to.getId(), to);
 				todo.add(to);
 			}
 		}
 		for (Link link : current.getInLinks().values()){
 			Node from = link.getFromNode();
 			if (!cluster.containsKey(from.getId())){
 				cluster.put(from.getId(), from);
 				todo.add(from);
 			}
 		}
 	}
 	return cluster;		
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3878996040228006,  0.3935257874003978,  0.3878996040228006,  0.39393880784620805,188.0,0.5449275362318841,188.0,0.5449275362318841,188.0,0.5449275362318841,192.0,0.5565217391304348,8.0,0.034782608695652174,0.0,0.0,26.0,0.11353711790393013,7.0,0.4666666666666667,2.0,0.16666666666666666,8.0,0.6666666666666666
757,cdk,"private void applyMDLValenceModel(IAtom atom, int explicitValence, int unpaired){
    if (atom.getValency() != null) {
        if (atom.getValency() >= explicitValence)
            atom.setImplicitHydrogenCount(atom.getValency() - (explicitValence - unpaired));
        else
            atom.setImplicitHydrogenCount(0);
    } else {
        Integer element = atom.getAtomicNumber();
        if (element == null)
            element = 0;
        Integer charge = atom.getFormalCharge();
        if (charge == null)
            charge = 0;
        int implicitValence = MDLValence.implicitValence(element, charge, explicitValence);
        if (implicitValence < explicitValence) {
            atom.setValency(explicitValence);
            atom.setImplicitHydrogenCount(0);
        } else {
            atom.setValency(implicitValence);
            atom.setImplicitHydrogenCount(implicitValence - explicitValence);
        }
    }
}",applyMDLValenceModel,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,"/**
     * Applies the MDL valence model to atoms using the explicit valence (bond
     * order sum) and charge to determine the correct number of implicit
     * hydrogens. The model is not applied if the explicit valence is less than
     * 0 - this is the case when a query bond was read for an atom.
     *
     * @param atom            the atom to apply the model to
     * @param unpaired        unpaired electron count
     * @param explicitValence the explicit valence (bond order sum)
     */",566-599,"('applyMDLValenceModel', {'INSTRUCTION': {'covered': 61, 'missed': 9}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",158.0,27.0,Applies the MDL valence model to atoms using the explicit valence (bond  order sum) and charge to determine the correct number of implicit  hydrogens.,This method applies the MDL valence model to atoms using the explicit valence and charge to determine the correct number of implicit hydrogens,The MDL model is applied to atoms using the explicit valence and charge to determine the correct number of implicit hydrogens.,0.428813681600703,Applies the MDL valence model to atoms using explicit valence (sum of bond order) and charge to determine the correct number of implicit hydrogens.,"private void applyMDLValenceModel(IAtom atom, int explicitValence, int unpaired){
        int charge = atom.getFormalCharge();
        int implicitHCount = 0;
        if (charge == 0) {
            implicitHCount = explicitValence - unpaired;
        } else if (charge > 0) {
            implicitHCount = explicitValence - unpaired - charge;
        } else {
            implicitHCount = explicitValence - unpaired + charge;
        }
        if (implicitHCount < 0)
            implicitHCount = 0;
        atom.setImplicitHydrogenCount(implicitHCount);      
 }",Not Valid,Not Valid,"private void applyMDLValenceModel(IAtom atom, int explicitValence, int unpaired){
        int charge = atom.getFormalCharge();
        int implicitH = 0;
        if (charge != 0) {
            if (charge > 0) {
                if (explicitValence + charge > 6)
                    implicitH = explicitValence + charge - 6;
            } else {
                if (explicitValence + charge < -6)
                    implicitH = explicitValence + charge + 6;
            }
        } else {
            if (explicitValence > 6)
                implicitH = explicitValence - 6;
            else if (explicitValence < -6)
                implicitH = explicitValence + 6;
        }
        atom.setImplicitHydrogenCount(implicitH);
        atom.setFormalCharge(0);
    }",NOT PASS,Not Valid,NOT PASS,Not Valid,  0.29282461353340566,None,  0.379187002495336,None,113.0,0.710691823899371,None,None,107.0,0.6729559748427673,None,None,None,None,61.0,0.488,None,None,7.0,0.28,5.0,0.2,8.0,0.32
758,weblogic-kubernetes-operator,"private void addToSplitResult(DataEntry entry){
    while (entry.getRemainingLength() > 0) {
        remainingRoom -= entry.addToMap(current, remainingRoom);
        if (remainingRoom == 0) {
            recordSplitResult();
            startSplitResult();
        }
    }
}",addToSplitResult,oracle/kubernetes/operator/helpers/ConfigMapSplitter.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/ConfigMapSplitter.java,"/**
   * Adds the specified data entry to one or more split results, recording its location if it is not wholly
   * in the first split result.
   * @param entry a data entry
   */",74-87,"('addToSplitResult', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,26.0,"Adds the specified data entry to one or more split results, recording its location if it is not wholly  in the first split result.",Adds the specified data entry to one or more split results,"If the data entry is not wholly in the first split result, it is recorded as a location.",0.197241656435893,"Adds the specified data entry to one or more split results, saving its location if it is not entirely in the first split result."," private void addToSplitResult(DataEntry entry){
    if (entry.getSize() > remainingRoom) {
      recordSplitResult();
      startSplitResult();
    }
    current.put(entry.getKey(), entry.getValue());
    remainingRoom -= entry.getSize();
  }"," private void addToSplitResult(DataEntry entry){
    if (entry.getSize() > remainingRoom) {
      recordSplitResult();
      startSplitResult();
    }
    current.put(entry.getKey(), entry.getValue());
    remainingRoom -= entry.getSize();
  }"," private void addToSplitResult(DataEntry entry){
    if (entry.size() > remainingRoom) {
      recordSplitResult();
      startSplitResult();
    }
    current.put(entry.key, entry.value);
    remainingRoom -= entry.size();
  }"," private void addToSplitResult(DataEntry entry){
    if (entry.size() > remainingRoom) {
      recordSplitResult();
      startSplitResult();
    }
    current.put(entry.key, entry.value);
    remainingRoom -= entry.size();
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4575323842301183,  0.4575323842301183,  0.4665740218697231,  0.4665740218697231,30.0,0.5454545454545454,30.0,0.5454545454545454,28.0,0.5490196078431373,28.0,0.5490196078431373,0.0,0.0,8.0,0.14545454545454545,8.0,0.14545454545454545,14.0,0.56,2.0,0.08,19.0,0.76
759,jackson-databind,"public static String quotedOr(Object str, String forNull){
    if (str == null) {
        return forNull;
    }
    return String.format(""\""%s\"""", str);
}",quotedOr,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * Returns either quoted value (with double-quotes) -- if argument non-null
     * String -- or String NULL (no quotes) (if null).
     *
     * @since 2.9
     */",648-659,"('quotedOr', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,26.0,Returns either quoted value (with double-quotes) -- if argument non-null  String -- or String NULL (no quotes) (if null).,This method returns append quotes if the input is not null,"If the argument is non-null, the value will be quoted or null.",0.77976307005835,Returns either a value in quotation marks (with double quotes) -- if the argument is not null String -- or String NULL (no quotation marks) (if null).," public static String quotedOr(Object str, String forNull){
        if (str == null) {
            return forNull;
        }
        return quoted(str);     
 }"," public static String quotedOr(Object str, String forNull){
        if(str == null){
            return forNull;
        }
        return ""\"""" + str + ""\"""";
    }"," public static String quotedOr(Object str, String forNull){
        if (str == null) {
            return forNull;
        }
        return quote(str.toString());
    }"," public static String quotedOr(Object str, String forNull){
        if (str == null) {
            return forNull;
        }
        return ""\"""" + str + ""\"""";
    }",NOT PASS,NOT PASS,PASS,NOT PASS,  0.8158085944666407,  0.7907607892173786,  0.7907607892173786,  0.806415464462903,5.0,0.14285714285714285,8.0,0.22857142857142856,8.0,0.22857142857142856,7.0,0.2,4.0,0.125,4.0,0.125,5.0,0.14285714285714285,18.0,0.9,12.0,0.42857142857142855,18.0,0.9
760,dataverse,"public static boolean isTrue(String s){
    return (s != null) && TRUE_VALUES.contains(s.trim().toLowerCase());
}",isTrue,edu/harvard/iq/dataverse/util/StringUtil.java,/src/main/java/edu/harvard/iq/dataverse/util/StringUtil.java,"/**
     * Checks if {@code s} contains a ""truthy"" value.
     * @param s
     * @return {@code true} iff {@code s} is not {@code null} and is ""truthy"" word.
     * @see #TRUE_VALUES
     */",80-88,"('isTrue', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,14.0,"Checks if {@code s} contains a ""truthy"" value.",Verify if the input contains a true value,"If @code s contains a ""truthy"" value, it's checked.",0.719791179358768,"Checks whether {@code s} contains a ""truthy"" value."," public static boolean isTrue(String s){
        return TRUE_VALUES.contains(s);     
 }"," public static boolean isTrue(String s){
        return TRUE_VALUES.contains(s.toLowerCase());       
 }"," public static boolean isTrue(String s){
        return TRUE_VALUES.contains(s);     
 }"," public static boolean isTrue(String s){
        return TRUE_VALUES.contains(s);     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4547159719612961,  0.5839688431806487,  0.4547159719612961,  0.4547159719612961,14.0,0.42424242424242425,10.0,0.30303030303030304,14.0,0.42424242424242425,14.0,0.42424242424242425,4.0,0.17391304347826086,0.0,0.0,0.0,0.0,5.0,0.5555555555555556,1.0,0.1111111111111111,7.0,0.7
761,cdk,"static int indexOfHetro(int[] cycle, int[] contribution){
    int index = -1;
    for (int i = 0; i < cycle.length - 1; i++) {
        if (contribution[cycle[i]] == 2)
            index = index == -1 ? i : -2;
    }
    return index;
}",indexOfHetro,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,"/**
     * Find the index of a hetroatom in a cycle. A hetroatom in MMFF is the unique atom that
     * contributes a pi-lone-pair to the aromatic system.
     *
     * @param cycle        aromatic cycle, |C| = 5
     * @param contribution vector of p electron contributions from each vertex
     * @return index of hetroatom, if none found index is < 0.
     */",316-330,"('indexOfHetro', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,10.0,Find the index of a hetroatom in a cycle.,Get the index of a hetroatom in a cycle. ,The hetroatom's index is found in a cycle.,0.238992412887403,Find the index of a hetroatoma in a cycle.,"static int indexOfHetro(int[] cycle, int[] contribution){
        for (int i = 0; i < cycle.length; i++) {
            if (contribution[cycle[i]] == 0) return i;
        }
        return -1;      
 }","static int indexOfHetro(int[] cycle, int[] contribution){
        for (int i = 0; i < cycle.length; i++) {
            if (contribution[cycle[i]] == 0) return i;
        }
        return -1;      
 }","static int indexOfHetro(int[] cycle, int[] contribution){
        for (int i = 0; i < cycle.length; i++) {
            if (contribution[cycle[i]] == 1) return i;
        }
        return -1;
    }","static int indexOfHetro(int[] cycle, int[] contribution){
        for (int i = 0; i < cycle.length; i++) {
            if (contribution[cycle[i]] == 1) return i;
        }
        return -1;      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5965806872975044,  0.5965806872975044,  0.5977588904216828,  0.5977588904216828,21.0,0.3,21.0,0.3,21.0,0.3,21.0,0.3,0.0,0.0,1.0,0.018518518518518517,1.0,0.018518518518518517,1.0,0.1,1.0,0.1,5.0,0.5
762,cdk,"private static int findOther(int[] vs, int u, int x){
    for (int v : vs) {
        if (v != u && v != x)
            return v;
    }
    throw new IllegalArgumentException(""vs[] did not contain another vertex"");
}",findOther,org/openscience/cdk/hash/stereo/DoubleBondElementEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/DoubleBondElementEncoderFactory.java,"/**
     * Finds a vertex in 'vs' which is not 'u' or 'x'.
     * .
     * @param vs fixed size array of 3 elements
     * @param u  a vertex in 'vs'
     * @param x  another vertex in 'vs'
     * @return the other vertex
     */",119-132,"('findOther', {'INSTRUCTION': {'covered': 24, 'missed': 5}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,17.0,Finds a vertex in 'vs' which is not 'u' or 'x'.,Get a vertex in 'vs' which is not 'u' or 'x'.,A person finds a difference between 'u' and 'x' in a piece of paper.,1.36243093621775,Find a vertex in 'vs' that is not 'u' or 'x'.," private static int findOther(int[] vs, int u, int x){
        for (int v : vs)
            if (v != u && v != x)
                return v;
        throw new IllegalStateException(""Could not find other vertex"");
    }"," private static int findOther(int[] vs, int u, int x){
        for (int v : vs)
            if (v != u && v != x)
                return v;
        throw new IllegalStateException(""Could not find other vertex"");
    }"," private static int findOther(int[] vs, int u, int x){
        for (int v : vs)
            if (v != u && v != x)
                return v;
        throw new IllegalStateException(""Could not find other vertex"");
    }"," private static int findOther(int[] vs, int u, int x){
        for (int v : vs)
            if (v != u && v != x)
                return v;
        throw new IllegalStateException(""Could not find other vertex"");
    }",PASS,PASS,PASS,PASS,  0.8384796123082541,  0.8384796123082541,  0.8384796123082541,  0.8384796123082541,4.0,0.08333333333333333,4.0,0.08333333333333333,4.0,0.08333333333333333,4.0,0.08333333333333333,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.08333333333333333,2.0,0.16666666666666666,13.0,0.8666666666666667
763,cdk,"private String parseLevelOfTheory(String line){
    StringBuffer summary = new StringBuffer();
    summary.append(line);
    try {
        do {
            line = input.readLine().trim();
            summary.append(line);
        } while (!(line.indexOf('@') >= 0));
    } catch (Exception exc) {
        logger.debug(""syntax problem while parsing summary of g98 section: "");
        logger.debug(exc);
    }
    logger.debug(""parseLoT(): "" + summary.toString());
    StringTokenizer st1 = new StringTokenizer(summary.toString(), ""\\"");
    if (st1.countTokens() < 6) {
        return null;
    }
    for (int i = 0; i < 4; ++i) {
        st1.nextToken();
    }
    return st1.nextToken() + ""/"" + st1.nextToken();
}",parseLevelOfTheory,org/openscience/cdk/io/Gaussian98Reader.java,/storage/io/src/main/java/org/openscience/cdk/io/Gaussian98Reader.java,"/**
     * Select the theory and basis set from the first archive line.
     *
     * @param line Description of the Parameter
     * @return Description of the Return Value
     */",463-496,"('parseLevelOfTheory', {'INSTRUCTION': {'covered': 67, 'missed': 9}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 12, 'missed': 4}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",165.0,12.0,Select the theory and basis set from the first archive line.,Get the theory and basis set from the first archive line.,The basis and theory can be found in the first archive line.,0.237863388574842,Select the theory and base set from the first archive line.," private String parseLevelOfTheory(String line){
        StringTokenizer st = new StringTokenizer(line);
        String theory = st.nextToken();
        String basis = st.nextToken();
        return theory + "" "" + basis;
    }"," private String parseLevelOfTheory(String line){
        StringTokenizer st = new StringTokenizer(line);
        String theory = st.nextToken();
        String basis = st.nextToken();
        return theory + "" "" + basis;
    }"," private String parseLevelOfTheory(String line){
        StringTokenizer st = new StringTokenizer(line);
        String basis = st.nextToken();
        String theory = st.nextToken();
        return basis + "" "" + theory;
    }"," private String parseLevelOfTheory(String line){
        StringTokenizer st = new StringTokenizer(line);
        String theory = st.nextToken();
        String baseSet = st.nextToken();
        return theory + "" "" + baseSet;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.15617658216327657,  0.15617658216327657,  0.15617658216327657,  0.15617658216327657,135.0,0.8132530120481928,135.0,0.8132530120481928,135.0,0.8132530120481928,135.0,0.8132530120481928,0.0,0.0,2.0,0.045454545454545456,4.0,0.09090909090909091,1.0,0.08333333333333333,1.0,0.08333333333333333,7.0,0.5384615384615384
767,incubator-shenyu,"public ShenyuAdminResult deleteShenyuDicts(@RequestBody @NotEmpty final List<@NotBlank String> ids){
    Integer deleteCount = shenyuDictService.deleteShenyuDicts(ids);
    return ShenyuAdminResult.success(ShenyuResultMessage.DELETE_SUCCESS, deleteCount);
}",deleteShenyuDicts,org/apache/shenyu/admin/controller/ShenyuDictController.java,/shenyu-admin/src/main/java/org/apache/shenyu/admin/controller/ShenyuDictController.java,"/**
     * batch delete some shenyu dicts by some id list.
     *
     * @param ids shenyu dict id list.
     * @return {@linkplain ShenyuAdminResult}
     */",126-136,"('deleteShenyuDicts', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,10.0,batch delete some shenyu dicts by some id list.,Delete some shenyu dicts by some id list.,Some shenyu dicts should be deleted by some id list.,0.576351733677674,delete in batches some shenyu dicts by a list of identifiers.," public ShenyuAdminResult deleteShenyuDicts(@RequestBody @NotEmpty final List<@NotBlank String> ids){
        Integer deleteCount = shenyuDictService.deleteByIds(ids);
        return ShenyuAdminResult.success(ShenyuResultMessage.DELETE_SUCCESS, deleteCount);      
 }"," public ShenyuAdminResult deleteShenyuDicts(@RequestBody @NotEmpty final List<@NotBlank String> ids){
        Integer deleteCount = shenyuDictService.deleteByIds(ids);
        return ShenyuAdminResult.success(ShenyuResultMessage.DELETE_SUCCESS, deleteCount);      
 }"," public ShenyuAdminResult deleteShenyuDicts(@RequestBody @NotEmpty final List<@NotBlank String> ids){
        Integer deleteCount = shenyuDictService.deleteByIds(ids);
        return ShenyuAdminResult.success(ShenyuResultMessage.DELETE_SUCCESS, deleteCount);      
 }"," public ShenyuAdminResult deleteShenyuDicts(@RequestBody @NotEmpty final List<@NotBlank String> ids){
        Integer deleteCount = shenyuDictService.deleteByIds(ids);
        return ShenyuAdminResult.success(ShenyuResultMessage.DELETE_SUCCESS, deleteCount);      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8965864240785307,  0.8965864240785307,  0.8965864240785307,  0.8965864240785307,1.0,0.023809523809523808,1.0,0.023809523809523808,1.0,0.023809523809523808,1.0,0.023809523809523808,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.2,7.0,0.5833333333333334,6.0,0.5454545454545454
770,jooby,"public static Usage parameterNameNotPresent(@Nonnull Parameter parameter){
    Executable executable = parameter.getDeclaringExecutable();
    int p = Stream.of(executable.getParameters()).collect(Collectors.toList()).indexOf(parameter);
    String message = ""Unable to provision parameter at position: '"" + p + ""', require by: "" + ProvisioningException.toString(parameter.getDeclaringExecutable()) + "". Parameter's name is missing"";
    return new Usage(message, ""bean-converter-parameter-name-missing"");
}",parameterNameNotPresent,io/jooby/Usage.java,/jooby/src/main/java/io/jooby/Usage.java,"/**
   * Thrown when the reflective bean converter has no access to a parameter name. Compilation
   * must be done using <code>parameters</code> compiler option.
   *
   * @param parameter Parameter.
   * @return Usage exception.
   */",45-59,"('parameterNameNotPresent', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",80.0,14.0,Thrown when the reflective bean converter has no access to a parameter name.,Check if the parameter name is not present,Thrown when the bean is not able to access a name.,0.200686079023569,Lifted when the reflective bean converter does not have access to a parameter name.," public static Usage parameterNameNotPresent(@Nonnull Parameter parameter){
    return apt(""Parameter name not found: `"" + parameter.getName()
        + ""`. Make sure Jooby annotation processor is configured properly."", ""parameter-name-not-present"");
  }"," public static Usage parameterNameNotPresent(@Nonnull Parameter parameter){
    return apt(""Parameter name not present: `"" + parameter.getName() + ""`."", ""parameter-name-not-present"");   
 }"," public static Usage parameterNameNotPresent(@Nonnull Parameter parameter){
    return apt(""Parameter name not present: `"" + parameter.getName() + ""`."", ""parameter-name-not-present"");
  }"," public static Usage parameterNameNotPresent(@Nonnull Parameter parameter){
    return apt(""Parameter name not present: `"" + parameter.getName() + ""`."", ""parameter-name-not-present"");
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.1813370728349415,  0.17423629616404315,  0.17423629616404315,  0.17423629616404315,58.0,0.7160493827160493,58.0,0.7160493827160493,58.0,0.7160493827160493,58.0,0.7160493827160493,2.0,0.06896551724137931,2.0,0.06896551724137931,2.0,0.06896551724137931,12.0,0.8571428571428571,4.0,0.26666666666666666,7.0,0.5
771,cdk,"private StereoEncoderFactory makeStereoEncoderFactory(){
    if (stereoEncoders.isEmpty()) {
        return StereoEncoderFactory.EMPTY;
    } else if (stereoEncoders.size() == 1) {
        return stereoEncoders.get(0);
    } else {
        StereoEncoderFactory factory = new ConjugatedEncoderFactory(stereoEncoders.get(0), stereoEncoders.get(1));
        for (int i = 2; i < stereoEncoders.size(); i++) {
            factory = new ConjugatedEncoderFactory(factory, stereoEncoders.get(i));
        }
        return factory;
    }
}",makeStereoEncoderFactory,org/openscience/cdk/hash/HashGeneratorMaker.java,/tool/hash/src/main/java/org/openscience/cdk/hash/HashGeneratorMaker.java,"/**
     * Combines the separate stereo encoder factories into a single factory.
     *
     * @return a single stereo encoder factory
     */",272-289,"('makeStereoEncoderFactory', {'INSTRUCTION': {'covered': 50, 'missed': 6}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,11.0,Combines the separate stereo encoder factories into a single factory.,This method combines the separate stereo encoder factories into a single factory,The stereo Encoder factories are combined into a single factory.,0.635240705602855,Combines separate stereo encoder factories into a single factory.,"private StereoEncoderFactory makeStereoEncoderFactory(){
        if(stereoEncoders.isEmpty()){
            return null;
        }
        else if(stereoEncoders.size() == 1){
            return stereoEncoders.get(0);
        }
        else{
            return new StereoEncoderFactory(stereoEncoders);
        }
    }",Empty Method," private StereoEncoderFactory makeStereoEncoderFactory(){
        return new StereoEncoderFactory(stereoEncoders);
    }","private StereoEncoderFactory makeStereoEncoderFactory(){
        if (stereoEncoders.isEmpty()) return null;
        if (stereoEncoders.size() == 1) return stereoEncoders.get(0);
        return new StereoEncoderFactory(stereoEncoders);
    }",NOT PASS,Empty Method,NOT PASS,NOT PASS,  0.31827096654135506,None,  0.27664359545744355,  0.04917050253403171,57.0,0.5377358490566038,None,None,65.0,0.6132075471698113,92.0,0.8679245283018868,None,None,8.0,0.15384615384615385,37.0,0.7115384615384616,4.0,0.3076923076923077,1.0,0.09090909090909091,6.0,0.5454545454545454
772,cdk,"private boolean hasCandidate(int n){
    for (int j = (n * matrix.mCols), end = (j + matrix.mCols); j < end; j++) if (matrix.get(j))
        return true;
    return false;
}",hasCandidate,org/openscience/cdk/isomorphism/UllmannState.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/UllmannState.java,"/**
     * Check if there are any feasible mappings left for the query vertex n. We
     * scan the compatibility matrix to see if any value is > 0.
     *
     * @param n query vertex
     * @return a candidate is present
     */",219-230,"('hasCandidate', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,14.0,Check if there are any feasible mappings left for the query vertex n.,Verify if there are any feasible mappings left for the query vertex,"If there are any feasible mappings left, check them out.",0.275562067462428,Check to see if there are any feasible mappings left for the n query vertex.,"private boolean hasCandidate(int n){
        for (int m = 0; m < matrix.mCols; m++) {
            if (matrix.get(n, m)) return true;
        }
        return false;
    }","private boolean hasCandidate(int n){
        for (int m = 0; m < matrix.mCols; m++) {
            if (matrix.get(n, m)) return true;
        }
        return false;
    }","private boolean hasCandidate(int n){
        for (int m = 0; m < matrix.mCols; m++) {
            if (matrix.get(n, m)) return true;
        }
        return false;
    }","private boolean hasCandidate(int n){
        for (int m = 0; m < matrix.mCols; m++) {
            if (matrix.get(n, m)) return true;
        }
        return false;
    }",PASS,PASS,PASS,PASS,  0.5008071649109211,  0.5008071649109211,  0.48414049824425454,  0.5008071649109211,25.0,0.45454545454545453,25.0,0.45454545454545453,25.0,0.45454545454545453,25.0,0.45454545454545453,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.14285714285714285,5.0,0.3125,8.0,0.5714285714285714
773,cdk,"public void add3DCoordinatesForSinglyBondedLigands(IAtomContainer atomContainer) throws CDKException{
    IAtom refAtom = null;
    IAtom atomC = null;
    int nwanted = 0;
    for (int i = 0; i < atomContainer.getAtomCount(); i++) {
        refAtom = atomContainer.getAtom(i);
        if (refAtom.getAtomicNumber() != IElement.H && hasUnsetNeighbour(refAtom, atomContainer)) {
            IAtomContainer noCoords = getUnsetAtomsInAtomContainer(refAtom, atomContainer);
            IAtomContainer withCoords = getPlacedAtomsInAtomContainer(refAtom, atomContainer);
            if (withCoords.getAtomCount() > 0) {
                atomC = getPlacedHeavyAtomInAtomContainer(withCoords.getAtom(0), refAtom, atomContainer);
            }
            if (refAtom.getFormalNeighbourCount() == 0 && refAtom.getAtomicNumber() == IElement.C) {
                nwanted = noCoords.getAtomCount();
            } else if (refAtom.getFormalNeighbourCount() == 0 && refAtom.getAtomicNumber() != IElement.C) {
                nwanted = 4;
            } else {
                nwanted = refAtom.getFormalNeighbourCount() - withCoords.getAtomCount();
            }
            Point3d[] newPoints = get3DCoordinatesForLigands(refAtom, noCoords, withCoords, atomC, nwanted, DEFAULT_BOND_LENGTH_H, -1);
            for (int j = 0; j < noCoords.getAtomCount(); j++) {
                IAtom ligand = noCoords.getAtom(j);
                Point3d newPoint = rescaleBondLength(refAtom, ligand, newPoints[j]);
                ligand.setPoint3d(newPoint);
                ligand.setFlag(CDKConstants.ISPLACED, true);
            }
            noCoords.removeAllElements();
            withCoords.removeAllElements();
        }
    }
}",add3DCoordinatesForSinglyBondedLigands,org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,"/**
     *  Generate coordinates for all atoms which are singly bonded and have no
     *  coordinates. This is useful when hydrogens are present but have no coordinates.
     *  It knows about C, O, N, S only and will give tetrahedral or trigonal
     *  geometry elsewhere. Bond lengths are computed from covalent radii or taken
     *  out of a parameter set if available. Angles are tetrahedral or trigonal
     *
     * @param  atomContainer  the set of atoms involved
     * @throws CDKException
     * @cdk.keyword           coordinate calculation
     * @cdk.keyword           3D model
     */",77-121,"('add3DCoordinatesForSinglyBondedLigands', {'INSTRUCTION': {'covered': 106, 'missed': 17}, 'BRANCH': {'covered': 12, 'missed': 6}, 'LINE': {'covered': 22, 'missed': 2}, 'COMPLEXITY': {'covered': 6, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",296.0,14.0,Generate coordinates for all atoms which are singly bonded and have no  coordinates.,This method generates the coordinates for all atoms which are singly bonded and have no coordinates,All atoms have no coordinates.,0.171842265585327,Generate coordinates for all atoms that are individually bonded and do not have coordinates.,"public void add3DCoordinatesForSinglyBondedLigands(IAtomContainer atomContainer) throws CDKException{
        for (IAtom atom : atomContainer.atoms()) {
            if (atom.getPoint3d() == null) {
                if (atom.getBondCount() == 1) {
                    IBond bond = atom.getBonds().iterator().next();
                    if (bond.getBegin().getPoint3d() == null || bond.getEnd().getPoint3d() == null) {
                        add3DCoordinatesForSinglyBondedLigand(atom, bond);
                    }
                }
            }
        }
    }","public void add3DCoordinatesForSinglyBondedLigands(IAtomContainer atomContainer) throws CDKException{
        for (IAtom atom : atomContainer.atoms()) {
            if (atom.getPoint3d() == null) {
                if (atom.getBondCount() == 1) {
                    IBond bond = atom.getBonds().iterator().next();
                    if (bond.getBegin().getPoint3d() == null || bond.getEnd().getPoint3d() == null) {
                        add3DCoordinatesForSinglyBondedLigands(atomContainer, bond);
                    }
                }
            }
        }
    }",Not Valid,"public void add3DCoordinatesForSinglyBondedLigands(IAtomContainer atomContainer) throws CDKException{
        for (IAtom atom : atomContainer.atoms()) {
            if (atom.getPoint3d() == null) {
                add3DCoordinatesForSinglyBondedLigand(atomContainer, atom);
            }
        }
    }",NOT PASS,NOT PASS,NOT PASS,Not Valid,  0.15328526537152914,  0.14832403178490133,  0.10325357205921377,None,230.0,0.7744107744107744,230.0,0.7744107744107744,263.0,0.8855218855218855,None,None,2.0,0.019801980198019802,59.0,0.5841584158415841,None,None,5.0,0.29411764705882354,5.0,0.3333333333333333,9.0,0.6428571428571429
774,jackson-databind,"public static List<Class<?>> findSuperClasses(Class<?> cls, Class<?> endBefore, boolean addClassItself){
    List<Class<?>> result = new ArrayList<Class<?>>(8);
    if ((cls != null) && (cls != endBefore)) {
        if (addClassItself) {
            result.add(cls);
        }
        while ((cls = cls.getSuperclass()) != null) {
            if (cls == endBefore) {
                break;
            }
            result.add(cls);
        }
    }
    return result;
}",findSuperClasses,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"/**
     * Method for finding all super classes (but not super interfaces) of given class,
     * starting with the immediate super class and ending in the most distant one.
     * Class itself is included if <code>addClassItself</code> is true.
     *<p>
     * NOTE: mostly/only called to resolve mix-ins as that's where we do not care
     * about fully-resolved types, just associated annotations.
     *
     * @since 2.7
     */",83-108,"('findSuperClasses', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",114.0,30.0,"Method for finding all super classes (but not super interfaces) of given class,  starting with the immediate super class and ending in the most distant one.",This method retrieves all super classes of a given class,The method for finding all super classes in a class is starting with the immediate super class and ending in the most distant one.,0.393550049906369,"Method for finding all super classes (but not super interfaces) of a given class, starting with the immediate superclass and ending with the furthest one.","public static List<Class<?>> findSuperClasses(Class<?> cls, Class<?> endBefore, boolean addClassItself){
        if ((cls == null) || (cls == endBefore) || (cls == Object.class)) {
            return Collections.emptyList();
        }
        List<Class<?>> result = new ArrayList<Class<?>>(8);
        _addSuperClasses(cls, endBefore, result, addClassItself);
        return result;
    }","public static List<Class<?>> findSuperClasses(Class<?> cls, Class<?> endBefore, boolean addClassItself){
        if ((cls == null) || (cls == endBefore) || (cls == Object.class)) {
            return Collections.emptyList();
        }
        List<Class<?>> result = new ArrayList<Class<?>>(8);
        _addSuperClasses(cls, endBefore, result, addClassItself);
        return result;
    }","public static List<Class<?>> findSuperClasses(Class<?> cls, Class<?> endBefore, boolean addClassItself){
        if ((cls == null) || (cls == endBefore) || (cls == Object.class)) {
            return Collections.emptyList();
        }
        List<Class<?>> result = new ArrayList<Class<?>>(8);
        _addSuperClasses(cls, endBefore, result, addClassItself);
        return result;
    }","public static List<Class<?>> findSuperClasses(Class<?> cls, Class<?> endBefore, boolean addClassItself){
        if ((cls == null) || (cls == endBefore) || (cls == Object.class)) {
            return Collections.emptyList();
        }
        List<Class<?>> result = new ArrayList<Class<?>>(8);
        _addSuperClasses(cls, endBefore, result, addClassItself);
        return result;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6051201411309065,  0.6051201411309065,  0.6051201411309065,  0.6051201411309065,68.0,0.591304347826087,68.0,0.591304347826087,68.0,0.591304347826087,68.0,0.591304347826087,0.0,0.0,0.0,0.0,0.0,0.0,21.0,0.7777777777777778,6.0,0.2222222222222222,9.0,0.3333333333333333
775,cdk,"private static boolean testSubgraphHeuristics(IAtomContainer ac1, IAtomContainer ac2) throws CDKException{
    if (ac1 instanceof IQueryAtomContainer) {
        throw new CDKException(""The first IAtomContainer must not be an IQueryAtomContainer"");
    }
    int ac1SingleBondCount = 0;
    int ac1DoubleBondCount = 0;
    int ac1TripleBondCount = 0;
    int ac1AromaticBondCount = 0;
    int ac2SingleBondCount = 0;
    int ac2DoubleBondCount = 0;
    int ac2TripleBondCount = 0;
    int ac2AromaticBondCount = 0;
    int ac1SCount = 0;
    int ac1OCount = 0;
    int ac1NCount = 0;
    int ac1FCount = 0;
    int ac1ClCount = 0;
    int ac1BrCount = 0;
    int ac1ICount = 0;
    int ac1CCount = 0;
    int ac2SCount = 0;
    int ac2OCount = 0;
    int ac2NCount = 0;
    int ac2FCount = 0;
    int ac2ClCount = 0;
    int ac2BrCount = 0;
    int ac2ICount = 0;
    int ac2CCount = 0;
    IBond bond;
    IAtom atom;
    for (int i = 0; i < ac1.getBondCount(); i++) {
        bond = ac1.getBond(i);
        if (bond.getFlag(CDKConstants.ISAROMATIC)) {
            ac1AromaticBondCount++;
        } else if (bond.getOrder() == IBond.Order.SINGLE) {
            ac1SingleBondCount++;
        } else if (bond.getOrder() == IBond.Order.DOUBLE) {
            ac1DoubleBondCount++;
        } else if (bond.getOrder() == IBond.Order.TRIPLE) {
            ac1TripleBondCount++;
        }
    }
    for (int i = 0; i < ac2.getBondCount(); i++) {
        bond = ac2.getBond(i);
        if (bond instanceof IQueryBond) {
            continue;
        }
        if (bond.getFlag(CDKConstants.ISAROMATIC)) {
            ac2AromaticBondCount++;
        } else if (bond.getOrder() == IBond.Order.SINGLE) {
            ac2SingleBondCount++;
        } else if (bond.getOrder() == IBond.Order.DOUBLE) {
            ac2DoubleBondCount++;
        } else if (bond.getOrder() == IBond.Order.TRIPLE) {
            ac2TripleBondCount++;
        }
    }
    if (ac2SingleBondCount > ac1SingleBondCount) {
        return false;
    }
    if (ac2AromaticBondCount > ac1AromaticBondCount) {
        return false;
    }
    if (ac2DoubleBondCount > ac1DoubleBondCount) {
        return false;
    }
    if (ac2TripleBondCount > ac1TripleBondCount) {
        return false;
    }
    for (int i = 0; i < ac1.getAtomCount(); i++) {
        atom = ac1.getAtom(i);
        if (atom.getSymbol().equals(""S"")) {
            ac1SCount++;
        } else if (atom.getSymbol().equals(""N"")) {
            ac1NCount++;
        } else if (atom.getSymbol().equals(""O"")) {
            ac1OCount++;
        } else if (atom.getSymbol().equals(""F"")) {
            ac1FCount++;
        } else if (atom.getSymbol().equals(""Cl"")) {
            ac1ClCount++;
        } else if (atom.getSymbol().equals(""Br"")) {
            ac1BrCount++;
        } else if (atom.getSymbol().equals(""I"")) {
            ac1ICount++;
        } else if (atom.getSymbol().equals(""C"")) {
            ac1CCount++;
        }
    }
    for (int i = 0; i < ac2.getAtomCount(); i++) {
        atom = ac2.getAtom(i);
        if (atom instanceof IQueryAtom) {
            continue;
        }
        if (atom.getSymbol().equals(""S"")) {
            ac2SCount++;
        } else if (atom.getSymbol().equals(""N"")) {
            ac2NCount++;
        } else if (atom.getSymbol().equals(""O"")) {
            ac2OCount++;
        } else if (atom.getSymbol().equals(""F"")) {
            ac2FCount++;
        } else if (atom.getSymbol().equals(""Cl"")) {
            ac2ClCount++;
        } else if (atom.getSymbol().equals(""Br"")) {
            ac2BrCount++;
        } else if (atom.getSymbol().equals(""I"")) {
            ac2ICount++;
        } else if (atom.getSymbol().equals(""C"")) {
            ac2CCount++;
        }
    }
    if (ac1SCount < ac2SCount) {
        return false;
    }
    if (ac1NCount < ac2NCount) {
        return false;
    }
    if (ac1OCount < ac2OCount) {
        return false;
    }
    if (ac1FCount < ac2FCount) {
        return false;
    }
    if (ac1ClCount < ac2ClCount) {
        return false;
    }
    if (ac1BrCount < ac2BrCount) {
        return false;
    }
    if (ac1ICount < ac2ICount) {
        return false;
    }
    return ac1CCount >= ac2CCount;
}",testSubgraphHeuristics,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,"/**
     *  Checks some simple heuristics for whether the subgraph query can
     *  realistically be atom subgraph of the supergraph. If, for example, the
     *  number of nitrogen atoms in the query is larger than that of the supergraph
     *  it cannot be part of it.
     *
     * @param  ac1  the supergraph to be checked. Must not be an IQueryAtomContainer.
     * @param  ac2  the subgraph to be tested for. May be an IQueryAtomContainer.
     * @return    true if the subgraph ac2 has atom chance to be atom subgraph of ac1
     * @throws org.openscience.cdk.exception.CDKException if the first molecule is an instance
     * of IQueryAtomContainer
     */",1010-1163,"('testSubgraphHeuristics', {'INSTRUCTION': {'covered': 270, 'missed': 60}, 'BRANCH': {'covered': 56, 'missed': 30}, 'LINE': {'covered': 82, 'missed': 27}, 'COMPLEXITY': {'covered': 16, 'missed': 28}, 'METHOD': {'covered': 1, 'missed': 0}})",872.0,18.0,Checks some simple heuristics for whether the subgraph query can  realistically be atom subgraph of the supergraph.,Test if some simple heuristics for whether the subgraph query can realistically be atom subgraph of the supergraph.,The subgraph query can be considered an atom subgraph of the supergraph.,0.661331478498849,Check some simple heuristics to see if the subgraph query can realistically be an atom subgraph of the supergraph.,"private static boolean testSubgraphHeuristics(IAtomContainer ac1, IAtomContainer ac2) throws CDKException{
        if (ac1.getAtomCount() > ac2.getAtomCount()) {
            return false;
        }
        if (ac1.getBondCount() > ac2.getBondCount()) {
            return false;
        }
        if (ac1.getAtomCount() == ac2.getAtomCount() && ac1.getBondCount() == ac2.getBondCount()) {
            return true;
        }
        return true;
    }","private static boolean testSubgraphHeuristics(IAtomContainer ac1, IAtomContainer ac2) throws CDKException{
        if (ac1.getAtomCount() > ac2.getAtomCount()) {
            return false;
        }
        if (ac1.getBondCount() > ac2.getBondCount()) {
            return false;
        }
        if (ac1.getAtomCount() == ac2.getAtomCount() && ac1.getBondCount() == ac2.getBondCount()) {
            return true;
        }
        return false;
    }","private static boolean testSubgraphHeuristics(IAtomContainer ac1, IAtomContainer ac2) throws CDKException{
        if (ac1.getAtomCount() > ac2.getAtomCount()) {
            return false;
        }
        if (ac1.getBondCount() > ac2.getBondCount()) {
            return false;
        }
        if (ac1.getAtomCount() == ac2.getAtomCount() && ac1.getBondCount() == ac2.getBondCount()) {
            return true;
        }
        if (ac1.getAtomCount() == ac2.getAtomCount() && ac1.getBondCount() < ac2.getBondCount()) {
            return true;
        }
        if (ac1.getAtomCount() < ac2.getAtomCount() && ac1.getBondCount() == ac2.getBondCount()) {
            return true;
        }
        if (ac1.getAtomCount() < ac2.getAtomCount() && ac1.getBondCount() < ac2.getBondCount()) {
            return true;
        }
        return false;
    }","private static boolean testSubgraphHeuristics(IAtomContainer ac1, IAtomContainer ac2) throws CDKException{
        if (ac1.getAtomCount() > ac2.getAtomCount()) {
            return false;
        }
        if (ac1.getBondCount() > ac2.getBondCount()) {
            return false;
        }
        if (ac1.getAtomCount() == ac2.getAtomCount() && ac1.getBondCount() == ac2.getBondCount()) {
            return true;
        }
        if (ac1.getAtomCount() == ac2.getAtomCount() && ac1.getBondCount() < ac2.getBondCount()) {
            return true;
        }
        if (ac1.getAtomCount() < ac2.getAtomCount() && ac1.getBondCount() == ac2.getBondCount()) {
            return true;
        }
        if (ac1.getAtomCount() < ac2.getAtomCount() && ac1.getBondCount() < ac2.getBondCount()) {
            return true;
        }
        return false;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.07736797126775426,  0.07779535602922127,  0.0874378468195567,  0.0874378468195567,803.0,0.9198167239404352,802.0,0.9186712485681557,746.0,0.854524627720504,746.0,0.854524627720504,1.0,0.011363636363636364,93.0,0.5138121546961326,93.0,0.5138121546961326,2.0,0.10526315789473684,5.0,0.25,10.0,0.5555555555555556
778,dcache,"public static boolean hasGid(Subject subject, long gid){
    Set<GidPrincipal> principals = subject.getPrincipals(GidPrincipal.class);
    for (GidPrincipal principal : principals) {
        if (principal.getGid() == gid) {
            return true;
        }
    }
    return false;
}",hasGid,org/dcache/auth/Subjects.java,/modules/common/src/main/java/org/dcache/auth/Subjects.java,"/**
     * Returns true if and only if the subject has the given group ID.
     */",114-126,"('hasGid', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,14.0,Returns true if and only if the subject has the given group ID.,Check if the given input has the given group ID,"If the subject has a group ID, this is true.",1.07957542541475,Returns true if and only if the object has the given group ID.," public static boolean hasGid(Subject subject, long gid){
        Set<GidPrincipal> principals =
                subject.getPrincipals(GidPrincipal.class);
        for (GidPrincipal principal : principals) {
            if (principal.getGid() == gid) {
                return true;
            }
        }
        return false;
    }"," public static boolean hasGid(Subject subject, long gid){
        Set<GidPrincipal> principals =
                subject.getPrincipals(GidPrincipal.class);
        for (GidPrincipal principal : principals) {
            if (principal.getGid() == gid) {
                return true;
            }
        }
        return false;
    }"," public static boolean hasGid(Subject subject, long gid){
        Set<GidPrincipal> principals =
            subject.getPrincipals(GidPrincipal.class);
        for (GidPrincipal principal : principals) {
            if (principal.getGid() == gid) {
                return true;
            }
        }
        return false;
    }"," public static boolean hasGid(Subject subject, long gid){
        Set<GidPrincipal> principals =
            subject.getPrincipals(GidPrincipal.class);
        for (GidPrincipal principal : principals) {
            if (principal.getGid() == gid) {
                return true;
            }
        }
        return false;
    }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,8.0,0.5714285714285714,1.0,0.07142857142857142,12.0,0.8571428571428571
779,logstash-logback-encoder,"private void writeFieldsOfNode(JsonGenerator generator, JsonNode node) throws IOException{
    if (node != null) {
        for (Iterator<Entry<String, JsonNode>> fields = node.fields(); fields.hasNext(); ) {
            Entry<String, JsonNode> field = fields.next();
            generator.writeFieldName(field.getKey());
            generator.writeTree(field.getValue());
        }
    }
}",writeFieldsOfNode,net/logstash/logback/composite/GlobalCustomFieldsJsonProvider.java,/src/main/java/net/logstash/logback/composite/GlobalCustomFieldsJsonProvider.java,"/**
     * Writes the fields of the given node into the generator.
     */",53-64,"('writeFieldsOfNode', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",86.0,11.0,Writes the fields of the given node into the generator.,This method writes the fields of the given node into the generator,The fields are written into the generator.,0.323792363435738,Writes the fields of the given node to the generator.," private void writeFieldsOfNode(JsonGenerator generator, JsonNode node) throws IOException{
        if (node == null) {
            return;
        }
        Iterator<Entry<String, JsonNode>> fields = node.fields();
        while (fields.hasNext()) {
            Entry<String, JsonNode> field = fields.next();
            String fieldName = field.getKey();
            JsonNode fieldValue = field.getValue();
            if (fieldValue.isObject()) {
                generator.writeObjectField(fieldName, fieldValue);
            } else if (fieldValue.isArray()) {
                generator.writeArrayFieldStart(fieldName);
                writeArray(generator, fieldValue);
                generator.writeEndArray();
            } else {
                generator.writeStringField(fieldName, fieldValue.asText());
            }
        }       
 }"," private void writeFieldsOfNode(JsonGenerator generator, JsonNode node) throws IOException{
        if (node == null) {
            return;
        }
        Iterator<Entry<String, JsonNode>> fields = node.fields();
        while (fields.hasNext()) {
            Entry<String, JsonNode> field = fields.next();
            String fieldName = field.getKey();
            JsonNode fieldValue = field.getValue();
            if (fieldValue.isObject()) {
                generator.writeObjectField(fieldName, fieldValue);
            } else if (fieldValue.isArray()) {
                generator.writeArrayFieldStart(fieldName);
                writeArray(generator, fieldValue);
                generator.writeEndArray();
            } else {
                generator.writeStringField(fieldName, fieldValue.asText());
            }
        }       
 }"," private void writeFieldsOfNode(JsonGenerator generator, JsonNode node) throws IOException{
        if (node == null) {
            return;
        }
        Iterator<Entry<String, JsonNode>> fields = node.fields();
        while (fields.hasNext()) {
            Entry<String, JsonNode> field = fields.next();
            String fieldName = field.getKey();
            JsonNode fieldValue = field.getValue();
            if (fieldValue.isObject()) {
                generator.writeFieldName(fieldName);
                writeFieldsOfNode(generator, fieldValue);
            } else {
                generator.writeStringField(fieldName, fieldValue.asText());
            }
        }
    }"," private void writeFieldsOfNode(JsonGenerator generator, JsonNode node) throws IOException{
        if (node == null) {
            return;
        }
        Iterator<Entry<String, JsonNode>> fields = node.fields();
        while (fields.hasNext()) {
            Entry<String, JsonNode> field = fields.next();
            String fieldName = field.getKey();
            JsonNode fieldValue = field.getValue();
            if (fieldValue.isObject()) {
                generator.writeFieldName(fieldName);
                writeFieldsOfNode(generator, fieldValue);
            } else {
                generator.writeStringField(fieldName, fieldValue.asText());
            }
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7301767257392173,  0.7301767257392173,  0.7033520339326278,  0.7033520339326278,74.0,0.49333333333333335,74.0,0.49333333333333335,48.0,0.3870967741935484,48.0,0.3870967741935484,0.0,0.0,28.0,0.18666666666666668,28.0,0.18666666666666668,4.0,0.3076923076923077,1.0,0.09090909090909091,6.0,0.5454545454545454
780,matsim-libs,"public static double calcProjectedEuclideanDistance(Coord coord, Coord other){
    double xDiff = other.getX() - coord.getX();
    double yDiff = other.getY() - coord.getY();
    return Math.sqrt((xDiff * xDiff) + (yDiff * yDiff));
}",calcProjectedEuclideanDistance,org/matsim/core/utils/geometry/CoordUtils.java,/matsim/src/main/java/org/matsim/core/utils/geometry/CoordUtils.java,"/**
         * Method to deal with distance calculation when only the x and y-components
         * of the coordinates are used. The elevation (z component) is ignored,
         * whether it is available or not. 
         * (xy-plane)
         * @param coord
         * @param other
         * @return
         */",192-205,"('calcProjectedEuclideanDistance', {'INSTRUCTION': {'covered': 21, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,18.0,Method to deal with distance calculation when only the x and y-components  of the coordinates are used.,Calculate the distance when only x an y components are provided,"When only the x and y-components of the coordinates are used, the method is used.",0.551656199171314,Method for processing distance calculation when only the x and y components of the coordinates are used.," public static double calcProjectedEuclideanDistance(Coord coord, Coord other){
	 double xDiff = other.getX()-coord.getX();
	 double yDiff = other.getY()-coord.getY();
	 return Math.sqrt((xDiff*xDiff) + (yDiff*yDiff));			
 }"," public static double calcProjectedEuclideanDistance(Coord coord, Coord other){
	 double xDiff = other.getX()-coord.getX();
	 double yDiff = other.getY()-coord.getY();
	 return Math.sqrt((xDiff*xDiff) + (yDiff*yDiff));			
 }"," public static double calcProjectedEuclideanDistance(Coord coord, Coord other){
	 double xDiff = other.getX()-coord.getX();
	 double yDiff = other.getY()-coord.getY();
	 return Math.sqrt((xDiff*xDiff) + (yDiff*yDiff));			
 }"," public static double calcProjectedEuclideanDistance(Coord coord, Coord other){
	 double xDiff = other.getX()-coord.getX();
	 double yDiff = other.getY()-coord.getY();
	 return Math.sqrt((xDiff*xDiff) + (yDiff*yDiff));			
 }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,12.0,0.6666666666666666,5.0,0.2777777777777778,11.0,0.6111111111111112
781,egeria,"public String createPortAlias(String userId, PortAlias portAlias, String processGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    return createPort(userId, portAlias, PORT_ALIAS_TYPE_NAME, processGUID, externalSourceName);
}",createPortAlias,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,"/**
     * Create the port alias and attach it to the process.
     *
     * @param userId             the name of the calling user
     * @param portAlias          the port alias values
     * @param processGUID        the unique identifier of the process
     * @param externalSourceName the unique name of the external source
     *
     * @return unique identifier of the port alias in the repository
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",100-118,"('createPortAlias', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,11.0,Create the port alias and attach it to the process.,This method builds the port alias and attach it to the process.,Attach the port to the process.,1.02391563562097,Create the port alias and attach it to the process.," public String createPortAlias(String userId, PortAlias portAlias, String processGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        return createPort(userId, portAlias, PORT_ALIAS_TYPE_NAME, processGUID, externalSourceName);        
 }"," public String createPortAlias(String userId, PortAlias portAlias, String processGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        return createPort(userId, portAlias, PORT_ALIAS_TYPE_NAME, processGUID, externalSourceName);        
 }"," public String createPortAlias(String userId, PortAlias portAlias, String processGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        return createPort(userId, portAlias, PORT_ALIAS_TYPE_NAME, processGUID, externalSourceName);
    }"," public String createPortAlias(String userId, PortAlias portAlias, String processGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        return createPort(userId, portAlias, PORT_ALIAS_TYPE_NAME, processGUID, externalSourceName);
    }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.23076923076923078,0.0,0.0,5.0,0.45454545454545453
782,cdk,"private IChemFile readChemFile(IChemFile chemFile){
    IChemSequence chemSequence;
    IChemModel chemModel;
    ICrystal crystal;
    try {
        String line = readLine();
        while (input.ready() && line != null) {
            if (line.startsWith(""%%Header Start"")) {
                while (input.ready() && line != null && !(line.startsWith(""%%Header End""))) {
                    if (line.startsWith(""%%Version Number"")) {
                        String version = readLine().trim();
                        if (!version.equals(""3.00"")) {
                            logger.error(""The PMPReader only supports PMP files with version 3.00"");
                            return null;
                        }
                    }
                    line = readLine();
                }
            } else if (line.startsWith(""%%Model Start"")) {
                modelStructure = chemFile.getBuilder().newInstance(IAtomContainer.class);
                while (input.ready() && line != null && !(line.startsWith(""%%Model End""))) {
                    Matcher objHeaderMatcher = objHeader.matcher(line);
                    if (objHeaderMatcher.matches()) {
                        String object = objHeaderMatcher.group(2);
                        constructObject(chemFile.getBuilder(), object);
                        int id = Integer.parseInt(objHeaderMatcher.group(1));
                        line = readLine();
                        while (input.ready() && line != null && !(line.trim().equals("")""))) {
                            Matcher objCommandMatcher = objCommand.matcher(line);
                            objHeaderMatcher = objHeader.matcher(line);
                            if (objHeaderMatcher.matches()) {
                                object = objHeaderMatcher.group(2);
                                id = Integer.parseInt(objHeaderMatcher.group(1));
                                constructObject(chemFile.getBuilder(), object);
                            } else if (objCommandMatcher.matches()) {
                                String format = objCommandMatcher.group(1);
                                String command = objCommandMatcher.group(2);
                                String field = objCommandMatcher.group(3);
                                processModelCommand(object, command, format, field);
                            } else {
                                logger.warn(""Skipping line: "" + line);
                            }
                            line = readLine();
                        }
                        if (chemObject instanceof IAtom) {
                            atomids.put(id, modelStructure.getAtomCount());
                            atomGivenIds.put(Integer.valueOf((String) chemObject.getProperty(PMP_ID)), id);
                            modelStructure.addAtom((IAtom) chemObject);
                        } else if (chemObject instanceof IBond) {
                        } else {
                            logger.error(""chemObject is not initialized or of bad class type"");
                        }
                    }
                    line = readLine();
                }
                assert line != null;
                if (line.startsWith(""%%Model End"")) {
                    int bondsFound = bondids.size();
                    logger.debug(""Found #bonds: "", bondsFound);
                    logger.debug(""#atom ones: "", bondAtomOnes.size());
                    logger.debug(""#atom twos: "", bondAtomTwos.size());
                    logger.debug(""#orders: "", bondOrders.size());
                    for (Integer index : bondids.keySet()) {
                        double order = (bondOrders.get(index) != null ? bondOrders.get(index) : 1.0);
                        logger.debug(""index: "", index);
                        logger.debug(""ones: "", bondAtomOnes.get(index));
                        IAtom atom1 = modelStructure.getAtom(atomids.get(bondAtomOnes.get(index)));
                        IAtom atom2 = modelStructure.getAtom(atomids.get(bondAtomTwos.get(index)));
                        IBond bond = modelStructure.getBuilder().newInstance(IBond.class, atom1, atom2);
                        if (order == 1.0) {
                            bond.setOrder(IBond.Order.SINGLE);
                        } else if (order == 2.0) {
                            bond.setOrder(IBond.Order.DOUBLE);
                        } else if (order == 3.0) {
                            bond.setOrder(IBond.Order.TRIPLE);
                        } else if (order == 4.0) {
                            bond.setOrder(IBond.Order.QUADRUPLE);
                        }
                        modelStructure.addBond(bond);
                    }
                }
            } else if (line.startsWith(""%%Traj Start"")) {
                chemSequence = chemFile.getBuilder().newInstance(IChemSequence.class);
                double energyFragment = 0.0;
                double energyTotal = 0.0;
                int Z = 1;
                while (input.ready() && line != null && !(line.startsWith(""%%Traj End""))) {
                    if (line.startsWith(""%%Start Frame"")) {
                        chemModel = chemFile.getBuilder().newInstance(IChemModel.class);
                        crystal = chemFile.getBuilder().newInstance(ICrystal.class);
                        while (input.ready() && line != null && !(line.startsWith(""%%End Frame""))) {
                            if (line.startsWith(""%%Atom Coords"")) {
                                if (energyFragment != 0.0 && energyTotal != 0.0) {
                                    Z = (int) Math.round(energyTotal / energyFragment);
                                    logger.debug(""Z derived from energies: "", Z);
                                }
                                int expatoms = modelStructure.getAtomCount();
                                for (int molCount = 1; molCount <= Z; molCount++) {
                                    IAtomContainer clone = modelStructure.getBuilder().newInstance(IAtomContainer.class);
                                    for (int i = 0; i < expatoms; i++) {
                                        line = readLine();
                                        IAtom a = clone.getBuilder().newInstance(IAtom.class);
                                        StringTokenizer st = new StringTokenizer(line, "" "");
                                        a.setPoint3d(new Point3d(Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken())));
                                        a.setCovalentRadius(0.6);
                                        IAtom modelAtom = modelStructure.getAtom(atomids.get(atomGivenIds.get(i + 1)));
                                        a.setSymbol(modelAtom.getSymbol());
                                        clone.addAtom(a);
                                    }
                                    rebonder.rebond(clone);
                                    crystal.add(clone);
                                }
                            } else if (line.startsWith(""%%E/Frag"")) {
                                line = readLine().trim();
                                energyFragment = Double.parseDouble(line);
                            } else if (line.startsWith(""%%Tot E"")) {
                                line = readLine().trim();
                                energyTotal = Double.parseDouble(line);
                            } else if (line.startsWith(""%%Lat Vects"")) {
                                StringTokenizer st;
                                line = readLine();
                                st = new StringTokenizer(line, "" "");
                                crystal.setA(new Vector3d(Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken())));
                                line = readLine();
                                st = new StringTokenizer(line, "" "");
                                crystal.setB(new Vector3d(Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken())));
                                line = readLine();
                                st = new StringTokenizer(line, "" "");
                                crystal.setC(new Vector3d(Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken())));
                            } else if (line.startsWith(""%%Space Group"")) {
                                line = readLine().trim();
                                if (""P 21 21 21 (1)"".equals(line)) {
                                    crystal.setSpaceGroup(""P 2_1 2_1 2_1"");
                                } else {
                                    crystal.setSpaceGroup(""P1"");
                                }
                            }
                            line = readLine();
                        }
                        chemModel.setCrystal(crystal);
                        chemSequence.addChemModel(chemModel);
                    }
                    line = readLine();
                }
                chemFile.addChemSequence(chemSequence);
            }
            line = readLine();
        }
    } catch (IOException e) {
        logger.error(""An IOException happened: "", e.getMessage());
        logger.debug(e);
        chemFile = null;
    } catch (CDKException e) {
        logger.error(""An CDKException happened: "", e.getMessage());
        logger.debug(e);
        chemFile = null;
    }
    return chemFile;
}",readChemFile,org/openscience/cdk/io/PMPReader.java,/storage/io/src/main/java/org/openscience/cdk/io/PMPReader.java,"/**
     *  Private method that actually parses the input to read a ChemFile
     *  object.
     *
     *  Each PMP frame is stored as a Crystal in a ChemModel. The PMP
     *  file is stored as a ChemSequence of ChemModels.
     *
     * @return A ChemFile containing the data parsed from input.
     */",181-383,"('readChemFile', {'INSTRUCTION': {'covered': 690, 'missed': 64}, 'BRANCH': {'covered': 69, 'missed': 25}, 'LINE': {'covered': 123, 'missed': 16}, 'COMPLEXITY': {'covered': 25, 'missed': 23}, 'METHOD': {'covered': 1, 'missed': 0}})",1532.0,13.0,Private method that actually parses the input to read a ChemFile  object.,This method parses the input to read a ChemFile  object,Private method that reads the input to the ChemFile object.,0.252968077086194,A private method that actually parses the input to read a ChemFile object.,Not Valid,Not Valid," private IChemFile readChemFile(IChemFile chemFile){
        try {
            String line = readLine();
            while (line != null) {
                if (line.startsWith(""(M"")) {
                    chemObject = readChemObject(line);
                    if (chemObject instanceof IChemSequence) {
                        chemFile.addChemSequence((IChemSequence) chemObject);
                    } else if (chemObject instanceof IChemModel) {
                        chemFile.addChemModel((IChemModel) chemObject);
                    } else {
                        throw new CDKException(""Only supported is reading of ChemSequence and ChemModel objects."");
                    }
                }
                line = readLine();
            }
        } catch (IOException exception) {
            logger.error(""IOException while reading PMP file: "", exception);
        }
        return chemFile;        
 }"," private IChemFile readChemFile(IChemFile chemFile){
        try {
            String line = readLine();
            while (line != null) {
                if (line.startsWith(""(M"")) {
                    chemObject = readChemObject(chemFile);
                    if (chemObject != null) {
                        chemFile.addChemSequence((IChemSequence) chemObject);
                    }
                } else {
                    logger.warn(""Expected molecule, found: "", line);
                }
                line = readLine();
            }
        } catch (IOException exception) {
            logger.error(""IOException while reading file: "", exception);
        }
        return chemFile;        
 }",Not Valid,Not Valid,NOT PASS,NOT PASS,None,None,  0.09788596942471303,  0.10137810983746606,None,None,None,None,1443.0,0.9412915851272016,1431.0,0.9334637964774951,None,None,100.0,0.9900990099009901,117.0,0.9915254237288136,4.0,0.3076923076923077,2.0,0.14285714285714285,4.0,0.3076923076923077
783,glowstone,"public void remove(){
    removed = true;
    active = false;
    boundingBox = null;
    world.getEntityManager().unregister(this);
    server.getEntityIdManager().deallocate(this);
    this.setPassenger(null);
    leaveVehicle();
    ImmutableList.copyOf(this.leashedEntities).forEach(e -> unleash(e, UnleashReason.HOLDER_GONE));
    if (isLeashed()) {
        unleash(this, UnleashReason.HOLDER_GONE);
    }
}",remove,net/glowstone/entity/GlowEntity.java,/src/main/java/net/glowstone/entity/GlowEntity.java,"/**
     * Destroys this entity by removing it from the world and marking it as not being active.
     */",1126-1144,"('remove', {'INSTRUCTION': {'covered': 36, 'missed': 4}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 11, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,17.0,Destroys this entity by removing it from the world and marking it as not being active.,Delete this entity by removing it from the world and marking it as not being active,Removes this entity from the world and marks it as inactive.,0.236270404387271,Destroys this entity by removing it from the world and marking it as not being active.," public void remove(){
        if (world != null) {
            world.removeEntity(this);
        }
        active = false;
    }"," public void remove(){
        if (world != null) {
            world.removeEntity(this);
        }
        active = false;
    }"," public void remove(){
        if (isDead()) {
            return;
        }
        setDead();
        if (world != null) {
            world.removeEntity(this);
        }
    }"," public void remove(){
        if (isActive()) {
            world.removeEntity(this);
            setActive(false);
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.11421838308179452,  0.11421838308179452,  0.11969593505105607,  0.16795731273411837,76.0,0.8172043010752689,76.0,0.8172043010752689,72.0,0.7741935483870968,69.0,0.7419354838709677,0.0,0.0,8.0,0.2857142857142857,18.0,0.4864864864864865,2.0,0.11764705882352941,0.0,0.0,8.0,0.47058823529411764
784,cdk,"private static int permParity(final ILigand[] ligands){
    int swaps = 0;
    for (int j = 1, hi = ligands.length; j < hi; j++) {
        ILigand ligand = ligands[j];
        int i = j - 1;
        int cmp = 0;
        while ((i >= 0) && (cmp = cipRule.compare(ligand, ligands[i])) > 0) {
            ligands[i + 1] = ligands[i--];
            swaps++;
        }
        if (cmp == 0)
            return 0;
        ligands[i + 1] = ligand;
    }
    return (swaps & 0x1) == 0x1 ? -1 : +1;
}",permParity,org/openscience/cdk/geometry/cip/CIPTool.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/CIPTool.java,"/**
     * Obtain the permutation parity (-1,0,+1) to put the ligands in descending
     * order (highest first). A parity of 0 indicates two or more ligands were
     * equivalent.
     *
     * @param ligands the ligands to sort
     * @return parity, odd (-1), even (+1) or none (0)
     */",249-278,"('permParity', {'INSTRUCTION': {'covered': 63, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",137.0,21.0,"Obtain the permutation parity (-1,0,+1) to put the ligands in descending  order (highest first).",Get the permutation parity to put the ligands in descending order,The permutation parity is needed to place the ligands in descending order.,0.333805003665781,"Get the permutation parity (-1.0,+1) to put the ligands in descending order (highest first).","private static int permParity(final ILigand[] ligands){
        int parity = 0;
        for (int i = 0; i < ligands.length; i++) {
            parity += ligands[i].getLigandAtom().getAtomicNumber();
        }
        return parity % 2 == 0 ? 1 : -1;
    }","private static int permParity(final ILigand[] ligands){
        int parity = 0;
        for (int i = 0; i < ligands.length; i++) {
            parity += ligands[i].getLigandAtom().getAtomicNumber();
        }
        return parity % 2 == 0 ? 1 : -1;
    }","private static int permParity(final ILigand[] ligands){
        int parity = 0;
        for (int i = 0; i < ligands.length; i++) {
            parity += permParity(ligands, i);
        }
        return parity;      
 }","private static int permParity(final ILigand[] ligands){
        int parity = 0;
        for (int i = 0; i < ligands.length; i++) {
            parity += ligands[i].getAtom().getAtomicNumber();
        }
        return parity % 2 == 0 ? 1 : -1;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2772785621156496,  0.2772785621156496,  0.2772785621156496,  0.19594723703574862,92.0,0.6666666666666666,92.0,0.6666666666666666,92.0,0.6666666666666666,101.0,0.7318840579710145,0.0,0.0,1.0,0.015625,19.0,0.296875,4.0,0.26666666666666666,2.0,0.13333333333333333,8.0,0.5333333333333333
785,cdk,"private Map<String, String> loadHydrogenDefinitions(InputStream hdefIn) throws IOException{
    final Map<String, String> hdefs = new HashMap<String, String>(200);
    BufferedReader br = new BufferedReader(new InputStreamReader(hdefIn));
    br.readLine();
    String line = null;
    while ((line = br.readLine()) != null) {
        String[] cols = line.split(""\t"");
        hdefs.put(cols[0].trim(), cols[3].trim());
    }
    return hdefs;
}",loadHydrogenDefinitions,org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,"/**
     * Hydrogen atom types are assigned based on their parent types. The mmff-symb-mapping file
     * provides this mapping.
     *
     * @param hdefIn input stream of mmff-symb-mapping.tsv
     * @return mapping of parent to hydrogen definitions
     * @throws IOException
     */",243-268,"('loadHydrogenDefinitions', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",114.0,11.0,Hydrogen atom types are assigned based on their parent types.,Loads hydrogen atom types based on their parent types,The hydrogen atom types are assigned based on their parent types.,0.324086402264527,The types of hydrogen atoms are assigned according to their parent types.,"private Map<String, String> loadHydrogenDefinitions(InputStream hdefIn) throws IOException{
        Map<String, String> hydrogenMap = new HashMap<String, String>();
        BufferedReader br = new BufferedReader(new InputStreamReader(hdefIn));
        String line = null;
        while ((line = br.readLine()) != null) {
            if (skipLine(line)) continue;
            String[] cols = line.split("" "");
            String parent = cols[0];
            String child = cols[1];
            hydrogenMap.put(parent, child);
        }
        return hydrogenMap;
    }","private Map<String, String> loadHydrogenDefinitions(InputStream hdefIn) throws IOException{
        Map<String, String> hydrogenMap = new HashMap<String, String>();
        BufferedReader br = new BufferedReader(new InputStreamReader(hdefIn));
        String line = null;
        while ((line = br.readLine()) != null) {
            if (skipLine(line)) continue;
            String[] cols = line.split("" "");
            String parent = cols[0];
            String child = cols[1];
            hydrogenMap.put(parent, child);
        }
        return hydrogenMap;
    }","private Map<String, String> loadHydrogenDefinitions(InputStream hdefIn) throws IOException{
        Map<String, String> hydrogenMap = new HashMap<String, String>();
        BufferedReader br = new BufferedReader(new InputStreamReader(hdefIn));
        String line = null;
        while ((line = br.readLine()) != null) {
            if (skipLine(line)) continue;
            String[] cols = line.split("" "");
            String parent = cols[0];
            String child = cols[1];
            hydrogenMap.put(parent, child);
        }
        return hydrogenMap;
    }","private Map<String, String> loadHydrogenDefinitions(InputStream hdefIn) throws IOException{
        Map<String, String> map = new HashMap<String, String>();
        BufferedReader br = new BufferedReader(new InputStreamReader(hdefIn));
        String line = null;
        while ((line = br.readLine()) != null) {
            if (skipLine(line)) continue;
            String[] cols = line.split("" "");
            String symb = cols[0];
            String hdef = cols[1];
            map.put(symb, hdef);
        }
        return map;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6075948815520115,  0.6343805958377258,  0.6254520244091543,  0.6165234529805829,36.0,0.3050847457627119,36.0,0.3050847457627119,36.0,0.3050847457627119,36.0,0.3050847457627119,0.0,0.0,7.0,0.059322033898305086,0.0,0.0,5.0,0.45454545454545453,7.0,0.5384615384615384,2.0,0.16666666666666666
786,dcache,"private synchronized Map<String, Level> computeEffectiveMap(LoggerName logger){
    Map<String, Level> inheritedMap = getInheritedMap(logger);
    if (!isRoot(logger)) {
        LoggerName parent = logger.getParent();
        if (parent != null) {
            Map<String, Level> mergedMap = computeEffectiveMap(parent);
            mergedMap.putAll(inheritedMap);
            return mergedMap;
        }
    }
    return inheritedMap;
}",computeEffectiveMap,dmg/util/logback/FilterThresholdSet.java,/modules/cells/src/main/java/dmg/util/logback/FilterThresholdSet.java,"/**
     * Returns a map from appenders to levels for a logger.
     * <p>
     * The map contains the effective log levels, that is, the levels used for filtering log
     * events.
     */",193-210,"('computeEffectiveMap', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",81.0,11.0,Returns a map from appenders to levels for a logger.,Get a map from appenders to levels for a logger,A map is returned from the appenders to the levels.,0.463027028272017,Returns a map of the appendages at the levels of a recorder.," private synchronized Map<String, Level> computeEffectiveMap(LoggerName logger){
        if (_parent == null) {
            return Maps.newHashMap(_rules.row(logger));
        } else {
            Map<String, Level> map = _parent.computeEffectiveMap(logger);
            map.putAll(_rules.row(logger));
            return map;
        }
    }"," private synchronized Map<String, Level> computeEffectiveMap(LoggerName logger){
        if (_parent == null) {
            return Maps.newHashMap(_rules.row(logger));
        } else {
            Map<String, Level> map = _parent.computeEffectiveMap(logger);
            map.putAll(_rules.row(logger));
            return map;
        }
    }"," private synchronized Map<String, Level> computeEffectiveMap(LoggerName logger){
        Map<String, Level> map = Maps.newHashMap();
        if (_parent != null) {
            map.putAll(_parent.getInheritedMap(logger));
        }
        map.putAll(_rules.row(logger));
        return map;
    }"," private synchronized Map<String, Level> computeEffectiveMap(LoggerName logger){
        Map<String, Level> map = Maps.newHashMap();
        if (_parent != null) {
            map.putAll(_parent.getInheritedMap(logger));
        }
        map.putAll(_rules.row(logger));
        return map;     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4509327032919084,  0.4509327032919084,  0.47194272724273223,  0.47194272724273223,47.0,0.573170731707317,47.0,0.573170731707317,43.0,0.524390243902439,43.0,0.524390243902439,0.0,0.0,29.0,0.4142857142857143,29.0,0.4142857142857143,2.0,0.18181818181818182,7.0,0.5384615384615384,9.0,0.8181818181818182
787,cdk,"public static IMolecularFormula removeElement(IMolecularFormula formula, IElement element){
    for (IIsotope isotope : getIsotopes(formula, element)) {
        formula.removeIsotope(isotope);
    }
    return formula;
}",removeElement,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * Removes all isotopes from a given element in the MolecularFormula.
     *
     * @param  formula   IMolecularFormula molecularFormula
     * @param  element   The IElement of the IIsotopes to be removed
     * @return           The molecularFormula with the isotopes removed
     */",206-218,"('removeElement', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,11.0,Removes all isotopes from a given element in the MolecularFormula.,This methods removes all isotopes from a given input in the MolecularFormula.,All elements in the MolecularFormula are removed.,0.396108163388387,Removes all isotopes of a given element in the MolecularFormula.," public static IMolecularFormula removeElement(IMolecularFormula formula, IElement element){
        List<IIsotope> isotopes = getIsotopes(formula, element);
        for (IIsotope isotope : isotopes) {
            formula.removeIsotope(isotope);
        }
        return formula;
    }"," public static IMolecularFormula removeElement(IMolecularFormula formula, IElement element){
        List<IIsotope> isotopes = getIsotopes(formula, element);
        for (IIsotope isotope : isotopes) {
            formula.removeIsotope(isotope);
        }
        return formula;
    }"," public static IMolecularFormula removeElement(IMolecularFormula formula, IElement element){
        return removeElement(formula, element.getSymbol());
    }"," public static IMolecularFormula removeElement(IMolecularFormula formula, IElement element){
        List<IIsotope> isotopes = getIsotopes(formula, element);
        for (IIsotope isotope : isotopes) {
            formula.removeIsotope(isotope);
        }
        return formula;
    }",PASS,PASS,PASS,NOT PASS,  0.7983429823604107,  0.7983429823604107,  0.7983429823604107,  0.4342999670563764,12.0,0.2608695652173913,12.0,0.2608695652173913,12.0,0.2608695652173913,16.0,0.42105263157894735,0.0,0.0,0.0,0.0,24.0,0.5217391304347826,4.0,0.3076923076923077,1.0,0.09090909090909091,10.0,0.9090909090909091
789,glowstone,"public void putDoubleList(@NonNls String key, List<Double> list){
    putList(key, TagType.DOUBLE, list, DoubleTag::new);
}",putDoubleList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Adds or replaces a list subtag with a list of doubles.
     *
     * @param key the key to write to
     * @param list the list contents as doubles, to convert to double tags
     */",977-985,"('putDoubleList', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,12.0,Adds or replaces a list subtag with a list of doubles.,Replaces or add a list subtag with a list of doubles,A list subtag is added or replaced with a list of doubles.,0.0885202813797454,Adds or replaces a list subtag with a duplicate list.," public void putDoubleList(@NonNls String key, List<Double> list){
        putList(key, TagType.DOUBLE, list, DoubleTag::new);
    }"," public void putDoubleList(@NonNls String key, List<Double> list){
        putList(key, TagType.DOUBLE, list, DoubleTag::new);
    }"," public void putDoubleList(@NonNls String key, List<Double> list){
        putList(key, TagType.DOUBLE, list, DoubleTag::new);
    }"," public void putDoubleList(@NonNls String key, List<Double> list){
        putList(key, TagType.DOUBLE, list, DoubleTag::new);
    }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.25,3.0,0.25,7.0,0.5384615384615384
790,cdk,"public boolean contains(IIsotope isotope){
    for (IIsotope thisIsotope : isotopes()) {
        if (isTheSame(thisIsotope, isotope)) {
            return true;
        }
    }
    return false;
}",contains,org/openscience/cdk/formula/MolecularFormula.java,/base/data/src/main/java/org/openscience/cdk/formula/MolecularFormula.java,"/**
     *  True, if the MolecularFormula contains the given IIsotope object and not
     *  the instance. The method looks for other isotopes which has the same
     *  symbol, natural abundance and exact mass.
     *
     * @param  isotope  The IIsotope this MolecularFormula is searched for
     * @return          True, if the MolecularFormula contains the given isotope object
     */",133-149,"('contains', {'INSTRUCTION': {'covered': 21, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,15.0,"True, if the MolecularFormula contains the given IIsotope object and not  the instance.",This method returns true if the MolecularFormula contains the given IIsotope object and false otherwise,"If the MolecularFormula contains the IIsotope object, it's true.",0.347816804911243,"True, if molecularFormula contains the given IIsotope object, not the instance."," public boolean contains(IIsotope isotope){
        return isotopes.containsKey(isotope);
    }"," public boolean contains(IIsotope isotope){
        return isotopes.containsKey(isotope);
    }"," public boolean contains(IIsotope isotope){
        return isotopes.containsKey(isotope);
    }"," public boolean contains(IIsotope isotope){
        for (IIsotope thisIsotope : isotopes()) {
            if (isTheSame(thisIsotope, isotope)) {
                return true;
            }
        }
        return false;
    }",NOT PASS,NOT PASS,PASS,NOT PASS,  0.26603383113188994,  0.26603383113188994,  1.0,  0.26603383113188994,23.0,0.6052631578947368,23.0,0.6052631578947368,0.0,0.0,23.0,0.6052631578947368,0.0,0.0,23.0,0.6052631578947368,0.0,0.0,7.0,0.4375,4.0,0.2857142857142857,8.0,0.5714285714285714
791,logstash-logback-encoder,"private NodeWriter<Event> initializeNodeWriter() throws JsonPatternException{
    AbstractJsonPatternParser<Event> parser = createParser(this.jsonFactory);
    parser.setOmitEmptyFields(omitEmptyFields);
    return parser.parse(pattern);
}",initializeNodeWriter,net/logstash/logback/composite/AbstractPatternJsonProvider.java,/src/main/java/net/logstash/logback/composite/AbstractPatternJsonProvider.java,"/**
     * Parses the pattern into a {@link NodeWriter}.
     * 
     * @return a {@link NodeWriter}
     * @throws JsonPatternException thrown in case of invalid pattern
     */",95-105,"('initializeNodeWriter', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,11.0,Parses the pattern into a {@link NodeWriter}.,Return a parser for a NodeWriter object,Parses the pattern into a writing program.,0.327252634615025,Parses the template in a {NodeWriter @link}.," private NodeWriter<Event> initializeNodeWriter() throws JsonPatternException{
        AbstractJsonPatternParser<Event> parser = createParser(jsonFactory);
        parser.setOmitEmptyFields(omitEmptyFields);
        parser.parse(pattern);
        return parser.getNodeWriter();
    }"," private NodeWriter<Event> initializeNodeWriter() throws JsonPatternException{
        AbstractJsonPatternParser<Event> parser = createParser(jsonFactory);
        parser.setPattern(pattern);
        parser.setOmitEmptyFields(omitEmptyFields);
        return parser;
    }"," private NodeWriter<Event> initializeNodeWriter() throws JsonPatternException{
        AbstractJsonPatternParser<Event> parser = createParser(jsonFactory);
        parser.setOmitEmptyFields(omitEmptyFields);
        parser.parse(pattern);
        return parser.getNodeWriter();
    }"," private NodeWriter<Event> initializeNodeWriter() throws JsonPatternException{
        AbstractJsonPatternParser<Event> parser = createParser(jsonFactory);
        parser.setOmitEmptyFields(omitEmptyFields);
        parser.parse(pattern);
        return parser.getNodeWriter();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8339483368838954,  0.8157134911964758,  0.8339483368838954,  0.8339483368838954,10.0,0.2222222222222222,10.0,0.24390243902439024,10.0,0.2222222222222222,10.0,0.2222222222222222,8.0,0.17777777777777778,0.0,0.0,0.0,0.0,6.0,0.75,4.0,0.5,2.0,0.25
792,jackson-databind,"public ObjectReader withValueToUpdate(Object value){
    if (value == _valueToUpdate)
        return this;
    if (value == null) {
        return _new(this, _config, _valueType, _rootDeserializer, null, _schema, _injectableValues, _dataFormatReaders);
    }
    JavaType t;
    if (_valueType == null) {
        t = _config.constructType(value.getClass());
    } else {
        t = _valueType;
    }
    return _new(this, _config, t, _rootDeserializer, value, _schema, _injectableValues, _dataFormatReaders);
}",withValueToUpdate,com/fasterxml/jackson/databind/ObjectReader.java,/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java,"/**
     * Method for constructing a new instance with configuration that
     * updates passed Object (as root value), instead of constructing 
     * a new value.
     *<p>
     * Note that the method does NOT change state of this reader, but
     * rather construct and returns a newly configured instance.
     */",792-822,"('withValueToUpdate', {'INSTRUCTION': {'covered': 54, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",97.0,25.0,"Method for constructing a new instance with configuration that  updates passed Object (as root value), instead of constructing   a new value.",Build a new instance with configuration that updates passed Object instead of constructing a new value.,The method for constructing a new instance with configuration that updates passed object is different from constructing a new value.,0.609135081155519,"A method of constructing a new instance with a configuration that updates the passed object (as a root value), instead of constructing a new value."," public ObjectReader withValueToUpdate(Object value){
        if (value == _valueToUpdate) {
            return this;
        }
        return _new(this, _config, _valueType, _rootDeserializer, value,
                _schema, _injectableValues, _dataFormatReaders);
    }"," public ObjectReader withValueToUpdate(Object value){
        if (value == _valueToUpdate) {
            return this;
        }
        return _new(this, _config, _valueType, _rootDeserializer, value,
                _schema, _injectableValues, _dataFormatReaders);
    }"," public ObjectReader withValueToUpdate(Object value){
        if (_valueToUpdate == value) {
            return this;
        }
        return _new(this, _config, _valueType, _rootDeserializer, value,
                _schema, _injectableValues, _dataFormatReaders);
    }"," public ObjectReader withValueToUpdate(Object value){
        if (_valueToUpdate == value) {
            return this;
        }
        return _new(this, _config, _valueType, _rootDeserializer, value,
                _schema, _injectableValues, _dataFormatReaders);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.26869201416716304,  0.26869201416716304,  0.25524699401040596,  0.25524699401040596,58.0,0.5918367346938775,58.0,0.5918367346938775,59.0,0.6020408163265306,59.0,0.6020408163265306,0.0,0.0,2.0,0.04878048780487805,2.0,0.04878048780487805,6.0,0.2727272727272727,7.0,0.2692307692307692,8.0,0.36363636363636365
793,cdk,"public List vertexList(){
    List vertices = new ArrayList(edgeSet().size());
    Object startVertex = vertexSet().iterator().next();
    Object vertex = startVertex;
    Object previousVertex = null;
    Object nextVertex = null;
    while (nextVertex != startVertex) {
        assert (degreeOf(vertex) == 2);
        List edges = edgesOf(vertex);
        vertices.add(vertex);
        Edge edge = (Edge) edges.get(0);
        nextVertex = edge.oppositeVertex(vertex);
        if (nextVertex == previousVertex) {
            edge = (Edge) edges.get(1);
            nextVertex = edge.oppositeVertex(vertex);
        }
        previousVertex = vertex;
        vertex = nextVertex;
    }
    return vertices;
}",vertexList,org/openscience/cdk/ringsearch/cyclebasis/SimpleCycle.java,/legacy/src/main/java/org/openscience/cdk/ringsearch/cyclebasis/SimpleCycle.java,"/**
     * Returns a list of the vertices contained in this cycle.
     * The vertices are in the order of a traversal of the cycle.
     *
     * @return a list of the vertices contained in this cycle
     */",100-135,"('vertexList', {'INSTRUCTION': {'covered': 64, 'missed': 4}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",147.0,11.0,Returns a list of the vertices contained in this cycle.,Get a list of all the vertices in this cycle,The list contains the vertices.,0.373500147961908,Returns a list of the vertices in this cycle.," public List vertexList(){
        List result = new ArrayList();
        Iterator vertexIterator = vertexSet().iterator();
        while (vertexIterator.hasNext()) {
            result.add(vertexIterator.next());
        }
        return result;
    }"," public List vertexList(){
        List vertexList = new ArrayList();
        Iterator vertexIterator = vertexSet().iterator();
        while (vertexIterator.hasNext()){
            vertexList.add(vertexIterator.next());
        }
        return vertexList;
    }"," public List vertexList(){
        return new ArrayList(vertexSet());      
 }"," public List vertexList(){
        List result = new ArrayList();
        Iterator vertexIterator = vertexSet().iterator();
        while (vertexIterator.hasNext()) {
            result.add(vertexIterator.next());
        }
        return result;
    }",PASS,PASS,PASS,PASS,  0.12972462336076346,  0.12972462336076346,  0.12972462336076346,  0.05906176098512707,108.0,0.7297297297297297,108.0,0.7297297297297297,108.0,0.7297297297297297,132.0,0.8918918918918919,3.0,0.058823529411764705,0.0,0.0,35.0,0.6862745098039216,4.0,0.36363636363636365,1.0,0.09090909090909091,8.0,0.7272727272727273
794,acs-aem-commons,"public Resource create(@Nonnull final Resource ensuredDefinition, @Nonnull final Resource oakIndexes) throws RepositoryException{
    final Node oakIndex = JcrUtil.copy(ensuredDefinition.adaptTo(Node.class), oakIndexes.adaptTo(Node.class), ensuredDefinition.getName());
    oakIndex.setPrimaryType(NT_OAK_QUERY_INDEX_DEFINITION);
    oakIndex.setProperty(JcrConstants.JCR_CREATED, Calendar.getInstance());
    oakIndex.setProperty(JcrConstants.JCR_CREATED_BY, ENSURE_OAK_INDEX_USER_NAME);
    log.info(""Created Oak Index at [ {} ] with Ensure Definition [ {} ]"", oakIndex.getPath(), ensuredDefinition.getPath());
    return ensuredDefinition.getResourceResolver().getResource(oakIndex.getPath());
}",create,com/adobe/acs/commons/oak/impl/EnsureOakIndexJobHandler.java,/bundle/src/main/java/com/adobe/acs/commons/oak/impl/EnsureOakIndexJobHandler.java,"/**
     * Create the oak index based on the ensure definition.
     *
     * @param ensuredDefinition the ensure definition
     * @param oakIndexes        the parent oak index folder
     * @return the updated oak index resource
     * @throws PersistenceException
     * @throws RepositoryException
     */",350-375,"('create', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",121.0,10.0,Create the oak index based on the ensure definition.,This method creates the oak index based on the ensure definition,The oak index is created based on the ensure definition.,0.338558939560389,Create the oak index based on the warranty definition.," public Resource create(@Nonnull final Resource ensuredDefinition, @Nonnull final Resource oakIndexes) throws RepositoryException{
        final ValueMap ensuredDefinitionProperties = ensuredDefinition.getValueMap();
        final String ensuredDefinitionName = ensuredDefinition.getName();
        final String ensuredDefinitionPath = ensuredDefinition.getPath();
        final String oakIndexesPath = oakIndexes.getPath();
    
        final String oakIndexName = ensuredDefinitionProperties.get(PN_NAME, ensuredDefinitionName);
        final String oakIndexPath = oakIndexesPath + ""/"" + oakIndexName;
    
        final Resource oakIndex = resourceResolver.getResource(oakIndexPath);
        if (oakIndex != null) {
            log.info(""Skipping creation of existing Oak Index at [ {} ]"", oakIndexPath);
            return oakIndex;
        }
    
        final String oakIndexType = ensuredDefinitionProperties.get(PN_TYPE, DEFAULT_TYPE);
        final String oakIndexPaths = ensuredDefinitionProperties.get(PN_PATHS, """");
        final String oakIndexQuery = ensuredDefinitionProperties.get(PN_QUERY, """");
        final String oakIndexQueryLanguage = ensuredDefinitionProperties.get(PN_QUERY_LANGUAGE, DEFAULT_QUERY_LANGUAGE);
        final String oakIndexQueryType = ensuredDefinitionProperties.get(PN_QUERY_TYPE, DEFAULT_QUERY_TYPE);
        final String oakIndexQueryAnalyzer = ensuredDefinitionProperties.get(PN_QUERY_ANALYZER, DEFAULT_QUERY_ANALYZER);
        final String oakIndexQueryAnalyzerLanguage = ensuredDefinitionProperties.get(PN_QUERY_ANALYZER_LANGUAGE, DEFAULT_QUERY_ANALYZER_LANGUAGE);
        final String oakIndexQueryAnalyzerType = ensuredDefinitionProperties.get(PN_QUERY_ANALYZER_TYPE, DEFAULT_QUERY_ANALYZER_TYPE);
        final String oakIndexQueryAnalyzerVersion = ensuredDefinitionProperties.get(PN_QUERY_ANALYZER_VERSION, DEFAULT_QUERY_ANALYZER_VERSION);
        final String oakIndexQueryAnalyzerVersionLanguage       
 }"," public Resource create(@Nonnull final Resource ensuredDefinition, @Nonnull final Resource oakIndexes) throws RepositoryException{
        final ValueMap ensuredDefinitionProperties = ensuredDefinition.getValueMap();
        final String ensuredDefinitionName = ensuredDefinition.getName();
        final String ensuredDefinitionPath = ensuredDefinition.getPath();
        final String oakIndexesPath = oakIndexes.getPath();
    
        final String oakIndexName = ensuredDefinitionProperties.get(PN_NAME, ensuredDefinitionName);
        final String oakIndexPath = oakIndexesPath + ""/"" + oakIndexName;
    
        final Resource oakIndex = resourceResolver.getResource(oakIndexPath);
        if (oakIndex != null) {
            log.info(""Skipping creation of existing Oak Index at [ {} ]"", oakIndexPath);
            return oakIndex;
        }
    
        final String oakIndexType = ensuredDefinitionProperties.get(PN_TYPE, DEFAULT_TYPE);
        final String oakIndexPaths = ensuredDefinitionProperties.get(PN_PATHS, """");
        final String oakIndexQuery = ensuredDefinitionProperties.get(PN_QUERY, """");
        final String oakIndexQueryLanguage = ensuredDefinitionProperties.get(PN_QUERY_LANGUAGE, DEFAULT_QUERY_LANGUAGE);
        final String oakIndexQueryType = ensuredDefinitionProperties.get(PN_QUERY_TYPE, DEFAULT_QUERY_TYPE);
        final String oakIndexQueryAnalyzer = ensuredDefinitionProperties.get(PN_QUERY_ANALYZER, DEFAULT_QUERY_ANALYZER);
        final String oakIndexQueryAnalyzerLanguage = ensuredDefinitionProperties.get(PN_QUERY_ANALYZER_LANGUAGE, DEFAULT_QUERY_ANALYZER_LANGUAGE);
        final String oakIndexQueryAnalyzerType = ensuredDefinitionProperties.get(PN_QUERY_ANALYZER_TYPE, DEFAULT_QUERY_ANALYZER_TYPE);
        final String oakIndexQueryAnalyzerVersion = ensuredDefinitionProperties.get(PN_QUERY_ANALYZER_VERSION, DEFAULT_QUERY_ANALYZER_VERSION);
        final String oakIndexQueryAnalyzerVersionLanguage       
 }"," public Resource create(@Nonnull final Resource ensuredDefinition, @Nonnull final Resource oakIndexes) throws RepositoryException{
        final ValueMap ensureDefinitionProperties = ensuredDefinition.getValueMap();
        final String indexName = ensuredDefinition.getName();
        final String indexPath = ensuredDefinition.getPath();
    
        final String indexType = ensureDefinitionProperties.get(PN_TYPE, DEFAULT_TYPE);
        final String indexPathPrefix = ensureDefinitionProperties.get(PN_PATH_PREFIX, DEFAULT_PATH_PREFIX);
        final String indexPathSuffix = ensureDefinitionProperties.get(PN_PATH_SUFFIX, DEFAULT_PATH_SUFFIX);
        final String indexPathDelimiter = ensureDefinitionProperties.get(PN_PATH_DELIMITER, DEFAULT_PATH_DELIMITER);
        final String indexPathDelimiterRegex = ensureDefinitionProperties.get(PN_PATH_DELIMITER_REGEX, DEFAULT_PATH_DELIMITER_REGEX);
        final String indexPathDelimiterReplacement = ensureDefinitionProperties.get(PN_PATH_DELIMITER_REPLACEMENT, DEFAULT_PATH_DELIMITER_REPLACEMENT);
        final String indexPathDelimiterReplacementRegex = ensureDefinitionProperties.get(PN_PATH_DELIMITER_REPLACEMENT_REGEX, DEFAULT_PATH_DELIMITER_REPLACEMENT_REGEX);
        final String indexPathDelimiterReplacementReplacement = ensureDefinitionProperties.get(PN_PATH_DELIMITER_REPLACEMENT_REPLACEMENT, DEFAULT_PATH_DELIMITER_REPLACEMENT_REPLACEMENT);
        final String indexPathDelimiterReplacementReplacementRegex = ensureDefinitionProperties.get(PN_PATH_DELIMITER_REPLACEMENT_REPLACEMENT_REGEX, DEFAULT_PATH_DELIMITER_REPLACEMENT_REPLACEMENT_REGEX);
        final String indexPathDelimiterReplacementReplacementReplacement = ensureDefinitionProperties.get(PN_PATH_DELIMITER_REPLACEMENT_REPLAC      
 }"," public Resource create(@Nonnull final Resource ensuredDefinition, @Nonnull final Resource oakIndexes) throws RepositoryException{
        final ValueMap ensuredDefinitionProperties = ensuredDefinition.getValueMap();
        final String ensuredIndexName = ensuredDefinition.getName();
        final String ensuredIndexPath = ensuredDefinition.getPath();
    
        final String ensuredIndexType = ensuredDefinitionProperties.get(PN_TYPE, DEFAULT_TYPE);
        final String ensuredIndexPathPrefix = ensuredDefinitionProperties.get(PN_PATH_PREFIX, DEFAULT_PATH_PREFIX);
        final String ensuredIndexPathSuffix = ensuredDefinitionProperties.get(PN_PATH_SUFFIX, DEFAULT_PATH_SUFFIX);
        final String ensuredIndexPathDelimiter = ensuredDefinitionProperties.get(PN_PATH_DELIMITER, DEFAULT_PATH_DELIMITER);
        final String ensuredIndexPathDelimiterRegex = ensuredDefinitionProperties.get(PN_PATH_DELIMITER_REGEX, DEFAULT_PATH_DELIMITER_REGEX);
        final String ensuredIndexPathDelimiterReplacement = ensuredDefinitionProperties.get(PN_PATH_DELIMITER_REPLACEMENT, DEFAULT_PATH_DELIMITER_REPLACEMENT);
        final String ensuredIndexPathDelimiterReplacementRegex = ensuredDefinitionProperties.get(PN_PATH_DELIMITER_REPLACEMENT_REGEX, DEFAULT_PATH_DELIMITER_REPLACEMENT_REGEX);
        final String ensuredIndexPathDelimiterReplacementRegexFlags = ensuredDefinitionProperties.get(PN_PATH_DELIMITER_REPLACEMENT_REGEX_FLAGS, DEFAULT_PATH_DELIMITER_REPLACEMENT_REGEX_FLAGS);
        final String ensuredIndexPathDelimiterReplacementRegexGroup = ensuredDefinitionProperties.get(PN_PATH_DELIMITER_REPLACEMENT_REGEX_GROUP, DEFAULT_PATH_DELIMITER_REPLACEMENT_REGEX_GROUP);
        final String ensuredIndexPathDelimiterReplacementRegexGroupFlags = ensuredDefinitionProperties.get(PN_PATH_DELIMITER_       
 }",Syntax Error,Syntax Error,Syntax Error,Syntax Error,None,None,None,None,None,None,None,None,115.0,0.6497175141242938,115.0,0.6497175141242938,None,None,89.0,0.37872340425531914,100.0,0.425531914893617,4.0,0.3333333333333333,1.0,0.1,4.0,0.36363636363636365
795,cdk,"public int test(Permutation permutation){
    for (int i = 0; i < size; i++) {
        int x = permutation.get(base.get(i));
        Permutation h = permutations[i][x];
        if (h == null) {
            return i;
        } else {
            permutation.setTo(h.invert().multiply(permutation));
        }
    }
    return size;
}",test,org/openscience/cdk/group/PermutationGroup.java,/tool/group/src/main/java/org/openscience/cdk/group/PermutationGroup.java,"/**
     * Test a permutation to see if it is in the group. Note that this also
     * alters the permutation passed in.
     *
     * @param permutation the one to test
     * @return the position it should be in the group, if any
     */",384-402,"('test', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,12.0,Test a permutation to see if it is in the group.,Check if a permutation is in the group,"If you can test a permutation, it is in the group.",0.523861045048062,Test a swap to see if it is in the group.,"public int test(Permutation permutation){
        int i = 0;
        for (int j = 0; j < size; j++) {
            if (permutations[j][permutation.get(base.get(j))] != null) {
                i++;
            }
        }
        return i;
    }","public int test(Permutation permutation){
        int i = 0;
        for (Permutation p : all()) {
            if (p.equals(permutation)) {
                return i;
            }
            i++;
        }
        return size;
    }","public int test(Permutation permutation){
        int deg = size;
        int i = 0;
        for (int j = 0; j < deg; j++) {
            int x = permutation.get(base.get(j));
            if (x != j) {
                i = j;
                break;
            }
        }
        return i;
    }","public int test(Permutation permutation){
        int i = 0;
        int j = 0;
        int deg = size;
        int[] base = this.base.getArray();
        int[] permutationArray = permutation.getArray();
        for (i = 0; i < deg; i++) {
            j = base[i];
            if (permutationArray[j] != i) {
                return i;
            }
        }
        return i;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.41796037705548794,  0.3371676133429905,  0.4424585545698542,  0.42956132856298923,52.0,0.611764705882353,55.0,0.6470588235294118,59.0,0.6704545454545454,50.0,0.5882352941176471,30.0,0.4918032786885246,51.0,0.5795454545454546,22.0,0.3235294117647059,7.0,0.5833333333333334,1.0,0.08333333333333333,6.0,0.5
796,shardingsphere-elasticjob,"public static CoordinatorRegistryCenter createCoordinatorRegistryCenter(final String connectString, final String namespace, final String digest){
    Hasher hasher = Hashing.sha256().newHasher().putString(connectString, StandardCharsets.UTF_8).putString(namespace, StandardCharsets.UTF_8);
    if (!Strings.isNullOrEmpty(digest)) {
        hasher.putString(digest, StandardCharsets.UTF_8);
    }
    HashCode hashCode = hasher.hash();
    return REG_CENTER_REGISTRY.computeIfAbsent(hashCode, unused -> {
        CoordinatorRegistryCenter result = newCoordinatorRegistryCenter(connectString, namespace, digest);
        result.init();
        return result;
    });
}",createCoordinatorRegistryCenter,org/apache/shardingsphere/elasticjob/lite/lifecycle/internal/reg/RegistryCenterFactory.java,/elasticjob-lite/elasticjob-lite-lifecycle/src/main/java/org/apache/shardingsphere/elasticjob/lite/lifecycle/internal/reg/RegistryCenterFactory.java,"/**
     * Create a {@link CoordinatorRegistryCenter} or return the existing one if there is one set up with the same {@code connectionString}, {@code namespace} and {@code digest} already.
     *
     * @param connectString registry center connect string
     * @param namespace registry center namespace
     * @param digest registry center digest
     * @return registry center
     */",43-62,"('createCoordinatorRegistryCenter', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",116.0,40.0,"Create a {@link CoordinatorRegistryCenter} or return the existing one if there is one set up with the same {@code connectionString}, {@code namespace} and {@code digest} already.",Build a CoordinatorRegistryCenter or return the existing one if there is one set up with the given connection string,"If there is one set up with the same @code connectionString, @code namespace and @code digest already, then create a @link coordinators or return the existing one.",1.09079148669036,"Create a {@link CoordinatorRegistryCenter} or return the existing one if there is already one with the same {@code connectionString}, {@code namespace} and {@code digest}.","public static CoordinatorRegistryCenter createCoordinatorRegistryCenter(final String connectString, final String namespace, final String digest){
        if (Strings.isNullOrEmpty(connectString) || Strings.isNullOrEmpty(namespace) || Strings.isNullOrEmpty(digest)) {
            throw new IllegalArgumentException(""Connection string, namespace and digest must not be null or empty."");
        }
        final HashCode hashCode = Hashing.sha256().hashString(connectString + namespace + digest, StandardCharsets.UTF_8);
        CoordinatorRegistryCenter regCenter = REG_CENTER_REGISTRY.get(hashCode);
        if (null == regCenter) {
            regCenter = new ZookeeperRegistryCenter(new ZookeeperConfiguration(connectString, namespace));
            REG_CENTER_REGISTRY.put(hashCode, regCenter);
        }
        return regCenter;
    }","public static CoordinatorRegistryCenter createCoordinatorRegistryCenter(final String connectString, final String namespace, final String digest){
        if (Strings.isNullOrEmpty(connectString)) {
            throw new IllegalArgumentException(""Connection string can not be null or empty."");
        }
        if (Strings.isNullOrEmpty(namespace)) {
            throw new IllegalArgumentException(""Namespace can not be null or empty."");
        }
        if (Strings.isNullOrEmpty(digest)) {
            throw new IllegalArgumentException(""Digest can not be null or empty."");
        }
        final HashCode hashCode = Hashing.sha256().hashString(connectString + namespace + digest, StandardCharsets.UTF_8);
        CoordinatorRegistryCenter regCenter = REG_CENTER_REGISTRY.get(hashCode);
        if (null == regCenter) {
            regCenter = new ZookeeperRegistryCenter(new ZookeeperConfiguration(connectString, namespace));
            REG_CENTER_REGISTRY.put(hashCode, regCenter);
        }
        return regCenter;
    }","public static CoordinatorRegistryCenter createCoordinatorRegistryCenter(final String connectString, final String namespace, final String digest){
        if (Strings.isNullOrEmpty(connectString) || Strings.isNullOrEmpty(namespace) || Strings.isNullOrEmpty(digest)) {
            throw new IllegalArgumentException(""connectString, namespace and digest must not be null or empty."");
        }
        final HashCode hashCode = Hashing.sha256().hashString(connectString + namespace + digest, StandardCharsets.UTF_8);
        CoordinatorRegistryCenter regCenter = REG_CENTER_REGISTRY.get(hashCode);
        if (null == regCenter) {
            ZookeeperConfiguration zookeeperConfiguration = new ZookeeperConfiguration(connectString, namespace);
            regCenter = new ZookeeperRegistryCenter(zookeeperConfiguration);
            REG_CENTER_REGISTRY.put(hashCode, regCenter);
        }
        return regCenter;
    }","public static CoordinatorRegistryCenter createCoordinatorRegistryCenter(final String connectString, final String namespace, final String digest){
        if (Strings.isNullOrEmpty(connectString) || Strings.isNullOrEmpty(namespace) || Strings.isNullOrEmpty(digest)) {
            throw new IllegalArgumentException(""Connection string, namespace and digest must not be null or empty."");
        }
        final HashCode hashCode = Hashing.sha256().hashString(connectString + namespace + digest, StandardCharsets.UTF_8);
        CoordinatorRegistryCenter regCenter = REG_CENTER_REGISTRY.get(hashCode);
        if (null == regCenter) {
            regCenter = new ZookeeperRegistryCenter(new ZookeeperConfiguration(connectString, namespace));
            REG_CENTER_REGISTRY.put(hashCode, regCenter);
        }
        return regCenter;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.48299637234028625,  0.46489716320405394,  0.47518387234028625,  0.4736531971456662,71.0,0.5966386554621849,82.0,0.5815602836879432,71.0,0.5966386554621849,75.0,0.6048387096774194,25.0,0.1773049645390071,0.0,0.0,13.0,0.10483870967741936,12.0,0.4444444444444444,5.0,0.18518518518518517,26.0,0.9285714285714286
799,dcache,"public StatePath childPath(){
    if (_elements == null || _elements.size() <= 1) {
        return null;
    }
    return new StatePath(_elements.subList(1, _elements.size()), _elements.size() - 1);
}",childPath,org/dcache/services/info/base/StatePath.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StatePath.java,"/**
     * Build a new StatePath that points to the same location from the immediate child's
     * point-of-view.  For example, if the current path is characterised as <tt>aa.bb.cc</tt>, then
     * the returned StatePath is characterised by <tt>bb.cc</tt>.
     * <p>
     * If the path has no children of children, null is returned.
     *
     * @return the path for the child element, or null if there is no child.
     */",377-392,"('childPath', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",52.0,17.0,Build a new StatePath that points to the same location from the immediate child's  point-of-view.,Create a new StatePath that points to the same location from the immediate child's point-of-view,A new StatePath should point to the same location as the one the child is currently in.,0.235997393693633,Create a new StatePath that points to the same location from the perspective of the immediate child.," public StatePath childPath(){
        StatePath newPath = new StatePath(_elements, _elements.size());
        return newPath;
    }"," public StatePath childPath(){
        StatePath newPath = new StatePath(_elements, _elements.size());
        return newPath;
    }"," public StatePath childPath(){
        return new StatePath(_elements, _elements.size());
    }"," public StatePath childPath(){
        StatePath newPath = new StatePath(_elements, _elements.size());
        return newPath;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.31396654636336824,  0.31396654636336824,  0.28271654636336824,  0.2830829584369363,33.0,0.6226415094339622,33.0,0.6226415094339622,33.0,0.6226415094339622,32.0,0.6037735849056604,0.0,0.0,0.0,0.0,6.0,0.23076923076923078,2.0,0.125,6.0,0.3333333333333333,11.0,0.6111111111111112
800,weblogic-kubernetes-operator," static WlsDynamicServerConfig create(String name, int index, String clusterName, String domainName, boolean calculatedListenPorts, WlsServerConfig serverTemplate){
    Integer listenPort = serverTemplate.getListenPort();
    Integer sslListenPort = serverTemplate.getSslListenPort();
    List<NetworkAccessPoint> networkAccessPoints = new ArrayList<>();
    if (serverTemplate.getNetworkAccessPoints() != null) {
        for (NetworkAccessPoint networkAccessPoint : serverTemplate.getNetworkAccessPoints()) {
            Integer networkAccessPointListenPort = networkAccessPoint.getListenPort();
            if (calculatedListenPorts) {
                networkAccessPointListenPort = networkAccessPointListenPort == null ? (DEFAULT_NAP_LISTEN_PORT_RANGE_BASE + index) : networkAccessPointListenPort + index;
            }
            networkAccessPoints.add(new NetworkAccessPoint(networkAccessPoint.getName(), networkAccessPoint.getProtocol(), networkAccessPointListenPort, networkAccessPoint.getPublicPort()));
        }
    }
    // calculate listen ports if configured to do so
    if (calculatedListenPorts) {
        listenPort = (listenPort == null) ? (DEFAULT_LISTEN_PORT_RANGE_BASE + index) : (listenPort + index);
        sslListenPort = (sslListenPort == null) ? (DEFAULT_SSL_LISTEN_PORT_RANGE_BASE + index) : (sslListenPort + index);
    }
    MacroSubstitutor macroSubstitutor = new MacroSubstitutor(index, name, clusterName, domainName, serverTemplate.getMachineName());
    return new WlsDynamicServerConfig(name, listenPort, macroSubstitutor.substituteMacro(serverTemplate.getListenAddress()), sslListenPort, macroSubstitutor.substituteMacro(serverTemplate.getMachineName()), serverTemplate.getAdminPort(), networkAccessPoints);
}",create,oracle/kubernetes/operator/wlsconfig/WlsDynamicServerConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsDynamicServerConfig.java,"/**
   * Create a dynamic server config using server template and index number of this server.
   *
   * @param name Name of the server
   * @param index index of this server within the cluster, for example, the index of dserver-2 would
   *     be 2
   * @param clusterName name of the WLS cluster that this server belongs to
   * @param domainName name of the WLS domain that this server belongs to
   * @param calculatedListenPorts whether listen ports are calculated according to configuration in
   *     the dynamic cluster
   * @param serverTemplate server template used for servers in the dynamic cluster
   * @return a dynamic server configuration object containing configuration of this dynamic server
   */",47-106,"('create', {'INSTRUCTION': {'covered': 109, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 26, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",248.0,15.0,Create a dynamic server config using server template and index number of this server.,Build a dynamic server config using server template with the given index number,The server template and index number are used to create a dynamic server config.,0.322253237376107,Create a dynamic server configuration using the server model and index number of that server.,"  static WlsDynamicServerConfig create(String name, int index, String clusterName, String domainName, boolean calculatedListenPorts, WlsServerConfig serverTemplate){
    WlsDynamicServerConfig dynamicServerConfig = new WlsDynamicServerConfig(
        name,
        serverTemplate.getListenPort(),
        serverTemplate.getListenAddress(),
        serverTemplate.getSslListenPort(),
        serverTemplate.getMachineName(),
        serverTemplate.getAdminPort(),
        serverTemplate.getNetworkAccessPoints());
    dynamicServerConfig.setClusterName(clusterName);
    dynamicServerConfig.setDomainName(domainName);
    dynamicServerConfig.setCalculatedListenPorts(calculatedListenPorts);
    dynamicServerConfig.setIndex(index);
    return dynamicServerConfig;     
  }","  static WlsDynamicServerConfig create(String name, int index, String clusterName, String domainName, boolean calculatedListenPorts, WlsServerConfig serverTemplate){
    WlsDynamicServerConfig dynamicServerConfig = new WlsDynamicServerConfig(
        name,
        serverTemplate.getListenPort(),
        serverTemplate.getListenAddress(),
        serverTemplate.getSslListenPort(),
        serverTemplate.getMachineName(),
        serverTemplate.getAdminPort(),
        serverTemplate.getNetworkAccessPoints());
    dynamicServerConfig.setClusterName(clusterName);
    dynamicServerConfig.setDomainName(domainName);
    dynamicServerConfig.setCalculatedListenPorts(calculatedListenPorts);
    dynamicServerConfig.setIndex(index);
    return dynamicServerConfig;     
  }","  static WlsDynamicServerConfig create(String name, int index, String clusterName, String domainName, boolean calculatedListenPorts, WlsServerConfig serverTemplate){
    WlsDynamicServerConfig dynamicServerConfig = new WlsDynamicServerConfig(
        name,
        null,
        null,
        null,
        null,
        null,
        null);
    dynamicServerConfig.setName(name);
    dynamicServerConfig.setClusterName(clusterName);
    dynamicServerConfig.setDomainName(domainName);
    dynamicServerConfig.setServerTemplate(serverTemplate);
    dynamicServerConfig.setIndex(index);
    dynamicServerConfig.setCalculatedListenPorts(calculatedListenPorts);
    return dynamicServerConfig;     
  }","  static WlsDynamicServerConfig create(String name, int index, String clusterName, String domainName, boolean calculatedListenPorts, WlsServerConfig serverTemplate){
    WlsDynamicServerConfig dynamicServerConfig = new WlsDynamicServerConfig(
        name,
        null,
        null,
        null,
        null,
        null,
        null);
    dynamicServerConfig.setName(name);
    dynamicServerConfig.setClusterName(clusterName);
    dynamicServerConfig.setDomainName(domainName);
    dynamicServerConfig.setListenPort(serverTemplate.getListenPort());
    dynamicServerConfig.setListenAddress(serverTemplate.getListenAddress());
    dynamicServerConfig.setSslListenPort(serverTemplate.getSslListenPort());
    dynamicServerConfig.setAdminPort(serverTemplate.getAdminPort());
    dynamicServerConfig.setMachineName(serverTemplate.getMachineName());
    dynamicServerConfig.setNetworkAccessPoints(serverTemplate.getNetworkAccessPoints());
    dynamicServerConfig.setCalculatedListenPorts(calculatedListenPorts);
    dynamicServerConfig.setListenPortRangeBase(serverTemplate.getListenPortRangeBase());
    dynamicServerConfig.setSslListenPortRangeBase(serverTemplate.getSslListenPortRangeBase());
    dynamicServerConfig.setNapListenPortRangeBase(serverTemplate.getNapListenPortRangeBase());
    dynamicServerConfig.setListenPortRangeSize(serverTemplate.getListenPortRangeSize());
    dynamicServerConfig.setSslListenPortRangeSize(serverTemplate.getSslListenPortRangeSize());
    dynamicServerConfig.setNapListenPortRangeSize(serverTemplate.getNapListenPortRangeSize());
    dynamicServerConfig.setListenPortRangeIncrement(serverTemplate.getListenPortRangeIncrement());
    dynamicServerConfig.setSslListenPortRangeIncrement(serverTemplate.getSslListenPortRangeIncrement());
    dynamicServerConfig.setNapListenPortRangeIncrement(serverTemplate.getNapListenPortRangeIncrement());
    dynamicServerConfig.setListenPortRangeStart(serverTemplate.getListenPortRangeStart());
    dynamicServerConfig.setSslListenPortRangeStart(serverTemplate.getSslListenPortRangeStart());
    dynamicServerConfig.setNapListenPortRangeStart(serverTemplate.getNapListenPortRangeStart());
    dynamicServerConfig.      
  }",NOT PASS,NOT PASS,Syntax Error,NOT PASS,  0.2689234566156419,  0.2689234566156419,None,  0.131673544583443,183.0,0.7349397590361446,183.0,0.7349397590361446,186.0,0.6788321167883211,194.0,0.7791164658634538,0.0,0.0,189.0,0.6897810218978102,35.0,0.3465346534653465,7.0,0.4666666666666667,4.0,0.25,14.0,0.9333333333333333
801,matsim-libs,"public static double calculateSpeedIfNoSpeedTag(double linkLength, LinkProperties properties){
    if (properties.hierarchyLevel > LinkProperties.LEVEL_MOTORWAY && properties.hierarchyLevel <= LinkProperties.LEVEL_TERTIARY && linkLength <= 300) {
        return ((2.7778 + (properties.freespeed - 2.7778) / 300 * linkLength));
    }
    return properties.freespeed;
}",calculateSpeedIfNoSpeedTag,org/matsim/contrib/osm/networkReader/LinkProperties.java,/contribs/osm/src/main/java/org/matsim/contrib/osm/networkReader/LinkProperties.java,"/**
         * For links with unknown max speed we assume that links with a length of less than 300m are urban links. For urban
         * links with a length of 0m the speed is 10km/h. For links with a length of 300m the speed is the default freespeed
         * property for that highway type. For links with a length between 0 and 300m the speed is interpolated linearly.
         * (2.778m/s ~ 10km/h)
         *
         * All links longer than 300m the default freesped property is assumed
         */",174-188,"('calculateSpeedIfNoSpeedTag', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,21.0,For links with unknown max speed we assume that links with a length of less than 300m are urban links.,Calculate the speed if the given speed tag is not provided,We assume links with a length of less than 300m are urban links.,0.340750096988916,"For links with an unknown maximum speed, we assume that links with a length of less than 300 m are urban links.","public static double calculateSpeedIfNoSpeedTag(double linkLength, LinkProperties properties){
	 double urbanSpeedFactor = linkLength < 300 ? DEFAULT_FREESPEED_FACTOR : 1.0;
	 return properties.freespeed * urbanSpeedFactor;
 }"," public static double calculateSpeedIfNoSpeedTag(double linkLength, LinkProperties properties){
	 double speed = properties.freespeed;
	 if(linkLength > properties.oneway){
		 speed = properties.freespeed;
	 }
	 return speed;
 }","public static double calculateSpeedIfNoSpeedTag(double linkLength, LinkProperties properties){
	 double urbanSpeedFactor = linkLength < 300 ? 2 : 1;
	 return properties.freespeed * urbanSpeedFactor;
 }","public static double calculateSpeedIfNoSpeedTag(double linkLength, LinkProperties properties){
	 double urbanSpeedFactor = linkLength < 300 ? DEFAULT_FREESPEED_FACTOR : 1.0;
	 return properties.freespeed * urbanSpeedFactor;
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.35150452053837494,  0.42132618370436703,  0.35150452053837494,  0.35150452053837494,41.0,0.6612903225806451,36.0,0.5806451612903226,41.0,0.6612903225806451,41.0,0.6612903225806451,19.0,0.475,0.0,0.0,2.0,0.0625,19.0,0.9047619047619048,5.0,0.21739130434782608,8.0,0.38095238095238093
802,matsim-libs,"public static URL resolveFileOrResource(String filename) throws UncheckedIOException{
    try {
        // I) do not handle URLs
        if (filename.startsWith(""jar:file:"") || filename.startsWith(""file:"") || filename.startsWith(""https:"")) {
            // looks like an URI
            return new URL(filename);
        }
        // II) Replace home identifier
        if (filename.startsWith(""~"" + File.separator)) {
            filename = System.getProperty(""user.home"") + filename.substring(1);
        }
        // III.1) First, try to find the file in the file system
        File file = new File(filename);
        if (file.exists()) {
            logger.info(String.format(""Resolved %s to %s"", filename, file));
            return file.toURI().toURL();
        }
        // III.2) Try to find file with an additional postfix for compression
        for (String postfix : COMPRESSION_EXTENSIONS.keySet()) {
            file = new File(filename + ""."" + postfix);
            if (file.exists()) {
                logger.info(String.format(""Resolved %s to %s"", filename, file));
                return file.toURI().toURL();
            }
        }
        // IV.1) First, try to find the file in the class path
        URL resource = IOUtils.class.getClassLoader().getResource(filename);
        if (resource != null) {
            logger.info(String.format(""Resolved %s to %s"", filename, resource));
            return resource;
        }
        // IV.2) Second, try to find the resource with a compression extension
        for (String postfix : COMPRESSION_EXTENSIONS.keySet()) {
            resource = IOUtils.class.getClassLoader().getResource(filename + ""."" + postfix);
            if (resource != null) {
                logger.info(String.format(""Resolved %s to %s"", filename, resource));
                return resource;
            }
        }
        throw new FileNotFoundException(filename);
    } catch (FileNotFoundException | MalformedURLException e) {
        throw new UncheckedIOException(e);
    }
}",resolveFileOrResource,org/matsim/core/utils/io/IOUtils.java,/matsim/src/main/java/org/matsim/core/utils/io/IOUtils.java,"/**
         * This function takes a path and tries to find the file in the file system or
         * in the resource path. The order of resolution is as follows:
         * 
         * <ol>
         * <li>Find path in file system</li>
         * <li>Find path in file system with compression extension (e.g. *.gz)</li>
         * <li>Find path in class path as resource</li>
         * <li>Find path in class path with compression extension</li>
         * </ol>
         *
         * In case the filename is a URL (i.e. starting with ""file:"" or ""jar:file:""),
         * then no resolution is done but the provided filename returned as URL.
         * 
         * @throws UncheckedIOException
         */",154-223,"('resolveFileOrResource', {'INSTRUCTION': {'covered': 159, 'missed': 7}, 'BRANCH': {'covered': 17, 'missed': 3}, 'LINE': {'covered': 26, 'missed': 1}, 'COMPLEXITY': {'covered': 8, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",311.0,21.0,This function takes a path and tries to find the file in the file system or  in the resource path.,This function tries to find in the given path if the file is in the file system or in the resource path,The function tries to find the file in the file system or the resource path.,0.429762610946329,This function takes a path and attempts to find the file in the file system or in the resource path.," public static URL resolveFileOrResource(String filename) throws UncheckedIOException{
	 		URL url = null;
 		try {
 			url = new URL(filename);
 		} catch (MalformedURLException e) {
 			// ignore
 		}
 		if (url == null) {
 			url = IOUtils.class.getResource(filename);
 		}
 		if (url == null) {
 			url = IOUtils.class.getClassLoader().getResource(filename);
 		}
 		if (url == null) {
 			url = new File(filename).toURI().toURL();
 		}
 		if (url == null) {
 			throw new UncheckedIOException(""Could not find file or resource '"" + filename + ""'."");
 		}
 		return url;
 	}"," public static URL resolveFileOrResource(String filename) throws UncheckedIOException{
	 		URL url = null;
 		try {
 			url = new URL(filename);
 		} catch (MalformedURLException e) {
 			// ignore
 		}
 		if (url == null) {
 			url = IOUtils.class.getResource(filename);
 		}
 		if (url == null) {
 			url = IOUtils.class.getClassLoader().getResource(filename);
 		}
 		if (url == null) {
 			url = new File(filename).toURI().toURL();
 		}
 		if (url == null) {
 			throw new UncheckedIOException(""Could not find file "" + filename);
 		}
 		return url;
 	}"," public static URL resolveFileOrResource(String filename) throws UncheckedIOException{
	 		// First, try to find the file in the file system.
 		File file = new File(filename);
 		if (file.exists()) {
 			try {
 				return file.toURI().toURL();
 			} catch (MalformedURLException e) {
 				throw new UncheckedIOException(e);
 			}
 		}
 
 		// If not found, try to find the file in the class path.
 		URL url = IOUtils.class.getClassLoader().getResource(filename);
 		if (url != null) {
 			return url;
 		}
 
 		// If not found, try to find the file in the class path.
 		url = IOUtils.class.getClassLoader().getResource(""/"" + filename);
 		if (url != null) {
 			return url;
 		}
 
 		// If not found, try to find the file in the class path.
 		url = IOUtils.class.getClassLoader().getResource(""/"" + filename + ""/"");
 		if (url != null) {
 			return url;
 		}
 
 		// If not found, try to find the file in the class path.
 		url = IOUtils.class.getClassLoader().getResource(""/"" + filename + ""/."");
 		if (url != null) {
 			return url;
 		}
 
 		// If not found, try to find the file in the class path.
 		url = IOUtils.class.getClassLoader().getResource(""/"" + filename + ""/.."");
 		if (url != null) {
 			return url;
 		}
 
 		// If not found, try to find the file in the class path.
 		url = IOUtils.class.getClassLoader().getResource(""/""		
 }"," public static URL resolveFileOrResource(String filename) throws UncheckedIOException{
	 		URL url = null;
 		try {
 			url = new File(filename).toURI().toURL();
 		} catch (MalformedURLException e) {
 			// ignore
 		}
 		if (url == null) {
 			url = IOUtils.class.getResource(filename);
 		}
 		if (url == null) {
 			throw new UncheckedIOException(""Could not find file or resource "" + filename);
 		}
 		return url;
 	}",NOT PASS,NOT PASS,NOT PASS,Syntax Error,  0.21169014510964218,  0.2100383972353995,  0.15790294286679288,None,236.0,0.7564102564102564,236.0,0.7564102564102564,251.0,0.8044871794871795,211.0,0.6762820512820513,3.0,0.024193548387096774,54.0,0.43548387096774194,126.0,0.5779816513761468,10.0,0.43478260869565216,1.0,0.047619047619047616,6.0,0.2857142857142857
804,cdk,"public void addMolecule(IAtomContainer molecule){
    if (!GeometryUtil.has2DCoordinates(molecule))
        throw new IllegalArgumentException(""Template did not have 2D coordinates"");
    GeometryUtil.scaleMolecule(molecule, GeometryUtil.getScaleFactor(molecule, StructureDiagramGenerator.DEFAULT_BOND_LENGTH));
    templates.add(molecule);
    anonPatterns.add(VentoFoggia.findSubstructure(molecule, anonAtomMatcher, anonBondMatcher));
    elemPatterns.add(VentoFoggia.findSubstructure(molecule, elemAtomMatcher, anonBondMatcher));
}",addMolecule,org/openscience/cdk/layout/TemplateHandler.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/TemplateHandler.java,"/**
     * Adds a Molecule to the list of templates use by this TemplateHandler.
     *
     * @param molecule The molecule to be added to the TemplateHandler
     */",151-171,"('addMolecule', {'INSTRUCTION': {'covered': 34, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",83.0,13.0,Adds a Molecule to the list of templates use by this TemplateHandler.,This method adds the given molecule to the list of templates use by this TemplateHandler,A Molecule is added to the list of templates.,0.548572477539528,Adds a molecule to the list of templates used by this TemplateHandler.," public void addMolecule(IAtomContainer molecule){
        templates.add(molecule);
    }"," public void addMolecule(IAtomContainer molecule){
        templates.add(molecule);
    }"," public void addMolecule(IAtomContainer molecule){
        templates.add(molecule);        
 }"," public void addMolecule(IAtomContainer molecule){
        templates.add(molecule);        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.1451853910860917,  0.1451853910860917,  0.1451853910860917,  0.1451853910860917,67.0,0.7976190476190477,67.0,0.7976190476190477,67.0,0.7976190476190477,67.0,0.7976190476190477,0.0,0.0,0.0,0.0,0.0,0.0,7.0,0.4375,2.0,0.15384615384615385,9.0,0.6923076923076923
805,openapi-generator,"public static boolean isMapSchema(Schema schema){
    if (schema instanceof MapSchema) {
        return true;
    }
    if (schema == null) {
        return false;
    }
    if (schema.getAdditionalProperties() instanceof Schema) {
        return true;
    }
    if (schema.getAdditionalProperties() instanceof Boolean && (Boolean) schema.getAdditionalProperties()) {
        return true;
    }
    return false;
}",isMapSchema,org/openapitools/codegen/utils/ModelUtils.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ModelUtils.java,"/**
     * Return true if the specified 'schema' is an object that can be extended with additional properties.
     * Additional properties means a Schema should support all explicitly defined properties plus any
     * undeclared properties.
     *
     * A MapSchema differs from an ObjectSchema in the following way:
     * - An ObjectSchema is not extensible, i.e. it has a fixed number of properties.
     * - A MapSchema is an object that can be extended with an arbitrary set of properties.
     *   The payload may include dynamic properties.
     *
     * Note that isMapSchema returns true for a composed schema (allOf, anyOf, oneOf) that also defines
     * additionalproperties.
     *
     * For example, an OpenAPI schema is considered a MapSchema in the following scenarios:
     *
     *   type: object
     *   additionalProperties: true
     *
     *   type: object
     *   additionalProperties:
     *     type: object
     *     properties:
     *       code:
     *         type: integer
     *
     *   allOf:
     *     - $ref: '#/components/schemas/Class1'
     *     - $ref: '#/components/schemas/Class2'
     *   additionalProperties: true
     *
     * @param schema the OAS schema
     * @return true if the specified schema is a Map schema.
     */",477-528,"('isMapSchema', {'INSTRUCTION': {'covered': 24, 'missed': 4}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 7, 'missed': 2}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,18.0,Return true if the specified 'schema' is an object that can be extended with additional properties.,Check if the specified 'schema' is an object that can be extended with additional properties.,"If the specified'schema' is an object that can be extended with additional properties, return true.",0.516999053887491,Return true if the specified 'schema' is an object that can be extended with additional properties.," public static boolean isMapSchema(Schema schema){
        if (schema instanceof MapSchema) {
            return true;
        }
        return false;
    }"," public static boolean isMapSchema(Schema schema){
        if (schema instanceof MapSchema) {
            return true;
        }
        return false;
    }"," public static boolean isMapSchema(Schema schema){
        if (schema instanceof MapSchema) {
            return true;
        }
        return false;
    }"," public static boolean isMapSchema(Schema schema){
        if (schema instanceof MapSchema) {
            return true;
        }
        return false;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.28260382578612775,  0.28260382578612775,  0.28260382578612775,  0.28260382578612775,50.0,0.6666666666666666,50.0,0.6666666666666666,50.0,0.6666666666666666,50.0,0.6666666666666666,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.11764705882352941,0.0,0.0,8.0,0.47058823529411764
806,cdk,"private int sortClockwise(int[] indices, IAtom focus, IAtom[] atoms, int n){
    int x = 0;
    for (int j = 1; j < n; j++) {
        int v = indices[j];
        int i = j - 1;
        while ((i >= 0) && less(v, indices[i], atoms, focus.getPoint2d())) {
            indices[i + 1] = indices[i--];
            x++;
        }
        indices[i + 1] = v;
    }
    return indexParity(x);
}",sortClockwise,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,"/**
     * Sort the {@code indices}, which correspond to an index in the {@code atoms} array in
     * clockwise order.
     *
     * @param indices indices, 0 to n
     * @param focus   the central atom
     * @param atoms   the neighbors of the focus
     * @param n       the number of neighbors
     * @return the permutation parity of the sort
     */",1135-1157,"('sortClockwise', {'INSTRUCTION': {'covered': 49, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",117.0,25.0,"Sort the {@code indices}, which correspond to an index in the {@code atoms} array in  clockwise order.",This method sorts the given indices in clockwise order,Sort the @code indices by their index in the @code atoms array.,0.808115623973241,"Sort the {@code indices}, which correspond to an index in the table {@code atoms} clockwise.","private int sortClockwise(int[] indices, IAtom focus, IAtom[] atoms, int n){
        int[] rank = priority(focus, atoms, n);
        int[] sorted = new int[n];
        for (int i = 0; i < n; i++)
            sorted[i] = indices[rank[i]];
        return rank[0];
    }","private int sortClockwise(int[] indices, IAtom focus, IAtom[] atoms, int n){
        int[] rank = priority(focus, atoms, n);
        int[] sorted = new int[n];
        for (int i = 0; i < n; i++)
            sorted[i] = indices[rank[i]];
        return rank[0];
    }","private int sortClockwise(int[] indices, IAtom focus, IAtom[] atoms, int n){
        int[] rank = priority(focus, atoms, n);
        int[] sorted = new int[n];
        for (int i = 0; i < n; i++)
            sorted[i] = indices[rank[i]];
        return rank[0];
    }","private int sortClockwise(int[] indices, IAtom focus, IAtom[] atoms, int n){
        int[] rank = priority(focus, atoms, n);
        int[] sorted = new int[n];
        for (int i = 0; i < n; i++)
            sorted[i] = indices[rank[i]];
        return rank[0];
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3599566073973422,  0.3599566073973422,  0.3599566073973422,  0.3599566073973422,70.0,0.5932203389830508,70.0,0.5932203389830508,70.0,0.5932203389830508,70.0,0.5932203389830508,0.0,0.0,0.0,0.0,0.0,0.0,14.0,0.7777777777777778,5.0,0.2777777777777778,12.0,0.6666666666666666
807,liquibase,"private void parseDefaultPropertyFileFromFile(File potentialPropertyFile) throws IOException, CommandLineParsingException{
    try (FileInputStream stream = new FileInputStream(potentialPropertyFile)) {
        parsePropertiesFile(stream);
    }
}",parseDefaultPropertyFileFromFile,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,"/**
     * Open a regular property file (not embedded in a resource - use {@link #parseDefaultPropertyFileFromResource}
     * for that) and parse it.
     *
     * @param potentialPropertyFile path and file name to the the property file
     * @throws IOException                 if the file cannot be opened
     * @throws CommandLineParsingException if an error occurs during parsing
     */",799-812,"('parseDefaultPropertyFileFromFile', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,26.0,Open a regular property file (not embedded in a resource - use {@link #parseDefaultPropertyFileFromResource}  for that) and parse it.,Open a regular property file and parse it,Parse a regular property file if it is not embedded in a resource.,0.273177176905171,Open a standard properties file (not embedded in a resource - use {@link #parseDefaultPropertyFileFromResource} for this) and parse it.," private void parseDefaultPropertyFileFromFile(File potentialPropertyFile) throws IOException, CommandLineParsingException{
        try (FileInputStream fileInputStream = new FileInputStream(potentialPropertyFile)) {
            parsePropertiesFile(fileInputStream);
        }
    }"," private void parseDefaultPropertyFileFromFile(File potentialPropertyFile) throws IOException, CommandLineParsingException{
        try (FileInputStream fileInputStream = new FileInputStream(potentialPropertyFile)) {
            parsePropertiesFile(fileInputStream);
        }
    }"," private void parseDefaultPropertyFileFromFile(File potentialPropertyFile) throws IOException, CommandLineParsingException{
        try (InputStream fileAsStream = new FileInputStream(potentialPropertyFile)) {
            parsePropertiesFile(fileAsStream);
        }
    }"," private void parseDefaultPropertyFileFromFile(File potentialPropertyFile) throws IOException, CommandLineParsingException{
        try (InputStream fileAsStream = new FileInputStream(potentialPropertyFile)) {
            parsePropertiesFile(fileAsStream);
        }
    }",PASS,PASS,PASS,PASS,  0.9129939317788568,  0.9129939317788568,  0.8965234976582728,  0.8965234976582728,2.0,0.0625,2.0,0.0625,3.0,0.09375,3.0,0.09375,0.0,0.0,3.0,0.09375,3.0,0.09375,12.0,0.6,3.0,0.15,15.0,0.75
808,matsim-libs,"private void visitNode(final Node n, final AStarNodeData data, final RouterPriorityQueue<Node> pendingNodes, final double time, final double cost, final double expectedRemainingCost, final Link outLink){
    data.setExpectedRemainingCost(expectedRemainingCost);
    super.visitNode(n, data, pendingNodes, time, cost, outLink);
}",visitNode,org/matsim/core/router/AStarEuclidean.java,/matsim/src/main/java/org/matsim/core/router/AStarEuclidean.java,"/**
         * Inserts the given Node n into the pendingNodes queue and updates its time and cost information.
         * 
         * @param n The Node that is revisited.
         * @param data The data for node.
         * @param pendingNodes The nodes visited and not processed yet.
         * @param time The time of the visit of n.
         * @param cost The accumulated cost at the time of the visit of n.
         * @param expectedRemainingCost The expected remaining travel cost when
         * traveling from n to the target node of the route.
         * @param outLink The link from which we came visiting n.
         */",184-200,"('visitNode', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,17.0,Inserts the given Node n into the pendingNodes queue and updates its time and cost information.,Add the given Node into the pendingNodes queue and updates its time and cost information,The given Node n is put into the pendingNodes queue and updated with time and cost information.,0.929030666264896,Inserts the given node n into the pendingNodes queue and updates its time and cost information.," private void visitNode(final Node n, final AStarNodeData data, final RouterPriorityQueue<Node> pendingNodes, final double time, final double cost, final double expectedRemainingCost, final Link outLink){
	 	data.setVisited(getIterationId());
 	data.setTime(time);
 	data.setCost(cost);
 	data.setExpectedRemainingCost(expectedRemainingCost);
 	data.setPrevLink(outLink);
 	pendingNodes.add(n);		
 }"," private void visitNode(final Node n, final AStarNodeData data, final RouterPriorityQueue<Node> pendingNodes, final double time, final double cost, final double expectedRemainingCost, final Link outLink){
	 	data.setVisited(getIterationId());
 	data.setTime(time);
 	data.setCost(cost);
 	data.setExpectedRemainingCost(expectedRemainingCost);
 	data.setPrevLink(outLink);
 	pendingNodes.add(n);		
 }"," private void visitNode(final Node n, final AStarNodeData data, final RouterPriorityQueue<Node> pendingNodes, final double time, final double cost, final double expectedRemainingCost, final Link outLink){
	 	data.setTime(time);
 	data.setCost(cost);
 	data.setExpectedRemainingCost(expectedRemainingCost);
 	data.setPrevLink(outLink);
 	data.setVisited(getIterationId());
 	pendingNodes.add(n);		
 }"," private void visitNode(final Node n, final AStarNodeData data, final RouterPriorityQueue<Node> pendingNodes, final double time, final double cost, final double expectedRemainingCost, final Link outLink){
	 	data.setTime(time);
 	data.setCost(cost);
 	data.setExpectedRemainingCost(expectedRemainingCost);
 	data.setPrevLink(outLink);
 	data.setVisited(getIterationId());
 	pendingNodes.add(n);		
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.749682278359733,  0.749682278359733,  0.749682278359733,  0.749682278359733,33.0,0.4024390243902439,33.0,0.4024390243902439,32.0,0.3902439024390244,32.0,0.3902439024390244,0.0,0.0,14.0,0.17073170731707318,14.0,0.17073170731707318,3.0,0.17647058823529413,1.0,0.058823529411764705,6.0,0.3333333333333333
809,dataverse," Optional<MailDomainGroup> findByAlias(String groupAlias){
    try {
        return Optional.of(em.createNamedQuery(""MailDomainGroup.findByPersistedGroupAlias"", MailDomainGroup.class).setParameter(""persistedGroupAlias"", groupAlias).getSingleResult());
    } catch (NoResultException nre) {
        return Optional.empty();
    }
}",findByAlias,edu/harvard/iq/dataverse/authorization/groups/impl/maildomain/MailDomainGroupServiceBean.java,/src/main/java/edu/harvard/iq/dataverse/authorization/groups/impl/maildomain/MailDomainGroupServiceBean.java,"/**
     * Find a specific mail domain group by it's alias.
     * @param groupAlias
     * @return
     */",114-129,"('findByAlias', {'INSTRUCTION': {'covered': 12, 'missed': 3}, 'LINE': {'covered': 4, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",56.0,11.0,Find a specific mail domain group by it's alias.,This method returns a specific mail domain group by it is alias,You can find a mail domain group by it's name.,0.496816643003777,Find a specific email domain group by its alias.,"  Optional<MailDomainGroup> findByAlias(String groupAlias){
        try {
            return Optional.of(em.createNamedQuery(""MailDomainGroup.findByAlias"", MailDomainGroup.class)
                                     .setParameter(""alias"", groupAlias)
                                     .getSingleResult());
        } catch (NoResultException ex) {
            return Optional.empty();
        }
    }","  Optional<MailDomainGroup> findByAlias(String groupAlias){
        try{
            return Optional.of(em.createNamedQuery(""MailDomainGroup.findByAlias"", MailDomainGroup.class).setParameter(""alias"", groupAlias).getSingleResult());
        }catch(NoResultException e){
            return Optional.empty();
        }
    }","  Optional<MailDomainGroup> findByAlias(String groupAlias){
        try {
            return Optional.of(em.createNamedQuery(""MailDomainGroup.findByAlias"", MailDomainGroup.class)
                                .setParameter(""alias"", groupAlias)
                                .getSingleResult());
        } catch (NoResultException ex) {
            return Optional.empty();
        }       
  }","  Optional<MailDomainGroup> findByAlias(String groupAlias){
        try {
            return Optional.of(em.createNamedQuery(""MailDomainGroup.findByAlias"", MailDomainGroup.class)
                                .setParameter(""alias"", groupAlias)
                                .getSingleResult());
        } catch (NoResultException ex) {
            return Optional.empty();
        }       
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.9301158212555595,  0.9301158212555595,  0.9301158212555595,  0.9301158212555595,3.0,0.05263157894736842,3.0,0.05263157894736842,3.0,0.05263157894736842,3.0,0.05263157894736842,1.0,0.017543859649122806,0.0,0.0,0.0,0.0,6.0,0.46153846153846156,2.0,0.2,5.0,0.45454545454545453
810,metrics,"public void addListener(MetricRegistryListener listener){
    listeners.add(listener);
    for (Map.Entry<MetricName, Metric> entry : metrics.entrySet()) {
        notifyListenerOfAddedMetric(listener, entry.getValue(), entry.getKey());
    }
}",addListener,io/dropwizard/metrics5/MetricRegistry.java,/metrics-core/src/main/java/io/dropwizard/metrics5/MetricRegistry.java,"/**
     * Adds a {@link MetricRegistryListener} to a collection of listeners that will be notified on
     * metric creation.  Listeners will be notified in the order in which they are added.
     * <p>
     * <b>N.B.:</b> The listener will be notified of all existing metrics when it first registers.
     *
     * @param listener the listener that will be notified
     */",395-409,"('addListener', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,20.0,Adds a {@link MetricRegistryListener} to a collection of listeners that will be notified on  metric creation.,This method adds a MetricRegistryListener to a collection of listeners that will be notified on metric creation event,A collection of listeners that will be notified on metric creation is added.,0.402212933612295,Adds a {@link MetricRegistryListener} to a collection of listeners that will be notified when the metric is created.," public void addListener(MetricRegistryListener listener){
        listeners.add(listener);        
 }"," public void addListener(MetricRegistryListener listener){
        listeners.add(listener);        
 }"," public void addListener(MetricRegistryListener listener){
        listeners.add(listener);        
 }"," public void addListener(MetricRegistryListener listener){
        listeners.add(listener);        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2320741863659077,  0.2320741863659077,  0.2320741863659077,  0.2320741863659077,37.0,0.6851851851851852,37.0,0.6851851851851852,37.0,0.6851851851851852,37.0,0.6851851851851852,0.0,0.0,0.0,0.0,0.0,0.0,7.0,0.3684210526315789,4.0,0.21052631578947367,9.0,0.5294117647058824
811,cdk,"public void removeMonomer(String name){
    if (monomers.containsKey(name)) {
        Monomer monomer = (Monomer) monomers.get(name);
        this.remove(monomer);
        monomers.remove(name);
    }
}",removeMonomer,org/openscience/cdk/Polymer.java,/base/data/src/main/java/org/openscience/cdk/Polymer.java,"/**
     * Removes a particular monomer, specified by its name.
     *
     * @param name The name of the monomer to remove
     */",129-141,"('removeMonomer', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,10.0,"Removes a particular monomer, specified by its name.",This method deletes a particular monomer by its name,A particular monomer is removed.,0.278849097620756,"Removes a particular monomer, specified by name."," public void removeMonomer(String name){
        IMonomer monomer = monomers.get(name);
        if (monomer != null) {
            removeMonomer(monomer);
        }
    }"," public void removeMonomer(String name){
        monomers.remove(name);
    }"," public void removeMonomer(String name){
        monomers.remove(name);
    }"," public void removeMonomer(String name){
        monomers.remove(name);      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.45773616264357053,  0.28857594648680074,  0.28857594648680074,  0.28857594648680074,23.0,0.4791666666666667,31.0,0.6458333333333334,31.0,0.6458333333333334,31.0,0.6458333333333334,17.0,0.5151515151515151,17.0,0.5151515151515151,17.0,0.5151515151515151,6.0,0.6,1.0,0.1111111111111111,7.0,0.7777777777777778
812,glowstone,"public static int calculateNeededBits(int number){
    int count = 0;
    do {
        count++;
        number >>>= 1;
    } while (number != 0);
    return count;
}",calculateNeededBits,net/glowstone/util/VariableValueArray.java,/src/main/java/net/glowstone/util/VariableValueArray.java,"/**
     * Calculates the number of bits that would be needed to store the given value.
     *
     * @param number the value
     * @return The number of bits that would be needed to store the value.
     */",40-53,"('calculateNeededBits', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,15.0,Calculates the number of bits that would be needed to store the given value.,This method returns the number of bits that would be needed to store the given value,The number of bits needed to store the value is calculated.,0.317824860098832,Calculates the number of bits needed to store the given value.,"public static int calculateNeededBits(int number){
        int bits = 0;
        while (number > 0){
            number >>= 1;
            bits++;
        }
        return bits;
    }","public static int calculateNeededBits(int number){
        int bits = 0;
        while(number > 0){
            number = number >> 1;
            bits++;
        }
        return bits;
    }","public static int calculateNeededBits(int number){
        int bits = 0;
        while(number > 0){
            bits++;
            number = number >> 1;
        }
        return bits;
    }","public static int calculateNeededBits(int number){
        int bits = 0;
        while (number > 0){
            number >>= 1;
            bits++;
        }
        return bits;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4461592176408328,  0.42035763858989467,  0.4461592176408328,  0.43270529979206235,18.0,0.5,19.0,0.5135135135135135,18.0,0.5,18.0,0.4864864864864865,4.0,0.10810810810810811,0.0,0.0,8.0,0.21621621621621623,4.0,0.23529411764705882,3.0,0.2,8.0,0.5333333333333333
813,matsim-libs,"public Iterator<E> iterator(){
    return new Iterator<E>() {

        final Iterator<E> iterDelegate = PseudoRemovePriorityQueue.this.lastEntry.keySet().iterator();

        @Override
        public boolean hasNext() {
            return this.iterDelegate.hasNext();
        }

        @Override
        public E next() {
            return this.iterDelegate.next();
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    };
}",iterator,org/matsim/core/utils/collections/PseudoRemovePriorityQueue.java,/matsim/src/main/java/org/matsim/core/utils/collections/PseudoRemovePriorityQueue.java,"/**
         * Returns an iterator over the elements in this queue. The iterator
         * does not return the elements in any particular order. Removing
         * elements is not supported via the iterator.
         *
         * @return an iterator over the elements in this queue.
         */",164-192,"('iterator', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",93.0,10.0,Returns an iterator over the elements in this queue.,This method get an iterator over the elements in this queue,The elements are in this queue.,0.313138569855149,Returns an iterator on the items in this queue.,Not Valid," public Iterator<E> iterator(){
	 return new PseudoRemovePriorityQueueIterator();			
 }"," public Iterator<E> iterator(){
	 return new PseudoRemovePriorityQueueIterator();			
 }",Not Valid,Not Valid,NOT PASS,Not Valid,NOT PASS,None,  0.14015493395169917,None,  0.14015493395169917,None,None,78.0,0.8297872340425532,None,None,78.0,0.8297872340425532,16.0,0.9411764705882353,None,None,16.0,0.9411764705882353,4.0,0.3333333333333333,2.0,0.2,6.0,0.6
815,dcache,"public static CompletableFuture<T> fromListenableFuture(ListenableFuture<T> listenable){
    final CompletableFuture<T> completable = new CompletableFuture<T>() {

        @Override
        public boolean cancel(boolean mayInterruptIfRunning) {
            boolean result = listenable.cancel(mayInterruptIfRunning);
            super.cancel(mayInterruptIfRunning);
            return result;
        }
    };
    Futures.addCallback(listenable, new FutureCallback<T>() {

        @Override
        public void onSuccess(T result) {
            completable.complete(result);
        }

        @Override
        public void onFailure(Throwable t) {
            completable.completeExceptionally(t);
        }
    }, MoreExecutors.directExecutor());
    return completable;
}",fromListenableFuture,org/dcache/util/CompletableFutures.java,/modules/common/src/main/java/org/dcache/util/CompletableFutures.java,"/**
     * Create a CompletableFuture from guava's ListenableFuture to help migration from Guava to
     * Java8.
     *
     * @param listenable ListenableFuture to convert.
     * @return new CompletableFuture.
     */",80-112,"('fromListenableFuture', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",126.0,15.0,Create a CompletableFuture from guava's ListenableFuture to help migration from Guava to  Java8.,This method helps to migration from Guava to Java8 by building a CompletableFuture from Guava's ListenableFuture,The ListenableFuture can be used to help migrate from Guava to Java8.,0.64040416481572,Create a CompleteableFuture from Guava's ListenableFuture to make it easier to migrate from Guava to Java8.," public static CompletableFuture<T> fromListenableFuture(ListenableFuture<T> listenable){
        return Futures.toCompletableFuture(listenable);
    }",Empty Method," public static CompletableFuture<T> fromListenableFuture(ListenableFuture<T> listenable){
        return Futures.toCompletableFuture(listenable);     
 }"," public static CompletableFuture<T> fromListenableFuture(ListenableFuture<T> listenable){
        return Futures.toCompletableFuture(listenable);     
 }",NOT PASS,Empty Method,NOT PASS,NOT PASS,  0.14608872727354538,None,  0.14608872727354538,  0.14608872727354538,103.0,0.8110236220472441,None,None,103.0,0.8110236220472441,103.0,0.8110236220472441,None,None,0.0,0.0,0.0,0.0,15.0,0.8823529411764706,7.0,0.4117647058823529,7.0,0.5
816,cdk,"private static boolean has2DCoordinates(List<IBond> bonds){
    for (IBond bond : bonds) {
        if (bond.getBegin().getPoint2d() == null || bond.getEnd().getPoint2d() == null)
            return false;
    }
    return true;
}",has2DCoordinates,org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,"/**
     * Check if all atoms in the bond list have 2D coordinates. There is some
     * redundant checking but the list will typically be short.
     *
     * @param bonds the bonds to check
     * @return whether all atoms have 2D coordinates
     */",292-304,"('has2DCoordinates', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,12.0,Check if all atoms in the bond list have 2D coordinates.,Verify if all atoms in the bond list have 2D coordinates or not,"If all the atoms in the bond list have 2D coordinates, you should check them.",0.253433606725007,Check if all the atoms in the list of bonds have 2D coordinates.,"private static boolean has2DCoordinates(List<IBond> bonds){
        for (IBond bond : bonds) {
            if (bond.getBegin().getPoint2d() == null || bond.getEnd().getPoint2d() == null) {
                return false;
            }
        }
        return true;        
 }","private static boolean has2DCoordinates(List<IBond> bonds){
        for (IBond bond : bonds) {
            if (bond.getBegin().getPoint2d() == null || bond.getEnd().getPoint2d() == null) {
                return false;
            }
        }
        return true;        
 }","private static boolean has2DCoordinates(List<IBond> bonds){
        for (IBond bond : bonds) {
            if (bond.getAtom(0).getPoint2d() == null || bond.getAtom(1).getPoint2d() == null) {
                return false;
            }
        }
        return true;        
 }","private static boolean has2DCoordinates(List<IBond> bonds){
        for (IBond bond : bonds) {
            if (bond.getAtom(0).getPoint2d() == null || bond.getAtom(1).getPoint2d() == null) {
                return false;
            }
        }
        return true;        
 }",PASS,PASS,PASS,PASS,  0.9227338602341005,  0.9227338602341005,  0.7508285867172296,  0.7508285867172296,2.0,0.03508771929824561,2.0,0.03508771929824561,6.0,0.1016949152542373,6.0,0.1016949152542373,0.0,0.0,4.0,0.06779661016949153,4.0,0.06779661016949153,4.0,0.2857142857142857,4.0,0.2857142857142857,8.0,0.5
817,cdk,"public static Rectangle2D shiftContainer(IAtomContainer container, Rectangle2D bounds, Rectangle2D last, double gap){
    if (last.getMaxX() + gap >= bounds.getMinX()) {
        double xShift = last.getMaxX() + gap - bounds.getMinX();
        Vector2d shift = new Vector2d(xShift, 0.0);
        GeometryTools.translate2D(container, shift);
        return new Rectangle2D.Double(bounds.getX() + xShift, bounds.getY(), bounds.getWidth(), bounds.getHeight());
    } else {
        return bounds;
    }
}",shiftContainer,org/openscience/cdk/geometry/GeometryTools.java,/legacy/src/main/java/org/openscience/cdk/geometry/GeometryTools.java,"/**
     * Shift the container horizontally to the right to make its bounds not
     * overlap with the other bounds.
     *
     * @param container the {@link IAtomContainer} to shift to the right
     * @param bounds    the {@link Rectangle2D} of the {@link IAtomContainer}
     *                  to shift
     * @param last      the bounds that is used as reference
     * @param gap       the gap between the two {@link Rectangle2D}s
     * @return          the {@link Rectangle2D} of the {@link IAtomContainer}
     *                  after the shift
     */",1637-1660,"('shiftContainer', {'INSTRUCTION': {'covered': 39, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",113.0,18.0,Shift the container horizontally to the right to make its bounds not  overlap with the other bounds.,This method shifts the given container horizontally from left to the right to make its bounds not overlap with the other bounds,The container's bounds should not overlap with the other bounds.,0.337983073458898,Move the container horizontally to the right so that its boundaries do not overlap with the other boundaries.,"public static Rectangle2D shiftContainer(IAtomContainer container, Rectangle2D bounds, Rectangle2D last, double gap){
        Rectangle2D newBounds = new Rectangle2D.Double(bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight());
        if (last != null) {
            if (newBounds.getX() + newBounds.getWidth() + gap > last.getX()) {
                newBounds.setRect(last.getX() + last.getWidth() + gap, newBounds.getY(), newBounds.getWidth(), newBounds.getHeight());
            }
        }
        return newBounds;       
 }","public static Rectangle2D shiftContainer(IAtomContainer container, Rectangle2D bounds, Rectangle2D last, double gap){
        Rectangle2D newBounds = new Rectangle2D.Double(bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight());
        if (last != null){
            if (last.getX() + last.getWidth() + gap + bounds.getWidth() > container.getBounds().getWidth()){
                newBounds.setX(container.getBounds().getWidth() - bounds.getWidth() - gap);
            } else {
                newBounds.setX(last.getX() + last.getWidth() + gap);
            }
        } else {
            newBounds.setX(0);
        }
        return newBounds;       
 }","public static Rectangle2D shiftContainer(IAtomContainer container, Rectangle2D bounds, Rectangle2D last, double gap){
        Rectangle2D newBounds = new Rectangle2D.Double(bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight());
        if (last != null) {
            if (newBounds.getX() < last.getX()) {
                newBounds.setRect(last.getX() + gap, newBounds.getY(), newBounds.getWidth(), newBounds.getHeight());
            }
            if (newBounds.getY() < last.getY()) {
                newBounds.setRect(newBounds.getX(), last.getY() + gap, newBounds.getWidth(), newBounds.getHeight());
            }
            if (newBounds.getX() + newBounds.getWidth() > last.getX() + last.getWidth()) {
                newBounds.setRect(last.getX() + last.getWidth() - newBounds.getWidth(), newBounds.getY(), newBounds.getWidth(), newBounds.getHeight());
            }
            if (newBounds.getY() + newBounds.getHeight() > last.getY() + last.getHeight()) {
                newBounds.setRect(newBounds.getX(), last.getY() + last.getHeight() - newBounds.getHeight(), newBounds.getWidth(), newBounds.getHeight());
            }
        }
        return newBounds;
    }","public static Rectangle2D shiftContainer(IAtomContainer container, Rectangle2D bounds, Rectangle2D last, double gap){
        Rectangle2D newBounds = new Rectangle2D.Double(bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight());
        if (last != null) {
            if (last.getMaxX() + gap + bounds.getWidth() > container.getBounds().getMaxX()) {
                newBounds.setRect(last.getMaxX() + gap, bounds.getY(), bounds.getWidth(), bounds.getHeight());
            }
        }
        return newBounds;       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5896986049808958,  0.5801828255289794,  0.655580409721253,  0.547810637182032,67.0,0.536,93.0,0.6078431372549019,62.0,0.5040650406504065,220.0,0.7432432432432432,47.0,0.30718954248366015,22.0,0.176,173.0,0.5844594594594594,7.0,0.30434782608695654,6.0,0.3157894736842105,11.0,0.6111111111111112
818,cdk,"public boolean hasNext(){
    if (nextAvailableIsKnown) {
        return hasNext;
    }
    hasNext = false;
    nextMolecule = null;
    try {
        currentFormat = (IChemFormat) MDLFormat.getInstance();
        int lineNum = 0;
        buffer.setLength(0);
        while ((currentLine = input.readLine()) != null) {
            buffer.append(currentLine).append(LINE_SEPARATOR);
            lineNum++;
            if (lineNum == 4) {
                Matcher versionMatcher = MDL_VERSION.matcher(currentLine);
                if (versionMatcher.find()) {
                    currentFormat = ""2000"".equals(versionMatcher.group(1)) ? (IChemFormat) MDLV2000Format.getInstance() : (IChemFormat) MDLV3000Format.getInstance();
                }
            }
            if (currentLine.startsWith(M_END)) {
                logger.debug(""MDL file part read: "", buffer);
                IAtomContainer molecule = null;
                try {
                    ISimpleChemObjectReader reader = getReader(currentFormat);
                    reader.setReader(new StringReader(buffer.toString()));
                    molecule = reader.read(builder.newAtomContainer());
                } catch (Exception exception) {
                    logger.error(""Error while reading next molecule: "" + exception.getMessage());
                    logger.debug(exception);
                }
                if (molecule != null) {
                    readDataBlockInto(molecule);
                    hasNext = true;
                    nextAvailableIsKnown = true;
                    nextMolecule = molecule;
                    return true;
                } else if (skip) {
                    String line;
                    while ((line = input.readLine()) != null) {
                        if (line.startsWith(SDF_RECORD_SEPARATOR)) {
                            break;
                        }
                    }
                } else {
                    return false;
                }
                buffer.setLength(0);
                lineNum = 0;
            }
            if (currentLine.startsWith(SDF_RECORD_SEPARATOR)) {
                buffer.setLength(0);
                lineNum = 0;
            }
        }
    } catch (IOException exception) {
        logger.error(""Error while reading next molecule: "" + exception.getMessage());
        logger.debug(exception);
    }
    return false;
}",hasNext,org/openscience/cdk/io/iterator/IteratingSDFReader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/iterator/IteratingSDFReader.java,"/**
     * Returns true if another {@link IAtomContainer} can be read.
     */",217-304,"('hasNext', {'INSTRUCTION': {'covered': 157, 'missed': 27}, 'BRANCH': {'covered': 18, 'missed': 4}, 'LINE': {'covered': 40, 'missed': 7}, 'COMPLEXITY': {'covered': 8, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",368.0,13.0,Returns true if another {@link IAtomContainer} can be read.,Check if the another IAtomContainer can be read,"If another @link IAtomContainer can be read, this is true.",1.01752169623892,Returns true if another {@link IAtomContainer} can be read.," public boolean hasNext(){
        if (!nextAvailableIsKnown) {
            nextAvailableIsKnown = true;
            hasNext = readNext();
        }
        return hasNext;     
 }"," public boolean hasNext(){
        if (!nextAvailableIsKnown) {
            try {
                nextMolecule = readMolecule();
            } catch (Exception e) {
                logger.error(""Error while reading next molecule"", e);
                nextMolecule = null;
            }
            nextAvailableIsKnown = true;
        }
        return nextMolecule != null;        
 }"," public boolean hasNext(){
        if (!nextAvailableIsKnown) {
            nextAvailableIsKnown = true;
            hasNext = readNext();
        }
        return hasNext;     
 }"," public boolean hasNext(){
        if (!nextAvailableIsKnown) {
            nextAvailableIsKnown = true;
            hasNext = readNext();
        }
        return hasNext;     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.04897563449887259,  0.07029984743710417,  0.04897563449887259,  0.04897563449887259,346.0,0.9376693766937669,329.0,0.8915989159891599,346.0,0.9376693766937669,346.0,0.9376693766937669,31.0,0.5849056603773585,0.0,0.0,0.0,0.0,6.0,0.6,0.0,0.0,9.0,0.8181818181818182
819,cdk,"TextOutline positionSubscript(TextOutline label, TextOutline subscript){
    final Rectangle2D hydrogenBounds = label.getBounds();
    final Rectangle2D hydrogenCountBounds = subscript.getBounds();
    subscript = subscript.translate((hydrogenBounds.getMaxX() + padding) - hydrogenCountBounds.getMinX(), (hydrogenBounds.getMaxY() + (hydrogenCountBounds.getHeight() / 2)) - hydrogenCountBounds.getMaxY());
    return subscript;
}",positionSubscript,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,"/**
     * Positions an outline in the subscript position relative to another 'primary' label.
     *
     * @param label     a label outline
     * @param subscript the label outline to position as subscript
     * @return positioned subscript outline
     */",462-475,"('positionSubscript', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",81.0,14.0,Positions an outline in the subscript position relative to another 'primary' label.,Move the outline in the subscript position relative to another 'primary' label,An outline is placed in the subscript position.,0.438770897641128,"Positions an outline in the subscript position relative to another ""primary"" label.","TextOutline positionSubscript(TextOutline label, TextOutline subscript){
        final Rectangle2D labelBounds = label.getBounds();
        final Rectangle2D subscriptBounds = subscript.getBounds();
        return subscript.translate(0, (labelBounds.getMinY() - padding) - subscriptBounds.getMaxY());       
 }","TextOutline positionSubscript(TextOutline label, TextOutline subscript){
        final Rectangle2D labelBounds = label.getBounds();
        final Rectangle2D subscriptBounds = subscript.getBounds();
        return subscript.translate(labelBounds.getCenterX() - subscriptBounds.getCenterX(),
                                    labelBounds.getMaxY() - subscriptBounds.getMinY());     
 }","TextOutline positionSubscript(TextOutline label, TextOutline subscript){
        final Rectangle2D labelBounds = label.getBounds();
        final Rectangle2D subscriptBounds = subscript.getBounds();
        return subscript.translate(labelBounds.getCenterX() - subscriptBounds.getCenterX(),
                                    labelBounds.getMaxY() - subscriptBounds.getMinY());     
 }","TextOutline positionSubscript(TextOutline label, TextOutline subscript){
        final Rectangle2D labelBounds = label.getBounds();
        final Rectangle2D subscriptBounds = subscript.getBounds();
        return subscript.translate(labelBounds.getCenterX() - subscriptBounds.getCenterX(),
                                    labelBounds.getMaxY() - subscriptBounds.getMinY());     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5054872676404356,  0.5243667026282178,  0.5243667026282178,  0.5243667026282178,35.0,0.4268292682926829,30.0,0.36585365853658536,30.0,0.36585365853658536,30.0,0.36585365853658536,13.0,0.20967741935483872,13.0,0.20967741935483872,13.0,0.20967741935483872,3.0,0.23076923076923078,1.0,0.07692307692307693,10.0,0.7692307692307693
820,cdk,"public int firstIndexOfDifference(Permutation other){
    int r = 0;
    while ((r < values.length) && values[r] == other.get(r)) {
        r++;
    }
    return r;
}",firstIndexOfDifference,org/openscience/cdk/group/Permutation.java,/tool/group/src/main/java/org/openscience/cdk/group/Permutation.java,"/**
     * Find an r such that this[r] != other[r].
     * @param other the other permutation to compare with
     * @return the first point at which the two permutations differ
     */",140-151,"('firstIndexOfDifference', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,16.0,Find an r such that this[r] != other[r].,Return the index such that this[index] != other[index].,Find an r such that this is the other.,0.478617271546198,Find an r such as this[r]!= other[r].,"public int firstIndexOfDifference(Permutation other){
        for (int i = 0; i < this.values.length; i++) {
            if (this.values[i] != other.values[i]) {
                return i;
            }
        }
        return -1;
    }","public int firstIndexOfDifference(Permutation other){
        for (int i = 0; i < this.values.length; i++) {
            if (this.values[i] != other.values[i]) {
                return i;
            }
        }
        return -1;
    }","public int firstIndexOfDifference(Permutation other){
        for (int i = 0; i < this.values.length; i++) {
            if (this.values[i] != other.values[i]) {
                return i;
            }
        }
        return -1;
    }","public int firstIndexOfDifference(Permutation other){
        for (int i = 0; i < this.values.length; i++) {
            if (this.values[i] != other.values[i]) {
                return i;
            }
        }
        return -1;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.48563864524322986,  0.48563864524322986,  0.48563864524322986,  0.48563864524322986,27.0,0.4909090909090909,27.0,0.4909090909090909,27.0,0.4909090909090909,27.0,0.4909090909090909,0.0,0.0,0.0,0.0,0.0,0.0,5.0,0.5555555555555556,3.0,0.3333333333333333,4.0,0.4
821,tablesaw,"protected PrimitiveIterator.OfInt sourceRowNumberIterator(){
    if (this.isSorted()) {
        return Arrays.stream(sortOrder).iterator();
    } else if (this.hasSelection()) {
        return selection.iterator();
    }
    return Selection.withRange(0, table.rowCount()).iterator();
}",sourceRowNumberIterator,tech/tablesaw/table/TableSlice.java,/core/src/main/java/tech/tablesaw/table/TableSlice.java,"/**
   * IntIterator of source table row numbers that are present in this view. This can be used to in
   * combination with the source table to iterate over the cells of a column in a sorted order
   * without copying the column.
   *
   * @return an int iterator of row numbers in the source table that are present in this view.
   */",191-205,"('sourceRowNumberIterator', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,13.0,IntIterator of source table row numbers that are present in this view.,Creates the IntIterator of source table row numbers that are present in this view,There are source table row numbers in this view.,0.206926173967,IntIterator of the row numbers of the source table present in this view.,"protected PrimitiveIterator.OfInt sourceRowNumberIterator(){
    if (hasSelection()) {
      return selection.rowNumberIterator();
    } else {
      return IntStream.range(0, table.rowCount()).iterator();
    }
  }","protected PrimitiveIterator.OfInt sourceRowNumberIterator(){
    if (hasSelection()) {
      return selection.rowNumberIterator();
    } else {
      return IntStream.range(0, table.rowCount()).iterator();
    }
  }","protected PrimitiveIterator.OfInt sourceRowNumberIterator(){
    if (hasSelection()) {
      return selection.rowNumberIterator();
    }
    return IntStream.range(0, table.rowCount()).iterator();
  }","protected PrimitiveIterator.OfInt sourceRowNumberIterator(){
    if (hasSelection()) {
      return selection.rowNumberIterator();
    }
    return IntStream.range(0, table.rowCount()).iterator();
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3905483298576216,  0.3905483298576216,  0.3792474727988625,  0.3792474727988625,29.0,0.4264705882352941,29.0,0.4264705882352941,28.0,0.4117647058823529,28.0,0.4117647058823529,0.0,0.0,3.0,0.06521739130434782,3.0,0.06521739130434782,3.0,0.2,6.0,0.42857142857142855,5.0,0.38461538461538464
822,cdk,"static IAtomContainer apply(IAtomContainer container){
    int n = container.getAtomCount();
    int[] valences = new int[n];
    Map<IAtom, Integer> atomToIndex = new HashMap<>(2 * n);
    for (IAtom atom : container.atoms()) atomToIndex.put(atom, atomToIndex.size());
    // compute the bond order sums
    for (IBond bond : container.bonds()) {
        int u = atomToIndex.get(bond.getBegin());
        int v = atomToIndex.get(bond.getEnd());
        int bondOrder = bond.getOrder().numeric();
        valences[u] += bondOrder;
        valences[v] += bondOrder;
    }
    for (int i = 0; i < n; i++) {
        IAtom atom = container.getAtom(i);
        Integer charge = atom.getFormalCharge();
        Integer element = atom.getAtomicNumber();
        if (element == null)
            continue;
        // unset = 0 in this case
        charge = charge == null ? 0 : charge;
        int explicit = valences[i];
        // if there was a valence read from the mol file use that otherwise
        // use the default value from the valence model to set the correct
        // number of implied hydrogens
        if (atom.getValency() != null) {
            atom.setImplicitHydrogenCount(atom.getValency() - explicit);
        } else {
            int implicit = implicitValence(element, charge, valences[i]);
            atom.setImplicitHydrogenCount(implicit - explicit);
            atom.setValency(implicit);
        }
    }
    return container;
}",apply,org/openscience/cdk/io/MDLValence.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLValence.java,"/**
     * Apply the MDL valence model to the provided atom container.
     *
     * @param container an atom container loaded from an MDL format
     * @return the container (for convenience)
     */",54-107,"('apply', {'INSTRUCTION': {'covered': 139, 'missed': 3}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 25, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",271.0,11.0,Apply the MDL valence model to the provided atom container.,This method applies the MDL valence model to the provided atom container.,The provided atom container has a MDL model applied to it.,0.267411522528055,Apply the MDL valence model to the supplied atom container.,Not Valid,Not Valid,"static IAtomContainer apply(IAtomContainer container){
     
      // map of atoms to their implicit hydrogens
      Map<IAtom, Integer> implicitHydrogens = new HashMap<IAtom, Integer>();
     
      // map of atoms to their valency
      Map<IAtom, Integer> valency = new HashMap<IAtom, Integer>();
     
      // map of atoms to their formal charge
      Map<IAtom, Integer> formalCharge = new HashMap<IAtom, Integer>();
     
      // map of atoms to their formal charge
      Map<IAtom, Integer> radical = new HashMap<IAtom, Integer>();
     
      // map of atoms to their formal charge
      Map<IAtom, Integer> lonePairs = new HashMap<IAtom, Integer>();
     
      // map of atoms to their formal charge
      Map<IAtom, Integer> hybridization = new HashMap<IAtom, Integer>();
     
      // map of atoms to their formal charge
      Map<IAtom, Integer> isotope = new HashMap<IAtom, Integer>();
     
      // map of atoms to their formal charge
      Map<IAtom, Integer> chiral = new HashMap<IAtom, Integer>();
     
      // map of atoms to their formal charge
      Map<IAtom, Integer> stereo = new HashMap<IAtom, Integer>();
     
      // map of atoms to their formal charge
      Map<IAtom, Integer> ringBondCount = new HashMap<IAtom, Integer>();
     
      // map of atoms to their formal charge
      Map<IAtom, Integer> ringSize = new HashMap<IAtom, Integer>();
     
      // map of atoms to their formal charge
      Map<IAtom, Integer> ringConnectivity = new HashMap<IAtom, Integer>();
     
      // map of atoms to their formal charge
      Map<IAtom, Integer> ringConnectivity2 = new HashMap<IAtom, Integer>();
     
      // map of atoms to their formal charge
      Map<IAtom, Integer> ringConnectivity3         
 }","static IAtomContainer apply(IAtomContainer container){
        Map<IAtom, Integer> valences = new HashMap<IAtom, Integer>();
        for (IAtom atom : container.atoms()) {
            valences.put(atom, 0);
        }
    
        for (IBond bond : container.bonds()) {
            IAtom a1 = bond.getAtom(0);
            IAtom a2 = bond.getAtom(1);
    
            int v1 = valences.get(a1);
            int v2 = valences.get(a2);
    
            int v = v1 + v2;
    
            if (bond.getOrder() == IBond.Order.SINGLE) {
                v += 1;
            } else if (bond.getOrder() == IBond.Order.DOUBLE) {
                v += 2;
            } else if (bond.getOrder() == IBond.Order.TRIPLE) {
                v += 3;
            }
    
            valences.put(a1, v);
            valences.put(a2, v);
        }
    
        for (IAtom atom : container.atoms()) {
            int v = valences.get(atom);
            if (v == 0) {
                v = 1;
            }
            atom.setImplicitHydrogenCount(v);
        }
    
        return container;
    }",Not Valid,Not Valid,NOT PASS,Syntax Error,None,None,  0.323949049652894,None,None,None,None,None,178.0,0.6544117647058824,226.0,0.8308823529411765,None,None,234.0,0.9957446808510638,250.0,0.9960159362549801,3.0,0.23076923076923078,1.0,0.09090909090909091,11.0,0.9166666666666666
823,cdk,"public static List<IAtomContainer> sample(IAtomContainer ac){
    LOGGER.debug(""RandomGenerator->mutate() Start"");
    List<IAtomContainer> structures = new ArrayList<IAtomContainer>();
    int nrOfAtoms = ac.getAtomCount();
    double a11 = 0, a12 = 0, a22 = 0, a21 = 0;
    double b11 = 0, lowerborder = 0, upperborder = 0;
    double b12 = 0;
    double b21 = 0;
    double b22 = 0;
    double[] cmax = new double[4];
    double[] cmin = new double[4];
    IAtomContainer newAc = null;
    IAtom ax1 = null, ax2 = null, ay1 = null, ay2 = null;
    IBond b1 = null, b2 = null, b3 = null, b4 = null;
    // int[] choices = new int[3];
    /* We need at least two non-zero bonds in order to be successful */
    int nonZeroBondsCounter = 0;
    for (int x1 = 0; x1 < nrOfAtoms; x1++) {
        for (int x2 = x1 + 1; x2 < nrOfAtoms; x2++) {
            for (int y1 = x2 + 1; y1 < nrOfAtoms; y1++) {
                for (int y2 = y1 + 1; y2 < nrOfAtoms; y2++) {
                    nonZeroBondsCounter = 0;
                    ax1 = ac.getAtom(x1);
                    ay1 = ac.getAtom(y1);
                    ax2 = ac.getAtom(x2);
                    ay2 = ac.getAtom(y2);
                    /* Get four bonds for these four atoms */
                    b1 = ac.getBond(ax1, ay1);
                    if (b1 != null) {
                        a11 = BondManipulator.destroyBondOrder(b1.getOrder());
                        nonZeroBondsCounter++;
                    } else {
                        a11 = 0;
                    }
                    b2 = ac.getBond(ax1, ay2);
                    if (b2 != null) {
                        a12 = BondManipulator.destroyBondOrder(b2.getOrder());
                        nonZeroBondsCounter++;
                    } else {
                        a12 = 0;
                    }
                    b3 = ac.getBond(ax2, ay1);
                    if (b3 != null) {
                        a21 = BondManipulator.destroyBondOrder(b3.getOrder());
                        nonZeroBondsCounter++;
                    } else {
                        a21 = 0;
                    }
                    b4 = ac.getBond(ax2, ay2);
                    if (b4 != null) {
                        a22 = BondManipulator.destroyBondOrder(b4.getOrder());
                        nonZeroBondsCounter++;
                    } else {
                        a22 = 0;
                    }
                    if (nonZeroBondsCounter > 1) {
                        /*
                             * Compute the range for b11 (see Faulons formulae
                             * for details)
                             */
                        cmax[0] = 0;
                        cmax[1] = a11 - a22;
                        cmax[2] = a11 + a12 - 3;
                        cmax[3] = a11 + a21 - 3;
                        cmin[0] = 3;
                        cmin[1] = a11 + a12;
                        cmin[2] = a11 + a21;
                        cmin[3] = a11 - a22 + 3;
                        lowerborder = MathTools.max(cmax);
                        upperborder = MathTools.min(cmin);
                        for (b11 = lowerborder; b11 <= upperborder; b11++) {
                            if (b11 != a11) {
                                b12 = a11 + a12 - b11;
                                b21 = a11 + a21 - b11;
                                b22 = a22 - a11 + b11;
                                LOGGER.debug(""Trying atom combination : "" + x1 + "":"" + x2 + "":"" + y1 + "":"" + y2);
                                try {
                                    newAc = (IAtomContainer) ac.clone();
                                    change(newAc, x1, y1, x2, y2, b11, b12, b21, b22);
                                    if (ConnectivityChecker.isConnected(newAc)) {
                                        structures.add(newAc);
                                    } else {
                                        LOGGER.debug(""not connected"");
                                    }
                                } catch (CloneNotSupportedException e) {
                                    LOGGER.error(""Cloning exception: "" + e.getMessage());
                                    LOGGER.debug(e);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return structures;
}",sample,org/openscience/cdk/structgen/VicinitySampler.java,/tool/structgen/src/main/java/org/openscience/cdk/structgen/VicinitySampler.java,"/**
     * Choose any possible quadruple of the set of atoms
     * in ac and establish all of the possible bonding schemes according to
     * Faulon's equations.
     */",53-163,"('sample', {'INSTRUCTION': {'covered': 307, 'missed': 18}, 'BRANCH': {'covered': 23, 'missed': 1}, 'LINE': {'covered': 66, 'missed': 4}, 'COMPLEXITY': {'covered': 12, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",693.0,25.0,Choose any possible quadruple of the set of atoms  in ac and establish all of the possible bonding schemes according to  Faulon's equations.,Sample any possible quadruple of the set of atoms in ac and establish all of the possible bonding schemes according to Faulon's equations,Pick any possible set of atoms in ac and then use the equations of Faulon to create bonding schemes.,0.393632317962405,Choose any possible quadruple of the set of atoms in ac and establish all possible bonding schemes according to Faulon's equations.,Not Valid,"public static List<IAtomContainer> sample(IAtomContainer ac){
        List<IAtomContainer> result = new ArrayList<IAtomContainer>();
        int nAtoms = ac.getAtomCount();
        int nBonds = ac.getBondCount();
        int nBondsMax = nAtoms*(nAtoms-1)/2;
        int nBondsMin = nBonds;
        int nBondsMax2 = nBondsMax;
        int nBondsMin2 = nBondsMin;
        int nBondsMax3 = nBondsMax;
        int nBondsMin3 = nBondsMin;
        int nBondsMax4 = nBondsMax;
        int nBondsMin4 = nBondsMin;
        int nBondsMax5 = nBondsMax;
        int nBondsMin5 = nBondsMin;
        int nBondsMax6 = nBondsMax;
        int nBondsMin6 = nBondsMin;
        int nBondsMax7 = nBondsMax;
        int nBondsMin7 = nBondsMin;
        int nBondsMax8 = nBondsMax;
        int nBondsMin8 = nBondsMin;
        int nBondsMax9 = nBondsMax;
        int nBondsMin9 = nBondsMin;
        int nBondsMax10 = nBondsMax;
        int nBondsMin10 = nBondsMin;
        int nBondsMax11 = nBondsMax;
        int nBondsMin11 = nBondsMin;
        int nBondsMax12 = nBondsMax;
        int nBondsMin12 = nBondsMin;
        int nBondsMax13 = nBondsMax;
        int nBondsMin13 = nBondsMin;
        int nBondsMax14 = nBondsMax;
        int nBondsMin14 = nBondsMin;
        int nBondsMax15 = nBondsMax;
        int nBondsMin15 = nBondsMin;
        int nBondsMax16 = nBondsMax;
        int nBondsMin16 = nBonds        
 }",Not Valid,"public static List<IAtomContainer> sample(IAtomContainer ac){
        List<IAtomContainer> result = new ArrayList<IAtomContainer>();
        int n = ac.getAtomCount();
        int[] a = new int[n];
        int[] b = new int[n];
        int[] c = new int[n];
        int[] d = new int[n];
        int[] e = new int[n];
        int[] f = new int[n];
        int[] g = new int[n];
        int[] h = new int[n];
        int[] i = new int[n];
        int[] j = new int[n];
        int[] k = new int[n];
        int[] l = new int[n];
        int[] m = new int[n];
        int[] n1 = new int[n];
        int[] n2 = new int[n];
        int[] n3 = new int[n];
        int[] n4 = new int[n];
        int[] n5 = new int[n];
        int[] n6 = new int[n];
        int[] n7 = new int[n];
        int[] n8 = new int[n];
        int[] n9 = new int[n];
        int[] n10 = new int[n];
        int[] n11 = new int[n];
        int[] n12 = new int[n];
        int[] n13 = new int[n];
        int[] n14 = new int[n];
        int[] n15 = new int[n];
        int[] n16 = new int[n];
        int[] n17 = new int[n];
        int[] n18 = new int[n];
        int[] n19 = new int[n];
        int[] n20 = new int[n];
        int[] n21 = new int[n];
        int[] n22 = new int[n];
        int[] n23 = new int[n];
        int[] n24 = new int[n];
        int[] n25 = new int[n];
        int[] n26 = new int[n];
        int[] n27 = new int[n];     
 }",Not Valid,Syntax Error,NOT PASS,Not Valid,None,None,  0.06723261947650451,None,None,None,None,None,571.0,0.8227665706051873,None,None,None,None,476.0,0.9979035639412998,None,None,2.0,0.08333333333333333,2.0,0.08333333333333333,14.0,0.5833333333333334
824,cdk,"private IAtom findAtomByPosition(IAtomContainer container, int position){
    String pos = String.valueOf(position);
    for (IAtom atom : container.atoms()) {
        if (atom.getID().equals(pos))
            return atom;
    }
    return null;
}",findAtomByPosition,org/openscience/cdk/tautomers/InChITautomerGenerator.java,/tool/tautomer/src/main/java/org/openscience/cdk/tautomers/InChITautomerGenerator.java,"/**
     * Helper method that locates an atom based on its InChI atom table
     * position, which has been set as ID.
     * @param container input container
     * @param position InChI atom table position
     * @return atom on the position
     */",624-637,"('findAtomByPosition', {'INSTRUCTION': {'covered': 22, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,21.0,"Helper method that locates an atom based on its InChI atom table  position, which has been set as ID.","This method locates an atom based on its InChI atom table position, which has been set as ID.",The method locates an atom by looking at the InChI atom table position.,0.646215500777016,"An assistive method that locates an atom based on its InChI atom table position, which has been defined as ID."," private IAtom findAtomByPosition(IAtomContainer container, int position){
        for (IAtom atom : container.atoms()) {
            if (atom.getID().equals(Integer.toString(position))) return atom;
        }
        return null;
    }"," private IAtom findAtomByPosition(IAtomContainer container, int position){
        for (IAtom atom : container.atoms()) {
            if (atom.getID().equals(Integer.toString(position))) return atom;
        }
        return null;
    }"," private IAtom findAtomByPosition(IAtomContainer container, int position){
        for (IAtom atom : container.atoms()) {
            if (atom.getProperty(InChIToStructure.INCHI_ATOM_TABLE_POSITION) != null
                    && atom.getProperty(InChIToStructure.INCHI_ATOM_TABLE_POSITION).equals(position))
                return atom;
        }
        return null;
    }"," private IAtom findAtomByPosition(IAtomContainer container, int position){
        for (IAtom atom : container.atoms()) {
            if (atom.getID().equals(Integer.toString(position))) return atom;
        }
        return null;
    }",PASS,PASS,PASS,NOT PASS,  0.6887815722149091,  0.6887815722149091,  0.6887815722149091,  0.651939906694145,16.0,0.2909090909090909,16.0,0.2909090909090909,16.0,0.2909090909090909,25.0,0.423728813559322,0.0,0.0,0.0,0.0,15.0,0.2542372881355932,2.0,0.1,3.0,0.14285714285714285,13.0,0.65
825,cdk,"private String[] generateOrderE(){
    String[] listElements = new String[] { ""C"", ""H"", ""O"", ""N"", ""Si"", ""P"", ""S"", ""F"", ""Cl"", ""Br"", ""I"", ""Sn"", ""B"", ""Pb"", ""Tl"", ""Ba"", ""In"", ""Pd"", ""Pt"", ""Os"", ""Ag"", ""Zr"", ""Se"", ""Zn"", ""Cu"", ""Ni"", ""Co"", ""Fe"", ""Cr"", ""Ti"", ""Ca"", ""K"", ""Al"", ""Mg"", ""Na"", ""Ce"", ""Hg"", ""Au"", ""Ir"", ""Re"", ""W"", ""Ta"", ""Hf"", ""Lu"", ""Yb"", ""Tm"", ""Er"", ""Ho"", ""Dy"", ""Tb"", ""Gd"", ""Eu"", ""Sm"", ""Pm"", ""Nd"", ""Pr"", ""La"", ""Cs"", ""Xe"", ""Te"", ""Sb"", ""Cd"", ""Rh"", ""Ru"", ""Tc"", ""Mo"", ""Nb"", ""Y"", ""Sr"", ""Rb"", ""Kr"", ""As"", ""Ge"", ""Ga"", ""Mn"", ""V"", ""Sc"", ""Ar"", ""Ne"", ""Be"", ""Li"", ""Tl"", ""Pb"", ""Bi"", ""Po"", ""At"", ""Rn"", ""Fr"", ""Ra"", ""Ac"", ""Th"", ""Pa"", ""U"", ""Np"", ""Pu"" };
    return listElements;
}",generateOrderE,org/openscience/cdk/formula/MassToFormulaTool.java,/legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java,"/**
     * generate the order of the Elements according probability occurrence.,
     * beginning the C, H, O, N, Si, P, S, F, Cl, Br, I, Sn, B, Pb, Tl, Ba, In, Pd,
     * Pt, Os, Ag, Zr, Se, Zn, Cu, Ni, Co, Fe, Cr, Ti, Ca, K, Al, Mg, Na, Ce,
     * Hg, Au, Ir, Re, W, Ta, Hf, Lu, Yb, Tm, Er, Ho, Dy, Tb, Gd, Eu, Sm, Pm,
     * Nd, Pr, La, Cs, Xe, Te, Sb, Cd, Rh, Ru, Tc, Mo, Nb, Y, Sr, Rb, Kr, As,
     * Ge, Ga, Mn, V, Sc, Ar, Ne, Be, Li, Tl, Pb, Bi, Po, At, Rn, Fr, Ra, Ac,
     * Th, Pa, U, Np, Pu.
     *
     * @return  Array with the elements ordered.
     *
     */",438-458,"('generateOrderE', {'INSTRUCTION': {'covered': 385, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",213.0,10.0,generate the order of the Elements according probability occurrence.,This method defines the order of the Elements according probability occurrence,The order of the Elements can be generated.,0.492583832220475,generate the order of the elements according to the probability occurrence.,"private String[] generateOrderE(){
        String[] orderElements = new String[this.orderElements.length];
        for (int i = 0; i < orderElements.length; i++) {
            orderElements[i] = this.orderElements[i];
        }
        return orderElements;
    }","private String[] generateOrderE(){
        String[] orderElements = new String[this.orderElements.length];
        for (int i = 0; i < orderElements.length; i++) {
            orderElements[i] = this.orderElements[i];
        }
        return orderElements;
    }","private String[] generateOrderE(){
        String[] orderElements = new String[this.isotopes_TO.size()];
        for (int i = 0; i < orderElements.length; i++) {
            orderElements[i] = this.isotopes_TO.get(i).getSymbol();
        }
        return orderElements;
    }","private String[] generateOrderE(){
        String[] orderElements = new String[this.isotopes_TO.size()];
        for (int i = 0; i < orderElements.length; i++) {
            orderElements[i] = this.isotopes_TO.get(i).getSymbol();
        }
        return orderElements;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.19300413080380327,  0.19300413080380327,  0.19448626420761436,  0.19448626420761436,194.0,0.9065420560747663,194.0,0.9065420560747663,194.0,0.9065420560747663,194.0,0.9065420560747663,0.0,0.0,13.0,0.19696969696969696,13.0,0.19696969696969696,4.0,0.3333333333333333,3.0,0.25,5.0,0.5
826,cdk,"public DescriptorValue calculate(IAtomContainer mol){
    mol = clone(mol);
    int lipinskifailures = 0;
    IMolecularDescriptor xlogP = new XLogPDescriptor();
    Object[] xlogPparams = { checkAromaticity, Boolean.TRUE };
    try {
        xlogP.setParameters(xlogPparams);
        double xlogPvalue = ((DoubleResult) xlogP.calculate(mol).getValue()).doubleValue();
        IMolecularDescriptor acc = new HBondAcceptorCountDescriptor();
        Object[] hBondparams = { checkAromaticity };
        acc.setParameters(hBondparams);
        int acceptors = ((IntegerResult) acc.calculate(mol).getValue()).intValue();
        IMolecularDescriptor don = new HBondDonorCountDescriptor();
        don.setParameters(hBondparams);
        int donors = ((IntegerResult) don.calculate(mol).getValue()).intValue();
        IMolecularDescriptor mw = new WeightDescriptor();
        Object[] mwparams = { ""*"" };
        mw.setParameters(mwparams);
        double mwvalue = ((DoubleResult) mw.calculate(mol).getValue()).doubleValue();
        IMolecularDescriptor rotata = new RotatableBondsCountDescriptor();
        Object[] rotatableBondsParams = { false, true };
        rotata.setParameters(rotatableBondsParams);
        int rotatablebonds = ((IntegerResult) rotata.calculate(mol).getValue()).intValue();
        if (xlogPvalue > 5.0) {
            lipinskifailures += 1;
        }
        if (acceptors > 10) {
            lipinskifailures += 1;
        }
        if (donors > 5) {
            lipinskifailures += 1;
        }
        if (mwvalue > 500.0) {
            lipinskifailures += 1;
        }
        if (rotatablebonds > 10.0) {
            lipinskifailures += 1;
        }
    } catch (CDKException e) {
        new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult((int) Double.NaN), getDescriptorNames(), e);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(lipinskifailures), getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/RuleOfFiveDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/RuleOfFiveDescriptor.java,"/**
     *  the method take a boolean checkAromaticity: if the boolean is true, it means that
     *  aromaticity has to be checked.
     *
     *@param  mol   AtomContainer for which this descriptor is to be calculated
     *@return    The number of failures of the Lipinski rule
     */",136-199,"('calculate', {'INSTRUCTION': {'covered': 156, 'missed': 20}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 32, 'missed': 5}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",383.0,22.0,"the method take a boolean checkAromaticity: if the boolean is true, it means that  aromaticity has to be checked.",Check if the aromaticity of the input has been previously checked,"If the boolean is true, it means that aromaticity has to be checked.",0.642492097252484,"the method takes a Boolean controlAromaticity: if the Boolean is true, it means that the aromaticity must be checked.","public DescriptorValue calculate(IAtomContainer mol){
        int failures = 0;
        int n = mol.getAtomCount();
        int nbonds = mol.getBondCount();
        int nrings = mol.getRingCount();
        int narom = 0;
        int naliph = 0;
        int naliph2 = 0;
        int naliph3 = 0;
        int naliph4 = 0;
        int naliph5 = 0;
        int naliph6 = 0;
        int naliph7 = 0;
        int naliph8 = 0;
        int naliph9 = 0;
        int naliph10 = 0;
        int naliph11 = 0;
        int naliph12 = 0;
        int naliph13 = 0;
        int naliph14 = 0;
        int naliph15 = 0;
        int naliph16 = 0;
        int naliph17 = 0;
        int naliph18 = 0;
        int naliph19 = 0;
        int naliph20 = 0;
        int naliph21 = 0;
        int naliph22 = 0;
        int naliph23 = 0;
        int naliph24 = 0;
        int naliph25 = 0;
        int naliph26 = 0;
        int naliph27 = 0;
        int naliph28 = 0;
        int naliph29 = 0;
        int naliph30 = 0;
        int naliph31 = 0;
        int naliph32 = 0;
        int naliph33 = 0;
        int naliph34 = 0;
        int naliph35 = 0;
        int naliph36 = 0;
        int naliph37 = 0;
        int naliph38 = 0;
        int naliph39 = 0;
        int naliph40 = 0;
        int naliph41 = 0;
        int naliph42 = 0;
        int naliph43 = 0;
        int naliph44 = 0;
        int naliph45        
 }","public DescriptorValue calculate(IAtomContainer mol){
        int failures = 0;
        int nAtoms = mol.getAtomCount();
        int nBonds = mol.getBondCount();
        int nAromAtoms = 0;
        int nAromBonds = 0;
        int nAromAtomsWithDoubleBond = 0;
        int nAromAtomsWithTripleBond = 0;
        int nAromAtomsWithQuadBond = 0;
        int nAromAtomsWithQuintBond = 0;
        int nAromAtomsWithSextBond = 0;
        int nAromAtomsWithSeptBond = 0;
        int nAromAtomsWithOctBond = 0;
        int nAromAtomsWithNonBond = 0;
        int nAromAtomsWithUnspecifiedBond = 0;
        int nAromAtomsWithUnspecifiedBondAndDoubleBond = 0;
        int nAromAtomsWithUnspecifiedBondAndTripleBond = 0;
        int nAromAtomsWithUnspecifiedBondAndQuadBond = 0;
        int nAromAtomsWithUnspecifiedBondAndQuintBond = 0;
        int nAromAtomsWithUnspecifiedBondAndSextBond = 0;
        int nAromAtomsWithUnspecifiedBondAndSeptBond = 0;
        int nAromAtomsWithUnspecifiedBondAndOctBond = 0;
        int nAromAtomsWithUnspecifiedBondAndNonBond = 0;
        int nAromAtomsWithUnspecifiedBondAndUnspecifiedBond = 0;
        int nAromAtomsWithUnspecifiedBondAndUnspecifiedBondAndDoubleBond = 0;
        int nAromAtomsWithUnspecifiedBondAndUnspecifiedBondAndTripleBond = 0;
        int nAromAtomsWithUnspecifiedBondAndUnspecifiedBondAndQuadBond = 0;
        int nAromAtomsWithUnspecifiedBondAndUnspecifiedBondAndQuintBond = 0;
        int nAromAtomsWithUnspecifiedBondAndUn      
 }","public DescriptorValue calculate(IAtomContainer mol){
        int failures = 0;
        int nrOfAtoms = mol.getAtomCount();
        int nrOfBonds = mol.getBondCount();
        int nrOfAromaticBonds = 0;
        int nrOfAromaticAtoms = 0;
        int nrOfAliphaticAtoms = 0;
        int nrOfAliphaticBonds = 0;
        int nrOfHydrogens = 0;
        int nrOfCarbonAtoms = 0;
        int nrOfNitrogenAtoms = 0;
        int nrOfOxygenAtoms = 0;
        int nrOfSulfurAtoms = 0;
        int nrOfSiliconAtoms = 0;
        int nrOfPhosphorusAtoms = 0;
        int nrOfChlorineAtoms = 0;
        int nrOfBromineAtoms = 0;
        int nrOfIodineAtoms = 0;
        int nrOfFluorineAtoms = 0;
        int nrOfChlorineBonds = 0;
        int nrOfBromineBonds = 0;
        int nrOfIodineBonds = 0;
        int nrOfFluorineBonds = 0;
        int nrOfHydrogenBonds = 0;
        int nrOfCarbonBonds = 0;
        int nrOfNitrogenBonds = 0;
        int nrOfOxygenBonds = 0;
        int nrOfSulfurBonds = 0;
        int nrOfSiliconBonds = 0;
        int nrOfPhosphorusBonds = 0;
        int nrOfChlorineBonds = 0;
        int nrOfBromineBonds = 0;
        int nrOfIodineBonds = 0;
        int nrOfFluorineBonds = 0;
        int nrOfHydrogenAtoms = 0;
        int nrOfCarbonAtoms = 0;
        int nrOfNitrogenAtoms = 0;
        int nrOfOxygen      
 }","public DescriptorValue calculate(IAtomContainer mol){
        int failures = 0;
        int numberOfAtoms = mol.getAtomCount();
        int numberOfBonds = mol.getBondCount();
        int numberOfAromaticBonds = 0;
        int numberOfAliphaticBonds = 0;
        int numberOfAromaticAtoms = 0;
        int numberOfAliphaticAtoms = 0;
        int numberOfAromaticAtomsInRing = 0;
        int numberOfAliphaticAtomsInRing = 0;
        int numberOfRings = 0;
        int numberOfAromaticRings = 0;
        int numberOfAliphaticRings = 0;
        int numberOfAromaticAtomsInAromaticRings = 0;
        int numberOfAliphaticAtomsInAromaticRings = 0;
        int numberOfAromaticAtomsInAliphaticRings = 0;
        int numberOfAliphaticAtomsInAliphaticRings = 0;
        int numberOfAromaticBondsInAromaticRings = 0;
        int numberOfAliphaticBondsInAromaticRings = 0;
        int numberOfAromaticBondsInAliphaticRings = 0;
        int numberOfAliphaticBondsInAliphaticRings = 0;
        int numberOfAromaticAtomsInAromaticBonds = 0;
        int numberOfAliphaticAtomsInAromaticBonds = 0;
        int numberOfAromaticAtomsInAliphaticBonds = 0;
        int numberOfAliphaticAtomsInAliphaticBonds = 0;
        int numberOfAromaticBondsInAromaticAtoms = 0;
        int numberOfAliphaticBondsInAromaticAtoms = 0;
        int numberOfAromaticBondsInAliphaticAtoms = 0;
        int numberOfAliphaticBondsInAliphaticAtoms = 0;
        int numberOfAromaticAtomsInAromaticBondsInAromaticRings = 0;
        int numberOfAliphaticAtomsInAromaticBonds       
 }",Syntax Error,Syntax Error,Syntax Error,Syntax Error,None,None,None,None,None,None,None,None,323.0,0.8411458333333334,323.0,0.8411458333333334,None,None,133.0,0.4944237918215613,105.0,0.3903345724907063,16.0,0.8,7.0,0.35,7.0,0.35
827,shardingsphere-elasticjob,"public List<TaskRunningStatistics> findTaskRunningStatisticsWeekly(){
    if (!isRdbConfigured()) {
        return Collections.emptyList();
    }
    return rdbRepository.findTaskRunningStatistics(StatisticTimeUtils.getStatisticTime(StatisticInterval.DAY, -7));
}",findTaskRunningStatisticsWeekly,org/apache/shardingsphere/elasticjob/cloud/scheduler/statistics/StatisticManager.java,/elasticjob-cloud/elasticjob-cloud-scheduler/src/main/java/org/apache/shardingsphere/elasticjob/cloud/scheduler/statistics/StatisticManager.java,"/**
     * Get the collection of task statistics in the most recent week.
     * 
     * @return Collection of running task statistics data objects
     */",225-235,"('findTaskRunningStatisticsWeekly', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,12.0,Get the collection of task statistics in the most recent week.,Find the collection of task statistics in the most recent week,The collection of task statistics is available.,0.113247346116951,Get the most recent week's task statistics collection.,"public List<TaskRunningStatistics> findTaskRunningStatisticsWeekly(){
        if (!isRdbConfigured()) {
            return Collections.emptyList();
        }
        return rdbRepository.findTaskRunningStatistics(StatisticTimeUtils.getStatisticTime(StatisticInterval.DAY, -7), StatisticInterval.DAY);
    }","public List<TaskRunningStatistics> findTaskRunningStatisticsWeekly(){
        if (!isRdbConfigured()) {
            return Collections.emptyList();
        }
        return rdbRepository.findTaskRunningStatistics(StatisticTimeUtils.getStatisticTime(StatisticInterval.DAY, -7), StatisticInterval.DAY);      
 }","public List<TaskRunningStatistics> findTaskRunningStatisticsWeekly(){
        if (!isRdbConfigured()) {
            return Collections.emptyList();
        }
        return rdbRepository.findTaskRunningStatistics(StatisticTimeUtils.getStatisticTime(StatisticInterval.DAY, -7), StatisticInterval.DAY);      
 }","public List<TaskRunningStatistics> findTaskRunningStatisticsWeekly(){
        if (!isRdbConfigured()) {
            return Collections.emptyList();
        }
        return rdbRepository.findTaskRunningStatistics(StatisticTimeUtils.getStatisticTime(StatisticInterval.DAY, -7), StatisticInterval.DAY);      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS, 0.8806615362338783, 0.8806615362338783, 0.8806615362338783, 0.8806615362338783,4.0,0.08163265306122448,4.0,0.08163265306122448,4.0,0.08163265306122448,4.0,0.08163265306122448,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.16666666666666666,8.0,0.6666666666666666,7.0,0.5833333333333334
828,jeromq,"public String popString(){
    ZFrame frame = pop();
    if (frame == null) {
        return null;
    }
    return frame.toString();
}",popString,org/zeromq/ZMsg.java,/src/main/java/org/zeromq/ZMsg.java,"/**
     * Pop a ZFrame and return the toString() representation of it.
     *
     * @return toString version of pop'ed frame, or null if no frame exists.
     */",687-700,"('popString', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,13.0,Pop a ZFrame and return the toString() representation of it.,Remove a ZFrame and return the toString() representation of it,Return the toString() representation of the ZFrame.,0.583365391442508,Display a ZFrame and return the toString() representation of it.," public String popString(){
        return pop().toString();        
 }"," public String popString(){
        ZFrame frame = pop();
        String str = frame.toString();
        frame.destroy();
        return str;
    }"," public String popString(){
        return pop().toString();
    }"," public String popString(){
        return pop().toString();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.2591966611033485,  0.6726376639571015,  0.2591966611033485,  0.2591966611033485,17.0,0.5151515151515151,15.0,0.45454545454545453,17.0,0.5151515151515151,17.0,0.5151515151515151,17.0,0.5151515151515151,0.0,0.0,0.0,0.0,2.0,0.18181818181818182,1.0,0.09090909090909091,7.0,0.6363636363636364
829,glowstone,"public boolean readFloatList(@NonNls String key, Consumer<? super List<Float>> consumer){
    return readList(key, TagType.FLOAT, consumer);
}",readFloatList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to a list subtag if it is present and its contents are float
     * tags.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */",596-606,"('readFloatList', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,19.0,Applies the given function to a list subtag if it is present and its contents are float  tags.,Read the float list if it is present,"If the function is present and the contents are float tags, apply it to the list subtag.",0.512949622910349,Applies the given function to a list subtag if it is present and its contents consist of floating tags.," public boolean readFloatList(@NonNls String key, Consumer<? super List<Float>> consumer){
        return readList(key, TagType.FLOAT, consumer);
    }"," public boolean readFloatList(@NonNls String key, Consumer<? super List<Float>> consumer){
        return readList(key, TagType.FLOAT, consumer);
    }"," public boolean readFloatList(@NonNls String key, Consumer<? super List<Float>> consumer){
        return readList(key, TagType.FLOAT, consumer);      
 }"," public boolean readFloatList(@NonNls String key, Consumer<? super List<Float>> consumer){
        return readList(key, TagType.FLOAT, consumer);
    }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,12.0,0.631578947368421,3.0,0.15,16.0,0.8421052631578947
830,cdk,"private double calculateSquaredDistanceBetweenTwoAtoms(IAtom atom1, IAtom atom2){
    double distance = 0;
    double tmp = 0;
    Point3d firstPoint = atom1.getPoint3d();
    Point3d secondPoint = atom2.getPoint3d();
    tmp = firstPoint.distance(secondPoint);
    distance = tmp * tmp;
    return distance;
}",calculateSquaredDistanceBetweenTwoAtoms,org/openscience/cdk/charges/InductivePartialCharges.java,/tool/charges/src/main/java/org/openscience/cdk/charges/InductivePartialCharges.java,"/**
     *  Evaluate the square of the Euclidean distance between two atoms.
     *
     *@param  atom1  first atom
     *@param  atom2  second atom
     *@return        squared distance between the 2 atoms
     */",372-387,"('calculateSquaredDistanceBetweenTwoAtoms', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",58.0,11.0,Evaluate the square of the Euclidean distance between two atoms.,This method calculates the square of the Euclidean distance between two atoms,Evaluate the distance between two atoms.,0.0744706836657519,Evaluate the square of the Euclidean distance between two atoms.,"private double calculateSquaredDistanceBetweenTwoAtoms(IAtom atom1, IAtom atom2){
        double x1 = atom1.getPoint3d().x;
        double y1 = atom1.getPoint3d().y;
        double z1 = atom1.getPoint3d().z;
        double x2 = atom2.getPoint3d().x;
        double y2 = atom2.getPoint3d().y;
        double z2 = atom2.getPoint3d().z;
        double distance = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2));
        return distance * distance;     
 }","private double calculateSquaredDistanceBetweenTwoAtoms(IAtom atom1, IAtom atom2){
        double x1 = atom1.getPoint3d().x;
        double y1 = atom1.getPoint3d().y;
        double z1 = atom1.getPoint3d().z;
        double x2 = atom2.getPoint3d().x;
        double y2 = atom2.getPoint3d().y;
        double z2 = atom2.getPoint3d().z;
        double distance = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2));
        return distance * distance;     
 }","private double calculateSquaredDistanceBetweenTwoAtoms(IAtom atom1, IAtom atom2){
        double x1 = atom1.getPoint3d().x;
        double y1 = atom1.getPoint3d().y;
        double z1 = atom1.getPoint3d().z;
        double x2 = atom2.getPoint3d().x;
        double y2 = atom2.getPoint3d().y;
        double z2 = atom2.getPoint3d().z;
        double distance = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2));
        return distance;
    }","private double calculateSquaredDistanceBetweenTwoAtoms(IAtom atom1, IAtom atom2){
        double x1 = atom1.getPoint3d().x;
        double y1 = atom1.getPoint3d().y;
        double z1 = atom1.getPoint3d().z;
        double x2 = atom2.getPoint3d().x;
        double y2 = atom2.getPoint3d().y;
        double z2 = atom2.getPoint3d().z;
        double distance = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2);
        return distance;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.44421123018862674,  0.44421123018862674,  0.44907649844160347,  0.44683126784179017,83.0,0.6484375,83.0,0.6484375,76.0,0.628099173553719,81.0,0.6428571428571429,0.0,0.0,7.0,0.0546875,2.0,0.015625,4.0,0.3076923076923077,0.0,0.0,4.0,0.36363636363636365
831,cdk,"static void reverse(List<String> tokens){
    Collections.reverse(tokens);
    Deque<String> numbers = new ArrayDeque<>();
    for (int i = 0; i < tokens.size(); i++) {
        String token = tokens.get(i);
        if (token.equals(""("")) {
            tokens.set(i, "")"");
            String num = numbers.pop();
            if (!num.isEmpty()) {
                tokens.add(i + 1, num);
                i++;
            }
        } else if (token.equals("")"")) {
            tokens.set(i, ""("");
            if (i > 0 && isNumber(tokens.get(i - 1))) {
                numbers.push(tokens.remove(i - 1));
                i--;
            } else {
                numbers.push("""");
            }
        }
    }
}",reverse,org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,"/**
     * Reverse a list of tokens for display, flipping
     * brackets as needed.
     *
     * @param tokens list of tokens
     */",270-300,"('reverse', {'INSTRUCTION': {'covered': 76, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",184.0,13.0,"Reverse a list of tokens for display, flipping  brackets as needed.","This method reverses a list of tokens for display, flipping brackets as needed",Pull the list of token and flip them as needed.,0.322845809017359,"Invert a list of tokens to display, flipping the square brackets if necessary.","static void reverse(List<String> tokens){
        int i = 0;
        int len = tokens.size();
        while (i < len) {
            String token = tokens.get(i);
            if (token.equals(""("")) {
                tokens.set(i, "")"");
            } else if (token.equals("")"")) {
                tokens.set(i, ""("");
            }
            i++;
        }
    }","static void reverse(List<String> tokens){
        int i = 0;
        int len = tokens.size();
        while (i < len) {
            String token = tokens.get(i);
            if (token.equals(""("")) {
                tokens.set(i, "")"");
            } else if (token.equals("")"")) {
                tokens.set(i, ""("");
            }
            i++;
        }
    }"," static void reverse(List<String> tokens){
        Collections.reverse(tokens);        
 }","static void reverse(List<String> tokens){
        int i = 0;
        int len = tokens.size();
        while (i < len) {
            String token = tokens.get(i);
            if (token.equals(""["")) {
                tokens.set(i, ""]"");
            } else if (token.equals(""]"")) {
                tokens.set(i, ""["");
            }
            i++;
        }       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3466017541359687,  0.3466017541359687,  0.3227838447168734,  0.08742471410860174,109.0,0.5891891891891892,109.0,0.5891891891891892,113.0,0.6108108108108108,165.0,0.8918918918918919,0.0,0.0,4.0,0.0449438202247191,71.0,0.797752808988764,4.0,0.2857142857142857,6.0,0.42857142857142855,7.0,0.5833333333333334
832,sonar-cxx,"public String toString(){
    var stream = new ByteArrayOutputStream();
    save(stream);
    return stream.toString(StandardCharsets.UTF_8);
}",toString,org/sonar/cxx/config/CxxSquidConfiguration.java,/cxx-squid/src/main/java/org/sonar/cxx/config/CxxSquidConfiguration.java,"/**
   * Returns a string representation of the object: XML/UTF-8 encoded.
   *
   * @return object XML encoded
   */",404-413,"('toString', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,11.0,Returns a string representation of the object: XML/UTF-8 encoded.,Get the string representation of the input object encoded in XML/UTF-8,The object is represented by a string.,0.663478655368489,Returns a string representation of the encoded XML/UTF-8 object.," public String toString(){
    try {
      var xmlOutput = new XMLOutputter();
      xmlOutput.setFormat(Format.getPrettyFormat());
      return xmlOutput.outputString(document);
    } catch (IOException e) {
      throw new IllegalStateException(""Can't save XML document"", e);
    }
  }"," public String toString(){
    StringWriter sw = new StringWriter();
    save(sw);
    return sw.toString();
  }"," public String toString(){
    return document.toString();   
 }"," public String toString(){
    return document.toString();
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3428555492496662,  0.6214539008879741,  0.27872310073704387,  0.27872310073704387,32.0,0.5925925925925926,8.0,0.25806451612903225,17.0,0.5483870967741935,17.0,0.5483870967741935,33.0,0.6111111111111112,41.0,0.7592592592592593,41.0,0.7592592592592593,7.0,0.5833333333333334,2.0,0.2,9.0,0.9
833,weblogic-kubernetes-operator,"public void scheduleOnce(long timeout, TimeUnit unit, Runnable runnable){
    this.owner.getExecutor().schedule(runnable, timeout, unit);
}",scheduleOnce,oracle/kubernetes/operator/work/Fiber.java,/operator/src/main/java/oracle/kubernetes/operator/work/Fiber.java,"/**
   * Use this fiber's executor to schedule an operation for some time in the future.
   * @param timeout the interval before the check should run, in units
   * @param unit the unit of time that defines the interval
   * @param runnable the operation to run
   */",106-115,"('scheduleOnce', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,16.0,Use this fiber's executor to schedule an operation for some time in the future.,Schedule an operation at the given time in the future,Use the fiber's executor to schedule an operation in the future.,0.294299937812538,Use the executor of this fiber to schedule an operation for a certain time in the future.," public void scheduleOnce(long timeout, TimeUnit unit, Runnable runnable){
    owner.getExecutor().schedule(runnable, timeout, unit);
  }"," public void scheduleOnce(long timeout, TimeUnit unit, Runnable runnable){
    owner.scheduleOnce(timeout, unit, runnable);
  }"," public void scheduleOnce(long timeout, TimeUnit unit, Runnable runnable){
    owner.scheduleOnce(timeout, unit, runnable);
  }"," public void scheduleOnce(long timeout, TimeUnit unit, Runnable runnable){
    owner.scheduleOnce(timeout, unit, runnable);
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8496634245311148,  0.6612733939479228,  0.6612733939479228,  0.6612733939479228,2.0,0.06060606060606061,10.0,0.30303030303030304,10.0,0.30303030303030304,10.0,0.30303030303030304,8.0,0.25806451612903225,8.0,0.25806451612903225,8.0,0.25806451612903225,10.0,0.6666666666666666,7.0,0.3888888888888889,4.0,0.26666666666666666
834,cdk,"private static boolean skipLine(String line){
    return line.isEmpty() || line.charAt(0) == '*' || line.charAt(0) == '$';
}",skipLine,org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,"/**
     * A line is skipped if it is empty or is a comment. MMFF files use '*' to mark comments and '$'
     * for end of file.
     *
     * @param line an input line
     * @return whether to skip this line
     */",270-279,"('skipLine', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,13.0,A line is skipped if it is empty or is a comment.,This method skips a line if it is empty,"If a line is empty or a comment, it is skipped.",0.291511969668511,A row is ignored if it is empty or if it is a comment.," private static boolean skipLine(String line){
        return line.isEmpty() || line.startsWith(""#"");
    }","private static boolean skipLine(String line){
        if(line.length()==0) return true;
        if(line.startsWith(""#"")) return true;
        return false;
    }","private static boolean skipLine(String line){
        if (line.length() == 0) return true;
        if (line.charAt(0) == '#') return true;
        return false;
    }"," private static boolean skipLine(String line){
        return line.isEmpty() || line.startsWith(""#"");
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4905757970868837,  0.3891136791576885,  0.4905757970868837,  0.5317944189320062,13.0,0.3611111111111111,21.0,0.5384615384615384,13.0,0.3611111111111111,20.0,0.4878048780487805,17.0,0.4358974358974359,0.0,0.0,21.0,0.5121951219512195,9.0,0.6923076923076923,4.0,0.26666666666666666,10.0,0.7692307692307693
835,jooby,"static String normalizePath(@Nullable String path){
    if (path == null || path.length() == 0 || path.equals(""/"")) {
        return ""/"";
    }
    int len = path.length();
    boolean modified = false;
    int p = 0;
    char[] buff = new char[len + 1];
    if (path.charAt(0) != '/') {
        buff[p++] = '/';
        modified = true;
    }
    for (int i = 0; i < path.length(); i++) {
        char ch = path.charAt(i);
        if (ch != '/') {
            buff[p++] = ch;
        } else if (i == 0 || path.charAt(i - 1) != '/') {
            buff[p++] = ch;
        } else {
            modified = true;
        }
    }
    return modified ? new String(buff, 0, p) : path;
}",normalizePath,io/jooby/Router.java,/jooby/src/main/java/io/jooby/Router.java,"/**
   * Normalize a path by removing consecutive <code>/</code>(slashes).
   *
   * @param path Path to process.
   * @return Safe path pattern.
   */",1065-1096,"('normalizePath', {'INSTRUCTION': {'covered': 84, 'missed': 0}, 'BRANCH': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",190.0,17.0,Normalize a path by removing consecutive <code>/</code>(slashes).,This method clean path by removing consecutive slashes,Remove the code from a path.,0.360315043614332,Normalize a path by removing <code>consecutive /() forward slashes</code>.,"static String normalizePath(@Nullable String path){
    if (path == null || path.length() == 0) {
      return ""/"";
    }
    StringBuilder buff = new StringBuilder(path);
    int i = 0;
    while (i < buff.length() - 1) {
      if (buff.charAt(i) == '/' && buff.charAt(i + 1) == '/') {
        buff.deleteCharAt(i);
      } else {
        i += 1;
      }
    }
    if (path.length() != buff.length()) {
      return buff.toString();
    }
    return path;    
 }","static String normalizePath(@Nullable String path){
    if(path == null || path.length() == 0){
      return ""/"";
    }
    StringBuilder buff = new StringBuilder(path);
    int i = buff.length() - 1;
    while(i > 0 && buff.charAt(i) == '/'){
      buff.setLength(i);
      i -= 1;
    }
    if(path.length() != buff.length()){
      return buff.toString();
    }
    return path;    
 }","static String normalizePath(@Nullable String path){
    if (path == null || path.length() == 0) {
      return ""/"";
    }
    if (path.charAt(0) == '/') {
      return path;
    }
    return ""/"" + path;
  }","static String normalizePath(@Nullable String path){
    if (path == null || path.length() == 0) {
      return ""/"";
    }
    if (path.charAt(0) != '/') {
      path = ""/"" + path;
    }
    StringBuilder buff = new StringBuilder(path);
    int i = 1;
    while (i < buff.length()) {
      if (buff.charAt(i) == '/') {
        if (buff.charAt(i - 1) == '/') {
          buff.deleteCharAt(i);
        } else {
          i += 1;
        }
      } else {
        i += 1;
      }
    }
    return buff.toString();
  }",NOT PASS,NOT PASS,PASS,NOT PASS,  0.3259445036720544,  0.27036750149127636,  0.35925834667776424,  0.15651306165568843,118.0,0.6178010471204188,123.0,0.643979057591623,109.0,0.5706806282722513,143.0,0.7486910994764397,24.0,0.1951219512195122,46.0,0.3484848484848485,77.0,0.6260162601626016,4.0,0.4444444444444444,4.0,0.4,7.0,0.875
836,twilio-java,"public static WorkflowRuleTarget fromJson(String json) throws IOException{
    ObjectMapper mapper = new ObjectMapper();
    return mapper.readValue(json, WorkflowRuleTarget.class);
}",fromJson,com/twilio/taskrouter/WorkflowRuleTarget.java,/src/main/java/com/twilio/taskrouter/WorkflowRuleTarget.java,"/**
     * Converts a JSON workflow configuration to a workflow configuration object.
     *
     * @param json JSON for workflow rule target
     * @return a workflow rule target object
     * @throws IOException if unable to create object
     */",147-157,"('fromJson', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,11.0,Converts a JSON workflow configuration to a workflow configuration object.,Parse a JSON workflow in the propoer workflow configuration object,A workflows configuration is converted to a object.,0.297076118714806,Converts a JSON workflow configuration to a workflow configuration object.," public static WorkflowRuleTarget fromJson(String json) throws IOException{
        return new ObjectMapper().readValue(json, WorkflowRuleTarget.class);        
 }"," public static WorkflowRuleTarget fromJson(String json) throws IOException{
        ObjectMapper mapper = new ObjectMapper();
        return mapper.readValue(json, WorkflowRuleTarget.class);
    }"," public static WorkflowRuleTarget fromJson(String json) throws IOException{
        return new ObjectMapper().readValue(json, WorkflowRuleTarget.class);        
 }"," public static WorkflowRuleTarget fromJson(String json) throws IOException{
        return new ObjectMapper().readValue(json, WorkflowRuleTarget.class);        
 }",PASS,PASS,PASS,PASS,  0.6102596348817327,  1.0,  0.6102596348817327,  0.6102596348817327,6.0,0.18181818181818182,0.0,0.0,6.0,0.18181818181818182,6.0,0.18181818181818182,6.0,0.18181818181818182,0.0,0.0,0.0,0.0,5.0,0.45454545454545453,0.0,0.0,7.0,0.6363636363636364
838,egeria,"public Optional<EntityDetail> findProcessEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, PROCESS_TYPE_NAME);
}",findProcessEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineProcessHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineProcessHandler.java,"/**
     * Find out if the Process object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",148-164,"('findProcessEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,13.0,Find out if the Process object is already stored in the repository.,Check if the Process object is already stored in the repository.,"If the Process object is already in the repository, you should find it.",0.137592533755924,Check if the Process object is already stored in the repository.," public Optional<EntityDetail> findProcessEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        final String methodName = ""findProcessEntity"";
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateName(qualifiedName, methodName);
    
        return assetHandler.findAssetByGUID(userId, qualifiedName, PROCESS_TYPE_GUID, methodName);
    }"," public Optional<EntityDetail> findProcessEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        final String methodName = ""findProcessEntity"";
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateName(qualifiedName, PROCESS_QUALIFIED_NAME_PROPERTY_NAME, methodName);
    
        return assetHandler.findAssetByGUID(userId, qualifiedName, PROCESS_TYPE_GUID, PROCESS_TYPE_NAME, methodName);       
 }"," public Optional<EntityDetail> findProcessEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        final String methodName = ""findProcessEntity"";
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateName(qualifiedName, methodName);
    
        return assetHandler.findAssetByGUID(userId, qualifiedName, methodName);
    }"," public Optional<EntityDetail> findProcessEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        final String methodName = ""findProcessEntity"";
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateName(qualifiedName, methodName);
    
        return assetHandler.findAssetByGUID(userId, qualifiedName, PROCESS_TYPE_GUID, PROCESS_TYPE_NAME, methodName);       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7027698485831495,  0.736527648265115,  0.704107020127839,  0.7600508503097438,29.0,0.48333333333333334,32.0,0.5,30.0,0.4838709677419355,27.0,0.46551724137931033,4.0,0.0625,2.0,0.03225806451612903,2.0,0.03333333333333333,2.0,0.15384615384615385,2.0,0.15384615384615385,9.0,0.6428571428571429
839,cdk,"public HashGeneratorMaker encode(AtomEncoder encoder){
    if (encoder == null)
        throw new NullPointerException(""no encoder provided"");
    customEncoders.add(encoder);
    return this;
}",encode,org/openscience/cdk/hash/HashGeneratorMaker.java,/tool/hash/src/main/java/org/openscience/cdk/hash/HashGeneratorMaker.java,"/**
     * Add a custom encoder to the hash generator which will be built. Although
     * not enforced, the encoder should be stateless and should not modify any
     * passed inputs.
     *
     * @param encoder an atom encoder
     * @return fluent API reference (self)
     * @throws NullPointerException no encoder provided
     */",257-270,"('encode', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,13.0,Add a custom encoder to the hash generator which will be built.,Add the custom passed encoder to the hash generator which will be built. ,The generator will be built with a custom encoder.,0.705514667978287,Add a custom encoder to the hash generator that will be built.," public HashGeneratorMaker encode(AtomEncoder encoder){
        this.encoderSet.add(encoder);
        return this;
    }"," public HashGeneratorMaker encode(AtomEncoder encoder){
        encoderSet.add(encoder);
        return this;
    }"," public HashGeneratorMaker encode(AtomEncoder encoder){
        this.encoderSet.add(encoder);
        return this;
    }"," public HashGeneratorMaker encode(AtomEncoder encoder){
        this.encoderSet.add(encoder);
        return this;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.49382234027384064,  0.5154529735765823,  0.49382234027384064,  0.49382234027384064,14.0,0.42424242424242425,14.0,0.42424242424242425,14.0,0.42424242424242425,14.0,0.42424242424242425,2.0,0.09090909090909091,0.0,0.0,0.0,0.0,2.0,0.14285714285714285,1.0,0.07692307692307693,12.0,0.9230769230769231
840,cdk,"private static String[] readSMARTSPattern(String filename) throws Exception{
    InputStream ins = StandardSubstructureSets.class.getClassLoader().getResourceAsStream(filename);
    BufferedReader reader = new BufferedReader(new InputStreamReader(ins));
    List<String> tmp = new ArrayList<String>();
    String line;
    while ((line = reader.readLine()) != null) {
        if (line.startsWith(""#"") || line.trim().length() == 0)
            continue;
        String[] toks = line.split("":"");
        StringBuffer s = new StringBuffer();
        for (int i = 1; i < toks.length - 1; i++) s.append(toks[i] + "":"");
        s.append(toks[toks.length - 1]);
        tmp.add(s.toString().trim());
    }
    return tmp.toArray(new String[] {});
}",readSMARTSPattern,org/openscience/cdk/fingerprint/StandardSubstructureSets.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/StandardSubstructureSets.java,"/**
     * Load a list of SMARTS patterns from the specified file.
     *
     * Each line in the file corresponds to a pattern with the following structure:
     * PATTERN_DESCRIPTION: SMARTS_PATTERN, <i>e.g., Thioketone: [#6][CX3](=[SX1])[#6]</i>
     *
     * Empty lines and lines starting with a ""#"" are skipped.
     *
     * @param filename list of the SMARTS pattern to be loaded
     * @return list of strings containing the loaded SMARTS pattern
     * @throws Exception if there is an error parsing SMILES patterns
     */",46-74,"('readSMARTSPattern', {'INSTRUCTION': {'covered': 84, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",191.0,11.0,Load a list of SMARTS patterns from the specified file.,Get a list of smart patterns from the specified file,A list of SMARTS patterns can be loaded.,0.309366533746837,Load a list of SMARTS templates from the specified file.,Empty Method,Empty Method," private static String[] readSMARTSPattern(String filename) throws Exception{
        InputStream in = StandardSubstructureSets.class.getClassLoader().getResourceAsStream(filename);
        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
        List<String> smarts = new ArrayList<String>();
        String line = null;
        while ((line = reader.readLine()) != null) {
            if (line.startsWith(""#"")) continue;
            smarts.add(line);
        }
        return smarts.toArray(new String[smarts.size()]);
    }       ","private static String[] readSMARTSPattern(String filename) throws Exception{
        InputStream in = StandardSubstructureSets.class.getClassLoader().getResourceAsStream(filename);
        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
        List<String> smarts = new ArrayList<String>();
        String line = null;
        while ((line = reader.readLine()) != null) {
            if (line.startsWith(""#"") || line.length() == 0) continue;
            smarts.add(line);
        }
        return smarts.toArray(new String[smarts.size()]);
    }",Empty Method,Empty Method,NOT PASS,NOT PASS,None,None,  0.49242517653845147,  0.46197126960524193,None,None,None,None,89.0,0.4635416666666667,97.0,0.5052083333333334,None,None,120.0,0.9917355371900827,112.0,0.9911504424778761,3.0,0.2727272727272727,1.0,0.09090909090909091,6.0,0.5454545454545454
841,matsim-libs,"public T selectPlan(final HasPlansAndId<T, I> person){
    // this used to use person.getRandomPlan(), but I inlined the function here in order to get rid of the function of the data class.
    // kai, nov'13
    if (person.getPlans().size() == 0) {
        return null;
    }
    int index = (int) (MatsimRandom.getRandom().nextDouble() * person.getPlans().size());
    // yyyy As far as I can tell, this produces race conditions when running multi-threaded.  I.e. when running the same
    // setup twice, this function may return different results per thread or per person.  kai, jun'14
    return person.getPlans().get(index);
}",selectPlan,org/matsim/core/replanning/selectors/RandomPlanSelector.java,/matsim/src/main/java/org/matsim/core/replanning/selectors/RandomPlanSelector.java,"/**
         * Choose a random plan from the person and return it.
         * @return The newly selected plan for this person; <code>null</code> if the person has no plans.
         */",35-52,"('selectPlan', {'INSTRUCTION': {'covered': 21, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,11.0,Choose a random plan from the person and return it.,Select a random plan from the person and return it,Pick a random plan from the person and return it.,0.181932803787602,Choose a random plan of the person and flip it over.," public T selectPlan(final HasPlansAndId<T, I> person){
    int randomIndex = MatsimRandom.getRandom().nextInt(person.getPlans().size());
    return person.getPlans().get(randomIndex);
  }"," public T selectPlan(final HasPlansAndId<T, I> person){
   	int index = MatsimRandom.getRandom().nextInt(person.getPlans().size());
 	return person.getPlans().get(index);
 }"," public T selectPlan(final HasPlansAndId<T, I> person){
   	return person.getPlans().get( MatsimRandom.getRandom().nextInt(person.getPlans().size()) );
 }"," public T selectPlan(final HasPlansAndId<T, I> person){
   	int index = MatsimRandom.getRandom().nextInt(person.getPlans().size());
 	return person.getPlans().get(index);
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6050278814096629,  0.6105346361549354,  0.6105346361549354,  0.4658720389578613,28.0,0.37333333333333335,26.0,0.3466666666666667,26.0,0.3466666666666667,33.0,0.44,2.0,0.04,2.0,0.04,16.0,0.32,2.0,0.18181818181818182,4.0,0.3333333333333333,1.0,0.09090909090909091
842,acs-aem-commons,"public void doPost(SlingHttpServletRequest request, SlingHttpServletResponse response) throws IOException, ServletException{
    response.setContentType(""application/json"");
    response.setCharacterEncoding(""UTF-8"");
    final ValueMap properties = request.getResource().adaptTo(ModifiableValueMap.class);
    final Parameters parameters = new Parameters(request);
    properties.put(GROUP_FILTER, parameters.getGroupFilter());
    properties.put(GROUPS, parameters.getGroups());
    properties.put(CUSTOM_PROPERTIES, parameters.getCustomProperties());
    request.getResourceResolver().commit();
}",doPost,com/adobe/acs/commons/exporters/impl/users/UsersSaveServlet.java,/bundle/src/main/java/com/adobe/acs/commons/exporters/impl/users/UsersSaveServlet.java,"/**
     * Persists the Users to CSV form data to the underlying jcr:content node.
     * @param request the Sling HTTP Request object
     * @param response the Sling HTTP Response object
     * @throws IOException
     * @throws ServletException
     */",45-64,"('doPost', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",106.0,15.0,Persists the Users to CSV form data to the underlying jcr:content node.,Add the Users to CSV form data to the underlying jcr,Users form data to the jcr:content.,1.33924433312161,Keeps users' CSV form data in the underlying jcr:content node.,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,Empty Method,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,3.0,0.23076923076923078,5.0,0.38461538461538464,7.0,0.5384615384615384
843,openapi-generator,"public String toEnumValue(String value, String datatype){
    if (""number"".equalsIgnoreCase(datatype) || ""boolean"".equalsIgnoreCase(datatype)) {
        return value;
    } else {
        return ""\"""" + escapeText(value) + ""\"""";
    }
}",toEnumValue,org/openapitools/codegen/DefaultCodegen.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java,"/**
     * Return the enum value in the language specified format
     * e.g. status becomes ""status""
     *
     * @param value    enum variable name
     * @param datatype data type
     * @return the sanitized value for enum
     */",754-768,"('toEnumValue', {'INSTRUCTION': {'covered': 21, 'missed': 2}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,11.0,Return the enum value in the language specified format  e.,Get the enum value in the language specified format,Return the value in the language specified.,0.145657789897354,Return the enum value in the specified language in e format.," public String toEnumValue(String value, String datatype){
        return datatype + ""."" + value;
    }"," public String toEnumValue(String value, String datatype){
        return datatype + ""."" + value;      
 }"," public String toEnumValue(String value, String datatype){
        return value;
    }"," public String toEnumValue(String value, String datatype){
        return value;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3067550943147968,  0.3067550943147968,  0.2624381414709361,  0.2624381414709361,30.0,0.6382978723404256,30.0,0.6382978723404256,31.0,0.6595744680851063,31.0,0.6595744680851063,0.0,0.0,4.0,0.2,4.0,0.2,2.0,0.18181818181818182,4.0,0.3333333333333333,4.0,0.36363636363636365
844,jackson-databind,"protected SequenceWriter _newSequenceWriter(boolean wrapInArray, JsonGenerator gen, boolean managedInput) throws IOException{
    return new SequenceWriter(_serializerProvider(), _configureGenerator(gen), managedInput, _prefetch).init(wrapInArray);
}",_newSequenceWriter,com/fasterxml/jackson/databind/ObjectWriter.java,/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java,"/**
     * Overridable factory method called by {@link #writeValues(OutputStream)}
     * method (and its various overrides), and initializes it as necessary.
     * 
     * @since 2.5
     */",248-262,"('_newSequenceWriter', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,28.0,"Overridable factory method called by {@link #writeValues(OutputStream)}  method (and its various overrides), and initializes it as necessary.",Create a default overridable sequence writer,The factory method called by @link #writeValues(OutputStream) method is over-simplified and has various overrides.,1.06452764766966,A substitutable factory method called by the {@link #writeValues(OutputStream)} method (and its various substitutions) and initializes if necessary.," protected SequenceWriter _newSequenceWriter(boolean wrapInArray, JsonGenerator gen, boolean managedInput) throws IOException{
        JsonSerializer<Object> ser = _prefetch.serializer();
        if (ser == null) {
            ser = _serializerProvider.findValueSerializer(_config.getSerializationType(), _config.getPropertyInclusion());
        }
        JsonSerializer<Object> contentSerializer = _prefetch.contentSerializer();
        if (contentSerializer == null) {
            contentSerializer = _serializerProvider.findContentSerializer(_config.getSerializationType(), _config.getPropertyInclusion());
        }
        JsonSerializer<Object> keySerializer = _prefetch.keySerializer();
        if (keySerializer == null) {
            keySerializer = _serializerProvider.findKeySerializer(_config.getSerializationType(), _config.getPropertyInclusion());
        }
        JsonSerializer<Object> contentKeySerializer = _prefetch.contentKeySerializer();
        if (contentKeySerializer == null) {
            contentKeySerializer = _serializerProvider.findKeySerializer(_config.getSerializationType(), _config.getPropertyInclusion());
        }
        JsonSerializer<Object> contentValueSerializer = _prefetch.contentValueSerializer();
        if (contentValueSerializer == null) {
            contentValueSerializer = _serializerProvider.findValueSerializer(_config.getSerializationType(), _config.getPropertyInclusion());
        }
        JsonSerializer<Object> keyValueSerializer = _prefetch.keyValueSerializer();
        if (keyValueSerializer == null) {
            keyValueSerializer = _serializerProvider.findValueSerializer(_config.getSerializationType(), _config.getPropertyInclusion());
        }
        JsonSerializer<Object> contentValueKeySerializer = _prefetch.contentValueKeySerializer();
        if (contentValueKeySerializer == null) {
            contentValueKeySerializer = _serializerProvider.findKeySerializer(_config.getSerializationType(), _config.getPropertyInclusion());
        }
        JsonSerializer<Object> contentValueKeyValueSerializer = _pre        
 }"," protected SequenceWriter _newSequenceWriter(boolean wrapInArray, JsonGenerator gen, boolean managedInput) throws IOException{
        return new SequenceWriter(wrapInArray, gen, managedInput);
    }"," protected SequenceWriter _newSequenceWriter(boolean wrapInArray, JsonGenerator gen, boolean managedInput) throws IOException{
        JsonGenerator g = gen;
        if (g == null) {
            g = _createGenerator(_config, _generatorFactory);
        }
        if (wrapInArray) {
            g.writeStartArray();
        }
        return new SequenceWriter(g, managedInput);
    }"," protected SequenceWriter _newSequenceWriter(boolean wrapInArray, JsonGenerator gen, boolean managedInput) throws IOException{
        return new SequenceWriter(this, wrapInArray, gen, managedInput);
    }",Syntax Error,NOT PASS,NOT PASS,NOT PASS,None,  0.6306285334143761,  0.6323730108360772,  0.6012748894444704,None,None,13.0,0.3170731707317073,13.0,0.3170731707317073,34.0,0.5573770491803278,275.0,0.9228187919463087,274.0,0.9194630872483222,252.0,0.8456375838926175,17.0,0.9444444444444444,6.0,0.3157894736842105,11.0,0.6111111111111112
845,cdk,"public AtomHashGenerator atomic(){
    if (depth < 0)
        throw new IllegalArgumentException(""no depth specified, use .depth(int)"");
    List<AtomEncoder> encoders = new ArrayList<AtomEncoder>();
    for (AtomEncoder encoder : encoderSet) {
        encoders.add(encoder);
    }
    encoders.addAll(this.customEncoders);
    boolean suppress = suppression != AtomSuppression.unsuppressed();
    AtomEncoder encoder = new ConjugatedAtomEncoder(encoders);
    SeedGenerator seeds = new SeedGenerator(encoder, suppression);
    AbstractAtomHashGenerator simple = suppress ? new SuppressedAtomHashGenerator(seeds, new Xorshift(), makeStereoEncoderFactory(), suppression, depth) : new BasicAtomHashGenerator(seeds, new Xorshift(), makeStereoEncoderFactory(), depth);
    if (equivSetFinder != null) {
        return new PerturbedAtomHashGenerator(seeds, simple, new Xorshift(), makeStereoEncoderFactory(), equivSetFinder, suppression);
    } else {
        return simple;
    }
}",atomic,org/openscience/cdk/hash/HashGeneratorMaker.java,/tool/hash/src/main/java/org/openscience/cdk/hash/HashGeneratorMaker.java,"/**
     * Given the current configuration create an {@link AtomHashGenerator}.
     *
     * @return instance of the generator
     * @throws IllegalArgumentException no depth or encoders were configured
     */",311-349,"('atomic', {'INSTRUCTION': {'covered': 101, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",167.0,12.0,Given the current configuration create an {@link AtomHashGenerator}.,Create a configuration starting from a given current configuration,The current configuration would make it possible to create an @link AtomHashGenerator.,1.25851225733188,"Given the current configuration, create a {@link AtomHashGenerator}.","public AtomHashGenerator atomic(){
        if (depth == 0) throw new IllegalArgumentException(""no depth configured"");
        if (encoders.isEmpty()) throw new IllegalArgumentException(""no encoders configured"");
        if (suppression == null) suppression = AtomSuppression.none();
        if (equivSetFinder == null) equivSetFinder = new MinimumEquivalentCyclicSet();
        return new AtomHashGenerator(depth, encoders, suppression, equivSetFinder);
    }"," public AtomHashGenerator atomic(){
        return new BasicAtomHashGenerator(
                makeStereoEncoderFactory(),
                suppression,
                equivSetFinder,
                customEncoders);
    }","public AtomHashGenerator atomic(){
        if (depth == 0) throw new IllegalArgumentException(""no depth specified"");
        if (encoders.isEmpty()) throw new IllegalArgumentException(""no encoders specified"");
        if (suppression == null) throw new IllegalArgumentException(""no atom suppression specified"");
        if (equivSetFinder == null) throw new IllegalArgumentException(""no equivalent set finder specified"");
        return new BasicAtomHashGenerator(depth, makeStereoEncoderFactory(), encoders, suppression, equivSetFinder);
    }","public AtomHashGenerator atomic(){
        if (encoders.isEmpty()) throw new IllegalArgumentException(""no encoders configured"");
        if (depth == 0) throw new IllegalArgumentException(""no depth configured"");
        if (equivSetFinder == null) throw new IllegalArgumentException(""no equivalent set finder configured"");
        if (suppression == null) throw new IllegalArgumentException(""no atom suppression configured"");
        if (customEncoders.isEmpty()) {
            return new BasicAtomHashGenerator(encoders, depth, equivSetFinder, suppression);
        } else {
            return new BasicAtomHashGenerator(encoders, depth, equivSetFinder, suppression, customEncoders);
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.1940873440950515,  0.07779258113701931,  0.24030023349219787,  0.19807736892490915,118.0,0.7023809523809523,148.0,0.8809523809523809,116.0,0.6904761904761905,115.0,0.6845238095238095,59.0,0.7763157894736842,51.0,0.49514563106796117,17.0,0.21518987341772153,9.0,0.9,2.0,0.2222222222222222,9.0,0.6923076923076923
846,cdk,"static boolean normaliseCycle(int[] cycle, int[] contribution){
    int offset = indexOfHetro(cycle, contribution);
    if (offset < 0)
        return false;
    if (offset == 0)
        return true;
    int[] cpy = Arrays.copyOf(cycle, cycle.length);
    int len = cycle.length - 1;
    for (int j = 0; j < len; j++) {
        cycle[j] = cpy[(offset + j) % len];
    }
    cycle[len] = cycle[0];
    return true;
}",normaliseCycle,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,"/**
     * Normalises a 5-member 'cycle' such that the hetroatom contributing the lone-pair is in
     * position 1 (index 0). The alpha atoms are then in index 1 and 4 whilst the beta atoms are in
     * index 2 and 3. If the ring contains more than one hetroatom the cycle is not normalised
     * (return=false).
     *
     * @param cycle        aromatic cycle to normalise, |C| = 5
     * @param contribution vector of p electron contributions from each vertex (size |V|)
     * @return whether the cycle was normalised
     */",332-353,"('normaliseCycle', {'INSTRUCTION': {'covered': 47, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",114.0,21.0,Normalises a 5-member 'cycle' such that the hetroatom contributing the lone-pair is in  position 1 (index 0).,This method normalises a 5-member 'cycle' such that the hetroatom contributing the lone-pair is in position 1,"Normalises a 5-membercycle, such that the hetroatom contributes the lone-pair.",0.663485710982068,"Normalizes a 5-limb ""cycle"" so that the hetroatoma contributing to the solitary pair is in position 1 (index 0).","static boolean normaliseCycle(int[] cycle, int[] contribution){
        int index = indexOfHetro(cycle, contribution);
        if (index == -1) return false;
        if (index == -2) throw new IllegalArgumentException(""More than one hetroatom in cycle"");
        int[] tmp = new int[cycle.length];
        System.arraycopy(cycle, index, tmp, 0, cycle.length - index);
        System.arraycopy(cycle, 0, tmp, cycle.length - index, index);
        System.arraycopy(tmp, 0, cycle, 0, cycle.length);
        return true;
    }","static boolean normaliseCycle(int[] cycle, int[] contribution){
        int index = indexOfHetro(cycle, contribution);
        if (index == -1) return false;
        if (index == -2) throw new IllegalArgumentException(""More than one hetroatom in cycle"");
        int tmp = cycle[0];
        cycle[0] = cycle[index];
        cycle[index] = tmp;
        return true;
    }","static boolean normaliseCycle(int[] cycle, int[] contribution){
        int index = indexOfHetro(cycle, contribution);
        if (index == -1) return false;
        if (index == -2) throw new IllegalArgumentException(""More than one hetroatom in cycle"");
        int tmp = cycle[0];
        cycle[0] = cycle[index];
        cycle[index] = tmp;
        return true;
    }","static boolean normaliseCycle(int[] cycle, int[] contribution){
        int index = indexOfHetro(cycle, contribution);
        if (index == -1) return false;
        if (index == -2) throw new IllegalArgumentException(""More than one hetroatom in cycle"");
        if (index != 0) {
            int tmp = cycle[0];
            cycle[0] = cycle[index];
            cycle[index] = tmp;
        }
        return true;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.43815754381091254,  0.39492257979709167,  0.41345367226644825,  0.40249833737284924,72.0,0.5901639344262295,58.0,0.5043478260869565,60.0,0.5217391304347826,58.0,0.5043478260869565,54.0,0.4426229508196721,59.0,0.48360655737704916,54.0,0.4426229508196721,5.0,0.2777777777777778,8.0,0.4,10.0,0.5555555555555556
847,egeria,"private String computeDisplayName(String pathName){
    return new File(pathName).getName().length() < 1 ? pathName : new File(pathName).getName();
}",computeDisplayName,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineFolderHierarchyHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineFolderHierarchyHandler.java,"/**
     * Will return the name of the last folder in pathName. Takes root folder into account.
     * When called with argument ""/folder"", return value is ""folder"".
     * When called with argument ""/"", return value is ""/""
     *
     * @param pathName path
     *
     * @return folder name
     */",209-220,"('computeDisplayName', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,11.0,Will return the name of the last folder in pathName.,This method returns the name of the last folder in pathName,Will return the name of the last folder.,0.0341194067124681,Returns the name of the last folder in pathName.,"private String computeDisplayName(String pathName){
        String[] folders = pathName.split(""/"");
        return folders[folders.length - 1];
    }","private String computeDisplayName(String pathName){
        String[] folders = pathName.split(""/"");
        return folders[folders.length - 1];
    }","private String computeDisplayName(String pathName){
        String displayName = pathName;
        int lastIndexOf = pathName.lastIndexOf(""/"");
        if (lastIndexOf > 0) {
            displayName = pathName.substring(lastIndexOf + 1);
        }
        return displayName;
    }","private String computeDisplayName(String pathName){
        String displayName = pathName;
        int lastIndexOf = pathName.lastIndexOf(""/"");
        if (lastIndexOf > 0) {
            displayName = pathName.substring(lastIndexOf + 1);
        }
        return displayName;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3134155018700666,  0.3134155018700666,  0.3939995020560616,  0.3939995020560616,25.0,0.6410256410256411,25.0,0.6410256410256411,29.0,0.6170212765957447,29.0,0.6170212765957447,0.0,0.0,26.0,0.5531914893617021,26.0,0.5531914893617021,4.0,0.3333333333333333,2.0,0.18181818181818182,3.0,0.2727272727272727
848,cdk,"long[] combine(long[][] perturbed){
    int n = perturbed.length;
    int m = perturbed[0].length;
    long[] combined = new long[n];
    long[] rotated = new long[m];
    for (int i = 0; i < n; i++) {
        Arrays.sort(perturbed[i]);
        for (int j = 0; j < m; j++) {
            if (j > 0 && perturbed[i][j] == perturbed[i][j - 1]) {
                combined[i] ^= rotated[j] = rotate(rotated[j - 1]);
            } else {
                combined[i] ^= rotated[j] = perturbed[i][j];
            }
        }
    }
    return combined;
}",combine,org/openscience/cdk/hash/PerturbedAtomHashGenerator.java,/tool/hash/src/main/java/org/openscience/cdk/hash/PerturbedAtomHashGenerator.java,"/**
     * Combines the values in an n x m matrix into a single array of size n.
     * This process scans the rows and xors all unique values in the row
     * together. If a duplicate value is found it is rotated using a
     * pseudorandom number generator.
     *
     * @param perturbed n x m, matrix
     * @return the combined values of each row
     */",167-200,"('combine', {'INSTRUCTION': {'covered': 83, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",165.0,17.0,Combines the values in an n x m matrix into a single array of size n.,This method combines the values in an n x m matrix into a single array of size n,The values in an n x m matrix are combined into a single array of size n.,0.364388068720225,Combines the values of a matrix n x m into a single array of size n.,"long[] combine(long[][] perturbed){
        int n = perturbed.length;
        int m = perturbed[0].length;
        long[] combined = new long[n];
        for (int i = 0; i < n; i++) {
            combined[i] = perturbed[i][0];
            for (int j = 1; j < m; j++) {
                combined[i] ^= perturbed[i][j];
            }
        }
        return combined;        
 }","long[] combine(long[][] perturbed){
        int n = perturbed.length;
        int m = perturbed[0].length;
        long[] combined = new long[n];
        for (int i = 0; i < n; i++) {
            combined[i] = perturbed[i][0];
            for (int j = 1; j < m; j++) {
                combined[i] ^= perturbed[i][j];
            }
        }
        return combined;        
 }","long[] combine(long[][] perturbed){
        int n = perturbed.length;
        int m = perturbed[0].length;
        long[] combined = new long[n];
        for (int i = 0; i < n; i++) {
            combined[i] = combine(perturbed[i]);
        }
        return combined;        
 }","long[] combine(long[][] perturbed){
        int n = perturbed.length;
        int m = perturbed[0].length;
        long[] combined = new long[n];
        for (int i = 0; i < n; i++) {
            combined[i] = Arrays.hashCode(perturbed[i]);
        }
        return combined;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5347571847917378,  0.5347571847917378,  0.4334113486918804,  0.38588491198416497,74.0,0.4457831325301205,74.0,0.4457831325301205,93.0,0.5602409638554217,93.0,0.5602409638554217,0.0,0.0,31.0,0.2980769230769231,31.0,0.2980769230769231,4.0,0.21052631578947367,4.0,0.23529411764705882,4.0,0.2222222222222222
849,dcache,"public void addType(ChecksumType type) throws IOException{
    synchronized (_digests) {
        if (_digests.stream().map(MessageDigest::getAlgorithm).noneMatch(t -> t.equals(type.getName()))) {
            MessageDigest digest = type.createMessageDigest();
            if (_isChecksumViable) {
                try {
                    updateFromChannel(Collections.singleton(digest), 0L, _nextChecksumOffset);
                } catch (IOException e) {
                    throw new IOException(""Failed when reading received data: "" + messageOrClassName(e), e);
                }
            }
            _digests.add(digest);
        }
    }
}",addType,org/dcache/pool/movers/ChecksumChannel.java,/modules/dcache/src/main/java/org/dcache/pool/movers/ChecksumChannel.java,"/**
     * Ensure that a Checksum is calculated for the supplied ChecksumType.  If the ChecksumType is
     * already registered then this method does nothing, otherwise the ChecksumChannel is updated to
     * calculate the new ChecksumType. If the ChecksumChannel has accepted a contiguous range of
     * data from offset 0 then this method will reread that contiguous range.
     *
     * @param type The algorithm this ChecksumChannel should calculate.
     * @throws IOException if the Channel has already started accepting data and an attempt to
     *                     reread data from disk fails.
     */",116-145,"('addType', {'INSTRUCTION': {'covered': 37, 'missed': 9}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 11, 'missed': 3}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",110.0,11.0,Ensure that a Checksum is calculated for the supplied ChecksumType.,Add a Checksum to the supplied ChecksumType,Ensure that the Checksum is calculated.,0.368537726356744,Make sure that a checksum is calculated for the type of checksum provided.," public void addType(ChecksumType type) throws IOException{
        _digests.add(type.createMessageDigest());
    }"," public void addType(ChecksumType type) throws IOException{
        _digests.add(type.createMessageDigest());
    }"," public void addType(ChecksumType type) throws IOException{
        _digests.add(type.createMessageDigest());
    }"," public void addType(ChecksumType type) throws IOException{
        _digests.add(type.createMessageDigest());
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.13106978807189254,  0.13106978807189254,  0.13106978807189254,  0.13106978807189254,89.0,0.8018018018018018,89.0,0.8018018018018018,89.0,0.8018018018018018,89.0,0.8018018018018018,0.0,0.0,0.0,0.0,0.0,0.0,6.0,0.5454545454545454,7.0,0.5,6.0,0.5454545454545454
850,jackson-databind,"public JsonNode putIfAbsent(String propertyName, JsonNode value){
    if (value == null) {
        value = nullNode();
    }
    return _children.putIfAbsent(propertyName, value);
}",putIfAbsent,com/fasterxml/jackson/databind/node/ObjectNode.java,/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java,"/**
     * Method that will set value of specified property if (and only if)
     * it had no set value previously.
     * Note that explicitly set {@code null} is a value.
     * Functionally equivalent to:
     *<code>
     *  if (get(propertyName) == null) {
     *      set(propertyName, value);
     *      return null;
     *  } else {
     *      return get(propertyName);
     *  }
     *</code>
     *
     * @param propertyName Name of property to set
     * @param value Value to set to property (if and only if it had no value previously);
     *  if null, will be converted to a {@link NullNode} first.
     *
     * @return Old value of the property, if any (in which case value was not changed);
     *     null if there was no old value (in which case value is now set)
     *
     * @since 2.13
     */",523-552,"('putIfAbsent', {'INSTRUCTION': {'covered': 9, 'missed': 3}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,21.0,Method that will set value of specified property if (and only if)  it had no set value previously.,Set a value of a specified property,"If the property had no set value before, the method will set the value.",0.804823132570538,Method; sets the value of the specified property if (and only if) it did not have a previously defined value.," public JsonNode putIfAbsent(String propertyName, JsonNode value){
        if (value == null) { // let's not store 'raw' nulls but nodes
            value = nullNode();
        }
        return _children.putIfAbsent(propertyName, value);
    }"," public JsonNode putIfAbsent(String propertyName, JsonNode value){
        if (value == null) { // let's not store 'raw' nulls but nodes
            value = nullNode();
        }
        return _children.putIfAbsent(propertyName, value);
    }"," public JsonNode putIfAbsent(String propertyName, JsonNode value){
        if (value == null) { // let's not store 'raw' nulls but nodes
            value = nullNode();
        }
        return _children.putIfAbsent(propertyName, value);
    }"," public JsonNode putIfAbsent(String propertyName, JsonNode value){
        if (value == null) { // let's not store 'raw' nulls but nodes
            value = nullNode();
        }
        return _children.putIfAbsent(propertyName, value);
    }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,15.0,0.7894736842105263,12.0,0.5714285714285714,17.0,0.8947368421052632
851,jeromq,"public ZFrame unwrap(){
    if (size() == 0) {
        return null;
    }
    ZFrame f = pop();
    ZFrame empty = getFirst();
    if (empty.hasData() && empty.size() == 0) {
        empty = pop();
        empty.destroy();
    }
    return f;
}",unwrap,org/zeromq/ZMsg.java,/src/main/java/org/zeromq/ZMsg.java,"/**
     * Pop frame off front of message, caller now owns frame.
     * If next frame is empty, pops and destroys that empty frame
     * (e.g. useful when unwrapping ROUTER socket envelopes)
     * @return
     *          Unwrapped frame
     */",129-148,"('unwrap', {'INSTRUCTION': {'covered': 22, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,12.0,"Pop frame off front of message, caller now owns frame.",Pop frames off the front of the message,The caller now owns the frame.,0.164138892923141,"Pop frame off front of message, the caller now owns frame."," public ZFrame unwrap(){
        ZFrame frame = pop();
        if (frame != null) {
            ZFrame empty = pop();
            assert empty != null;
            empty.destroy();
        }
        return frame;
    }"," public ZFrame unwrap(){
        ZFrame frame = pop();
        if (frame != null) {
            ZFrame empty = pop();
            if (empty != null) {
                empty.destroy();
            }
        }
        return frame;
    }"," public ZFrame unwrap(){
        ZFrame frame = pop();
        pop();
        return frame;
    }"," public ZFrame unwrap(){
        ZFrame frame = pop();
        if (frame != null) {
            ZFrame empty = pop();
            assert empty != null;
            empty.destroy();
        }
        return frame;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4194870152046331,  0.4283130018177114,  0.4194870152046331,  0.2545121611049427,38.0,0.5588235294117647,38.0,0.5588235294117647,38.0,0.5588235294117647,48.0,0.7058823529411765,5.0,0.10638297872340426,0.0,0.0,22.0,0.5,7.0,0.6363636363636364,1.0,0.08333333333333333,7.0,0.6363636363636364
853,logstash-logback-encoder,"private void appendRootCauseLast(StringBuilder builder, String prefix, int indent, IThrowableProxy throwableProxy, Deque<String> stackHashes){
    if (throwableProxy == null || builder.length() > maxLength) {
        return;
    }
    String hash = stackHashes == null || stackHashes.isEmpty() ? null : stackHashes.removeFirst();
    appendFirstLine(builder, prefix, indent, throwableProxy, hash);
    appendStackTraceElements(builder, indent, throwableProxy);
    IThrowableProxy[] suppressedThrowableProxies = throwableProxy.getSuppressed();
    if (suppressedThrowableProxies != null) {
        for (IThrowableProxy suppressedThrowableProxy : suppressedThrowableProxies) {
            appendRootCauseLast(builder, CoreConstants.SUPPRESSED, indent + ThrowableProxyUtil.SUPPRESSED_EXCEPTION_INDENT, suppressedThrowableProxy, null);
        }
    }
    appendRootCauseLast(builder, CoreConstants.CAUSED_BY, indent, throwableProxy.getCause(), stackHashes);
}",appendRootCauseLast,net/logstash/logback/stacktrace/ShortenedThrowableConverter.java,/src/main/java/net/logstash/logback/stacktrace/ShortenedThrowableConverter.java,"/**
     * Appends a throwable and recursively appends its causedby/suppressed throwables
     * in ""normal"" order (Root cause last).
     */",320-347,"('appendRootCauseLast', {'INSTRUCTION': {'covered': 70, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 3}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",151.0,20.0,"Appends a throwable and recursively appends its causedby/suppressed throwables  in ""normal"" order (Root cause last).",Appends recursively the root cause,Appends a throwable and then adds it to the normal order.,2.19599717760306,"Adds a disposable and recursively adds its caused/deleted disposables in the ""normal"" order (first cause last).","private void appendRootCauseLast(StringBuilder builder, String prefix, int indent, IThrowableProxy throwableProxy, Deque<String> stackHashes){
        if (throwableProxy == null) {
            return;
        }
        String throwableClassName = throwableProxy.getClassName();
        String throwableMessage = throwableProxy.getMessage();
        String throwableHash = null;
        if (inlineHash && stackHashes != null) {
            throwableHash = stackHashes.poll();
        }
        if (throwableMessage == null) {
            throwableMessage = CoreConstants.EMPTY_STRING;
        }
        if (throwableHash != null) {
            throwableMessage += "" ("" + throwableHash + "")"";
        }
        if (prefix == null) {
            prefix = CoreConstants.EMPTY_STRING;
        }
        if (indent > 0) {
            builder.append(prefix).append(CoreConstants.LINE_SEPARATOR);
        }
        builder.append(prefix).append(throwableClassName);
        if (throwableMessage.length() > 0) {
            builder.append("": "").append(throwableMessage);
        }
        builder.append(CoreConstants.LINE_SEPARATOR);
        if (throwableProxy.getSuppressed() != null) {
            for (IThrowableProxy suppressed : throwableProxy.getSuppressed()) {
                appendRootCauseLast(builder, prefix + ThrowableProxyUtil.SUPPRESSED_EXCEPTION_INDENT, indent, suppressed, stackHashes);
            }
        }
        if (throwableProxy.getCause() != null) {
            appendRootCauseLast(builder, prefix + ThrowableProxyUtil.CAUSED_BY_EXCEPTION_INDENT, indent, throwableProxy.getCause(), stackHashes);
        }       
 }","private void appendRootCauseLast(StringBuilder builder, String prefix, int indent, IThrowableProxy throwableProxy, Deque<String> stackHashes){
        if (throwableProxy == null) {
            return;
        }
        String throwableClassName = throwableProxy.getClassName();
        String throwableMessage = throwableProxy.getMessage();
        String throwableHash = null;
        if (inlineHash && stackHashes != null) {
            throwableHash = stackHashes.poll();
        }
        if (throwableMessage == null) {
            throwableMessage = CoreConstants.EMPTY_STRING;
        }
        if (throwableHash != null) {
            throwableMessage += "" ("" + throwableHash + "")"";
        }
        if (prefix == null) {
            prefix = CoreConstants.EMPTY_STRING;
        }
        if (indent > 0) {
            builder.append(prefix).append(CoreConstants.LINE_SEPARATOR);
        }
        builder.append(prefix).append(throwableClassName).append("": "").append(throwableMessage);
        if (throwableProxy.getCause() != null) {
            builder.append(CoreConstants.LINE_SEPARATOR);
            appendRootCauseLast(builder, prefix + ThrowableProxyUtil.REGULAR_EXCEPTION_INDENT, indent, throwableProxy.getCause(), stackHashes);
        }       
 }","private void appendRootCauseLast(StringBuilder builder, String prefix, int indent, IThrowableProxy throwableProxy, Deque<String> stackHashes){
        if (throwableProxy == null) {
            return;
        }
    
        String throwableProxyIndent = prefix == null ? """" : prefix;
        String throwableProxyPrefix = throwableProxyIndent + ThrowableProxyUtil.REGULAR_EXCEPTION_INDENT;
    
        // append the throwable class name
        builder.append(throwableProxyIndent).append(throwableProxy.getClassName()).append(CoreConstants.LINE_SEPARATOR);
    
        // append the message
        String message = throwableProxy.getMessage();
        if (message != null) {
            builder.append(throwableProxyPrefix).append(message).append(CoreConstants.LINE_SEPARATOR);
        }
    
        // append the throwable's suppressed exceptions
        IThrowableProxy[] suppressedExceptions = throwableProxy.getSuppressed();
        if (suppressedExceptions != null && suppressedExceptions.length > 0) {
            builder.append(throwableProxyPrefix).append(""Suppressed:"").append(CoreConstants.LINE_SEPARATOR);
            for (IThrowableProxy suppressedException : suppressedExceptions) {
                appendRootCauseLast(builder, throwableProxyPrefix, indent, suppressedException, stackHashes);
            }
        }
    
        // append the stack trace
        Stack       
 }","private void appendRootCauseLast(StringBuilder builder, String prefix, int indent, IThrowableProxy throwableProxy, Deque<String> stackHashes){
        if (throwableProxy == null) {
            return;
        }
        String throwableProxyString = throwableProxy.toString();
        if (throwableProxyString.length() > maxLength) {
            throwableProxyString = throwableProxyString.substring(0, maxLength - ELLIPSIS.length() - CoreConstants.LINE_SEPARATOR.length()) + ELLIPSIS + CoreConstants.LINE_SEPARATOR;
        }
        builder.append(prefix).append(throwableProxyString);
        if (stackHashes != null) {
            builder.append(stackHashes.pollFirst());
        }
        builder.append(CoreConstants.LINE_SEPARATOR);
        if (throwableProxy.getCause() != null) {
            appendRootCauseLast(builder, ThrowableProxyUtil.CAUSE_PREFIX, indent, throwableProxy.getCause(), stackHashes);
        }
        if (throwableProxy.getSuppressed() != null) {
            for (int i = 0; i < throwableProxy.getSuppressed().length; i++) {
                appendRootCauseLast(builder, ThrowableProxyUtil.SUPPRESSED_PREFIX + i + CoreConstants.LINE_SEPARATOR, indent, throwableProxy.getSuppressed()[i], stackHashes);
            }
        }       
 }",NOT PASS,NOT PASS,NOT PASS,Syntax Error,  0.5428298591387999,  0.5031756398981583,  0.5721323378416634,None,165.0,0.6297709923664122,130.0,0.6310679611650486,136.0,0.6181818181818182,113.0,0.6243093922651933,62.0,0.2366412213740458,143.0,0.5458015267175572,147.0,0.5610687022900763,12.0,0.75,7.0,0.4117647058823529,11.0,0.6875
855,acs-aem-commons,"private List<JackrabbitAccessControlList> findAcls(ResourceResolver resourceResolver, String principalName, JackrabbitAccessControlManager accessControlManager){
    final Set<String> paths = new HashSet<String>();
    final List<JackrabbitAccessControlList> acls = new ArrayList<JackrabbitAccessControlList>();
    final Map<String, String> params = new HashMap<String, String>();
    params.put(""type"", PROP_NT_REP_ACE);
    params.put(""property"", PROP_REP_PRINCIPAL_NAME);
    params.put(""property.value"", principalName);
    params.put(""p.limit"", ""-1"");
    Query query = queryBuilder.createQuery(PredicateGroup.create(params), resourceResolver.adaptTo(Session.class));
    QueryUtil.setResourceResolverOn(resourceResolver, query);
    for (final Hit hit : query.getResult().getHits()) {
        try {
            final Resource aceResource = resourceResolver.getResource(hit.getPath());
            final Resource contentResource = aceResource.getParent().getParent();
            if (!paths.contains(contentResource.getPath())) {
                paths.add(contentResource.getPath());
                for (AccessControlPolicy policy : accessControlManager.getPolicies(contentResource.getPath())) {
                    if (policy instanceof JackrabbitAccessControlList) {
                        acls.add((JackrabbitAccessControlList) policy);
                        break;
                    }
                }
            }
        } catch (RepositoryException e) {
            log.error(""Failed to get resource for query result."", e);
        }
    }
    return acls;
}",findAcls,com/adobe/acs/commons/users/impl/EnsureAce.java,/bundle/src/main/java/com/adobe/acs/commons/users/impl/EnsureAce.java,"/**
     * Locates by query all the ACLs that the principal participates in.
     *
     * @param resourceResolver     the resource resolver to perform the user management
     * @param principalName        the principal name
     * @param accessControlManager Jackrabbit access control manager
     * @return a list of ACLs that principal participates in.
     */",225-271,"('findAcls', {'INSTRUCTION': {'covered': 111, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 23, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",270.0,12.0,Locates by query all the ACLs that the principal participates in.,Locates all the ACLs that participates in the principal.,The principal participates in theACLs.,0.595035480238705,Locates by query all access control lists in which the principal participates.,"private List<JackrabbitAccessControlList> findAcls(ResourceResolver resourceResolver, String principalName, JackrabbitAccessControlManager accessControlManager){
        final Session session = resourceResolver.adaptTo(Session.class);
        final String query = String.format(""SELECT * FROM [%s] WHERE [%s] = '%s'"", JCR_ACL, PROP_PRINCIPAL, principalName);
        final QueryManager queryManager = session.getWorkspace().getQueryManager();
        final Query queryObject = queryManager.createQuery(query, Query.JCR_SQL2);
        final QueryResult queryResult = queryObject.execute();
        final NodeIterator nodeIterator = queryResult.getNodes();
        final List<JackrabbitAccessControlList> acls = new ArrayList<JackrabbitAccessControlList>();
        while (nodeIterator.hasNext()) {
            final Node node = nodeIterator.nextNode();
            final JackrabbitAccessControlList acl = (JackrabbitAccessControlList) accessControlManager.getPolicy(node.getPath());
            acls.add(acl);
        }
        return acls;
    }"," private List<JackrabbitAccessControlList> findAcls(ResourceResolver resourceResolver, String principalName, JackrabbitAccessControlManager accessControlManager){
        final List<JackrabbitAccessControlList> acls = new ArrayList<JackrabbitAccessControlList>();
        final Session session = resourceResolver.adaptTo(Session.class);
    
        final String systemUserPath =
                AccessControlUtils.getSystemUserPath(session);
        final String systemUserName =
                AccessControlUtils.getSystemUserName(session);
    
        final String systemUserAclPath =
                AccessControlUtils.getSystemUserAclPath(session);
    
        final JackrabbitAccessControlList systemUserAcl =
                AccessControlUtils.getAccessControlList(session, systemUserAclPath);
    
        final JackrabbitAccessControlEntry[] systemUserAces =
                (JackrabbitAccessControlEntry[]) systemUserAcl.getAccessControlEntries();
    
        for (JackrabbitAccessControlEntry ace : systemUserAces) {
            if (StringUtils.equals(principalName, ace.getPrincipal().getName())) {
                if (StringUtils.equals(systemUserName, ace.getPrincipal().getName())) {
                    // Skip the corner case of ACL's under the system user itself; Do nothing to these.
                } else {
                    acls.add(ace.getAccessControlList());
                }
            }
        }
    
        return acls;
    }"," private List<JackrabbitAccessControlList> findAcls(ResourceResolver resourceResolver, String principalName, JackrabbitAccessControlManager accessControlManager){
        final List<JackrabbitAccessControlList> acls = new ArrayList<JackrabbitAccessControlList>();
        final Session session = resourceResolver.adaptTo(Session.class);
        final JackrabbitAccessControlList[] allAcls =
                (JackrabbitAccessControlList[]) accessControlManager.getApplicablePolicies(session.getRootNode().getPath());
    
        for (JackrabbitAccessControlList acl : allAcls) {
            final JackrabbitAccessControlEntry[] aces = (JackrabbitAccessControlEntry[]) acl.getAccessControlEntries();
    
            for (JackrabbitAccessControlEntry ace : aces) {
                if (StringUtils.equals(principalName, ace.getPrincipal().getName())) {
                    acls.add(acl);
                }
            }
        }
    
        return acls;
    }","private List<JackrabbitAccessControlList> findAcls(ResourceResolver resourceResolver, String principalName, JackrabbitAccessControlManager accessControlManager){
        final Session session = resourceResolver.adaptTo(Session.class);
        final QueryManager queryManager = session.getWorkspace().getQueryManager();
        final Query query = queryManager.createQuery(""SELECT * FROM [nt:base] WHERE [rep:principalName] = $principalName"", Query.JCR_SQL2);
        final QueryResult result = query.execute();
        final NodeIterator nodes = result.getNodes();
        final List<JackrabbitAccessControlList> acls = new ArrayList<JackrabbitAccessControlList>();
        while (nodes.hasNext()) {
            final Node node = nodes.nextNode();
            final JackrabbitAccessControlList acl = (JackrabbitAccessControlList) accessControlManager.getPolicies(node.getPath())[0];
            final Principal principal = acl.getAccessControlEntries()[0].getPrincipal();
            if (StringUtils.equals(principal.getName(), principalName)) {
                acls.add(acl);
            }
        }
        return acls;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.35580137906973136,  0.3498983363996665,  0.37207837615420947,  0.30518564196231707,185.0,0.6826568265682657,176.0,0.6494464944649446,184.0,0.6789667896678967,180.0,0.6642066420664207,110.0,0.6179775280898876,63.0,0.34806629834254144,102.0,0.6335403726708074,6.0,0.5,7.0,0.5384615384615384,10.0,0.8333333333333334
856,cdk,"private void fixNCNTypes(String[] symbs, int[][] graph){
    for (int v = 0; v < graph.length; v++) {
        if (""NCN+"".equals(symbs[v])) {
            boolean foundCNN = false;
            for (int w : graph[v]) {
                foundCNN = foundCNN || ""CNN+"".equals(symbs[w]) || ""CIM+"".equals(symbs[w]);
            }
            if (!foundCNN) {
                symbs[v] = ""NC=N"";
            }
        }
    }
}",fixNCNTypes,org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,"/**
     * Special case, 'NCN+' matches entries that the validation suite say should actually be 'NC=N'.
     * We can achieve 100% compliance by checking if NCN+ is still next to CNN+ or CIM+ after
     * aromatic types are assigned
     *
     * @param symbs symbolic types
     * @param graph adjacency list graph
     */",141-161,"('fixNCNTypes', {'INSTRUCTION': {'covered': 59, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,18.0,"Special case, 'NCN+' matches entries that the validation suite say should actually be 'NC=N'.",Fix a special case in which 'NCN+' matches entries that the validation suite say should actually be 'NC=N',The validation suite say that the entries should be 'NC+'.,0.1272514193519,"In a particular case, 'NCN+' corresponds to the entries which, according to the validation sequence, should actually be 'NC=N'.","private void fixNCNTypes(String[] symbs, int[][] graph){
        for (int i = 0; i < symbs.length; i++) {
            if (symbs[i] == null) continue;
            if (symbs[i].equals(""NCN+"")) {
                for (int j = 0; j < graph[i].length; j++) {
                    if (symbs[graph[i][j]] != null && symbs[graph[i][j]].equals(""CNN+"")) {
                        symbs[i] = ""NC=N"";
                        break;
                    }
                }
            }
        }
    }","private void fixNCNTypes(String[] symbs, int[][] graph){
        for (int i = 0; i < symbs.length; i++) {
            if (symbs[i] == null) continue;
            if (symbs[i].equals(""NCN+"")) {
                for (int j = 0; j < graph[i].length; j++) {
                    if (symbs[graph[i][j]] != null && symbs[graph[i][j]].equals(""CNN+"")) {
                        symbs[i] = ""NC=N"";
                        break;
                    }
                }
            }
        }
    }","private void fixNCNTypes(String[] symbs, int[][] graph){
        for (int i = 0; i < symbs.length; i++) {
            if (symbs[i] == null) continue;
            if (symbs[i].equals(""NCN+"")) {
                if (isNextTo(graph, i, ""CNN+"") || isNextTo(graph, i, ""CIM+"")) {
                    symbs[i] = ""NC=N"";
                }
            }
        }
    }","private void fixNCNTypes(String[] symbs, int[][] graph){
        for (int i = 0; i < symbs.length; i++) {
            if (symbs[i] == null) continue;
            if (symbs[i].equals(""NCN+"")) {
                if (isNextTo(graph, i, ""CNN+"") || isNextTo(graph, i, ""CIM+"")) {
                    symbs[i] = ""NC=N"";
                }
            }
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4968522907319592,  0.48792371930338774,  0.48473856147773786,  0.48473856147773786,64.0,0.512,64.0,0.512,52.0,0.49056603773584906,52.0,0.49056603773584906,0.0,0.0,45.0,0.36,45.0,0.36,7.0,0.3684210526315789,11.0,0.55,10.0,0.6666666666666666
857,cdk,"private boolean isContainedIn(BitSet sourceBitSet, BitSet targetBitSet){
    boolean result = false;
    if (sourceBitSet.isEmpty()) {
        return true;
    }
    BitSet setA = (BitSet) sourceBitSet.clone();
    setA.and(targetBitSet);
    if (setA.equals(sourceBitSet)) {
        result = true;
    }
    return result;
}",isContainedIn,org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,"/**
     *  Test if set sourceBitSet is contained in  set targetBitSet.
     * @param  sourceBitSet  a bitSet
     * @param  targetBitSet  a bitSet
     * @return    true if  sourceBitSet is contained in  targetBitSet
     */",562-583,"('isContainedIn', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,10.0,Test if set sourceBitSet is contained in set targetBitSet.,Check if the set sourceBitSet is contained in the set targetBitSet,"If sourceBitSet is contained in set targetBitSet, you can test it.",0.243493481349462,Test whether set sourceBitSet is contained in set targetBitSet.,"private boolean isContainedIn(BitSet sourceBitSet, BitSet targetBitSet){
        boolean result = true;
        for (int x = sourceBitSet.nextSetBit(0); x >= 0; x = sourceBitSet.nextSetBit(x + 1)) {
            if (!targetBitSet.get(x)) {
                result = false;
                break;
            }
        }
        return result;
    }","private boolean isContainedIn(BitSet sourceBitSet, BitSet targetBitSet){
        boolean result = true;
        for (int x = sourceBitSet.nextSetBit(0); x >= 0; x = sourceBitSet.nextSetBit(x + 1)) {
            if (!targetBitSet.get(x)) {
                result = false;
                break;
            }
        }
        return result;
    }","private boolean isContainedIn(BitSet sourceBitSet, BitSet targetBitSet){
        boolean result = false;
        for (int x = sourceBitSet.nextSetBit(0); x >= 0; x = sourceBitSet.nextSetBit(x + 1)) {
            if (targetBitSet.get(x)) {
                result = true;
                break;
            }
        }
        return result;
    }","private boolean isContainedIn(BitSet sourceBitSet, BitSet targetBitSet){
        boolean result = true;
        for (int x = sourceBitSet.nextSetBit(0); x >= 0; x = sourceBitSet.nextSetBit(x + 1)) {
            if (!targetBitSet.get(x)) {
                result = false;
                break;
            }
        }
        return result;
    }",PASS,PASS,PASS,NOT PASS,  0.5126935150394244,  0.5126935150394244,  0.5126935150394244,  0.5583121134721953,34.0,0.5,34.0,0.5,34.0,0.5,31.0,0.45588235294117646,0.0,0.0,0.0,0.0,3.0,0.04411764705882353,4.0,0.3333333333333333,1.0,0.1,8.0,0.6666666666666666
858,dataverse,"public void applyDisplayInfo(AuthenticatedUserDisplayInfo inf){
    setFirstName(inf.getFirstName());
    setLastName(inf.getLastName());
    if (nonEmpty(inf.getEmailAddress())) {
        setEmail(inf.getEmailAddress());
    }
    if (nonEmpty(inf.getAffiliation())) {
        setAffiliation(inf.getAffiliation());
    }
    if (nonEmpty(inf.getPosition())) {
        setPosition(inf.getPosition());
    }
}",applyDisplayInfo,edu/harvard/iq/dataverse/authorization/users/AuthenticatedUser.java,/src/main/java/edu/harvard/iq/dataverse/authorization/users/AuthenticatedUser.java,"/**
     * Takes the passed info object and updated the internal fields according to it.
     * @param inf the info from which we update the fields.
    */",178-194,"('applyDisplayInfo', {'INSTRUCTION': {'covered': 33, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",93.0,14.0,Takes the passed info object and updated the internal fields according to it.,Update the internal fields according to the passed object values,The internal fields were updated according to the passed info object.,0.340017106162112,Takes the transmitted information object and updates the internal fields based on it.," public void applyDisplayInfo(AuthenticatedUserDisplayInfo inf){
        this.firstName = inf.getFirstName();
        this.lastName = inf.getLastName();
        this.email = inf.getEmail();
        this.affiliation = inf.getAffiliation();
        this.position = inf.getPosition();
    }"," public void applyDisplayInfo(AuthenticatedUserDisplayInfo inf){
        this.firstName = inf.getFirstName();
        this.lastName = inf.getLastName();
        this.email = inf.getEmail();
        this.affiliation = inf.getAffiliation();
        this.position = inf.getPosition();
    }"," public void applyDisplayInfo(AuthenticatedUserDisplayInfo inf){
        this.firstName = inf.getFirstName();
        this.lastName = inf.getLastName();
        this.email = inf.getEmail();
        this.affiliation = inf.getAffiliation();
        this.position = inf.getPosition();
    }"," public void applyDisplayInfo(AuthenticatedUserDisplayInfo inf){
        this.firstName = inf.getFirstName();
        this.lastName = inf.getLastName();
        this.email = inf.getEmail();
        this.affiliation = inf.getAffiliation();
        this.position = inf.getPosition();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.33522355684561966,  0.33522355684561966,  0.33522355684561966,  0.33522355684561966,55.0,0.5851063829787234,55.0,0.5851063829787234,55.0,0.5851063829787234,55.0,0.5851063829787234,0.0,0.0,0.0,0.0,0.0,0.0,11.0,0.7857142857142857,5.0,0.35714285714285715,12.0,0.8571428571428571
859,jackson-databind,"protected JsonToken _initForReading(JsonParser p, JavaType targetType) throws IOException{
    _deserializationConfig.initialize(p);
    JsonToken t = p.currentToken();
    if (t == null) {
        t = p.nextToken();
        if (t == null) {
            throw MismatchedInputException.from(p, targetType, ""No content to map due to end-of-input"");
        }
    }
    return t;
}",_initForReading,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Method called to ensure that given parser is ready for reading
     * content for data binding.
     *
     * @return First token to be used for data binding after this call:
     *  can never be null as exception will be thrown if parser cannot
     *  provide more tokens.
     *
     * @throws IOException if the underlying input source has problems during
     *   parsing
     */",4740-4770,"('_initForReading', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,16.0,Method called to ensure that given parser is ready for reading  content for data binding.,Check if the given parser is ready for reading content for data binding,The method was used to make sure that the given scribal is ready for reading.,0.996743435882625,Method called to ensure that the given parser is ready to read content for data binding.,Not Valid," protected JsonToken _initForReading(JsonParser p, JavaType targetType) throws IOException{
        JsonToken t = p.currentToken();
        if (t == null) {
            t = p.nextToken();
            if (t == null) {
                return null;
            }
        }
        if (t == JsonToken.START_ARRAY) {
            if (targetType.isContainerType()) {
                JavaType contentType = targetType.getContentType();
                if (contentType == null) {
                    throw new IllegalArgumentException(""Can not deserialize List of Untyped Objects"");
                }
                if (contentType.isContainerType()) {
                    throw new IllegalArgumentException(""Can not deserialize List of Lists"");
                }
            }
        } else if (t == JsonToken.START_OBJECT) {
            if (targetType.isContainerType()) {
                JavaType contentType = targetType.getContentType();
                if (contentType == null) {
                    throw new IllegalArgumentException(""Can not deserialize Map of Untyped Objects"");
                }
                if (contentType.isContainerType()) {
                    throw new IllegalArgumentException(""Can not deserialize Map of Maps"");
                }
            }
        }
        return t;
    }","protected JsonToken _initForReading(JsonParser p, JavaType targetType) throws IOException{
        JsonToken t = p.currentToken();
        if (t == null) {
            t = p.nextToken();
            if (t == null) {
                return null;
            }
        }
        if (targetType != null) {
            if (t == JsonToken.START_OBJECT) {
                // [databind#631]: need to check for empty object
                JsonToken t2 = p.nextToken();
                if (t2 == JsonToken.END_OBJECT) {
                    // Empty object; need to return null
                    return null;
                }
                if (t2 == null) {
                    return null;
                }
                // And then need to check that first token is what we need
                if (t2 != JsonToken.FIELD_NAME) {
                    // [databind#631]: need to allow for empty object
                    if (t2 == JsonToken.END_OBJECT) {
                        return null;
                    }
                    throw new JsonMappingException(""Can not deserialize a ""+targetType+"" from non-null JSON Object (token ""+t2+"")"");
                }
            }
        }
        return t;
    }","protected JsonToken _initForReading(JsonParser p, JavaType targetType) throws IOException{
        JsonToken t = p.currentToken();
        if (t == null) {
            t = p.nextToken();
            if (t == null) {
                return null;
            }
        }
        if (targetType != null) {
            if (t == JsonToken.START_OBJECT) {
                // [databind#631]: need to check for empty object
                t = p.nextToken();
                if (t == JsonToken.END_OBJECT) {
                    // Empty object; need to return null
                    return null;
                }
                p.skipChildren();
                t = p.nextToken();
            }
            if (t == JsonToken.START_ARRAY) {
                // [databind#631]: need to check for empty array
                t = p.nextToken();
                if (t == JsonToken.END_ARRAY) {
                    // Empty array; need to return null
                    return null;
                }
                p.skipChildren();
                t = p.nextToken();
            }
        }
        return t;
    }",Not Valid,NOT PASS,NOT PASS,NOT PASS,None,  0.6061345517937237,  0.6579703368511304,  0.6409550740075959,None,None,122.0,0.6892655367231638,94.0,0.618421052631579,87.0,0.6083916083916084,176.0,0.9943502824858758,151.0,0.993421052631579,142.0,0.993006993006993,6.0,0.375,3.0,0.17647058823529413,13.0,0.8125
860,cdk,"public void addCDKChangeListener(ICDKChangeListener listener){
    if (listeners == null) {
        listeners = new ArrayList<ICDKChangeListener>();
    }
    if (!listeners.contains(listener)) {
        listeners.add(listener);
    }
}",addCDKChangeListener,org/openscience/cdk/renderer/RendererModel.java,/display/render/src/main/java/org/openscience/cdk/renderer/RendererModel.java,"/**
     * Adds a change listener to the list of listeners.
     *
     * @param listener
     *            The listener added to the list
     */",379-392,"('addCDKChangeListener', {'INSTRUCTION': {'covered': 14, 'missed': 5}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,10.0,Adds a change listener to the list of listeners.,This method appends a change listener to the list of listeners,A change listener is added to the list.,0.430362730176571,Adds a change listener to the list of listeners.," public void addCDKChangeListener(ICDKChangeListener listener){
        changeListeners.add(listener);      
 }"," public void addCDKChangeListener(ICDKChangeListener listener){
        changeListeners.add(listener);      
 }"," public void addCDKChangeListener(ICDKChangeListener listener){
        if(!listeners.contains(listener)){
            listeners.add(listener);
        }       
 }"," public void addCDKChangeListener(ICDKChangeListener listener){
        changeListeners.add(listener);      
 }",NOT PASS,NOT PASS,NOT PASS,PASS,  0.27222229001056886,  0.27222229001056886,  0.27222229001056886,  0.5411215679045605,31.0,0.6595744680851063,31.0,0.6595744680851063,31.0,0.6595744680851063,18.0,0.3829787234042553,0.0,0.0,0.0,0.0,13.0,0.4482758620689655,4.0,0.3333333333333333,0.0,0.0,7.0,0.7
861,acs-aem-commons,"public static V doWithTccl(ClassLoader classLoader, Callable<V> task) throws Exception{
    ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
    Thread.currentThread().setContextClassLoader(classLoader);
    try {
        return task.call();
    } finally {
        Thread.currentThread().setContextClassLoader(oldClassLoader);
    }
}",doWithTccl,com/adobe/acs/commons/util/ThreadContextClassLoaderTaskExecutor.java,/bundle/src/main/java/com/adobe/acs/commons/util/ThreadContextClassLoaderTaskExecutor.java,"/**
     * Execute the task while the Thread Context Class Loader is set to the provided
     * Class Loader.
     * 
     * @param classLoader the requested class loader
     * @param task the task
     * @param <V> the return type of the task
     * @return the return value
     * @throws Exception the exception throw, if any, by the task
     */",35-53,"('doWithTccl', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,17.0,Execute the task while the Thread Context Class Loader is set to the provided  Class Loader.,This method executes the task while the Thread Context Class Loader is set to the provided Class Loader,The Thread Context Class Loader is set to execute the task.,0.306690775590389,Run the task when thread context class Loader is set to the supplied Class Loader.," public static V doWithTccl(ClassLoader classLoader, Callable<V> task) throws Exception{
      ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
      Thread.currentThread().setContextClassLoader(classLoader);
      try {
          return task.call();
      } finally {
          Thread.currentThread().setContextClassLoader(oldClassLoader);
      }
  } "," public static V doWithTccl(ClassLoader classLoader, Callable<V> task) throws Exception{
      ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
      Thread.currentThread().setContextClassLoader(classLoader);
      try {
          return task.call();
      } finally {
          Thread.currentThread().setContextClassLoader(oldClassLoader);
      }
  } "," public static V doWithTccl(ClassLoader classLoader, Callable<V> task) throws Exception{
      ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
      try {
          Thread.currentThread().setContextClassLoader(classLoader);
          return task.call();
      } finally {
          Thread.currentThread().setContextClassLoader(oldClassLoader);
      }
  } "," public static V doWithTccl(ClassLoader classLoader, Callable<V> task) throws Exception{
      ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
      try {
          Thread.currentThread().setContextClassLoader(classLoader);
          return task.call();
      } finally {
          Thread.currentThread().setContextClassLoader(oldClassLoader);
      }
  } ",PASS,PASS,NOT PASS,NOT PASS,  1.0,  1.0,  0.9445916725899133,  0.9445916725899133,0.0,0.0,0.0,0.0,4.0,0.05970149253731343,4.0,0.05970149253731343,0.0,0.0,4.0,0.05970149253731343,4.0,0.05970149253731343,4.0,0.21052631578947367,7.0,0.4117647058823529,9.0,0.5294117647058824
862,weblogic-kubernetes-operator,"static void addPatches(JsonPatchBuilder patchBuilder, String basePath, Map<String, String> current, Map<String, String> required){
    for (String name : required.keySet()) {
        String encodedPath = basePath + name.replace(""~"", ""~0"").replace(""/"", ""~1"");
        if (!current.containsKey(name)) {
            patchBuilder.add(encodedPath, required.get(name));
        } else {
            patchBuilder.replace(encodedPath, required.get(name));
        }
    }
}",addPatches,oracle/kubernetes/operator/helpers/KubernetesUtils.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/KubernetesUtils.java,"/**
   * Adds patches to the specified patch builder to correct differences in the current vs required
   * maps.
   *
   * @param patchBuilder a builder for the patches
   * @param basePath     the base for the patch path (excluding the name)
   * @param current      a map of the values found in a Kubernetes resource
   * @param required     a map of the values specified for the resource by the domain
   */",65-91,"('addPatches', {'INSTRUCTION': {'covered': 44, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,17.0,Adds patches to the specified patch builder to correct differences in the current vs required  maps.,This method adds the patches to the specified patch builder to correct differences in the current vs required maps,Patching is done to correct differences in the current vs required maps.,0.380973896617421,Adds patches to the specified patch builder to correct differences between current and required adapters.," static void addPatches(JsonPatchBuilder patchBuilder, String basePath, Map<String, String> current, Map<String, String> required){
    for (String name : required.keySet()) {
      String currentValue = current.get(name);
      String requiredValue = required.get(name);
      if (!Objects.equals(currentValue, requiredValue)) {
        patchBuilder.replace(basePath + ""/"" + name, requiredValue);
      }
    }
  }"," static void addPatches(JsonPatchBuilder patchBuilder, String basePath, Map<String, String> current, Map<String, String> required){
    for (String name : required.keySet()) {
      String currentValue = current.get(name);
      String requiredValue = required.get(name);
      if (!Objects.equals(currentValue, requiredValue)) {
        patchBuilder.replace(basePath + ""/"" + name, requiredValue);
      }
    }
  }"," static void addPatches(JsonPatchBuilder patchBuilder, String basePath, Map<String, String> current, Map<String, String> required){
    for (String name : required.keySet()) {
      if (!current.containsKey(name)) {
        patchBuilder.add(basePath + ""/"" + name, required.get(name));
      }
    }
  }"," static void addPatches(JsonPatchBuilder patchBuilder, String basePath, Map<String, String> current, Map<String, String> required){
    for (String name : required.keySet()) {
      if (!Objects.equals(current.get(name), required.get(name))) {
        patchBuilder.replace(basePath + ""/"" + name, required.get(name));
      }
    }
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5552991993088365,  0.5472346831798043,  0.5606844195191121,  0.5475796084389724,43.0,0.4056603773584906,43.0,0.4056603773584906,37.0,0.3490566037735849,38.0,0.3584905660377358,0.0,0.0,27.0,0.30337078651685395,32.0,0.3595505617977528,5.0,0.25,4.0,0.23529411764705882,7.0,0.4117647058823529
863,cdk,"public Partition splitAfter(int cellIndex, int splitElement){
    Partition r = new Partition();
    for (int j = 0; j < cellIndex; j++) {
        r.addCell(this.copyBlock(j));
    }
    SortedSet<Integer> splitBlock = this.copyBlock(cellIndex);
    splitBlock.remove(splitElement);
    r.addCell(splitBlock);
    r.addSingletonCell(splitElement);
    for (int j = cellIndex + 1; j < this.size(); j++) {
        r.addCell(this.copyBlock(j));
    }
    return r;
}",splitAfter,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,"/**
     * Splits this partition by taking the cell at cellIndex and making two
     * new cells - the first with the the rest of the elements from that cell
     * and the second with the singleton splitElement.
     *
     * @param cellIndex the index of the cell to split on
     * @param splitElement the element to put in its own cell
     * @return a new (finer) Partition
     */",242-269,"('splitAfter', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",119.0,35.0,Splits this partition by taking the cell at cellIndex and making two  new cells - the first with the the rest of the elements from that cell  and the second with the singleton splitElement.,This method splits the given partition by taking the cell at cellIndex and making two new cells,The first cell with the rest of the elements from that cell and the second with the singleton splitElement is split.,0.322982723963472,Divides this partition by taking the cell to cellIndex and creating two new cells - the first with the rest of the elements of this cell and the second with the singleton splitElement.,"public Partition splitAfter(int cellIndex, int splitElement){
        Partition r = new Partition();
        // copy the cells up to cellIndex
        for (int j = 0; j < cellIndex; j++) {
            r.addCell(this.copyBlock(j));
        }
    
        // split the block at block index
        SortedSet<Integer> splitBlock = this.copyBlock(cellIndex);
        splitBlock.remove(splitElement);
        r.addCell(splitBlock);
        r.addSingletonCell(splitElement);
    
        // copy the blocks after blockIndex, shuffled up by one
        for (int j = cellIndex + 1; j < this.size(); j++) {
            r.addCell(this.copyBlock(j));
        }
        return r;
    }","public Partition splitAfter(int cellIndex, int splitElement){
        Partition r = new Partition();
        // copy the cells up to cellIndex
        for (int j = 0; j < cellIndex; j++) {
            r.addCell(this.copyBlock(j));
        }
    
        // split the block at block index
        SortedSet<Integer> splitBlock = this.copyBlock(cellIndex);
        splitBlock.remove(splitElement);
        r.addCell(splitBlock);
        r.addSingletonCell(splitElement);
    
        // copy the blocks after blockIndex, shuffled up by one
        for (int j = cellIndex + 1; j < this.size(); j++) {
            r.addCell(this.copyBlock(j));
        }
        return r;
    }",Empty Method,"public Partition splitAfter(int cellIndex, int splitElement){
        Partition r = new Partition();
        // copy the cells up to cellIndex
        for (int j = 0; j < cellIndex; j++) {
            r.addCell(this.copyBlock(j));
        }
    
        // split the block at block index
        SortedSet<Integer> splitBlock = this.copyBlock(cellIndex);
        splitBlock.remove(splitElement);
        r.addCell(splitBlock);
        r.addSingletonCell(splitElement);
    
        // copy the blocks after blockIndex, shuffled up by one
        for (int j = cellIndex + 1; j < this.size(); j++) {
            r.addCell(this.copyBlock(j));
        }
        return r;
    }",PASS,PASS,PASS,Empty Method,  1.0,  1.0,  1.0,None,0.0,0.0,0.0,0.0,0.0,0.0,None,None,0.0,0.0,0.0,0.0,None,None,25.0,0.7142857142857143,6.0,0.17142857142857143,20.0,0.5714285714285714
864,cdk,"private static IAtom findOtherSinglyBonded(IAtomContainer container, IAtom atom, IAtom exclude){
    for (final IBond bond : container.getConnectedBondsList(atom)) {
        if (!IBond.Order.SINGLE.equals(bond.getOrder()) || bond.contains(exclude))
            continue;
        return bond.getOther(atom);
    }
    return atom;
}",findOtherSinglyBonded,org/openscience/cdk/inchi/InChIToStructure.java,/storage/inchi/src/main/java/org/openscience/cdk/inchi/InChIToStructure.java,"/**
     * Finds a neighbor attached to 'atom' that is singley bonded and isn't
     * 'exclude'. If no such atom exists, the 'atom' is returned.
     *
     * @param container a molecule container
     * @param atom      the atom to find the neighbor or
     * @param exclude   don't find this atom
     * @return the other atom (or 'atom')
     */",400-415,"('findOtherSinglyBonded', {'INSTRUCTION': {'covered': 25, 'missed': 3}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,17.0,Finds a neighbor attached to 'atom' that is singley bonded and isn't  'exclude'.,Gets a neighbor attached to 'atom' that is singley bonded and is not excluded,A neighbor is attached to 'atom' and not 'exclude'.,0.603202269618759,"Find a neighbor attached to ""atom"" that is bound to one and is not ""excluded""."," private static IAtom findOtherSinglyBonded(IAtomContainer container, IAtom atom, IAtom exclude){
        for (IAtom neighbor : container.getConnectedAtoms(atom)) {
            if (container.getBond(atom, neighbor).getOrder() == IBond.Order.SINGLE
                    && !neighbor.equals(exclude)) {
                return neighbor;
            }
        }
        return null;
    }"," private static IAtom findOtherSinglyBonded(IAtomContainer container, IAtom atom, IAtom exclude){
        for (IAtom neighbor : container.getConnectedAtoms(atom)) {
            if (neighbor.equals(exclude))
                continue;
            if (container.getBond(atom, neighbor).getOrder() == IBond.Order.SINGLE)
                return neighbor;
        }
        return null;
    }"," private static IAtom findOtherSinglyBonded(IAtomContainer container, IAtom atom, IAtom exclude){
        for (IAtom neighbor : container.getConnectedAtomsList(atom)) {
            if (neighbor.equals(exclude))
                continue;
            if (container.getBond(atom, neighbor) != null)
                continue;
            return neighbor;
        }
        return null;
    }"," private static IAtom findOtherSinglyBonded(IAtomContainer container, IAtom atom, IAtom exclude){
        for (IAtom neighbor : container.getConnectedAtomsList(atom)) {
            if (container.getBond(atom, neighbor) != null &&
                    container.getBond(atom, neighbor).getOrder() == IBond.Order.SINGLE &&
                    !neighbor.equals(exclude))
                return neighbor;
        }
        return null;
    }",NOT PASS,NOT PASS,PASS,NOT PASS,  0.625878036256991,  0.6412103642198523,  0.6197624737942702,  0.5467070192766205,33.0,0.4714285714285714,32.0,0.45714285714285713,38.0,0.4935064935064935,31.0,0.44285714285714284,21.0,0.30434782608695654,14.0,0.18181818181818182,24.0,0.35294117647058826,4.0,0.26666666666666666,8.0,0.5,8.0,0.5714285714285714
865,matsim-libs,"public static FixedBordersDiscretizer create(double[] samples, int size){
    TDoubleArrayList borders;
    double min = Double.MAX_VALUE;
    double max = -Double.MAX_VALUE;
    TDoubleIntHashMap hist = new TDoubleIntHashMap(samples.length);
    for (int i = 0; i < samples.length; i++) {
        hist.adjustOrPutValue(samples[i], 1, 1);
        min = Math.min(min, samples[i]);
        max = Math.max(max, samples[i]);
    }
    double[] keys = hist.keys();
    Arrays.sort(keys);
    borders = new TDoubleArrayList(keys.length);
    borders.add(min - 1E-10);
    int binsize = 0;
    int n = 0;
    for (int i = 0; i < keys.length; i++) {
        int nBin = hist.get(keys[i]);
        binsize += nBin;
        n += nBin;
        if (binsize >= size && i > 0) {
            // sufficient samples for the
            // current bin
            if (samples.length - n >= binsize) {
                // sufficient remaining
                // samples to fill the
                // next bin
                borders.add(keys[i]);
                binsize = 0;
            }
        }
    }
    if (binsize > 0)
        borders.add(max);
    return new FixedBordersDiscretizer(borders.toArray());
}",create,org/matsim/contrib/common/stats/FixedSampleSizeDiscretizer.java,/contribs/common/src/main/java/org/matsim/contrib/common/stats/FixedSampleSizeDiscretizer.java,"/**
         * Creates a new discretizer with bin borders defined such that each bin
         * would contain approximately <tt>size</tt> samples from <tt>samples</tt>.
         * 
         * Samples are sorted into bins in ascending order. If there are not
         * sufficient (less than <tt>size</tt>) samples to fill a further bin, the
         * remaining samples are sorted into the last bin. That is, the last bin is
         * the only bin that may contain more than <tt>size</tt> samples.
         * 
         * @param samples
         *            an array with samples.
         * @param size
         *            the number of samples per bin.
         * @return a new discretizer.
         */",37-92,"('create', {'INSTRUCTION': {'covered': 112, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",252.0,32.0,Creates a new discretizer with bin borders defined such that each bin  would contain approximately <tt>size</tt> samples from <tt>samples</tt>.,Creates a new discretizer with bin borders defined such that each bin would contain approximately the size samples from the given samples,A new discretizer is created with bin borders that allow for the size of the samples in each bin to be determined.,0.570409461821323,Creates a new discretizer with tray borders defined so that each tray contains approximate <tt>sample sizes</tt> <tt>from samples</tt>.,Not Valid,"public static FixedBordersDiscretizer create(double[] samples, int size){
    TDoubleArrayList borders = new TDoubleArrayList();
    TDoubleIntHashMap counts = new TDoubleIntHashMap();
    
    borders.add(Double.NEGATIVE_INFINITY);
    
    for(double sample : samples){
      if(!counts.containsKey(sample))
        counts.put(sample, 1);
      else
        counts.put(sample, counts.get(sample)+1);
    }
    
    double[] sortedSamples = counts.keys();
    Arrays.sort(sortedSamples);
    
    int total = 0;
    for(double sample : sortedSamples){
      total += counts.get(sample);
      if(total >= size){
        borders.add(sample);
        total = 0;
      }
    }
    
    borders.add(Double.POSITIVE_INFINITY);
    
    return new FixedBordersDiscretizer(borders.toArray());    
 }","public static FixedBordersDiscretizer create(double[] samples, int size){
    TDoubleArrayList borders = new TDoubleArrayList();
    borders.add(Double.NEGATIVE_INFINITY);
    borders.add(Double.POSITIVE_INFINITY);
    TDoubleIntHashMap counts = new TDoubleIntHashMap();
    counts.put(Double.NEGATIVE_INFINITY, 0);
    counts.put(Double.POSITIVE_INFINITY, 0);
    for(double sample : samples){
      if(counts.containsKey(sample))
        counts.put(sample, counts.get(sample)+1);
      else
        counts.put(sample, 1);
    }
    double[] sorted = counts.keys(new double[counts.size()]);
    Arrays.sort(sorted);
    int i = 0;
    while(borders.size() < size){
      borders.add(sorted[i]);
      i++;
    }
    return new FixedBordersDiscretizer(borders.toArray());    
 }"," public static FixedBordersDiscretizer create(double[] samples, int size){
    TDoubleArrayList borders = new TDoubleArrayList();
    borders.add(Double.NEGATIVE_INFINITY);
    borders.addAll(Arrays.asList(StatUtils.rank(samples, size)));
    borders.add(Double.POSITIVE_INFINITY);
    return new FixedBordersDiscretizer(borders.toArray());    
 }",Not Valid,NOT PASS,NOT PASS,NOT PASS,None,  0.3419637133248747,  0.15786078346419602,  0.36158219118411733,None,None,152.0,0.6007905138339921,196.0,0.7747035573122529,170.0,0.6719367588932806,165.0,0.9939759036144579,71.0,0.9861111111111112,183.0,0.9945652173913043,5.0,0.21739130434782608,10.0,0.5,18.0,0.782608695652174
866,cdk,"private void readPartialCharges(IChemModel model) throws CDKException, IOException{
    logger.info(""Reading partial atomic charges"");
    IAtomContainerSet moleculeSet = model.getMoleculeSet();
    IAtomContainer molecule = moleculeSet.getAtomContainer(0);
    String line = input.readLine();
    while (input.ready()) {
        line = input.readLine();
        logger.debug(""Read charge block line: "" + line);
        if ((line == null) || (line.indexOf(""Sum of Mulliken charges"") >= 0)) {
            logger.debug(""End of charge block found"");
            break;
        }
        StringReader sr = new StringReader(line);
        StreamTokenizer tokenizer = new StreamTokenizer(sr);
        if (tokenizer.nextToken() == StreamTokenizer.TT_NUMBER) {
            int atomCounter = (int) tokenizer.nval;
            tokenizer.nextToken();
            double charge;
            if (tokenizer.nextToken() == StreamTokenizer.TT_NUMBER) {
                charge = tokenizer.nval;
                logger.debug(""Found charge for atom "" + atomCounter + "": "" + charge);
            } else {
                throw new CDKException(""Error while reading charge: expected double."");
            }
            IAtom atom = molecule.getAtom(atomCounter - 1);
            atom.setCharge(charge);
        }
    }
}",readPartialCharges,org/openscience/cdk/io/Gaussian98Reader.java,/storage/io/src/main/java/org/openscience/cdk/io/Gaussian98Reader.java,"/**
     * Reads partial atomic charges and add the to the given ChemModel.
     *
     * @param model Description of the Parameter
     * @throws CDKException Description of the Exception
     * @throws IOException  Description of the Exception
     */",332-371,"('readPartialCharges', {'INSTRUCTION': {'covered': 97, 'missed': 5}, 'BRANCH': {'covered': 6, 'missed': 4}, 'LINE': {'covered': 22, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",218.0,12.0,Reads partial atomic charges and add the to the given ChemModel.,This method reads the partial atomic charges and add the them to the given model,Add the ChemModel to the partial atomic charges read.,0.264426528064113,Reads the partial atomic charges and adds them to the given ChemModel.,"private void readPartialCharges(IChemModel model) throws CDKException, IOException{
        String line = input.readLine();
        while (input.ready() && (line != null)) {
            if (line.indexOf(""Total atomic charges"") >= 0) {
                break;
            }
            line = input.readLine();
        }
        if (line == null) {
            return;
        }
        line = input.readLine();
        while (input.ready() && (line != null)) {
            if (line.indexOf(""-----"") >= 0) {
                break;
            }
            int atomicNumber;
            StringReader sr = new StringReader(line);
            StreamTokenizer token = new StreamTokenizer(sr);
            token.nextToken();
    
            // ignore first token
            if (token.nextToken() == StreamTokenizer.TT_NUMBER) {
                atomicNumber = (int) token.nval;
            } else {
                throw new CDKException(""Error while reading partial charges: expected integer."");
            }
            token.nextToken();
    
            // ignore third token
            double charge;
            if (token.nextToken() == StreamTokenizer.TT_NUMBER) {
                charge = token.nval;
            } else {
                throw new IOException(""Error reading partial charge"");
            }
            String symbol = PeriodicTable.getSymbol(atomicNumber);
            IAtom atom = model.getBuilder().newInstance(IAtom.class, symbol);
            atom.setCharge(charge);
            model.getBuilder().add(model.getMoleculeSet(), atom);
            line = input.readLine();
        }       
 }","private void readPartialCharges(IChemModel model) throws CDKException, IOException{
        String line = input.readLine();
        while (input.ready() && (line != null)) {
            if (line.indexOf(""Total atomic charges"") >= 0) {
                break;
            }
            line = input.readLine();
        }
        if (line == null) {
            return;
        }
        line = input.readLine();
        while (input.ready() && (line != null)) {
            if (line.indexOf(""-----"") >= 0) {
                break;
            }
            int atomicNumber;
            StringReader sr = new StringReader(line);
            StreamTokenizer token = new StreamTokenizer(sr);
            token.nextToken();
    
            // ignore first token
            if (token.nextToken() == StreamTokenizer.TT_NUMBER) {
                atomicNumber = (int) token.nval;
                if (atomicNumber == 0) {
    
                    // Skip dummy atoms. Dummy atoms must be skipped
                    // if frequencies are to be read because Gaussian
                    // does not report dummy atoms in frequencies, and
                    // the number of atoms is used for reading frequencies.
                    continue;
                }
            } else {
                throw new CDKException(""Error while reading coordinates: expected integer."");
            }
            token.nextToken();
    
            // ignore third token
            double partialCharge;
            if (token.nextToken() == StreamTokenizer.TT_NUMBER) {
                partialCharge = token.nval;
            } else {
                throw new IOException(""Error reading x coordinate"");
            }
            String symbol = ""Du"";
            symbol = PeriodicTable.getSymbol(atomicNumber);
            IAtom atom = model.getBuilder().newInstance(IAtom.class, symbol);
            atom.setProperty(CDKConstants.PARTIAL_CHARGE, partialCharge);
            model.getMoleculeSet().getAtomContainer(0).addAtom(atom);
            line = input.readLine();
        }       
 }",Empty Method,Empty Method,NOT PASS,NOT PASS,Empty Method,Empty Method,  0.5307678302806145,  0.5109726739732837,None,None,144.0,0.5333333333333333,164.0,0.5714285714285714,None,None,None,None,31.0,0.10801393728222997,None,None,None,None,6.0,0.375,3.0,0.23076923076923078,10.0,0.8333333333333334
867,cdk,"public static ILigand[] order(ILigand[] ligands){
    ILigand[] newLigands = new ILigand[ligands.length];
    System.arraycopy(ligands, 0, newLigands, 0, ligands.length);
    Arrays.sort(newLigands, cipRule);
    return newLigands;
}",order,org/openscience/cdk/geometry/cip/CIPTool.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/CIPTool.java,"/**
     * Reorders the {@link ILigand} objects in the array according to the CIP rules.
     *
     * @param ligands Array of {@link ILigand}s to be reordered.
     * @return        Reordered array of {@link ILigand}s.
     */",235-247,"('order', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",56.0,17.0,Reorders the {@link ILigand} objects in the array according to the CIP rules.,Reorder the given object according to the CIP rules,The @link ILigand objects should be ordered according to the rules.,1.04138019028815,Rearranges the {@link ILigand} objects in the array according to CIP rules.," public static ILigand[] order(ILigand[] ligands){
        Arrays.sort(ligands, cipRule);
        return ligands;
    }"," public static ILigand[] order(ILigand[] ligands){
        Arrays.sort(ligands, cipRule);
        return ligands;
    }"," public static ILigand[] order(ILigand[] ligands){
        Arrays.sort(ligands, cipRule);
        return ligands;
    }"," public static ILigand[] order(ILigand[] ligands){
        Arrays.sort(ligands, cipRule);
        return ligands;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.36641280683555755,  0.36641280683555755,  0.36641280683555755,  0.36641280683555755,32.0,0.5614035087719298,32.0,0.5614035087719298,32.0,0.5614035087719298,32.0,0.5614035087719298,0.0,0.0,0.0,0.0,0.0,0.0,8.0,0.5714285714285714,2.0,0.14285714285714285,8.0,0.5714285714285714
868,lettuce-core,"protected ConnectionFuture<T> initializeChannelAsync(ConnectionBuilder connectionBuilder){
    Mono<SocketAddress> socketAddressSupplier = connectionBuilder.socketAddress();
    if (clientResources.eventExecutorGroup().isShuttingDown()) {
        throw new IllegalStateException(""Cannot connect, Event executor group is terminated."");
    }
    CompletableFuture<SocketAddress> socketAddressFuture = new CompletableFuture<>();
    CompletableFuture<Channel> channelReadyFuture = new CompletableFuture<>();
    socketAddressSupplier.doOnError(socketAddressFuture::completeExceptionally).doOnNext(socketAddressFuture::complete).subscribe(redisAddress -> {
        if (channelReadyFuture.isCancelled()) {
            return;
        }
        initializeChannelAsync0(connectionBuilder, channelReadyFuture, redisAddress);
    }, channelReadyFuture::completeExceptionally);
    return new DefaultConnectionFuture<>(socketAddressFuture, channelReadyFuture.thenApply(channel -> (T) connectionBuilder.connection()));
}",initializeChannelAsync,io/lettuce/core/AbstractRedisClient.java,/src/main/java/io/lettuce/core/AbstractRedisClient.java,"/**
     * Connect and initialize a channel from {@link ConnectionBuilder}.
     *
     * @param connectionBuilder must not be {@code null}.
     * @return the {@link ConnectionFuture} to synchronize the connection process.
     * @since 4.4
     */",346-377,"('initializeChannelAsync', {'INSTRUCTION': {'covered': 49, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",145.0,12.0,Connect and initialize a channel from {@link ConnectionBuilder}.,This method connects and initializes a channel from the passed parameter,You can connect and create a channel from @link ConnectionBuilder.,1.23840411699481,Connect and initialize a channel from {@link ConnectionBuilder}.," protected ConnectionFuture<T> initializeChannelAsync(ConnectionBuilder connectionBuilder){
        return connectionBuilder.initializeChannelAsync();
    }"," protected ConnectionFuture<T> initializeChannelAsync(ConnectionBuilder connectionBuilder){
        return connectionBuilder.initializeChannelAsync();
    }"," protected ConnectionFuture<T> initializeChannelAsync(ConnectionBuilder connectionBuilder){
        return connectionBuilder.initializeChannelAsync();      
 }"," protected ConnectionFuture<T> initializeChannelAsync(ConnectionBuilder connectionBuilder){
        return connectionBuilder.initializeAsync();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.14065960466601413,  0.14065960466601413,  0.12929596830237777,  0.14065960466601413,127.0,0.8698630136986302,127.0,0.8698630136986302,127.0,0.8698630136986302,127.0,0.8698630136986302,0.0,0.0,1.0,0.05,0.0,0.0,7.0,0.5833333333333334,0.0,0.0,6.0,0.5454545454545454
869,cdk,"private List<Integer> tryDoubleBondCombinations(IAtomContainer container, int dblBondsAdded, int bondOffSet, int doubleBondMax, List<IAtom> atomsInNeedOfFix){
    int offSet = bondOffSet;
    List<Integer> dblBondPositions = null;
    while (offSet < container.getBondCount() && dblBondPositions == null) {
        IBond bond = container.getBond(offSet);
        if (atomsInNeedOfFix.contains(bond.getBegin()) && atomsInNeedOfFix.contains(bond.getEnd())) {
            bond.setOrder(IBond.Order.DOUBLE);
            dblBondsAdded = dblBondsAdded + 1;
            if (dblBondsAdded == doubleBondMax) {
                boolean validDoubleBondConfig = true;
                CHECK: for (IAtom atom : container.atoms()) {
                    if (atom.getValency() != atom.getImplicitHydrogenCount() + getConnectivity(atom, container)) {
                        validDoubleBondConfig = false;
                        break CHECK;
                    }
                }
                if (validDoubleBondConfig) {
                    dblBondPositions = new ArrayList<Integer>();
                    for (int idx = 0; idx < container.getBondCount(); idx++) {
                        if (container.getBond(idx).getOrder().equals(IBond.Order.DOUBLE))
                            dblBondPositions.add(idx);
                    }
                    return dblBondPositions;
                }
            } else {
                dblBondPositions = tryDoubleBondCombinations(container, dblBondsAdded, offSet + 1, doubleBondMax, atomsInNeedOfFix);
            }
            bond.setOrder(IBond.Order.SINGLE);
            dblBondsAdded = dblBondsAdded - 1;
        }
        offSet++;
    }
    return dblBondPositions;
}",tryDoubleBondCombinations,org/openscience/cdk/tautomers/InChITautomerGenerator.java,/tool/tautomer/src/main/java/org/openscience/cdk/tautomers/InChITautomerGenerator.java,"/**
     * Tries double bond combinations for a certain input container of which the double bonds have been stripped
     * around the mobile hydrogen positions. Recursively.
     *
     * @param container
     * @param dblBondsAdded counts double bonds added so far
     * @param bondOffSet offset for next double bond position to consider
     * @param doubleBondMax maximum number of double bonds to add
     * @param atomsInNeedOfFix atoms that require more bonds
     * @return a list of double bond positions (index) that make a valid combination, null if none found
     */",639-688,"('tryDoubleBondCombinations', {'INSTRUCTION': {'covered': 113, 'missed': 0}, 'BRANCH': {'covered': 20, 'missed': 0}, 'LINE': {'covered': 27, 'missed': 0}, 'COMPLEXITY': {'covered': 11, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",278.0,23.0,Tries double bond combinations for a certain input container of which the double bonds have been stripped  around the mobile hydrogen positions.,This method recursively tries double bond combinations for a certain input container of which the double bonds have been stripped around the mobile hydrogen positions,Double bonds have been stripped around the mobile hydrogen positions for a certain input container of tries double bond combinations.,0.625384318017966,Try double bond combinations for a certain inlet vessel whose double bonds have been stripped around the mobile positions of hydrogen.,"private List<Integer> tryDoubleBondCombinations(IAtomContainer container, int dblBondsAdded, int bondOffSet, int doubleBondMax, List<IAtom> atomsInNeedOfFix){
            List<Integer> dblBondPositions = new ArrayList<Integer>();
            for (int i = 0; i < atomsInNeedOfFix.size(); i++) {
                IAtom atom = atomsInNeedOfFix.get(i);
                int conn = getConnectivity(atom, container);
                if (conn == 1) {
                    dblBondPositions.add(bondOffSet + i);
                }
            }
            if (dblBondPositions.size() == 0) {
                return dblBondPositions;
            } else {
                List<Integer> dblBondPositions2 = new ArrayList<Integer>();
                for (int i = 0; i < dblBondPositions.size(); i++) {
                    int pos = dblBondPositions.get(i);
                    if (pos + dblBondsAdded < doubleBondMax) {
                        dblBondPositions2.add(pos + dblBondsAdded);
                    }
                }
                return dblBondPositions2;
            }
        }","private List<Integer> tryDoubleBondCombinations(IAtomContainer container, int dblBondsAdded, int bondOffSet, int doubleBondMax, List<IAtom> atomsInNeedOfFix){
        List<Integer> dblBondPositions = new ArrayList<Integer>();
        if (dblBondsAdded == doubleBondMax) {
            return dblBondPositions;
        } else {
            for (int i = bondOffSet; i < container.getBondCount(); i++) {
                IBond bond = container.getBond(i);
                if (bond.getOrder() == IBond.Order.DOUBLE) {
                    IAtom atom1 = bond.getAtom(0);
                    IAtom atom2 = bond.getAtom(1);
                    if (atomsInNeedOfFix.contains(atom1) || atomsInNeedOfFix.contains(atom2)) {
                        dblBondPositions.add(i);
                        dblBondPositions.add(i);
                        dblBondsAdded++;
                        atomsInNeedOfFix.remove(atom1);
                        atomsInNeedOfFix.remove(atom2);
                        dblBondPositions.addAll(tryDoubleBondCombinations(container, dblBondsAdded, i + 1, doubleBondMax, atomsInNeedOfFix));
                        dblBondPositions.remove(dblBondPositions.size() - 1);
                        dblBondPositions.remove(dblBondPositions.size() - 1);
                        dblBondsAdded--;
                        atomsInNeedOfFix.add(atom1);
                        atomsInNeedOfFix.add(atom2);
                    }
                }
            }
            return dblBondPositions;
        }       
 }","private List<Integer> tryDoubleBondCombinations(IAtomContainer container, int dblBondsAdded, int bondOffSet, int doubleBondMax, List<IAtom> atomsInNeedOfFix){
            List<Integer> dblBondPositions = new ArrayList<>();
            for (int i = 0; i < atomsInNeedOfFix.size(); i++) {
                IAtom atom = atomsInNeedOfFix.get(i);
                int conn = getConnectivity(atom, container);
                int hCnt = 0;
                for (int j = 0; j < dblBondPositions.size(); j++) {
                    if (dblBondPositions.get(j) == bondOffSet + i) hCnt++;
                }
                if (atom.getValency() - atom.getFormalCharge() > (hCnt + conn)) {
                    if (dblBondsAdded < doubleBondMax) {
                        dblBondPositions.add(bondOffSet + i);
                        dblBondsAdded++;
                        tryDoubleBondCombinations(container, dblBondsAdded, bondOffSet, doubleBondMax, atomsInNeedOfFix);
                        dblBondPositions.remove(dblBondPositions.size() - 1);
                        dblBondsAdded--;
                    }
                }
            }
            return dblBondPositions;
        }","private List<Integer> tryDoubleBondCombinations(IAtomContainer container, int dblBondsAdded, int bondOffSet, int doubleBondMax, List<IAtom> atomsInNeedOfFix){
        List<Integer> dblBondPositions = new ArrayList<>();
        int dblBondCount = 0;
        for (int i = 0; i < container.getBondCount(); i++) {
            IBond bond = container.getBond(i);
            if (bond.getOrder() == IBond.Order.DOUBLE) {
                dblBondCount++;
                if (dblBondCount > doubleBondMax)
                    return dblBondPositions;
                dblBondPositions.add(i);
            }
        }
        if (dblBondCount == 0)
            return dblBondPositions;
        List<List<Integer>> combinations = new ArrayList<>();
        List<Integer> taken = new ArrayList<>();
        combineHydrogenPositions(taken, combinations, container, dblBondsAdded, dblBondPositions);
        for (List<Integer> combination : combinations) {
            IAtomContainer tautomer = (IAtomContainer) container.clone();
            for (int i = 0; i < combination.size(); i++) {
                int pos = combination.get(i);
                IAtom atom = findAtomByPosition(tautomer, pos);
                atom.setImplicitHydrogenCount(1);
                IBond bond = tautomer.getBond(atom);
                bond.setOrder(IBond.Order.DOUBLE);
            }
            if (isValidTautomer(tautomer, atomsInNeedOfFix)) {
                return combination;
            }
        }
        return dblBondPositions;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS - TIMEOUT,  0.33161303171383616,  0.45950906189455354,  0.45763459613994006,  0.3695111559913029,176.0,0.6308243727598566,186.0,0.6666666666666666,183.0,0.6559139784946236,177.0,0.6344086021505376,137.0,0.5780590717299579,141.0,0.5202952029520295,92.0,0.46938775510204084,5.0,0.19230769230769232,9.0,0.391304347826087,21.0,0.9130434782608695
870,cdk,"private static int findChargePosition(String formula){
    int end = formula.length() - 1;
    int pos = end;
    while (pos >= 0 && isSign(formula.charAt(pos))) pos--;
    int mark1 = pos;
    while (pos >= 0 && isDigit(formula.charAt(pos))) pos--;
    int mark2 = pos;
    while (pos >= 0 && isSign(formula.charAt(pos))) pos--;
    if (pos == mark2 && formula.charAt(pos) != ']')
        pos = mark1;
    return pos + 1;
}",findChargePosition,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * Extract the charge position given a molecular formula format [O3S]2-.
     *
     * @param formula The formula to inspect
     * @return        The charge position in the string
     */",805-825,"('findChargePosition', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",117.0,14.0,Extract the charge position given a molecular formula format [O3S]2-.,Given a molecular this method extracts the charge position,The charge position is given in a formula format.,0.156022130724962,Extract the charging position according to a molecular formula format [O3S]2-.,"private static int findChargePosition(String formula){
        int pos = formula.indexOf(""["");
        if (pos < 0)
            return -1;
        int pos2 = formula.indexOf(""]"", pos);
        if (pos2 < 0)
            return -1;
        return pos;
    }","private static int findChargePosition(String formula){
        int pos = formula.indexOf(""["");
        if (pos < 0)
            pos = formula.indexOf(""("");
        if (pos < 0)
            pos = formula.indexOf(""+"");
        if (pos < 0)
            pos = formula.indexOf(""-"");
        return pos;
    }","private static int findChargePosition(String formula){
        int pos = formula.indexOf('[');
        if (pos < 0)
            pos = formula.indexOf('(');
        if (pos < 0)
            return -1;
        int pos2 = formula.indexOf(']');
        if (pos2 < 0)
            pos2 = formula.indexOf(')');
        if (pos2 < 0)
            return -1;
        return pos;
    }","private static int findChargePosition(String formula){
        int pos = formula.indexOf(']');
        if (pos < 0)
            return -1;
        int pos2 = formula.indexOf('[');
        if (pos2 < 0)
            return -1;
        if (pos2 > pos)
            return -1;
        return pos;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.18563558195724195,  0.2008123815743162,  0.19577385890891688,  0.22841047098818562,80.0,0.6779661016949152,72.0,0.6101694915254238,77.0,0.652542372881356,74.0,0.6271186440677966,27.0,0.391304347826087,14.0,0.21875,32.0,0.38095238095238093,10.0,0.9090909090909091,3.0,0.25,7.0,0.6363636363636364
871,shardingsphere-elasticjob,"public boolean isRegisterStartSuccess(final Collection<Integer> shardingItems){
    for (int each : shardingItems) {
        if (!jobNodeStorage.isJobNodeExisted(GuaranteeNode.getStartedNode(each))) {
            return false;
        }
    }
    return true;
}",isRegisterStartSuccess,org/apache/shardingsphere/elasticjob/lite/internal/guarantee/GuaranteeService.java,/elasticjob-lite/elasticjob-lite-core/src/main/java/org/apache/shardingsphere/elasticjob/lite/internal/guarantee/GuaranteeService.java,"/**
     * Judge whether current sharding items are all register start success.
     *
     * @param shardingItems current sharding items
     * @return current sharding items are all start success or not
     */",51-64,"('isRegisterStartSuccess', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,11.0,Judge whether current sharding items are all register start success.,Check whether current sharding items are all register start success,"If current items are all register start success, judge.",0.513562870430424,Determine if the current partitioning items are all registry startup successes.," public boolean isRegisterStartSuccess(final Collection<Integer> shardingItems){
        for (int each : shardingItems) {
            if (!jobNodeStorage.isJobNodeExisted(GuaranteeNode.getStartedNode(each))) {
                return false;
            }
        }
        return true;
    }"," public boolean isRegisterStartSuccess(final Collection<Integer> shardingItems){
        for (int each : shardingItems) {
            if (!jobNodeStorage.isJobNodeExisted(GuaranteeNode.getStartedNode(each))) {
                return false;
            }
        }
        return true;
    }"," public boolean isRegisterStartSuccess(final Collection<Integer> shardingItems){
        for (int each : shardingItems) {
            if (!jobNodeStorage.isJobNodeExisted(GuaranteeNode.getStartedNode(each))) {
                return false;
            }
        }
        return true;
    }"," public boolean isRegisterStartSuccess(final Collection<Integer> shardingItems){
        for (int each : shardingItems) {
            if (!jobNodeStorage.isJobNodeExisted(GuaranteeNode.getStartedNode(each))) {
                return false;
            }
        }
        return true;
    }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.18181818181818182,7.0,0.5833333333333334,5.0,0.45454545454545453
872,cdk,"private int parity(ITetrahedralChirality.Stereo stereo){
    switch(stereo) {
        case CLOCKWISE:
            return -1;
        case ANTI_CLOCKWISE:
            return +1;
        default:
            return 0;
    }
}",parity,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,"/**
     * Obtain the parity (winding) of a tetrahedral element. The parity is -1
     * for clockwise (odd), +1 for anticlockwise (even) and 0 for unspecified.
     *
     * @param stereo configuration
     * @return the parity
     */",978-994,"('parity', {'INSTRUCTION': {'covered': 9, 'missed': 2}, 'BRANCH': {'covered': 2, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,11.0,Obtain the parity (winding) of a tetrahedral element.,This method winds a tetrahedral element,The element has a parity.,0.0464146088728633,Obtain parity (winding) of a tetrahedral element.,"private int parity(ITetrahedralChirality.Stereo stereo){
        switch (stereo) {
        case CLOCKWISE:
            return +1;
        case ANTICLOCKWISE:
            return -1;
        case DOUBLE_CLOCKWISE:
            return +2;
        case DOUBLE_ANTICLOCKWISE:
            return -2;
        default:
            return 0;
        }
    }","private int parity(ITetrahedralChirality.Stereo stereo){
        if(stereo == ITetrahedralChirality.Stereo.CLOCKWISE)
            return +1;
        else if(stereo == ITetrahedralChirality.Stereo.ANTI_CLOCKWISE)
            return -1;
        else
            return 0;
    }","private int parity(ITetrahedralChirality.Stereo stereo){
        if (stereo == ITetrahedralChirality.Stereo.CLOCKWISE)
            return +1;
        if (stereo == ITetrahedralChirality.Stereo.ANTI_CLOCKWISE)
            return -1;
        return 0;
    }","private int parity(ITetrahedralChirality.Stereo stereo){
        switch (stereo) {
            case Clockwise:
                return +1;
            case AntiClockwise:
                return -1;
            default:
                return 0;
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8353894944618183,  0.6157322711577538,  0.9177219197897111,  0.6204928658909781,16.0,0.3137254901960784,22.0,0.4888888888888889,4.0,0.10810810810810811,21.0,0.4883720930232558,28.0,0.5490196078431373,16.0,0.3137254901960784,28.0,0.5490196078431373,6.0,0.6666666666666666,1.0,0.1111111111111111,7.0,0.7777777777777778
873,cdk,"public IAtomContainer assignGasteigerMarsiliSigmaPartialCharges(IAtomContainer ac, boolean setCharge) throws Exception{
    for (int i = 0; i < ac.getAtomCount(); i++) ac.getAtom(i).setCharge(0.0);
    double[] gasteigerFactors = assignGasteigerSigmaMarsiliFactors(ac);
    double alpha = 1.0;
    double q;
    double deoc;
    IAtom[] atoms = null;
    int atom1 = 0;
    int atom2 = 0;
    double[] q_old = new double[ac.getAtomCount()];
    for (int i = 0; i < q_old.length; i++) q_old[0] = 20.0;
    out: for (int i = 0; i < MX_ITERATIONS; i++) {
        alpha *= MX_DAMP;
        boolean isDifferent = false;
        for (int j = 0; j < ac.getAtomCount(); j++) {
            q = gasteigerFactors[STEP_SIZE * j + j + 5];
            double difference = Math.abs(q_old[j]) - Math.abs(q);
            if (Math.abs(difference) > 0.001)
                isDifferent = true;
            q_old[j] = q;
            gasteigerFactors[STEP_SIZE * j + j + 4] = gasteigerFactors[STEP_SIZE * j + j + 2] * q * q + gasteigerFactors[STEP_SIZE * j + j + 1] * q + gasteigerFactors[STEP_SIZE * j + j];
        }
        if (!isDifferent)
            break out;
        Iterator<IBond> bonds = ac.bonds().iterator();
        while (bonds.hasNext()) {
            IBond bond = (IBond) bonds.next();
            atom1 = ac.indexOf(bond.getBegin());
            atom2 = ac.indexOf(bond.getEnd());
            if (gasteigerFactors[STEP_SIZE * atom1 + atom1 + 4] >= gasteigerFactors[STEP_SIZE * atom2 + atom2 + 4]) {
                if (""H"".equals(ac.getAtom(atom2).getSymbol())) {
                    deoc = DEOC_HYDROGEN;
                } else {
                    deoc = gasteigerFactors[STEP_SIZE * atom2 + atom2 + 3];
                }
            } else {
                if (""H"".equals(ac.getAtom(atom1).getSymbol())) {
                    deoc = DEOC_HYDROGEN;
                } else {
                    deoc = gasteigerFactors[STEP_SIZE * atom1 + atom1 + 3];
                }
            }
            q = (gasteigerFactors[STEP_SIZE * atom1 + atom1 + 4] - gasteigerFactors[STEP_SIZE * atom2 + atom2 + 4]) / deoc;
            gasteigerFactors[STEP_SIZE * atom1 + atom1 + 5] -= (q * alpha);
            gasteigerFactors[STEP_SIZE * atom2 + atom2 + 5] += (q * alpha);
        }
    }
    for (int i = 0; i < ac.getAtomCount(); i++) {
        ac.getAtom(i).setCharge(gasteigerFactors[STEP_SIZE * i + i + 5]);
    }
    return ac;
}",assignGasteigerMarsiliSigmaPartialCharges,org/openscience/cdk/charges/GasteigerMarsiliPartialCharges.java,/tool/charges/src/main/java/org/openscience/cdk/charges/GasteigerMarsiliPartialCharges.java,"/**
     *  Main method which assigns Gasteiger Marisili partial sigma charges.
     *
     *@param  ac             AtomContainer
     *@param setCharge            The Charge
     *@return                AtomContainer with partial charges
     *@exception  Exception  Possible Exceptions
     */",117-197,"('assignGasteigerMarsiliSigmaPartialCharges', {'INSTRUCTION': {'covered': 312, 'missed': 4}, 'BRANCH': {'covered': 21, 'missed': 1}, 'LINE': {'covered': 39, 'missed': 1}, 'COMPLEXITY': {'covered': 11, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",557.0,10.0,Main method which assigns Gasteiger Marisili partial sigma charges.,This method assigns partial sigma charges,The main method assigns partial sigma charges.,0.4369889151423,The main method that assigns Gasteiger Marisili partial sigma charges.," public IAtomContainer assignGasteigerMarsiliSigmaPartialCharges(IAtomContainer ac, boolean setCharge) throws Exception{
        if (ac == null) {
            throw new CDKException(""Null atom container"");
        }
        if (setCharge) {
            setPartialCharges(ac);
        } else {
            getPartialCharges(ac);
        }
        return ac;
    }","public IAtomContainer assignGasteigerMarsiliSigmaPartialCharges(IAtomContainer ac, boolean setCharge) throws Exception{
        if (ac == null) {
            throw new Exception(""Null atom container"");
        }
        if (ac.getAtomCount() == 0) {
            throw new Exception(""Empty atom container"");
        }
        if (ac.getBondCount() == 0) {
            throw new Exception(""Empty bond container"");
        }
    
        // initialize the charges
        for (int i = 0; i < ac.getAtomCount(); i++) {
            ac.getAtom(i).setCharge(0.0);
        }
    
        // initialize the partial charges
        for (int i = 0; i < ac.getAtomCount(); i++) {
            ac.getAtom(i).setPartialCharge(0.0);
        }
    
        // initialize the partial charges
        for (int i = 0; i < ac.getBondCount(); i++) {
            ac.getBond(i).set partialCharge(0.0);
        }
    
        // initialize the partial charges
        for (int i = 0; i < ac.getBondCount(); i++) {
            ac.getBond(i).set partialCharge(0.0);
        }
    
        // initialize the partial charges
        for (int i = 0; i < ac.getBondCount(); i++) {
            ac.getBond(i).set partialCharge(0.0);
        }
    
        // initialize the partial charges
        for (int i = 0; i < ac.getBondCount(); i++) {
            ac.getBond(i).set partialCharge(0.0);
        }
    
        // initialize the partial charges
        for (int i = 0; i < ac.getBondCount(); i++) {
            ac.getBond(i).set partialCharge(0.0);
        }
    
        // initialize the partial charges
        for (int i = 0; i < ac.getBondCount(); i++) {
            ac.getBond(i).set partialCharge(0.0);
        }
    
        // initialize the partial charges
        for (int i      
 }","public IAtomContainer assignGasteigerMarsiliSigmaPartialCharges(IAtomContainer ac, boolean setCharge) throws Exception{
        if (ac == null) return null;
        if (ac.getAtomCount() == 0) return null;
        if (ac.getBondCount() == 0) return null;
    
        //  Initialize the partial charges
        for (int i = 0; i < ac.getAtomCount(); i++) {
            ac.getAtom(i).setCharge(0.0);
        }
    
        //  Initialize the partial charges
        for (int i = 0; i < ac.getBondCount(); i++) {
            ac.getBond(i).setOrder(IBond.SINGLE);
        }
    
        //  Initialize the partial charges
        for (int i = 0; i < ac.getAtomCount(); i++) {
            ac.getAtom(i).setFormalCharge(0);
        }
    
        //  Initialize the partial charges
        for (int i = 0; i < ac.getAtomCount(); i++) {
            ac.getAtom(i).setPartialCharge(0.0);
        }
    
        //  Initialize the partial charges
        for (int i = 0; i < ac.getAtomCount(); i++) {
            ac.getAtom(i).setImplicitHydrogenCount(0);
        }
    
        //  Initialize the partial charges
        for (int i = 0; i < ac.getAtomCount(); i++) {
            ac.getAtom(i).setFormalCharge(0);
        }
    
        //  Initialize the partial charges
        for (int i = 0; i < ac.getAtomCount(); i++) {
            ac.getAtom(i).setPartialCharge(0.0);
        }
    
        //  Initialize the partial charges
        for (int i = 0; i < ac.getAtomCount(); i++) {
            ac.getAtom(i).setImplicitHydrogenCount(0);
        }
    
        //  Initialize the partial charges
        for (int i = 0; i < ac.getAtomCount     
 }",Not Valid,NOT PASS,Syntax Error,Not Valid,Syntax Error,  0.03965812505914829,None,None,None,515.0,0.9229390681003584,None,None,None,None,404.0,0.7240143369175627,None,None,None,None,278.0,0.86875,5.0,0.5,3.0,0.2727272727272727,5.0,0.5
874,cdk,"public static void breadthFirstSearch(IAtomContainer ac, List<IAtom> sphere, IAtomContainer[] pathes) throws CDKException{
    IAtom atom = null;
    IAtom nextAtom = null;
    int atomNr;
    int nextAtomNr;
    List<IAtom> newSphere = new ArrayList<IAtom>();
    logger.debug(""Start of breadthFirstSearch"");
    for (int f = 0; f < sphere.size(); f++) {
        atom = sphere.get(f);
        if (!atom.getFlag(CDKConstants.ISINRING)) {
            atomNr = ac.indexOf(atom);
            logger.debug(""BreadthFirstSearch around atom "" + (atomNr + 1));
            List bonds = ac.getConnectedBondsList(atom);
            for (int g = 0; g < bonds.size(); g++) {
                IBond curBond = (IBond) bonds.get(g);
                nextAtom = curBond.getOther(atom);
                if (!nextAtom.getFlag(CDKConstants.VISITED) && !nextAtom.getFlag(CDKConstants.ISPLACED)) {
                    nextAtomNr = ac.indexOf(nextAtom);
                    logger.debug(""BreadthFirstSearch is meeting new atom "" + (nextAtomNr + 1));
                    pathes[nextAtomNr] = ac.getBuilder().newInstance(IAtomContainer.class, pathes[atomNr]);
                    logger.debug(""Making copy of path "" + (atomNr + 1) + "" to form new path "" + (nextAtomNr + 1));
                    pathes[nextAtomNr].addAtom(nextAtom);
                    logger.debug(""Adding atom "" + (nextAtomNr + 1) + "" to path "" + (nextAtomNr + 1));
                    pathes[nextAtomNr].addBond(curBond);
                    if (ac.getConnectedBondsCount(nextAtom) > 1) {
                        newSphere.add(nextAtom);
                    }
                }
            }
        }
    }
    if (newSphere.size() > 0) {
        for (int f = 0; f < newSphere.size(); f++) {
            newSphere.get(f).setFlag(CDKConstants.VISITED, true);
        }
        breadthFirstSearch(ac, newSphere, pathes);
    }
    logger.debug(""End of breadthFirstSearch"");
}",breadthFirstSearch,org/openscience/cdk/layout/AtomPlacer.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/AtomPlacer.java,"/**
     *  Performs a breadthFirstSearch in an AtomContainer starting with a
     *  particular sphere, which usually consists of one start atom, and searches
     *  for the longest aliphatic chain which is yet unplaced. If the search
     *  encounters an unplaced ring atom, it is also appended to the chain so that
     *  this last bond of the chain can also be laid out. This gives us the
     *  orientation for the attachment of the ring system.
     *
     *@param  ac                                              The AtomContainer to
     *      be searched
     *@param  sphere                                          A sphere of atoms to
     *      start the search with
     *@param  pathes                                          A vector of N pathes
     *      (N = no of heavy atoms).
     *@exception  org.openscience.cdk.exception.CDKException  Description of the
     *      Exception
     */",659-718,"('breadthFirstSearch', {'INSTRUCTION': {'covered': 186, 'missed': 0}, 'BRANCH': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 29, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",392.0,32.0,"Performs a breadthFirstSearch in an AtomContainer starting with a  particular sphere, which usually consists of one start atom, and searches  for the longest aliphatic chain which is yet unplaced.",This method performs a breadth first search in the given container starting with a particular sphere,The breadth first search is performed in an atom container with a sphere and searches for the longest aliphatic chain which is yet unplace.,0.936232493801435,"Performs a breadthFirstSearch in an AtomContainer starting with a particular sphere, which usually consists of a starting atom, and looks for the longest aliphatic chain that is not yet placed.","public static void breadthFirstSearch(IAtomContainer ac, List<IAtom> sphere, IAtomContainer[] pathes) throws CDKException{
        logger.debug(""Start of breadthFirstSearch."");
        List<IAtom> newSphere = new ArrayList<IAtom>();
        for (int f = 0; f < sphere.size(); f++) {
            IAtom atom = sphere.get(f);
            List<IAtom> connectedAtoms = ac.getConnectedAtomsList(atom);
            for (int g = 0; g < connectedAtoms.size(); g++) {
                IAtom curatom = connectedAtoms.get(g);
                if (!curatom.getFlag(CDKConstants.VISITED)) {
                    curatom.setFlag(CDKConstants.VISITED, true);
                    pathes[curatom.getIndex()].addAtom(atom);
                    newSphere.add(curatom);
                }
            }
        }
        if (newSphere.size() > 0) {
            breadthFirstSearch(ac, newSphere, pathes);
        }
        logger.debug(""End of breadthFirstSearch."");
    }","public static void breadthFirstSearch(IAtomContainer ac, List<IAtom> sphere, IAtomContainer[] pathes) throws CDKException{
        logger.debug(""Start of breadthFirstSearch."");
        List<IAtom> newSphere = new ArrayList<IAtom>();
        for (int f = 0; f < sphere.size(); f++) {
            IAtom atom = sphere.get(f);
            List<IAtom> connectedAtoms = ac.getConnectedAtomsList(atom);
            for (int g = 0; g < connectedAtoms.size(); g++) {
                IAtom curatom = connectedAtoms.get(g);
                if (!curatom.getFlag(CDKConstants.VISITED)) {
                    curatom.setFlag(CDKConstants.VISITED, true);
                    pathes[curatom.getIndex()].addAtom(atom);
                    newSphere.add(curatom);
                }
            }
        }
        if (newSphere.size() > 0) {
            breadthFirstSearch(ac, newSphere, pathes);
        }
        logger.debug(""End of breadthFirstSearch."");
    }","public static void breadthFirstSearch(IAtomContainer ac, List<IAtom> sphere, IAtomContainer[] pathes) throws CDKException{
        logger.debug(""Start of breadthFirstSearch."");
        IAtomContainerBuilder builder = ac.getBuilder();
        List<IAtom> newSphere = new ArrayList<IAtom>();
        for (int f = 0; f < sphere.size(); f++) {
            IAtom atom = sphere.get(f);
            if (!atom.getFlag(CDKConstants.VISITED)) {
                atom.setFlag(CDKConstants.VISITED, true);
                List<IAtom> connectedAtoms = ac.getConnectedAtomsList(atom);
                for (int g = 0; g < connectedAtoms.size(); g++) {
                    IAtom curatom = connectedAtoms.get(g);
                    if (!curatom.getFlag(CDKConstants.VISITED)) {
                        newSphere.add(curatom);
                        pathes[curatom.getIndex()].addAtom(atom);
                    }
                }
            }
        }
        if (newSphere.size() > 0) {
            breadthFirstSearch(ac, newSphere, pathes);
        }
        logger.debug(""End of breadthFirstSearch."");     
 }","public static void breadthFirstSearch(IAtomContainer ac, List<IAtom> sphere, IAtomContainer[] pathes) throws CDKException{
        logger.debug(""Start of breadthFirstSearch."");
        int maxPathLength = 0;
        int maxDegreeSum = 0;
        int degreeSum = 0;
        int longest = 0;
        int longestPathLength = 0;
        IAtomContainer[] newPathes = new IAtomContainer[ac.getAtomCount()];
        for (int f = 0; f < ac.getAtomCount(); f++) {
            newPathes[f] = pathes[f];
        }
        for (int f = 0; f < sphere.size(); f++) {
            IAtom atom = sphere.get(f);
            if (atom.getFlag(CDKConstants.VISITED)) {
                continue;
            }
            atom.setFlag(CDKConstants.VISITED, true);
            List<IAtom> newSphere = new ArrayList<IAtom>();
            newSphere.add(atom);
            breadthFirstSearch(ac, newSphere, newPathes);
            for (int g = 0; g < newPathes.length; g++) {
                if (newPathes[g].getAtomCount() >= maxPathLength) {
                    degreeSum = getDegreeSum(newPathes[g], ac);
                    if (degreeSum > maxDegreeSum) {
                        maxDegreeSum = degreeSum;
                        longest = g;
                        longestPathLength = newPathes[g].getAtomCount();
                    }
                }
            }
        }
        if (longestPathLength > pathes[longest].getAtomCount()) {
            pathes[longest] = newPathes[longest];
        }
        logger.debug(""End of breadthFirstSearch."");     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.36884776377500966,  0.36884776377500966,  0.40543877431541486,  0.40448726589268225,231.0,0.5877862595419847,231.0,0.5877862595419847,274.0,0.6972010178117048,222.0,0.5648854961832062,0.0,0.0,175.0,0.6013745704467354,47.0,0.2186046511627907,27.0,0.9,6.0,0.1935483870967742,18.0,0.6
875,sonar-cxx,"private static boolean isGeneratedNodeExcluded(AstNode astNode){
    var prev = astNode.getPreviousAstNode();
    return prev != null && prev.getTokenLine() == astNode.getTokenLine() && prev.isCopyBookOrGeneratedNode();
}",isGeneratedNodeExcluded,org/sonar/cxx/checks/metrics/TooManyStatementsPerLineCheck.java,/cxx-checks/src/main/java/org/sonar/cxx/checks/metrics/TooManyStatementsPerLineCheck.java,"/**
   * Exclude subsequent generated nodes, if they are consecutive and on the same line.
   */",56-64,"('isGeneratedNodeExcluded', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",42.0,15.0,"Exclude subsequent generated nodes, if they are consecutive and on the same line.",If subsequent generated nodes are consecutive and on the same line this method excludes them,"If they are on the same line, exclude subsequent generated nodes.",0.347080853396962,"Exclude the following generated nodes, if they are consecutive and on the same line."," private static boolean isGeneratedNodeExcluded(AstNode astNode){
    if (astNode.getParent() == null) {
      return false;
    }
    AstNode parent = astNode.getParent();
    if (parent.getType() == CxxGrammarImpl.GENERATED_NODE) {
      return true;
    }
    return isGeneratedNodeExcluded(parent);
  }"," private static boolean isGeneratedNodeExcluded(AstNode astNode){
    if(astNode.getParent() != null && astNode.getParent().getParent() != null){
      if(astNode.getParent().getParent().getType() == CxxGrammarImpl.GENERATED_NODE){
        return true;
      }
    }
    return false;   
 }"," private static boolean isGeneratedNodeExcluded(AstNode astNode){
    return astNode.getPreviousAstNode() != null && astNode.getPreviousAstNode().getToken().getType().equals(CxxGrammarImpl.GENERATED_NODE);   
 }"," private static boolean isGeneratedNodeExcluded(AstNode astNode){
    return astNode.is(CxxGrammarImpl.DEFAULT_STATEMENT, CxxGrammarImpl.CASE_STATEMENT, CxxGrammarImpl.BREAK_STATEMENT, CxxGrammarImpl.CONTINUE_STATEMENT, CxxGrammarImpl.GOTO_STATEMENT, CxxGrammarImpl.RETURN_STATEMENT, CxxGrammarImpl.THROW_STATEMENT, CxxGrammarImpl.TRY_STATEMENT, CxxGrammarImpl.WHILE_STATEMENT, CxxGrammarImpl.DO_STATEMENT, CxxGrammarImpl.FOR_STATEMENT, CxxGrammarImpl.IF_STATEMENT, CxxGrammarImpl.SWITCH_STATEMENT, CxxGrammarImpl.DECLARATION_STATEMENT, CxxGrammarImpl.EXPRESSION_STATEMENT, CxxGrammarImpl.LABELED_STATEMENT, CxxGrammarImpl.MEMBER_DECLARATION_STATEMENT, CxxGrammarImpl.MEMBER_INITIALIZATION_STATEMENT, CxxGrammarImpl.NAMESPACE_ALIAS_DECLARATION_STATEMENT, CxxGrammarImpl.USING_DECLARATION_STATEMENT, CxxGrammarImpl.USING_DIRECTIVE_STATEMENT, CxxGrammarImpl.USING_NAMESPACE_STATEMENT, CxxGrammarImpl.USING_TYPENAME_STATEMENT, CxxGrammarImpl.USING_UNQUALIFIED_NAME_STATEMENT, CxxGrammarImpl.ASM_STATEMENT, CxxGrammarImpl.ATTRIBUTE_SPECIFICATION_STATEMENT, CxxGrammarImpl.ATTRIBUTE_STATEMENT, CxxGrammarImpl.AUTO_STATEMENT, CxxGrammarImpl.BREAK_STATEMENT, CxxGrammarImpl.CASE_STATEMENT, CxxGrammarImpl.CATCH_STATEMENT, CxxGrammarImpl.CLASS_DECLARATION_STATEMENT, CxxGrammarImpl.CLASS_TEMPLATE_DEC    
 }",NOT PASS,NOT PASS,Syntax Error,NOT PASS,  0.4479134215520418,  0.38990735049996406,None,  0.44610717037693715,33.0,0.5689655172413793,38.0,0.6031746031746031,132.0,0.8979591836734694,19.0,0.4418604651162791,24.0,0.38095238095238093,130.0,0.8843537414965986,30.0,0.5172413793103449,9.0,0.5625,2.0,0.13333333333333333,12.0,0.8571428571428571
877,matsim-libs,"public final ConfigGroup createModule(final String name){
    if (this.modules.containsKey(name)) {
        throw new IllegalArgumentException(""Module "" + name + "" exists already."");
    }
    ConfigGroup m = new ConfigGroup(name);
    this.modules.put(name, m);
    return m;
}",createModule,org/matsim/core/config/Config.java,/matsim/src/main/java/org/matsim/core/config/Config.java,"/**
         * Creates a new module / config-group with the specified name.
         *
         * @param name
         *            The name of the config-group to be created.
         *
         * @return the newly created config group
         * @throws IllegalArgumentException
         *             if a config-group with the specified name already exists.
         */",226-243,"('createModule', {'INSTRUCTION': {'covered': 18, 'missed': 6}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",58.0,11.0,Creates a new module / config-group with the specified name.,Creates a new config-group with a specified name,A new module is created with the name specified.,0.527388237642134,Creates a configuration module/group with the specified name.," public final ConfigGroup createModule(final String name){
	 ConfigGroup module = this.modules.get(name);
	 if (module == null) {
		 module = new ConfigGroup(name);
		 this.modules.put(name, module);
	 }
	 return module;
 }"," public final ConfigGroup createModule(final String name){
	 ConfigGroup module = this.modules.get(name);
	 if (module == null) {
		 module = new ConfigGroup(name);
		 this.modules.put(name, module);
	 }
	 return module;
 }"," public final ConfigGroup createModule(final String name){
	 		ConfigGroup module = this.modules.get(name);
 		if (module != null) {
 			throw new RuntimeException(""Module "" + name + "" already exists."");
 		}
 		module = new ConfigGroup(name);
 		this.modules.put(name, module);
 		return module;
 	}		"," public final ConfigGroup createModule(final String name){
	 		ConfigGroup module = this.modules.get(name);
 		if (module != null) {
 			throw new IllegalStateException(""Module "" + name + "" already exists."");
 		}
 		module = new ConfigGroup(name);
 		this.modules.put(name, module);
 		return module;
 	}		",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5987868406377783,  0.5987868406377783,  0.703150756443269,  0.703150756443269,21.0,0.3559322033898305,21.0,0.3559322033898305,16.0,0.24615384615384617,16.0,0.24615384615384617,0.0,0.0,14.0,0.2153846153846154,14.0,0.2153846153846154,4.0,0.36363636363636365,4.0,0.36363636363636365,6.0,0.5454545454545454
878,jackson-databind,"protected JsonDeserializer<Object> _prefetchRootDeserializer(JavaType valueType){
    if ((valueType == null) || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {
        return null;
    }
    JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);
    if (deser == null) {
        try {
            DeserializationContext ctxt = createDummyDeserializationContext();
            deser = ctxt.findRootValueDeserializer(valueType);
            if (deser != null) {
                _rootDeserializers.put(valueType, deser);
            }
            return deser;
        } catch (JacksonException e) {
        }
    }
    return deser;
}",_prefetchRootDeserializer,com/fasterxml/jackson/databind/ObjectReader.java,/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java,"/**
     * Method called to locate deserializer ahead of time, if permitted
     * by configuration. Method also is NOT to throw an exception if
     * access fails.
     */",2360-2386,"('_prefetchRootDeserializer', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,14.0,"Method called to locate deserializer ahead of time, if permitted  by configuration.","Prefetch deserializer ahead of time, if permitted by configuration","If allowed by configuration, method to locate deserializer ahead of time.",0.891610588174616,"Method called to locate the deserializer in advance, if the configuration allows it."," protected JsonDeserializer<Object> _prefetchRootDeserializer(JavaType valueType){
        if (_rootDeserializer != null) {
            return _rootDeserializer;
        }
        // Sanity check: must have actual type...
        if (valueType == null) {
            return null;
        }
        // First: have we already seen it?
        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);
        if (deser != null) {
            return deser;
        }
        // Nope: need to ask provider to resolve it
        deser = _config.getDeserializationContext().findRootValueDeserializer(valueType);
        if (deser == null) { // can this happen?
            return null;
        }
        _rootDeserializers.put(valueType, deser);
        return deser;
    }"," protected JsonDeserializer<Object> _prefetchRootDeserializer(JavaType valueType){
        if (_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {
            JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);
            if (deser == null) {
                deser = _rootDeserializer;
                if (deser == null) {
                    return null;
                }
                _rootDeserializers.put(valueType, deser);
            }
            return deser;
        }
        return null;
    }"," protected JsonDeserializer<Object> _prefetchRootDeserializer(JavaType valueType){
        if (_rootDeserializer != null) {
            return _rootDeserializers.get(_valueType);
        }
        return null;
    }"," protected JsonDeserializer<Object> _prefetchRootDeserializer(JavaType valueType){
        if (_rootDeserializer != null) {
            return _rootDeserializers.get(_valueType);
        }
        return null;
    }",NOT PASS,NOT PASS,PASS,PASS,  0.5762216295157945,  0.5938968338629065,  0.16692597894403466,  0.16692597894403466,44.0,0.41509433962264153,40.0,0.37735849056603776,78.0,0.7358490566037735,78.0,0.7358490566037735,38.0,0.4,64.0,0.6736842105263158,64.0,0.6736842105263158,5.0,0.38461538461538464,8.0,0.5714285714285714,10.0,0.7692307692307693
879,cdk,"static GeometricParity geometric(IAtomContainer mol, int l, int r, int l1, int l2, int r1, int r2){
    Point2d l2d = mol.getAtom(l).getPoint2d();
    Point2d r2d = mol.getAtom(r).getPoint2d();
    Point2d l12d = mol.getAtom(l1).getPoint2d();
    Point2d l22d = mol.getAtom(l2).getPoint2d();
    Point2d r12d = mol.getAtom(r1).getPoint2d();
    Point2d r22d = mol.getAtom(r2).getPoint2d();
    if (l2d != null && r2d != null && l12d != null && l22d != null && r12d != null && r22d != null) {
        return new DoubleBond2DParity(l2d, r2d, l12d, l22d, r12d, r22d);
    }
    Point3d l3d = mol.getAtom(l).getPoint3d();
    Point3d r3d = mol.getAtom(r).getPoint3d();
    Point3d l13d = mol.getAtom(l1).getPoint3d();
    Point3d r13d = mol.getAtom(r1).getPoint3d();
    if (l3d != null && r3d != null && l13d != null && r13d != null)
        return new DoubleBond3DParity(l3d, r3d, l13d, r13d);
    return null;
}",geometric,org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,"/**
     * Generate a new geometric parity (2D or 3D) for the given molecule and
     * atom indices. This method ensure that 2D and 3D coordinates are available
     * on the specified atoms and returns null if the 2D or 3D coordinates are
     * not fully available.
     *
     * @param mol a molecule
     * @param l   left double bonded atom
     * @param r   right double bonded atom
     * @param l1  first substituent atom of <i>l</i>
     * @param l2  second substituent atom of <i>l</i> or <i>l</i> if there is
     *            none
     * @param r1  first substituent atom of <i>r</i>
     * @param r2  second substituent atom of <i>r</i> or <i>r</i> if there is
     *            none
     * @return geometric parity or null
     */",148-194,"('geometric', {'INSTRUCTION': {'covered': 90, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 8}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 8}, 'METHOD': {'covered': 1, 'missed': 0}})",246.0,18.0,Generate a new geometric parity (2D or 3D) for the given molecule and  atom indices.,This method generates a new geometric parity for the given molecule and atom indices,A new geometric parity is created for the given molecule and atom indices.,0.404368086266465,Generate a new geometric parity (2D or 3D) for the given molecule and atom indices.,"static GeometricParity geometric(IAtomContainer mol, int l, int r, int l1, int l2, int r1, int r2){
     
      // get the coordinates of the atoms
      Point3d l1Coord = mol.getAtom(l1).getPoint3d();
      Point3d l2Coord = mol.getAtom(l2).getPoint3d();
      Point3d r1Coord = mol.getAtom(r1).getPoint3d();
      Point3d r2Coord = mol.getAtom(r2).getPoint3d();
     
      // if there are no coordinates then return null
      if (l1Coord == null || l2Coord == null || r1Coord == null || r2Coord == null) return null;
     
      // if there are no coordinates then return null
      if (l1Coord.equals(l2Coord) || r1Coord.equals(r2Coord)) return null;
     
      // if there are no coordinates then return null
      if (l1Coord.equals(r1Coord) || l2Coord.equals(r2Coord)) return null;
     
      // if there are no coordinates then return null
      if (l1Coord.equals(r2Coord) || l2Coord.equals(r1Coord)) return null;
     
      // if there are no coordinates then return null
      if (r1Coord.equals(l2Coord) || r2Coord.equals(l1Coord)) return null;
     
      // if there are no coordinates then return null
      if (r1Coord.equals(l1Coord) || r2Coord.equals(l2Coord)) return null;
     
      // if there are no coordinates then return null
      if (l1Coord.equals(r2Coord) || l2Coord.equals(r1Coord)) return null;
     
      // if there are no coordinates then return null
      if (l1Coord.equals(r1Coord) || l2Coord.equals(r2Coord)) return null;
     
      // if there are no coordinates then return null
      if            
 }","static GeometricParity geometric(IAtomContainer mol, int l, int r, int l1, int l2, int r1, int r2){
     
      // get the coordinates of the atoms
      Point3d l1Coord = mol.getAtom(l1).getPoint3d();
      Point3d l2Coord = mol.getAtom(l2).getPoint3d();
      Point3d r1Coord = mol.getAtom(r1).getPoint3d();
      Point3d r2Coord = mol.getAtom(r2).getPoint3d();
     
      // if there are no coordinates then return null
      if (l1Coord == null || l2Coord == null || r1Coord == null || r2Coord == null) return null;
     
      // get the 2D coordinates of the atoms
      Point2d l1Coord2D = new Point2d(l1Coord.x, l1Coord.y);
      Point2d l2Coord2D = new Point2d(l2Coord.x, l2Coord.y);
      Point2d r1Coord2D = new Point2d(r1Coord.x, r1Coord.y);
      Point2d r2Coord2D = new Point2d(r2Coord.x, r2Coord.y);
     
      // get the 2D/3D geometry
      GeometricParity geometric = new GeometricParity(l1Coord2D, l2Coord2D, r1Coord2D, r2Coord2D);
     
      return geometric;         
 }","static GeometricParity geometric(IAtomContainer mol, int l, int r, int l1, int l2, int r1, int r2){
     
      // get the coordinates
      Point3d l1c = mol.getAtom(l1).getPoint3d();
      Point3d l2c = mol.getAtom(l2).getPoint3d();
      Point3d r1c = mol.getAtom(r1).getPoint3d();
      Point3d r2c = mol.getAtom(r2).getPoint3d();
     
      // if the coordinates are not present then return null
      if (l1c == null || l2c == null || r1c == null || r2c == null) return null;
     
      // create the geometry
      return new GeometricParity(l1c, l2c, r1c, r2c);           
 }","static GeometricParity geometric(IAtomContainer mol, int l, int r, int l1, int l2, int r1, int r2){
     
      // get the coordinates
      Point3d l1c = mol.getAtom(l1).getPoint3d();
      Point3d l2c = mol.getAtom(l2).getPoint3d();
      Point3d r1c = mol.getAtom(r1).getPoint3d();
      Point3d r2c = mol.getAtom(r2).getPoint3d();
     
      // if all coordinates are null then we can't encode
      if (l1c == null || l2c == null || r1c == null || r2c == null) return null;
     
      // if all coordinates are the same then we can't encode
      if (l1c.equals(l2c) && r1c.equals(r2c)) return null;
     
      // if all coordinates are the same then we can't encode
      if (l1c.equals(r1c) && l2c.equals(r2c)) return null;
     
      // if all coordinates are the same then we can't encode
      if (l1c.equals(r2c) && l2c.equals(r1c)) return null;
     
      // if all coordinates are the same then we can't encode
      if (l1c.equals(r2c) && r1c.equals(l2c)) return null;
     
      // if all coordinates are the same then we can't encode
      if (l1c.equals(r1c) && r2c.equals(l2c)) return null;
     
      // if all coordinates are the same then we can't encode
      if (l1c.equals(r1c) && r2c.equals(l2c)) return null;
     
      // if all coordinates are the same then we can't encode
      if (l1c.equals(r2c) && r1c.equals(l2c)) return null;
     
      // if all coordinates are the same then we can't encode
      if (l1c.equals(r1c) &&            
 }",Syntax Error,NOT PASS,Syntax Error,NOT PASS,None,  0.5174414929307054,None,  0.44722874553241143,None,None,142.0,0.5748987854251012,159.0,0.6437246963562753,158.0,0.6396761133603239,108.0,0.45188284518828453,51.0,0.20647773279352227,138.0,0.5774058577405857,7.0,0.4375,0.0,0.0,5.0,0.3125
880,weblogic-kubernetes-operator,"static Map<String, String> loadContents(Path rootDir) throws IOException{
    try (Stream<Path> walk = Files.walk(rootDir, 1)) {
        return walk.filter(path -> !Files.isDirectory(path)).collect(Collectors.toMap(FileGroupReader::asString, FileGroupReader::readContents));
    }
}",loadContents,oracle/kubernetes/operator/helpers/FileGroupReader.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/FileGroupReader.java,"/**
   * Given a file path, loads the contents of the files into a map.
   *
   * @param rootDir the path to the top-level directory
   * @return a map of file names to string contents.
   * @throws IOException if an error occurs during the read
   */",45-57,"('loadContents', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,15.0,"Given a file path, loads the contents of the files into a map.",Loads the contents of the files into a map from a given file path,Load the contents of the files into a map.,0.28029309509853,"Because of a path to the file, loads the contents of the files into a map."," static Map<String, String> loadContents(Path rootDir) throws IOException{
    return Files.walk(rootDir)
      .filter(Files::isRegularFile)
      .map(FileGroupReader::getFileName)
      .collect(Collectors.toMap(Function.identity(), FileGroupReader::readFile));
  }"," static Map<String, String> loadContents(Path rootDir) throws IOException{
    return Files.walk(rootDir)
      .filter(Files::isRegularFile)
      .map(FileGroupReader::getFileName)
      .collect(Collectors.toMap(Function.identity(), FileGroupReader::readFile));
  }"," static Map<String, String> loadContents(Path rootDir) throws IOException{
    return Files.walk(rootDir)
        .filter(Files::isRegularFile)
        .map(FileGroupReader::uriToPath)
        .map(FileGroupReader::getFileName)
        .map(FileGroupReader::getFileContents)
        .collect(Collectors.toMap(Function.identity(), Function.identity()));
  }"," static Map<String, String> loadContents(Path rootDir) throws IOException{
    return Files.walk(rootDir)
        .filter(Files::isRegularFile)
        .map(FileGroupReader::getFileName)
        .map(FileGroupReader::getFileContents)
        .collect(Collectors.toMap(Function.identity(), Function.identity()));   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4675609612776779,  0.4675609612776779,  0.5577492601017286,  0.5494409160090999,29.0,0.4264705882352941,29.0,0.4264705882352941,36.0,0.5294117647058824,40.0,0.547945205479452,0.0,0.0,12.0,0.18181818181818182,19.0,0.2602739726027397,11.0,0.7333333333333333,6.0,0.35294117647058826,5.0,0.35714285714285715
881,egeria,"public Optional<EntityDetail> findEntity(String userId, String qualifiedName, String entityTypeName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    final String methodName = ""findEntity"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateName(qualifiedName, CommonMapper.QUALIFIED_NAME_PROPERTY_NAME, methodName);
    qualifiedName = repositoryHelper.getExactMatchRegex(qualifiedName);
    InstanceProperties properties = repositoryHelper.addStringPropertyToInstance(serviceName, null, CommonMapper.QUALIFIED_NAME_PROPERTY_NAME, qualifiedName, methodName);
    TypeDef entityTypeDef = repositoryHelper.getTypeDefByName(userId, entityTypeName);
    Optional<EntityDetail> retrievedEntity = Optional.ofNullable(repositoryHandler.getUniqueEntityByName(userId, qualifiedName, CommonMapper.QUALIFIED_NAME_PROPERTY_NAME, properties, entityTypeDef.getGUID(), entityTypeDef.getName(), methodName));
    log.trace(""Searching for entity with qualifiedName: {}. Result is {}"", qualifiedName, retrievedEntity.map(InstanceHeader::getGUID).orElse(null));
    return retrievedEntity;
}",findEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCommonHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCommonHandler.java,"/**
     * Find out if the entity is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId         the name of the calling user
     * @param qualifiedName  the qualifiedName name of the entity to be searched
     * @param entityTypeName the type name of the entity
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",160-195,"('findEntity', {'INSTRUCTION': {'covered': 59, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",159.0,12.0,Find out if the entity is already stored in the repository.,Check if the given entity is already stored in the repository,"If the entity is already in the repository, you should find out.",0.205241507725891,Check if the entity is already stored in the repository.," public Optional<EntityDetail> findEntity(String userId, String qualifiedName, String entityTypeName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        final String methodName = ""findEntity"";
    
        TypeDef entityTypeDef = repositoryHelper.getTypeDefByName(userId, entityTypeName);
    
        return repositoryHandler.getEntityByGUID(userId, qualifiedName, entityTypeDef.getGUID(), entityTypeName, methodName);       
 }"," public Optional<EntityDetail> findEntity(String userId, String qualifiedName, String entityTypeName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        final String methodName = ""findEntity"";
    
        TypeDef entityTypeDef = repositoryHelper.getTypeDefByName(userId, entityTypeName);
    
        return repositoryHandler.getEntityByGUID(userId, qualifiedName, entityTypeDef.getGUID(), entityTypeName, methodName);       
 }"," public Optional<EntityDetail> findEntity(String userId, String qualifiedName, String entityTypeName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        final String methodName = ""findEntity"";
    
        TypeDef entityTypeDef = repositoryHelper.getTypeDefByName(userId, entityTypeName);
    
        return repositoryHandler.findEntityByGUID(userId, qualifiedName, entityTypeDef.getGUID(), entityTypeName, methodName);      
 }"," public Optional<EntityDetail> findEntity(String userId, String qualifiedName, String entityTypeName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
        final String methodName = ""findEntity"";
    
        TypeDef entityTypeDef = repositoryHelper.getTypeDefByName(userId, entityTypeName);
    
        return repositoryHandler.findEntityByGUID(userId, qualifiedName, entityTypeDef.getGUID(), entityTypeName, methodName);      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.29420635514663995,  0.29420635514663995,  0.29420635514663995,  0.29420635514663995,100.0,0.625,100.0,0.625,100.0,0.625,100.0,0.625,0.0,0.0,1.0,0.015873015873015872,1.0,0.015873015873015872,4.0,0.3333333333333333,2.0,0.16666666666666666,9.0,0.6923076923076923
882,cdk,"private void mapInputMoleculeToInchiMolgraph(IAtomContainer inchiMolGraph, IAtomContainer mol) throws CDKException{
    Iterator<Map<IAtom, IAtom>> iter = org.openscience.cdk.isomorphism.VentoFoggia.findIdentical(inchiMolGraph, AtomMatcher.forElement(), BondMatcher.forAny()).matchAll(mol).limit(1).toAtomMap().iterator();
    if (iter.hasNext()) {
        for (Map.Entry<IAtom, IAtom> e : iter.next().entrySet()) {
            IAtom src = e.getKey();
            IAtom dst = e.getValue();
            String position = src.getID();
            dst.setID(position);
            LOGGER.debug(""Mapped InChI "", src.getSymbol(), "" "", src.getID(), "" to "", dst.getSymbol(), "" "" + dst.getID());
        }
    } else {
        throw new IllegalArgumentException(CANSMI.create(inchiMolGraph) + "" "" + CANSMI.create(mol));
    }
}",mapInputMoleculeToInchiMolgraph,org/openscience/cdk/tautomers/InChITautomerGenerator.java,/tool/tautomer/src/main/java/org/openscience/cdk/tautomers/InChITautomerGenerator.java,"/**
     * Atom-atom mapping of the input molecule to the bare container constructed from the InChI connection table.
     * This makes it possible to map the positions of the mobile hydrogens in the InChI back to the input molecule.
     * @param inchiMolGraph molecule (bare) as defined in InChI
     * @param mol user input molecule
     * @throws CDKException
     */",315-342,"('mapInputMoleculeToInchiMolgraph', {'INSTRUCTION': {'covered': 84, 'missed': 18}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",199.0,17.0,Atom-atom mapping of the input molecule to the bare container constructed from the InChI connection table.,Create an Atom-atom mapping of the input molecule to the bare container constructed from the InChI connection table,The input molecule is mapped to the bare container from the InChI connection table.,1.59036224566433,Atom-atom mapping of the input molecule to the bare container built from the InChI connection table.,Not Valid,Not Valid,"private void mapInputMoleculeToInchiMolgraph(IAtomContainer inchiMolGraph, IAtomContainer mol) throws CDKException{
        for (IAtom atom : mol.atoms()) {
            IAtom inchiAtom = inchiMolGraph.getAtom(Integer.valueOf(atom.getID()));
            if (inchiAtom != null) {
                inchiAtom.setSymbol(atom.getSymbol());
                inchiAtom.setPoint3d(atom.getPoint3d());
            } else {
                throw new CDKException(""Could not find atom in InChI connection table for atom "" + atom.getSymbol()
                        + "" with ID "" + atom.getID());
            }
        }       
 }"," private void mapInputMoleculeToInchiMolgraph(IAtomContainer inchiMolGraph, IAtomContainer mol) throws CDKException{
        for (IAtom atom : mol.atoms()) {
            IAtom inchiAtom = inchiMolGraph.getAtom(Integer.valueOf(atom.getID()));
            if (inchiAtom != null) {
                inchiMolGraph.removeAtom(inchiAtom);
                inchiMolGraph.addAtom(atom);
            }
        }       
 }",Not Valid,Not Valid,NOT PASS,NOT PASS,None,None,  0.19242548262081605,  0.22266047595291816,None,None,None,None,153.0,0.765,138.0,0.69,None,None,68.0,0.9855072463768116,100.0,0.9900990099009901,3.0,0.15789473684210525,1.0,0.058823529411764705,7.0,0.4117647058823529
883,dcache,"public boolean awaitChangeUntil(int value, Date deadline) throws InterruptedException{
    _lock.lock();
    try {
        inLock();
        return _counter != value || _updated.awaitUntil(deadline);
    } finally {
        _lock.unlock();
    }
}",awaitChangeUntil,org/dcache/util/AtomicCounter.java,/modules/common/src/main/java/org/dcache/util/AtomicCounter.java,"/**
     * Waits for the counter to change to a value different from
     * <code>value</code>.
     * <p>
     * The method returns when one of the following happens:
     * <p>
     * * The current counter value is different from the
     * <code>value</code> argument; or
     * <p>
     * * Some other thread invokes the <code>increment</code> method for this AtomicCounter; or
     * <p>
     * * Some other thread interrupts the current thread; or
     * <p>
     * * The specified deadline elapses; or
     * <p>
     * * A ""spurious wakeup"" occurs.
     *
     * @param value    the value to wait for the counter to change away from
     * @param deadline the absolute time to wait until
     * @return true if the counter has a different value than {@code value} upon return
     * @throw InterruptedException if the current thread is interrupted
     */",45-76,"('awaitChangeUntil', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,19.0,Waits for the counter to change to a value different from  <code>value</code>.,Wait that the counter changes to the given value ,Waits for the counter to change to a different value.,0.525471010106787,Waits for the counter to change to a value other than the <code>value</code>.," public boolean awaitChangeUntil(int value, Date deadline) throws InterruptedException{
        _lock.lock();
        try {
            inLock();
            while (_counter == value) {
                if (!_updated.awaitUntil(deadline)) {
                    return false;
                }
            }
            return true;
        } finally {
            _lock.unlock();
        }
    }"," public boolean awaitChangeUntil(int value, Date deadline) throws InterruptedException{
        _lock.lock();
        try {
            inLock();
            while (_counter != value) {
                if (!_updated.awaitUntil(deadline)) {
                    return false;
                }
            }
            return true;
        } finally {
            _lock.unlock();
        }
    }"," public boolean awaitChangeUntil(int value, Date deadline) throws InterruptedException{
        _lock.lock();
        try {
            inLock();
            while (_counter == value) {
                if (!_updated.awaitUntil(deadline)) {
                    return false;
                }
            }
            return true;
        } finally {
            _lock.unlock();
        }
    }"," public boolean awaitChangeUntil(int value, Date deadline) throws InterruptedException{
        _lock.lock();
        try {
            inLock();
            while (_counter == value) {
                if (!_updated.awaitUntil(deadline)) {
                    return false;
                }
            }
            return true;
        } finally {
            _lock.unlock();
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8182374736808655,  0.8269250960624193,  0.8182374736808655,  0.8182374736808655,17.0,0.2698412698412698,16.0,0.25396825396825395,17.0,0.2698412698412698,17.0,0.2698412698412698,1.0,0.015873015873015872,0.0,0.0,0.0,0.0,9.0,0.6923076923076923,3.0,0.21428571428571427,3.0,0.23076923076923078
884,cdk,"public static Rectangle2D shiftReactionVertical(IReaction reaction, Rectangle2D bounds, Rectangle2D last, double gap){
    if (last.getMaxY() + gap >= bounds.getMinY()) {
        double yShift = bounds.getHeight() + last.getHeight() + gap;
        Vector2d shift = new Vector2d(0, yShift);
        List<IAtomContainer> containers = ReactionManipulator.getAllAtomContainers(reaction);
        for (IAtomContainer container : containers) {
            translate2D(container, shift);
        }
        return new Rectangle2D.Double(bounds.getX(), bounds.getY() + yShift, bounds.getWidth(), bounds.getHeight());
    } else {
        return bounds;
    }
}",shiftReactionVertical,org/openscience/cdk/geometry/GeometryTools.java,/legacy/src/main/java/org/openscience/cdk/geometry/GeometryTools.java,"/**
     * Shift the containers in a reaction vertically upwards to not overlap
     * with the reference Rectangle2D. The shift is such that the given
     * gap is realized, but only if the reactions are actually overlapping.
     *
     * @param reaction the reaction to shift
     * @param bounds   the bounds of the reaction to shift
     * @param last     the bounds of the last reaction
     * @return         the Rectangle2D of the shifted reaction
     */",1699-1723,"('shiftReactionVertical', {'INSTRUCTION': {'covered': 53, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",133.0,16.0,Shift the containers in a reaction vertically upwards to not overlap  with the reference Rectangle2D.,Shift the given containers vertically upwards to not overlap with the reference Rectangle2D,The containers should be shifted vertically upwards to not overlap with the reference.,0.353401222210984,Move the containers vertically upwards so as not to overlap the Rectangle2D reference.,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,5.0,0.3125,10.0,0.625,7.0,0.4375
885,cdk,"public void addSingletonCell(int element){
    SortedSet<Integer> cell = new TreeSet<Integer>();
    cell.add(element);
    this.cells.add(cell);
}",addSingletonCell,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,"/**
     * Add a new singleton cell to the end of the partition containing only
     * this element.
     *
     * @param element the element to add in its own cell
     */",309-319,"('addSingletonCell', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,16.0,Add a new singleton cell to the end of the partition containing only  this element.,Add a singleton to the end of the partition that contains this element only.,The partition contains only one element and should be added with a new singleton cell.,0.5637347271794,Add a new singleton cell to the end of the partition containing only this item.," public void addSingletonCell(int element){
        SortedSet<Integer> cell = new TreeSet<Integer>();
        cell.add(element);
        this.cells.add(cell);
    }"," public void addSingletonCell(int element){
        SortedSet<Integer> cell = new TreeSet<Integer>();
        cell.add(element);
        this.cells.add(cell);
    }"," public void addSingletonCell(int element){
        SortedSet<Integer> cell = new TreeSet<Integer>();
        cell.add(element);
        this.cells.add(cell);
    }"," public void addSingletonCell(int element){
        SortedSet<Integer> cell = new TreeSet<Integer>();
        cell.add(element);
        this.cells.add(cell);
    }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,6.0,0.375,1.0,0.0625,15.0,0.9375
886,dcache,"public static Map<PnfsId, EnumSet<EventType>> fromZkData(byte[] data){
    checkArgument(data.length > 1, ""Too little data"");
    checkArgument(data[0] == 0, ""Wrong format"");
    Map<PnfsId, EnumSet<EventType>> deserialised = new HashMap<>();
    int index = 1;
    while (index < data.length) {
        checkArgument(data.length - index >= 3, ""Too little data for bitmask"");
        short bitmask = (short) (data[index++] << 8 | data[index++] & 0xFF);
        EnumSet<EventType> eventTypes = Arrays.stream(EventType.values()).filter(t -> (bitmask & 1 << t.ordinal()) != 0).collect(Collectors.toCollection(() -> EnumSet.noneOf(EventType.class)));
        byte length = data[index++];
        checkArgument(data.length - index >= length, ""Too little data for PNFSID"");
        PnfsId id = new PnfsId(BaseEncoding.base16().encode(data, index, length));
        index += length;
        deserialised.put(id, eventTypes);
        LOGGER.debug(""Adding id={} bitmask={} types={}"", id, bitmask, eventTypes);
    }
    return deserialised;
}",fromZkData,diskCacheV111/namespace/EventNotifier.java,/modules/dcache/src/main/java/diskCacheV111/namespace/EventNotifier.java,"/**
     * Convert a binary representation back into an event receiver's list of desired events.
     *
     * @param data the binary data
     * @return a Map between the target and its set of desired event types.
     * @throws IllegalArgumentException if the data is badly formatted.
     */",143-173,"('fromZkData', {'INSTRUCTION': {'covered': 115, 'missed': 4}, 'BRANCH': {'covered': 6, 'missed': 4}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",242.0,15.0,Convert a binary representation back into an event receiver's list of desired events.,Convert a binary representation back into list of desired events of the event receiver.,A receiver wants a list of desired events.,0.532418879175502,Convert a binary representation back into a list of events desired by an event receiver.,"public static Map<PnfsId, EnumSet<EventType>> fromZkData(byte[] data){
        Map<PnfsId, EnumSet<EventType>> entries = new ConcurrentHashMap<>();
        ByteArrayInputStream in = new ByteArrayInputStream(data);
        int format = in.read();
        checkState(format == 0, ""Unsupported format: %d"", format);
        while (in.available() > 0) {
            short bitmask = (short) ((in.read() & 0xff) << 8 | in.read() & 0xff);
            int pnfsidLength = in.read();
            byte[] pnfsid = new byte[pnfsidLength];
            in.read(pnfsid);
            PnfsId id = PnfsId.valueOf(BaseEncoding.base16().encode(pnfsid));
            EnumSet<EventType> events = EnumSet.noneOf(EventType.class);
            for (EventType event : EventType.values()) {
                if ((bitmask & (1 << event.ordinal())) != 0) {
                    events.add(event);
                }
            }
            entries.put(id, events);
            LOGGER.debug(""decoded id={} bitmask={}"", id, bitmask);
        }
        return entries;     
 }","public static Map<PnfsId, EnumSet<EventType>> fromZkData(byte[] data){
        ByteArrayInputStream in = new ByteArrayInputStream(data);
        int format = in.read();
        checkState(format == 0, ""Unsupported format: %d"", format);
        Map<PnfsId, EnumSet<EventType>> entries = new ConcurrentHashMap<>();
        while (in.available() > 0) {
            short bitmask = (short) (in.read() << 8 | in.read());
            int pnfsidLength = in.read();
            byte[] pnfsid = new byte[pnfsidLength];
            in.read(pnfsid);
            PnfsId id = PnfsId.valueOf(BaseEncoding.base16().encode(pnfsid));
            EnumSet<EventType> events = EnumSet.noneOf(EventType.class);
            for (EventType event : EventType.values()) {
                if ((bitmask & (1 << event.ordinal())) != 0) {
                    events.add(event);
                }
            }
            entries.put(id, events);
            LOGGER.debug(""decoded id={} bitmask={}"", id, bitmask);
        }
        return entries;     
 }","public static Map<PnfsId, EnumSet<EventType>> fromZkData(byte[] data){
        ByteArrayInputStream in = new ByteArrayInputStream(data);
        int format = in.read();
        checkState(format == 0, ""unsupported format %d"", format);
        Map<PnfsId, EnumSet<EventType>> entries = new HashMap<>();
        while (in.available() > 0) {
            short bitmask = (short) (in.read() << 8);
            bitmask |= in.read();
            int length = in.read();
            byte[] pnfsid = new byte[length];
            in.read(pnfsid);
            PnfsId id = new PnfsId(BaseEncoding.base16().encode(pnfsid));
            EnumSet<EventType> events = EnumSet.noneOf(EventType.class);
            for (EventType event : EventType.values()) {
                if ((bitmask & (1 << event.ordinal())) != 0) {
                    events.add(event);
                }
            }
            entries.put(id, events);
            LOGGER.debug(""decoded id={} bitmask={}"", id, bitmask);
        }
        return entries;     
 }","public static Map<PnfsId, EnumSet<EventType>> fromZkData(byte[] data){
        ByteArrayInputStream in = new ByteArrayInputStream(data);
        int format = in.read();
        checkState(format == 0, ""unsupported format %d"", format);
        Map<PnfsId, EnumSet<EventType>> entries = new HashMap<>();
        while (in.available() > 0) {
            short bitmask = (short) (in.read() << 8);
            bitmask |= in.read();
            int pnfsidLength = in.read();
            byte[] pnfsid = new byte[pnfsidLength];
            in.read(pnfsid);
            PnfsId id = PnfsId.valueOf(BaseEncoding.base16().encode(pnfsid));
            EnumSet<EventType> events = EnumSet.noneOf(EventType.class);
            for (EventType event : EventType.values()) {
                if ((bitmask & (1 << event.ordinal())) != 0) {
                    events.add(event);
                }
            }
            entries.put(id, events);
            LOGGER.debug(""decoded id={} bitmask={}"", id, bitmask);
        }
        return entries;     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4099849051175763,  0.4343200609298532,  0.4416402731760195,  0.4356834470684224,169.0,0.6954732510288066,153.0,0.6296296296296297,153.0,0.6296296296296297,153.0,0.6296296296296297,42.0,0.1810344827586207,46.0,0.19827586206896552,51.0,0.21982758620689655,7.0,0.4666666666666667,8.0,0.5,9.0,0.6428571428571429
887,cdk,"private static void exch(long[] values, int i, int j){
    long k = values[i];
    values[i] = values[j];
    values[j] = k;
}",exch,org/openscience/cdk/graph/invariant/InChINumbersTools.java,/storage/inchi/src/main/java/org/openscience/cdk/graph/invariant/InChINumbersTools.java,"/**
     * Exchange the elements at index i with that at index j.
     *
     * @param values an array of values
     * @param i an index
     * @param j another index
     */",193-204,"('exch', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",43.0,12.0,Exchange the elements at index i with that at index j.,Replace the elements at i with the ones at j.,Exchange elements at index i and j.,0.163197373453167,Swap the items in index i with those in index j.," private static void exch(long[] values, int i, int j){
        long temp = values[i];
        values[i] = values[j];
        values[j] = temp;
    }"," private static void exch(long[] values, int i, int j){
        long tmp = values[i];
        values[i] = values[j];
        values[j] = tmp;
    }"," private static void exch(long[] values, int i, int j){
        long tmp = values[i];
        values[i] = values[j];
        values[j] = tmp;
    }"," private static void exch(long[] values, int i, int j){
        long tmp = values[i];
        values[i] = values[j];
        values[j] = tmp;
    }",PASS,PASS,PASS,PASS,  0.9424891384201075,  0.9424891384201075,  0.9424891384201075,  0.9424891384201075,2.0,0.045454545454545456,2.0,0.045454545454545456,2.0,0.045454545454545456,2.0,0.045454545454545456,2.0,0.045454545454545456,2.0,0.045454545454545456,2.0,0.045454545454545456,5.0,0.4166666666666667,5.0,0.4166666666666667,5.0,0.4166666666666667
888,cron-utils,"private void buildMappings(final CronDefinition from, final CronDefinition to){
    final Map<CronFieldName, FieldDefinition> sourceFieldDefinitions = getFieldDefinitions(from);
    final Map<CronFieldName, FieldDefinition> destFieldDefinitions = getFieldDefinitions(to);
    boolean startedDestMapping = false;
    boolean startedSourceMapping = false;
    for (final CronFieldName name : CronFieldName.values()) {
        final FieldDefinition destinationFieldDefinition = destFieldDefinitions.get(name);
        final FieldDefinition sourceFieldDefinition = sourceFieldDefinitions.get(name);
        if (destinationFieldDefinition != null) {
            startedDestMapping = true;
        }
        if (sourceFieldDefinition != null) {
            startedSourceMapping = true;
        }
        if (startedDestMapping && destinationFieldDefinition == null) {
            break;
        }
        if (!startedSourceMapping && destinationFieldDefinition != null) {
            mappings.put(name, returnOnZeroExpression(name));
        }
        if (startedSourceMapping && sourceFieldDefinition == null && destinationFieldDefinition != null) {
            mappings.put(name, returnAlwaysExpression(name));
        }
        if (sourceFieldDefinition == null || destinationFieldDefinition == null) {
            continue;
        }
        if (CronFieldName.DAY_OF_WEEK.equals(name)) {
            mappings.put(name, dayOfWeekMapping((DayOfWeekFieldDefinition) sourceFieldDefinition, (DayOfWeekFieldDefinition) destinationFieldDefinition));
        } else if (CronFieldName.DAY_OF_MONTH.equals(name)) {
            mappings.put(name, dayOfMonthMapping(sourceFieldDefinition, destinationFieldDefinition));
        } else {
            mappings.put(name, returnSameExpression());
        }
    }
}",buildMappings,com/cronutils/mapper/CronMapper.java,/src/main/java/com/cronutils/mapper/CronMapper.java,"/**
     * Builds functions that map the fields from source CronDefinition to target.
     *
     * @param from - source CronDefinition
     * @param to   - target CronDefinition
     */",175-217,"('buildMappings', {'INSTRUCTION': {'covered': 115, 'missed': 0}, 'BRANCH': {'covered': 26, 'missed': 2}, 'LINE': {'covered': 25, 'missed': 0}, 'COMPLEXITY': {'covered': 13, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",262.0,12.0,Builds functions that map the fields from source CronDefinition to target.,Builds procedures that associate the fields from the source CronDefinition to the target.,Functions that map the fields from source to target were built.,0.361086964306062,Generates functions that map fields from the source CronDefinition to the target.," private void buildMappings(final CronDefinition from, final CronDefinition to){
        for (final CronFieldName name : CronFieldName.values()) {
            if (from.retrieveField(name) != null) {
                mappings.put(name, field -> {
                    final CronField fromField = from.retrieveField(name);
                    final CronField toField = to.retrieveField(name);
                    if (fromField.getExpression() instanceof Always) {
                        return toField;
                    } else {
                        return new CronField(toField.getName(), fromField.getExpression(), toField.getConstraints());
                    }
                });
            }
        }
    }"," private void buildMappings(final CronDefinition from, final CronDefinition to){
        for (final CronFieldName name : CronFieldName.values()) {
            if (from.retrieve(name) != null) {
                mappings.put(name, field -> {
                    final CronField fromField = from.retrieve(name);
                    final CronField toField = to.retrieve(name);
                    if (fromField.getExpression() instanceof Always) {
                        return toField;
                    } else {
                        return new CronField(toField.getName(), fromField.getExpression(), toField.getConstraints());
                    }
                });
            }
        }
    }"," private void buildMappings(final CronDefinition from, final CronDefinition to){
        for (final CronFieldName name : CronFieldName.values()) {
            if (from.retrieve(name) != null && to.retrieve(name) != null) {
                mappings.put(name, fromField(name, to));
            }
        }       
 }"," private void buildMappings(final CronDefinition from, final CronDefinition to){
        for (final CronFieldName name : CronFieldName.values()) {
            if (from.retrieve(name) != null && to.retrieve(name) != null) {
                mappings.put(name, cronField -> {
                    final CronField fromField = from.retrieve(name);
                    final CronField toField = to.retrieve(name);
                    final CronFieldName toName = toField.getName();
                    final CronFieldName fromName = fromField.getName();
                    final CronFieldExpression fromExpression = fromField.getExpression();
                    final CronFieldExpression toExpression = toField.getExpression();
                    final CronFieldConstraints toConstraints = toField.getConstraints();
                    final CronFieldConstraints fromConstraints = fromField.getConstraints();
                    final CronFieldExpression expression;
                    if (fromExpression instanceof Always) {
                        expression = toExpression;
                    } else if (toExpression instanceof Always) {
                        expression = fromExpression;
                    } else if (fromExpression instanceof QuestionMark) {
                        expression = toExpression;
                    } else if (toExpression instanceof QuestionMark) {
                        expression = fromExpression;
                    } else {
                        expression = fromExpression;
                    }
                    final CronFieldConstraints constraints;
                    if (fromConstraints instanceof Always) {
                        constraints = toConstraints;
                    } else if (toConstraints instanceof Always) {
                        constraints = fromConstraints;
                    } else if (fromConstraints instanceof QuestionMark) {
                        constraints = toConstraints;
                    } else if (toConstraints instanceof QuestionMark) {
                        constraints = fromConstraints;
                    } else {
                        constraints = fromConstraints;
                    }
                    return new CronField(toName, expression, constraints);
                });
            }
        }
    }       ",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.23351734593285217,  0.23351734593285217,  0.3150988187115411,  0.16372453593562136,191.0,0.7262357414448669,191.0,0.7262357414448669,215.0,0.7678571428571429,205.0,0.779467680608365,3.0,0.02564102564102564,184.0,0.6571428571428571,62.0,0.5299145299145299,4.0,0.2857142857142857,4.0,0.3076923076923077,6.0,0.5
889,cdk,"boolean hasPriority(int focus, int i, int j){
    if (tetrahedralElements[i] == null && tetrahedralElements[j] != null)
        return true;
    if (tetrahedralElements[i] != null && tetrahedralElements[j] == null)
        return false;
    if (doubleBondElements[i] == null && doubleBondElements[j] != null)
        return true;
    if (doubleBondElements[i] != null && doubleBondElements[j] == null)
        return false;
    IAtom iAtom = container.getAtom(i);
    IAtom jAtom = container.getAtom(j);
    boolean iIsSp3 = isSp3Carbon(iAtom, graph[i].length);
    boolean jIsSp3 = isSp3Carbon(jAtom, graph[j].length);
    if (iIsSp3 != jIsSp3)
        return !iIsSp3;
    if (tetrahedralElements[i] == null && tetrahedralElements[j] != null)
        return true;
    if (tetrahedralElements[i] != null && tetrahedralElements[j] == null)
        return false;
    boolean iCyclic = focus >= 0 ? ringSearch.cyclic(focus, i) : ringSearch.cyclic(i);
    boolean jCyclic = focus >= 0 ? ringSearch.cyclic(focus, j) : ringSearch.cyclic(j);
    if (!iCyclic && jCyclic)
        return true;
    if (iCyclic && !jCyclic)
        return false;
    if (iAtom.getAtomicNumber() > 0 && jAtom.getAtomicNumber() == 0)
        return true;
    if (iAtom.getAtomicNumber() == 0 && jAtom.getAtomicNumber() > 0)
        return false;
    final int iDegree = graph[i].length;
    int iElem = iAtom.getAtomicNumber();
    final int jDegree = graph[j].length;
    int jElem = jAtom.getAtomicNumber();
    if (iElem == 6)
        iElem = 256;
    if (jElem == 6)
        jElem = 256;
    if (iDegree == 1 && jDegree > 1)
        return true;
    if (jDegree == 1 && iDegree > 1)
        return false;
    if (iElem < jElem)
        return true;
    if (iElem > jElem)
        return false;
    if (iDegree < jDegree)
        return true;
    if (iDegree > jDegree)
        return false;
    return false;
}",hasPriority,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,"/**
     * Does the atom at index {@code i} have priority over the atom at index
     * {@code j} for the tetrahedral atom {@code focus}.
     *
     * @param focus tetrahedral centre (or -1 if double bond)
     * @param i     adjacent atom index
     * @param j     adjacent atom index
     * @return whether atom i has priority
     */",1065-1133,"('hasPriority', {'INSTRUCTION': {'covered': 217, 'missed': 18}, 'BRANCH': {'covered': 58, 'missed': 10}, 'LINE': {'covered': 35, 'missed': 2}, 'COMPLEXITY': {'covered': 26, 'missed': 9}, 'METHOD': {'covered': 1, 'missed': 0}})",421.0,32.0,Does the atom at index {@code i} have priority over the atom at index  {@code j} for the tetrahedral atom {@code focus}.,Checks if the atom at index {@code i} has priority over the one at index {@code j} for the tetrahedral atom {@code focus}.,Does the atom at index @code i have priority over the atom at index @code j for the tetrahedral atom?,0.664531766827107,Does the atom with the index {@code i} have priority over the atom at the index {@code j} for the tetrahedral atom {@code focus}.," boolean hasPriority(int focus, int i, int j){
        if (i == focus) return true;
        if (j == focus) return false;
        if (i < j) return true;
        if (i > j) return false;
        return i < j;
    }"," boolean hasPriority(int focus, int i, int j){
        if (i == focus) return true;
        if (j == focus) return false;
        if (i < j) return true;
        if (i > j) return false;
        if (i == j) return false;
        throw new IllegalArgumentException(""invalid indices"");
    }"," boolean hasPriority(int focus, int i, int j){
        // if the focus is the same as the atom at index i, then it has priority
        if (i == focus) return true;
        // if the focus is the same as the atom at index j, then it has priority
        if (j == focus) return false;
        // if the focus is not the same as either atom, then the atom at index i has priority
        return true;
    }"," boolean hasPriority(int focus, int i, int j){
        if (i == focus) return true;
        if (j == focus) return false;
        if (i == j) return true;
        if (i < j) return true;
        return false;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.10916860354120841,  0.11216225137057709,  0.1055358322498765,  0.08961801705424477,371.0,0.8791469194312796,363.0,0.8601895734597157,371.0,0.8791469194312796,387.0,0.9170616113744076,13.0,0.19402985074626866,6.0,0.10714285714285714,20.0,0.35714285714285715,4.0,0.16666666666666666,3.0,0.12,7.0,0.30434782608695654
890,egeria,"public Optional<EntityDetail> findPortImplementationEntity(String userId, String qualifiedName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, PORT_IMPLEMENTATION_TYPE_NAME);
}",findPortImplementationEntity,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,"/**
     * Find out if the PortImplementation object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",331-347,"('findPortImplementationEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,13.0,Find out if the PortImplementation object is already stored in the repository.,Checks whether the PortImplementation object is already stored in the repository. It relies on the fully qualified name to get the entity.,"If the PortImplementation object is already in the repository, you should find it.",0.173286932716251,Check if the PortImplementation object is already stored in the repository.," public Optional<EntityDetail> findPortImplementationEntity(String userId, String qualifiedName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        return dataEngineCommonHandler.findEntity(userId, qualifiedName, PORT_IMPLEMENTATION_TYPE_NAME);        
 }"," public Optional<EntityDetail> findPortImplementationEntity(String userId, String qualifiedName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        final String methodName = ""findPortImplementationEntity"";
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateName(qualifiedName, QUALIFIED_NAME_PROPERTY_NAME, methodName);
    
        return dataEngineCommonHandler.findEntity(userId, qualifiedName, PORT_IMPLEMENTATION_TYPE_NAME);        
 }"," public Optional<EntityDetail> findPortImplementationEntity(String userId, String qualifiedName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        final String methodName = ""findPortImplementationEntity"";
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateName(qualifiedName, QUALIFIED_NAME_PROPERTY_NAME, methodName);
    
        return dataEngineCommonHandler.findEntityByGUID(userId, qualifiedName, PORT_IMPLEMENTATION_TYPE_NAME);      
 }"," public Optional<EntityDetail> findPortImplementationEntity(String userId, String qualifiedName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        final String methodName = ""findPortImplementationEntity"";
        invalidParameterHandler.validateUserId(userId, methodName);
        invalidParameterHandler.validateName(qualifiedName, QUALIFIED_NAME_PROPERTY_NAME, methodName);
    
        return dataEngineCommonHandler.findEntityByGUID(userId, qualifiedName, PORT_IMPLEMENTATION_TYPE_NAME);      
 }",PASS,NOT PASS,NOT PASS,NOT PASS,  1.0,  0.8319631334601366,  0.8001797799583297,  0.8001797799583297,0.0,0.0,26.0,0.43333333333333335,27.0,0.45,27.0,0.45,26.0,0.43333333333333335,27.0,0.45,27.0,0.45,14.0,0.6086956521739131,2.0,0.15384615384615385,9.0,0.6428571428571429
892,cdk,"public static boolean checkIfAllLigandsAreDifferent(ILigand[] ligands){
    for (int i = 0; i < (ligands.length - 1); i++) {
        if (cipRule.compare(ligands[i], ligands[i + 1]) == 0)
            return false;
    }
    return true;
}",checkIfAllLigandsAreDifferent,org/openscience/cdk/geometry/cip/CIPTool.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/CIPTool.java,"/**
     * Checks if each next {@link ILigand} is different from the previous
     * one according to the {@link CIPLigandRule}. It assumes that the input
     * is sorted based on that rule.
     *
     * @param ligands array of {@link ILigand} to check
     * @return true, if all ligands are different
     */",220-233,"('checkIfAllLigandsAreDifferent', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,24.0,Checks if each next {@link ILigand} is different from the previous  one according to the {@link CIPLigandRule}.,"Returns true if all the lingards {@link ILigand} are different from the previous one, based on the {@link CIPLigandRule}. This method assumes that the input lingards are sorted based on the rule.",Checks if the previous one is different from the next one.,0.179617955641623,Checks whether each following {@link ILigand} is different from the previous one according to the {@link CIPLigandRule}.,"public static boolean checkIfAllLigandsAreDifferent(ILigand[] ligands){
        for (int i = 0; i < ligands.length; i++) {
            for (int j = i + 1; j < ligands.length; j++) {
                if (CIPLigandRule.areEqual(ligands[i], ligands[j])) return false;
            }
        }
        return true;
    }","public static boolean checkIfAllLigandsAreDifferent(ILigand[] ligands){
        if(ligands.length < 2) return true;
        for(int i = 0; i < ligands.length - 1; i++){
            if(ligands[i].equals(ligands[i+1])) return false;
        }
        return true;
    }","public static boolean checkIfAllLigandsAreDifferent(ILigand[] ligands){
        for (int i = 0; i < ligands.length - 1; i++) {
            if (ligands[i].equals(ligands[i + 1])) return false;
        }
        return true;
    }","public static boolean checkIfAllLigandsAreDifferent(ILigand[] ligands){
        for (int i = 0; i < ligands.length - 1; i++) {
            if (!CIPLigandRule.isDifferent(ligands[i], ligands[i + 1])) return false;
        }
        return true;
    }",NOT PASS,PASS,NOT PASS,PASS,  0.687476928348188,  0.6514555108530904,  0.8082375937305227,  0.7513922821445551,28.0,0.3783783783783784,22.0,0.3283582089552239,7.0,0.11290322580645161,11.0,0.1774193548387097,33.0,0.44594594594594594,25.0,0.33783783783783783,29.0,0.3918918918918919,22.0,0.6666666666666666,2.0,0.1111111111111111,11.0,0.6111111111111112
893,cdk,"public static IAtomContainer fromSignatureString(String signatureString, IChemObjectBuilder coBuilder){
    ColoredTree tree = AtomSignature.parse(signatureString);
    MoleculeFromSignatureBuilder builder = new MoleculeFromSignatureBuilder(coBuilder);
    builder.makeFromColoredTree(tree);
    return builder.getAtomContainer();
}",fromSignatureString,org/openscience/cdk/signature/MoleculeSignature.java,/descriptor/signature/src/main/java/org/openscience/cdk/signature/MoleculeSignature.java,"/**
     * Builder for molecules (rather, for atom containers) from signature
     * strings.
     *
     * @param signatureString the signature string to use
     * @param coBuilder {@link IChemObjectBuilder} to build the returned atom container from
     * @return an atom container
     */",171-184,"('fromSignatureString', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,14.0,"Builder for molecules (rather, for atom containers) from signature  strings.",Allows to build molecules from strings that represent their signatures.,Molecules and atom containers are built from signature strings.,0.401865835723998,Manufacturer of molecules (rather containers of atoms) from signature chains.,"public static IAtomContainer fromSignatureString(String signatureString, IChemObjectBuilder coBuilder){
        ColoredTree tree = ColoredTree.fromSignatureString(signatureString);
        IAtomContainer molecule = coBuilder.newInstance(IAtomContainer.class);
        for (int i = 0; i < tree.getVertexCount(); i++) {
            molecule.addAtom(coBuilder.newInstance(IAtom.class));
        }
        for (int i = 0; i < tree.getEdgeCount(); i++) {
            molecule.addBond(coBuilder.newInstance(IBond.class, molecule.getAtom(tree.getEdge(i).getSource()), molecule.getAtom(tree.getEdge(i).getTarget())));
        }
        return molecule;
    }"," public static IAtomContainer fromSignatureString(String signatureString, IChemObjectBuilder coBuilder){
        ColoredTree tree = ColoredTree.fromSignatureString(signatureString);
        return tree.toAtomContainer(coBuilder);
    }","public static IAtomContainer fromSignatureString(String signatureString, IChemObjectBuilder coBuilder){
        return fromSignatureString(signatureString, coBuilder, -1);     
 }","public static IAtomContainer fromSignatureString(String signatureString, IChemObjectBuilder coBuilder){
        return fromSignatureString(signatureString, coBuilder, -1);     
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5376905576404806,  0.5179028316318377,  0.31201072690042914,  0.31201072690042914,104.0,0.7482014388489209,21.0,0.44680851063829785,28.0,0.5957446808510638,28.0,0.5957446808510638,109.0,0.7841726618705036,118.0,0.8489208633093526,118.0,0.8489208633093526,10.0,0.9090909090909091,7.0,0.6363636363636364,7.0,0.6363636363636364
894,tablesaw,"Column<T> first(final int numRows){
    int newRowCount = Math.min(numRows, size());
    return inRange(0, newRowCount);
}",first,tech/tablesaw/columns/Column.java,/core/src/main/java/tech/tablesaw/columns/Column.java,/** Returns a column of the same type containing the first {@code numRows} of this column. */,654-658,"('first', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,19.0,Returns a column of the same type containing the first {@code numRows} of this column.,"Returns a column of the same type which only includes the first ""numRows"" of such a column.",The first @code numRows of this column is returned.,0.57451134197374,Returns a column of the same type containing the first {@code numRows} in that column.,"Column<T> first(final int numRows){
    return subColumn(0, numRows);   
 }","Column<T> first(final int numRows){
    return subColumn(0, numRows);   
 }","Column<T> first(final int numRows){
    return subColumn(0, numRows);   
 }"," Column<T> first(final int numRows){
    return take(numRows);   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.37729446657992527,  0.37729446657992527,  0.3188628427495249,  0.37729446657992527,16.0,0.45714285714285713,16.0,0.45714285714285713,18.0,0.5142857142857142,16.0,0.45714285714285713,0.0,0.0,3.0,0.14285714285714285,0.0,0.0,7.0,0.3888888888888889,2.0,0.125,14.0,0.875
895,tablesaw,"StringColumn yearMonth(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & month"");
    for (int r = 0; r < this.size(); r++) {
        long c1 = this.getLongInternal(r);
        if (DateTimeColumn.valueIsMissing(c1)) {
            newColumn.append(StringColumnType.missingValueIndicator());
        } else {
            String ym = String.valueOf(getYear(c1));
            ym = ym + ""-"" + Strings.padStart(String.valueOf(getMonthValue(c1)), 2, '0');
            newColumn.append(ym);
        }
    }
    return newColumn;
}",yearMonth,tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,"/**
   * Returns a StringColumn with the year and month from this column concatenated into a String that
   * will sort lexicographically in temporal order.
   *
   * <p>This simplifies the production of plots and tables that aggregate values into standard
   * temporal units (e.g., you want monthly data but your source data is more than a year long and
   * you don't want months from different years aggregated together).
   */",215-236,"('yearMonth', {'INSTRUCTION': {'covered': 52, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",125.0,23.0,Returns a StringColumn with the year and month from this column concatenated into a String that  will sort lexicographically in temporal order.,"Returns a StringColumn that contains, for each row, the year and month from this column. Such data are concatenated so that it will be possible to sort the column in lexicographical order to obtain temporal order. This makes the production of plots and tables in temporal order easier.",The year and month from this column will be combined into a String that will sort lexicographically in temporal order.,0.962798330709575,Returns a StringColumn with the year and month of this column concatenated into a String that will sort lexicographically in temporal order.,"StringColumn yearMonth(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & month"");
    for (int r = 0; r < this.size(); r++) {
      long c1 = this.getLongInternal(r);
      if (DateTimeColumn.valueIsMissing(c1)) {
        newColumn.append(StringColumnType.missingValueIndicator());
      } else {
        String ym = getYear(c1) + ""-"" + getMonthValue(c1);
        newColumn.append(ym);
      }
    }
    return newColumn;
  }","StringColumn yearMonth(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & month"");
    for (int r = 0; r < this.size(); r++) {
      long c1 = this.getLongInternal(r);
      if (DateTimeColumn.valueIsMissing(c1)) {
        newColumn.append(StringColumnType.missingValueIndicator());
      } else {
        String ym = getYear(c1) + ""-"" + getMonthValue(c1);
        newColumn.append(ym);
      }
    }
    return newColumn;
  }","StringColumn yearMonth(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & month"");
    for (int r = 0; r < this.size(); r++) {
      long c1 = this.getLongInternal(r);
      if (DateTimeColumn.valueIsMissing(c1)) {
        newColumn.append(StringColumnType.missingValueIndicator());
      } else {
        String ym = getYear(c1) + ""-"" + getMonthValue(c1);
        newColumn.append(ym);
      }
    }
    return newColumn;   
 }","StringColumn yearMonth(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & month"");
    for (int r = 0; r < this.size(); r++) {
      long c1 = this.getLongInternal(r);
      if (DateTimeColumn.valueIsMissing(c1)) {
        newColumn.append(StringColumnType.missingValueIndicator());
      } else {
        String ym = getYear(c1) + ""-"" + getMonthValue(c1);
        newColumn.append(ym);
      }
    }
    return newColumn;   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7297034658498899,  0.7297034658498899,  0.7297034658498899,  0.7297034658498899,23.0,0.18253968253968253,23.0,0.18253968253968253,23.0,0.18253968253968253,23.0,0.18253968253968253,0.0,0.0,0.0,0.0,0.0,0.0,33.0,0.673469387755102,1.0,0.043478260869565216,8.0,0.34782608695652173
896,matsim-libs,"private void reportOptions(){
    logger.info(String.format(""Received %d positional command line arguments:"", positionalArguments.size()));
    logger.info(""   "" + String.join("" , "", positionalArguments));
    Map<String, List<String>> prefixedOptions = new HashMap<>();
    List<String> nonPrefixedOptions = new LinkedList<>();
    for (String option : options.keySet()) {
        int separatorIndex = option.indexOf(':');
        if (separatorIndex > -1) {
            String prefix = option.substring(0, separatorIndex);
            option = option.substring(separatorIndex + 1);
            if (!prefixedOptions.containsKey(prefix)) {
                prefixedOptions.put(prefix, new LinkedList<>());
            }
            prefixedOptions.get(prefix).add(option);
        } else {
            nonPrefixedOptions.add(option);
        }
    }
    logger.info(String.format(""Received %d command line options with %d prefixes:"", options.size(), prefixedOptions.size()));
    Collections.sort(nonPrefixedOptions);
    for (String option : nonPrefixedOptions) {
        logger.info(String.format(""   %s = %s"", option, options.get(option)));
    }
    List<String> orderedPrefixes = new LinkedList<>(prefixedOptions.keySet());
    Collections.sort(orderedPrefixes);
    for (String prefix : orderedPrefixes) {
        logger.info(String.format(""   Prefix %s:"", prefix));
        for (String option : prefixedOptions.get(prefix)) {
            logger.info(String.format(""      %s = %s"", option, options.get(prefix + "":"" + option)));
        }
    }
}",reportOptions,org/matsim/core/config/CommandLine.java,/matsim/src/main/java/org/matsim/core/config/CommandLine.java,"/**
	 * Reports on the options that have been inserted into the MATSim {@link Config}
	 * via the command line.
	 */",500-546,"('reportOptions', {'INSTRUCTION': {'covered': 194, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 30, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",323.0,21.0,Reports on the options that have been inserted into the MATSim {@link Config}  via the command line.,Writes the options that have been added into the MATSim using the command line.,Reports on the options that have been inserted into the MATSim.,0.243643074012951,Indicates the options that have been inserted into MATSim {@link Config} via the command line.," private void reportOptions(){
	 		log.info(""Command line options:"");
 		for (String option : options.keySet()) {
 			log.info(String.format(""  %s = %s"", option, options.get(option)));
 		}
 	}"," private void reportOptions(){
	 System.out.println(""Command line options:"");
	 for (String option : options.keySet()) {
		 System.out.println(option + "" = "" + options.get(option));
	 }
 }"," private void reportOptions(){
	 System.out.println(""Options:"");
	 for (String option : options.keySet()) {
		 System.out.println(String.format(""\t%s = %s"", option, options.get(option)));
	 }
 }"," private void reportOptions(){
	 System.out.println(""Options:"");
	 for (String option : options.keySet()) {
		 System.out.println(option + "": "" + options.get(option));
	 }
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.12822227276950715,  0.11092969397945479,  0.10798005600469647,  0.12069473938612825,279.0,0.8611111111111112,285.0,0.8796296296296297,285.0,0.8796296296296297,279.0,0.8611111111111112,14.0,0.2857142857142857,15.0,0.30612244897959184,10.0,0.18867924528301888,6.0,0.3333333333333333,3.0,0.16666666666666666,7.0,0.3888888888888889
897,cdk,"private List<IIsotope> isotopesList(){
    List<IIsotope> isotopes = new ArrayList<IIsotope>();
    Iterator<IMolecularFormula> componentIterator = components.iterator();
    while (componentIterator.hasNext()) {
        Iterator<IIsotope> compIsotopes = componentIterator.next().isotopes().iterator();
        while (compIsotopes.hasNext()) {
            IIsotope isotope = compIsotopes.next();
            if (!isotopes.contains(isotope)) {
                isotopes.add(isotope);
            }
        }
    }
    return isotopes;
}",isotopesList,org/openscience/cdk/formula/AdductFormula.java,/base/data/src/main/java/org/openscience/cdk/formula/AdductFormula.java,"/**
     *  Returns a List for looping over all isotopes in this adduct formula.
     *
     * @return    A List with the isotopes in this adduct formula
     */",194-212,"('isotopesList', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",107.0,13.0,Returns a List for looping over all isotopes in this adduct formula.,Returns a list for cycling over all the isotopes in this adduct formula.,This adduct formula returns a List for looping over all the isotopes.,1.0252007974211,Returns a list for the loop on all isotopes of this adduct formula.," private List<IIsotope> isotopesList(){
        List<IIsotope> isotopes = new ArrayList<IIsotope>();
        Iterator<IMolecularFormula> componentIterator = components.iterator();
        while (componentIterator.hasNext()) {
            Iterator<IIsotope> isotopeIterator = componentIterator.next().isotopes().iterator();
            while (isotopeIterator.hasNext()) {
                IIsotope isotope = isotopeIterator.next();
                if (!isotopes.contains(isotope)) {
                    isotopes.add(isotope);
                }
            }
        }
        return isotopes;
    }"," private List<IIsotope> isotopesList(){
        List<IIsotope> isotopes = new ArrayList<IIsotope>();
        for (IMolecularFormula component : components) {
            for (IIsotope isotope : component.isotopes()) {
                if (!isotopes.contains(isotope)) {
                    isotopes.add(isotope);
                }
            }
        }
        return isotopes;
    }"," private List<IIsotope> isotopesList(){
        List<IIsotope> isotopes = new ArrayList<IIsotope>();
        Iterator<IMolecularFormula> componentIterator = components.iterator();
        while (componentIterator.hasNext()) {
            Iterator<IIsotope> isotopeIterator = componentIterator.next().isotopes().iterator();
            while (isotopeIterator.hasNext()) {
                isotopes.add(isotopeIterator.next());
            }
        }
        return isotopes;
    }"," private List<IIsotope> isotopesList(){
        List<IIsotope> isotopes = new ArrayList<IIsotope>();
        for (IMolecularFormula mf : components) {
            for (IIsotope isotope : mf.isotopes()) {
                if (!isotopes.contains(isotope)) {
                    isotopes.add(isotope);
                }
            }
        }
        return isotopes;
    }",PASS,PASS,NOT PASS,NOT PASS,  0.9643027620789877,  0.5310404713631804,  0.5310404713631804,  0.7532722593881671,3.0,0.027777777777777776,48.0,0.4444444444444444,48.0,0.4444444444444444,23.0,0.21296296296296297,48.0,0.4444444444444444,48.0,0.4444444444444444,21.0,0.19444444444444445,3.0,0.21428571428571427,5.0,0.35714285714285715,9.0,0.6923076923076923
898,cdk,"public Partition splitBefore(int cellIndex, int splitElement){
    Partition r = new Partition();
    for (int j = 0; j < cellIndex; j++) {
        r.addCell(this.copyBlock(j));
    }
    r.addSingletonCell(splitElement);
    SortedSet<Integer> splitBlock = this.copyBlock(cellIndex);
    splitBlock.remove(splitElement);
    r.addCell(splitBlock);
    for (int j = cellIndex + 1; j < this.size(); j++) {
        r.addCell(this.copyBlock(j));
    }
    return r;
}",splitBefore,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,"/**
     * Splits this partition by taking the cell at cellIndex and making two
     * new cells - the first with the singleton splitElement and the second
     * with the rest of the elements from that cell.
     *
     * @param cellIndex the index of the cell to split on
     * @param splitElement the element to put in its own cell
     * @return a new (finer) Partition
     */",213-240,"('splitBefore', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",119.0,34.0,Splits this partition by taking the cell at cellIndex and making two  new cells - the first with the singleton splitElement and the second  with the rest of the elements from that cell.,"Splits this partition into two new cells, the first of which contains the singleton splitElement and the second of which contains the remaining items from the cell at cellIndex.    ",The first cell with the singleton splitElement is used to split the partition and the second with the rest of the elements from that cell.,0.818558101104882,Divides this partition by taking the cell to cellIndex and creating two new cells - the first with the singleton splitElement and the second with the rest of the elements in this cell.," public Partition splitBefore(int cellIndex, int splitElement){
        Partition split = new Partition();
        SortedSet<Integer> cell = this.cells.get(cellIndex);
        SortedSet<Integer> first = new TreeSet<Integer>();
        first.add(splitElement);
        SortedSet<Integer> second = new TreeSet<Integer>();
        second.addAll(cell);
        second.remove(splitElement);
        split.cells.add(first);
        split.cells.add(second);
        return split;
    }"," public Partition splitBefore(int cellIndex, int splitElement){
        Partition split = new Partition();
        SortedSet<Integer> cell = this.cells.get(cellIndex);
        SortedSet<Integer> first = new TreeSet<Integer>();
        SortedSet<Integer> second = new TreeSet<Integer>();
        first.add(splitElement);
        for (Integer i : cell) {
            if (i < splitElement) {
                first.add(i);
            } else {
                second.add(i);
            }
        }
        split.cells.add(first);
        split.cells.add(second);
        return split;
    }","public Partition splitBefore(int cellIndex, int splitElement){
        Partition split = new Partition();
        split.cells.add(new TreeSet<Integer>());
        split.cells.get(0).add(splitElement);
        for (int i = 0; i < cellIndex; i++) {
            split.cells.add(new TreeSet<Integer>(this.cells.get(i)));
        }
        for (int i = cellIndex; i < this.cells.size(); i++) {
            split.cells.add(new TreeSet<Integer>(this.cells.get(i)));
        }
        return split;
    }","public Partition splitBefore(int cellIndex, int splitElement){
        Partition newPartition = new Partition();
        newPartition.cells.add(new TreeSet<Integer>());
        newPartition.cells.get(0).add(splitElement);
        for (int i = 0; i < cellIndex; i++) {
            newPartition.cells.add(new TreeSet<Integer>(this.cells.get(i)));
        }
        for (int i = cellIndex; i < this.cells.size(); i++) {
            newPartition.cells.add(new TreeSet<Integer>(this.cells.get(i)));
        }
        return newPartition;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3779808181879719,  0.38047370236442923,  0.44829593720319993,  0.44829593720319993,69.0,0.575,83.0,0.6587301587301587,79.0,0.5766423357664233,79.0,0.5766423357664233,37.0,0.29365079365079366,82.0,0.5985401459854015,79.0,0.5766423357664233,23.0,0.6764705882352942,5.0,0.14705882352941177,19.0,0.5588235294117647
899,matsim-libs,"public boolean decreaseKey(E value, double cost){
    int index = indices[this.getIndex(value)];
    if (index < 0) {
        return this.add(value, cost);
    }
    double oldCost = costs[index];
    if (oldCost < cost)
        return false;
    siftUp(index, value, cost);
    return true;
}",decreaseKey,org/matsim/core/router/priorityqueue/BinaryMinHeap.java,/matsim/src/main/java/org/matsim/core/router/priorityqueue/BinaryMinHeap.java,"/**
         * Increases the priority (=decrease the given double value) of the element.
         * If the element ins not part of the queue, it is added. If the new priority
         * is lower than the existing one, the method returns <tt>false</tt>
         *
         * @return <tt>true</tt> if the elements priority was decreased.
         */",313-339,"('decreaseKey', {'INSTRUCTION': {'covered': 30, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",72.0,14.0,Increases the priority (=decrease the given double value) of the element.,Decreases the specified double value while increasing the element's priority. The element is added if it is not already in the queue. The method returns false if the new priority is lower than the current one.,The priority is increased by decreasing the double value.,0.302780900210906,Increases the priority (= decrease the double value given) of the element.,"public boolean decreaseKey(E value, double cost){
	 
	 if (value == null) return false;
	 
	 int index = indices[this.getIndex(value)];
	 if (index < 0) return false;
	 
	 if (costs[index] <= cost) return false;
	 
	 costs[index] = cost;
	 
	 siftDown(index);
	 
	 return true;
 }","public boolean decreaseKey(E value, double cost){
		
		if (value == null) {
			throw new NullPointerException(""null values are not supported!"");
		}
		
		int index = indices[this.getIndex(value)];
		if (index < 0) {
			// if the element is not present in the queue, add it
			if (heapSize == data.length) throw new RuntimeException(""Heap's underlying storage is overflow!"");			
			
			this.modCount++;
			siftUp(heapSize, value, cost);
			heapSize++;			
			return true;
		} else {
			// if the element is present in the queue, decrease its priority
			if (cost < costs[index]) {
				this.modCount++;
				costs[index] = cost;
				siftDown(index);
				return true;
			} else return false;
		}
	}","public boolean decreaseKey(E value, double cost){
		
		if (value == null) {
			throw new NullPointerException(""null values are not supported!"");
		}
		
		int index = indices[this.getIndex(value)];
		if (index < 0) {
			return false;
		} else {
			if (cost < costs[index]) {
				costs[index] = cost;
				siftUp(index, value, cost);
				this.modCount++;
				return true;
			} else return false;
		}
	}","public boolean decreaseKey(E value, double cost){
	 
	 if (value == null) {
		 throw new NullPointerException(""null values are not supported!"");
	 }
	 
	 int index = indices[this.getIndex(value)];
	 if (index < 0) {
		 return false;
	 } else {
		 if (cost < costs[index]) {
			 costs[index] = cost;
			 siftUp(index, value, cost);
			 this.modCount++;
			 return true;
		 } else return false;
	 }			
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6078653120199449,  0.6364922356693256,  0.6684013870009897,  0.6684013870009897,36.0,0.4931506849315068,70.0,0.5737704918032787,48.0,0.5106382978723404,48.0,0.5106382978723404,59.0,0.48360655737704916,35.0,0.3723404255319149,35.0,0.3723404255319149,33.0,0.8918918918918919,5.0,0.38461538461538464,10.0,0.8333333333333334
900,cdk,"private void layoutMolecule(List ringSetMolecule, IAtomContainer molecule, AtomPlacer3D ap3d, AtomTetrahedralLigandPlacer3D atlp3d, AtomPlacer atomPlacer) throws CDKException, IOException, CloneNotSupportedException{
    IAtomContainer ac = null;
    int safetyCounter = 0;
    IAtom atom = null;
    do {
        safetyCounter++;
        atom = ap3d.getNextPlacedHeavyAtomWithUnplacedRingNeighbour(molecule);
        if (atom != null) {
            IAtom unplacedAtom = ap3d.getUnplacedRingHeavyAtom(molecule, atom);
            IRingSet ringSetA = getRingSetOfAtom(ringSetMolecule, unplacedAtom);
            IAtomContainer ringSetAContainer = RingSetManipulator.getAllInOneContainer(ringSetA);
            templateHandler.mapTemplates(ringSetAContainer, ringSetAContainer.getAtomCount());
            if (checkAllRingAtomsHasCoordinates(ringSetAContainer)) {
            } else {
                throw new IOException(""RingAtomLayoutError: Not every ring atom is placed! Molecule cannot be layout.Sorry"");
            }
            Point3d firstAtomOriginalCoord = unplacedAtom.getPoint3d();
            Point3d centerPlacedMolecule = ap3d.geometricCenterAllPlacedAtoms(molecule);
            setBranchAtom(molecule, unplacedAtom, atom, ap3d.getPlacedHeavyAtoms(molecule, atom), ap3d, atlp3d);
            layoutRingSystem(firstAtomOriginalCoord, unplacedAtom, ringSetA, centerPlacedMolecule, atom, ap3d);
            searchAndPlaceBranches(molecule, ringSetAContainer, ap3d, atlp3d, atomPlacer);
            ringSetA = null;
            unplacedAtom = null;
            firstAtomOriginalCoord = null;
            centerPlacedMolecule = null;
        } else {
            setAtomsToUnVisited(molecule);
            atom = ap3d.getNextPlacedHeavyAtomWithUnplacedAliphaticNeighbour(molecule);
            if (atom != null) {
                ac = atom.getBuilder().newInstance(IAtomContainer.class);
                ac.addAtom(atom);
                searchAndPlaceBranches(molecule, ac, ap3d, atlp3d, atomPlacer);
                ac = null;
            }
        }
    } while (!ap3d.allHeavyAtomsPlaced(molecule) || safetyCounter > molecule.getAtomCount());
}",layoutMolecule,org/openscience/cdk/modeling/builder3d/ModelBuilder3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/ModelBuilder3D.java,"/**
     * Layout the molecule, starts with ring systems and than aliphatic chains.
     *
     *@param  ringSetMolecule  ringSystems of the molecule
     */",260-312,"('layoutMolecule', {'INSTRUCTION': {'covered': 97, 'missed': 25}, 'BRANCH': {'covered': 6, 'missed': 4}, 'LINE': {'covered': 26, 'missed': 5}, 'COMPLEXITY': {'covered': 2, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",297.0,13.0,"Layout the molecule, starts with ring systems and than aliphatic chains.","Starting with ring systems and moving on to aliphatic chains, the molecule is laid out. ",The molecule starts with ring systems and aliphatic chains.,0.401767762688681,The arrangement of the molecule begins with ring systems and then aliphatic chains.,"private void layoutMolecule(List ringSetMolecule, IAtomContainer molecule, AtomPlacer3D ap3d, AtomTetrahedralLigandPlacer3D atlp3d, AtomPlacer atomPlacer) throws CDKException, IOException, CloneNotSupportedException{
        IRingSet ringSet = null;
        IAtomContainer ac = null;
        int numberOfRingAtoms = 0;
        if (ringSetMolecule.size() > 0) {
            ringSet = RingSetManipulator.getLargestRingSet(ringSetMolecule);
            ac = RingSetManipulator.getAllInOneContainer(ringSet);
            numberOfRingAtoms = ac.getAtomCount();
            templateHandler.mapTemplates(ac, numberOfRingAtoms);
            if (!checkAllRingAtomsHasCoordinates(ac)) {
                throw new CDKException(""RingAtomLayoutError: Not every ring atom is placed! Molecule cannot be layout."");
            }
            setAtomsToPlace(ac);
            searchAndPlaceBranches(molecule, ac, ap3d, atlp3d, atomPlacer);
            ringSet = null;
        }
        //logger.debug(""****** Start of handling aliphatic molecule ******"");
        ac = atomPlacer.getInitialLongestChain(molecule);
        setAtomsToUnVisited(molecule);
        setAtomsToUnPlaced(molecule);
        ap3d.placeAliphaticHeavyChain(molecule, ac);
        //ZMatrixApproach
        ap3d.zmatrixChainToCartesian(molecule, false);
        searchAndPlaceBranches(molecule, ac, ap3d, atlp3d, atomPlacer);     
 }","private void layoutMolecule(List ringSetMolecule, IAtomContainer molecule, AtomPlacer3D ap3d, AtomTetrahedralLigandPlacer3D atlp3d, AtomPlacer atomPlacer) throws CDKException, IOException, CloneNotSupportedException{
        IRingSet ringSet = null;
        IAtomContainer ac = null;
        IAtomContainer ac2 = null;
        IAtomContainer ac3 = null;
        IAtomContainer ac4 = null;
        IAtomContainer ac5 = null;
        IAtomContainer ac6 = null;
        IAtomContainer ac7 = null;
        IAtomContainer ac8 = null;
        IAtomContainer ac9 = null;
        IAtomContainer ac10 = null;
        IAtomContainer ac11 = null;
        IAtomContainer ac12 = null;
        IAtomContainer ac13 = null;
        IAtomContainer ac14 = null;
        IAtomContainer ac15 = null;
        IAtomContainer ac16 = null;
        IAtomContainer ac17 = null;
        IAtomContainer ac18 = null;
        IAtomContainer ac19 = null;
        IAtomContainer ac20 = null;
        IAtomContainer ac21 = null;
        IAtomContainer ac22 = null;
        IAtomContainer ac23 = null;
        IAtomContainer ac24 = null;
        IAtomContainer ac25 = null;
        IAtomContainer ac26 = null;
        IAtomContainer ac27 = null;
        IAtomContainer ac28 = null;
        IAtomContainer ac29 = null;
        IAtomContainer ac30 = null;
        IAtomContainer ac31 = null;
        IAtomContainer ac32 = null;
        IAtomContainer ac33 = null;
        IAtomContainer ac34 = null;
        IAtomContainer ac35 = null;
        IAtomContainer ac36 = null;
        IAtomContainer ac37 = null;
        IAtomContainer ac38 = null;
        IAtomContainer ac39 = null;
        IAtomContainer ac40 = null;
        IAtomContainer ac41 = null;
        IAtomContainer ac42 = null;
        IAtomContainer ac43 = null;
        IAtomContainer ac44 = null;
        IAtomContainer ac       
 }","private void layoutMolecule(List ringSetMolecule, IAtomContainer molecule, AtomPlacer3D ap3d, AtomTetrahedralLigandPlacer3D atlp3d, AtomPlacer atomPlacer) throws CDKException, IOException, CloneNotSupportedException{
        IRingSet ringSet = null;
        IRingSet ringSetOfAtom = null;
        IAtomContainer ac = null;
        IAtomContainer ac2 = null;
        IAtomContainer ac3 = null;
        IAtomContainer ac4 = null;
        IAtomContainer ac5 = null;
        IAtomContainer ac6 = null;
        IAtomContainer ac7 = null;
        IAtomContainer ac8 = null;
        IAtomContainer ac9 = null;
        IAtomContainer ac10 = null;
        IAtomContainer ac11 = null;
        IAtomContainer ac12 = null;
        IAtomContainer ac13 = null;
        IAtomContainer ac14 = null;
        IAtomContainer ac15 = null;
        IAtomContainer ac16 = null;
        IAtomContainer ac17 = null;
        IAtomContainer ac18 = null;
        IAtomContainer ac19 = null;
        IAtomContainer ac20 = null;
        IAtomContainer ac21 = null;
        IAtomContainer ac22 = null;
        IAtomContainer ac23 = null;
        IAtomContainer ac24 = null;
        IAtomContainer ac25 = null;
        IAtomContainer ac26 = null;
        IAtomContainer ac27 = null;
        IAtomContainer ac28 = null;
        IAtomContainer ac29 = null;
        IAtomContainer ac30 = null;
        IAtomContainer ac31 = null;
        IAtomContainer ac32 = null;
        IAtomContainer ac33 = null;
        IAtomContainer ac34 = null;
        IAtomContainer ac35 = null;
        IAtomContainer ac36 = null;
        IAtomContainer ac37 = null;
        IAtomContainer ac38 = null;
        IAtomContainer ac39 = null;
        IAtomContainer ac40 = null;
        IAtomContainer ac41 = null;
        IAtomContainer ac42 = null;
        IAtomContainer ac43 = null;
        IAtom       
 }","private void layoutMolecule(List ringSetMolecule, IAtomContainer molecule, AtomPlacer3D ap3d, AtomTetrahedralLigandPlacer3D atlp3d, AtomPlacer atomPlacer) throws CDKException, IOException, CloneNotSupportedException{
        IRingSet ringSet = null;
        IAtomContainer ac = null;
        int numberOfRingAtoms = 0;
        int numberOfRingAtomsPlaced = 0;
        int numberOfRingAtomsPlacedInThisRing = 0;
        int numberOfRingAtomsPlacedInThisRingSystem = 0;
        int numberOfRingAtomsPlacedInThisRingSystemInThisRing = 0;
        int numberOfRingAtomsPlacedInThisRingSystemInThisRingInThisRing = 0;
        int numberOfRingAtomsPlacedInThisRingSystemInThisRingInThisRingSystem = 0;
        int numberOfRingAtomsPlacedInThisRingSystemInThisRingInThisRingSystemInThisRing = 0;
        int numberOfRingAtomsPlacedInThisRingSystemInThisRingInThisRingSystemInThisRingInThisRing = 0;
        int numberOfRingAtomsPlacedInThisRingSystemInThisRingInThisRingSystemInThisRingInThisRingSystem = 0;
        int numberOfRingAtomsPlacedInThisRingSystemInThisRingInThisRingSystemInThisRingInThisRingSystemInThisRing = 0;
        int numberOfRingAtomsPlacedInThisRingSystemInThisRingInThisRingSystemInThisRingInThisRingSystemInThisRingInThisRing = 0;
        int numberOfRingAtomsPlacedInThisRingSystemInThisRingInThisRingSystemInThisRingInThisRingSystemInThisRingInThisRingSystem = 0;
        int numberOfRingAtomsPlacedInThisRingSystemInThisRingInThisRingSystemInThisRingInThisRingSystemInThisRingInThisRingSystemInThisRing = 0;
        int numberOfRingAtomsPlacedInThisRingSystemInThisRingInThisRingSystemInThisRingInThisRingSystemInThisRingInThisRingSystemInThisRingInThisRing = 0;
        int numberOfRingAtomsPlacedInThisRingSystemInThisRingInThisRingSystemInThisRingInThisRingSystemInThisRingInThisRingSystemInThisRingInThisRingSystem = 0;
        int numberOfRingAtomsPlacedInThisRingSystemInThisRingInThisRingSystemInThisRingInThisRingSystemIn       
 }",NOT PASS,Syntax Error,Syntax Error,Syntax Error,  0.40264005349506676,None,None,None,178.0,0.5973154362416108,None,None,237.0,0.7953020134228188,225.0,0.7550335570469798,None,None,120.0,0.6703910614525139,194.0,0.7637795275590551,13.0,0.8125,6.0,0.42857142857142855,4.0,0.3333333333333333
901,dataverse,"public static boolean conflictsWithExistingFilenames(String pathPlusFilename, List<FileMetadata> fileMetadatas){
    List<String> filePathsAndNames = getPathsAndFileNames(fileMetadatas);
    return filePathsAndNames.contains(pathPlusFilename);
}",conflictsWithExistingFilenames,edu/harvard/iq/dataverse/ingest/IngestUtil.java,/src/main/java/edu/harvard/iq/dataverse/ingest/IngestUtil.java,"/**
     * Given a new proposed label or directoryLabel for a file, check against
     * existing files if a duplicate directoryLabel/label combination would be
     * created.
     */",125-133,"('conflictsWithExistingFilenames', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,24.0,"Given a new proposed label or directoryLabel for a file, check against  existing files if a duplicate directoryLabel/label combination would be  created.",Check existing files to see if a duplicate directoryLabel/label combination would be produced if a new label or directoryLabel is proposed for a file.,"If a duplicate directoryLabel/label combination is created, check against existing files.",0.840980661428584,"Given a new label or directory proposedlabel for a file, check against existing files if a duplicate directory/label combination would be created."," public static boolean conflictsWithExistingFilenames(String pathPlusFilename, List<FileMetadata> fileMetadatas){
        for (FileMetadata fm : fileMetadatas) {
            if (fm.getLabel().equals(pathPlusFilename)) {
                return true;
            }
            if (fm.getDirectoryLabel() != null && fm.getDirectoryLabel().equals(pathPlusFilename)) {
                return true;
            }
        }
        return false;
    }"," public static boolean conflictsWithExistingFilenames(String pathPlusFilename, List<FileMetadata> fileMetadatas){
        for (FileMetadata fm : fileMetadatas) {
            if (fm.getLabel().equals(pathPlusFilename)) {
                return true;
            }
        }
        return false;
    }"," public static boolean conflictsWithExistingFilenames(String pathPlusFilename, List<FileMetadata> fileMetadatas){
        for (FileMetadata fm : fileMetadatas) {
            if (fm.getLabel().equals(pathPlusFilename)) {
                return true;
            }
        }
        return false;
    }"," public static boolean conflictsWithExistingFilenames(String pathPlusFilename, List<FileMetadata> fileMetadatas){
        for (FileMetadata fm : fileMetadatas) {
            if (fm.getLabel().equals(pathPlusFilename)) {
                return true;
            }
        }
        return false;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5287567199897196,  0.5634728536146055,  0.5634728536146055,  0.5634728536146055,48.0,0.6575342465753424,24.0,0.5106382978723404,24.0,0.5106382978723404,24.0,0.5106382978723404,26.0,0.3561643835616438,26.0,0.3561643835616438,26.0,0.3561643835616438,23.0,0.92,4.0,0.17391304347826086,18.0,0.782608695652174
902,glowstone,"public boolean readDoubleList(@NonNls String key, Consumer<? super List<Double>> consumer){
    return readList(key, TagType.DOUBLE, consumer);
}",readDoubleList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Applies the given function to a list subtag if it is present and its contents are double
     * tags.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */",608-618,"('readDoubleList', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,19.0,Applies the given function to a list subtag if it is present and its contents are double  tags.,"If a list subtag is present and its contents are double tags, it applies the specified function to it. ","If the function is present and the contents are double tags, apply it to the list subtag.",0.505753964242334,Applies the given function to a list subtag if it is present and its contents consist of double tags.," public boolean readDoubleList(@NonNls String key, Consumer<? super List<Double>> consumer){
        return readList(key, TagType.DOUBLE, consumer);
    }"," public boolean readDoubleList(@NonNls String key, Consumer<? super List<Double>> consumer){
        return readList(key, TagType.DOUBLE, consumer);
    }"," public boolean readDoubleList(@NonNls String key, Consumer<? super List<Double>> consumer){
        return readList(key, TagType.DOUBLE, consumer);
    }"," public boolean readDoubleList(@NonNls String key, Consumer<? super List<Double>> consumer){
        return readList(key, TagType.DOUBLE, consumer);
    }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,15.0,0.75,2.0,0.1,16.0,0.8421052631578947
903,cdk,"TextOutline positionMassLabel(TextOutline massLabel, TextOutline elementLabel){
    final Rectangle2D elementBounds = elementLabel.getBounds();
    final Rectangle2D massBounds = massLabel.getBounds();
    return massLabel.translate((elementBounds.getMinX() - padding) - massBounds.getMaxX(), (elementBounds.getMinY() - (massBounds.getHeight() / 2)) - massBounds.getMinY());
}",positionMassLabel,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,"/**
     * Position the mass label relative to the element label. The mass adjunct is position to the
     * top left of the element label.
     *
     * @param massLabel    mass label outline
     * @param elementLabel element label outline
     * @return positioned mass label
     */",528-541,"('positionMassLabel', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,10.0,Position the mass label relative to the element label.,Place the element label in relation to the mass label. The mass adjunct is located above the element label on the left.,The mass label should be placed relative to the element label.,0.47803109772495,Position the mass label relative to the item label.,"TextOutline positionMassLabel(TextOutline massLabel, TextOutline elementLabel){
        final Rectangle2D elementBounds = elementLabel.getBounds();
        final Rectangle2D massBounds = massLabel.getBounds();
        massLabel = massLabel.translate((elementBounds.getMaxX() + padding) - massBounds.getMinX(),
                                        (elementBounds.getMaxY() + padding) - massBounds.getMinY());
        return massLabel;       
 }","TextOutline positionMassLabel(TextOutline massLabel, TextOutline elementLabel){
        final Rectangle2D massBounds = massLabel.getBounds();
        final Rectangle2D elementBounds = elementLabel.getBounds();
        massLabel = massLabel.translate((elementBounds.getMinX() - padding) - massBounds.getMaxX(),
                                        (elementBounds.getMinY() - (massBounds.getHeight() / 2)) - massBounds.getMinY());
        return massLabel;       
 }","TextOutline positionMassLabel(TextOutline massLabel, TextOutline elementLabel){
        final Rectangle2D massBounds = massLabel.getBounds();
        final Rectangle2D elementBounds = elementLabel.getBounds();     
 }","TextOutline positionMassLabel(TextOutline massLabel, TextOutline elementLabel){
        final Rectangle2D elementBounds = elementLabel.getBounds();
        final Rectangle2D massBounds = massLabel.getBounds();
        return massLabel.translate((elementBounds.getMaxX() + padding) - massBounds.getMinX(),
                                    (elementBounds.getMinY() - (massBounds.getHeight() / 2)) - massBounds.getMinY());       
 }",NOT PASS,PASS,NOT PASS,NOT PASS,  0.7730013918291216,  0.8922786802518872,  0.9711737551540562,  0.4124500808179713,19.0,0.24358974358974358,9.0,0.10975609756097561,3.0,0.038461538461538464,50.0,0.6410256410256411,18.0,0.21951219512195122,16.0,0.20512820512820512,46.0,0.6216216216216216,17.0,0.7391304347826086,1.0,0.1,5.0,0.4166666666666667
904,acs-aem-commons,"protected final void searchAndUpdateResourceType(String oldResourceType, String newResourceType) throws RepositoryException{
    Map<String, String> map = new HashMap<>();
    map.put(""p.limit"", ""-1"");
    map.put(""path"", ""/content"");
    map.put(""1_property"", SLING_RESOURCE_TYPE);
    map.put(""1_property.value"", oldResourceType);
    logger.info(""Finding all nodes under /content with resource type: {}"", oldResourceType);
    final QueryBuilder queryBuilder = resourceResolver.adaptTo(QueryBuilder.class);
    if (queryBuilder != null) {
        Query query = queryBuilder.createQuery(PredicateGroup.create(map), session);
        QueryUtil.setResourceResolverOn(resourceResolver, query);
        SearchResult result = query.getResult();
        Iterator<Node> nodeItr = result.getNodes();
        if (nodeItr.hasNext()) {
            while (nodeItr.hasNext()) {
                Node node = nodeItr.next();
                updateResourceType(node, newResourceType);
            }
        } else {
            logger.info(""No nodes found with resource type: {}"", oldResourceType);
        }
    }
}",searchAndUpdateResourceType,com/adobe/acs/commons/ondeploy/scripts/OnDeployScriptBase.java,/bundle/src/main/java/com/adobe/acs/commons/ondeploy/scripts/OnDeployScriptBase.java,"/**
     * Searches for the current sling:resourceType under /content and replaces any nodes it finds
     * with the newResourceType.
     *
     * @param oldResourceType The current sling:resourceType.
     * @param newResourceType The new sling:resourceType to be used.
     */",182-213,"('searchAndUpdateResourceType', {'INSTRUCTION': {'covered': 75, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",191.0,19.0,Searches for the current sling:resourceType under /content and replaces any nodes it finds  with the newResourceType.,"/content is searched for the current sling:resourceType, and any nodes it finds are changed with the newResourceType. ",The current sling:resourceType is searched under /content and replaced with the newResourceType.,0.46389417722212,Finds the current sling:resourceType under /content and replaces all nodes it finds with the newResourceType.," protected final void searchAndUpdateResourceType(String oldResourceType, String newResourceType) throws RepositoryException{
        logger.info(""Searching for {} and replacing with {}"", oldResourceType, newResourceType);
        Map<String, String> map = new HashMap<String, String>();
        map.put(SLING_RESOURCE_TYPE, oldResourceType);
        Iterator<Resource> resources = resourceResolver.findResources(""/content/*"", map);
        while (resources.hasNext()) {
            Resource resource = resources.next();
            ModifiableValueMap properties = resource.adaptTo(ModifiableValueMap.class);
            if (properties.containsKey(SLING_RESOURCE_TYPE)) {
                properties.put(SLING_RESOURCE_TYPE, newResourceType);
            }
        }
    }"," protected final void searchAndUpdateResourceType(String oldResourceType, String newResourceType) throws RepositoryException{
        logger.info(""Searching for {} and updating to {}"", oldResourceType, newResourceType);
        String searchPath = ""/content"";
        Node searchNode = session.getRootNode().getNode(searchPath);
        NodeIterator nodeIterator = searchNode.getNodes();
        while (nodeIterator.hasNext()) {
            Node node = nodeIterator.nextNode();
            if (node.hasProperty(SLING_RESOURCE_TYPE)) {
                String resourceType = node.getProperty(SLING_RESOURCE_TYPE).getString();
                if (resourceType.equals(oldResourceType)) {
                    logger.info(""Updating resource type on {} to {}"", node.getPath(), newResourceType);
                    node.setProperty(SLING_RESOURCE_TYPE, newResourceType);
                }
            }
        }
    }"," protected final void searchAndUpdateResourceType(String oldResourceType, String newResourceType) throws RepositoryException{
        logger.info(""Searching for resourceType {} and replacing with {}"", oldResourceType, newResourceType);
        String query = String.format(""/jcr:root//element(*, %s)[@%s='%s']"", JcrConstants.NT_UNSTRUCTURED, SLING_RESOURCE_TYPE, oldResourceType);
        QueryManager queryManager = session.getWorkspace().getQueryManager();
        Query queryObject = queryManager.createQuery(query, Query.XPATH);
        QueryResult queryResult = queryObject.execute();
        NodeIterator nodeIterator = queryResult.getNodes();
        while (nodeIterator.hasNext()) {
            Node node = nodeIterator.nextNode();
            logger.info(""Updating resourceType of {}"", node.getPath());
            node.setProperty(SLING_RESOURCE_TYPE, newResourceType);
        }
    }"," protected final void searchAndUpdateResourceType(String oldResourceType, String newResourceType) throws RepositoryException{
        logger.info(""Searching for nodes with resourceType {} and updating to {}"", oldResourceType, newResourceType);
        String query = String.format(""/jcr:root//element(*, %s)[@%s='%s']"", JcrConstants.NT_UNSTRUCTURED, SLING_RESOURCE_TYPE, oldResourceType);
        QueryManager queryManager = session.getWorkspace().getQueryManager();
        Query queryObject = queryManager.createQuery(query, Query.XPATH);
        QueryResult queryResult = queryObject.execute();
        NodeIterator nodeIterator = queryResult.getNodes();
        while (nodeIterator.hasNext()) {
            Node node = nodeIterator.nextNode();
            logger.info(""Updating resourceType of node {} to {}"", node.getPath(), newResourceType);
            node.setProperty(SLING_RESOURCE_TYPE, newResourceType);
        }       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.38945823990471307,  0.32931883857427047,  0.34261993801887947,  0.34666423519996903,126.0,0.65625,121.0,0.6302083333333334,116.0,0.6041666666666666,115.0,0.5989583333333334,75.0,0.5597014925373134,75.0,0.5639097744360902,73.0,0.5572519083969466,9.0,0.5,3.0,0.17647058823529413,10.0,0.5882352941176471
905,anserini,"public String documentRaw(int ldocid){
    try {
        return reader.document(ldocid).get(IndexArgs.RAW);
    } catch (Exception e) {
        return null;
    }
}",documentRaw,io/anserini/search/SimpleImpactSearcher.java,/src/main/java/io/anserini/search/SimpleImpactSearcher.java,"/**
     * Returns the ""raw"" field of a document based on an internal Lucene docid.
     * The method is named to be consistent with Lucene's {@link IndexReader#document(int)}, contra Java's standard
     * method naming conventions.
     *
     * @param ldocid internal Lucene docid
     * @return the ""raw"" field the document
     */",346-361,"('documentRaw', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,16.0,"Returns the ""raw"" field of a document based on an internal Lucene docid.","Gives back a document's ""raw"" field based on an internal Lucene docid. Unlike Java's typical method naming standards, the method is named to be consistent  with Lucene's @link IndexReader#document(int).","The ""raw"" field is based on an internal docid.",0.968394096741965,"Returns the ""raw"" field of a document based on an internal Lucene docid."," public String documentRaw(int ldocid){
    try {
      return reader.document(ldocid).get(IndexArgs.RAW);
    } catch (Exception e) {
      // Eat any exceptions and just return null.
      return null;
    }   
 }"," public String documentRaw(int ldocid){
    try {
      return reader.document(ldocid).get(IndexArgs.RAW);
    } catch (Exception e) {
      // Eat any exceptions and just return null.
      return null;
    }
  }"," public String documentRaw(int ldocid){
    try {
      return reader.document(ldocid).get(IndexArgs.RAW);
    } catch (Exception e) {
      // Eat any exceptions and just return null.
      return null;
    }   
 }"," public String documentRaw(int ldocid){
    try {
      return reader.document(ldocid).get(IndexArgs.RAW);
    } catch (Exception e) {
      // Eat any exceptions and just return null.
      return null;
    }   
 }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,24.0,0.8,0.0,0.0,6.0,0.42857142857142855
906,glowstone,"public boolean matches(CompoundTag other){
    for (Entry<String, Tag> entry : value.entrySet()) {
        if (!other.value.containsKey(entry.getKey())) {
            return false;
        }
        Tag value = entry.getValue();
        Tag otherValue = other.value.get(entry.getKey());
        if ((value == null && otherValue != null) || (value != null && otherValue == null)) {
            return false;
        }
        if (value != null) {
            if (value.getClass() != otherValue.getClass()) {
                return false;
            }
            if (value instanceof CompoundTag) {
                if (!((CompoundTag) value).matches((CompoundTag) otherValue)) {
                    return false;
                }
            } else if (value instanceof IntArrayTag) {
                if (!Arrays.equals(((IntArrayTag) value).getValue(), ((IntArrayTag) otherValue).getValue())) {
                    return false;
                }
            } else if (value instanceof ByteArrayTag) {
                if (!Arrays.equals(((ByteArrayTag) value).getValue(), ((ByteArrayTag) otherValue).getValue())) {
                    return false;
                }
            } else if (!value.equals(otherValue)) {
                return false;
            }
        }
    }
    return true;
}",matches,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Checks to see if this tag is a strict, deep submap of the given CompoundTag.
     *
     * @param other The CompoundTag that should contain our values.
     */",85-125,"('matches', {'INSTRUCTION': {'covered': 80, 'missed': 16}, 'BRANCH': {'covered': 18, 'missed': 12}, 'LINE': {'covered': 18, 'missed': 7}, 'COMPLEXITY': {'covered': 5, 'missed': 11}, 'METHOD': {'covered': 1, 'missed': 0}})",265.0,17.0,"Checks to see if this tag is a strict, deep submap of the given CompoundTag.","Checks if this tag is a strict and deep submap of the given CompoundTag, which contains our values.","If this tag is a deep submap of the CompoundTag, we need to check it.",0.252647609626212,Checks whether this tag is a strict and deep submap of the given CompoundTag.," public boolean matches(CompoundTag other){
        if(other.value.size() != value.size()) return false;
        for(Entry<String, Tag> entry : value.entrySet()){
            if(!other.value.containsKey(entry.getKey())) return false;
            if(!entry.getValue().matches(other.value.get(entry.getKey()))) return false;
        }
        return true;
    }"," public boolean matches(CompoundTag other){
        for(Entry<String, Tag> entry : value.entrySet()){
            Tag otherTag = other.value.get(entry.getKey());
            if(otherTag == null || !otherTag.equals(entry.getValue())){
                return false;
            }
        }
        return true;
    }"," public boolean matches(CompoundTag other){
        if(other.value.size() != value.size()) return false;
        for(Entry<String, Tag> entry : value.entrySet()){
            if(!other.value.containsKey(entry.getKey())) return false;
            if(!entry.getValue().matches(other.value.get(entry.getKey()))) return false;
        }
        return true;
    }"," public boolean matches(CompoundTag other){
        if (other.value.size() != value.size()) {
            return false;
        }
        for (Entry<String, Tag> entry : value.entrySet()) {
            Tag otherTag = other.value.get(entry.getKey());
            if (otherTag == null || !otherTag.matches(entry.getValue())) {
                return false;
            }
        }
        return true;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.25463646340982427,  0.23376810740395199,  0.26408673043673614,  0.2699425858588039,196.0,0.7368421052631579,200.0,0.7518796992481203,201.0,0.7556390977443609,196.0,0.7368421052631579,42.0,0.4329896907216495,24.0,0.24742268041237114,0.0,0.0,9.0,0.47368421052631576,5.0,0.3125,11.0,0.6875
907,cdk,"private Integer massNumber(int atomicNumber, double exactMass) throws IOException{
    String symbol = PeriodicTable.getSymbol(atomicNumber);
    IIsotope isotope = Isotopes.getInstance().getIsotope(symbol, exactMass, 0.001);
    return isotope != null ? isotope.getMassNumber() : null;
}",massNumber,org/openscience/cdk/modeling/builder3d/MMFF94BasedParameterSetReader.java,/tool/forcefield/src/main/java/org/openscience/cdk/modeling/builder3d/MMFF94BasedParameterSetReader.java,"/**
     * Mass number for a atom with a given atomic number and exact mass.
     *
     * @param atomicNumber atomic number
     * @param exactMass    exact mass
     * @return the mass number (or null) if no mass number was found
     * @throws IOException isotope configuration could not be loaded
     */",562-574,"('massNumber', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,14.0,Mass number for a atom with a given atomic number and exact mass.,"For an atom with a specific atomic number and mass, returns its mass number. ",The mass number is the atomic number for the atom.,0.464625742652082,The number of masses for an atom with a given atomic number and an exact mass.,"private Integer massNumber(int atomicNumber, double exactMass) throws IOException{
        Integer massNumber = null;
        if (exactMass == 0.0) {
            massNumber = new Integer(0);
        } else {
            double mass = 0.0;
            for (int i = 0; i < atomTypes.size(); i++) {
                AtomType type = (AtomType) atomTypes.get(i);
                if (type.getAtomicNumber() == atomicNumber) {
                    mass = type.getMass();
                    break;
                }
            }
            massNumber = new Integer((int) (exactMass / mass));
        }
        return massNumber;      
 }","private Integer massNumber(int atomicNumber, double exactMass) throws IOException{
        Integer massNumber = null;
        if (exactMass == 0.0) {
            return massNumber;
        }
        if (exactMass == -1.0) {
            return massNumber;
        }
        if (exactMass == -2.0) {
            return massNumber;
        }
        if (exactMass == -3.0) {
            return massNumber;
        }
        if (exactMass == -4.0) {
            return massNumber;
        }
        if (exactMass == -5.0) {
            return massNumber;
        }
        if (exactMass == -6.0) {
            return massNumber;
        }
        if (exactMass == -7.0) {
            return massNumber;
        }
        if (exactMass == -8.0) {
            return massNumber;
        }
        if (exactMass == -9.0) {
            return massNumber;
        }
        if (exactMass == -10.0) {
            return massNumber;
        }
        if (exactMass == -11.0) {
            return massNumber;
        }
        if (exactMass == -12.0) {
            return massNumber;
        }
        if (exactMass == -13.0) {
            return massNumber;
        }
        if (exactMass == -14.0) {
            return massNumber;
        }
        if (exactMass == -15.0) {
            return massNumber;
        }
        if (exactMass == -16.0) {
            return massNumber;
        }
        if (exactMass == -17.0) {
            return massNumber;
        }
        if (exactMass == -18.0) {
            return massNumber;
        }
        if (exactMass == -19.0) {
            return massNumber;
        }
        if (exactMass == -20.0) {
            return massNumber;
        }
        if (exactMass == -21        
 }","private Integer massNumber(int atomicNumber, double exactMass) throws IOException{
        Integer massNumber = null;
        if (exactMass != 0.0) {
            massNumber = new Integer((int) exactMass);
        } else {
            massNumber = new Integer(atomicNumber);
        }
        return massNumber;
    }","private Integer massNumber(int atomicNumber, double exactMass) throws IOException{
        Integer massNumber = null;
        String key = atomicNumber + "";"" + exactMass;
        if (parameterSet.containsKey(key)) {
            massNumber = (Integer) parameterSet.get(key).get(0);
        }
        return massNumber;      
 }",NOT PASS,Syntax Error,NOT PASS,PASS,  0.40978067175628285,None,  0.40056986851690457,  0.34140083050568787,87.0,0.7435897435897436,None,None,38.0,0.6333333333333333,34.0,0.6071428571428571,None,None,75.0,0.6410256410256411,69.0,0.5897435897435898,10.0,0.6666666666666666,5.0,0.29411764705882354,11.0,0.7857142857142857
908,cdk,"public boolean matches(IAtom atom){
    PharmacophoreAtom patom = PharmacophoreAtom.get(atom);
    return patom.getSymbol().equals(getSymbol());
}",matches,org/openscience/cdk/pharmacophore/PharmacophoreQueryAtom.java,/tool/pcore/src/main/java/org/openscience/cdk/pharmacophore/PharmacophoreQueryAtom.java,"/**
     * Checks whether this query atom matches a target atom.
     * 
     * Currently a query pharmacophore atom will match a target pharmacophore group if the
     * symbols of the two groups match. This is based on the assumption that
     * pharmacophore groups with the same symbol will have the same SMARTS
     * pattern.
     *
     * @param atom A target pharmacophore group
     * @return true if the current query group has the same symbol as the target group
     */",104-119,"('matches', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,10.0,Checks whether this query atom matches a target atom.,"Determines if the destination atom matches the query atom. Currently, if the symbols of the two groups match, a query pharmacophore atom will match a target pharmacophore group. This is predicated on the idea that pharmacophore  groups sharing a symbol will have a similar SMARTS pattern. ",Does the query atom match the target atom?,0.733197961810215,Checks whether this query atom corresponds to a target atom.," public boolean matches(IAtom atom){
        for (SmartsPattern smarts : compiledSmarts) {
            if (smarts.matches(atom)) return true;
        }
        return false;       
 }"," public boolean matches(IAtom atom){
        if (atom instanceof PharmacophoreQueryAtom) {
            PharmacophoreQueryAtom queryAtom = (PharmacophoreQueryAtom)atom;
            if (queryAtom.getSymbol().equals(this.getSymbol())) {
                return true;
            }
        }
        return false;       
 }"," public boolean matches(IAtom atom){
        for (SmartsPattern smarts : compiledSmarts) {
            if (smarts.matches(atom)) return true;
        }
        return false;       
 }"," public boolean matches(IAtom atom){
        for (SmartsPattern smarts : compiledSmarts) {
            if (smarts.matches(atom)) return true;
        }
        return false;       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.38208013298090693,  0.45445492699727075,  0.38208013298090693,  0.38208013298090693,21.0,0.6176470588235294,26.0,0.5098039215686274,21.0,0.6176470588235294,21.0,0.6176470588235294,26.0,0.5098039215686274,0.0,0.0,0.0,0.0,42.0,0.8936170212765957,2.0,0.18181818181818182,6.0,0.6
909,tablesaw,"DoubleColumn neg(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[neg]"", size());
    for (int i = 0; i < size(); i++) {
        newColumn.set(i, getDouble(i) * -1);
    }
    return newColumn;
}",neg,tech/tablesaw/columns/numbers/NumberMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/numbers/NumberMapFunctions.java,"/**
   * For each item in the column, returns the same number with the sign changed. For example: -1.3
   * returns 1.3, 2.135 returns -2.135 0 returns 0
   */",336-346,"('neg', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,16.0,"For each item in the column, returns the same number with the sign changed.",Returns the same number with a new sign for each item in the column. For instance: -1.3 yields 1.3; and 2.135 yields -2.135; 0 yields 0.,The number is returned for each item in the column.,0.403218119683488,"For each item in the column, returns the same number with the modified sign.","DoubleColumn neg(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[neg]"", size());
    for (int i = 0; i < size(); i++) {
      newColumn.set(i, -getDouble(i));
    }
    return newColumn;
  }","DoubleColumn neg(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[neg]"", size());
    for (int i = 0; i < size(); i++) {
      newColumn.set(i, -getDouble(i));
    }
    return newColumn;
  }","DoubleColumn neg(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[neg]"", size());
    for (int i = 0; i < size(); i++) {
      newColumn.set(i, -getDouble(i));
    }
    return newColumn;
  }","DoubleColumn neg(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[neg]"", size());
    for (int i = 0; i < size(); i++) {
      newColumn.set(i, -getDouble(i));
    }
    return newColumn;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8799146370860043,  0.8799146370860043,  0.8799146370860043,  0.8799146370860043,4.0,0.06557377049180328,4.0,0.06557377049180328,4.0,0.06557377049180328,4.0,0.06557377049180328,0.0,0.0,0.0,0.0,0.0,0.0,22.0,0.8148148148148148,2.0,0.13333333333333333,13.0,0.8666666666666667
910,matsim-libs,"private static void copyShipments(Carrier carrierWS, Carrier carrier){
    for (CarrierShipment carrierShipment : carrier.getShipments().values()) {
        log.debug(""Copy CarrierShipment: "" + carrierShipment.toString());
        CarrierUtils.addShipment(carrierWS, carrierShipment);
    }
}",copyShipments,org/matsim/contrib/freight/utils/FreightUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/utils/FreightUtils.java,"/**
	 * Copy all shipments from the existing carrier to the new carrier with
	 * shipments.
	 *
	 * @param carrierWS the ""new"" carrier with Shipments
	 * @param carrier   the already existing carrier
	 */",250-262,"('copyShipments', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",52.0,14.0,Copy all shipments from the existing carrier to the new carrier with  shipments.,Transfer every shipment made with the old carrier to the new one. ,All shipments from the old carrier to the new carrier should be copied.,0.415829637398229,Copy all shipments from the existing carrier to the new carrier with the shipments.," private static void copyShipments(Carrier carrierWS, Carrier carrier){
	 		for (Shipment shipment : carrier.getShipments().values()) {
 			CarrierShipment carrierShipment = new CarrierShipment(shipment.getId());
 			carrierShipment.setPickupLocation(shipment.getPickupLocation());
 			carrierShipment.setDeliveryLocation(shipment.getDeliveryLocation());
 			carrierShipment.setPickupTimeWindow(shipment.getPickupTimeWindow());
 			carrierShipment.setDeliveryTimeWindow(shipment.getDeliveryTimeWindow());
 			carrierShipment.setCapacity(shipment.getCapacity());
 			carrierShipment.setCarrierId(carrier.getId());
 			carrierWS.addShipment(carrierShipment);
 		}
 	}",Not Valid,Not Valid," private static void copyShipments(Carrier carrierWS, Carrier carrier){
	 		for (Shipment shipment : carrier.getShipments().values()) {
 			CarrierUtils.addShipment(carrierWS, shipment);
 		}
 	}",NOT PASS,Not Valid,NOT PASS,Not Valid,  0.5897067582520092,None,  0.6250637403474254,None,74.0,0.6324786324786325,None,None,16.0,0.3018867924528302,None,None,None,None,81.0,0.6923076923076923,None,None,9.0,0.6428571428571429,1.0,0.06666666666666667,6.0,0.42857142857142855
911,cdk,"static List<Point2D> pointsOf(final Shape shape){
    final List<Point2D> points = new ArrayList<Point2D>();
    final double[] coordinates = new double[6];
    for (PathIterator i = shape.getPathIterator(null); !i.isDone(); i.next()) {
        switch(i.currentSegment(coordinates)) {
            case PathIterator.SEG_CLOSE:
                break;
            case PathIterator.SEG_MOVETO:
            case PathIterator.SEG_LINETO:
                points.add(new Point2D.Double(coordinates[0], coordinates[1]));
                break;
            case PathIterator.SEG_QUADTO:
                points.add(new Point2D.Double(coordinates[0], coordinates[1]));
                points.add(new Point2D.Double(coordinates[2], coordinates[3]));
                break;
            case PathIterator.SEG_CUBICTO:
                points.add(new Point2D.Double(coordinates[0], coordinates[1]));
                points.add(new Point2D.Double(coordinates[2], coordinates[3]));
                points.add(new Point2D.Double(coordinates[4], coordinates[5]));
                break;
        }
    }
    if (!points.isEmpty() && points.get(points.size() - 1).equals(points.get(0))) {
        points.remove(points.size() - 1);
    }
    return points;
}",pointsOf,org/openscience/cdk/renderer/generators/standard/ConvexHull.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/ConvexHull.java,"/**
     * Convert a Java 2D shape to a list of points.
     *
     * @param shape a shape
     * @return list of point
     */",128-161,"('pointsOf', {'INSTRUCTION': {'covered': 120, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 2}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",287.0,11.0,Convert a Java 2D shape to a list of points.,Returns a list of points related to the given Java 2D shape.,A Java 2D shape can be converted to a list of points.,0.179186457343141,Convert a Java 2D shape to a list of points.,"static List<Point2D> pointsOf(final Shape shape){
        final List<Point2D> points = new ArrayList<Point2D>();
        final PathIterator iterator = shape.getPathIterator(null);
        while (!iterator.isDone()) {
            final double[] coords = new double[6];
            final int type = iterator.currentSegment(coords);
            switch (type) {
                case PathIterator.SEG_MOVETO:
                    points.add(new Point2D.Double(coords[0], coords[1]));
                    break;
                case PathIterator.SEG_LINETO:
                    points.add(new Point2D.Double(coords[0], coords[1]));
                    break;
                case PathIterator.SEG_QUADTO:
                    points.add(new Point2D.Double(coords[0], coords[1]));
                    points.add(new Point2D.Double(coords[2], coords[3]));
                    break;
                case PathIterator.SEG_CUBICTO:
                    points.add(new Point2D.Double(coords[0], coords[1]));
                    points.add(new Point2D.Double(coords[2], coords[3]));
                    points.add(new Point2D.Double(coords[4], coords[5]));
                    break;
                case PathIterator.SEG_CLOSE:
                    points.add(new Point2D.Double(coords[0], coords[1]));
                    break;
            }
            iterator.next();
        }
        return points;      
 }","static List<Point2D> pointsOf(final Shape shape){
        final List<Point2D> points = new ArrayList<Point2D>();
        final PathIterator iterator = shape.getPathIterator(null);
        while (!iterator.isDone()) {
            final double[] coords = new double[6];
            final int type = iterator.currentSegment(coords);
            switch (type) {
                case PathIterator.SEG_MOVETO:
                    points.add(new Point2D.Double(coords[0], coords[1]));
                    break;
                case PathIterator.SEG_LINETO:
                    points.add(new Point2D.Double(coords[0], coords[1]));
                    break;
                case PathIterator.SEG_QUADTO:
                    points.add(new Point2D.Double(coords[0], coords[1]));
                    points.add(new Point2D.Double(coords[2], coords[3]));
                    break;
                case PathIterator.SEG_CUBICTO:
                    points.add(new Point2D.Double(coords[0], coords[1]));
                    points.add(new Point2D.Double(coords[2], coords[3]));
                    points.add(new Point2D.Double(coords[4], coords[5]));
                    break;
                case PathIterator.SEG_CLOSE:
                    points.add(new Point2D.Double(coords[0], coords[1]));
                    break;
            }
            iterator.next();
        }
        return points;      
 }","static List<Point2D> pointsOf(final Shape shape){
        final List<Point2D> points = new ArrayList<Point2D>();
        final PathIterator iterator = shape.getPathIterator(null);
        final double[] coords = new double[6];
        while (!iterator.isDone()) {
            switch (iterator.currentSegment(coords)) {
                case PathIterator.SEG_MOVETO:
                    points.add(new Point2D.Double(coords[0], coords[1]));
                    break;
                case PathIterator.SEG_LINETO:
                    points.add(new Point2D.Double(coords[0], coords[1]));
                    break;
                case PathIterator.SEG_CLOSE:
                    points.add(new Point2D.Double(coords[0], coords[1]));
                    break;
            }
            iterator.next();
        }
        return points;      
 }","static List<Point2D> pointsOf(final Shape shape){
        final List<Point2D> points = new ArrayList<Point2D>();
        final PathIterator it = shape.getPathIterator(null);
        double[] coords = new double[6];
        while (!it.isDone()) {
            switch (it.currentSegment(coords)) {
                case PathIterator.SEG_MOVETO:
                    points.add(new Point2D.Double(coords[0], coords[1]));
                    break;
                case PathIterator.SEG_LINETO:
                    points.add(new Point2D.Double(coords[0], coords[1]));
                    break;
                case PathIterator.SEG_CLOSE:
                    points.add(new Point2D.Double(coords[0], coords[1]));
                    break;
            }
            it.next();
        }
        return points;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6526612248079023,  0.6526612248079023,  0.4979512203730352,  0.5030234491304185,111.0,0.3801369863013699,111.0,0.3801369863013699,156.0,0.5416666666666666,157.0,0.5451388888888888,0.0,0.0,139.0,0.476027397260274,135.0,0.4623287671232877,10.0,0.7692307692307693,0.0,0.0,5.0,0.38461538461538464
912,cdk,"public DescriptorValue calculate(IAtomContainer container){
    boolean[] originalFlag4 = new boolean[container.getAtomCount()];
    for (int i = 0; i < originalFlag4.length; i++) {
        originalFlag4[i] = container.getAtom(i).getFlag(CDKConstants.VISITED);
    }
    if (checkAromaticity) {
        try {
            AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(container);
            Aromaticity.cdkLegacy().apply(container);
        } catch (CDKException e) {
            return getDummyDescriptorValue(e);
        }
    }
    int largestPiSystemAtomsCount = 0;
    List<IAtom> startSphere;
    List<IAtom> path;
    for (int i = 0; i < container.getAtomCount(); i++) {
        container.getAtom(i).setFlag(CDKConstants.VISITED, false);
    }
    for (int i = 0; i < container.getAtomCount(); i++) {
        if ((container.getMaximumBondOrder(container.getAtom(i)) != IBond.Order.SINGLE || Math.abs(container.getAtom(i).getFormalCharge()) >= 1 || container.getAtom(i).getFlag(CDKConstants.ISAROMATIC) || container.getAtom(i).getAtomicNumber() == IElement.N || container.getAtom(i).getAtomicNumber() == IElement.O) && !container.getAtom(i).getFlag(CDKConstants.VISITED)) {
            startSphere = new ArrayList<IAtom>();
            path = new ArrayList<IAtom>();
            startSphere.add(container.getAtom(i));
            try {
                breadthFirstSearch(container, startSphere, path);
            } catch (CDKException e) {
                return getDummyDescriptorValue(e);
            }
            if (path.size() > largestPiSystemAtomsCount) {
                largestPiSystemAtomsCount = path.size();
            }
        }
    }
    for (int i = 0; i < originalFlag4.length; i++) {
        container.getAtom(i).setFlag(CDKConstants.VISITED, originalFlag4[i]);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(largestPiSystemAtomsCount), getDescriptorNames());
}",calculate,org/openscience/cdk/qsar/descriptors/molecular/LargestPiSystemDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/LargestPiSystemDescriptor.java,"/**
     * Calculate the count of atoms of the largest pi system in the supplied {@link IAtomContainer}.
     * 
     * <p>The method require one parameter:
     * <ol>
     * <li>if checkAromaticity is true, the method check the aromaticity,
     * <li>if false, means that the aromaticity has already been checked
     * </ol>
     *
     * @param container The {@link IAtomContainer} for which this descriptor is to be calculated
     * @return the number of atoms in the largest pi system of this AtomContainer
     * @see #setParameters
     */",141-206,"('calculate', {'INSTRUCTION': {'covered': 147, 'missed': 17}, 'BRANCH': {'covered': 22, 'missed': 2}, 'LINE': {'covered': 24, 'missed': 7}, 'COMPLEXITY': {'covered': 11, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",416.0,19.0,Calculate the count of atoms of the largest pi system in the supplied {@link IAtomContainer}.,"Find the greatest pi system's atom count in the provided IAtomContainer. If ""checkAromaticity"" is true, the method checks the aromaticity. If ""checkAromaticity"" is false, it means that the aromaticity has already been verified. The method requires only one parameter.",The count of the largest pi system is calculated by using the supplied IAtomContainer.,0.306199009087694,Calculate the number of atoms of the largest pi system in the supplied {@link IAtomContainer}.," public DescriptorValue calculate(IAtomContainer container){
        try {
            return calculateValue(container);
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }"," public DescriptorValue calculate(IAtomContainer container){
        try {
            return calculateValue(container);
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }"," public DescriptorValue calculate(IAtomContainer container){
        try {
            return calculate(container, checkAromaticity);
        } catch (CDKException e) {
            return getDummyDescriptorValue(e);
        }       
 }","public DescriptorValue calculate(IAtomContainer container){
        try {
            if (container == null) {
                return getDummyDescriptorValue(new CDKException(""Null container""));
            }
            if (container.getAtomCount() == 0) {
                return getDummyDescriptorValue(new CDKException(""Empty container""));
            }
            if (checkAromaticity) {
                Aromaticity.cdkLegacy().apply(container);
            }
            int nAtomP = 0;
            for (int i = 0; i < container.getBondCount(); i++) {
                IBond bond = container.getBond(i);
                if (bond.getOrder() == IBond.Order.SINGLE) {
                    IAtom atom1 = bond.getAtom(0);
                    IAtom atom2 = bond.getAtom(1);
                    if (atom1.getSymbol().equals(""P"") && atom2.getSymbol().equals(""P"")) {
                        nAtomP++;
                    }
                }
            }
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(nAtomP),
                    getDescriptorNames());
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.0671883426041282,  0.06512222690164887,  0.3116798092761879,  0.07068856912697455,387.0,0.9280575539568345,387.0,0.9280575539568345,296.0,0.709832134292566,385.0,0.9232613908872902,0.0,0.0,179.0,0.8523809523809524,4.0,0.11764705882352941,35.0,0.875,1.0,0.0625,10.0,0.625
913,acs-aem-commons,"private boolean pathMatchesFilter(final String[] filters, String path){
    boolean matches = false;
    for (String filter : filters) {
        try {
            if (filter.equals(""*"") || path.matches(filter)) {
                matches = true;
                break;
            }
        } catch (PatternSyntaxException ex) {
            logErrorMessage(""Ignoring invalid regex filter: ["" + filter + ""].  Reason: "" + ex.getMessage());
        }
    }
    return matches;
}",pathMatchesFilter,com/adobe/acs/commons/replication/dispatcher/impl/RefetchFlushContentBuilderImpl.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/impl/RefetchFlushContentBuilderImpl.java,"/**
     * See if any of the provided filter patterns match the current path.  TRUE, if no filters are received.
     *
     * @param filters An array of string making up the regex to match with the path.  They should never
     *                be empty since there is a DEFAULT value.
     * @param path The path to interrogate.
     * @return true (match found) or false (no match)
     */",347-369,"('pathMatchesFilter', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",81.0,13.0,See if any of the provided filter patterns match the current path.,"Analyze the current path to see whether any of the specified filter patterns fit it. If no filters are received, it returns true.","If any of the filters match the current path, you should.",0.180484239687758,Check if any of the filter templates provided match the current path.,"private boolean pathMatchesFilter(final String[] filters, String path){
        if (filters == null || filters.length == 0) {
            return true;
        }
    
        for (String nextFilter: filters) {
            if (path.matches(nextFilter)) {
                return true;
            }
        }
    
        return false;
    }","private boolean pathMatchesFilter(final String[] filters, String path){
        if (filters == null || filters.length == 0) {
            return true;
        }
    
        for (String nextFilter: filters) {
            if (path.matches(nextFilter)) {
                return true;
            }
        }
    
        return false;
    }","private boolean pathMatchesFilter(final String[] filters, String path){
        if (filters == null || filters.length == 0) {
            return true;
        }
    
        for (String nextFilter: filters) {
            if (path.startsWith(nextFilter)) {
                return true;
            }
        }
    
        return false;
    }","private boolean pathMatchesFilter(final String[] filters, String path){
        if (filters == null || filters.length == 0) {
            return true;
        }
    
        for (String nextFilter: filters) {
            if (pathMatchesFilter(nextFilter, path)) {
                return true;
            }
        }
    
        return false;       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3331920308176422,  0.3331920308176422,  0.2939165283755728,  0.32422897723845423,50.0,0.6097560975609756,50.0,0.6097560975609756,50.0,0.6097560975609756,50.0,0.6097560975609756,0.0,0.0,5.0,0.0847457627118644,1.0,0.01694915254237288,18.0,0.75,4.0,0.3076923076923077,8.0,0.6153846153846154
914,cdk,"private static boolean failParse(String label, List<String> tokens){
    tokens.clear();
    tokens.add(label);
    return false;
}",failParse,org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,"/**
     * Abort call when a label could not be parsed. The tokens are cleared
     * and replaced with the original label.
     *
     * @param label  the original label
     * @param tokens the current tokens
     * @return always returns false
     */",249-261,"('failParse', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,10.0,Abort call when a label could not be parsed.,"When a label can not be parsed, end the request. The tokens are cleared, and the original label is put in their place. ","When a label could not be read, abort.",0.317289471382304,Abort the call when a label could not be analyzed.," private static boolean failParse(String label, List<String> tokens){
        tokens.clear();
        return false;
    }"," private static boolean failParse(String label, List<String> tokens){
        tokens.clear();
        tokens.add(label);
        return false;
    }"," private static boolean failParse(String label, List<String> tokens){
        tokens.clear();
        return false;
    }"," private static boolean failParse(String label, List<String> tokens){
        tokens.clear();
        return false;
    }",NOT PASS,PASS,NOT PASS,NOT PASS,  0.6619177563400733,  1.0,  0.6619177563400733,  0.6619177563400733,7.0,0.21212121212121213,0.0,0.0,7.0,0.21212121212121213,7.0,0.21212121212121213,7.0,0.21212121212121213,0.0,0.0,0.0,0.0,21.0,0.875,2.0,0.18181818181818182,5.0,0.5
915,dcache,"private Set<Checksum> finalizeChecksums(){
    _ioStateWriteLock.lock();
    try {
        _isWritable = false;
    } finally {
        _ioStateWriteLock.unlock();
    }
    synchronized (_dataRangeSet) {
        synchronized (_digests) {
            try {
                if (_dataRangeSet.asRanges().size() != 1 || _nextChecksumOffset == 0) {
                    feedZerosToDigesterForRangeGaps();
                }
                return _digests.stream().map(Checksum::new).collect(Collectors.toSet());
            } catch (IOException e) {
                _log.info(""Unable to generate checksum of sparse file: {}"", e.toString());
                return Collections.emptySet();
            }
        }
    }
}",finalizeChecksums,org/dcache/pool/movers/ChecksumChannel.java,/modules/dcache/src/main/java/org/dcache/pool/movers/ChecksumChannel.java,"/**
     * Returns the computed digest or null if overlapping writes have been detected.
     *
     * @return Checksum
     */",239-271,"('finalizeChecksums', {'INSTRUCTION': {'covered': 43, 'missed': 10}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 3}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",121.0,13.0,Returns the computed digest or null if overlapping writes have been detected.,Gives back the calculated digest. Returns null if overlapping writes were encountered. ,"If there are overlap writes, returns the computed digest.",0.377351046018884,Returns the calculated summary or null if overlapping writes were detected.," private Set<Checksum> finalizeChecksums(){
        _ioStateReadLock.lock();
        try {
            checkState(_isWritable, ""ChecksumChannel must not be written to after getChecksums"");
    
            if (_isChecksumViable) {
                _isWritable = false;
                _isChecksumViable = false;
                return _digests.stream()
                    .map(d -> new Checksum(d.getAlgorithm(), d.digest()))
                    .collect(Collectors.toSet());
            } else {
                return null;
            }
        } finally {
            _ioStateReadLock.unlock();
        }
    }","private Set<Checksum> finalizeChecksums(){
        _ioStateReadLock.lock();
        try {
            checkState(_isWritable, ""ChecksumChannel must not be written to after getChecksums"");
    
            if (_isChecksumViable) {
                try {
                    updateFromChannel(_digests, 0L, _nextChecksumOffset);
                } catch (IOException e) {
                    throw new IOException(""Failed when reading received data: ""
                        + messageOrClassName(e), e);
                }
            }
    
            return _digests.stream()
                .map(d -> new Checksum(d.getAlgorithm(), d.digest()))
                .collect(Collectors.toSet());
        } finally {
            _ioStateReadLock.unlock();
        }
    }"," private Set<Checksum> finalizeChecksums(){
        _ioStateWriteLock.lock();
        try {
            _isWritable = false;
            _isChecksumViable = false;
            _finalChecksums = _digests.stream()
                .map(d -> new Checksum(d.getAlgorithm(), d.digest()))
                .collect(Collectors.toSet());
            return _finalChecksums;
        } finally {
            _ioStateWriteLock.unlock();
        }
    }","private Set<Checksum> finalizeChecksums(){
        _ioStateWriteLock.lock();
        try {
            _isWritable = false;
            _isChecksumViable = false;
    
            if (_nextChecksumOffset > 0) {
                try {
                    updateFromChannel(_digests, 0L, _nextChecksumOffset);
                } catch (IOException e) {
                    throw new IOException(""Failed when reading received data: ""
                        + messageOrClassName(e), e);
                }
            }
    
            return _digests.stream()
                .map(d -> new Checksum(d.getAlgorithm(), d.digest()))
                .collect(Collectors.toSet());
        } finally {
            _ioStateWriteLock.unlock();
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4334708739879787,  0.5982736878789506,  0.6400324210268318,  0.45787540129676296,71.0,0.5819672131147541,70.0,0.5737704918032787,66.0,0.5409836065573771,70.0,0.5737704918032787,39.0,0.3482142857142857,50.0,0.43478260869565216,21.0,0.22580645161290322,8.0,0.6153846153846154,4.0,0.3076923076923077,12.0,0.9230769230769231
916,jackson-databind,"public String writeValueAsString(Object value) throws JsonProcessingException{
    SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());
    try {
        _writeValueAndClose(createGenerator(sw), value);
    } catch (JsonProcessingException e) {
        throw e;
    } catch (IOException e) {
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
    return sw.getAndClear();
}",writeValueAsString,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Method that can be used to serialize any Java value as
     * a String. Functionally equivalent to calling
     * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}
     * and constructing String, but more efficient.
     *<p>
     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
     */",3807-3828,"('writeValueAsString', {'INSTRUCTION': {'covered': 20, 'missed': 4}, 'LINE': {'covered': 6, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,14.0,Method that can be used to serialize any Java value as  a String.,"A method for serializing any Java value to a String. Functionally equal to creating a String by using ""StringWriter#writeValue(Writer,Object)"", but more quick. ",The method can be used toserialize any Java value.,1.07561336036725,A method that can be used to serialize any Java value as a String.," public String writeValueAsString(Object value) throws JsonProcessingException{
        StringWriter sw = new StringWriter();
        writeValue(sw, value);
        return sw.toString();
    }"," public String writeValueAsString(Object value) throws JsonProcessingException{
        StringWriter sw = new StringWriter();
        writeValue(sw, value);
        return sw.toString();
    }"," public String writeValueAsString(Object value) throws JsonProcessingException{
        StringWriter sw = new StringWriter();
        writeValue(sw, value);
        return sw.toString();
    }"," public String writeValueAsString(Object value) throws JsonProcessingException{
        StringWriter sw = new StringWriter();
        writeValue(sw, value);
        return sw.toString();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.24224859329174558,  0.24224859329174558,  0.24224859329174558,  0.24224859329174558,40.0,0.5714285714285714,40.0,0.5714285714285714,40.0,0.5714285714285714,40.0,0.5714285714285714,0.0,0.0,0.0,0.0,0.0,0.0,20.0,0.8695652173913043,2.0,0.13333333333333333,8.0,0.5714285714285714
917,tablesaw,"DoubleColumn log10(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[log10]"", size());
    for (int i = 0; i < size(); i++) {
        newColumn.set(i, Math.log10(getDouble(i)));
    }
    return newColumn;
}",log10,tech/tablesaw/columns/numbers/NumberMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/numbers/NumberMapFunctions.java,/** Returns the base 10 log of the values in this column as a NumberColumn. */,285-292,"('log10', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",62.0,15.0,Returns the base 10 log of the values in this column as a NumberColumn.,Returns the values in this column's base-10 log as a NumberColumn.,The base 10 log of the values is returned as a NumberColumn.,0.378569996567353,Returns the base 10 log of the values in this column as a Number column.,Not Valid,"DoubleColumn log10(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[log10]"", size());
    for (int i = 0; i < size(); i++) {
      newColumn.set(i, Math.log10(getDouble(i)));
    }
    return newColumn;
  }","DoubleColumn log10(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[log10]"", size());
    for (int i = 0; i < size(); i++) {
      newColumn.set(i, Math.log10(getDouble(i)));
    }
    return newColumn;
  }","DoubleColumn log10(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[log10]"", size());
    for (int i = 0; i < size(); i++) {
      newColumn.set(i, Math.log10(getDouble(i)));
    }
    return newColumn;
  }",Not Valid,PASS,PASS,PASS,None,  1.0,  1.0,  1.0,None,None,0.0,0.0,0.0,0.0,0.0,0.0,62.0,0.9841269841269841,62.0,0.9841269841269841,62.0,0.9841269841269841,8.0,0.5333333333333333,2.0,0.125,5.0,0.3333333333333333
918,cdk,"public void write(IChemObject object) throws CDKException{
    if (object instanceof IReactionSet) {
        writeReactionSet((IReactionSet) object);
    } else if (object instanceof IReaction) {
        writeReaction((IReaction) object);
    } else {
        throw new CDKException(""Only supported is writing ReactionSet, Reaction objects."");
    }
}",write,org/openscience/cdk/io/MDLRXNWriter.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLRXNWriter.java,"/**
     * Writes a IChemObject to the MDL RXN file formated output.
     * It can only output ChemObjects of type Reaction
     *
     * @param object class must be of type Molecule or MoleculeSet.
     *
     * @see org.openscience.cdk.ChemFile
     */",177-194,"('write', {'INSTRUCTION': {'covered': 17, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,11.0,Writes a IChemObject to the MDL RXN file formated output.,IChemObject is written to the output in MDL RXN file format. Only ChemObjects of the type Reaction can be produced by it. ,The MDL RXN file formated output is written in a IChemObject.,0.27447922925773,Writes an IChemObject in the formatted output of the RXN MDL file.,Empty Method,Empty Method,Empty Method," public void write(IChemObject object) throws CDKException{
        if (object instanceof IReaction) {
            write((IReaction) object);
        } else if (object instanceof IReactionSet) {
            write((IReactionSet) object);
        } else {
            throw new CDKException(""Only IReaction or IReactionSet supported."");
        }
    }",Empty Method,Empty Method,NOT PASS,Empty Method,None,None,  0.8231083950224424,None,None,None,None,None,7.0,0.12727272727272726,None,None,None,None,54.0,0.9818181818181818,None,None,17.0,0.7391304347826086,9.0,0.6923076923076923,11.0,0.9166666666666666
919,acs-aem-commons,"private void replaceInArray(JsonNode node, Map<String, Object> contentVariableReplacements){
    if (node.get(0) != null && node.get(0).isTextual()) {
        List<String> updated = new LinkedList<>();
        for (JsonNode arrayItem : node) {
            String current = arrayItem.asText();
            updated.add(replaceInString(current, contentVariableReplacements));
        }
        ((ArrayNode) node).removeAll();
        for (int i = 0; i < updated.size(); i++) {
            ((ArrayNode) node).insert(i, updated.get(i));
        }
    } else if (node.get(0) != null && node.get(0).isContainerNode()) {
        for (JsonNode arrayItem : node) {
            replaceInElements(arrayItem, contentVariableReplacements);
        }
    }
}",replaceInArray,com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,/bundle/src/main/java/com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,"/**
     * Iterates through array items and replaces any placeholders found.
     *
     * @param node Array node
     * @param contentVariableReplacements current map of content variables
     */",172-194,"('replaceInArray', {'INSTRUCTION': {'covered': 81, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",175.0,10.0,Iterates through array items and replaces any placeholders found.,Replaces the placeholders in the array items,Iterates through array items.,1.94278108772124,Browses table elements and replaces all found placeholders.," private void replaceInArray(JsonNode node, Map<String, Object> contentVariableReplacements){
        Iterator<JsonNode> elements = node.elements();
        while (elements.hasNext()) {
            JsonNode element = elements.next();
            replaceInElements(element, contentVariableReplacements);
        }       
 }"," private void replaceInArray(JsonNode node, Map<String, Object> contentVariableReplacements){
        for (JsonNode arrayItem : node) {
            replaceInElements(arrayItem, contentVariableReplacements);
        }       
 }"," private void replaceInArray(JsonNode node, Map<String, Object> contentVariableReplacements){
        Iterator<JsonNode> elements = node.elements();
        while (elements.hasNext()) {
            replaceInElements(elements.next(), contentVariableReplacements);
        }       
 }"," private void replaceInArray(JsonNode node, Map<String, Object> contentVariableReplacements){
        for (JsonNode child : node) {
            replaceInElements(child, contentVariableReplacements);
        }       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.19745942461817906,  0.13525733707682908,  0.12712025414089229,  0.16972782032243325,133.0,0.7556818181818182,142.0,0.8068181818181818,144.0,0.8181818181818182,135.0,0.7670454545454546,27.0,0.48214285714285715,27.0,0.48214285714285715,7.0,0.125,9.0,0.9,7.0,0.7,6.0,0.6
920,soul,"protected void updateCache(final ConfigGroupEnum group, final List<T> data){
    String json = GsonUtils.getInstance().toJson(data);
    ConfigDataCache newVal = new ConfigDataCache(group.name(), json, Md5Utils.md5(json), System.currentTimeMillis());
    ConfigDataCache oldVal = CACHE.put(newVal.getGroup(), newVal);
    LOG.info(""update config cache[{}], old: {}, updated: {}"", group, oldVal, newVal);
}",updateCache,org/apache/shenyu/admin/listener/AbstractDataChangedListener.java,/shenyu-admin/src/main/java/org/apache/shenyu/admin/listener/AbstractDataChangedListener.java,"/**
     * if md5 is not the same as the original, then update lcoal cache.
     * @param group ConfigGroupEnum
     * @param <T> the type of class
     * @param data the new config data
     */",225-236,"('updateCache', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,15.0,"if md5 is not the same as the original, then update lcoal cache.",Update the local cache if the MD5 does not equal the original,"If md5 is different from the original, then update the cache.",0.183585960514276,"If md5 is not the same as the original, update the lcoal cache.","protected void updateCache(final ConfigGroupEnum group, final List<T> data){
        ConfigDataCache config = CACHE.get(group.name());
        if (config == null) {
            return;
        }
        if (config.getMd5().equals(DigestUtils.md5Hex(GsonUtils.getGson().toJson(data)))) {
            return;
        }
        config.setJson(GsonUtils.getGson().toJson(data));
        config.setMd5(DigestUtils.md5Hex(GsonUtils.getGson().toJson(data)));
        config.setLastModifyTime(System.currentTimeMillis());
    }","protected void updateCache(final ConfigGroupEnum group, final List<T> data){
        ConfigDataCache config = CACHE.get(group.name());
        if (config == null) {
            config = new ConfigDataCache();
            CACHE.put(group.name(), config);
        }
        if (config.getMd5().equals(MD5Utils.getMD5(data))) {
            return;
        }
        config.setJson(GsonUtils.getGson().toJson(data));
        config.setMd5(MD5Utils.getMD5(data));
        config.setLastModifyTime(System.currentTimeMillis());
    }","protected void updateCache(final ConfigGroupEnum group, final List<T> data){
        ConfigDataCache config = CACHE.get(group.name());
        if (config == null) {
            return;
        }
        String json = GsonUtils.getGson().toJson(data);
        String md5 = DigestUtils.md5Hex(json);
        if (!config.getMd5().equals(md5)) {
            config.setMd5(md5);
            config.setJson(json);
            config.setLastModifyTime(System.currentTimeMillis());
        }
    }","protected void updateCache(final ConfigGroupEnum group, final List<T> data){
        ConfigDataCache config = CACHE.get(group.name());
        if (config == null) {
            return;
        }
        if (config.getMd5().equals(getMd5(data))) {
            return;
        }
        config.setJson(GsonUtils.getGson().toJson(data));
        config.setMd5(getMd5(data));
        config.setLastModifyTime(System.currentTimeMillis());
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4536111551063192,  0.4882300012027211,  0.4324435734172567,  0.5268326658339677,75.0,0.6198347107438017,69.0,0.5702479338842975,60.0,0.6060606060606061,64.0,0.5981308411214953,35.0,0.2892561983471074,24.0,0.19834710743801653,46.0,0.38016528925619836,13.0,0.9285714285714286,3.0,0.21428571428571427,6.0,0.42857142857142855
921,cdk,"private String formatMDLInt(int i, int l){
    String s = """", fs = """";
    NumberFormat nf = NumberFormat.getNumberInstance(Locale.ENGLISH);
    nf.setParseIntegerOnly(true);
    nf.setMinimumIntegerDigits(1);
    nf.setMaximumIntegerDigits(l);
    nf.setGroupingUsed(false);
    s = nf.format(i);
    l = l - s.length();
    for (int f = 0; f < l; f++) fs += "" "";
    fs += s;
    return fs;
}",formatMDLInt,org/openscience/cdk/io/MDLRXNWriter.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLRXNWriter.java,"/**
     * Formats an int to fit into the connectiontable and changes it
     * to a String.
     *
     * @param   i  The int to be formated
     * @param   l  Length of the String
     * @return     The String to be written into the connectiontable
     */",323-344,"('formatMDLInt', {'INSTRUCTION': {'covered': 56, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,15.0,Formats an int to fit into the connectiontable and changes it  to a String.,Converts an integer to a String after formatting it to fit in the connectiontable. ,The int is formatted to fit into the connectiontable and changed to a String.,0.630791158575775,Formats an int to fit the connection table and replaces it with a string.," private String formatMDLInt(int i, int l){
        String s = Integer.toString(i);
        while (s.length() < l) s = "" "" + s;
        return s;
    }"," private String formatMDLInt(int i, int l){
        String s = Integer.toString(i);
        while (s.length() < l) s = "" "" + s;
        return s;
    }"," private String formatMDLInt(int i, int l){
        String s = Integer.toString(i);
        while (s.length() < l) s = "" "" + s;
        return s;
    }"," private String formatMDLInt(int i, int l){
        String s = Integer.toString(i);
        while (s.length() < l) s = "" "" + s;
        return s;
    }",NOT PASS,PASS,PASS,PASS,  0.22065367909119993,  0.22065367909119993,  0.22065367909119993,  0.22065367909119993,72.0,0.6792452830188679,72.0,0.6792452830188679,72.0,0.6792452830188679,72.0,0.6792452830188679,0.0,0.0,0.0,0.0,0.0,0.0,12.0,0.8,6.0,0.4,6.0,0.4
922,cdk,"private static boolean processAtomLabels(final CharIter iter, final Map<Integer, String> dest){
    int atomIdx = 0;
    while (iter.hasNext()) {
        // fast forward through empty labels
        while (iter.nextIf(';')) atomIdx++;
        char c = iter.next();
        if (c == '$') {
            // optional
            iter.nextIf(',');
            // end of atom label
            return true;
        } else {
            // push back
            iter.pos--;
            int beg = iter.pos;
            int rollback = beg;
            while (iter.hasNext()) {
                if (iter.pos == beg && iter.curr() == '_' && iter.peek() == 'R') {
                    ++beg;
                }
                // correct step over of escaped label
                if (iter.curr() == '&') {
                    rollback = iter.pos;
                    if (iter.nextIf('&') && iter.nextIf('#') && iter.nextIfDigit()) {
                        // more digits
                        while (iter.nextIfDigit()) {
                        }
                        if (!iter.nextIf(';')) {
                            iter.pos = rollback;
                        } else {
                        }
                    } else {
                        iter.pos = rollback;
                    }
                } else if (iter.curr() == ';')
                    break;
                else if (iter.curr() == '$')
                    break;
                else
                    iter.next();
            }
            dest.put(atomIdx, unescape(iter.substr(beg, iter.pos)));
            atomIdx++;
            if (iter.nextIf('$')) {
                // optional
                iter.nextIf(',');
                return true;
            }
            if (!iter.nextIf(';'))
                return false;
        }
    }
    return false;
}",processAtomLabels,org/openscience/cdk/smiles/CxSmilesParser.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/CxSmilesParser.java,"/**
     * Process atom labels from extended SMILES in a char iter.
     *
     * @param iter char iteration
     * @param dest destination of labels (atomidx->label)
     * @return parse success/failure
     */",62-124,"('processAtomLabels', {'INSTRUCTION': {'covered': 118, 'missed': 10}, 'BRANCH': {'covered': 30, 'missed': 4}, 'LINE': {'covered': 34, 'missed': 2}, 'COMPLEXITY': {'covered': 14, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",309.0,11.0,Process atom labels from extended SMILES in a char iter.,Handle expanded SMILES' atom labels in a char iter. ,atom labels are processed in a char iter.,0.252647615578951,Process extended SMILES atom labels in a tank.,"private static boolean processAtomLabels(final CharIter iter, final Map<Integer, String> dest){
        final StringBuilder sb = new StringBuilder();
        while(iter.hasNext()){
            final char c = iter.next();
            if(c == ','){
                dest.put(dest.size(), sb.toString());
                sb.setLength(0);
            } else if(c == '.'){
                dest.put(dest.size(), sb.toString());
                sb.setLength(0);
                return true;
            } else {
                sb.append(c);
            }
        }
        dest.put(dest.size(), sb.toString());
        return false;       
 }","private static boolean processAtomLabels(final CharIter iter, final Map<Integer, String> dest){
        final StringBuilder sb = new StringBuilder();
        while(iter.hasNext()){
            final char c = iter.next();
            if(c == ')'){
                break;
            } else if(c == ','){
                dest.put(Integer.parseInt(sb.toString()), null);
                sb.setLength(0);
            } else {
                sb.append(c);
            }
        }
        if(sb.length() > 0){
            dest.put(Integer.parseInt(sb.toString()), null);
        }
        return true;        
 }",Empty Method,Empty Method,NOT PASS,NOT PASS,Empty Method,Empty Method,  0.24509435162982965,  0.2311802827484652,None,None,211.0,0.6806451612903226,217.0,0.7,None,None,None,None,54.0,0.36486486486486486,None,None,None,None,6.0,0.5454545454545454,7.0,0.6363636363636364,4.0,0.36363636363636365
923,jackson-databind,"public ArrayNode insertPOJO(int index, Object pojo){
    return _insert(index, (pojo == null) ? nullNode() : pojoNode(pojo));
}",insertPOJO,com/fasterxml/jackson/databind/node/ArrayNode.java,/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java,"/**
     * Method that will construct a POJONode and
     * insert it at specified position in this array.
     *
     * @return This array node, to allow chaining
     */",625-633,"('insertPOJO', {'INSTRUCTION': {'covered': 9, 'missed': 3}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,16.0,Method that will construct a POJONode and  insert it at specified position in this array.,Creates a POJONode and insets it into this array at the provided position.,The method will construct a POJONode and place it in this array.,0.931629513328207,Method that will construct a POJONode and insert it at the position specified in this array.," public ArrayNode insertPOJO(int index, Object pojo){
        return _insert(index, POJONode(pojo));
    }"," public ArrayNode insertPOJO(int index, Object pojo){
        return _insert(index, POJONode(pojo));
    }"," public ArrayNode insertPOJO(int index, Object pojo){
        return _insert(index, POJONode.POJO_NODE.wrap(pojo));
    }"," public ArrayNode insertPOJO(int index, Object pojo){
        return _insert(index, POJONode.POJO_NODE.wrap(pojo));
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6218236078660864,  0.6218236078660864,  0.615356450573241,  0.615356450573241,11.0,0.3235294117647059,11.0,0.3235294117647059,11.0,0.3235294117647059,11.0,0.3235294117647059,0.0,0.0,4.0,0.14285714285714285,4.0,0.14285714285714285,12.0,0.75,2.0,0.11764705882352941,6.0,0.375
924,cdk,"public Point3d[] calculate3DCoordinates1(Point3d aPoint, Point3d bPoint, Point3d cPoint, int nwanted, double length, double angle){
    Point3d[] points = new Point3d[nwanted];
    Vector3d ba = new Vector3d(aPoint);
    ba.sub(bPoint);
    ba.normalize();
    if (cPoint == null) {
        Vector3d cVector = getNonColinearVector(ba);
        cPoint = new Point3d(cVector);
    }
    Vector3d cb = new Vector3d(bPoint);
    cb.sub(cPoint);
    cb.normalize();
    double cbdotba = cb.dot(ba);
    if (cbdotba > 0.999999) {
        Vector3d cVector = getNonColinearVector(ba);
        cPoint = new Point3d(cVector);
        cb = new Vector3d(bPoint);
        cb.sub(cPoint);
    }
    Vector3d cbxba = new Vector3d();
    cbxba.cross(cb, ba);
    cbxba.normalize();
    Vector3d ax = new Vector3d();
    ax.cross(cbxba, ba);
    ax.normalize();
    double drot = Math.PI * 2.0 / (double) nwanted;
    for (int i = 0; i < nwanted; i++) {
        double rot = (double) i * drot;
        points[i] = new Point3d(aPoint);
        Vector3d vx = new Vector3d(ba);
        vx.scale(-Math.cos(angle) * length);
        Vector3d vy = new Vector3d(ax);
        vy.scale(Math.cos(rot) * length);
        Vector3d vz = new Vector3d(cbxba);
        vz.scale(Math.sin(rot) * length);
        points[i].add(vx);
        points[i].add(vy);
        points[i].add(vz);
    }
    return points;
}",calculate3DCoordinates1,org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,"/**
     *  Calculate new point(s) X in a B-A system to form B-A-X. Use C as reference
     *  for * staggering about the B-A bond (1a) 1 ligand(B) of refAtom (A) which
     *  itself has a ligand (C) (i) 1 points required; vector along AB vector (ii)
     *  2 points: 2 vectors in ABC plane, staggered and eclipsed wrt C (iii) 3
     *  points: 1 staggered wrt C, the others +- gauche wrt C If C is null, a
     *  random non-colinear C is generated
     *
     *@param  aPoint   to which substituents are added
     *@param  nwanted  number of points to calculate (1-3)
     *@param  length   A-X length
     *@param  angle    B-A-X angle
     *@param  bPoint   Description of the Parameter
     *@param  cPoint   Description of the Parameter
     *@return          Point3d[] nwanted points (or zero if failed)
     */",370-436,"('calculate3DCoordinates1', {'INSTRUCTION': {'covered': 137, 'missed': 17}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 32, 'missed': 4}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",354.0,15.0,Calculate new point(s) X in a B-A system to form B-A-X.,"To create a B-A-X system, this method determines new point(s) X in a B-A system. For reference, it uses C when talking about the B-A bond (1a) 1 ligand (B) of a refAtom (A), which possesses a ligand (C) of its own. (i) one point is needed; the vector follows the AB vector (ii) Two points: two vectors in the ABC plane, shadowed and spaced apart from C (iii) Three points: one left wrt C whereas the others were staggered. A random non-colinear C is created if C is null.",B-A-X is formed by calculating new point(s) X in a B-A system.,0.490037157452595,Calculate new X points in a B-A system to form B-A-X.,"public Point3d[] calculate3DCoordinates1(Point3d aPoint, Point3d bPoint, Point3d cPoint, int nwanted, double length, double angle){
        Point3d points[] = new Point3d[0];
        if (nwanted == 1) {
            points = new Point3d[1];
            points[0] = calculate3DCoordinates1(aPoint, bPoint, cPoint, length, angle);
        } else if (nwanted == 2) {
            points = new Point3d[2];
            points[0] = calculate3DCoordinates1(aPoint, bPoint, cPoint, length, angle);
            points[1] = calculate3DCoordinates1(aPoint, bPoint, cPoint, length, -angle);
        }
        return points;      
 }",Not Valid,"public Point3d[] calculate3DCoordinates1(Point3d aPoint, Point3d bPoint, Point3d cPoint, int nwanted, double length, double angle){
        Point3d points[] = new Point3d[0];
        if (nwanted == 1) {
            points = new Point3d[1];
            points[0] = calculate3DCoordinates1(aPoint, bPoint, cPoint, length, angle);
        } else if (nwanted == 2) {
            points = new Point3d[2];
            points[0] = calculate3DCoordinates1(aPoint, bPoint, cPoint, length, angle);
            points[1] = calculate3DCoordinates1(aPoint, bPoint, cPoint, -length, angle);
        } else if (nwanted == 3) {
            points = new Point3d[3];
            points[0] = calculate3DCoordinates1(aPoint, bPoint, cPoint, length, angle);
            points[1] = calculate3DCoordinates1(aPoint, bPoint, cPoint, -length, angle);
            points[2] = calculate3DCoordinates1(aPoint, bPoint, cPoint, 0.0, angle);
        } else if (nwanted == 4) {
            points = new Point3d[4];
            points[0] = calculate3DCoordinates1(aPoint, bPoint, cPoint, length, angle);
            points[1] = calculate3DCoordinates1(aPoint, bPoint, cPoint, -length, angle);
            points[2] = calculate3DCoordinates1(aPoint, bPoint, cPoint, 0.0, angle);
            points[3] = calculate3DCoordinates1(aPoint, bPoint, cPoint, length * 0.5, angle);
        }
        return points;      
 }",Not Valid,NOT PASS,Not Valid,Not Valid,NOT PASS,  0.14400549357618497,None,None,  0.1933989244109231,278.0,0.7830985915492957,None,None,None,None,264.0,0.7436619718309859,None,None,None,None,164.0,0.5597269624573379,84.0,0.9230769230769231,2.0,0.16666666666666666,9.0,0.6923076923076923
925,cdk,"public static Point3d[] zmatrixToCartesian(double[] distances, int[] first_atoms, double[] angles, int[] second_atoms, double[] dihedrals, int[] third_atoms){
    Point3d[] cartesianCoords = new Point3d[distances.length];
    for (int index = 0; index < distances.length; index++) {
        if (index == 0) {
            cartesianCoords[index] = new Point3d(0d, 0d, 0d);
        } else if (index == 1) {
            cartesianCoords[index] = new Point3d(distances[1], 0d, 0d);
        } else if (index == 2) {
            cartesianCoords[index] = new Point3d(-Math.cos((angles[2] / 180) * Math.PI) * distances[2] + distances[1], Math.sin((angles[2] / 180) * Math.PI) * distances[2], 0d);
            if (first_atoms[index] == 0)
                cartesianCoords[index].x = (cartesianCoords[index].x - distances[1]) * -1;
        } else {
            Vector3d cd = new Vector3d();
            cd.sub(cartesianCoords[third_atoms[index]], cartesianCoords[second_atoms[index]]);
            Vector3d bc = new Vector3d();
            bc.sub(cartesianCoords[second_atoms[index]], cartesianCoords[first_atoms[index]]);
            Vector3d n1 = new Vector3d();
            n1.cross(cd, bc);
            Vector3d n2 = rotate(n1, bc, -dihedrals[index]);
            Vector3d ba = rotate(bc, n2, -angles[index]);
            ba.normalize();
            ba.scale(distances[index]);
            Point3d result = new Point3d();
            result.add(cartesianCoords[first_atoms[index]], ba);
            cartesianCoords[index] = result;
        }
    }
    return cartesianCoords;
}",zmatrixToCartesian,org/openscience/cdk/geometry/ZMatrixTools.java,/storage/io/src/main/java/org/openscience/cdk/geometry/ZMatrixTools.java,"/**
     * Takes the given Z Matrix coordinates and converts them to cartesian coordinates.
     * The first Atom end up in the origin, the second on on the x axis, and the third
     * one in the XY plane. The rest is added by applying the Zmatrix distances, angles
     * and dihedrals. Angles are in degrees.
     *
     * @param distances     Array of distance variables of the Z matrix
     * @param angles        Array of angle variables of the Z matrix
     * @param dihedrals     Array of distance variables of the Z matrix
     * @param first_atoms   Array of atom ids of the first invoked atom in distance, angle and dihedral
     * @param second_atoms  Array of atom ids of the second invoked atom in angle and dihedral
     * @param third_atoms   Array of atom ids of the third invoked atom in dihedral
     *
     * @cdk.dictref blue-obelisk:zmatrixCoordinatesIntoCartesianCoordinates
     */",42-91,"('zmatrixToCartesian', {'INSTRUCTION': {'covered': 178, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",384.0,13.0,Takes the given Z Matrix coordinates and converts them to cartesian coordinates.,"Transforms the supplied Z Matrix coordinates to cartesian coordinates. The first atom is found at the point of origin, the second is found on the x-axis, and the third is found in the XY plane. Applying the Zmatrix distances, angles, and dihedrals adds the remaining information. Angles have a degree value. ",The Z Matrix coordinates are converted to cartesian coordinates.,0.477558458624275,Takes the coordinates of the given Z matrix and converts them to Cartesian coordinates.,Not Valid,Not Valid,Not Valid,"public static Point3d[] zmatrixToCartesian(double[] distances, int[] first_atoms, double[] angles, int[] second_atoms, double[] dihedrals, int[] third_atoms){
     
      Point3d[] coords = new Point3d[distances.length];
      for (int i=0; i<distances.length; i++){
            coords[i] = new Point3d();
      }
     
      // first atom
      coords[0].x = 0.0;
      coords[0].y = 0.0;
      coords[0].z = 0.0;
     
      // second atom
      coords[1].x = distances[0];
      coords[1].y = 0.0;
      coords[1].z = 0.0;
     
      // third atom
      coords[2].x = distances[0] + distances[1] * Math.cos(angles[0] * Math.PI / 180.0);
      coords[2].y = distances[1] * Math.sin(angles[0] * Math.PI / 180.0);
      coords[2].z = 0.0;
     
      // fourth atom
      coords[3].x = distances[0] + distances[1] * Math.cos(angles[0] * Math.PI / 180.0) + distances[2] * Math.cos(angles[1] * Math.PI / 180.0);
      coords[3].y = distances[1] * Math.sin(angles[0] * Math.PI / 180.0) + distances[2] * Math.sin(angles[1] * Math.PI / 180.0);
      coords[3].z = 0.0;
     
      // fifth atom
      coords[4].x = distances[0] + distances[1] * Math.cos(angles[0] * Math.PI / 180.0) + distances[2] * Math.cos(angles[1] * Math.PI / 180.0) + distances[3] * Math.cos(angles[2] * Math.PI / 180.0);
      coords[4].y = distances[1] * Math.sin(angles[0] * Math.PI / 180.0) + distances[2] * Math.sin(angles[          
 }",Not Valid,Not Valid,Syntax Error,Not Valid,None,None,None,None,None,None,None,None,289.0,0.6658986175115207,None,None,None,None,433.0,0.9976958525345622,None,None,46.0,0.8846153846153846,6.0,0.4,6.0,0.46153846153846156
928,glowstone,"public void putLongList(@NonNls String key, List<Long> list){
    putList(key, TagType.LONG, list, LongTag::new);
}",putLongList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Adds or replaces a list subtag with a list of longs.
     *
     * @param key the key to write to
     * @param list the list contents as longs, to convert to long tags
     */",987-995,"('putLongList', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,12.0,Adds or replaces a list subtag with a list of longs.,"Substitutes a list subtag with a list of longs, or adds one.",A list subtag is replaced with a list of longs.,0.176201704914121,Adds or replaces a list subtag with a list of long ones.," public void putLongList(@NonNls String key, List<Long> list){
        putList(key, TagType.LONG, list, LongTag::new);
    }"," public void putLongList(@NonNls String key, List<Long> list){
        putList(key, TagType.LONG, list, LongTag::new);
    }"," public void putLongList(@NonNls String key, List<Long> list){
        putList(key, TagType.LONG, list, LongTag::new);
    }"," public void putLongList(@NonNls String key, List<Long> list){
        putList(key, TagType.LONG, list, LongTag::new);
    }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,7.0,0.5384615384615384,2.0,0.15384615384615385,6.0,0.5
929,shardingsphere-elasticjob,"public List<JobRunningStatistics> findJobRunningStatisticsWeekly(){
    if (!isRdbConfigured()) {
        return Collections.emptyList();
    }
    return rdbRepository.findJobRunningStatistics(StatisticTimeUtils.getStatisticTime(StatisticInterval.DAY, -7));
}",findJobRunningStatisticsWeekly,org/apache/shardingsphere/elasticjob/cloud/scheduler/statistics/StatisticManager.java,/elasticjob-cloud/elasticjob-cloud-scheduler/src/main/java/org/apache/shardingsphere/elasticjob/cloud/scheduler/statistics/StatisticManager.java,"/**
     * Get the collection of job statistics in the most recent week.
     * 
     * @return collection of running task statistics data objects
     */",237-247,"('findJobRunningStatisticsWeekly', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,12.0,Get the collection of job statistics in the most recent week.,Obtain the most recent week's data on employment. ,The collection of job statistics is available.,0.16924381998587,Get the most recent week's employment statistics collection.,"public List<JobRunningStatistics> findJobRunningStatisticsWeekly(){
        if (!isRdbConfigured()) {
            return Collections.emptyList();
        }
        return rdbRepository.findJobRunningStatistics(StatisticTimeUtils.getStatisticTime(StatisticInterval.DAY, -7));
    }","public List<JobRunningStatistics> findJobRunningStatisticsWeekly(){
        if (!isRdbConfigured()) {
            return Collections.emptyList();
        }
        return rdbRepository.findJobRunningStatistics(StatisticTimeUtils.getStatisticTime(StatisticInterval.DAY, -7));
    }","public List<JobRunningStatistics> findJobRunningStatisticsWeekly(){
        if (!isRdbConfigured()) {
            return Collections.emptyList();
        }
        return rdbRepository.findJobRunningStatistics(StatisticTimeUtils.getStatisticTime(StatisticInterval.DAY, -7));
    }","public List<JobRunningStatistics> findJobRunningStatisticsWeekly(){
        if (!isRdbConfigured()) {
            return Collections.emptyList();
        }
        return rdbRepository.findJobRunningStatistics(StatisticTimeUtils.getStatisticTime(StatisticInterval.DAY, -7));
    }",PASS,PASS,PASS,PASS, 1.0, 1.0, 1.0, 1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10.0,0.8333333333333334,9.0,0.75,7.0,0.5833333333333334
930,cdk,"public static double evalValenceIndex(IAtomContainer atomContainer, List<List<Integer>> fragList) throws CDKException{
    try {
        IsotopeFactory ifac = Isotopes.getInstance();
        ifac.configureAtoms(atomContainer);
    } catch (IOException e) {
        throw new CDKException(""IO problem occurred when using the CDK atom config\n"" + e.getMessage(), e);
    }
    double sum = 0;
    for (List<Integer> aFragList : fragList) {
        List<Integer> frag = aFragList;
        double prod = 1.0;
        for (Object aFrag : frag) {
            int atomSerial = (Integer) aFrag;
            IAtom atom = atomContainer.getAtom(atomSerial);
            String sym = atom.getSymbol();
            if (sym.equals(""S"")) {
                double tmp = deltavSulphur(atom, atomContainer);
                if (tmp != -1) {
                    prod = prod * tmp;
                    continue;
                }
            }
            if (sym.equals(""P"")) {
                double tmp = deltavPhosphorous(atom, atomContainer);
                if (tmp != -1) {
                    prod = prod * tmp;
                    continue;
                }
            }
            int z = atom.getAtomicNumber();
            int zv = getValenceElectronCount(atom);
            int hsupp = atom.getImplicitHydrogenCount();
            double deltav = (double) (zv - hsupp) / (double) (z - zv - 1);
            prod = prod * deltav;
        }
        if (prod != 0)
            sum += 1.0 / Math.sqrt(prod);
    }
    return sum;
}",evalValenceIndex,org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,"/**
     * Evaluates the valence corrected chi index for a set of fragments.
     * 
     * This method takes into account the S and P atom types described in
     * Kier & Hall (1986), page 20 for which empirical delta V values are used.
     *
     * @param atomContainer The target <code>AtomContainer</code>
     * @param fragList      A list of fragments
     * @return The valence corrected chi index
     * @throws CDKException if the <code>IsotopeFactory</code> cannot be created
     */",122-178,"('evalValenceIndex', {'INSTRUCTION': {'covered': 113, 'missed': 20}, 'BRANCH': {'covered': 12, 'missed': 2}, 'LINE': {'covered': 28, 'missed': 4}, 'COMPLEXITY': {'covered': 6, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",279.0,12.0,Evaluates the valence corrected chi index for a set of fragments.,"For a group of fragments, this method determines the valence corrected chi index.  The S and P atom types mentioned in Kier & Hall (1986), page 20, for which empirical delta V values are utilized, are taken into consideration by this method.",Evaluates the chi index for a set of fragments.,0.141464324381515,Evaluates the valence-corrected chi index for a set of fragments.,"public static double evalValenceIndex(IAtomContainer atomContainer, List<List<Integer>> fragList) throws CDKException{
        double sum = 0;
        for (List<Integer> fragList : fragList) {
            double prod = 1.0;
            for (Integer atomSerial : fragList) {
                IAtom atom = atomContainer.getAtom(atomSerial);
                int nconnected = AtomValenceTool.getValence(atom);
                prod = prod * nconnected;
            }
            if (prod != 0) sum += 1.0 / Math.sqrt(prod);
        }
        return sum;
    }","public static double evalValenceIndex(IAtomContainer atomContainer, List<List<Integer>> fragList) throws CDKException{
        double sum = 0;
        for (List<Integer> frag : fragList) {
            double prod = 1.0;
            for (Integer atomSerial : frag) {
                IAtom atom = atomContainer.getAtom(atomSerial);
                int nconnected = atomContainer.getConnectedBondsCount(atom);
                prod = prod * nconnected;
            }
            if (prod != 0) sum += 1.0 / Math.sqrt(prod);
        }
        return sum;
    }","public static double evalValenceIndex(IAtomContainer atomContainer, List<List<Integer>> fragList) throws CDKException{
        double sum = 0;
        for (List<Integer> fragList : fragList) {
            double prod = 1.0;
            for (Integer atomSerial : fragList) {
                IAtom atom = atomContainer.getAtom(atomSerial);
                int nconnected = atomContainer.getConnectedBondsCount(atom);
                prod = prod * nconnected;
            }
            if (prod != 0) sum += 1.0 / Math.sqrt(prod);
        }
        return sum;
    }","public static double evalValenceIndex(IAtomContainer atomContainer, List<List<Integer>> fragList) throws CDKException{
        double sum = 0;
        for (List<Integer> fragList : fragList) {
            double prod = 1.0;
            for (Integer atomSerial : fragList) {
                IAtom atom = atomContainer.getAtom(atomSerial);
                int nconnected = AtomValenceTool.getValence(atom);
                prod = prod * nconnected;
            }
            if (prod != 0) sum += 1.0 / Math.sqrt(prod);
        }
        return sum;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.24278217198787494,  0.2460461307224045,  0.24278217198787494,  0.24298368127146242,189.0,0.675,188.0,0.6714285714285714,189.0,0.675,189.0,0.675,4.0,0.04040404040404041,0.0,0.0,2.0,0.020202020202020204,37.0,0.8604651162790697,2.0,0.16666666666666666,2.0,0.16666666666666666
931,matsim-libs,"public boolean put(final double x, final double y, final T value){
    if (!this.top.bounds.containsOrEquals(x, y)) {
        throw new IllegalArgumentException(""cannot add a point at x="" + x + "", y="" + y + "" with bounds "" + this.top.bounds);
    }
    if (this.top.put(x, y, value)) {
        incrementSize();
        return true;
    }
    return false;
}",put,org/matsim/core/utils/collections/QuadTree.java,/matsim/src/main/java/org/matsim/core/utils/collections/QuadTree.java,"/**
         * Associates the specified value with the specified coordinates in this
         * QuadTree.
         *
         * @param x x-coordinate where the specified value is to be associated.
         * @param y y-coordinate where the specified value is to be associated.
         * @param value value to be associated with the specified coordinates.
         *
         * @return true if insertion was successful and the data structure changed,
         *         false otherwise.
         */",75-95,"('put', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,12.0,Associates the specified value with the specified coordinates in this  QuadTree.,"In this QuadTree, a connection is made between the supplied value and the specified coordinates. ",The QuadTree has specified coordinates.,0.299165802015411,Associates the specified value with the coordinates specified in this QuadTree.," public boolean put(final double x, final double y, final T value){
	 		if (value == null) throw new IllegalArgumentException(""value must not be null."");
 		if (x < this.top.minX || x > this.top.maxX || y < this.top.minY || y > this.top.maxY) {
 			throw new IllegalArgumentException(""The point "" + x + "","" + y + "" is not in the bounds of the QuadTree."");
 		}
 		Node<T> node = this.top;
 		while (node != null) {
 			if (node.isLeaf()) {
 				if (node.put(x, y, value)) {
 					this.incrementSize();
 					return true;
 				}
 				return false;
 			}
 			node = node.getChild(x, y);
 		}
 		return false;
 	}"," public boolean put(final double x, final double y, final T value){
	 		if (value == null) throw new IllegalArgumentException(""value must not be null."");
 		if (x < this.top.minX || x > this.top.maxX || y < this.top.minY || y > this.top.maxY) {
 			throw new IllegalArgumentException(""The point "" + x + "","" + y + "" is not within the bounds of the QuadTree."");
 		}
 		Node<T> node = this.top;
 		while (node != null) {
 			if (node.contains(x, y)) {
 				if (node.value != null) {
 					throw new IllegalArgumentException(""The point "" + x + "","" + y + "" is already contained in the QuadTree."");
 				}
 				node.value = value;
 				this.incrementSize();
 				return true;
 			}
 			node = node.getChild(x, y);
 		}
 		return false;
 	}"," public boolean put(final double x, final double y, final T value){
	 		if (value == null) throw new IllegalArgumentException(""value must not be null."");
 		if (this.top == null) throw new IllegalStateException(""QuadTree is empty."");
 		Node<T> node = this.top;
 		while (node != null) {
 			if (node.contains(x, y)) {
 				if (node.isLeaf()) {
 					node.add(value);
 					this.incrementSize();
 					return true;
 				} else {
 					node = node.getChild(x, y);
 				}
 			} else {
 				node = node.getNext();
 			}
 		}
 		return false;
 	}"," public boolean put(final double x, final double y, final T value){
	 		if (value == null) throw new IllegalArgumentException(""value must not be null."");
 		if (x < this.top.minX || x > this.top.maxX || y < this.top.minY || y > this.top.maxY) {
 			throw new IllegalArgumentException(""The point "" + x + "","" + y + "" is not within the bounds of the QuadTree."");
 		}
 		Node<T> node = this.top;
 		while (node != null) {
 			if (node.contains(x, y)) {
 				if (node.value != null) {
 					throw new IllegalArgumentException(""The point "" + x + "","" + y + "" is already contained in the QuadTree."");
 				}
 				node.value = value;
 				this.incrementSize();
 				return true;
 			}
 			node = node.getChild(x, y);
 		}
 		return false;
 	}",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6429443096978773,  0.5893069092033085,  0.5893069092033085,  0.5210735063771708,85.0,0.5592105263157895,106.0,0.6309523809523809,106.0,0.6309523809523809,83.0,0.6287878787878788,32.0,0.19047619047619047,32.0,0.19047619047619047,71.0,0.46710526315789475,14.0,0.875,2.0,0.16666666666666666,10.0,0.8333333333333334
932,cdk,"public Object clone() throws CloneNotSupportedException{
    Mapping clone = (Mapping) super.clone();
    if (relation != null) {
        clone.relation = new IChemObject[relation.length];
        for (int f = 0; f < relation.length; f++) {
            if (relation[f] != null) {
                clone.relation[f] = (IChemObject) relation[f].clone();
            }
        }
    }
    return clone;
}",clone,org/openscience/cdk/silent/Mapping.java,/base/silent/src/main/java/org/openscience/cdk/silent/Mapping.java,"/**
     * Clones this <code>Mapping</code> and the mapped <code>IChemObject</code>s.
     *
     * @return  The cloned object
     */",118-136,"('clone', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,21.0,Clones this <code>Mapping</code> and the mapped <code>IChemObject</code>s.,Copies both this mapping and the IChemObjects it contains. ,This is a clone of the mapped code>IChemObject/code>s.,0.796903573317898,Clone this <code>mapping</code> and the mapped <code>IChemObjects</code>.,"public Object clone() throws CloneNotSupportedException{
        Mapping clone = (Mapping)super.clone();
        clone.relation = new IChemObject[2];
        clone.relation[0] = (IChemObject)relation[0].clone();
        clone.relation[1] = (IChemObject)relation[1].clone();
        return clone;
    }","public Object clone() throws CloneNotSupportedException{
        Mapping clone = (Mapping) super.clone();
        clone.relation = new IChemObject[2];
        clone.relation[0] = (IChemObject) relation[0].clone();
        clone.relation[1] = (IChemObject) relation[1].clone();
        return clone;       
 }","public Object clone() throws CloneNotSupportedException{
        Mapping clone = (Mapping)super.clone();
        clone.relation = new IChemObject[2];
        clone.relation[0] = (IChemObject)relation[0].clone();
        clone.relation[1] = (IChemObject)relation[1].clone();
        return clone;
    }","public Object clone() throws CloneNotSupportedException{
        Mapping clone = (Mapping)super.clone();
        clone.relation = new IChemObject[2];
        clone.relation[0] = (IChemObject)relation[0].clone();
        clone.relation[1] = (IChemObject)relation[1].clone();
        return clone;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.42531664403044567,  0.4060858747996764,  0.4060858747996764,  0.42531664403044567,37.0,0.3978494623655914,37.0,0.3978494623655914,37.0,0.3978494623655914,37.0,0.3978494623655914,0.0,0.0,0.0,0.0,0.0,0.0,6.0,0.6,3.0,0.375,6.0,0.6666666666666666
933,tablesaw,"private void withMissingLeftJoin(Table destination, Table table1, Selection table1Rows, Set<Integer> ignoreColumns, boolean keepTable2JoinKeyColumns){
    for (int c = 0; c < destination.columnCount(); c++) {
        if (!keepTable2JoinKeyColumns && ignoreColumns.contains(c)) {
            continue;
        }
        if (c < table1.columnCount()) {
            Column t1Col = table1.column(c);
            for (int index : table1Rows) {
                destination.column(c).append(t1Col, index);
            }
        } else {
            for (int r1 = 0; r1 < table1Rows.size(); r1++) {
                destination.column(c).appendMissing();
            }
        }
    }
}",withMissingLeftJoin,tech/tablesaw/joining/DataFrameJoiner.java,/core/src/main/java/tech/tablesaw/joining/DataFrameJoiner.java,"/**
   * Adds rows to destination for each row in table1 with the columns from table2 added as missing
   * values.
   */",875-901,"('withMissingLeftJoin', {'INSTRUCTION': {'covered': 58, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",139.0,19.0,Adds rows to destination for each row in table1 with the columns from table2 added as missing  values.,"Every row in table 1 will have additional rows added to the destination, with the columns from table 2 being used to fill in any gaps.",Adding rows to destination for each row in table1 and columns to table2 adds missing values.,0.615075144398616,Adds destination rows for each row in table1 with the columns in table2 added as missing values.,"private void withMissingLeftJoin(Table destination, Table table1, Selection table1Rows, Set<Integer> ignoreColumns, boolean keepTable2JoinKeyColumns){
    for (int r1 : table1Rows) {
      Row row = table1.row(r1);
      for (int c = 0; c < table1.columnCount(); c++) {
        if (!keepTable2JoinKeyColumns && ignoreColumns.contains(c)) {
          continue;
        }
        destination.column(c).append(table1.column(c), r1);
      }
      for (int c = table1.columnCount(); c < destination.columnCount(); c++) {
        destination.column(c).append(null, r1);
      }
    }   
 }","private void withMissingLeftJoin(Table destination, Table table1, Selection table1Rows, Set<Integer> ignoreColumns, boolean keepTable2JoinKeyColumns){
    for (int c = 0; c < table1.columnCount(); c++) {
      if (!keepTable2JoinKeyColumns && ignoreColumns.contains(c)) {
        continue;
      }
      Column t1Col = table1.column(c);
      for (int r1 : table1Rows) {
        destination.column(c).append(t1Col, r1);
      }
    }   
 }","private void withMissingLeftJoin(Table destination, Table table1, Selection table1Rows, Set<Integer> ignoreColumns, boolean keepTable2JoinKeyColumns){
    for (int c = 0; c < table1.columnCount(); c++) {
      if (!keepTable2JoinKeyColumns && ignoreColumns.contains(c)) {
        continue;
      }
      Column t1Col = table1.column(c);
      for (int r1 : table1Rows) {
        destination.column(c).append(t1Col, r1);
      }
    }   
 }","private void withMissingLeftJoin(Table destination, Table table1, Selection table1Rows, Set<Integer> ignoreColumns, boolean keepTable2JoinKeyColumns){
    for (int r1 : table1Rows) {
      for (int c = 0; c < table1.columnCount(); c++) {
        if (!keepTable2JoinKeyColumns && ignoreColumns.contains(c)) {
          continue;
        }
        Column t1Col = table1.column(c);
        destination.column(c).append(t1Col, r1);
      }
      for (int c = table1.columnCount(); c < destination.columnCount(); c++) {
        destination.column(c).append(null, r1);
      }
    }   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6755632333847352,  0.6713706571396756,  0.6942633960360463,  0.6713706571396756,66.0,0.4714285714285714,48.0,0.34285714285714286,47.0,0.3357142857142857,48.0,0.34285714285714286,50.0,0.36496350364963503,22.0,0.16058394160583941,50.0,0.36496350364963503,22.0,0.8148148148148148,4.0,0.21052631578947367,6.0,0.3157894736842105
934,dataverse,"public boolean isLockedFor(DatasetLock.Reason reason){
    for (DatasetLock l : getLocks()) {
        if (l.getReason() == reason) {
            return true;
        }
    }
    return false;
}",isLockedFor,edu/harvard/iq/dataverse/Dataset.java,/src/main/java/edu/harvard/iq/dataverse/Dataset.java,"/**
     * Checks whether {@code this} dataset is locked for a given reason.
     * @param reason the reason we test for.
     * @return {@code true} iff the data set is locked for {@code reason}.
     */",164-176,"('isLockedFor', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,15.0,Checks whether {@code this} dataset is locked for a given reason.,Determines if this dataset is locked for the specified reason. ,Does a check to see if the dataset is locked for a reason.,1.46130920833579,Checks whether the dataset {@code this} is locked for a given reason.," public boolean isLockedFor(DatasetLock.Reason reason){
        for (DatasetLock lock : datasetLocks) {
            if (lock.getReason() == reason) {
                return true;
            }
        }
        return false;
    }"," public boolean isLockedFor(DatasetLock.Reason reason){
        if (datasetLocks == null) {
            return false;
        }
        for (DatasetLock datasetLock : datasetLocks) {
            if (datasetLock.getReason() == reason) {
                return true;
            }
        }
        return false;
    }"," public boolean isLockedFor(DatasetLock.Reason reason){
        if (datasetLocks == null){
            return false;
        }
        for (DatasetLock datasetLock : datasetLocks){
            if (datasetLock.getReason().equals(reason)){
                return true;
            }
        }
        return false;       
 }"," public boolean isLockedFor(DatasetLock.Reason reason){
        if (datasetLocks == null) {
            return false;
        }
        for (DatasetLock lock : datasetLocks) {
            if (lock.getReason() == reason) {
                return true;
            }
        }
        return false;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.8385977104311699,  0.7857446274102031,  0.7857446274102031,  0.6973592969317327,5.0,0.12195121951219512,16.0,0.32,16.0,0.32,20.0,0.37735849056603776,13.0,0.26,11.0,0.22,17.0,0.32075471698113206,6.0,0.5,3.0,0.23076923076923078,8.0,0.5714285714285714
935,cdk,"public Object clone() throws CloneNotSupportedException{
    SingleElectron clone = (SingleElectron) super.clone();
    if (atom != null) {
        clone.atom = (IAtom) ((IAtom) atom).clone();
    }
    return clone;
}",clone,org/openscience/cdk/SingleElectron.java,/base/data/src/main/java/org/openscience/cdk/SingleElectron.java,"/**
     * Clones this SingleElectron object, including a clone of the atom for which the
     * SingleElectron is defined.
     *
     * @return    The cloned object
     */",143-157,"('clone', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",50.0,18.0,"Clones this SingleElectron object, including a clone of the atom for which the  SingleElectron is defined.","Copies this SingleElectron object, including a copy of the atom for which it is defined.","The SingleElectron object is cloned, along with the atom for which it is defined.",0.827882426759804,"Clone this SingleElectron object, including a clone of the atom for which the SingleElectron is defined."," public Object clone() throws CloneNotSupportedException{
        SingleElectron clone = (SingleElectron)super.clone();
        if (atom != null) clone.atom = (IAtom)atom.clone();
        return clone;       
 }"," public Object clone() throws CloneNotSupportedException{
        SingleElectron clone = (SingleElectron)super.clone();
        if (atom != null) clone.atom = (IAtom)atom.clone();
        return clone;       
 }"," public Object clone() throws CloneNotSupportedException{
        SingleElectron clone = (SingleElectron) super.clone();
        clone.atom = (IAtom) atom.clone();
        return clone;
    }"," public Object clone() throws CloneNotSupportedException{
        SingleElectron clone = (SingleElectron) super.clone();
        if (atom != null) clone.atom = (IAtom) atom.clone();
        return clone;
    }",PASS,PASS,PASS,NOT PASS,  0.7626238073902194,  0.7626238073902194,  0.7626238073902194,  0.6124330389655424,7.0,0.13725490196078433,7.0,0.13725490196078433,7.0,0.13725490196078433,13.0,0.2549019607843137,0.0,0.0,0.0,0.0,6.0,0.13636363636363635,4.0,0.23529411764705882,1.0,0.058823529411764705,9.0,0.5294117647058824
936,cdk,"protected static double deltavSulphur(IAtom atom, IAtomContainer atomContainer){
    if (atom.getAtomicNumber() != IElement.S)
        return -1;
    List<IAtom> connected = atomContainer.getConnectedAtomsList(atom);
    for (IAtom connectedAtom : connected) {
        if (connectedAtom.getAtomicNumber() == IElement.S && atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.SINGLE)
            return .89;
    }
    int count = 0;
    for (IAtom connectedAtom : connected) {
        if (connectedAtom.getAtomicNumber() == IElement.O && atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.DOUBLE)
            count++;
    }
    if (count == 1)
        return 1.33;
    else if (count == 2)
        return 2.67;
    return -1;
}",deltavSulphur,org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,"/**
     * Evaluates the empirical delt V for some S environments.
     * 
     * The method checks to see whether a S atom is in a -S-S-,
     * -SO-, -SO2- group and returns the empirical values noted
     * in Kier & Hall (1986), page 20.
     *
     * @param atom          The S atom in question
     * @param atomContainer The molecule containing the S
     * @return The empirical delta V if it is present in one of the above
     *         environments, -1 otherwise
     */",185-217,"('deltavSulphur', {'INSTRUCTION': {'covered': 63, 'missed': 11}, 'BRANCH': {'covered': 13, 'missed': 5}, 'LINE': {'covered': 14, 'missed': 1}, 'COMPLEXITY': {'covered': 6, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",156.0,10.0,Evaluates the empirical delt V for some S environments.,"The empirical delt V for some S settings is evaluated.  The approach returns the empirical values mentioned in Kier & Hall (1986), page 20, and determines if a S atom is a member of a -S-S-, -SO-, or -SO2- group.",Evaluates the empirical delt V for S environments.,0.403647046060232,Evaluates empirical delt V for selected S environments.,Not Valid,"protected static double deltavSulphur(IAtom atom, IAtomContainer atomContainer){
        int hcount = atom.getImplicitHydrogenCount();
        int z = atom.getAtomicNumber();
        int zv = getValenceElectronCount(atom);
        int nconnected = atomContainer.getConnectedBondsCount(atom);
        int nconnected2 = atomContainer.getConnectedBondsCount(atomContainer.getConnectedAtomsList(atom));
        int nconnected3 = atomContainer.getConnectedBondsCount(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atom)));
        int nconnected4 = atomContainer.getConnectedBondsCount(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atom))));
        int nconnected5 = atomContainer.getConnectedBondsCount(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atom)))));
        int nconnected6 = atomContainer.getConnectedBondsCount(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atom))))));
        int nconnected7 = atomContainer.getConnectedBondsCount(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atom)))))));
        int nconnected8 = atomContainer.getConnectedBondsCount(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atomContainer.getConnectedAtomsList(atom))))))));
        int nconnected9 = atomContainer.getConnectedBondsCount(atomContainer        
 }","protected static double deltavSulphur(IAtom atom, IAtomContainer atomContainer){
        int hcount = atom.getImplicitHydrogenCount();
        int z = atom.getAtomicNumber();
        int zv = getValenceElectronCount(atom);
        int nconnected = atomContainer.getConnectedBondsCount(atom);
        double deltav = (double) (zv - hcount) / (double) (z - zv - 1);
        if (nconnected == 1) {
            if (hcount == 1) {
                deltav = 0.5;
            } else if (hcount == 2) {
                deltav = 0.75;
            }
        } else if (nconnected == 2) {
            if (hcount == 1) {
                deltav = 0.25;
            } else if (hcount == 2) {
                deltav = 0.5;
            }
        } else if (nconnected == 3) {
            if (hcount == 1) {
                deltav = 0.75;
            } else if (hcount == 2) {
                deltav = 0.5;
            }
        } else if (nconnected == 4) {
            if (hcount == 1) {
                deltav = 0.5;
            } else if (hcount == 2) {
                deltav = 0.25;
            }
        } else if (nconnected == 5) {
            if (hcount == 1) {
                deltav = 0.25;
            }
        } else if (nconnected == 6) {
            if (hcount == 1) {
                deltav = 0.75;
            }
        } else if (nconnected == 7) {
            if (hcount == 1) {
                deltav = 0.5;
            }
        } else if (nconnected == 8) {
            if (hcount == 1) {
                deltav = 0.25;
            }
        } else if (nconnected == 9) {
            if (hcount == 1) {
                deltav = 0.75;
            }
        } else if (nconnected == 10     
 }",Not Valid,Not Valid,Syntax Error,Not Valid,Syntax Error,None,None,None,None,None,None,None,None,None,None,246.0,0.7711598746081505,None,None,None,None,318.0,0.9968652037617555,35.0,0.8536585365853658,2.0,0.2,1.0,0.1
937,weblogic-kubernetes-operator,"public boolean isLocalAdminProtocolChannelSecure(){
    boolean adminProtocolPortSecure = false;
    boolean adminProtocolPortFound = false;
    if (networkAccessPoints != null) {
        for (NetworkAccessPoint nap : networkAccessPoints) {
            if (nap.isAdminProtocol()) {
                adminProtocolPortFound = true;
                adminProtocolPortSecure = true;
                break;
            }
        }
    }
    if (!adminProtocolPortFound) {
        if (adminPort != null) {
            adminProtocolPortSecure = true;
        } else if (sslListenPort != null) {
            adminProtocolPortSecure = true;
        } else if (listenPort != null) {
            adminProtocolPortSecure = false;
        }
    }
    return adminProtocolPortSecure;
}",isLocalAdminProtocolChannelSecure,oracle/kubernetes/operator/wlsconfig/WlsServerConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsServerConfig.java,"/**
   * Check if the admin protocol channel is using a secure protocol like T3S or HTTPS.
   * @return true is a secure protocol is being used
   */",383-409,"('isLocalAdminProtocolChannelSecure', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 13, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",102.0,16.0,Check if the admin protocol channel is using a secure protocol like T3S or HTTPS.,"Verify whether the admin protocol channel is employing a secure protocol, such as HTTPS or T3S.","If the admin protocol channel uses a secure protocol, you should check it.",0.112277984682776,Check if the administration protocol channel uses a secure protocol such as T3S or HTTPS.," public boolean isLocalAdminProtocolChannelSecure(){
    boolean isSecure = false;
    if (networkAccessPoints != null) {
      for (NetworkAccessPoint nap : networkAccessPoints) {
        if (nap.isAdminProtocol()) {
          isSecure = nap.isSecure();
          break;
        }
      }
    }
    return isSecure;
  }"," public boolean isLocalAdminProtocolChannelSecure(){
    boolean isSecure = false;
    if (networkAccessPoints != null) {
      for (NetworkAccessPoint nap : networkAccessPoints) {
        if (nap.isAdminProtocol()) {
          isSecure = nap.isSecure();
          break;
        }
      }
    }
    return isSecure;
  }"," public boolean isLocalAdminProtocolChannelSecure(){
    boolean isSecure = false;
    if (networkAccessPoints != null) {
      for (NetworkAccessPoint nap : networkAccessPoints) {
        if (nap.isAdminProtocol()) {
          isSecure = nap.isSecure();
          break;
        }
      }
    }
    return isSecure;
  }"," public boolean isLocalAdminProtocolChannelSecure(){
    boolean isSecure = false;
    if (networkAccessPoints != null) {
      for (NetworkAccessPoint nap : networkAccessPoints) {
        if (nap.isAdminProtocol()) {
          isSecure = nap.isSecure();
          break;
        }
      }
    }
    return isSecure;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4894489205309135,  0.4894489205309135,  0.4894489205309135,  0.4894489205309135,57.0,0.5533980582524272,57.0,0.5533980582524272,57.0,0.5533980582524272,57.0,0.5533980582524272,0.0,0.0,0.0,0.0,0.0,0.0,8.0,0.47058823529411764,5.0,0.3125,9.0,0.5625
938,dcache,"public void addChild(BulkJob job){
    Preconditions.checkArgument(job.getParentKey().getRequestId().equals(job.getKey().getRequestId()), ""Job completion listener is "" + ""being shared between two "" + ""different requests! "" + ""This is a bug."");
    synchronized (descendants) {
        Long parentId = job.getParentKey().getJobId();
        Long childId = job.getKey().getJobId();
        descendants.put(parentId, childId);
        LOGGER.trace(""addChild: parent {}, child {}; descendants {}."", parentId, childId, descendants.size());
    }
}",addChild,org/dcache/services/bulk/handlers/BulkJobCompletionHandler.java,/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/handlers/BulkJobCompletionHandler.java,"/**
     * When a job is submitted, it adds itself as the child of a parent job.  When it terminates, it
     * removes itself from the parent list.  The multimap implementation automatically removes the
     * parent key from the table when its child collection is empty.
     * <p>
     * Breadth-first directories do not remove themselves from the map until all their children are
     * registered.
     * <p>
     * Depth-first directories wait for their immediate children to terminate.  Subdirectories of
     * the root expansion node do not add themselves as children, since the expansion is done by
     * recursion rather than exec'ing a new job (as in breadth-first).
     */",107-134,"('addChild', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",103.0,17.0,"When a job is submitted, it adds itself as the child of a parent job.","A job inserts itself as a child of a parent job when it is submitted. It eliminates itself from the parent list when it ends. When the child collection of a multimap implementation is empty, the parent key is automatically deleted from the table.  Breadth-first directories wait until all of their offspring have registered before removing themselves from the map.   Depth-first directories watch for the termination of their immediate children. Since the expansion is performed through recursion rather than by executing a new job, subdirectories of the root expansion node do not add themselves as children (as in breadth-first). ","When a job is submitted, it becomes the child of a parent job.",0.218577652547556,"When a task is submitted, it is added as a child of a parent task."," public void addChild(BulkJob job){
        descendants.put(job.getParentId(), job.getId());        
 }",Empty Method," public void addChild(BulkJob job){
        descendants.put(job.getParentId(), job.getId());        
 }"," public void addChild(BulkJob job){
        descendants.put(job.getParentId(), job.getId());        
 }",NOT PASS,Empty Method,NOT PASS,NOT PASS,  0.17565641438715413,None,  0.17565641438715413,  0.17565641438715413,81.0,0.7788461538461539,None,None,81.0,0.7788461538461539,81.0,0.7788461538461539,None,None,0.0,0.0,0.0,0.0,90.0,0.9,5.0,0.3125,3.0,0.1875
939,egeria,"private String createPort(String userId, Port port, String entityTpeName, String processGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    final String methodName = ""createPort"";
    validatePortParameters(userId, port.getQualifiedName(), port.getDisplayName(), methodName);
    invalidParameterHandler.validateGUID(processGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    String externalSourceGUID = registrationHandler.getExternalDataEngine(userId, externalSourceName);
    return portHandler.createPort(userId, externalSourceGUID, externalSourceName, processGUID, PROCESS_GUID_PARAMETER_NAME, port.getQualifiedName(), port.getDisplayName(), port.getPortType().getOrdinal(), port.getAdditionalProperties(), entityTpeName, null, methodName);
}",createPort,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,"/**
     * Create the port and attach it to the process.
     *
     * @param userId             the name of the calling user
     * @param port               the port values
     * @param entityTpeName      the type name
     * @param externalSourceName the unique name of the external source
     * @param processGUID        the unique identifier of the process containing the port
     *
     * @return unique identifier of the port in the repository
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */",157-183,"('createPort', {'INSTRUCTION': {'covered': 43, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",127.0,10.0,Create the port and attach it to the process.,"Creates the given port, then associates it to the given process, given its unique identifier. It returns the unique identifier of the port in the repository. ",Attach the port to the process.,0.590499991565058,Create the port and attach it to the process.," private String createPort(String userId, Port port, String entityTpeName, String processGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        String portGUID = null;
    
        if (port != null) {
            portGUID = portHandler.createPort(userId, port, entityTpeName, processGUID, externalSourceName);
        }
    
        return portGUID;        
 }"," private String createPort(String userId, Port port, String entityTpeName, String processGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        String portGUID = null;
    
        if (port != null) {
            portGUID = portHandler.createPort(userId, port, entityTpeName, externalSourceName);
    
            if (portGUID != null) {
                dataEngineCommonHandler.attachPortToProcess(userId, processGUID, portGUID, externalSourceName);
            }
        }
    
        return portGUID;        
 }"," private String createPort(String userId, Port port, String entityTpeName, String processGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        String portGUID = null;
    
        if (port != null) {
            portGUID = portHandler.createPort(userId, port, entityTpeName, processGUID, externalSourceName);
        }
    
        return portGUID;        
 }"," private String createPort(String userId, Port port, String entityTpeName, String processGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
        String portGUID = null;
    
        if (port != null) {
            portGUID = portHandler.createPort(userId, port, entityTpeName, processGUID, externalSourceName);
        }
    
        return portGUID;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3170400822958074,  0.37027659295078785,  0.3170400822958074,  0.3170400822958074,81.0,0.6328125,77.0,0.6015625,81.0,0.6328125,81.0,0.6328125,19.0,0.2375,0.0,0.0,0.0,0.0,22.0,0.8148148148148148,0.0,0.0,4.0,0.4
940,logstash-logback-encoder,"private NodeWriter<Event> parseNode(JsonPointer location, JsonNode node) throws JsonPatternException{
    if (node.isTextual()) {
        try {
            ValueGetter<Event, ?> getter = makeComputableValueGetter(node.asText());
            return new ValueWriter<>(getter);
        } catch (RuntimeException e) {
            String msg = ""Invalid JSON property '"" + location + ""' (was '"" + node.asText() + ""'): "" + e.getMessage();
            throw new JsonPatternException(msg, e);
        }
    }
    if (node.isArray()) {
        return parseArray(location, (ArrayNode) node);
    }
    if (node.isObject()) {
        return parseObject(location, (ObjectNode) node);
    }
    return new ValueWriter<>(g -> node);
}",parseNode,net/logstash/logback/pattern/AbstractJsonPatternParser.java,/src/main/java/net/logstash/logback/pattern/AbstractJsonPatternParser.java,"/**
     * Parse a {@link JsonNode} and produce the corresponding {@link NodeWriter}.
     * 
     * @param node the {@link JsonNode} to parse.
     * @return a {@link NodeWriter} corresponding to the given JSON node
     * @throws JsonPatternException denotes an invalid pattern
     */",307-333,"('parseNode', {'INSTRUCTION': {'covered': 63, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",148.0,17.0,Parse a {@link JsonNode} and produce the corresponding {@link NodeWriter}.,Create the corresponding NodeWriter by parsing a JsonNode. ,Parse a @link JsonNode and then produce the corresponding @link NodeWriter.,1.10049863697193,Analyze a {JsonNode} @link and produce the corresponding {@link NodeWriter}.," private NodeWriter<Event> parseNode(JsonPointer location, JsonNode node) throws JsonPatternException{
        if (node.isObject()) {
            return parseObject(location, node);
        } else if (node.isArray()) {
            return parseArray(location, node);
        } else if (node.isTextual()) {
            return parseText(location, node);
        } else if (node.isNumber()) {
            return parseNumber(location, node);
        } else if (node.isBoolean()) {
            return parseBoolean(location, node);
        } else if (node.isNull()) {
            return parseNull(location, node);
        } else {
            throw new JsonPatternException(""unexpected JSON node type: "" + node.getNodeType());
        }       
 }"," private NodeWriter<Event> parseNode(JsonPointer location, JsonNode node) throws JsonPatternException{
        if (node.isObject()) {
            return parseObject(location, node);
        } else if (node.isArray()) {
            return parseArray(location, node);
        } else if (node.isTextual()) {
            return parseText(location, node);
        } else if (node.isNumber()) {
            return parseNumber(location, node);
        } else if (node.isBoolean()) {
            return parseBoolean(location, node);
        } else if (node.isNull()) {
            return parseNull(location, node);
        } else {
            throw new JsonPatternException(""unexpected JSON node type: "" + node.getNodeType());
        }       
 }"," private NodeWriter<Event> parseNode(JsonPointer location, JsonNode node) throws JsonPatternException{
        if (node.isObject()) {
            return parseObject(location, node);
        } else if (node.isArray()) {
            return parseArray(location, node);
        } else if (node.isTextual()) {
            return parseText(location, node);
        } else if (node.isBoolean()) {
            return parseBoolean(location, node);
        } else if (node.isNumber()) {
            return parseNumber(location, node);
        } else if (node.isNull()) {
            return parseNull(location, node);
        } else {
            throw new JsonPatternException(""Unsupported JSON node type: "" + node.getNodeType());
        }       
 }"," private NodeWriter<Event> parseNode(JsonPointer location, JsonNode node) throws JsonPatternException{
        if (node.isObject()) {
            return parseObject(location, node);
        } else if (node.isArray()) {
            return parseArray(location, node);
        } else if (node.isTextual()) {
            return parseText(location, node);
        } else if (node.isBoolean()) {
            return parseBoolean(location, node);
        } else if (node.isNumber()) {
            return parseNumber(location, node);
        } else if (node.isNull()) {
            return parseNull(location, node);
        } else {
            throw new JsonPatternException(""Unsupported JSON node type: "" + node.getNodeType());
        }       
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.449732813799391,  0.449732813799391,  0.449732813799391,  0.449732813799391,74.0,0.4966442953020134,74.0,0.4966442953020134,74.0,0.4966442953020134,74.0,0.4966442953020134,0.0,0.0,5.0,0.034013605442176874,5.0,0.034013605442176874,10.0,0.9090909090909091,3.0,0.2727272727272727,5.0,0.4166666666666667
941,matsim-libs," static SumoNetworkHandler read(File file) throws ParserConfigurationException, SAXException, IOException{
    SAXParserFactory factory = SAXParserFactory.newInstance();
    SAXParser saxParser = factory.newSAXParser();
    SumoNetworkHandler sumoHandler = new SumoNetworkHandler();
    saxParser.parse(file, sumoHandler);
    return sumoHandler;
}",read,org/matsim/contrib/sumo/SumoNetworkHandler.java,/contribs/sumo/src/main/java/org/matsim/contrib/sumo/SumoNetworkHandler.java,"/**
     * Creates a new sumo handler by reading data from xml file.
     */",78-87,"('read', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,12.0,Creates a new sumo handler by reading data from xml file.,Reads information from an xml file to create a new sumo handler. ,A new sumo handler is created by reading data.,0.533066407682523,Creates a sumo handler by reading the data in the xml file.,"  static SumoNetworkHandler read(File file) throws ParserConfigurationException, SAXException, IOException{
        SumoNetworkHandler handler = new SumoNetworkHandler();
        SAXParserFactory factory = SAXParserFactory.newInstance();
        factory.setNamespaceAware(true);
        SAXParser saxParser = factory.newSAXParser();
        saxParser.parse(file, handler);
        return handler;     
  }","  static SumoNetworkHandler read(File file) throws ParserConfigurationException, SAXException, IOException{
        SumoNetworkHandler handler = new SumoNetworkHandler();
        SAXParserFactory factory = SAXParserFactory.newInstance();
        factory.setNamespaceAware(true);
        SAXParser saxParser = factory.newSAXParser();
        saxParser.parse(file, handler);
        return handler;     
  }","  static SumoNetworkHandler read(File file) throws ParserConfigurationException, SAXException, IOException{
        SAXParserFactory factory = SAXParserFactory.newInstance();
        factory.setValidating(false);
        factory.setNamespaceAware(false);
        SAXParser parser = factory.newSAXParser();
        SumoNetworkHandler handler = new SumoNetworkHandler();
        parser.parse(file, handler);
        return handler;     
  }","  static SumoNetworkHandler read(File file) throws ParserConfigurationException, SAXException, IOException{
        SAXParserFactory factory = SAXParserFactory.newInstance();
        factory.setValidating(false);
        factory.setNamespaceAware(false);
        SAXParser parser = factory.newSAXParser();
        SumoNetworkHandler handler = new SumoNetworkHandler();
        parser.parse(file, handler);
        return handler;     
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.7639972182439353,  0.744766449013166,  0.8164100658853015,  0.8164100658853015,20.0,0.32786885245901637,20.0,0.32786885245901637,19.0,0.27941176470588236,19.0,0.27941176470588236,0.0,0.0,21.0,0.3088235294117647,21.0,0.3088235294117647,12.0,0.9230769230769231,4.0,0.3076923076923077,8.0,0.6666666666666666
942,weblogic-kubernetes-operator,"public static Collection<String> parseNamespaceList(String namespaceString){
    Collection<String> namespaces = Stream.of(namespaceString.split("","")).filter(s -> !isNullOrEmpty(s)).map(String::trim).collect(Collectors.toUnmodifiableList());
    return namespaces.isEmpty() ? Collections.singletonList(getOperatorNamespace()) : namespaces;
}",parseNamespaceList,oracle/kubernetes/operator/helpers/NamespaceHelper.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/NamespaceHelper.java,"/**
   * Parse a string of namespace names and return them as a collection.
   * @param namespaceString a comma-separated list of namespace names
   * @return Namespace list
   */",36-49,"('parseNamespaceList', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",76.0,13.0,Parse a string of namespace names and return them as a collection.,Identifies namespace names in the given string and it returns them,Return a string of names as a collection.,0.738350184684208,Parse a string of namespace names and return them as a collection.," public static Collection<String> parseNamespaceList(String namespaceString){
    if (isNullOrEmpty(namespaceString)) {
      return Collections.emptyList();
    }
    return Stream.of(namespaceString.split("","")).collect(Collectors.toList());
  }   "," public static Collection<String> parseNamespaceList(String namespaceString){
    if (isNullOrEmpty(namespaceString)) {
      return Collections.emptyList();
    }
    return Stream.of(namespaceString.split("",""))
      .map(String::trim)
      .filter(s -> !isNullOrEmpty(s))
      .collect(Collectors.toList());
  }   "," public static Collection<String> parseNamespaceList(String namespaceString){
    if (isNullOrEmpty(namespaceString)) {
      return Collections.emptyList();
    }
    return Stream.of(namespaceString.split("","")).collect(Collectors.toList());
  }   "," public static Collection<String> parseNamespaceList(String namespaceString){
    if (isNullOrEmpty(namespaceString)) {
      return Collections.emptyList();
    }
    return Stream.of(namespaceString.split("","")).collect(Collectors.toList());
  }   ",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.36596753322677167,  0.5492397149082756,  0.36596753322677167,  0.36596753322677167,45.0,0.5844155844155844,41.0,0.5324675324675324,45.0,0.5844155844155844,45.0,0.5844155844155844,18.0,0.2571428571428571,0.0,0.0,0.0,0.0,12.0,0.9230769230769231,0.0,0.0,5.0,0.38461538461538464
943,jeromq,"public Object[] recvBinaryPicture(Socket socket, final String picture){
    if (!BINARY_FORMAT.matcher(picture).matches()) {
        throw new ZMQException(picture + "" is not in expected binary format "" + BINARY_FORMAT.pattern(), ZError.EPROTO);
    }
    ZFrame frame = ZFrame.recvFrame(socket);
    if (frame == null) {
        return null;
    }
    ZNeedle needle = new ZNeedle(frame);
    Object[] results = new Object[picture.length()];
    for (int index = 0; index < picture.length(); index++) {
        char pattern = picture.charAt(index);
        switch(pattern) {
            case '1':
                {
                    results[index] = needle.getNumber1();
                    break;
                }
            case '2':
                {
                    results[index] = needle.getNumber2();
                    break;
                }
            case '4':
                {
                    results[index] = needle.getNumber4();
                    break;
                }
            case '8':
                {
                    results[index] = needle.getNumber8();
                    break;
                }
            case 's':
                {
                    results[index] = needle.getString();
                    break;
                }
            case 'S':
                {
                    results[index] = needle.getLongString();
                    break;
                }
            case 'b':
            case 'c':
                {
                    int size = needle.getNumber4();
                    results[index] = needle.getBlock(size);
                    break;
                }
            case 'f':
                {
                    results[index] = ZFrame.recvFrame(socket);
                    break;
                }
            case 'm':
                {
                    results[index] = ZMsg.recvMsg(socket);
                    break;
                }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    return results;
}",recvBinaryPicture,org/zeromq/proto/ZPicture.java,/src/main/java/org/zeromq/proto/ZPicture.java,"/**
     * Receive a binary encoded 'picture' message from the socket (or actor).
     * This method is similar to {@link org.zeromq.ZMQ.Socket#recv()}, except the arguments are encoded
     * in a binary format that is compatible with zproto, and is designed to
     * reduce memory allocations.
     *
     * @param picture The picture argument is a string that defines
     *                the type of each argument. See {@link #sendBinaryPicture(Socket, String, Object...)}
     *                for the supported argument types.
     * @return the picture elements as object array
     **/",171-245,"('recvBinaryPicture', {'INSTRUCTION': {'covered': 113, 'missed': 18}, 'BRANCH': {'covered': 14, 'missed': 4}, 'LINE': {'covered': 29, 'missed': 2}, 'COMPLEXITY': {'covered': 11, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",324.0,15.0,Receive a binary encoded 'picture' message from the socket (or actor).,"Obtain a ""image"" message in binary from the socket (or actor).  This approach resembles org.zeromq.ZMQ.Socket#recv(), but is intended to use less memory because the arguments are encoded in a binary format that is compatible with zproto. ",Receive a picture message from the actor.,0.129101639715445,Receive a binary encoded 'image' message from the socket (or actor).,"public Object[] recvBinaryPicture(Socket socket, final String picture){
        ZMsg msg = recvMsg(socket);
        if (msg == null) {
            return null;
        }
        if (msg.size() != 1) {
            throw new ZMQException(""Expected 1 frame, got "" + msg.size(), ZError.EPROTO);
        }
        ZFrame frame = msg.getFirst();
        if (frame.size() == 0) {
            return null;
        }
        ZNeedle needle = new ZNeedle(frame);
        Object[] args = new Object[picture.length()];
        for (int index = 0; index < picture.length(); index++) {
            char pattern = picture.charAt(index);
            switch (pattern) {
            case '1': {
                args[index] = needle.getNumber1();
                break;
            }
            case '2': {
                args[index] = needle.getNumber2();
                break;
            }
            case '4': {
                args[index] = needle.getNumber4();
                break;
            }
            case '8': {
                args[index] = needle.getNumber8();
                break;
            }
            case 's': {
                args[index] = needle.getString();
                break;
            }
            case 'S': {
                args[index] = needle.getLongString();
                break;
            }
            case 'b':
            case 'c': {
                int size = needle.getNumber4();
                args[index] = needle.getBlock(size);
                break;
            }
            case 'f': {
                args[index] = needle.getFrame();
                break;
            }
            case 'm': {
                args[index] = needle.getMsg();
                break;
            }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
            }
        }
        return args;        
 }","public Object[] recvBinaryPicture(Socket socket, final String picture){
        ZMsg msg = ZMsg.recvMsg(socket);
        if (msg == null) {
            return null;
        }
        ZFrame frame = msg.getFirst();
        if (frame == null) {
            return null;
        }
        ZNeedle needle = new ZNeedle(frame);
        Object[] args = new Object[picture.length()];
        for (int index = 0; index < picture.length(); index++) {
            char pattern = picture.charAt(index);
            switch (pattern) {
            case '1': {
                args[index] = needle.getNumber1();
                break;
            }
            case '2': {
                args[index] = needle.getNumber2();
                break;
            }
            case '4': {
                args[index] = needle.getNumber4();
                break;
            }
            case '8': {
                args[index] = needle.getNumber8();
                break;
            }
            case 's': {
                args[index] = needle.getString();
                break;
            }
            case 'S': {
                args[index] = needle.getLongString();
                break;
            }
            case 'b':
            case 'c': {
                int size = needle.getNumber4();
                args[index] = needle.getBlock(size);
                break;
            }
            case 'f': {
                args[index] = needle.getFrame();
                break;
            }
            case 'm': {
                args[index] = needle.getMsg();
                break;
            }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
            }
        }
        return args;
    }","public Object[] recvBinaryPicture(Socket socket, final String picture){
        ZMsg msg = ZMsg.recvMsg(socket);
        if (msg == null) {
            return null;
        }
        ZFrame frame = msg.getFirst();
        if (frame == null) {
            return null;
        }
        ZNeedle needle = new ZNeedle(frame);
        Object[] args = new Object[picture.length()];
        for (int index = 0; index < picture.length(); index++) {
            char pattern = picture.charAt(index);
            switch (pattern) {
            case '1': {
                args[index] = needle.getNumber1();
                break;
            }
            case '2': {
                args[index] = needle.getNumber2();
                break;
            }
            case '4': {
                args[index] = needle.getNumber4();
                break;
            }
            case '8': {
                args[index] = needle.getNumber8();
                break;
            }
            case 's': {
                args[index] = needle.getString();
                break;
            }
            case 'S': {
                args[index] = needle.getLongString();
                break;
            }
            case 'b':
            case 'c': {
                int size = needle.getNumber4();
                args[index] = needle.getBlock(size);
                break;
            }
            case 'f': {
                args[index] = needle.getFrame();
                break;
            }
            case 'm': {
                args[index] = msg;
                break;
            }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
            }
        }
        return args;
    }","public Object[] recvBinaryPicture(Socket socket, final String picture){
        ZMsg msg = recvMsg(socket);
        if (msg == null) {
            return null;
        }
        if (msg.size() != 1) {
            throw new ZMQException(""Expected 1 frame, got "" + msg.size(), ZError.EPROTO);
        }
        ZFrame frame = msg.getFirst();
        if (frame.size() == 0) {
            return null;
        }
        ZNeedle needle = new ZNeedle(frame);
        Object[] args = new Object[picture.length()];
        for (int index = 0; index < picture.length(); index++) {
            char pattern = picture.charAt(index);
            switch (pattern) {
            case '1': {
                args[index] = needle.getNumber1();
                break;
            }
            case '2': {
                args[index] = needle.getNumber2();
                break;
            }
            case '4': {
                args[index] = needle.getNumber4();
                break;
            }
            case '8': {
                args[index] = needle.getNumber8();
                break;
            }
            case 's': {
                args[index] = needle.getString();
                break;
            }
            case 'S': {
                args[index] = needle.getLongString();
                break;
            }
            case 'b':
            case 'c': {
                int size = needle.getNumber4();
                args[index] = needle.getBlock(size);
                break;
            }
            case 'f': {
                args[index] = needle.getFrame();
                break;
            }
            case 'm': {
                args[index] = needle.getMsg();
                break;
            }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
            }
        }
        return args;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6882847496534285,  0.6787845722840278,  0.6882847496534285,  0.6765674170331435,52.0,0.15339233038348082,48.0,0.1476923076923077,52.0,0.15339233038348082,51.0,0.15692307692307692,36.0,0.10619469026548672,0.0,0.0,41.0,0.12094395280235988,30.0,0.8108108108108109,1.0,0.08333333333333333,6.0,0.5
944,tablesaw," Column<T> last(final int numRows){
    int newRowCount = Math.min(numRows, size());
    return inRange(size() - newRowCount, size());
}",last,tech/tablesaw/columns/Column.java,/core/src/main/java/tech/tablesaw/columns/Column.java,/** Returns a column of the same type containing the last {@code numRows} of this column. */,660-664,"('last', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,19.0,Returns a column of the same type containing the last {@code numRows} of this column.,returns a column of the same type that contains this column's final numRows rows. ,The last @code numRows of this column is returned.,0.708129896546577,Returns a column of the same type containing the last {@code numRows} in that column.,"  Column<T> last(final int numRows){
    int newRowCount = Math.min(numRows, size());
    return inRange(size() - newRowCount, size());     
  }","  Column<T> last(final int numRows){
    int newRowCount = Math.min(numRows, size());
    return inRange(size() - newRowCount, size());     
  }","  Column<T> last(final int numRows){
    int newRowCount = Math.min(numRows, size());
    return inRange(size() - newRowCount, size());     
  }","  Column<T> last(final int numRows){
    int newRowCount = Math.min(numRows, size());
    return inRange(size() - newRowCount, size());     
  }",PASS,PASS,PASS,PASS,  1.0,  1.0,  1.0,  1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,9.0,0.5625,2.0,0.125,14.0,0.875
945,acs-aem-commons,"private void replaceInObject(JsonNode node, Map<String, Object> contentVariableReplacements){
    Iterator<String> fieldNames = node.fieldNames();
    while (fieldNames.hasNext()) {
        String name = fieldNames.next();
        JsonNode nodeValue = node.get(name);
        if (nodeValue.isContainerNode()) {
            replaceInElements(nodeValue, contentVariableReplacements);
        } else if (nodeValue.isTextual()) {
            String current = nodeValue.asText();
            String replaced = replaceInString(current, contentVariableReplacements);
            if (!StringUtils.equals(current, replaced)) {
                ((ObjectNode) node).put(name, replaced);
            }
        }
    }
}",replaceInObject,com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,/bundle/src/main/java/com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,"/**
     * Iterates over keys to replace any placeholders in the values.
     *
     * @param node Object node
     * @param contentVariableReplacements current map of content variables
     */",196-217,"('replaceInObject', {'INSTRUCTION': {'covered': 45, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",133.0,11.0,Iterates over keys to replace any placeholders in the values.,Replaces any placeholders in the values by iterating across the keys. ,Iterates over keys to replace the values.,2.08847534306106,Be on keys to replace placeholders in values.," private void replaceInObject(JsonNode node, Map<String, Object> contentVariableReplacements){
        if (node.isObject()) {
            Iterator<Map.Entry<String, JsonNode>> fields = node.fields();
            while (fields.hasNext()) {
                Map.Entry<String, JsonNode> field = fields.next();
                String current = field.getValue().asText();
                field.setValue(replaceInString(current, contentVariableReplacements));
            }
        }
    }"," private void replaceInObject(JsonNode node, Map<String, Object> contentVariableReplacements){
        if (node.get(""value"") != null && node.get(""value"").isTextual()) {
            String current = node.get(""value"").asText();
            node.set(""value"", replaceInString(current, contentVariableReplacements));
        } else if (node.get(""value"") != null && node.get(""value"").isContainerNode()) {
            replaceInElements(node.get(""value""), contentVariableReplacements);
        }
        if (node.get(""key"") != null && node.get(""key"").isTextual()) {
            String current = node.get(""key"").asText();
            node.set(""key"", replaceInString(current, contentVariableReplacements));
        } else if (node.get(""key"") != null && node.get(""key"").isContainerNode()) {
            replaceInElements(node.get(""key""), contentVariableReplacements);
        }
    }"," private void replaceInObject(JsonNode node, Map<String, Object> contentVariableReplacements){
        if (node.get(""key"") != null && node.get(""key"").isTextual()) {
            String current = node.get(""key"").asText();
            String replaced = replaceInString(current, contentVariableReplacements);
            node.put(""key"", replaced);
        } else if (node.get(""key"") != null && node.get(""key"").isContainerNode()) {
            replaceInElements(node.get(""key""), contentVariableReplacements);
        }
        if (node.get(""value"") != null && node.get(""value"").isTextual()) {
            String current = node.get(""value"").asText();
            String replaced = replaceInString(current, contentVariableReplacements);
            node.put(""value"", replaced);
        } else if (node.get(""value"") != null && node.get(""value"").isContainerNode()) {
            replaceInElements(node.get(""value""), contentVariableReplacements);
        }
    }"," private void replaceInObject(JsonNode node, Map<String, Object> contentVariableReplacements){
        if (node.isObject()) {
            Iterator<Map.Entry<String, JsonNode>> fields = node.fields();
            while (fields.hasNext()) {
                Map.Entry<String, JsonNode> field = fields.next();
                replaceInElements(field.getValue(), contentVariableReplacements);
            }
        }
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.43724872383038466,  0.4023439635872168,  0.35152809208362584,  0.4427765679529746,78.0,0.582089552238806,115.0,0.5867346938775511,83.0,0.6194029850746269,118.0,0.5728155339805825,130.0,0.6632653061224489,16.0,0.16326530612244897,142.0,0.6893203883495146,10.0,0.8333333333333334,4.0,0.36363636363636365,3.0,0.2727272727272727
946,cdk,"protected static List<IAtomContainer> splitMolecule(IAtomContainer atomContainer, IBond bond){
    List<IAtomContainer> ret = new ArrayList<IAtomContainer>();
    for (IAtom atom : bond.atoms()) {
        // later on we'll want to make sure that the fragment doesn't contain
        // the bond joining the current atom and the atom that is on the other side
        IAtom excludedAtom;
        if (atom.equals(bond.getBegin()))
            excludedAtom = bond.getEnd();
        else
            excludedAtom = bond.getBegin();
        List<IBond> part = new ArrayList<IBond>();
        part.add(bond);
        part = traverse(atomContainer, atom, part);
        // at this point we have a partion which contains the bond we
        // split. This partition should actually 2 partitions:
        // - one with the splitting bond
        // - one without the splitting bond
        // note that this will lead to repeated fragments when we  do this
        // with adjacent bonds, so when we gather all the fragments we need
        // to check for repeats
        IAtomContainer partContainer;
        partContainer = makeAtomContainer(atom, part, excludedAtom);
        // by checking for more than 2 atoms, we exclude single bond fragments
        // also if a fragment has the same number of atoms as the parent molecule,
        // it is the parent molecule, so we exclude it.
        if (partContainer.getAtomCount() > 2 && partContainer.getAtomCount() != atomContainer.getAtomCount())
            ret.add(partContainer);
        part.remove(0);
        partContainer = makeAtomContainer(atom, part, excludedAtom);
        if (partContainer.getAtomCount() > 2 && partContainer.getAtomCount() != atomContainer.getAtomCount())
            ret.add(partContainer);
    }
    return ret;
}",splitMolecule,org/openscience/cdk/fragment/FragmentUtils.java,/tool/fragment/src/main/java/org/openscience/cdk/fragment/FragmentUtils.java,"/**
     * Non destructively split a molecule into two parts at the specified bond.
     *
     * Note that if a ring bond is specified, the resultant list will contain
     * teh opened ring twice.
     *
     * @param atomContainer The molecule to split
     * @param bond The bond to split at
     * @return A list containing the two parts of the molecule
     */",44-93,"('splitMolecule', {'INSTRUCTION': {'covered': 83, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",201.0,13.0,Non destructively split a molecule into two parts at the specified bond.,"At the designated bond, nondestructively divide a molecule into two pieces.   It should be noted that the opened ring will appear twice in the resultant list if a ring bond is supplied. ",A molecule is split into two parts.,0.24225738585216,Non-destructively divide a molecule into two parts at the specified bond.,"protected static List<IAtomContainer> splitMolecule(IAtomContainer atomContainer, IBond bond){
        List<IAtomContainer> ret = new ArrayList<IAtomContainer>();
        IAtomContainer mol1 = atomContainer.getBuilder().newInstance(IAtomContainer.class, atomContainer);
        IAtomContainer mol2 = atomContainer.getBuilder().newInstance(IAtomContainer.class, atomContainer);
        for (IAtom atom : atomContainer.atoms()) {
            if (atom.getFlag(CDKConstants.REMOVE_ATOM)) {
                mol1.removeAtom(atom);
                mol2.removeAtom(atom);
            }
        }
        for (IBond bond : atomContainer.bonds()) {
            if (bond.getFlag(CDKConstants.REMOVE_BOND)) {
                mol1.removeBond(bond);
                mol2.removeBond(bond);
            }
        }
        ret.add(mol1);
        ret.add(mol2);
        return ret;     
 }","protected static List<IAtomContainer> splitMolecule(IAtomContainer atomContainer, IBond bond){
        List<IAtomContainer> result = new ArrayList<IAtomContainer>();
        IAtomContainer mol1 = atomContainer.getBuilder().newInstance(IAtomContainer.class, atomContainer);
        IAtomContainer mol2 = atomContainer.getBuilder().newInstance(IAtomContainer.class, atomContainer);
        IAtom atom1 = bond.getBegin();
        IAtom atom2 = bond.getEnd();
        mol1.removeAtom(atom1);
        mol1.removeAtom(atom2);
        mol2.removeAtom(atom1);
        mol2.removeAtom(atom2);
        mol1.addAtom(atom2);
        mol2.addAtom(atom1);
        mol1.addBond(bond);
        mol2.addBond(bond);
        result.add(mol1);
        result.add(mol2);
        return result;      
 }","protected static List<IAtomContainer> splitMolecule(IAtomContainer atomContainer, IBond bond){
        List<IAtomContainer> ret = new ArrayList<IAtomContainer>();
        IAtomContainer left = atomContainer.getBuilder().newInstance(IAtomContainer.class, atomContainer);
        IAtomContainer right = atomContainer.getBuilder().newInstance(IAtomContainer.class, atomContainer);
        IAtom atom1 = bond.getAtom(0);
        IAtom atom2 = bond.getAtom(1);
        left.removeAtom(atom1);
        left.removeAtom(atom2);
        right.removeAtom(atom1);
        right.removeAtom(atom2);
        ret.add(left);
        ret.add(right);
        return ret;     
 }",Not Valid,NOT PASS,NOT PASS,Not Valid,NOT PASS,  0.4111986092434802,  0.39715556796869245,None,  0.3846966963912423,124.0,0.6138613861386139,119.0,0.5891089108910891,None,None,123.0,0.6089108910891089,48.0,0.2926829268292683,None,None,60.0,0.36585365853658536,27.0,0.8181818181818182,3.0,0.23076923076923078,10.0,0.7692307692307693
947,cdk,"private static List<List<CDKRMap>> makeAtomsMapOfBondsMapSingleBond(List<CDKRMap> list, IAtomContainer sourceGraph, IAtomContainer targetGraph){
    if (list == null) {
        return null;
    }
    Map<IBond, IBond> bondMap = new HashMap<IBond, IBond>(list.size());
    for (CDKRMap solBondMap : list) {
        int id1 = solBondMap.getId1();
        int id2 = solBondMap.getId2();
        IBond qBond = sourceGraph.getBond(id1);
        IBond tBond = targetGraph.getBond(id2);
        bondMap.put(qBond, tBond);
    }
    List<CDKRMap> result1 = new ArrayList<CDKRMap>();
    List<CDKRMap> result2 = new ArrayList<CDKRMap>();
    for (IBond qbond : sourceGraph.bonds()) {
        if (bondMap.containsKey(qbond)) {
            IBond tbond = bondMap.get(qbond);
            CDKRMap map00 = null;
            CDKRMap map01 = null;
            CDKRMap map10 = null;
            CDKRMap map11 = null;
            if ((qbond.getBegin().getSymbol().equals(tbond.getBegin().getSymbol())) && (qbond.getEnd().getSymbol().equals(tbond.getEnd().getSymbol()))) {
                map00 = new CDKRMap(sourceGraph.indexOf(qbond.getBegin()), targetGraph.indexOf(tbond.getBegin()));
                map11 = new CDKRMap(sourceGraph.indexOf(qbond.getEnd()), targetGraph.indexOf(tbond.getEnd()));
                if (!result1.contains(map00)) {
                    result1.add(map00);
                }
                if (!result1.contains(map11)) {
                    result1.add(map11);
                }
            }
            if ((qbond.getBegin().getSymbol().equals(tbond.getEnd().getSymbol())) && (qbond.getEnd().getSymbol().equals(tbond.getBegin().getSymbol()))) {
                map01 = new CDKRMap(sourceGraph.indexOf(qbond.getBegin()), targetGraph.indexOf(tbond.getEnd()));
                map10 = new CDKRMap(sourceGraph.indexOf(qbond.getEnd()), targetGraph.indexOf(tbond.getBegin()));
                if (!result2.contains(map01)) {
                    result2.add(map01);
                }
                if (!result2.contains(map10)) {
                    result2.add(map10);
                }
            }
        }
    }
    List<List<CDKRMap>> result = new ArrayList<List<CDKRMap>>();
    if (result1.size() == result2.size()) {
        result.add(result1);
        result.add(result2);
    } else if (result1.size() > result2.size()) {
        result.add(result1);
    } else {
        result.add(result2);
    }
    return result;
}",makeAtomsMapOfBondsMapSingleBond,org/openscience/cdk/smsd/algorithm/rgraph/CDKRMapHandler.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKRMapHandler.java,"/**
     *  This makes atom map of matching atoms out of atom map of matching bonds as produced by the get(Subgraph|Ismorphism)Map methods.
     *  Added by Asad since CDK one doesn't pick up the correct changes
     * @param  list   The list produced by the getMap method.
     * @param  sourceGraph  first molecule. Must not be an IQueryAtomContainer.
     * @param  targetGraph  second molecule. May be an IQueryAtomContainer.
     * @return     The mapping found projected on sourceGraph. This is atom List of CDKRMap objects containing Ids of matching atoms.
     */",398-467,"('makeAtomsMapOfBondsMapSingleBond', {'INSTRUCTION': {'covered': 207, 'missed': 16}, 'BRANCH': {'covered': 16, 'missed': 12}, 'LINE': {'covered': 44, 'missed': 4}, 'COMPLEXITY': {'covered': 4, 'missed': 11}, 'METHOD': {'covered': 1, 'missed': 0}})",580.0,25.0,This makes atom map of matching atoms out of atom map of matching bonds as produced by the get(Subgraph|Ismorphism)Map methods.,"By using the get(Subgraph|Ismorphism)Map methods, this method creates an atom map of matching atoms from an atom map of matching bonds.  Asad added it because CDK One doesn't detect the proper changes. ",The get(Subgraph)IsmorphismMap methods make atom map of matching atoms out of atom map of matching bonds.,0.982019504526801,This makes the map of the atoms of corresponding atoms from the atom map of the corresponding bonds as produced by the get(Subgraph| Ismorphism)Cartographic methods.,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,22.0,0.6666666666666666,11.0,0.4230769230769231,11.0,0.5238095238095238
948,liquibase,"public boolean generateStatementsVolatile(SqlStatement statement, Database database){
    for (SqlGenerator generator : getGenerators(statement, database)) {
        if (generator.generateStatementsIsVolatile(database)) {
            return true;
        }
    }
    return false;
}",generateStatementsVolatile,liquibase/sqlgenerator/SqlGeneratorFactory.java,/liquibase-core/src/main/java/liquibase/sqlgenerator/SqlGeneratorFactory.java,"/**
     * Return true if the SqlStatement class queries the database in any way to determine Statements to execute.
     * If the statement queries the database, it cannot be used in updateSql type operations
     */",223-234,"('generateStatementsVolatile', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",43.0,18.0,Return true if the SqlStatement class queries the database in any way to determine Statements to execute.,"If the SqlStatement class makes any kind of database query to select which Statements to execute, this method returns true.  The statement cannot be used for updateSql type actions if it queries the database. ","If the SqlStatement class queries the database to determine statements to execute, return true.",0.910369825771863,Return true if the SqlStatement class queries the database in any way to determine which statements to execute.," public boolean generateStatementsVolatile(SqlStatement statement, Database database){
        return false;
    }"," public boolean generateStatementsVolatile(SqlStatement statement, Database database){
        return false;
    }"," public boolean generateStatementsVolatile(SqlStatement statement, Database database){
        return false;
    }"," public boolean generateStatementsVolatile(SqlStatement statement, Database database){
        SqlGeneratorChain generatorChain = createGeneratorChain(statement, database);
        if (generatorChain == null) {
            throw new IllegalStateException(""Cannot find generators for database "" + database.getClass() + "", statement: "" + statement);
        }
        return generatorChain.generateStatementsVolatile(statement, database);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.21193427140774895,  0.21193427140774895,  0.4749236214161553,  0.21193427140774895,28.0,0.6363636363636364,28.0,0.6363636363636364,34.0,0.5862068965517241,28.0,0.6363636363636364,0.0,0.0,43.0,0.7413793103448276,0.0,0.0,30.0,0.8571428571428571,2.0,0.10526315789473684,10.0,0.5555555555555556
950,cdk,"public boolean isOK(IAtomContainer m) throws CDKException{
    // OK, we take advantage here from the fact that this class does not take
    // into account rings larger than 7 atoms. See fixAromaticBondOrders().
    IRingSet rs = allRingsFinder.findAllRings(m, 7);
    storeRingSystem(m, rs);
    boolean StructureOK = this.isStructureOK(m);
    IRingSet irs = this.removeExtraRings(m);
    if (irs == null)
        throw new CDKException(""error in AllRingsFinder.findAllRings"");
    int count = this.getBadCount(m, irs);
    return StructureOK && count == 0;
}",isOK,org/openscience/cdk/smiles/DeduceBondSystemTool.java,/legacy/src/main/java/org/openscience/cdk/smiles/DeduceBondSystemTool.java,"/**
     * Determines if, according to the algorithms implemented in this class, the given
     * AtomContainer has properly distributed double bonds.
     *
     * @param  m {@link IAtomContainer} to check the bond orders for.
     * @return true, if bond orders are properly distributed
     * @throws CDKException thrown when something went wrong
     */",95-116,"('isOK', {'INSTRUCTION': {'covered': 32, 'missed': 6}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",82.0,21.0,"Determines if, according to the algorithms implemented in this class, the given  AtomContainer has properly distributed double bonds.",Checks to see if the given AtomContainer contains evenly distributed double bonds according to the algorithms used in this class. ,"The given AtomContainer has properly distributed double bonds, if the method is implemented in this class.",0.560601552920656,"Determines whether, based on the algorithms implemented in this class, the given AtomContainer correctly distributed the double bindings.","public boolean isOK(IAtomContainer m) throws CDKException{
        if (m.getBondCount() == 0) return true;
        if (m.getAtomCount() == 0) return true;
        if (m.getAtomCount() == 1) return true;
        if (m.getAtomCount() == 2) return true;
        if (m.getAtomCount() == 3) return true;
        if (m.getAtomCount() == 4) return true;
        if (m.getAtomCount() == 5) return true;
        if (m.getAtomCount() == 6) return true;
        if (m.getAtomCount() == 7) return true;
        if (m.getAtomCount() == 8) return true;
        if (m.getAtomCount() == 9) return true;
        if (m.getAtomCount() == 10) return true;
        if (m.getAtomCount() == 11) return true;
        if (m.getAtomCount() == 12) return true;
        if (m.getAtomCount() == 13) return true;
        if (m.getAtomCount() == 14) return true;
        if (m.getAtomCount() == 15) return true;
        if (m.getAtomCount() == 16) return true;
        if (m.getAtomCount() == 17) return true;
        if (m.getAtomCount() == 18) return true;
        if (m.getAtomCount() == 19) return true;
        if (m.getAtomCount() == 20) return true;
        if (m.getAtomCount() == 21) return true;
        if (m.getAtomCount() == 22) return true;
        if (m.getAtomCount() == 23) return true;
        if (m.getAtomCount() == 24) return true;
        if (m.getAtomCount() == 25) return true;
        if (m.getAtomCount() == 26) return true;
        if (m.getAtomCount() == 27) return true;
        if (m.get       
 }","public boolean isOK(IAtomContainer m) throws CDKException{
        if (m.getBondCount() == 0) return true;
        if (m.getAtomCount() == 0) return true;
        if (m.getAtomCount() == 1) return true;
        if (m.getAtomCount() == 2) return true;
        if (m.getAtomCount() == 3) return true;
        if (m.getAtomCount() == 4) return true;
        if (m.getAtomCount() == 5) return true;
        if (m.getAtomCount() == 6) return true;
        if (m.getAtomCount() == 7) return true;
        if (m.getAtomCount() == 8) return true;
        if (m.getAtomCount() == 9) return true;
        if (m.getAtomCount() == 10) return true;
        if (m.getAtomCount() == 11) return true;
        if (m.getAtomCount() == 12) return true;
        if (m.getAtomCount() == 13) return true;
        if (m.getAtomCount() == 14) return true;
        if (m.getAtomCount() == 15) return true;
        if (m.getAtomCount() == 16) return true;
        if (m.getAtomCount() == 17) return true;
        if (m.getAtomCount() == 18) return true;
        if (m.getAtomCount() == 19) return true;
        if (m.getAtomCount() == 20) return true;
        if (m.getAtomCount() == 21) return true;
        if (m.getAtomCount() == 22) return true;
        if (m.getAtomCount() == 23) return true;
        if (m.getAtomCount() == 24) return true;
        if (m.getAtomCount() == 25) return true;
        if (m.getAtomCount() == 26) return true;
        if (m.getAtomCount() == 27) return true;
        if (m.get       
 }"," public boolean isOK(IAtomContainer m) throws CDKException{
        return true;
    }","public boolean isOK(IAtomContainer m) throws CDKException{
        if (m.getBondCount() == 0) return true;
        if (m.getAtomCount() == 0) return true;
        if (m.getAtomCount() == 1) return true;
        if (m.getAtomCount() == 2) return true;
        if (m.getAtomCount() == 3) return true;
        if (m.getAtomCount() == 4) return true;
        if (m.getAtomCount() == 5) return true;
        if (m.getAtomCount() == 6) return true;
        if (m.getAtomCount() == 7) return true;
        if (m.getAtomCount() == 8) return true;
        if (m.getAtomCount() == 9) return true;
        if (m.getAtomCount() == 10) return true;
        if (m.getAtomCount() == 11) return true;
        if (m.getAtomCount() == 12) return true;
        if (m.getAtomCount() == 13) return true;
        if (m.getAtomCount() == 14) return true;
        if (m.getAtomCount() == 15) return true;
        if (m.getAtomCount() == 16) return true;
        if (m.getAtomCount() == 17) return true;
        if (m.getAtomCount() == 18) return true;
        if (m.getAtomCount() == 19) return true;
        if (m.getAtomCount() == 20) return true;
        if (m.getAtomCount() == 21) return true;
        if (m.getAtomCount() == 22) return true;
        if (m.getAtomCount() == 23) return true;
        if (m.getAtomCount() == 24) return true;
        if (m.getAtomCount() == 25) return true;
        if (m.getAtomCount() == 26) return true;
        if (m.getAtomCount() == 27) return true;
        if (m.get       
 }",Syntax Error,Syntax Error,Syntax Error,PASS,None,None,None,  0.0723464976019004,None,None,None,None,347.0,0.8807106598984772,69.0,0.8313253012048193,None,None,0.0,0.0,379.0,0.9619289340101523,19.0,0.9047619047619048,7.0,0.3684210526315789,17.0,0.8947368421052632
951,liquibase,"public PrimaryKey addColumn(int position, Column column){
    if (position >= getColumns().size()) {
        for (int i = getColumns().size() - 1; i < position; i++) {
            this.getColumns().add(null);
        }
    }
    this.getColumns().set(position, column);
    return this;
}",addColumn,liquibase/structure/core/PrimaryKey.java,/liquibase-core/src/main/java/liquibase/structure/core/PrimaryKey.java,"/**
     * Adds a new column to the column list of this PrimaryKey. The first column has the position 0.
     * If you specify a position that is greater than the number of columns present, undefined
     * columns (NULL expressions) will be added as padding. If a position that is already
     * occupied by a column is specified, that column will be replaced.
     *
     * @param position the position where to insert or replace the column
     * @param column   the new column
     * @return a reference to the updated PrimaryKey object.
     */",69-87,"('addColumn', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,12.0,Adds a new column to the column list of this PrimaryKey.,Adds a new column to this PrimaryKey's list of columns. Position 0 is present in the first column. Undefined columns (NULL expressions) will be inserted as padding if the position you give exceeds the number of columns already present. A column will be replaced if a position that it now occupies is specified.,A new column is added to the PrimaryKey.,0.572069577823675,Adds a new column to the list of columns for this primary key.," public PrimaryKey addColumn(int position, Column column){
        List<Column> columns = getColumns();
        columns.add(position, column);
        setAttribute(""columns"", columns);
        return this;        
 }","public PrimaryKey addColumn(int position, Column column){
        List<Column> columns = getColumns();
        if (position < 0) {
            position = 0;
        }
        if (position > columns.size()) {
            position = columns.size();
        }
        columns.add(position, column);
        return this;        
 }"," public PrimaryKey addColumn(int position, Column column){
        List<Column> columns = getColumns();
        columns.add(position, column);
        column.setRelation(getTable());
        return this;        
 }"," public PrimaryKey addColumn(int position, Column column){
        List<Column> columns = getColumns();
        columns.add(position, column);
        column.setRelation(getTable());
        return this;        
 }",NOT PASS,PASS,NOT PASS,NOT PASS,  0.3360315131174012,  0.47201764639622423,  0.34514403468287386,  0.34514403468287386,49.0,0.6282051282051282,43.0,0.5512820512820513,48.0,0.6153846153846154,48.0,0.6153846153846154,31.0,0.4626865671641791,6.0,0.13636363636363635,6.0,0.13636363636363635,46.0,0.8518518518518519,5.0,0.35714285714285715,8.0,0.6666666666666666
952,tablesaw,"public static String repeat(final String str, final int repeat){
    if (str == null) {
        return null;
    }
    if (repeat <= 0) {
        return EMPTY;
    }
    final int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
        return str;
    }
    if (inputLength == 1 && repeat <= PAD_LIMIT) {
        return repeat(str.charAt(0), repeat);
    }
    final int outputLength = inputLength * repeat;
    switch(inputLength) {
        case 1:
            return repeat(str.charAt(0), repeat);
        case 2:
            final char ch0 = str.charAt(0);
            final char ch1 = str.charAt(1);
            final char[] output2 = new char[outputLength];
            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                output2[i] = ch0;
                output2[i + 1] = ch1;
            }
            return new String(output2);
        default:
            final StringBuilder buf = new StringBuilder(outputLength);
            for (int i = 0; i < repeat; i++) {
                buf.append(str);
            }
            return buf.toString();
    }
}",repeat,tech/tablesaw/util/StringUtils.java,/core/src/main/java/tech/tablesaw/util/StringUtils.java,"/**
   * Repeat a String {@code repeat} times to form a new String.
   *
   * <pre>
   * StringUtils.repeat(null, 2) = null
   * StringUtils.repeat("""", 0)   = """"
   * StringUtils.repeat("""", 2)   = """"
   * StringUtils.repeat(""a"", 3)  = ""aaa""
   * StringUtils.repeat(""ab"", 2) = ""abab""
   * StringUtils.repeat(""a"", -2) = """"
   * </pre>
   *
   * @param str the String to repeat, may be null
   * @param repeat number of times to repeat str, negative treated as zero
   * @return a new String consisting of the original String repeated, {@code null} if null String
   *     input
   */",200-254,"('repeat', {'INSTRUCTION': {'covered': 22, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",242.0,15.0,Repeat a String {@code repeat} times to form a new String.,Creates a new String by repeating a given String repeat several times. ,A new String can be formed by repeating a string @code repeat times.,1.20258873442126,Repeat a string {@code repeat} times to form a new string.,"public static String repeat(final String str, final int repeat){
    if (str == null) {
      return null;
    }
    if (repeat <= 0) {
      return EMPTY;
    }
    final int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
      return str;
    }
    if (inputLength == 1 && repeat <= PAD_LIMIT) {
      return padding(repeat, str.charAt(0));
    }
  
    final int outputLength = inputLength * repeat;
    final int mod = outputLength % PAD_LIMIT;
    final int fullCopyLength = outputLength - mod;
    final char[] output = new char[fullCopyLength];
  
    for (int i = 0; i < fullCopyLength; i += inputLength) {
      str.getChars(0, inputLength, output, i);
    }
  
    if (mod != 0) {
      final String padStr = padding(mod, ' ');
      str.getChars(0, mod, output, fullCopyLength);
      return new String(output) + padStr;
    }
  
    return new String(output);    
 }",Empty Method,"public static String repeat(final String str, final int repeat){
    if (str == null) {
      return null;
    }
    if (repeat <= 0) {
      return EMPTY;
    }
    final int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
      return str;
    }
    if (inputLength == 1 && repeat <= PAD_LIMIT) {
      return padding(repeat, str.charAt(0));
    }
  
    final int outputLength = inputLength * repeat;
    final int mod = outputLength % PAD_LIMIT;
    final int fullCopyLength = outputLength - mod;
    final char[] output = new char[fullCopyLength];
  
    for (int i = 0; i < fullCopyLength; i += inputLength) {
      str.getChars(0, inputLength, output, i);
    }
  
    if (mod != 0) {
      final String padStr = padding(mod, ' ');
      str.getChars(0, mod, output, fullCopyLength);
      return new String(output) + padStr;
    }
  
    return new String(output);    
 }","public static String repeat(final String str, final int repeat){
    if (str == null) {
      return null;
    }
    final StringBuilder buf = new StringBuilder(str.length() * repeat);
    for (int i = 0; i < repeat; i++) {
      buf.append(str);
    }
    return buf.toString();
  }",NOT PASS,Empty Method,PASS,NOT PASS,  0.5319946173086517,None,  0.24057106239523274,  0.5319946173086517,112.0,0.4609053497942387,None,None,175.0,0.720164609053498,112.0,0.4609053497942387,None,None,143.0,0.7079207920792079,0.0,0.0,10.0,0.7692307692307693,2.0,0.16666666666666666,11.0,0.7857142857142857
953,matsim-libs,"public Path calcLeastCostPath(final Node fromNode, final Node toNode, final double startTime, final Person person2, final Vehicle vehicle2){
    checkNodeBelongToNetwork(fromNode);
    checkNodeBelongToNetwork(toNode);
    augmentIterationId();
    this.person = person2;
    this.vehicle = vehicle2;
    if (this.pruneDeadEnds) {
        this.deadEndEntryNode = getPreProcessData(toNode).getDeadEndEntryNode();
    }
    RouterPriorityQueue<Node> pendingNodes = (RouterPriorityQueue<Node>) createRouterPriorityQueue();
    initFromNode(fromNode, toNode, startTime, pendingNodes);
    Node foundToNode = searchLogic(fromNode, toNode, pendingNodes);
    if (foundToNode == null)
        return null;
    else {
        DijkstraNodeData outData = getData(foundToNode);
        double arrivalTime = outData.getTime();
        return constructPath(fromNode, foundToNode, startTime, arrivalTime);
    }
}",calcLeastCostPath,org/matsim/core/router/Dijkstra.java,/matsim/src/main/java/org/matsim/core/router/Dijkstra.java,"/**
         * Calculates the cheapest route from Node 'fromNode' to Node 'toNode' at
         * starting time 'startTime'.
         *
         * @param fromNode
         *            The Node at which the route should start.
         * @param toNode
         *            The Node at which the route should end.
         * @param startTime
         *            The time at which the route should start.
         * @see org.matsim.core.router.util.LeastCostPathCalculator#calcLeastCostPath(org.matsim.api.core.v01.network.Node, org.matsim.api.core.v01.network.Node, double, org.matsim.api.core.v01.population.Person, org.matsim.vehicles.Vehicle)
         */",198-244,"('calcLeastCostPath', {'INSTRUCTION': {'covered': 56, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",153.0,18.0,Calculates the cheapest route from Node 'fromNode' to Node 'toNode' at  starting time 'startTime'.,Finds the shortest path between Nodes 'fromNode' and 'toNode' at the specified start time. ,The cheapest route from the beginning to the end is 'fromNode' to 'toNode'.,0.520737728612463,Calculates the cheapest route from the 'fromNode' node to the 'toNode' node at the 'startTime' departure time.,Empty Method,Empty Method,"public Path calcLeastCostPath(final Node fromNode, final Node toNode, final double startTime, final Person person2, final Vehicle vehicle2){
	 this.person = person2;
	 this.vehicle = vehicle2;
	 return calcLeastCostPath(fromNode, toNode, startTime);
 }","public Path calcLeastCostPath(final Node fromNode, final Node toNode, final double startTime, final Person person2, final Vehicle vehicle2){
	 this.person = person2;
	 this.vehicle = vehicle2;
	 return calcLeastCostPath(fromNode, toNode, startTime);
 }",Empty Method,Empty Method,NOT PASS,NOT PASS,None,None,  0.2581474738578984,  0.2581474738578984,None,None,None,None,107.0,0.6948051948051948,107.0,0.6948051948051948,None,None,48.0,0.9795918367346939,48.0,0.9795918367346939,11.0,0.7333333333333333,8.0,0.4444444444444444,10.0,0.6666666666666666
954,cdk,"public StereoEncoder create(IAtomContainer container, int[][] graph){
    List<StereoEncoder> encoders = new ArrayList<StereoEncoder>(5);
    for (IBond bond : container.bonds()) {
        // if double bond and not E or Z query bond
        if (DOUBLE.equals(bond.getOrder()) && !E_OR_Z.equals(bond.getStereo())) {
            IAtom left = bond.getBegin();
            IAtom right = bond.getEnd();
            // skip -N=N- double bonds which exhibit inversion
            if (Integer.valueOf(7).equals(left.getAtomicNumber()) && Integer.valueOf(7).equals(right.getAtomicNumber()))
                continue;
            StereoEncoder encoder = newEncoder(container, left, right, right, left, graph);
            if (encoder != null) {
                encoders.add(encoder);
            }
        }
    }
    return encoders.isEmpty() ? StereoEncoder.EMPTY : new MultiStereoEncoder(encoders);
}",create,org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,"/**
     * Create a stereo encoder for all potential 2D and 3D double bond stereo
     * configurations.
     *
     * @param container an atom container
     * @param graph     adjacency list representation of the container
     * @return a new encoder for tetrahedral elements
     */",58-92,"('create', {'INSTRUCTION': {'covered': 63, 'missed': 7}, 'BRANCH': {'covered': 10, 'missed': 4}, 'LINE': {'covered': 11, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",175.0,15.0,Create a stereo encoder for all potential 2D and 3D double bond stereo  configurations.,"For each possible 2D and 3D double bond stereo configuration, create a stereo encoder.",A stereo Encoder is needed for all double bond stereo configurations.,0.50970645988885,Create a stereo encoder for all potential dual-link 2D and 3D stereo configurations.," public StereoEncoder create(IAtomContainer container, int[][] graph){
        return new GeometricDoubleBondEncoder(container, graph);        
 }"," public StereoEncoder create(IAtomContainer container, int[][] graph){
     	List<StereoEncoder> encoders = new ArrayList<StereoEncoder>();
     	for (int[] stereo : graph) {
     		encoders.add(new GeometricDoubleBondEncoder(container, stereo));
     	}
     	return new StereoEncoder.Composite(encoders);       
 }"," public StereoEncoder create(IAtomContainer container, int[][] graph){
     	return new GeometricDoubleBondEncoder(container, graph);        
 }"," public StereoEncoder create(IAtomContainer container, int[][] graph){
        return new GeometricDoubleBondEncoder(container, graph);        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.08146392369572371,  0.2084523481730514,  0.08146392369572371,  0.08146392369572371,152.0,0.8636363636363636,125.0,0.7102272727272727,152.0,0.8636363636363636,152.0,0.8636363636363636,40.0,0.625,0.0,0.0,0.0,0.0,12.0,0.8,3.0,0.2,9.0,0.6
955,dataverse,"public String asString(){
    if (protocol == null || authority == null || identifier == null) {
        return """";
    }
    return protocol + "":"" + authority + ""/"" + identifier;
}",asString,edu/harvard/iq/dataverse/GlobalId.java,/src/main/java/edu/harvard/iq/dataverse/GlobalId.java,"/**
     * Returns {@code this}' string representation. Differs from {@link #toString}
     * which can also contain debug data, if needed.
     * 
     * @return The string representation of this global id.
     */",110-121,"('asString', {'INSTRUCTION': {'covered': 17, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,10.0,Returns {@code this}' string representation.,"Returns a string representation of this. It differs from toString, which, if necessary, can also contain debug data. ",The string representation is returned.,0.387611331798701,Returns the representation as a string {@code this}'.," public String asString(){
        return protocol + "":"" + authority + "":"" + identifier;
    }"," public String asString(){
        return protocol + "":"" + authority + "":"" + identifier;
    }"," public String asString(){
        return getProtocol() + "":"" + getAuthority() + "":"" + getIdentifier();
    }"," public String asString(){
        return protocol + "":"" + authority + "":"" + identifier;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.27386553581872053,  0.27386553581872053,  0.27386553581872053,  0.15656029491571893,20.0,0.5263157894736842,20.0,0.5263157894736842,20.0,0.5263157894736842,25.0,0.6578947368421053,0.0,0.0,0.0,0.0,9.0,0.36,17.0,0.8947368421052632,6.0,0.6666666666666666,5.0,0.8333333333333334
956,cdk,"private List<List<Integer>> assignRingGroups(List<Integer[]> rBondsArray){
    List<List<Integer>> ringGroups;
    ringGroups = new ArrayList<List<Integer>>();
    for (int i = 0; i < rBondsArray.size() - 1; i++) {
        for (int j = 0; j < rBondsArray.get(i).length; j++) {
            for (int k = i + 1; k < rBondsArray.size(); k++) {
                for (int l = 0; l < rBondsArray.get(k).length; l++) {
                    if (Objects.equals(rBondsArray.get(i)[j], rBondsArray.get(k)[l])) {
                        if (i != k) {
                            ringGroups.add(new ArrayList<Integer>());
                            ringGroups.get(ringGroups.size() - 1).add(i);
                            ringGroups.get(ringGroups.size() - 1).add(k);
                        }
                    }
                }
            }
        }
    }
    while (combineGroups(ringGroups)) ;
    for (int i = 0; i < rBondsArray.size(); i++) {
        boolean found = false;
        for (int j = 0; j < ringGroups.size(); j++) {
            if (ringGroups.get(j).contains(i)) {
                found = true;
                break;
            }
        }
        if (!found) {
            ringGroups.add(new ArrayList<Integer>());
            ringGroups.get(ringGroups.size() - 1).add(i);
        }
    }
    return ringGroups;
}",assignRingGroups,org/openscience/cdk/smiles/FixBondOrdersTool.java,/legacy/src/main/java/org/openscience/cdk/smiles/FixBondOrdersTool.java,"/**
     * Assigns a set of rings to groups each sharing a bond.
     *
     * @param rBondsArray
     * @return A List of Lists each containing the ring indices of a set of fused rings
     */",285-330,"('assignRingGroups', {'INSTRUCTION': {'covered': 145, 'missed': 2}, 'BRANCH': {'covered': 20, 'missed': 2}, 'LINE': {'covered': 21, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",334.0,12.0,Assigns a set of rings to groups each sharing a bond.,Gives to each group a link a set of rings.,A set of rings is given to groups.,0.176721640836169,Assigns a set of rings to groups that each share a link.,"private List<List<Integer>> assignRingGroups(List<Integer[]> rBondsArray){
        List<List<Integer>> ringGroups = new ArrayList<List<Integer>>();
        for (int i = 0; i < rBondsArray.size(); i++) {
            List<Integer> ringGroup = new ArrayList<Integer>();
            ringGroup.add(i);
            for (int j = 0; j < rBondsArray.get(i).length; j++) {
                if (rBondsArray.get(i)[j] != null) {
                    for (int k = 0; k < ringGroups.size(); k++) {
                        if (ringGroups.get(k).contains(rBondsArray.get(i)[j])) {
                            ringGroups.get(k).add(i);
                            break;
                        }
                    }
                }
            }
            ringGroups.add(ringGroup);
        }
        return ringGroups;      
 }","private List<List<Integer>> assignRingGroups(List<Integer[]> rBondsArray){
        List<List<Integer>> ringGroups = new ArrayList<List<Integer>>();
        for (int i = 0; i < rBondsArray.size(); i++) {
            List<Integer> ringGroup = new ArrayList<Integer>();
            ringGroup.add(i);
            ringGroups.add(ringGroup);
        }
        return ringGroups;
    }","private List<List<Integer>> assignRingGroups(List<Integer[]> rBondsArray){
            List<List<Integer>> ringGroups = new ArrayList<List<Integer>>();
            List<Integer> ringGroup = new ArrayList<Integer>();
            for (int i = 0; i < rBondsArray.size(); i++) {
                if (ringGroup.size() == 0) {
                    ringGroup.add(i);
                } else {
                    boolean found = false;
                    for (int j = 0; j < ringGroup.size(); j++) {
                        if (rBondsArray.get(ringGroup.get(j)).length == rBondsArray.get(i).length) {
                            if (Arrays.equals(rBondsArray.get(ringGroup.get(j)), rBondsArray.get(i))) {
                                found = true;
                                break;
                            }
                        }
                    }
                    if (!found) {
                        ringGroup.add(i);
                    }
                }
            }
            ringGroups.add(ringGroup);
            return ringGroups;
        }","private List<List<Integer>> assignRingGroups(List<Integer[]> rBondsArray){
            List<List<Integer>> ringGroups = new ArrayList<List<Integer>>();
            List<Integer> ringGroup = new ArrayList<Integer>();
            for (int i = 0; i < rBondsArray.size(); i++) {
                if (ringGroup.size() == 0) {
                    ringGroup.add(i);
                } else {
                    boolean found = false;
                    for (int j = 0; j < ringGroup.size(); j++) {
                        if (rBondsArray.get(ringGroup.get(j)).length == rBondsArray.get(i).length) {
                            if (Arrays.equals(rBondsArray.get(ringGroup.get(j)), rBondsArray.get(i))) {
                                found = true;
                                break;
                            }
                        }
                    }
                    if (!found) {
                        ringGroup.add(i);
                    }
                }
            }
            ringGroups.add(ringGroup);
            return ringGroups;
        }",PASS,PASS,NOT PASS,NOT PASS,  0.47454757414620613,  0.25709601262236026,  0.4579470932471935,  0.4579470932471935,187.0,0.5582089552238806,249.0,0.7432835820895523,198.0,0.591044776119403,198.0,0.591044776119403,97.0,0.5132275132275133,93.0,0.4492753623188406,93.0,0.4492753623188406,11.0,0.9166666666666666,3.0,0.23076923076923078,8.0,0.6666666666666666
958,cdk," static HydrogenPosition usingDefaultPlacement(final IAtom atom){
    if (PREFIXED_H.contains(Elements.ofNumber(atom.getAtomicNumber())))
        return Left;
    return Right;
}",usingDefaultPlacement,org/openscience/cdk/renderer/generators/standard/HydrogenPosition.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/HydrogenPosition.java,"/**
     * Access the default position of the hydrogen label when the atom has no
     * bonds.
     *
     * @param atom hydrogens will be labelled
     * @return the position
     */",269-279,"('usingDefaultPlacement', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,15.0,Access the default position of the hydrogen label when the atom has no  bonds.,"When the atom has no bonds, this method accesses the hydrogen label's default position. ",The hydrogen label has a default position when the atom has no bonds.,0.472448249795105,Go to the default position of the hydrogen label when the atom has no bonds.,Empty Method,"  static HydrogenPosition usingDefaultPlacement(final IAtom atom){
    if (atom instanceof IPseudoAtom) {
      return Above;
    } else if (atom instanceof IQueryAtom) {
      return Above;
    } else if (atom instanceof IAtom) {
      return Above;
    } else {
      return Above;
    }           
  }",Empty Method,"  static HydrogenPosition usingDefaultPlacement(final IAtom atom){
    if (atom instanceof IPseudoAtom) {
      return Above;
    }
    return Right;           
  }",Empty Method,NOT PASS,NOT PASS,Empty Method,None,  0.5223674939635377,  0.5663894058090884,None,None,None,31.0,0.5961538461538461,16.0,0.45714285714285713,None,None,51.0,0.9807692307692307,24.0,0.96,None,None,12.0,0.8,2.0,0.125,8.0,0.5333333333333333
959,weblogic-kubernetes-operator,"static WlsServerConfig create(Map<String, Object> serverConfigMap){
    // parse the configured network access points or channels
    Map networkAccessPointsMap = (Map<String, Object>) serverConfigMap.get(""networkAccessPoints"");
    List<NetworkAccessPoint> networkAccessPoints = new ArrayList<>();
    if (networkAccessPointsMap != null) {
        List<Map<String, Object>> networkAccessPointItems = (List<Map<String, Object>>) networkAccessPointsMap.get(""items"");
        if (networkAccessPointItems != null && networkAccessPointItems.size() > 0) {
            for (Map<String, Object> networkAccessPointConfigMap : networkAccessPointItems) {
                NetworkAccessPoint networkAccessPoint = new NetworkAccessPoint(networkAccessPointConfigMap);
                networkAccessPoints.add(networkAccessPoint);
            }
        }
    }
    // parse the SSL configuration
    Map<String, Object> sslMap = (Map<String, Object>) serverConfigMap.get(""SSL"");
    Integer sslListenPort = (sslMap == null) ? null : (Integer) sslMap.get(""listenPort"");
    boolean sslPortEnabled = sslMap != null && sslMap.get(""listenPort"") != null;
    // parse the administration port
    return new WlsServerConfig((String) serverConfigMap.get(""name""), (String) serverConfigMap.get(""listenAddress""), getMachineNameFromJsonMap(serverConfigMap), (Integer) serverConfigMap.get(""listenPort""), sslListenPort, (Integer) serverConfigMap.get(""adminPort""), networkAccessPoints);
}",create,oracle/kubernetes/operator/wlsconfig/WlsServerConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsServerConfig.java,"/**
   * Creates a WLSServerConfig object using an ""servers"" or ""serverTemplates"" item parsed from JSON
   * result from WLS REST call.
   *
   * @param serverConfigMap A Map containing the parsed ""servers"" or ""serverTemplates"" element for a
   *     WLS server or WLS server template.
   * @return A new WlsServerConfig object using the provided configuration from the configuration
   *     map
   */",71-111,"('create', {'INSTRUCTION': {'covered': 89, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 2}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",242.0,23.0,"Creates a WLSServerConfig object using an ""servers"" or ""serverTemplates"" item parsed from JSON  result from WLS REST call.","Uses a ""servers"" or ""serverTemplates"" item parsed from the JSON response of the WLS REST call to create a WLSServerConfig object. ","The item that is created is a serverconfig object and is created using a ""servers"" or ""serverTemplates"" item.",1.64504311636287,"Creates a WLSServerConfig object using a ""servers"" or ""serverTemplates"" element that is scanned from the JSON result of the WLS REST call."," static WlsServerConfig create(Map<String, Object> serverConfigMap){
    String name = (String) serverConfigMap.get(""name"");
    String listenAddress = (String) serverConfigMap.get(""listenAddress"");
    String machineName = (String) serverConfigMap.get(""machineName"");
    Integer listenPort = (Integer) serverConfigMap.get(""listenPort"");
    Integer sslListenPort = (Integer) serverConfigMap.get(""sslListenPort"");
    Integer adminPort = (Integer) serverConfigMap.get(""adminPort"");
    List<NetworkAccessPoint> networkAccessPoints = new ArrayList<>();
    List<Map<String, Object>> networkAccessPointList = (List<Map<String, Object>>) serverConfigMap.get(""networkAccessPoints"");
    if (networkAccessPointList != null) {
      for (Map<String, Object> networkAccessPointMap : networkAccessPointList) {
        networkAccessPoints.add(NetworkAccessPoint.create(networkAccessPointMap));
      }
    }
    return new WlsServerConfig(name, listenAddress, machineName, listenPort, sslListenPort, adminPort, networkAccessPoints);
  }"," static WlsServerConfig create(Map<String, Object> serverConfigMap){
    String name = (String) serverConfigMap.get(""name"");
    String listenAddress = (String) serverConfigMap.get(""listenAddress"");
    String machineName = (String) serverConfigMap.get(""machineName"");
    Integer listenPort = (Integer) serverConfigMap.get(""listenPort"");
    Integer sslListenPort = (Integer) serverConfigMap.get(""sslListenPort"");
    Integer adminPort = (Integer) serverConfigMap.get(""adminPort"");
    List<NetworkAccessPoint> networkAccessPoints = new ArrayList<>();
    List<Map<String, Object>> networkAccessPointList = (List<Map<String, Object>>) serverConfigMap.get(""networkAccessPoints"");
    if (networkAccessPointList != null) {
      for (Map<String, Object> networkAccessPointMap : networkAccessPointList) {
        networkAccessPoints.add(NetworkAccessPoint.create(networkAccessPointMap));
      }
    }
    return new WlsServerConfig(name, listenAddress, machineName, listenPort, sslListenPort, adminPort, networkAccessPoints);
  }"," static WlsServerConfig create(Map<String, Object> serverConfigMap){
    WlsServerConfig serverConfig = new WlsServerConfig();
    serverConfig.setName((String) serverConfigMap.get(""name""));
    serverConfig.setListenAddress((String) serverConfigMap.get(""listenAddress""));
    serverConfig.setListenPort((Integer) serverConfigMap.get(""listenPort""));
    serverConfig.setMachineName((String) serverConfigMap.get(""machineName""));
    serverConfig.setClusterName((String) serverConfigMap.get(""clusterName""));
    serverConfig.setSslListenPort((Integer) serverConfigMap.get(""sslListenPort""));
    serverConfig.setAdminPort((Integer) serverConfigMap.get(""adminPort""));
    serverConfig.setNetworkAccessPoints(
        (List<NetworkAccessPoint>) serverConfigMap.get(""networkAccessPoints""));
    return serverConfig;
  }"," static WlsServerConfig create(Map<String, Object> serverConfigMap){
    WlsServerConfig serverConfig = new WlsServerConfig();
    serverConfig.setName((String) serverConfigMap.get(""name""));
    serverConfig.setListenAddress((String) serverConfigMap.get(""listenAddress""));
    serverConfig.setListenPort((Integer) serverConfigMap.get(""listenPort""));
    serverConfig.setMachineName((String) serverConfigMap.get(""machineName""));
    serverConfig.setAdminPort((Integer) serverConfigMap.get(""adminPort""));
    serverConfig.setSslListenPort((Integer) serverConfigMap.get(""sslListenPort""));
    serverConfig.setClusterName((String) serverConfigMap.get(""clusterName""));
    List<Map<String, Object>> networkAccessPoints = (List<Map<String, Object>>) serverConfigMap.get(""networkAccessPoints"");
    if (networkAccessPoints != null) {
      List<NetworkAccessPoint> networkAccessPointList = new ArrayList<>();
      for (Map<String, Object> networkAccessPointMap : networkAccessPoints) {
        networkAccessPointList.add(NetworkAccessPoint.create(networkAccessPointMap));
      }
      serverConfig.setNetworkAccessPoints(networkAccessPointList);
    }
    return serverConfig;
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.4686555896057725,  0.47268784767028865,  0.47224520099670014,  0.32210453889048846,162.0,0.6666666666666666,162.0,0.6666666666666666,174.0,0.7160493827160493,167.0,0.6872427983539094,0.0,0.0,90.0,0.4205607476635514,116.0,0.6170212765957447,15.0,0.6818181818181818,8.0,0.34782608695652173,18.0,0.9473684210526315
960,weblogic-kubernetes-operator,"public static SchemaGenerator createCrdSchemaGenerator(){
    SchemaGenerator generator = new SchemaGenerator();
    generator.defineAdditionalProperties(Quantity.class, ""string"");
    generator.setForbidAdditionalProperties(false);
    generator.setSupportObjectReferences(false);
    generator.setIncludeSchemaReference(false);
    generator.addPackageToSuppressDescriptions(""io.kubernetes.client.openapi.models"");
    generator.defineEnabledFeatures(Optional.ofNullable(TuningParameters.getInstance()).map(TuningParameters::getFeatureGates).map(TuningParameters.FeatureGates::getEnabledFeatures).orElse(Collections.emptyList()));
    return generator;
}",createCrdSchemaGenerator,oracle/kubernetes/weblogic/domain/model/CrdSchemaGenerator.java,/operator/src/main/java/oracle/kubernetes/weblogic/domain/model/CrdSchemaGenerator.java,"/**
   * Creates a schema generator, suitably customized for generating Kubernetes CRD schemas.
   */",15-31,"('createCrdSchemaGenerator', {'INSTRUCTION': {'covered': 33, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",99.0,13.0,"Creates a schema generator, suitably customized for generating Kubernetes CRD schemas.",Creates a schema generator that is specifically tailored to produce Kubernetes CRD schemas. ,A custom-made generator is created for generating Kubernetes CRD schemas.,0.950001974546631,"Creates a schema builder, customized appropriately to generate Kubernetes CRD schemas.",Empty Method," public static SchemaGenerator createCrdSchemaGenerator(){
    return new SchemaGenerator(Collections.singletonList(new CrdSchemaGenerator()));            
 }","public static SchemaGenerator createCrdSchemaGenerator(){
    SchemaGenerator schemaGenerator = new SchemaGenerator();
    schemaGenerator.setCrdVersion(""v1"");
    schemaGenerator.setCrdKind(""PerturbedPegasus"");
    schemaGenerator.setCrdPlural(""perturbedpegasuses"");
    schemaGenerator.setCrdGroup(""oracle.com"");
    schemaGenerator.setCrdNamespace(""weblogic.com"");
    schemaGenerator.setCrdName(""PerturbedPegasus"");
    schemaGenerator.setCrdDescription(""PerturbedPegasus is a custom resource for testing"");
    schemaGenerator.setCrdScope(""Namespaced"");
    schemaGenerator.setCrdValidation(true);
    schemaGenerator.setCrdNamespaced(true);
    schemaGenerator.setCrdStatus(true);
    schemaGenerator.setCrdSubresources(true);
    schemaGenerator.setCrdPreserveUnknownFields(true);
    schemaGenerator.setCrdAdditionalProperties(true);
    schemaGenerator.setCrdXKubernetesEmbeddedItems(true);
    schemaGenerator.setCrdXKubernetesPreserveUnknownFields(true);
    schemaGenerator.setCrdXKubernetesClusterScoped(true);
    schemaGenerator.setCrdXKubernetesSubresources(true);
    schemaGenerator.setCrdXKubernetesNonNamespaced(true);
    schemaGenerator.setCrdXKubernetesListOptions(true);
    schemaGenerator.setCrdXKubernetesWatch(true);
    schemaGenerator.setCrdXKubernetesPatchStrategy(true);
    schemaGenerator.setCrdXKubernetesPatchMergeKey(true);
    schemaGenerator.setCrdXKubernetesPatchStrategyType(true);
    schemaGenerator.setCrdXKubernetesPatchStrategyMergeKey(true);
    schemaGenerator.setCrdXKubernetesPatchStrategyRetainKeys(true);
    schemaGenerator.setCrdX         
 }",Empty Method,Empty Method,NOT PASS,Empty Method,Syntax Error,None,  0.08672238615286959,None,None,None,None,81.0,0.81,None,None,141.0,0.698019801980198,23.0,0.9583333333333334,None,None,201.0,0.995049504950495,7.0,0.5,5.0,0.4166666666666667,6.0,0.5
961,logstash-logback-encoder,"private static int findParamEndIndex(String paramsString, int startIndex){
    int nestLevel = 0;
    for (int c = startIndex; c < paramsString.length(); c++) {
        char character = paramsString.charAt(c);
        if (character == PARAM_START_CHAR) {
            nestLevel++;
        } else if (character == PARAM_END_CHAR) {
            nestLevel--;
            if (nestLevel < 0) {
                throw new IllegalArgumentException(String.format(""Unbalanced '}' at character position %d in %s"", c, paramsString));
            }
        } else if (character == PARAM_SEPARATOR_CHAR && nestLevel == 0) {
            return c;
        }
    }
    if (nestLevel != 0) {
        throw new IllegalArgumentException(String.format(""Unbalanced '{' in %s"", paramsString));
    }
    return paramsString.length();
}",findParamEndIndex,net/logstash/logback/appender/WaitStrategyFactory.java,/src/main/java/net/logstash/logback/appender/WaitStrategyFactory.java,"/**
     * Finds the end character index of the parameter within the paramsString that starts at startIndex.
     *
     * Takes into account nesting of parameters.
     *
     * @param paramsString
     * @param startIndex index within paramsString to start looking
     * @return index at which the parameter string ends (e.g. the next comma, or paramsString length if no comma found)
     *
     * @throws IllegalArgumentException if the parameter is not well formed
     */",192-222,"('findParamEndIndex', {'INSTRUCTION': {'covered': 66, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",140.0,16.0,Finds the end character index of the parameter within the paramsString that starts at startIndex.,"Identifies the parameter's final character index within the paramsString, which begins at startIndex. Considers the nesting of parameters. ",The end character index of the parameter is found by looking at the startIndex.,0.283611829702436,Looks for the end character index of the parameter in the ParamsString that starts at startIndex.," private static int findParamEndIndex(String paramsString, int startIndex){
        int endIndex = startIndex;
        while (endIndex < paramsString.length() && paramsString.charAt(endIndex) != PARAM_END_CHAR) {
            endIndex++;
        }
        if (endIndex == paramsString.length()) {
            throw new IllegalArgumentException(String.format(""Parameters of %s must end with '}'"", paramsString));
        }
        return endIndex;
    }","private static int findParamEndIndex(String paramsString, int startIndex){
        int nestingLevel = 0;
        for (int i = startIndex; i < paramsString.length(); i++) {
            char c = paramsString.charAt(i);
            if (c == PARAM_START_CHAR) {
                nestingLevel++;
            } else if (c == PARAM_END_CHAR) {
                nestingLevel--;
                if (nestingLevel == 0) {
                    return i;
                }
            }
        }
        throw new IllegalArgumentException(String.format(""Unmatched '%s' in paramsString %s"", PARAM_START_CHAR, paramsString));
    }"," private static int findParamEndIndex(String paramsString, int startIndex){
        int endIndex = startIndex;
        while (endIndex < paramsString.length() && paramsString.charAt(endIndex) != PARAM_END_CHAR) {
            endIndex++;
        }
        if (endIndex == paramsString.length()) {
            throw new IllegalArgumentException(String.format(""Parameters of %s must end with '}'"", paramsString));
        }
        return endIndex;
    }"," private static int findParamEndIndex(String paramsString, int startIndex){
        int endIndex = startIndex;
        while (endIndex < paramsString.length() && paramsString.charAt(endIndex) != PARAM_END_CHAR) {
            endIndex++;
        }
        if (endIndex == paramsString.length()) {
            throw new IllegalArgumentException(String.format(""Parameters of %s must end with '}'"", paramsString));
        }
        return endIndex;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.328026255268587,  0.5341224484331543,  0.328026255268587,  0.328026255268587,83.0,0.5886524822695035,59.0,0.41843971631205673,83.0,0.5886524822695035,83.0,0.5886524822695035,50.0,0.5050505050505051,0.0,0.0,0.0,0.0,14.0,0.7368421052631579,4.0,0.23529411764705882,8.0,0.5
962,cdk,"public static String[] generateOrderEle(){
    return new String[] { ""C"", ""H"", ""O"", ""N"", ""Si"", ""P"", ""S"", ""F"", ""Cl"", ""Br"", ""I"", ""Sn"", ""B"", ""Pb"", ""Tl"", ""Ba"", ""In"", ""Pd"", ""Pt"", ""Os"", ""Ag"", ""Zr"", ""Se"", ""Zn"", ""Cu"", ""Ni"", ""Co"", ""Fe"", ""Cr"", ""Ti"", ""Ca"", ""K"", ""Al"", ""Mg"", ""Na"", ""Ce"", ""Hg"", ""Au"", ""Ir"", ""Re"", ""W"", ""Ta"", ""Hf"", ""Lu"", ""Yb"", ""Tm"", ""Er"", ""Ho"", ""Dy"", ""Tb"", ""Gd"", ""Eu"", ""Sm"", ""Pm"", ""Nd"", ""Pr"", ""La"", ""Cs"", ""Xe"", ""Te"", ""Sb"", ""Cd"", ""Rh"", ""Ru"", ""Tc"", ""Mo"", ""Nb"", ""Y"", ""Sr"", ""Rb"", ""Kr"", ""As"", ""Ge"", ""Ga"", ""Mn"", ""V"", ""Sc"", ""Ar"", ""Ne"", ""He"", ""Be"", ""Li"", ""Bi"", ""Po"", ""At"", ""Rn"", ""Fr"", ""Ra"", ""Ac"", ""Th"", ""Pa"", ""U"", ""Np"", ""Pu"", ""Am"", ""Cm"", ""Bk"", ""Cf"", ""Es"", ""Fm"", ""Md"", ""No"", ""Lr"", ""Rf"", ""Db"", ""Sg"", ""Bh"", ""Hs"", ""Mt"", ""Ds"", ""Rg"", ""Cn"", ""R"" };
}",generateOrderEle,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,"/**
     * Returns the Elements ordered according to (approximate) probability of occurrence.
     *
     * <p>This begins with the ""elements of life"" C, H, O, N, (Si, P, S, F, Cl),
     * then continues with the ""common"" chemical synthesis ingredients, closing off
     * with the tail-end of the periodic table in atom-number order and finally
     * the generic R-group.
     *
     * @return  fixed-order array
     *
     */",1183-1214,"('generateOrderEle', {'INSTRUCTION': {'covered': 455, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",243.0,13.0,Returns the Elements ordered according to (approximate) probability of occurrence.,"Returns the Elements arranged in order of (approximate) likelihood of occurrence. The ""elements of life"" C, H, O, N, (Si, P, S, F, Cl), followed by the ""common"" chemical synthesis ingredients, the tail end of the periodic table in atom-number order, and lastly the generic R-group, make up the first section of this. ",The Elements are ordered according to the probability of occurrence.,0.164178117445616,Returns items ordered based on the (approximate) probability of occurrence.,"public static String[] generateOrderEle(){
        String[] orderEle = new String[118];
        orderEle[0] = ""H"";
        orderEle[1] = ""He"";
        orderEle[2] = ""Li"";
        orderEle[3] = ""Be"";
        orderEle[4] = ""B"";
        orderEle[5] = ""C"";
        orderEle[6] = ""N"";
        orderEle[7] = ""O"";
        orderEle[8] = ""F"";
        orderEle[9] = ""Ne"";
        orderEle[10] = ""Na"";
        orderEle[11] = ""Mg"";
        orderEle[12] = ""Al"";
        orderEle[13] = ""Si"";
        orderEle[14] = ""P"";
        orderEle[15] = ""S"";
        orderEle[16] = ""Cl"";
        orderEle[17] = ""Ar"";
        orderEle[18] = ""K"";
        orderEle[19] = ""Ca"";
        orderEle[20] = ""Sc"";
        orderEle[21] = ""Ti"";
        orderEle[22] = ""V"";
        orderEle[23] = ""Cr"";
        orderEle[24] = ""Mn"";
        orderEle[25] = ""Fe"";
        orderEle[26] = ""Co"";
        orderEle[27] = ""Ni"";
        orderEle[28] = ""Cu"";
        orderEle[29] = ""Zn"";
        orderEle[30] = ""Ga"";
        orderEle[31] = ""Ge"";
        orderEle[32] = ""As"";
        orderEle[33] = ""Se"";
        orderEle[34] = ""Br"";
        orderEle[35] = ""Kr"";
        orderEle[36] = ""Rb"";
        orderEle[37] = ""Sr"";
        orderEle[38] = ""Y"";
        orderEle[39] = ""Zr"";
        orderEle[40] = ""Nb"";
        orderEle[41] = ""Mo"";
        orderEle[42] = ""Tc"";
        orderEle[43     
 }","public static String[] generateOrderEle(){
        String[] orderEle = new String[118];
        orderEle[0] = ""C"";
        orderEle[1] = ""H"";
        orderEle[2] = ""O"";
        orderEle[3] = ""N"";
        orderEle[4] = ""Si"";
        orderEle[5] = ""P"";
        orderEle[6] = ""S"";
        orderEle[7] = ""F"";
        orderEle[8] = ""Cl"";
        orderEle[9] = ""B"";
        orderEle[10] = ""Al"";
        orderEle[11] = ""Ga"";
        orderEle[12] = ""In"";
        orderEle[13] = ""Tl"";
        orderEle[14] = ""Sn"";
        orderEle[15] = ""Cn"";
        orderEle[16] = ""Nh"";
        orderEle[17] = ""Fl"";
        orderEle[18] = ""Mc"";
        orderEle[19] = ""Lv"";
        orderEle[20] = ""Ts"";
        orderEle[21] = ""Og"";
        orderEle[22] = ""Ce"";
        orderEle[23] = ""Pr"";
        orderEle[24] = ""Nd"";
        orderEle[25] = ""Pm"";
        orderEle[26] = ""Sm"";
        orderEle[27] = ""Eu"";
        orderEle[28] = ""Gd"";
        orderEle[29] = ""Tb"";
        orderEle[30] = ""Dy"";
        orderEle[31] = ""Ho"";
        orderEle[32] = ""Er"";
        orderEle[33] = ""Tm"";
        orderEle[34] = ""Yb"";
        orderEle[35] = ""Lu"";
        orderEle[36] = ""Hf"";
        orderEle[37] = ""Ta"";
        orderEle[38] = ""W"";
        orderEle[39] = ""Re"";
        orderEle[40] = ""Os"";
        orderEle[41] = ""Ir"";
        orderEle[42] = ""Pt"";        
 }","public static String[] generateOrderEle(){
        String[] orderEle = new String[118];
        orderEle[0] = ""H"";
        orderEle[1] = ""He"";
        orderEle[2] = ""Li"";
        orderEle[3] = ""Be"";
        orderEle[4] = ""B"";
        orderEle[5] = ""C"";
        orderEle[6] = ""N"";
        orderEle[7] = ""O"";
        orderEle[8] = ""F"";
        orderEle[9] = ""Ne"";
        orderEle[10] = ""Na"";
        orderEle[11] = ""Mg"";
        orderEle[12] = ""Al"";
        orderEle[13] = ""Si"";
        orderEle[14] = ""P"";
        orderEle[15] = ""S"";
        orderEle[16] = ""Cl"";
        orderEle[17] = ""Ar"";
        orderEle[18] = ""K"";
        orderEle[19] = ""Ca"";
        orderEle[20] = ""Sc"";
        orderEle[21] = ""Ti"";
        orderEle[22] = ""V"";
        orderEle[23] = ""Cr"";
        orderEle[24] = ""Mn"";
        orderEle[25] = ""Fe"";
        orderEle[26] = ""Co"";
        orderEle[27] = ""Ni"";
        orderEle[28] = ""Cu"";
        orderEle[29] = ""Zn"";
        orderEle[30] = ""Ga"";
        orderEle[31] = ""Ge"";
        orderEle[32] = ""As"";
        orderEle[33] = ""Se"";
        orderEle[34] = ""Br"";
        orderEle[35] = ""Kr"";
        orderEle[36] = ""Rb"";
        orderEle[37] = ""Sr"";
        orderEle[38] = ""Y"";
        orderEle[39] = ""Zr"";
        orderEle[40] = ""Nb"";
        orderEle[41] = ""Mo"";
        orderEle[42] = ""Tc"";
        orderEle[43     
 }","public static String[] generateOrderEle(){
        String[] orderEle = new String[100];
        orderEle[0] = ""C"";
        orderEle[1] = ""N"";
        orderEle[2] = ""O"";
        orderEle[3] = ""S"";
        orderEle[4] = ""P"";
        orderEle[5] = ""F"";
        orderEle[6] = ""Cl"";
        orderEle[7] = ""Br"";
        orderEle[8] = ""I"";
        orderEle[9] = ""B"";
        orderEle[10] = ""Si"";
        orderEle[11] = ""Ge"";
        orderEle[12] = ""As"";
        orderEle[13] = ""Se"";
        orderEle[14] = ""Sn"";
        orderEle[15] = ""Sb"";
        orderEle[16] = ""Te"";
        orderEle[17] = ""Po"";
        orderEle[18] = ""At"";
        orderEle[19] = ""Rn"";
        orderEle[20] = ""Fr"";
        orderEle[21] = ""Ra"";
        orderEle[22] = ""Rf"";
        orderEle[23] = ""Db"";
        orderEle[24] = ""Sg"";
        orderEle[25] = ""Bh"";
        orderEle[26] = ""Hs"";
        orderEle[27] = ""Mt"";
        orderEle[28] = ""Ds"";
        orderEle[29] = ""Rg"";
        orderEle[30] = ""Cn"";
        orderEle[31] = ""Uut"";
        orderEle[32] = ""Fl"";
        orderEle[33] = ""Uup"";
        orderEle[34] = ""Lv"";
        orderEle[35] = ""Uus"";
        orderEle[36] = ""Uuo"";
        orderEle[37] = ""Uue"";
        orderEle[38] = ""Ubn"";
        orderEle[39] = ""Ube"";
        orderEle[40] = ""Ubc"";
        orderEle[41] = ""Ubb"";
        orderEle[42] =      
 }",Syntax Error,NOT PASS,Syntax Error,Syntax Error,None, 0.0422735963291778,None,None,None,None,296.0,0.9164086687306502,296.0,0.9221183800623053,305.0,0.9355828220858896,46.0,0.1411042944785276,48.0,0.147239263803681,0.0,0.0,47.0,0.8703703703703703,5.0,0.45454545454545453,4.0,0.36363636363636365
963,cdk,"public static Bayesian deserialise(String str) throws IOException{
    BufferedReader rdr = new BufferedReader(new StringReader(str));
    Bayesian model = deserialise(rdr);
    rdr.close();
    return model;
}",deserialise,org/openscience/cdk/fingerprint/model/Bayesian.java,/tool/model/src/main/java/org/openscience/cdk/fingerprint/model/Bayesian.java,"/**
     * Converts a given string into a Bayesian model instance, or throws an exception if it is not valid.
     * 
     * @param str string containing the serialised model
     * @return instantiated model that can be used for predictions
     */",530-541,"('deserialise', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",42.0,20.0,"Converts a given string into a Bayesian model instance, or throws an exception if it is not valid.","Creates a Bayesian model instance from a specified string, or raises an error if the string is invalid. ","If the string is not valid, it can be converted into a model instance.",0.661809302039093,Converts a given string to a Bayesian model instance or throws an exception if it is invalid.,Not Valid,Not Valid,"public static Bayesian deserialise(String str) throws IOException{
        if (str == null)
            throw new IllegalArgumentException(""Null string"");
        if (!str.startsWith(""Bayesian!(""))
            throw new IllegalArgumentException(""Invalid string"");
    
        String[] lines = str.split(""\n"");
        if (lines.length < 2)
            throw new IllegalArgumentException(""Invalid string"");
    
        String[] tokens = lines[0].split(""\\s*,\\s*"");
        if (tokens.length != 4)
            throw new IllegalArgumentException(""Invalid string"");
    
        String fpname = tokens[0];
        int folding = Integer.parseInt(tokens[1]);
        double lowThresh = Double.parseDouble(tokens[2]);
        double highThresh = Double.parseDouble(tokens[3]);
    
        if (!(folding == CircularFingerprinter.FOLDING_NONE || folding == CircularFingerprinter.FOLDING_CIRCULAR))
            throw new IllegalArgumentException(""Invalid folding"");
    
        if (!(lowThresh >= 0 && lowThresh <= 1))
            throw new IllegalArgumentException(""Invalid low threshold"");
    
        if (!(highThresh >= 0 && highThresh <= 1))
            throw new IllegalArgumentException(""Invalid high threshold"");
    
        if (lowThresh > highThresh)
            throw new IllegalArgumentException(""Low threshold greater than high threshold"");
    
        if (!(fpname.equals(""ECFP0"") || fpname.equals(""ECFP2"") || fpname.equals(""ECFP4"") || fpname.equals(""ECFP6"")
                || fpname.equals(""FCFP0"") || fpname.equals(""FCFP2"") || fpname.equals(""FCFP4"") || fpname.equals(""FCFP6"")))
            throw new IllegalArgumentException(""Invalid fingerprint name"");
    
        Bayesian model = new Bayesian(fpname, folding, lowThresh, highThresh);
    
        for (int n = 1; n < lines.      
 }","public static Bayesian deserialise(String str) throws IOException{
        if (str == null)
            throw new IllegalArgumentException(""Null string"");
        if (!str.startsWith(""Bayesian!(""))
            throw new IllegalArgumentException(""Invalid format"");
    
        String[] tokens = str.substring(10).split("","");
        if (tokens.length != 4)
            throw new IllegalArgumentException(""Invalid format"");
    
        String fpname = tokens[0];
        int folding = Integer.parseInt(tokens[1]);
        double lowThresh = Double.parseDouble(tokens[2]);
        double highThresh = Double.parseDouble(tokens[3]);
    
        CircularFingerprinter fp = null;
        if (fpname.equals(""ECFP0""))
            fp = new CircularFingerprinter(CircularFingerprinter.CLASS_ECFP0, folding, lowThresh, highThresh);
        else if (fpname.equals(""ECFP2""))
            fp = new CircularFingerprinter(CircularFingerprinter.CLASS_ECFP2, folding, lowThresh, highThresh);
        else if (fpname.equals(""ECFP4""))
            fp = new CircularFingerprinter(CircularFingerprinter.CLASS_ECFP4, folding, lowThresh, highThresh);
        else if (fpname.equals(""ECFP6""))
            fp = new CircularFingerprinter(CircularFingerprinter.CLASS_ECFP6, folding, lowThresh, highThresh);
        else if (fpname.equals(""FCFP0""))
            fp = new CircularFingerprinter(CircularFingerprinter.CLASS_FCFP0, folding, lowThresh, highThresh);
        else if (fpname.equals(""FCFP2""))
            fp = new CircularFingerprinter(CircularFingerprinter.CLASS_FCFP2, folding, lowThresh, highThresh);
        else if (fpname.equals(""FCFP4""))
            fp = new CircularFinger     
 }",Not Valid,Not Valid,Syntax Error,Syntax Error,None,None,None,None,None,None,None,None,266.0,0.8986486486486487,287.0,0.9025157232704403,None,None,295.0,0.9966216216216216,317.0,0.9968553459119497,14.0,0.7368421052631579,4.0,0.21052631578947367,17.0,0.8947368421052632
964,logstash-logback-encoder,"protected boolean recycleInstance(T instance){
    if (instance instanceof Lifecycle) {
        return ((Lifecycle) instance).recycle();
    } else {
        return true;
    }
}",recycleInstance,net/logstash/logback/util/ThreadLocalHolder.java,/src/main/java/net/logstash/logback/util/ThreadLocalHolder.java,"/**
     * Recycle the instance before returning it to the pool.
     * Sub-classes may override this method if they wish to implement their own custom logic.
     * 
     * @param instance the instance to recycle
     * @return {@code true} if the instance can be recycled and returned to the pool, {@code false} if not.
     */",247-260,"('recycleInstance', {'INSTRUCTION': {'covered': 7, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,10.0,Recycle the instance before returning it to the pool.,"Before putting the instance back in the pool, recycle it. If a subclass wants to add their own custom logic, they can override this function. ","Before returning the instance to the pool, recycle it.",1.33180019615599,Recycle the instance before returning it to the pool.," protected boolean recycleInstance(T instance){
        return true;        
 }"," protected boolean recycleInstance(T instance){
        return true;
    }"," protected boolean recycleInstance(T instance){
        return true;
    }"," protected boolean recycleInstance(T instance){
        return true;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.21495925763868282,  0.21495925763868282,  0.21495925763868282,  0.21495925763868282,23.0,0.6388888888888888,23.0,0.6388888888888888,23.0,0.6388888888888888,23.0,0.6388888888888888,0.0,0.0,0.0,0.0,0.0,0.0,22.0,0.8461538461538461,0.0,0.0,8.0,0.8
965,tablesaw,"private void renameDuplicateColumnHeaders(String[] headerNames){
    Map<String, Integer> nameCounter = new HashMap<>();
    for (int i = 0; i < headerNames.length; i++) {
        String name = headerNames[i];
        Integer count = nameCounter.get(name);
        if (count == null) {
            nameCounter.put(name, 1);
        } else {
            count++;
            nameCounter.put(name, count);
            headerNames[i] = name + ""-"" + count;
        }
    }
}",renameDuplicateColumnHeaders,tech/tablesaw/io/FileReader.java,/core/src/main/java/tech/tablesaw/io/FileReader.java,"/**
   * Renames any column header that appears more than once. Subsequent appearances have ""-[count]""
   * appended; For example, the first (or only) appearance of ""foo"" is named ""foo"", the second
   * appearance is named ""foo-2"" The header array is modified in place.
   *
   * @param headerNames The header names to be potentially adjusted.
   */",133-153,"('renameDuplicateColumnHeaders', {'INSTRUCTION': {'covered': 61, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,10.0,Renames any column header that appears more than once.,"Any column header that appears more than once is given a new name. The suffix ""-[count]"" is applied to subsequent appearances; for instance, ""foo"" is named ""foo"" for its first (or sole) appearance, and ""foo-2"" for its second. The header array is changed on the fly.",Rename any column that appears more than once.,0.65289809014547,Renames any column header that appears multiple times.,"private void renameDuplicateColumnHeaders(String[] headerNames){
    Map<String, Integer> nameCounts = new HashMap<>();
    for (String headerName : headerNames) {
      if (nameCounts.containsKey(headerName)) {
        nameCounts.put(headerName, nameCounts.get(headerName) + 1);
      } else {
        nameCounts.put(headerName, 1);
      }
    }
    for (int i = 0; i < headerNames.length; i++) {
      if (nameCounts.get(headerNames[i]) > 1) {
        headerNames[i] = headerNames[i] + nameCounts.get(headerNames[i]);
      }
    }
  }","private void renameDuplicateColumnHeaders(String[] headerNames){
    Map<String, Integer> nameCounts = new HashMap<>();
    for (int i = 0; i < headerNames.length; i++) {
      String name = headerNames[i];
      if (nameCounts.containsKey(name)) {
        int count = nameCounts.get(name);
        nameCounts.put(name, count + 1);
        headerNames[i] = name + ""-"" + count;
      } else {
        nameCounts.put(name, 1);
      }
    }
  }","private void renameDuplicateColumnHeaders(String[] headerNames){
    Map<String, Integer> nameCounts = new HashMap<>();
    for (String name : headerNames) {
      if (nameCounts.containsKey(name)) {
        nameCounts.put(name, nameCounts.get(name) + 1);
      } else {
        nameCounts.put(name, 1);
      }
    }
    for (int i = 0; i < headerNames.length; i++) {
      if (nameCounts.get(headerNames[i]) > 1) {
        headerNames[i] = headerNames[i] + nameCounts.get(headerNames[i]);
      }
    }
  }","private void renameDuplicateColumnHeaders(String[] headerNames){
    Map<String, Integer> nameCounts = new HashMap<>();
    for (String headerName : headerNames) {
      if (nameCounts.containsKey(headerName)) {
        nameCounts.put(headerName, nameCounts.get(headerName) + 1);
      } else {
        nameCounts.put(headerName, 1);
      }
    }
    for (int i = 0; i < headerNames.length; i++) {
      if (nameCounts.get(headerNames[i]) > 1) {
        headerNames[i] = headerNames[i] + nameCounts.get(headerNames[i]);
      }
    }
  }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5636148971301602,  0.7651192006038814,  0.5636148971301602,  0.594555175192444,78.0,0.6046511627906976,38.0,0.35185185185185186,78.0,0.6046511627906976,76.0,0.5891472868217055,75.0,0.5813953488372093,0.0,0.0,5.0,0.03875968992248062,41.0,0.8723404255319149,3.0,0.3,2.0,0.2
966,cdk,"public void partitionPartners(IAtom atom, IAtomContainer unplacedPartners, IAtomContainer placedPartners){
    List atoms = molecule.getConnectedAtomsList(atom);
    for (int i = 0; i < atoms.size(); i++) {
        IAtom curatom = (IAtom) atoms.get(i);
        if (curatom.getFlag(CDKConstants.ISPLACED)) {
            placedPartners.addAtom(curatom);
        } else {
            unplacedPartners.addAtom(curatom);
        }
    }
}",partitionPartners,org/openscience/cdk/layout/AtomPlacer.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/AtomPlacer.java,"/**
     *  Partition the bonding partners of a given atom into placed (coordinates
     *  assinged) and not placed.
     *
     *@param  atom              The atom whose bonding partners are to be
     *      partitioned
     *@param  unplacedPartners  A vector for the unplaced bonding partners to go in
     *@param  placedPartners    A vector for the placed bonding partners to go in
     */",542-561,"('partitionPartners', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,18.0,Partition the bonding partners of a given atom into placed (coordinates  assinged) and not placed.,Divide the bonding partners of a specific atom among those that are put (coordinates assigned) and those that are not. ,The bonding partners of a given atom should be placed and not placed.,0.775809300864485,Partition the bond partners of a given atom into placed (associated coordinates) and non-placed.," public void partitionPartners(IAtom atom, IAtomContainer unplacedPartners, IAtomContainer placedPartners){
        for (IAtom partner : atom.getBonds()) {
            if (partner.getFlag(CDKConstants.ISPLACED))
                placedPartners.addAtom(partner);
            else
                unplacedPartners.addAtom(partner);
        }       
 }"," public void partitionPartners(IAtom atom, IAtomContainer unplacedPartners, IAtomContainer placedPartners){
        List<IAtom> partners = molecule.getConnectedAtomsList(atom);
        for (IAtom partner : partners) {
            if (partner.getFlag(CDKConstants.ISPLACED))
                placedPartners.addAtom(partner);
            else
                unplacedPartners.addAtom(partner);
        }       
 }"," public void partitionPartners(IAtom atom, IAtomContainer unplacedPartners, IAtomContainer placedPartners){
        List<IBond> bonds = molecule.getConnectedBondsList(atom);
        for (IBond bond : bonds) {
            IAtom partner = bond.getOther(atom);
            if (partner.getFlag(CDKConstants.ISPLACED)) {
                placedPartners.addBond(bond);
            } else {
                unplacedPartners.addBond(bond);
            }
        }       
 }","public void partitionPartners(IAtom atom, IAtomContainer unplacedPartners, IAtomContainer placedPartners){
        List<IAtom> partners = molecule.getConnectedAtomsList(atom);
        for (IAtom partner : partners) {
            if (partner.getPoint2d() != null) {
                placedPartners.addAtom(partner);
            } else {
                unplacedPartners.addAtom(partner);
            }
        }
    }",NOT PASS,PASS,NOT PASS,NOT PASS,  0.3912798609256471,  0.4725223645589016,  0.47569605549472516,  0.5336998627219743,42.0,0.47191011235955055,39.0,0.43820224719101125,40.0,0.449438202247191,32.0,0.3595505617977528,15.0,0.234375,23.0,0.34328358208955223,32.0,0.41025641025641024,12.0,0.5714285714285714,5.0,0.3125,6.0,0.375
967,cdk,"public static IDifference construct(String name, Point3d first, Point3d second){
    if (first == null && second == null)
        return null;
    Point3dDifference totalDiff = new Point3dDifference(name);
    totalDiff.addChild(DoubleDifference.construct(""x"", first == null ? null : first.x, second == null ? null : second.x));
    totalDiff.addChild(DoubleDifference.construct(""y"", first == null ? null : first.y, second == null ? null : second.y));
    totalDiff.addChild(DoubleDifference.construct(""z"", first == null ? null : first.z, second == null ? null : second.z));
    if (totalDiff.childCount() == 0) {
        return null;
    }
    return totalDiff;
}",construct,org/openscience/cdk/tools/diff/tree/Point3dDifference.java,/misc/diff/src/main/java/org/openscience/cdk/tools/diff/tree/Point3dDifference.java,"/**
     * Constructs a new {@link IDifference} object.
     *
     * @param name   a name reflecting the nature of the created {@link IDifference}
     * @param first  the first object to compare
     * @param second the second object to compare
     * @return       an {@link IDifference} reflecting the differences between the first and second object
     */",39-61,"('construct', {'INSTRUCTION': {'covered': 72, 'missed': 0}, 'BRANCH': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",152.0,10.0,Constructs a new {@link IDifference} object.,"Creates a new IDifference object, given its name and the two objects to compare.",A new object is created.,0.305586218041028,Constructs a new {@link IDifference} object.,"public static IDifference construct(String name, Point3d first, Point3d second){
        Point3dDifference diff = new Point3dDifference(name);
        diff.add(first, second);
        return diff;
    }","public static IDifference construct(String name, Point3d first, Point3d second){
        Point3dDifference diff = new Point3dDifference(name);
        diff.addDifference(first, second);
        return diff;
    }","public static IDifference construct(String name, Point3d first, Point3d second){
        Point3dDifference diff = new Point3dDifference(name);
        diff.add(new Point3d(first));
        diff.add(new Point3d(second));
        return diff;        
 }","public static IDifference construct(String name, Point3d first, Point3d second){
        Point3dDifference diff = new Point3dDifference(name);
        diff.add(new Point3dDifference.Point3dDifferenceElement(first, second));
        return diff;        
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.14104730186614173,  0.14104730186614173,  0.14659497936288435,  0.15953800090257272,119.0,0.7777777777777778,119.0,0.7777777777777778,116.0,0.7581699346405228,112.0,0.7320261437908496,1.0,0.02631578947368421,6.0,0.13636363636363635,14.0,0.27450980392156865,12.0,0.8,0.0,0.0,5.0,0.7142857142857143
968,matsim-libs,"static AfterLinkCreated adjustFreespeed(final double factor){
    return (link, osmTags, direction) -> {
        if (osmTags.containsKey(OsmTags.MAXSPEED)) {
            if (link.getFreespeed() < 51 / 3.6)
                link.setFreespeed(link.getFreespeed() * factor);
        }
    };
}",adjustFreespeed,org/matsim/contrib/osm/networkReader/SupersonicOsmNetworkReader.java,/contribs/osm/src/main/java/org/matsim/contrib/osm/networkReader/SupersonicOsmNetworkReader.java,"/**
     * Creates a function to adjust the freespeed for urban links.
     * @see LinkProperties#DEFAULT_FREESPEED_FACTOR
     *
     * @apiNote Can be used as example, but no public access currently
     */",64-77,"('adjustFreespeed', {'INSTRUCTION': {'covered': 3, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,11.0,Creates a function to adjust the freespeed for urban links.,A function is created to change the freespeed for urban links. ,The function adjusts the freespeed for urban links.,0.181377000437248,Creates a function to adjust the free speed for urban connections.,"static AfterLinkCreated adjustFreespeed(final double factor){
        return (link, network) -> {
            if (link.getFreespeed() > 0) {
                link.setFreespeed(link.getFreespeed() * factor);
            }
        };
    }","static AfterLinkCreated adjustFreespeed(final double factor){
        return (link, network) -> {
            if (link.getFreespeed() > 0) {
                link.setFreespeed(link.getFreespeed() * factor);
            }
        };      
 }",Not Valid,Not Valid,NOT PASS,NOT PASS,Not Valid,Not Valid,  0.6293394455882126,  0.6293394455882126,None,None,20.0,0.32786885245901637,20.0,0.32786885245901637,None,None,None,None,0.0,0.0,None,None,None,None,5.0,0.4166666666666667,3.0,0.25,4.0,0.36363636363636365
969,cdk,"public String toString(){
    StringBuffer resultString = new StringBuffer();
    resultString.append(""LonePair("");
    resultString.append(this.hashCode());
    if (atom != null) {
        resultString.append("", "").append(atom.toString());
    }
    resultString.append(')');
    return resultString.toString();
}",toString,org/openscience/cdk/silent/LonePair.java,/base/silent/src/main/java/org/openscience/cdk/silent/LonePair.java,"/**
     * Returns a one line string representation of this LonePair.
     * This method is conform RFC #9.
     *
     * @return    The string representation of this LonePair
     */",133-149,"('toString', {'INSTRUCTION': {'covered': 23, 'missed': 8}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",71.0,10.0,Returns a one line string representation of this LonePair.,This LonePair is represented by a single line of text in the response. This technique complies with RFC #9.,A one line string representation of this Lone Pair is returned.,0.299933043231155,Returns a string representation of a row of this LonePair.," public String toString(){
        return ""LonePair"";      
 }"," public String toString(){
        return ""LonePair"";      
 }"," public String toString(){
        return ""Lone Pair"";
    }"," public String toString(){
        StringBuffer sb = new StringBuffer();
        sb.append(""LonePair: "");
        sb.append(atom.toString());
        return sb.toString();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.05475648310126392,  0.05475648310126392,  0.46004583852693104,  0.05497482055025,62.0,0.8611111111111112,62.0,0.8611111111111112,36.0,0.5,62.0,0.8611111111111112,0.0,0.0,31.0,0.7560975609756098,1.0,0.09090909090909091,17.0,0.85,5.0,0.45454545454545453,6.0,0.5
970,logstash-logback-encoder,"public NodeWriter<Event> parse(String pattern) throws JsonPatternException{
    if (StringUtils.isEmpty(pattern)) {
        return null;
    }
    final ObjectNode node;
    try (JsonParser jsonParser = jsonFactory.createParser(pattern)) {
        node = JsonReadingUtils.readFullyAsObjectNode(jsonFactory, pattern);
    } catch (IOException e) {
        throw new JsonPatternException(""pattern is not a valid JSON object"", e);
    }
    NodeWriter<Event> nodeWriter = new RootWriter<>(parseObject(JsonPointer.compile(""/""), node));
    if (omitEmptyFields) {
        nodeWriter = new OmitEmptyFieldWriter<>(nodeWriter);
    }
    return nodeWriter;
}",parse,net/logstash/logback/pattern/AbstractJsonPatternParser.java,/src/main/java/net/logstash/logback/pattern/AbstractJsonPatternParser.java,"/**
     * Parse a JSON pattern and produce the corresponding {@link NodeWriter}.
     * Returns <em>null</em> if the pattern is invalid, null or empty. An error status is
     * logged when the pattern is invalid and parsing failed.
     * 
     * @param pattern the JSON pattern to parse
     * @return a {@link NodeWriter} configured according to the pattern
     * @throws JsonPatternException denotes an invalid pattern
     */",279-305,"('parse', {'INSTRUCTION': {'covered': 40, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",116.0,14.0,Parse a JSON pattern and produce the corresponding {@link NodeWriter}.,"Create the appropriate NodeWriter by parsing a JSON pattern. If the pattern is incorrect, empty, or null, it returns null. When the pattern is invalid and parsing fails, an error status is recorded. ",Parse a pattern and then send it to the link.,0.485211359461548,Analyze a JSON template and produce the corresponding {nodewriter @link}.," public NodeWriter<Event> parse(String pattern) throws JsonPatternException{
        return parse(pattern, null);        
 }"," public NodeWriter<Event> parse(String pattern) throws JsonPatternException{
        if (StringUtils.isEmpty(pattern)) {
            return null;
        }
        try {
            return new JsonNodeWriter(JsonReadingUtils.readFully(jsonFactory, pattern));
        } catch (JsonParseException e) {
            throw new JsonPatternException(""Failed to parse JSON pattern '"" + pattern + ""'"", e);
        } catch (IOException e) {
            throw new JsonPatternException(""Unexpected IOException when reading JSON pattern '"" + pattern + ""'"", e);
        }       
 }",Empty Method," public NodeWriter<Event> parse(String pattern) throws JsonPatternException{
        return parse(pattern, null);        
 }",NOT PASS,NOT PASS,NOT PASS,Empty Method,  0.12871018037396792,  0.3998241129111071,  0.12871018037396792,None,96.0,0.8205128205128205,62.0,0.5299145299145299,96.0,0.8205128205128205,None,None,65.0,0.7558139534883721,0.0,0.0,None,None,29.0,0.8529411764705882,4.0,0.36363636363636365,7.0,0.6363636363636364
971,glowstone,"public void putList(@NonNls String key, TagType type, List<V> value, Function<? super V, ? extends Tag> tagCreator){
    List<Tag> result = new ArrayList<>(value.size());
    for (V item : value) {
        result.add(tagCreator.apply(item));
    }
    put(key, new ListTag<>(type, result));
}",putList,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,"/**
     * Adds or replaces a list subtag, converting the list entries to tags.
     *
     * @param <V> the list elements' Java type
     * @param key the key to write to
     * @param type the list elements' tag type
     * @param value the list contents, as objects to convert to tags
     * @param tagCreator a function that will convert each V to an element tag
     */",925-941,"('putList', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",86.0,14.0,"Adds or replaces a list subtag, converting the list entries to tags.",Converts the list entries into tags by adding or removing a list subtag. ,Adding or replacing a list subtag converts the list entries to tags.,0.253062237448111,"Adds or replaces a list subtag, converting list entries to tags."," public void putList(@NonNls String key, TagType type, List<V> value, Function<? super V, ? extends Tag> tagCreator){
        ListTag list = new ListTag(type);
        for (V v : value) {
            list.add(tagCreator.apply(v));
        }
        put(key, list);
    }"," public void putList(@NonNls String key, TagType type, List<V> value, Function<? super V, ? extends Tag> tagCreator){
        if (value.isEmpty()) {
            remove(key);
            return;
        }
        if (!is(key, ListTag.class)) {
            put(key, new ListTag(type));
        }
        ListTag tag = getTag(key, ListTag.class);
        tag.clear();
        for (V v : value) {
            tag.add(tagCreator.apply(v));
        }
    }"," public void putList(@NonNls String key, TagType type, List<V> value, Function<? super V, ? extends Tag> tagCreator){
        ListTag listTag = new ListTag(type);
        for (V v : value) {
            listTag.add(tagCreator.apply(v));
        }
        put(key, listTag);
    }"," public void putList(@NonNls String key, TagType type, List<V> value, Function<? super V, ? extends Tag> tagCreator){
        ListTag list = new ListTag(type);
        for (V v : value) {
            list.add(tagCreator.apply(v));
        }
        put(key, list);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6193395698369148,  0.635172808039982,  0.6193395698369148,  0.6193395698369148,25.0,0.28735632183908044,66.0,0.5789473684210527,25.0,0.28735632183908044,25.0,0.28735632183908044,61.0,0.5350877192982456,0.0,0.0,3.0,0.04285714285714286,13.0,0.9285714285714286,1.0,0.07692307692307693,4.0,0.3076923076923077
972,cdk,"private StereoBond findStereoBond(IAtom atom){
    for (IBond bond : stereoBonds) if (bond.contains(atom))
        return (StereoBond) bond;
    return null;
}",findStereoBond,org/openscience/cdk/smiles/smarts/parser/SmartsQueryVisitor.java,/legacy/src/main/java/org/openscience/cdk/smiles/smarts/parser/SmartsQueryVisitor.java,"/**
     * Locate a stereo bond adjacent to the {@code atom}.
     *
     * @param atom an atom
     * @return a stereo bond or null if non found
     */",339-349,"('findStereoBond', {'INSTRUCTION': {'covered': 21, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,13.0,Locate a stereo bond adjacent to the {@code atom}.,Find a stereo bond that is close to the atom. ,There is a stereo bond next to the @code atom.,0.840962581487483,Locate a stereo link adjacent to the atom {@code}.," private StereoBond findStereoBond(IAtom atom){
        for (IAtom neighbor : neighbors.get(atom)){
            for (StereoBond bond : stereoBonds){
                if (bond.contains(neighbor)) return bond;
            }
        }
        return null;
    }"," private StereoBond findStereoBond(IAtom atom){
        for (StereoBond bond : stereoBonds) {
            if (bond.isClose(atom)) return bond;
        }
        return null;
    }"," private StereoBond findStereoBond(IAtom atom){
        for (IAtom neighbor : neighbors.get(atom)) {
            for (StereoBond bond : stereoBonds) {
                if (bond.contains(neighbor)) return bond;
            }
        }
        return null;
    }"," private StereoBond findStereoBond(IAtom atom){
        for (IAtom neighbor : neighbors.get(atom)) {
            for (StereoBond bond : stereoBonds) {
                if (bond.contains(neighbor)) return bond;
            }
        }
        return null;
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.6183507566181808,  0.7095849195215128,  0.6183507566181808,  0.6183507566181808,21.0,0.4375,7.0,0.2,21.0,0.4375,21.0,0.4375,16.0,0.3333333333333333,0.0,0.0,0.0,0.0,6.0,0.5454545454545454,3.0,0.3,5.0,0.45454545454545453
973,acs-aem-commons,"protected boolean accepts(SlingHttpServletRequest request){
    if (!StringUtils.equalsIgnoreCase(POST_METHOD, request.getMethod())) {
        return false;
    } else if (!DAM_FOLDER_SHARE_OPERATION.equals(request.getParameter(OPERATION))) {
        return false;
    } else if (!StringUtils.startsWith(request.getResource().getPath(), DAM_PATH_PREFIX)) {
        return false;
    } else if (!request.getResource().isResourceType(JcrResourceConstants.NT_SLING_FOLDER) && !request.getResource().isResourceType(JcrResourceConstants.NT_SLING_ORDERED_FOLDER)) {
        return false;
    }
    return true;
}",accepts,com/adobe/acs/commons/dam/impl/AssetsFolderPropertiesSupport.java,/bundle/src/main/java/com/adobe/acs/commons/dam/impl/AssetsFolderPropertiesSupport.java,"/**
     * Gateway method the Filter uses to determine if the request is a candidate for processing by Assets Folder Properties Support.
     * These checks should be fast and fail broadest and fastest first.
     *
     * @param request the request
     * @return true if Assets Folder Properties Support should process this request.
     */",148-174,"('accepts', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",116.0,21.0,Gateway method the Filter uses to determine if the request is a candidate for processing by Assets Folder Properties Support.,This is a gateway method that the Filter employs a to decide whether or not the request qualifies for processing by the Assets Folder Properties Support. These tests ought to be quick and fail the broadest and quickest first.,The Filter uses a gateway method to determine if the request is a candidate for processing.,0.206820285415467,The gateway method used by the filter to determine whether the request is likely to be processed by supporting the properties of the Assets folder.," protected boolean accepts(SlingHttpServletRequest request){
        return POST_METHOD.equals(request.getMethod()) && request.getResource().getPath().startsWith(DAM_PATH_PREFIX);      
 }"," protected boolean accepts(SlingHttpServletRequest request){
        if (POST_METHOD.equals(request.getMethod())) {
            final String operation = request.getParameter(OPERATION);
            if (DAM_FOLDER_SHARE_OPERATION.equals(operation)) {
                return true;
            }
        }
        return false;
    }"," protected boolean accepts(SlingHttpServletRequest request){
        return POST_METHOD.equals(request.getMethod()) && request.getResource().getPath().startsWith(DAM_PATH_PREFIX);      
 }"," protected boolean accepts(SlingHttpServletRequest request){
        return POST_METHOD.equals(request.getMethod()) && request.getResource().getPath().startsWith(DAM_PATH_PREFIX);      
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.21288762697989783,  0.3610877007549739,  0.21288762697989783,  0.21288762697989783,85.0,0.7264957264957265,75.0,0.6410256410256411,85.0,0.7264957264957265,85.0,0.7264957264957265,24.0,0.4528301886792453,0.0,0.0,0.0,0.0,28.0,0.7,18.0,0.6923076923076923,12.0,0.5714285714285714
974,cdk,"public String generate(int[] atomIdxs){
    if (atomIdxs == null)
        throw new NullPointerException(""No atom indexes provided"");
    if (atomIdxs.length == 0)
        return null;
    if (atomIdxs.length == 1 && mode == MODE_EXACT)
        return aexpr[atomIdxs[0]];
    Arrays.fill(rbnds, 0);
    Arrays.fill(avisit, 0);
    for (int atmIdx : atomIdxs) avisit[atmIdx] = -1;
    numVisit = 1;
    for (int atomIdx : atomIdxs) {
        if (avisit[atomIdx] < 0)
            markRings(atomIdx, -1);
    }
    numVisit = 1;
    for (int atmIdx : atomIdxs) avisit[atmIdx] = -1;
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < atomIdxs.length; i++) {
        if (avisit[atomIdxs[i]] < 0) {
            if (i > 0)
                sb.append('.');
            encodeExpr(atomIdxs[i], -1, sb);
        }
    }
    return sb.toString();
}",generate,org/openscience/cdk/smarts/SmartsFragmentExtractor.java,/tool/smarts/src/main/java/org/openscience/cdk/smarts/SmartsFragmentExtractor.java,"/**
     * Generate a SMARTS for the substructure formed of the provided
     * atoms.
     *
     * @param atomIdxs atom indexes
     * @return SMARTS, null if an empty array is passed
     */",189-235,"('generate', {'INSTRUCTION': {'covered': 132, 'missed': 11}, 'BRANCH': {'covered': 19, 'missed': 3}, 'LINE': {'covered': 21, 'missed': 2}, 'COMPLEXITY': {'covered': 9, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",211.0,12.0,Generate a SMARTS for the substructure formed of the provided  atoms.,Create a SMARTS for the substructure built with the atoms you've provided. ,The provided atoms have a substructure.,0.19161171849055,Generate a SMARTS for the substructure formed by the supplied atoms.,"public String generate(int[] atomIdxs){
        // check arg
        if (atomIdxs.length == 0)
            throw new IllegalArgumentException(""No atoms specified!"");
    
        // clear visit flags
        for (int i = 0; i < avisit.length; i++)
            avisit[i] = 0;
    
        // traverse the graph
        numVisit = 0;
        for (int i = 0; i < atomIdxs.length; i++)
            traverse(atomIdxs[i]);
    
        // generate SMARTS
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < numVisit; i++)
            sb.append(aexpr[rnums[i]]);
        return sb.toString();
    }","public String generate(int[] atomIdxs){
        // check arg
        if (atomIdxs.length == 0)
            throw new IllegalArgumentException(""No atoms specified!"");
    
        // clear visit flags
        for (int i = 0; i < avisit.length; i++)
            avisit[i] = 0;
    
        // traverse the graph
        numVisit = 0;
        for (int i = 0; i < atomIdxs.length; i++)
            traverse(atomIdxs[i]);
    
        // generate SMARTS
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < numVisit; i++)
            sb.append(aexpr[rnums[i]]);
        return sb.toString();
    }"," public String generate(int[] atomIdxs){
        return generate(atomIdxs, null);        
 }","public String generate(int[] atomIdxs){
        // check arg
        if (atomIdxs.length == 0)
            throw new IllegalArgumentException(""No atoms specified!"");
    
        // clear visit flags
        for (int i = 0; i < avisit.length; i++)
            avisit[i] = 0;
    
        // traverse the graph
        numVisit = 0;
        for (int i = 0; i < atomIdxs.length; i++)
            traverse(atomIdxs[i]);
    
        // generate SMARTS
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < atomIdxs.length; i++) {
            if (i > 0)
                sb.append('.');
            sb.append(aexpr[atomIdxs[i]]);
        }
        return sb.toString();
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.3384315943961331,  0.3384315943961331,  0.3989625317960607,  0.0673738628264049,129.0,0.6084905660377359,129.0,0.6084905660377359,117.0,0.5518867924528302,194.0,0.9150943396226415,0.0,0.0,19.0,0.1386861313868613,104.0,0.8666666666666667,6.0,0.46153846153846156,2.0,0.16666666666666666,11.0,0.9166666666666666
976,cdk,"public void add(IRingSet ringSet){
    for (int f = 0; f < ringSet.getAtomContainerCount(); f++) {
        if (!contains(ringSet.getAtomContainer(f))) {
            addAtomContainer(ringSet.getAtomContainer(f));
        }
    }
}",add,org/openscience/cdk/silent/RingSet.java,/base/silent/src/main/java/org/openscience/cdk/silent/RingSet.java,"/**
     * Adds all rings of another RingSet if they are not already part of this ring set.
     *
     * If you want to add a single ring to the set use {@link #addAtomContainer(org.openscience.cdk.interfaces.IAtomContainer)}
     *
     * @param   ringSet  the ring set to be united with this one.
     */",120-134,"('add', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,17.0,Adds all rings of another RingSet if they are not already part of this ring set.,"If they are not already a part of this ring set, adds all rings from another RingSet.  Use #addAtomContainer(org.openscience.cdk.interfaces.IAtomContainer) to add a single ring to the set","If they are not part of the ring set, add all of them.",0.228937688416791,Adds all rings from another RingSet if they are not already part of that ring set.,"public void add(IRingSet ringSet){
        for (int i = 0; i < ringSet.getAtomContainerCount(); i++) {
            if (!contains(ringSet.getAtomContainer(i))) {
                addAtomContainer(ringSet.getAtomContainer(i));
            }
        }
    }","public void add(IRingSet ringSet){
        for (int i = 0; i < ringSet.getAtomContainerCount(); i++) {
            addAtomContainer(ringSet.getAtomContainer(i));
        }
    }","public void add(IRingSet ringSet){
        for (int i=0; i<ringSet.getAtomContainerCount(); i++){
            addAtomContainer(ringSet.getAtomContainer(i));
        }       
 }","public void add(IRingSet ringSet){
        for (int i=0; i<ringSet.getAtomContainerCount(); i++){
            if (!contains(ringSet.getAtomContainer(i))) addAtomContainer(ringSet.getAtomContainer(i));
        }       
 }",PASS,NOT PASS - TIMEOUT,NOT PASS,NOT PASS - TIMEOUT,  0.8768734973953738,  0.6241858888307392,  0.7912352346671561,  0.6241858888307392,5.0,0.09090909090909091,19.0,0.34545454545454546,7.0,0.12727272727272726,19.0,0.34545454545454546,15.0,0.2727272727272727,2.0,0.03636363636363636,15.0,0.2727272727272727,24.0,0.8571428571428571,2.0,0.11764705882352941,14.0,0.8235294117647058
978,dcache,"private void becomeMortal(long lifetime){
    _whenIShouldExpire = new Date(System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(lifetime));
}",becomeMortal,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,"/**
     * Initialise our expiry time to some point in the future.
     *
     * @param lifetime the time, in seconds.
     */",202-210,"('becomeMortal', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,11.0,Initialise our expiry time to some point in the future.,Set our expiration period as far in the future as possible. ,We should initialise our time to the future.,0.326143655612421,Initialize our expiration time at some point in the future.,"private void becomeMortal(long lifetime){
        _isEphemeral = false;
        _whenIShouldExpire = new Date(System.currentTimeMillis() + lifetime * 1000);
    }","private void becomeMortal(long lifetime){
        _isEphemeral = false;
        _whenIShouldExpire = new Date(System.currentTimeMillis() + lifetime * 1000);
    }","private void becomeMortal(long lifetime){
        _isEphemeral = false;
        _whenIShouldExpire = new Date(System.currentTimeMillis() + lifetime * 1000);
    }","private void becomeMortal(long lifetime){
        _isEphemeral = false;
        _whenIShouldExpire = new Date(System.currentTimeMillis() + lifetime * 1000);
    }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.5940247908690902,  0.5940247908690902,  0.5940247908690902,  0.5940247908690902,12.0,0.3870967741935484,12.0,0.3870967741935484,12.0,0.3870967741935484,12.0,0.3870967741935484,0.0,0.0,0.0,0.0,0.0,0.0,9.0,0.75,3.0,0.2727272727272727,7.0,0.6363636363636364
979,tablesaw,"public Iterator<Row> iterator(){
    return new Iterator<Row>() {

        private final Row row = new Row(TableSlice.this);

        @Override
        public Row next() {
            return row.next();
        }

        @Override
        public boolean hasNext() {
            return row.hasNext();
        }
    };
}",iterator,tech/tablesaw/table/TableSlice.java,/core/src/main/java/tech/tablesaw/table/TableSlice.java,"/**
   * Iterate over the underlying rows in the source table. If you set one of the rows while
   * iterating it will change the row in the source table.
   */",224-245,"('iterator', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,10.0,Iterate over the underlying rows in the source table.,Go through the source table's underlying rows iteratively. The row in the source table will change if one of the rows is set during iterating. ,Over the underlying rows in the source table.,0.129867450211606,Iterate over the underlying rows in the source table.,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,Not Valid,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,19.0,0.7307692307692307,0.0,0.0,2.0,0.2
980,tablesaw,"public static String capitalize(final String str){
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    final int firstCodepoint = str.codePointAt(0);
    final int newCodePoint = Character.toTitleCase(firstCodepoint);
    if (firstCodepoint == newCodePoint) {
        return str;
    }
    final int[] newCodePoints = new int[strLen];
    int outOffset = 0;
    newCodePoints[outOffset++] = newCodePoint;
    for (int inOffset = Character.charCount(firstCodepoint); inOffset < strLen; ) {
        final int codepoint = str.codePointAt(inOffset);
        newCodePoints[outOffset++] = codepoint;
        inOffset += Character.charCount(codepoint);
    }
    return new String(newCodePoints, 0, outOffset);
}",capitalize,tech/tablesaw/util/StringUtils.java,/core/src/main/java/tech/tablesaw/util/StringUtils.java,"/**
   * Capitalizes a String changing the first character to title case as per {@link
   * Character#toTitleCase(int)}. No other characters are changed.
   *
   * <p>A {@code null} input String returns {@code null}.
   *
   * <pre>
   * StringUtils.capitalize(null)  = null
   * StringUtils.capitalize("""")    = """"
   * StringUtils.capitalize(""cat"") = ""Cat""
   * StringUtils.capitalize(""cAt"") = ""CAt""
   * StringUtils.capitalize(""'cat'"") = ""'cat'""
   * </pre>
   *
   * @param str the String to capitalize, may be null
   * @return the capitalized String, {@code null} if null String input
   * @since 2.0
   */",301-341,"('capitalize', {'INSTRUCTION': {'covered': 55, 'missed': 4}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 13, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",153.0,23.0,Capitalizes a String changing the first character to title case as per {@link  Character#toTitleCase(int)}.,Capitalizes a String changing the first character to title case as per Character#toTitleCase(int). No other characters are changed.  A null input String returns null.,The capitalizes a string changing the first character to the title case.,0.272532820587144,Caps a string by replacing the first character with the title case according to {@link Character#toTitleCase(int)}.," public static String capitalize(final String str){
    return changeFirstCharacterCase(str, true);   
 }"," public static String capitalize(final String str){
    return changeFirstCharacterCase(str, true);   
 }"," public static String capitalize(final String str){
    return changeFirstCharacterCase(str, true);   
 }"," public static String capitalize(final String str){
    return changeFirstCharacterCase(str, true);   
 }",NOT PASS,NOT PASS,NOT PASS,NOT PASS,  0.06784999458178648,  0.06784999458178648,  0.06784999458178648,  0.06784999458178648,136.0,0.8831168831168831,136.0,0.8831168831168831,136.0,0.8831168831168831,136.0,0.8831168831168831,0.0,0.0,0.0,0.0,0.0,0.0,12.0,0.48,8.0,0.47058823529411764,9.0,0.6
981,cdk,"private Rectangle2D transformedBounds(Shape shape){
    Rectangle2D rectangle2D = shape.getBounds2D();
    Point2D minPoint = new Point2D.Double(rectangle2D.getMinX(), rectangle2D.getMinY());
    Point2D maxPoint = new Point2D.Double(rectangle2D.getMaxX(), rectangle2D.getMaxY());
    transform.transform(minPoint, minPoint);
    transform.transform(maxPoint, maxPoint);
    double minX = Math.min(minPoint.getX(), maxPoint.getX());
    double maxX = Math.max(minPoint.getX(), maxPoint.getX());
    double minY = Math.min(minPoint.getY(), maxPoint.getY());
    double maxY = Math.max(minPoint.getY(), maxPoint.getY());
    return new Rectangle2D.Double(minX, minY, maxX - minX, maxY - minY);
}",transformedBounds,org/openscience/cdk/renderer/generators/standard/TextOutline.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/TextOutline.java,"/**
     * Access the bounds of a shape that have been transformed.
     *
     * @param shape any shape
     * @return the bounds of the shape transformed
     */",135-156,"('transformedBounds', {'INSTRUCTION': {'covered': 67, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",177.0,11.0,Access the bounds of a shape that have been transformed.,Access the boundaries of a modified shape. ,The bounds of a shape have been changed.,0.207072108029742,Navigate to the boundaries of a shape that have been transformed.,"private Rectangle2D transformedBounds(Shape shape){
        Rectangle2D bounds = shape.getBounds2D();
        Point2D p1 = new Point2D.Double(bounds.getMinX(), bounds.getMinY());
        Point2D p2 = new Point2D.Double(bounds.getMaxX(), bounds.getMaxY());
        transform.transform(p1, p1);
        transform.transform(p2, p2);
        return new Rectangle2D.Double(p1.getX(), p1.getY(), p2.getX() - p1.getX(), p2.getY() - p1.getY());
    }","private Rectangle2D transformedBounds(Shape shape){
        Rectangle2D bounds = shape.getBounds2D();
        Point2D p1 = new Point2D.Double(bounds.getMinX(), bounds.getMinY());
        Point2D p2 = new Point2D.Double(bounds.getMaxX(), bounds.getMaxY());
        transform.transform(p1, p1);
        transform.transform(p2, p2);
        return new Rectangle2D.Double(p1.getX(), p1.getY(), p2.getX() - p1.getX(), p2.getY() - p1.getY());
    }","private Rectangle2D transformedBounds(Shape shape){
        Rectangle2D bounds = shape.getBounds2D();
        Point2D p1 = new Point2D.Double(bounds.getX(), bounds.getY());
        Point2D p2 = new Point2D.Double(bounds.getX() + bounds.getWidth(), bounds.getY() + bounds.getHeight());
        transform.transform(p1, p1);
        transform.transform(p2, p2);
        return new Rectangle2D.Double(p1.getX(), p1.getY(), p2.getX() - p1.getX(), p2.getY() - p1.getY());
    }","private Rectangle2D transformedBounds(Shape shape){
        Rectangle2D bounds = shape.getBounds2D();
        Point2D p1 = new Point2D.Double(bounds.getMinX(), bounds.getMinY());
        Point2D p2 = new Point2D.Double(bounds.getMaxX(), bounds.getMaxY());
        transform.transform(p1, p1);
        transform.transform(p2, p2);
        return new Rectangle2D.Double(p1.getX(), p1.getY(), p2.getX() - p1.getX(), p2.getY() - p1.getY());
    }",NOT PASS,PASS,NOT PASS,PASS,  0.5336020340113259,  0.5252687006779926,  0.5294353673446592,  0.49194221653466863,81.0,0.4550561797752809,81.0,0.4550561797752809,81.0,0.4550561797752809,92.0,0.5168539325842697,0.0,0.0,0.0,0.0,16.0,0.11940298507462686,6.0,0.5454545454545454,3.0,0.25,4.0,0.36363636363636365
982,jackson-databind,"protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException{
    final SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);
    final DefaultSerializerProvider context = _serializerProvider(config);
    TokenBuffer buf = context.bufferForValueConversion(this);
    if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
        buf = buf.forceUseOfBigDecimal(true);
    }
    try {
        context.serializeValue(buf, fromValue);
        final JsonParser p = buf.asParser();
        Object result;
        final DeserializationConfig deserConfig = getDeserializationConfig();
        JsonToken t = _initForReading(p, toValueType);
        if (t == JsonToken.VALUE_NULL) {
            DeserializationContext ctxt = createDeserializationContext(p, deserConfig);
            result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);
        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
            result = null;
        } else {
            DeserializationContext ctxt = createDeserializationContext(p, deserConfig);
            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);
            result = deser.deserialize(p, ctxt);
        }
        p.close();
        return result;
    } catch (IOException e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    }
}",_convert,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"/**
     * Actual conversion implementation: instead of using existing read
     * and write methods, much of code is inlined. Reason for this is
     * that we must avoid root value wrapping/unwrapping both for efficiency and
     * for correctness. If root value wrapping/unwrapping is actually desired,
     * caller must use explicit <code>writeValue</code> and
     * <code>readValue</code> methods.
     */",4347-4395,"('_convert', {'INSTRUCTION': {'covered': 81, 'missed': 7}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 19, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",232.0,19.0,"Actual conversion implementation: instead of using existing read  and write methods, much of code is inlined.",Actual conversion implementation: Much of the code is inlined rather than using the read and write methods that are already in place. This is necessary to prevent root value wrapping and unwrapping for both performance and correctness. Caller must utilize explicit writeValue and readValue methods if root value wrapping or unwrapping is genuinely desired. ,The actual conversion implementation is inlined.,0.334738157034902,"Actual conversion implementation: Instead of using existing read and write methods, much of the code is integrated.",Not Valid,Not Valid,"protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException{
        // First: serialize to JSON
        ByteArrayOutputStream out = new ByteArrayOutputStream(256);
        JsonGenerator gen = _generatorFactory.createGenerator(out);
        try {
            gen.writeObject(fromValue);
        } catch (IOException e) {
            throw new IllegalArgumentException(""Failed to serialize value of type "" + fromValue.getClass().getName(), e);
        } finally {
            gen.close();
        }
        // Then: deserialize from JSON
        JsonParser p = _parserFactory.createParser(out.toByteArray());
        try {
            return _readValue(p, toValueType);
        } catch (IOException e) {
            throw new IllegalArgumentException(""Failed to deserialize JSON data"", e);
        } finally {
            p.close();
        }
    }","protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException{
        // First: serialize to JSON
        ByteArrayOutputStream out = new ByteArrayOutputStream(512);
        JsonGenerator gen = _createGenerator(out, null);
        try {
            gen.writeObject(fromValue);
        } catch (IOException e) {
            throw new IllegalArgumentException(""Failed to serialize value of type "" + fromValue.getClass().getName(), e);
        } finally {
            gen.close();
        }
        // Then: deserialize from JSON
        JsonParser p = _createParser(new ByteArrayInputStream(out.toByteArray()));
        try {
            return _readValue(p, toValueType);
        } catch (IOException e) {
            throw new IllegalArgumentException(""Failed to deserialize value of type "" + toValueType.getRawClass().getName(), e);
        } finally {
            p.close();
        }
    }",Not Valid,Not Valid,NOT PASS,NOT PASS,None,None,  0.2580700891810714,  0.24884277120714793,None,None,None,None,163.0,0.6995708154506438,166.0,0.7124463519313304,None,None,140.0,0.9929078014184397,128.0,0.9922480620155039,45.0,0.8181818181818182,3.0,0.16666666666666666,14.0,0.8235294117647058
983,cdk,"private static boolean validCorrelation(IMolecularFormula formulaMin, IMolecularFormula formulamax){
    for (IElement element : MolecularFormulaManipulator.elements(formulaMin)) {
        if (!MolecularFormulaManipulator.containsElement(formulamax, element))
            return false;
    }
    return true;
}",validCorrelation,org/openscience/cdk/tools/manipulator/MolecularFormulaSetManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaSetManipulator.java,"/**
     * In the minimal IMolecularFormula must contain all those IElement found in the
     * minimal IMolecularFormula.
     *
     * @param formulaMax  A IMolecularFormula which contains the maximal representation of the Elements
     * @param formulaMin  A IMolecularFormula which contains the minimal representation of the Elements
     * @return            True, if the correlation is valid
     */",150-164,"('validCorrelation', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,15.0,In the minimal IMolecularFormula must contain all those IElement found in the  minimal IMolecularFormula.,All the IElements contained in the minimal IMolecularFormula must be present in the minimal IMolecularFormula. ,The minimal IMolecularFormula must contain all the I Elements.,0.363023957882471,In the minimum IMolecularFormula must contain all the IElement found in the minimum IMolecularFormula.," private static boolean validCorrelation(IMolecularFormula formulaMin, IMolecularFormula formulamax){
        for (IElement element : MolecularFormulaManipulator.elements(formulaMin)) {
            int occurMin = MolecularFormulaManipulator.getElementCount(formulaMin, element);
            int occurMax = MolecularFormulaManipulator.getElementCount(formulamax, element);
            if (occurMin > occurMax) return false;
        }
        return true;        
 }"," private static boolean validCorrelation(IMolecularFormula formulaMin, IMolecularFormula formulamax){
        for (IElement element : MolecularFormulaManipulator.elements(formulaMin)) {
            if (!MolecularFormulaManipulator.containsElement(formulamax, element)) return false;
        }
        return true;        
 }"," private static boolean validCorrelation(IMolecularFormula formulaMin, IMolecularFormula formulamax){
        for (IElement element : MolecularFormulaManipulator.elements(formulaMin)) {
            if (!MolecularFormulaManipulator.containsElement(formulamax, element)) return false;
        }
        return true;
    }"," private static boolean validCorrelation(IMolecularFormula formulaMin, IMolecularFormula formulamax){
        for (IElement element : MolecularFormulaManipulator.elements(formulaMin)) {
            if (!MolecularFormulaManipulator.containsElement(formulamax, element)) return false;
        }
        return true;
    }",NOT PASS,PASS,PASS,PASS,  0.7634345784137109,  1.0,  1.0,  1.0,21.0,0.328125,0.0,0.0,0.0,0.0,0.0,0.0,21.0,0.328125,21.0,0.328125,21.0,0.328125,10.0,0.625,3.0,0.2,8.0,0.5333333333333333
984,acs-aem-commons," EnumMap<ReportColumns, Object> report(WorkflowRemovalStatus status){
    final EnumMap<ReportColumns, Object> row = new EnumMap<>(ReportColumns.class);
    row.put(ReportColumns.STARTED, status.getStartedAt());
    row.put(ReportColumns.CHECKED, status.getChecked());
    row.put(ReportColumns.REMOVED, status.getRemoved());
    row.put(ReportColumns.COMPLETED, status.getCompletedAt());
    row.put(ReportColumns.ERRED, status.getErredAt());
    row.put(ReportColumns.INITIATED_BY, status.getInitiatedBy());
    return row;
}",report,com/adobe/acs/commons/mcp/impl/processes/WorkflowRemover.java,/bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/WorkflowRemover.java,"/**
     * Collect and return a report row for the workflow status.  Method is package scope for unit tests.
     * @param status the status to report upon.
     * @return the row of data
     */",145-162,"('report', {'INSTRUCTION': {'covered': 45, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",125.0,11.0,Collect and return a report row for the workflow status.,Create and provide a report row that details the workflow state. This method is package scope because of unit tests. ,Return a report row for the status of the workflow.,0.243243600869384,Collect and return a report row for the status of the workflow.,"  EnumMap<ReportColumns, Object> report(WorkflowRemovalStatus status){
        EnumMap<ReportColumns, Object> reportRow = new EnumMap<>(ReportColumns.class);
        reportRow.put(ReportColumns.STATUS, status.getStatus());
        reportRow.put(ReportColumns.TOTAL_WORKFLOWS, status.getTotalWorkflows());
        reportRow.put(ReportColumns.REMOVED_WORKFLOWS, status.getRemovedWorkflows());
        reportRow.put(ReportColumns.REMOVED_WORKFLOWS_PERCENT, status.getRemovedWorkflowsPercent());
        reportRow.put(ReportColumns.TOTAL_WORKFLOW_INSTANCES, status.getTotalWorkflowInstances());
        reportRow.put(ReportColumns.REMOVED_WORKFLOW_INSTANCES, status.getRemovedWorkflowInstances());
        reportRow.put(ReportColumns.REMOVED_WORKFLOW_INSTANCES_PERCENT, status.getRemovedWorkflowInstancesPercent());
        reportRow.put(ReportColumns.TOTAL_WORKFLOW_INSTANCE_NODES, status.getTotalWorkflowInstanceNodes());
        reportRow.put(ReportColumns.REMOVED_WORKFLOW_INSTANCE_NODES, status.getRemovedWorkflowInstanceNodes());
        reportRow.put(ReportColumns.REMOVED_WORKFLOW_INSTANCE_NODES_PERCENT, status.getRemovedWorkflowInstanceNodesPercent());
        reportRow.put(ReportColumns.TOTAL_WORKFLOW_INSTANCE_NODE_PROPERTIES, status.getTotalWorkflowInstanceNodeProperties());
        reportRow.put(ReportColumns.REMOVED_WORKFLOW_INSTANCE_NODE_PROPERTIES, status.getRemovedWorkflowInstanceNodeProperties());
        reportRow.put(ReportColumns.REMOVED_WORKFLOW_INSTANCE_NODE_PROPERTIES_PERCENT, status.getRemovedWorkflowInstanceNodePropertiesPercent());
        reportRow.put(ReportColumns.TOTAL_WORKFLOW_INSTANCE_NODE_PROPERTY_VALUES, status.getTotalWorkflow       
  }","  EnumMap<ReportColumns, Object> report(WorkflowRemovalStatus status){
        EnumMap<ReportColumns, Object> reportRow = new EnumMap<>(ReportColumns.class);
        reportRow.put(ReportColumns.STATUS, status.name());
        reportRow.put(ReportColumns.TOTAL_WORKFLOWS, status.getTotalWorkflows());
        reportRow.put(ReportColumns.REMOVED_WORKFLOWS, status.getRemovedWorkflows());
        reportRow.put(ReportColumns.REMOVED_WORKFLOWS_PERCENT, status.getRemovedWorkflowsPercent());
        reportRow.put(ReportColumns.TOTAL_WORKFLOW_INSTANCES, status.getTotalWorkflowInstances());
        reportRow.put(ReportColumns.REMOVED_WORKFLOW_INSTANCES, status.getRemovedWorkflowInstances());
        reportRow.put(ReportColumns.REMOVED_WORKFLOW_INSTANCES_PERCENT, status.getRemovedWorkflowInstancesPercent());
        reportRow.put(ReportColumns.TOTAL_WORKFLOW_INSTANCES_REMOVED, status.getTotalWorkflowInstancesRemoved());
        reportRow.put(ReportColumns.TOTAL_WORKFLOW_INSTANCES_NOT_REMOVED, status.getTotalWorkflowInstancesNotRemoved());
        reportRow.put(ReportColumns.TOTAL_WORKFLOW_INSTANCES_NOT_REMOVED_PERCENT, status.getTotalWorkflowInstancesNotRemovedPercent());
        reportRow.put(ReportColumns.TOTAL_WORKFLOW_INSTANCES_NOT_REMOVED_PERCENT, status.getTotalWorkflowInstancesNotRemovedPercent());
        reportRow.put(ReportColumns.TOTAL_WORKFLOW_INSTANCES_NOT_REMOVED_PERCENT, status.getTotalWorkflowInstancesNotRemovedPercent());
        reportRow.put(ReportColumns.TOTAL_WORKFLOW_INSTANCES_NOT_REMOVED_PERCENT, status.getTotalWorkflowInstancesNotRemovedPercent());
        reportRow.put(ReportColumns.TOTAL_WORKFLOW_INSTANCES_NOT_REMOVED_       
  }","  EnumMap<ReportColumns, Object> report(WorkflowRemovalStatus status){
        EnumMap<ReportColumns, Object> reportRow = new EnumMap<>(ReportColumns.class);
        reportRow.put(ReportColumns.STATUS, status.getStatus());
        reportRow.put(ReportColumns.TOTAL_WORKFLOWS, status.getTotalWorkflows());
        reportRow.put(ReportColumns.REMOVED_WORKFLOWS, status.getRemovedWorkflows());
        reportRow.put(ReportColumns.REMOVED_WORKFLOWS_BY_MODEL, status.getRemovedWorkflowsByModel());
        reportRow.put(ReportColumns.REMOVED_WORKFLOWS_BY_STATUS, status.getRemovedWorkflowsByStatus());
        reportRow.put(ReportColumns.REMOVED_WORKFLOWS_BY_PAYLOAD, status.getRemovedWorkflowsByPayload());
        reportRow.put(ReportColumns.REMOVED_WORKFLOWS_BY_DATE, status.getRemovedWorkflowsByDate());
        reportRow.put(ReportColumns.REMOVED_WORKFLOWS_BY_DURATION, status.getRemovedWorkflowsByDuration());
        return reportRow;
    }","  EnumMap<ReportColumns, Object> report(WorkflowRemovalStatus status){
        EnumMap<ReportColumns, Object> reportRow = new EnumMap<>(ReportColumns.class);
        reportRow.put(ReportColumns.STATUS, status.getStatus());
        reportRow.put(ReportColumns.WORKFLOWS_REMOVED, status.getWorkflowsRemoved());
        reportRow.put(ReportColumns.WORKFLOWS_FAILED, status.getWorkflowsFailed());
        reportRow.put(ReportColumns.WORKFLOWS_SKIPPED, status.getWorkflowsSkipped());
        reportRow.put(ReportColumns.WORKFLOWS_TOTAL, status.getWorkflowsTotal());
        reportRow.put(ReportColumns.WORKFLOWS_REMOVED_BY_MODEL, status.getWorkflowsRemovedByModel());
        reportRow.put(ReportColumns.WORKFLOWS_FAILED_BY_MODEL, status.getWorkflowsFailedByModel());
        reportRow.put(ReportColumns.WORKFLOWS_SKIPPED_BY_MODEL, status.getWorkflowsSkippedByModel());
        reportRow.put(ReportColumns.WORKFLOWS_TOTAL_BY_MODEL, status.getWorkflowsTotalByModel());
        return reportRow;       
  }",Syntax Error,Syntax Error,NOT PASS,NOT PASS,None,None,  0.7168243710615154,  0.7266372027294501,None,None,None,None,66.0,0.38823529411764707,51.0,0.32903225806451614,None,None,85.0,0.35714285714285715,94.0,0.3949579831932773,14.0,0.6666666666666666,4.0,0.3076923076923077,7.0,0.6363636363636364
985,jooby,"public static Config defaults(){
    Path tmpdir = Paths.get(System.getProperty(""user.dir""), ""tmp"");
    Map<String, String> defaultMap = new HashMap<>();
    defaultMap.put(""application.tmpdir"", tmpdir.toString());
    defaultMap.put(""application.charset"", ""UTF-8"");
    String pid = pid();
    if (pid != null) {
        System.setProperty(""PID"", pid);
        defaultMap.put(""pid"", pid);
    }
    return ConfigFactory.parseMap(defaultMap, ""defaults"");
}",defaults,io/jooby/Environment.java,/jooby/src/main/java/io/jooby/Environment.java,"/**
   * Creates a default configuration properties with some common values like: application.tmpdir,
   * application.charset and pid (process ID).
   *
   * @return A configuration object.
   */",377-395,"('defaults', {'INSTRUCTION': {'covered': 42, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,13.0,Creates a default configuration properties with some common values like: application.,"A default configuration property is created with several widely used values, such as application.tmpdir, application.charset, and pid (process ID). ",The default configuration properties are: application.,0.657112375791891,Creates default configuration properties with common values such as: application.," public static Config defaults(){
    return ConfigFactory.parseResources(""application.conf"");
  }","public static Config defaults(){
    return ConfigFactory.empty()
        .withValue(""application.tmpdir"", ConfigValueFactory.fromAnyRef(System.getProperty(""java.io.tmpdir"")))
        .withValue(""application.charset"", ConfigValueFactory.fromAnyRef(Charset.defaultCharset().name()))
        .withValue(""pid"", ConfigValueFactory.fromAnyRef(ManagementFactory.getRuntimeMXBean().getName().split(""@"")[0]))
        .withValue(""application.name"", ConfigValueFactory.fromAnyRef(System.getProperty(""sun.java.command"")))
        .withValue(""application.version"", ConfigValueFactory.fromAnyRef(System.getProperty(""sun.java.command"")))
        .withValue(""application.home"", ConfigValueFactory.fromAnyRef(System.getProperty(""user.dir"")))
        .withValue(""application.classpath"", ConfigValueFactory.fromAnyRef(System.getProperty(""java.class.path"")))
        .withValue(""application.pid"", ConfigValueFactory.fromAnyRef(ManagementFactory.getRuntimeMXBean().getName().split(""@"")[0]))
        .withValue(""application.version"", ConfigValueFactory.fromAnyRef(System.getProperty(""sun.java.command"")))
        .withValue(""application.name"", ConfigValueFactory.fromAnyRef(System.getProperty(""sun.java.command"")))
        .withValue(""application.home"", ConfigValueFactory.fromAnyRef(System.getProperty(""user.dir"")))
        .withValue(""application.classpath"", ConfigValueFactory.fromAnyRef(System.getProperty(""java.class.path"")))
        .withValue(""application.pid"", ConfigValueFactory.fromAnyRef(ManagementFactory.getRuntimeMXBean().getName().split(""@"")[0]))
        .withValue(""application.version"", ConfigValueFactory.fromAnyRef(System.getProperty(""sun.java.command"")))
        .withValue(""application.name"", ConfigValueFactory.fromAnyRef(System.getProperty(""sun.java.command"")))
        .withValue(""application.home"", ConfigValueFactory.fromAnyRef(   
 }"," public static Config defaults(){
    return ConfigFactory.parseResourcesAnySyntax(
        ""application.conf"",
        ConfigParseOptions.defaults().setOriginDescription(""defaults""));
  }"," public static Config defaults(){
    return ConfigFactory.parseResources(Environment.class, ""application.conf"");
  }",NOT PASS,Syntax Error,NOT PASS,NOT PASS,  0.05993010230959141,None,  0.05051456959373758,  0.10664687245176586,91.0,0.8584905660377359,None,None,91.0,0.8584905660377359,86.0,0.8113207547169812,None,None,4.0,0.19047619047619047,12.0,0.42857142857142855,17.0,0.85,4.0,0.3333333333333333,7.0,0.5833333333333334
986,cdk,"private IRingSet removeExtraRings(IAtomContainer m) throws Exception{
    IRingSet rs = Cycles.sssr(m).toRingSet();
    Iterator<IAtomContainer> i = rs.atomContainers().iterator();
    while (i.hasNext()) {
        IRing r = (IRing) i.next();
        if (r.getAtomCount() > 8) {
            i.remove();
        } else {
            for (IAtom a : r.atoms()) {
                Hybridization h = a.getHybridization();
                if (h == CDKConstants.UNSET || !(h == Hybridization.SP2 || h == Hybridization.PLANAR3)) {
                    i.remove();
                    break;
                }
            }
        }
    }
    return rs;
}",removeExtraRings,org/openscience/cdk/smiles/FixBondOrdersTool.java,/legacy/src/main/java/org/openscience/cdk/smiles/FixBondOrdersTool.java,"/**
     * Removes rings which do not have all sp2/planar3 aromatic atoms.
     * and also gets rid of rings that have more than 8 atoms in them.
     *
     * @param m The {@link IAtomContainer} from which we want to remove rings
     * @return The set of reduced rings
     */",233-261,"('removeExtraRings', {'INSTRUCTION': {'covered': 49, 'missed': 3}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 13, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",142.0,11.0,Removes rings which do not have all sp2/planar3 aromatic atoms.,Removes rings with more than 8 atoms as well as rings that don't include all sp2/planar3 aromatic atoms.,The rings do not have all the aromatic atoms.,0.530830392353091,Removes rings that do not have all the aromatic atoms sp2/planar3.,"private IRingSet removeExtraRings(IAtomContainer m) throws Exception{
        IRingSet ringSet = null;
        try {
            ringSet = (IRingSet) new SSSRFinder(m).findAllRings();
        } catch (Exception x) {
            throw x;
        } catch (Exception x) {
            throw new CDKException(""failure in SSSRFinder.findAllRings"", x);
        }
        if (ringSet == null) {
            throw new CDKException(""failure in SSSRFinder.findAllRings"");
        }
        List<IRing> rings = ringSet.toList();
        List<IRing> ringsToRemove = new ArrayList<IRing>();
        for (int i = 0; i < rings.size(); i++) {
            IRing ring = rings.get(i);
            if (ring.getFlag(CDKConstants.ISAROMATIC)) {
                if (!isAromaticRing(ring)) {
                    ringsToRemove.add(ring);
                }
            }
        }
        for (int i = 0; i < ringsToRemove.size(); i++) {
            ringSet.remove(ringsToRemove.get(i));
        }
        return ringSet;     
 }","private IRingSet removeExtraRings(IAtomContainer m) throws Exception{
        IRingSet ringSet = null;
        try {
            ringSet = (IRingSet) new SSSRFinder(m).findAllRings();
        } catch (Exception e) {
            throw new Exception(""Failed to find rings"");
        }
    
        if (ringSet == null) {
            throw new Exception(""Failed to find rings"");
        }
    
        List<IRing> rings = ringSet.toList();
        List<IRing> ringsToRemove = new ArrayList<IRing>();
        for (IRing ring : rings) {
            if (ring.getAtomCount() > 8) {
                ringsToRemove.add(ring);
            } else {
                boolean allAromatic = true;
                for (IAtom atom : ring.atoms()) {
                    if (!atom.getFlag(CDKConstants.ISAROMATIC)) {
                        allAromatic = false;
                        break;
                    }
                }
                if (!allAromatic) {
                    ringsToRemove.add(ring);
                }
            }
        }
        for (IRing ring : ringsToRemove) {
            ringSet.remove(ring);
        }
        return ringSet;     
 }"," private IRingSet removeExtraRings(IAtomContainer m) throws Exception{
        IRingSet ringSet = null;
        try {
            ringSet = (IRingSet) new SSSRFinder(m).findAllRings();
        } catch (Exception x) {
            throw x;
        } catch (Exception x) {
            throw new CDKException(""failure in SSSRFinder.findAllRings"", x);
        }
        if (ringSet == null) {
            throw new CDKException(""failure in SSSRFinder.findAllRings"");
        }
        return ringSet;     
 }",Not Valid,NOT PASS,NOT PASS,Not Valid,NOT PASS,  0.35392549969267245,  0.4015294473563622,None,  0.1904203049936079,134.0,0.6802030456852792,119.0,0.6197916666666666,None,None,100.0,0.6993006993006993,85.0,0.43147208121827413,None,None,118.0,0.5989847715736041,12.0,0.631578947368421,4.0,0.3333333333333333,3.0,0.2727272727272727
